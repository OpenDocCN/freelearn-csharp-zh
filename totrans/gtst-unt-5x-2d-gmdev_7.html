<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Trading Cupcakes and the Ultimate Battle for the Cake – Gameplay Programming</h1></div></div></div><p>After going through different parts of the Unity engine, it's time to come back to our game and finish it up. In doing this, we will explore another big topic: <strong>gameplay programming</strong>. In particular, we will see how data can be exchanged between different parts of a game. Since in our tower defense game there are still many parts to connect, and they can be implemented in thousands of different ways, I tried to choose different techniques in order to give you a different perspective on how things can be implemented within Unity.</p><p>Specifically, in this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem">How to implement a trading system to allow the player to buy, sell, and upgrade cupcake towers</li><li class="listitem">Scripting how the player can place cupcake towers on the map once they are bought</li><li class="listitem">How game over conditions can be triggered to display a winning or losing screen</li><li class="listitem">Keeping track of the progress made by the player during the level</li><li class="listitem">Creating a spawn system for our Pandas, based on dividing the Pandas into waves</li><li class="listitem">Designing and implementing a main menu</li><li class="listitem">How to change a scene in Unity</li></ul></div><p>As always, at the end of the chapter you can find the <em>Homework</em> section, which is full of exercises for you to bring your skills to a higher level. Some of these exercises will challenge you about the concepts learnt in the chapter, and they will guide you in improving our tower defense game.</p><p>But before we go straight into gameplay programming for our game, let's spend some time learning about gameplay programming in general.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec79"/>Getting ready</h1></div></div></div><p>To better understand this chapter, you should have followed all of the other chapters, since we are going to implement our scripts here on top of the ones we have previously created throughout the book.</p><p>For simplicity, for those readers who only did the first implementation in the previous chapter, I have kept the code of the first implementation. However, for those who did the second implementation, you shouldn't have a problem doing the same modifications to the code. In any case, it's recommended that you have the second implementation of the code in the game, because the next chapter will give us some ways to exploit its potential in the context of a larger game.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec80"/>What does gameplay programming mean?</h1></div></div></div><p>There is not a unique definition for gameplay programming. Of course, it deals with building and developing the game, but for instance, does it include programming artificial intelligence? Or UIs? Or database connections? Or animation machines? Therefore, the definition depends on the context. However, it is interesting to note how the definition changes again, when you seek a job position. As a rule of thumb, based only on experience, the bigger and larger the company is, the better the gameplay programmer job position will be. In fact, in small companies, teams can be resource limited and therefore having a gameplay programmer means that he/she will do everything, whereas in larger teams where there are AI, UI, and animation programmers, the gameplay programmer is likely to be more a coordinator of all such roles, and therefore it is a higher position.</p><p>I would like to close this section with a quote from a blog of a game developer (Ask a Game Dev at <a class="ulink" href="http://askagamedev.tumblr.com/post/72792621882/roles-in-the-industry-the-gameplay-programmer">http://askagamedev.tumblr.com/post/72792621882/roles-in-the-industry-the-gameplay-programmer</a>), who describes what it feels like to be a gameplay programmer:</p><div><blockquote class="blockquote"><p><em>"As you can see, being a gameplay programmer is about solving problems even moreso than the designer - you have to really figure out all of the bits of the problem and solve them all. But you also have much more in-depth knowledge of how the entire system works. You get to create those systems. You get to be the first to see something awesome happen."</em></p></blockquote></div><p>Now, it's time to go into the specifics and get our tower defense game done!</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec81"/>Planning what is left to implement for our game</h1></div></div></div><p>The first thing to do before we complete our game is to reorganize the ideas after having written down what we have done so far.</p><p>In <a class="link" title="Chapter 1. A Flat World in Unity" href="part0016.xhtml#aid-F8901">Chapter 1</a>, <em>A Flat World in Unity</em>, we imported all the Sprites and set them up properly. Then, in <a class="link" title="Chapter 2. Baking Cupcake Towers" href="part0028.xhtml#aid-QMFO1">Chapter 2</a>, <em>Baking Cupcake Towers</em>, we implemented the Projectile and Cupcake tower classes. In <a class="link" title="Chapter 3. Communicating with the Player – the User Interface" href="part0043.xhtml#aid-190861">Chapter 3</a>, <em>Communicating with the Player – the User Interface</em>, we implemented the health and the sugar of the player, whereas in <a class="link" title="Chapter 4. No Longer Alone – Sweet-Toothed Pandas Strike" href="part0056.xhtml#aid-1LCVG1">Chapter 4</a>, <em>No Longer Alone – Sweet-Toothed Pandas Strike</em>, we focused on animating our sweet-toothed Panda. Finally, in <a class="link" title="Chapter 5. The Secret Ingredient Is a Dash of Physics" href="part0062.xhtml#aid-1R42S1">Chapter 5</a>, <em>The Secret Ingredient Is a Dash of Physics</em>, we explored physics and how we can use it within our game, and in <a class="link" title="Chapter 6. Through a Sea of Sprinkles – Navigation in Artificial Intelligence" href="part0077.xhtml#aid-29DRA1">Chapter 6</a>, <em>Through a Sea of Sprinkles – Navigation in Artificial Intelligence</em>, we gave the Pandas the possibility of moving along the path towards the sweet cake.</p><p>So, what's left to do is the following:</p><div><ul class="itemizedlist"><li class="listitem">Integrate a trading system so the player can buy, sell, and upgrade cupcake towers</li><li class="listitem">Create a mechanism to place the cupcake towers once they have been bought</li><li class="listitem">Specify how the player can select a specific cupcake tower</li><li class="listitem">Set up game over conditions.</li><li class="listitem">Keeping track of the progress of the player during gameplay</li><li class="listitem">Implement a spawning system for our Pandas</li><li class="listitem">Create a main menu for our game</li></ul></div><p>After we have done all of this, we will basically have a functioning game. So, let's get started with the first on the list.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec82"/>Trading cupcake towers</h1></div></div></div><p>In this section, we will see how to allow the player to trade towers. In particular, the player can either buy, sell, or upgrade a cupcake tower. Since these three actions have something in common, we will implement them by using <strong>inheritance</strong>. If you remember, we talked a bit about it in <a class="link" title="Chapter 2. Baking Cupcake Towers" href="part0028.xhtml#aid-QMFO1">Chapter 2</a>, <em>Baking Cupcake Towers</em>, but now we have the possibility of seeing it in action. As a result, along the way we will have a better understanding of abstract methods and static variables, since we will use them again.</p><p>In any case, each one of these trading actions that the player can perform are implemented separately. This is the structure we will implement:</p><div><img src="img/image00594.jpeg" alt="Trading cupcake towers"/></div><p style="clear:both; height: 1em;"> </p><p>Each of the child scripts can be attached to a UI element, and that will be transformed into a button to perform that specific action. Let's start with the parent class.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec88"/>The trading parent class</h2></div></div></div><p>Let's start to create a general class named <code class="literal">TradeCupcakeTower</code>, and open it with your favorite code editor.</p><p>Buying, selling, and upgrading require the user to click on their icon in the user interface (we will create the UI in the scene for the trading actions after we have scripted the whole trading system first), and so we need to provide a way to detect the click (or the tap in case of a mobile application) of the player. As we have talked about it in <a class="link" title="Chapter 3. Communicating with the Player – the User Interface" href="part0043.xhtml#aid-190861">Chapter 3</a>, <em>Communicating with the Player – the User Interface</em>, we can use a handler. Thus, we need to add the following library at the beginning of our script:</p><pre class="programlisting">using UnityEngine.EventSystems; &#13;
</pre><p>Now, in the definition of the class, we can add the click handler. Moreover, since this will be an abstract class, we need to specify it in the following way:</p><pre class="programlisting">public abstract class TradeCupcakeTowers : MonoBehaviour,&#13;
  IPointerClickHandler { &#13;
</pre><p>When trading, we want to check the player's sugar level (which is the currency of our game). As a result, we need to have a reference to the Sugar Meter, which is also shared among all the trading classes. Thus, we can make the variable protected and static:</p><pre class="programlisting">
<em>// Variable to store the Sugar Meter</em> &#13;
protected static SugarMeterScript sugarMeter; &#13;
</pre><p>Similar to what we did in the last chapter when we had to get the reference to the game manager for all the Pandas (since also, in that case the variable was static), we need to get the reference to the Sugar Meter only once. As such, in the <code class="literal">Start()</code> function we can write:</p><pre class="programlisting">void Start () { &#13;
  <em>//If the reference to the Sugar Meter is missing, the script gets it</em> &#13;
  if (sugarMeter == null) { &#13;
    sugarMeter = FindObjectOfType&lt;SugarMeterScript&gt;(); &#13;
  }      &#13;
} &#13;
</pre><p>When the player sells or upgrades a tower, the trading system should know which tower the player is referring to (how the player selects a tower is left for later in <em>Selecting the towers</em> section). Therefore, again we can use a protected and static variable shared across all the trading operation classes:</p><pre class="programlisting">
<em>//Variable to store the current selected tower by the player</em> &#13;
protected static CupcakeTowerScript currentActiveTower; &#13;
</pre><p>Then, we need a function to set the selection (the current active tower), and it needs to be static, so it can be easily set by other scripts (as we will see later). The function just assigns the tower passed as a parameter to the static variable:</p><pre class="programlisting">
<em>// Static function that allows other scripts to assign the new/current&#13;
  selected tower</em> &#13;
public static void setActiveTower(CupcakeTowerScript cupcakeTower) { &#13;
  currentActiveTower = cupcakeTower; &#13;
} &#13;
</pre><p>Finally, we need to implement the interface for handling the click. However, the sequence of actions that should be performed depends on if the player is either buying, selling, or upgrading. Therefore, we can leave the implementation to the child classes, and leave this as an abstract function (refer to <a class="link" title="Chapter 2. Baking Cupcake Towers" href="part0028.xhtml#aid-QMFO1">Chapter 2</a>, <em>Baking Cupcake Towers</em>, on how abstract and virtual methods work) as shown here:</p><pre class="programlisting">
<em>// Abstract function triggered when one of the trading buttons is&#13;
  pressed, however the &#13;
// implementation is specific for each trade operation.</em> &#13;
public abstract void OnPointerClick(PointerEventData eventData); &#13;
</pre><p>We can save the script, and as a result our parent class is ready. Now, before we implement its children for specific trading actions that the player can perform, we need to modify the <code class="literal">CupcakeTowerScript</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec89"/>Modifying the CupcakeTowerScript</h2></div></div></div><p>Back in <a class="link" title="Chapter 2. Baking Cupcake Towers" href="part0028.xhtml#aid-QMFO1">Chapter 2</a>, <em>Baking Cupcake Towers</em>, we implemented many functionalities for our cupcake towers. However, there is more work to do on their script. In particular, we need to add some variables to store their prices and costs.</p><p>Let's start by adding the following self-explanatory variables, which we may want to set into the <strong>Inspector</strong> later:</p><pre class="programlisting">
<em>// How much this tower costs when it is bought    </em> &#13;
public int initialCost; &#13;
 &#13;
<em>// How much this tower costs when it is upgraded</em> &#13;
public int upgradingCost; &#13;
 &#13;
<em>// How much this tower is valuable if sold</em> &#13;
public int sellingValue; &#13;
</pre><p>Every time we upgrade the cupcake tower, we want to raise both the <code class="literal">sellingValue,</code> because an upgraded tower is more valuable, and the <code class="literal">UpgradingCost</code>, because upgrading to higher levels requires more sugar. So, we can add the following lines of code in the <code class="literal">Upgrade()</code> function (the values may depend on your very specific balance of the game, but the next chapter will go into more detail on this and how to handle costs of towers in a dynamic way):</p><pre class="programlisting">
<em>//Increase the value of the tower;</em> &#13;
sellingValue += 5; &#13;
 &#13;
//Increase the upgrading cost &#13;
upgradingCost += 10; &#13;
</pre><p>Save the script, and go into your cupcake tower prefabs and change the values of these three, new variables in the <strong>Inspector</strong> (again, feel free to use the values you prefer). Here is an example:</p><div><img src="img/image00595.jpeg" alt="Modifying the CupcakeTowerScript"/></div><p style="clear:both; height: 1em;"> </p><p>Now, we are ready to implement the trading actions, starting with buying.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec90"/>Buying cupcake towers</h2></div></div></div><p>In this section, we will implement the script that handles the buying action. Let's start by creating a new script and name it TradeCupcakeTowers_Buying and open it.</p><p>First of all, we still need to import the event systems library from the Unity engine:</p><pre class="programlisting">using UnityEngine.EventSystems; &#13;
</pre><p>In the class declaration, we need to specify that we are going to extend the <code class="literal">TradeCupcakeTowers</code> class, instead of <code class="literal">MonoBehaviour</code>, in the following way:</p><pre class="programlisting">public class TradeCupcakeTowers_Buying : TradeCupcakeTowers { &#13;
</pre><p>If you look at the design of our user interface back in <a class="link" title="Chapter 3. Communicating with the Player – the User Interface" href="part0043.xhtml#aid-190861">Chapter 3</a>, <em>Communicating with the Player – the User Interface</em>, we have three different kinds of towers that the player can buy. Each one of the buttons, once clicked, will instantiate a different tower. Therefore, we need to specify which cupcake tower prefab this instance of the script is referring to. Of course, its values should be set in the <strong>Inspector</strong> (we will see this later). So, let's add the following variable:</p><pre class="programlisting">
<em>/* Public variable to identify which tower this script is selling. &#13;
 * Ideally, you could have many instances of this script selling&#13;
   different &#13;
 * Cupcake towers, and the tower is specified in the Inspector */</em> &#13;
public GameObject cupcakeTowerPrefab; &#13;
</pre><p>Then, we need to implement the abstract function inherited from its parent, to handle what happens when the player clicks on its icon. As such, we need to use the <code class="literal">override</code> property, and declare the method in the following way:</p><pre class="programlisting">public override void OnPointerClick(PointerEventData eventData) { &#13;
 <em> //Rest of the code</em> &#13;
} &#13;
</pre><p>Now, the first thing to do when the player clicks is to retrieve the price of the cupcake tower that the player wants to buy:</p><pre class="programlisting">
<em>//Retrieve from the prefab which is its initial cost</em> &#13;
int price = cupcakeTowerPrefab.GetComponent&lt;CupcakeTowerScript&#13;
  ().initialCost; &#13;
</pre><p>Next, we need to check if the player has enough sugar, by using the shared static variable, <code class="literal">sugarMeter</code>. If the player has enough sugar, then a new cupcake tower is instantiated (we will see how the player places the tower later in the chapter) and it is assigned as the active tower among the trading classes:</p><pre class="programlisting">
<em>// Check if the player can afford to buy the tower</em> &#13;
if (price &lt;= sugarMeter.getSugarAmount()) { &#13;
 <em> //Payment succeeds, and the cost is removed from the player's sugar</em> &#13;
  sugarMeter.ChangeSugar(-price); &#13;
 <em> //A new cupcake tower is created</em> &#13;
  GameObject newTower = Instantiate(cupcakeTowerPrefab); &#13;
 <em> //The new cupcake tower is also assigned as the current selection</em> &#13;
  currentActiveTower = newTower.GetComponent&lt;CupcakeTowerScript&gt;(); &#13;
} &#13;
</pre><p>Save the script, and the buy functionality is implemented. Let's see how the player can sell the cupcake towers to get some sugar back.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec91"/>Selling cupcake towers</h2></div></div></div><p>In this section, we will implement the script that handles the selling action. Create a new script and name it <code class="literal">TradeCupcakeTowers_Selling</code>, then open it.</p><p>Once again, we still need to import the event systems library from the Unity engine:</p><pre class="programlisting">using UnityEngine.EventSystems; &#13;
</pre><p>As we did for the <code class="literal">TradeCupcakeTowers_Buying</code>, we need to inherit from the <code class="literal">TradeCupcakeTowers</code> class in the following way:</p><pre class="programlisting">public class TradeCupcakeTowers_Selling : TradeCupcakeTowers { &#13;
</pre><p>Then, we need to implement the abstract function, to handle what happens when the player clicks on the selling icon. Again, we need to use the <code class="literal">override</code> property, like the following:</p><pre class="programlisting">public override void OnPointerClick(PointerEventData eventData) { &#13;
  <em>//Rest of code</em> &#13;
} &#13;
</pre><p>Since selling is an action that the player is always able to perform, we don't need to do any checks (except if there is an active tower), but rather retrieve the value of the cupcake tower and add that amount to the player's savings. Then, remove the cupcake tower from the scene:</p><pre class="programlisting">
<em>//Check if there is a tower selected before to proceed</em> &#13;
if (currentActiveTower == null) &#13;
  return; &#13;
 &#13;
<em>//Add to the player's sugar the value of the tower</em> &#13;
sugarMeter.ChangeSugar(currentActiveTower.sellingValue); &#13;
<em>//Remove the cupcake tower from the scene</em> &#13;
Destroy(currentActiveTower); &#13;
</pre><p>Finally, we can save the script. As a result, the selling functionality is also implemented. Only the upgrading one is left.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec92"/>Upgrading cupcakes towers</h2></div></div></div><p>Here we get to create the upgrading button. Create a script and name it <code class="literal">TradeCupcakeTowers_Upgrading</code>, then open it.</p><p>Once again, we still need to import the event systems library from the Unity engine:</p><pre class="programlisting">using UnityEngine.EventSystems; &#13;
</pre><p>As we did for the other trading classes, we need to inherit from the <code class="literal">TradeCupcakeTowers</code> class in the following way:</p><pre class="programlisting">public class TradeCupcakeTowers_Upgrading : TradeCupcakeTowers { &#13;
</pre><p>Then, we need to implement the abstract function, to handle what happens when the player clicks on the upgrading button. Once more, we need to use the <code class="literal">override</code> property, like the following:</p><pre class="programlisting">public override void OnPointerClick(PointerEventData eventData) { &#13;
 <em> //Rest of the code</em> &#13;
} &#13;
</pre><p>Similar to what we did with the buying button, we need to check if the player can afford to upgrade the tower, and if the tower is actually upgradable (we had a Boolean flag for that, set back in <a class="link" title="Chapter 2. Baking Cupcake Towers" href="part0028.xhtml#aid-QMFO1">Chapter 2</a>, <em>Baking Cupcake Towers</em>). If so, the cost of the upgrade is subtracted from the player's sugar, and the tower is finally upgraded:</p><pre class="programlisting">
<em>//Check if the player can afford to upgrade the tower</em> &#13;
if(currentActiveTower.isUpgradable &amp;&amp; currentActiveTower.upgradingCost&#13;
  &lt;=sugarMeter.getSugarAmount()) { &#13;
 <em> //The payment is executed and the sugar removed from the player</em> &#13;
  sugarMeter.ChangeSugar(-currentActiveTower.upgradingCost); &#13;
<em>  //The tower is upgraded</em> &#13;
  currentActiveTower.Upgrade(); &#13;
} &#13;
</pre><p>Save this script, and as a result we have completed all the trading functionalities. However, they are not present in the scene, so let's add them to our interface.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec93"/>Adding the trading options to the user interface</h2></div></div></div><p>Now that we have the scripts to implement all the different trading buttons, we need to actually place them within our scene/level.</p><p>Therefore, let's start to create three UI images, and attach to each one of them, the <code class="literal">TradeCupcakeTowers_Buying</code> script. As their <strong>Source Image</strong>, you can select the icons we have in our graphical package for the three different kind of towers we have. In case you didn't implement them all, that's alright, just remove the buttons you don't need. If on the contrary, you have implemented more with your own graphics, feel free to add more of these buttons. Then, after you have properly scaled the buttons, place them within our interface as shown in the following screenshot:</p><div><img src="img/image00596.jpeg" alt="Adding the trading options to the user interface"/></div><p style="clear:both; height: 1em;"> </p><p>Then, in the <strong>Inspector</strong>, we need to assign their respective <strong>Cupcake Tower Prefab</strong>. Here is just one of the three buttons, shown as an example for you:</p><div><img src="img/image00597.jpeg" alt="Adding the trading options to the user interface"/></div><p style="clear:both; height: 1em;"> </p><p>Very well, now the player can buy towers! What about selling and upgrading them?</p><p>Let's create another two UI images, and attach respectively, the <code class="literal">TradeCupcakeTowers_Selling</code> and <code class="literal">TradeCupcakeTowers_Upgrading</code> scripts to them. Then, use the icons for selling and upgrading you can find in our graphical package as <strong>Source Image</strong>. Scale the buttons properly, and place them within our interface as shown in the following screenshot:</p><div><img src="img/image00598.jpeg" alt="Adding the trading options to the user interface"/></div><p style="clear:both; height: 1em;"> </p><p>We don't have any variables to assign in the <strong>Inspector</strong>, so we can consider our trading system ready! Although to make it work properly, we still need to have a way to place our towers and a way to select the towers. These will be explored in the next sections.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec83"/>Placing the towers</h1></div></div></div><p>Once the player has bought a cupcake tower, he or she should be able to decide where to place it. This section will explore how to implement this mechanism, which may be simple, but requires you pay attention to many things.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec94"/>Sketching the idea of how it works</h2></div></div></div><p>There are many ways in which we can implement this system, but we will use colliders and a second script on the cupcake tower. As a result, you will also be able to learn new ways to handle situations in which information should be exchanged among the different game elements.</p><p>In particular, we will define some areas where it is allowed to place a tower, and we will do this through the use of colliders. Then, the game manager registers if the pointer of the player is within allowed areas. A second script, attached to the cupcake towers, uses this information from the game manager to actually allow the player to place cupcake towers. Moreover, once the tower is placed, the script attaches a collider to the cupcake tower. This will prevent a tower from being placed on top of others, and it will also be useful for implementing the selection system.</p><div><h3 class="title"><a id="note101"/>Note</h3><p>In the <em>Homework</em> section, you will find some exercises to improve what we are going to implement in this section.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec95"/>Allowed areas</h2></div></div></div><p>To begin, we should notice that the player is not free to place his towers wherever he wants to on the map. In fact, he cannot place them along the path where the Pandas are moving or in areas where there is water or other obstacles. Therefore, we need to specify this constraint within our game. Thus, we need to look at our map and find all the spots where the player can place the tower. In our case, the spots that we are looking for are the following:</p><div><img src="img/image00599.jpeg" alt="Allowed areas"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see, they have a custom shape. Even if it is possible to implement custom shapes (which is left as an exercise to readers who want to challenge themselves), it can be much more convenient to think in terms of rectangles and thus to split our shapes into rectangles. Of course, this can be done in more than one way; however, the less rectangles that cover the entire area, the better from a computational point of view. On the other hand, by using more rectangles, you are able to better approximate your areas. So find your tradeoff.</p><p>A possible choice could be the following:</p><div><img src="img/image00600.jpeg" alt="Allowed areas"/></div><p style="clear:both; height: 1em;"> </p><p>In the end, we have found 11 areas.</p><p>The idea here is that all these areas are <strong>Box Colliders 2D</strong> attached to the <code class="literal">Game Manager</code> object, which will check if the mouse is within one of these areas or not by toggling a flag. This flag will be read by the script we are going to implement in the next section.</p><p>Let's start by adding a <strong>Box Collider 2D</strong> on the <strong>Game Manager</strong> by clicking on<strong> Component | Physics 2D | Box Collider 2D</strong>. Then, we need to resize it to the same dimensions as one of the rectangles we have found, and by using the offset parameter, place it onto the map. At this stage in the book, you should be able to repeat this operation for all the areas of the map, without having their exact values written down here in the book.</p><p>Now, the next stage is to modify the <code class="literal">GameManagerScript</code> to toggle the flag. Once we have opened the script, we can already add the flag as a Boolean variable:</p><pre class="programlisting">
<em>//Private variable to check if the mouse is hovering an area where&#13;
</em>
<em>//Cupcake tower can be placed</em> &#13;
private bool _isPointerOnAllowedArea = true; &#13;
</pre><p>Since we don't want other scripts to change this variable, it is private, and therefore we need to expose a function to retrieve its value:</p><pre class="programlisting">
<em>//Function that returns true if the mouse is hovering an area where a &#13;
//Cupcake tower can be placed</em> &#13;
public bool isPointerOnAllowedArea() { &#13;
  return _isPointerOnAllowedArea; &#13;
} &#13;
</pre><p>Unity offers us a couple of very handy functions to detect when the pointer of the player enters within an area. Their names are self-explanatory: <code class="literal">OnMouseEnter()</code> and <code class="literal">OnMouseExit()</code>. In the first function, we will set the flag to <code class="literal">true</code>, whereas in the second we will set the flag to <code class="literal">false</code>:</p><pre class="programlisting">
<em>//Function which is called when the mouse enters in one of the &#13;
//colliders of the Game Manager</em> &#13;
void OnMouseEnter() { &#13;
  <em>//Set that the mouse is now hovering an area where placing Cupcake &#13;
  //towers is allowed</em> &#13;
  _isPointerOnAllowedArea = true; &#13;
} &#13;
 &#13;
<em>//Function which is called when the mouse exits from one of the &#13;
//colliders of the Game Manager</em> &#13;
void OnMouseExit() { &#13;
 <em> //Set that the mouse is not hovering anymore an area where placing &#13;
  //Cupcake towers is allowed</em> &#13;
  _isPointerOnAllowedArea = false; &#13;
} &#13;
</pre><p>Save the script, and the setup for the allowed areas is ready.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Scripting the placement script</h2></div></div></div><p>For placing the cupcake towers after having been bought, we need to create another script for our cupcake towers. You can rename it <code class="literal">PlacingCupcakeTowerScript</code>, and add it to the <strong>Cupcake Tower Prefabs</strong>.</p><p>Before modifying it, we need to uncheck the <code class="literal">CupcakeTowerScript</code> from the prefabs of our cupcake towers. In fact, a tower enters in the scene for the first time because the player has bought it. While in placing mode, the cupcake tower should not shoot. Once placed, the <code class="literal">CupcakeTowerScript</code> is enabled, and the tower is operative again.</p><p>Now, we can open the newly-created script. We need to retrieve the <code class="literal">Game Manager</code>, since we will need it to check when the mouse is on an area where cupcake towers can be placed. As such, we can write the following code, which is the same we used in <a class="link" title="Chapter 6. Through a Sea of Sprinkles – Navigation in Artificial Intelligence" href="part0077.xhtml#aid-29DRA1">Chapter 6</a>, <em>Through a Sea of Sprinkles – Navigation in Artificial Intelligence</em>, to retrieve the <code class="literal">Game Manager</code> for the first time:</p><pre class="programlisting">
<em>// Private variable to store the reference to the Game Manager</em> &#13;
private GameManagerScript gameManager; &#13;
 &#13;
void Start () { &#13;
 <em> //Get the reference to the Game Manager</em> &#13;
  gameManager = FindObjectOfType&lt;GameManagerScript&gt;(); &#13;
} &#13;
</pre><p>In the <code class="literal">Update()</code> function we are moving the tower to the mouse location (so at each frame, the tower will move with the mouse of the player), and if the player presses a key, we check if the pointer is actually over an allowed area. If so, the tower is placed, which means that the script that moves the tower is destroyed. Moreover, the <code class="literal">CupcakeTowerScript</code> is enabled again, and a collider is placed on the cupcake tower. In fact, this additional collider prevents the placing of other towers on top of this (and to select the tower in the next section):</p><pre class="programlisting">void Update () { &#13;
  <em>//Get the mouse position</em> &#13;
  float x = Input.mousePosition.x; &#13;
  float y = Input.mousePosition.y; &#13;
 &#13;
  <em>/* Place the cupcake Tower where the mouse is, transformed in game&#13;
    coordinates &#13;
   * from the Main Camera. Since the Camera is placed at -10 and we&#13;
     want the &#13;
   * tower to be at -3, we need to use 7 as z-axis coordinate */</em> &#13;
  transform.position = Camera.main.ScreenToWorldPoint(new Vector3(x,&#13;
     y, 7)); &#13;
 &#13;
  <em>//If the player clicks, the second condition checks if the current&#13;
    position is &#13;
  //within an area where cupcake towers can be placed</em> &#13;
  if (Input.GetMouseButtonDown(0) &amp;&amp;&#13;
    gameManager.isPointerOnAllowedArea()) { &#13;
 <em> //Enabling again the main cupcake tower script, so to make it&#13;
    operative</em> &#13;
  GetComponent&lt;CupcakeTowerScript&gt;().enabled = true; &#13;
 <em> //Place a collider on the Cupcake tower</em> &#13;
  gameObject.AddComponent&lt;BoxCollider2D&gt;(); &#13;
  <em>//Remove this script, so to not keeping the Cupcake Tower on the&#13;
    mouse</em> &#13;
  Destroy(this); &#13;
} &#13;
</pre><p>Save the script, and as a result the player is able to place cupcake towers once they are bought.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec84"/>Selecting the towers</h1></div></div></div><p>If you remember, all the trading operations have a selected tower to deal with. In fact, when the player presses the sell button, the game should know which cupcake tower the player intends to sell. As such, the player should be able to select (and unselect) a tower, and this tower should notify the trading system.</p><p>To achieve this, we need to slightly modify the <code class="literal">CupcakeTowerScript</code>. From the previous section, we know that when the tower is active, it has a collider to prevent placing other towers on top of it as well. But, we can also use this collider to detect if the player clicks on this very specific tower. In particular, we can use the self-explanatory function, <code class="literal">OnMouseDown()</code> in the following way:</p><pre class="programlisting">
<em>//Function called when the player clicks on the cupcake Tower</em> 
void OnMouseDown() { 
 <em> //Assign this tower as the active tower for trading operations</em> 
  TradeCupcakeTowers.setActiveTower(this); 
} 
</pre><p>After saving the script, the player is able to select a specific tower among the ones he or she has in the game, and sell or upgrade it through the trading system.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec85"/>The Game Manager</h1></div></div></div><p>In the previous chapter, we introduced the <code class="literal">GameMangerScript</code>, but even after the second implementation of waypoints, we have left this script empty with no use. However, we do indeed need a game manager in our game to handle a couple of things. So, in case you have erased it from the last chapter, recreate it, along with a game object in the scene with such a script attached (the same way as if you erased the reference from the <code class="literal">PandaScript</code>, because we will need it later on).</p><p>We will use the <code class="literal">Game Manager</code> as a hub for exchanging information between the player's health and the Pandas. In fact, the <code class="literal">Game Manager</code> will spawn Pandas in the scene divided into waves, and it's the only script to be aware of when the level starts and finishes and/or if the player has lost all the health. This makes the Game Manager the perfect candidate to handle and trigger the game over conditions. Let's start with them.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec97"/>Game over conditions</h2></div></div></div><p>When does our game reach an end? Well, there are two cases: when the player loses his/her health, which means the Pandas have eaten all the cake (losing condition), or when the player has shot down all the Pandas (winning condition). In either case, we need to show to the player the outcome and terminate the game.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec68"/>Game over feedback</h3></div></div></div><p>In our graphic package, there are two screens ready for when the game is over. Respectively, these are <em>Game Over</em>, used for the losing condition, and <em>You Win</em>, used for the winning condition.</p><p>Create two UI images, as we learnt in <a class="link" title="Chapter 3. Communicating with the Player – the User Interface" href="part0043.xhtml#aid-190861">Chapter 3</a>, <em>Communicating with the Player – the User Interface</em>, and place the two sprites of our package, one for each UI image. You probably want to press the <strong>Set Native Size</strong> button, and then scale and move them, so that they are in the middle of the scene, as shown here:</p><div><img src="img/image00601.jpeg" alt="Game over feedback"/></div><p style="clear:both; height: 1em;"> </p><p>Now, we can disable them, since they shouldn't be displayed until the game ends. However, we need to add a reference to them in the <code class="literal">Game Manager</code>.</p><p>As such, open the <code class="literal">GameManagerScript</code> and let's add these variables:</p><pre class="programlisting">
<em>//Variable to store the the screen displayed when the player loses</em> &#13;
public GameObject losingScreen; &#13;
 &#13;
<em>//Variable to store the screen displayed when the player wins</em> &#13;
public GameObject winningScreen; &#13;
</pre><p>Save the script, and from the <strong>Inspector</strong> assign the UI images we created previously, as shown here:</p><div><img src="img/image00602.jpeg" alt="Game over feedback"/></div><p style="clear:both; height: 1em;"> </p><p>As a result, the <code class="literal">Game Manager</code> is able to activate one of the two when certain conditions are met. Let's see how to implement a function for that in the next section.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec69"/>The GameOver function</h3></div></div></div><p>To keep things ordered within our <code class="literal">GameManagerScript</code>, let's create a function to trigger what happens when the game ends. It will have a Boolean as a parameter to determine if the player has won or not.</p><div><h3 class="title"><a id="note102"/>Note</h3><p>Of course, what exactly should happen when the game ends is up to you. You can save statistics and the score (if you have any), trigger nice and cool animations, display buttons to load next levels, and so on. In this book, we will just display the UI images created in the previous section, because the goal is to show you where and how to insert code for game over. Feel free to add your own implementation to it.</p></div><p>Therefore, let's write down this function that, based on the parameter, will display the right screen to the player. Then, it stops the time of the game to create a kind of pause situation in the game. As a result, the game won't be running when the game over screen appears (if any UI is present, it will still be possible for the player to press on it):</p><pre class="programlisting">
<em>//Private function called when some gameover conditions are met, and&#13;
  displays&#13;
//the winning or losing screen depending from the value of the&#13;
  parameter passed.</em> &#13;
private void GameOver(bool playerHasWon) { &#13;
  <em>//Check if the player has won from the parameter</em> &#13;
  if (playerHasWon) { &#13;
    <em>//Display the winning screen</em> &#13;
    winningScreen.SetActive(true); &#13;
  }else { &#13;
    <em>//Display the losing screen</em> &#13;
    losingScreen.SetActive(true); &#13;
  } &#13;
 &#13;
  <em>//Freeze the game time, so to stop in some way the level to be&#13;
    executed</em> &#13;
  Time.timeScale = 0; &#13;
} &#13;
</pre><div><h3 class="title"><a id="note103"/>Note</h3><p>You can find out more about <code class="literal">timeScale</code> here in the official documentation for Unity: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Time-timeScale.html">https://docs.unity3d.com/ScriptReference/Time-timeScale.html</a></p></div><p>Save the <code class="literal">GameManagerScript</code>, and let's explore when to trigger this function in the next sections.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec98"/>Keeping track of the game's progress</h2></div></div></div><p>Keeping track of the game's progress is one of the fundamental functions of a Game Manager. So, the first thing we want to ask is: what should we keep track of?</p><p>Definitely not the sugar possessed by the player, since it is separately handled within the Sugar Meter and the trading scripts. What about the player's health? Well, we do indeed want to keep track of it. In fact, when the player loses his/her health, the game ends as well, and the <code class="literal">Game Manager</code> needs to handle this case. What else? The <code class="literal">Game Manager</code> needs to keep track of how many Pandas the player shoots down, because in this way, the game manager is able to determine when the player wins.</p><p>Thus, the first thing we need to do is to get a reference to the health of the player. We can add the following variable:</p><pre class="programlisting">
<em>//Private variable to store the reference to the Player's health</em> &#13;
private HealthBarScript playerHealth; &#13;
</pre><p>We can initialize it in the <code class="literal">Start()</code> function, by adding this line at the beginning:</p><pre class="programlisting">void Start () { &#13;
<em>  //Get the reference to the Player's health</em> &#13;
  playerHealth = FindObjectOfType&lt;HealthBarScript&gt;(); &#13;
} &#13;
</pre><p>Then, we need a variable to keep track of how many Pandas there are still to defeat, hence we can add the following variable:</p><pre class="programlisting">
<em>//Private variable which acts as a counter of how many Pandas are&#13;
  remained to defeat</em> &#13;
private int numberOfPandasToDefeat; &#13;
</pre><p>It will be initialized by our spawning system, which we will implement soon.</p><p>Finally, we need to implement a couple of functions, which will be called, respectively, when a Panda is shot down, and when the player loses his/her health.</p><p>For the first, we don't need any parameters or return values, since the <code class="literal">Game Manager</code> just acknowledges that a Panda has been shot down by decreasing the number of Pandas that still need to be defeated:</p><pre class="programlisting">
<em>//Function that decreases the number of Pandas still to defeat every&#13;
  time a Panda dies </em> &#13;
public void OneMorePandaInHeaven() { &#13;
  numberOfPandasToDefeat--; &#13;
} &#13;
</pre><p>Regarding the second function, we want to create a hub of communication between the Panda that is eating the cake and the player's health. As such, we need to implement a function that takes the damage of the Panda as a parameter and subtract it from the player's health. Then, it checks if the player is still alive, because if he/she is not, the <code class="literal">GameOver</code> function is triggered. In either case, at the end we need to decrease the number of Pandas still to defeat, because we remember that Pandas eat so much cake that they explode:</p><pre class="programlisting">
<em>//Function that damages the player when a Panda reaches the player's&#13;
  cake. &#13;
//Moreover, it monitors the player's health to trigger the GameOver&#13;
  function when needed</em> &#13;
public void BiteTheCake(int damage) { &#13;
 <em> //Apply damage to the player and retrieve a Boolean to see if the&#13;
    cake has been eaten all</em> &#13;
  bool IsCakeAllEaten = playerHealth.ApplyDamage(damage); &#13;
 <em> //If the cake has been eaten all, the GameOver function is called in&#13;
    "losing mode"</em> &#13;
  if (IsCakeAllEaten) { &#13;
    GameOver(false); &#13;
  } &#13;
  <em>//The Panda that bit the cake will also explode, and therefore we&#13;
    have a Panda less to defeat</em> &#13;
  OneMorePandaInHeaven(); &#13;
} &#13;
</pre><p>Save the script, and open the <code class="literal">PandaScript</code> since now we need to slightly modify it. In particular, we need to call the functions just created in the <code class="literal">Game Manager</code>. From <a class="link" title="Chapter 6. Through a Sea of Sprinkles – Navigation in Artificial Intelligence" href="part0077.xhtml#aid-29DRA1">Chapter 6</a>, <em>Through a Sea of Sprinkles – Navigation in Artificial Intelligence</em>, we already have a reference to the <code class="literal">Game Manager</code>, which we can use to trigger these functions.</p><p>The first modification is to add the following variable to determine how much cake this specific Panda can eat when it bites (its value needs to be set in the Inspector, don't forget it!):</p><pre class="programlisting">
<em>//The amount of cake that the Panda eats</em> &#13;
public int cakeEatenPerBite; &#13;
</pre><p>The second modification is in the <code class="literal">FixedUpdate()</code> function. In fact, we need to detract health from the player by using the <code class="literal">BiteTheCake()</code> function in the <code class="literal">Game Manager</code>. The highlighted part is what we have modified:</p><pre class="programlisting">void FixedUpdate() { &#13;
  <em>//if the Panda has reached the cake, then it will eat it, by&#13;
    triggering the right animation, &#13;
  //and remove this script, since the State Machine Behaviour will take&#13;
    care of removing the Panda</em> &#13;
  if (currentWaypointNumber == gameManager.waypoints.Length) { &#13;
    animator.SetTrigger(AnimEatTriggerHash); &#13;
    gameManager.BiteTheCake(cakeEatenPerBite); &#13;
    Destroy(this); &#13;
    return; &#13;
  } &#13;
 <em> // [...] The remaining code of the function</em>
</pre><p>The third and last modification is in the <code class="literal">Hit()</code> function, in which we also need to trigger the <code class="literal">OneMorePandaInHeaven()</code> function of the Game Manager. We can do it in the following way (again the highlighted part is what is changed):</p><pre class="programlisting">private void Hit(float damage) { &#13;
 <em> //Subtract the damage to the health of the Panda</em> &#13;
  health -= damage; &#13;
 <em> //Then it triggers the Die or the Hit animations based if the Panda&#13;
    is still alive</em> &#13;
  if(health &lt;= 0) { &#13;
    animator.SetTrigger(AnimDieTriggerHash); &#13;
    gameManager.OneMorePandaInHeaven(); &#13;
  } &#13;
  else { &#13;
    animator.SetTrigger(AnimHitTriggerHash); &#13;
  } &#13;
} &#13;
</pre><p>Save the script, because we are going to explore how the Pandas are created/spawned in the next section.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec86"/>Panda invasion – spawning Pandas</h1></div></div></div><p>In this section, we will implement the spawning system of the game. This can be done in many ways. However, since we have only one kind of Panda (at least for the moment), we will implement it in a simple way. In any case, we will use coroutines to implement the system, and we will see a template structure which we might also use in more complex spawning systems (in the next chapter, some ideas of more complex spawning systems will be provided).</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec99"/>What is a coroutine?</h2></div></div></div><p>It is a structure that Unity provides to allow functions to be interrupted and continued in other frames of the game. In the case of our spawning system, we don't want to spawn all the Pandas at the same time, but a little bit over time. This over time can be controlled with coroutines. You can definitely learn more and see some examples in the official documentation here: <a class="ulink" href="https://docs.unity3d.com/Manual/Coroutines.html">https://docs.unity3d.com/Manual/Coroutines.html</a></p><p>However, the most important things to know about coroutines are listed here:</p><div><ul class="itemizedlist"><li class="listitem">They are special functions which have an <code class="literal">IEnumerator</code> as a return value.</li><li class="listitem">They can be started with the <code class="literal">StartCoroutine()</code> function and stopped with the <code class="literal">StopCourotine()</code> function.</li><li class="listitem">They cannot run/start within any <code class="literal">Update()</code> function. The reason is because the <code class="literal">Update()</code> function's nature is to be called one time per frame (or more), whereas the coroutine's nature is to run at the time they specify.</li><li class="listitem">They can use a special instruction; yield: It allows them to wait for something, such as a fixed amount of time, the end of the frame, or even another coroutine. In any case, after the yield, they expect a return value. Common functions that are used with yield are:<div><ul class="itemizedlist"><li class="listitem"><code class="literal">WaitForEndOfFrame()</code>: Waits until the next frame (official documentation: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/WaitForEndOfFrame.html">https://docs.unity3d.com/ScriptReference/WaitForEndOfFrame.html</a>)</li><li class="listitem"><code class="literal">WaitForSeconds()</code>: Waits a specific amount of time specified in seconds as a parameter (official documentation: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/WaitForSeconds.html">https://docs.unity3d.com/ScriptReference/WaitForSeconds.html</a>)</li><li class="listitem"><code class="literal">WaitUntil()</code>: Waits until a certain condition is met (official documentation: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/WaitUntil.html">https://docs.unity3d.com/ScriptReference/WaitUntil.html</a>)</li></ul></div></li></ul></div><p>Moreover, you can even implement custom yield instructions, as shown in the official documentation here: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html">https://docs.unity3d.com/ScriptReference/CustomYieldInstruction.html</a></p><div><h3 class="title"><a id="note104"/>Note</h3><p>For the most curious of you, coroutines are not threads. In fact, coroutines run on the same thread as the rest of the game.</p></div><p>It takes time to get used to them, since they are hard to make work when you have complex environments, and as such they are often considered as an advanced topic. But they unlock many potentialities in what can be done, which is fundamental for good gameplay programming. Unfortunately, in this book we don't have enough space to dedicate them a proper space, but I hope that with the official documentation, this small explanation, and the example of the spawning system in the next section, you will be able to better understand coroutines.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec100"/>Sketching the idea of how it works</h2></div></div></div><p>We will divide our game into waves. Each wave has a determined number of Pandas, which will be spawned over time at an increasing intensity. Once all of the Pandas of that wave have been shot down, the game will increase the number of spawned Pandas for the next wave and start it. When all the waves are completed by the player, the level can be considered as a win.</p><p>In particular, we will have a cycle in a coroutine which will manage the different waves and wait till the end of a wave before starting another one. A second routine will take care of the single wave, to spawn Pandas for it, and check when all the Pandas have been shot down by the player.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec101"/>Setting up the spawning system</h2></div></div></div><p>Designers should be provided with a way to place where the Pandas will be spawned. As such, we can create an empty game object, and call it <code class="literal">SpawningPoint</code>. Moreover, you can attach to it a gizmo, similar to what we have done with waypoints in the previous chapter. As a result, it will be visible in the <strong>Scene</strong> view. So, at the end you should have something like this:</p><div><img src="img/image00603.jpeg" alt="Setting up the spawning system"/></div><p style="clear:both; height: 1em;"> </p><p>Open the <code class="literal">GameManagerScript</code> and let's add a variable to keep track of where this <code class="literal">SpawningPoint</code> is. Since we just need the position, we can just take the Transform, instead of the whole game object:</p><pre class="programlisting">
<em>//The Spawning Point transform so to get where the Pandas should be&#13;
  spawned</em> &#13;
private Transform spawner; &#13;
</pre><p>To set its value, let's change the <code class="literal">Start()</code> function like the following:</p><pre class="programlisting">void Start () {&#13;
  <em>//Get the reference to the Player's health</em>&#13;
  playerHealth = FindObjectOfType&lt;HealthBarScript&gt;();&#13;
 &#13;
<em> //Get the reference to the Spawner</em>&#13;
  spawner = GameObject.Find("Spawning Spot").transform;&#13;
}</pre><p>Also, we need three more variables. One is for the prefab of the Panda to instantiate the right enemy, another is for the number of waves that the player has to face, and the last one for the number of Pandas per wave (which will increase between waves):</p><pre class="programlisting">
<em>//The Panda Prefab that should be spawned as enemy</em>&#13;
public GameObject pandaPrefab;&#13;
&#13;
<em>//The number of waves that the player has to face in this level</em>&#13;
public int numberOfWaves;&#13;
&#13;
<em>//The number of Pandas that the player as to face per wave.&#13;
//It increase when a wave is won.</em>&#13;
public int numberOfPandasPerWave;</pre><p>After we have saved the script, we have to assign the variable in the <strong>Inspector</strong>, as shown in the following screenshot (feel free to change the values to suit the balance of your game):</p><div><img src="img/image00604.jpeg" alt="Setting up the spawning system"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec102"/>Managing waves</h2></div></div></div><p>In this section, we are going to implement the first of the two coroutines aforementioned. In fact, this coroutine will cycle over all the waves, and call the second one to handle the single wave. Between waves, the number of spawned enemies is increased. If the player has won all the waves, then the <code class="literal">GameOver()</code> function is called in the winning mode.</p><p>Thus, open the <code class="literal">GameManagerScript</code> and we can start to write the following:</p><pre class="programlisting">
<em>//Coroutine that spawns the different waves of Pandas </em>&#13;
private IEnumerator WavesSpawner() { &#13;
 <em> //For each wave</em> &#13;
  for(int i = 0; i &lt; numberOfWaves; i++) { &#13;
    <em>//Let the PandaSpawner coroutine to handle the single wave. When it&#13;
      finishes &#13;
    //also the wave is finished, and so this coroutine can continue.</em> &#13;
    yield return PandaSpawner(); &#13;
    <em>//Increase the number of Pandas that are generated per wave</em> &#13;
    numberOfPandasPerWave += 3; &#13;
  } &#13;
 <em> //If the Player won all the waves, call the GameOver function in&#13;
    "winning" mode</em> &#13;
  GameOver(true); &#13;
} &#13;
</pre><p>As you can see from the code, we call call the <code class="literal">PandaSpawner()</code> coroutine, which we implement in the next section.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec103"/>The single wave</h2></div></div></div><p>Now for the tough part. Here we need to write a coroutine that is able to handle a whole wave of Pandas. Therefore, let's look at it step-by-step, starting with creating the coroutine:</p><pre class="programlisting">
<em>//Coroutine that spawns the Pandas for a single wave, and waits until&#13;
  "all the Pandas are in Heaven"</em> &#13;
private IEnumerator PandaSpawner() { &#13;
  <em>//Rest of the code</em> &#13;
} &#13;
</pre><p>The first thing to do is to initialize the <code class="literal">numberOfPandasToDefeat</code> variable, to keep track of how many Pandas the player has defeated so far. Of course, we will initialize this number to be the same as the number of Pandas that will be spawned in the wave:</p><pre class="programlisting">
<em>//Initialize the number that needs to be defeated for this wave</em> &#13;
numberOfPandasToDefeat = numberOfPandasPerWave; &#13;
</pre><p>The next step is to cycle through all the Pandas to spawn, to progressively spawn them:</p><pre class="programlisting">
<em>//Progressively spawn Pandas</em> &#13;
for(int i=0; i &lt; numberOfPandasPerWave; i++) {&#13;
  <em>//Rest of the code inside the cycle</em> &#13;
} &#13;
<em>//Rest of the code outside the cycle</em>
</pre><p>Inside the cycle, we need to first spawn the Pandas at their spawned position (with no rotation, which means having the identity as a <strong>quaternion</strong>). Then, we need to wait for a time that depends both on how many Pandas are left and by a random number. In particular, we will calculate the ratio of how many Pandas are left, and use it to interpolate between two times. As a result, the greater the number of Pandas spawned so far, the less time to wait. Then, this is added to a random number, to add a bit of chance in our game. Here is the code:</p><pre class="programlisting">
<em>//Spawn/Instantiate a Panda at the Spawner position</em> &#13;
Instantiate(pandaPrefab, spawner.position, Quaternion.identity);&#13;
 &#13;
<em>//Wait a time that depends both on how many Pandas are left to be &#13;
//spawned and by a random number</em> &#13;
float ratio = (i * 1f) / (numberOfPandasPerWave - 1); &#13;
float timeToWait = Mathf.Lerp(3f, 5f, ratio) + Random.Range(0f, 2f); &#13;
yield return new WaitForSeconds(timeToWait); &#13;
</pre><div><h3 class="title"><a id="note105"/>Note</h3><p>Of course, this is not the only way to implement this and the numbers in the code are arbitrary. In a real game, everything should be decided in order to balance the game, by the hard work of designing and play testing. You can find a bit more about this in the next chapter.</p></div><p>Outside the cycle, instead, we need to wait until all the Pandas have been shot down by the player (or some game over conditions have been met) before ending the coroutine, and so give back control to the <code class="literal">WavesSpawner()</code> coroutine for the next wave:</p><pre class="programlisting">
<em>//Once all the Pandas are spawned, wait until all of them are defeated &#13;
//by the player (or a gameover condition occurred before)</em> &#13;
yield return new WaitUntil(() =&gt; numberOfPandasToDefeat &lt;= 0); &#13;
</pre><p>Save the script, and as a result, the player has to face many, terrible waves of sweet-toothed Pandas!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec87"/>The main menu</h1></div></div></div><p>As in many games, there is a main menu when the game starts, and so, also, in our game we cannot forget a main menu. This will give us the possibility to explore a bit more of what we have touched upon in <a class="link" title="Chapter 1. A Flat World in Unity" href="part0016.xhtml#aid-F8901">Chapter 1</a>, <em>A Flat World in Unity</em>, about changing scenes in Unity.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec104"/>Designing the main menu</h2></div></div></div><p>As we learnt back in <a class="link" title="Chapter 3. Communicating with the Player – the User Interface" href="part0043.xhtml#aid-190861">Chapter 3</a>, <em>Communicating with the Player – the User Interface</em>, it's good practice to have a design of the user interface, and the main menu is an extension of the user interface. As such, it should be designed with the same principles of UI design in mind.</p><p>The menu for our game is very simple: we have a cool background, and three buttons placed just below the center of the screen. They are respectively:</p><div><ul class="itemizedlist"><li class="listitem"><strong>NEW GAME</strong>: Creates a new game for the player, by loading the level we have been creating so far</li><li class="listitem"><strong>SETTINGS</strong>: Triggers a setting screen, where the player can manipulate some options (this is left as an exercise, in the <em>Homework</em> section)</li><li class="listitem"><strong>QUIT</strong>: As the name suggests, it closes the game</li></ul></div><p>So, our design will look something like the following:</p><div><img src="img/image00605.jpeg" alt="Designing the main menu"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec105"/>Creating the main menu in another scene</h2></div></div></div><p>To create another scene in Unity, you can select <strong>File</strong> | <strong>New Scene</strong> from the top bar, but it's preferable to navigate in the <strong>Project</strong> panel within the <code class="literal">Scene</code> folder so that by right-clicking you can select <strong>Create |
</strong>
<strong> Scene</strong>. In this second way, the scene will be directly created within the right folder; as a result, your project is ordered and tidy.</p><p>You can name the scene <code class="literal">Main Menu</code>, and then double-click to open it. And here from scratch again, there is an empty void to fill up with your creativity and fantasies!</p><p>Now, you should have the skills to do the following without a step-by-step explanation:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a UI image (which will automatically generate a <strong>Canvas</strong> as well as the <strong>Event System</strong>), and name it <code class="literal">Background</code>. Then, extend it to the whole screen, and place the cool background you have in mind.</li><li class="listitem">Tweak the canvas settings if you need to achieve what you have in mind.</li><li class="listitem">Create three buttons, change their graphics if you want, and their texts so to match <strong>NEW GAME</strong>, <strong>SETTINGS</strong>, and <strong>QUIT</strong> respectively. Place them, as in the design of the previous section.</li><li class="listitem">Create an empty GameObject where we will attach a script to handle all the different interactions.</li><li class="listitem">On the three buttons, add an <code class="literal">OnClick()</code> event and drag the new empty object into the <code class="literal">object</code> variable</li></ol><div></div><p>Once the menu is created, we can save the scene.</p><p>Since we have two scenes, if we want to include them in the final version of the game, we need to include them in the <strong>Scenes In Build</strong>. To do so, we need to open the building settings from the top bar menu by clicking on <strong>File</strong> |<strong> Building Settings… </strong>. You can drag and drop the scene in the <strong>Scenes In Build</strong> area from your <strong>Project</strong> panel, and they will appear there in a determined order. The numbers you see next to the scenes are the identifiers of the scene. For instance, we can use this identifier to specify which scene to load.</p><p>In our case, be sure that the <code class="literal">Main Menu</code> scene is before our <code class="literal">Level_01</code>, as shown in the following screenshot:</p><div><img src="img/image00606.jpeg" alt="Creating the main menu in another scene"/></div><p style="clear:both; height: 1em;"> </p><p>Now, it's time to create the script with all the functionalities.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec106"/>Loading scenes through scripts</h2></div></div></div><p>Create a new script and call it <code class="literal">MainMenuFunctionalities</code>. Since its functions will be triggered by the <code class="literal">OnClick()</code> event, we need to make them public.</p><p>In particular, we have a function for loading the level of our game. If you remember, its ID is <code class="literal">1</code>. To load a scene in Unity, you use a special class called <code class="literal">SceneManager</code>. As such, we need to import its library by adding the following line of code at the beginning of our script:</p><pre class="programlisting">using UnityEngine.SceneManagement; &#13;
</pre><div><h3 class="title"><a id="note106"/>Note</h3><p>The <code class="literal">SceneManager</code> class along with the <code class="literal">UnityEngine.SceneManagement</code> library are relatively new in Unity. In fact, these allow you to perform many actions on scenes, such as loading them together, loading them dynamically, and unloading them, all at runtime. This gives you a new universe of possibilities, which I hope you will have chance to explore, since in this book we don't have time to go through everything in detail. In any case, a good starting point is, as usual, the official documentation that you can find here: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html">https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.html</a>.</p><p>For the more curious of you, before the <code class="literal">SceneManager</code> class, scenes were handled by the <code class="literal">Application</code> class. So, in case you have some outdated code, which still uses the <code class="literal">Application</code> class to load scenes, you know that it was written for previous versions of Unity. If that code belongs to your project, consider (if possible, due to legal issues) to update it using the <code class="literal">SceneManager</code> class.</p></div><p>The most common function of the <code class="literal">SceneManager</code> class is <code class="literal">LoadScene()</code>, which can load another scene. One way to specify the scene is with its identifier (as we will do in our script), but there are also other ways, such as with a string containing the name of the scene.</p><p>We can implement the function that will be called by the <strong>NEW GAME</strong> button in the following way, which is really simple and straight forward:</p><pre class="programlisting">
<em>//Function that loads the first level</em> &#13;
public void NewGame() { &#13;
  SceneManager.LoadScene(1); &#13;
} &#13;
</pre><p>The function related to the <strong>SETTINGS</strong> button, instead, is left as an exercise (see<em> Homework </em>section):</p><pre class="programlisting">
<em>//Function that displays the settings</em> &#13;
public void Settings() { &#13;
 <em> //Your own code here</em> &#13;
} &#13;
</pre><p>Finally, the function to quit the game uses the <code class="literal">Application</code> class (more on this class in the official documentation here: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Application.html">https://docs.unity3d.com/ScriptReference/Application.html</a>), where there is a specific function to quit your game:</p><pre class="programlisting">
<em>//Function that closes the game</em> &#13;
public void Quit() { &#13;
  Application.Quit(); &#13;
} &#13;
</pre><div><h3 class="title"><a id="note107"/>Note</h3><p>Keep in mind that this function doesn't work in some circumstances, such as when the game is running in the editor (in Unity itself), or for instance, for web-based games. As such, closing a game that should be shipped on different platforms might require more work. More about multi-platform games in the next chapter.</p></div><p>Save the script, and come back to the <code class="literal">OnClick()</code> events on the three buttons.</p><p>Assign the correct function to each of them. Here is the example of how the <strong>NEW GAME</strong> button event should look:</p><div><img src="img/image00607.jpeg" alt="Loading scenes through scripts"/></div><p style="clear:both; height: 1em;"> </p><p>And also, the main menu has been implemented. With this, our game is basically completed and functioning. Let's recap what we have done and learnt so far in the next section.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec88"/>Techniques we learnt in this chapter</h1></div></div></div><p>If you have reached this point of the chapter and book, it means that your game is completed. Let's recap what we have learnt in terms of techniques, instead of topics:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Inheritance</strong>: We have implemented our trading system by using inheritance, and this gave us the possibility to explore it. In particular, we learnt a bit more about:<div><ul class="itemizedlist"><li class="listitem"><strong>Abstract classes and methods</strong>: So that their full implementation is left to child classes</li><li class="listitem"><strong>Protected variables</strong>: Which can be seen by some scripts but not all of them</li><li class="listitem"><strong>UI handlers</strong>: Can be automatically linked to have an interaction with the UI without settings events in the <strong>Inspector</strong></li></ul></div></li><li class="listitem"><strong>Interaction between mouse and camera</strong>: To implement the placing script, we needed to transform the mouse coordinates into game coordinates.</li><li class="listitem"><strong>Enabling/disabling scripts</strong>: To implement functionalities, always in the placing script, we learnt how it is possible to disable and enable scripts to trigger functionalities when they are needed.</li><li class="listitem"><strong>Storing information</strong>: Within the <code class="literal">Game Manager</code>, we learnt how other scripts can have access to them. Throughout all the chapters we have done this, and in different ways. In particular, we used public functions on the <code class="literal">Game Manager</code> that have been called by the other scripts. As a result, the <strong>Game Manager</strong> became a hub to exchange data between the different parts of the game.</li><li class="listitem"><strong>Using static functions</strong>: To assign generic variables again, in the trading system, we have implemented a static function to set the active tower. As a result, any script can have access to that function without the need to get a reference to the specific trading class instance (moreover the parent class is abstract so it doesn't have instances). This could have been done without many problems, because the variable assigned was already static and shared among all the instances of the trading classes.</li><li class="listitem"><strong>Implementing coroutines</strong>: To handle events that last over time<em> </em>in implementing the spawning system, we have used coroutines. These are special functions which have the possibility to be interrupted and continue in other frames of the game. This is the most powerful tool we have seen in this chapter, although it requires a bit more practice than other tools to master it, but it is definitely worth it.</li><li class="listitem"><strong>Using UI events</strong>: To implement the functions, in our main menu, we have implemented functions within a script to be triggered by the <code class="literal">OnClick()</code> event of the buttons. In this way, you avoid using UI handlers. The advantages of this method is that you can place all the functions within a single script and have a specific instance of that script to trigger (in case the script can be instantiated). On the other hand the disadvantage is that a lot of manual work for linking the events in the <strong>Inspector</strong> is required. UI handlers, on the contrary, have advantages and disadvantages flipped. As such, UI handlers are suitable for big scripts with many functions implemented in that which require a bit of interaction with the UI. For small functions, instead, it is better to have them all in a single script that creates a different script for each one of them. In any case, the best solution depends on the situation and which one is your goal.</li><li class="listitem"><strong>Using colliders to identify zones</strong>: We used the physics engine to detect if the mouse is hovering over certain zones when placing cupcake towers is allowed. Moreover, we used a collider on the cupcake towers to detect a click on it (so as to be selected) and to avoid placing other cupcake towers on top of others. These are just one of the many ways to use the Physics engine for non-physics related calculations.</li></ul></div><p>I hope you have learnt a lot in this chapter, and that you have grasped the basic concepts of each of the different techniques we have used. To improve both the game and your skills, I invite you do the exercises in the following section.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec89"/>Homework</h1></div></div></div><p>In this chapter, we have covered many techniques on how to exchange information between different parts of our game, and learnt a bit about gameplay programming. Here there are some exercises to improve your skills and become a better game developer:</p><div><ol class="orderedlist arabic"><li class="listitem"><strong>Sweet capital</strong>: When the the game begins, Pandas start coming and the player should buy some cupcake tower to defend his/her cake. But, at the very beginning, the player doesn't have any sugar to buy towers, nor he/she can kill some Pandas to get some sugar. Thus, add an initial sugar amount variable in the <code class="literal">Game Manager</code> (so that it can be set from the Inspector), and set this quantity in the <code class="literal">Sugar Meter</code> within the <code class="literal">Start()</code> function. As a result, the player will be immediately ready to fight Pandas.</li><li class="listitem"><strong>The calm before the storm</strong>: At this stage, when the game starts, the Pandas immediately come to eat the player's delicious cake. However, the player should have the time to buy and place some cupcake towers at the beginning, with the capital set from the previous exercise. In the <code class="literal">wavesSpawner()</code> coroutine, set a timer before each wave to give the player the time to assess. Then, expose the right variables in the <strong>Inspector</strong>, so as to tweak the timer depending on the level. Consider, as a variant, that you can increase or decrease such a timer between waves.</li><li class="listitem"><strong>Wave bonus (Part I)</strong>: If you are planning to increase the number of Pandas spawned significantly between waves, then you should consider rewarding the player with some sugar once the wave is completed. Modify the <code class="literal">wavesSpawner()</code> coroutine to include a sweet bonus for the player. Then, expose the right variables in the Inspector to tweak the bonus for each level.</li><li class="listitem"><strong>Wave bonus (Part II)</strong>: After have done the previous exercise, make an array of bonuses, where its dimension changes according to the number of waves. Then, at the end of each wave, assign the right bonus to the player, so as to have the possibility to tweak the bonus not only for each level, but also for each wave.</li><li class="listitem"><strong>Singleton pattern (Part I)</strong>: In our game, there are some scripts that should have a single instance at the time, such as the <code class="literal">Game manager</code>, the <code class="literal">Health Bar</code>, or the <code class="literal">Sugar Meter</code>. As such, it's best practice to make them unique, since some of our scripts rely on the implicit (but not granted) fact that there is only one instance of such classes. Therefore, you should implement a pattern called <strong>singleton</strong>. You can definitely search on the Internet how to implement it, but try to come up with your own personal solution. Many online implementations rely on a static variable to retrieve the single instance of the class. Since our script will find these classes with the <code class="literal">FindObjectOfType()</code> function, you can try to explore other ways. So, try to give your solution to the problem and implement it for the <code class="literal">GameMangerScript</code>, the <code class="literal">HealthBarScript</code>, and the <code class="literal">SugarMeterScript</code>.</li><li class="listitem"><strong>Singleton pattern (Part II)</strong>: After Part I, you should have implemented the singleton pattern in your way. Now, look at the following two links: <a class="ulink" href="http://wiki.unity3d.com/index.php/Singleton">http://wiki.unity3d.com/index.php/Singleton</a> and <a class="ulink" href="https://unity3d.com/learn/tutorials/projects/2d-roguelike-tutorial/writing-game-manager">https://unity3d.com/learn/tutorials/projects/2d-roguelike-tutorial/writing-game-manager</a>, since both implement the singleton pattern. Compare those to the ones you came up with, and highlight for each approach, the advantages and the disadvantages. Which approach do you think would work better in our game? Does the approach differ for the <code class="literal">Game Manager</code>, the <code class="literal">Health Bar</code>, or the <code class="literal">Sugar Meter</code>? Implement the singleton pattern you consider worthwhile for our tower defense game.</li><li class="listitem"><strong>Improving the allowed areas (Part I)</strong>: We have seen how it is possible to use colliders to check if the mouse is hovering over allowed areas, so that the placing script knows if it is a suitable place or not when it needs to release the cupcake towers. But what happens in the <code class="literal">Game Manager</code>? Even if there is no tower to place, it stills checks for allowed areas and updates its internal state. Think about a solution in which the <code class="literal">Game Manager</code> checks if the mouse is hovering over allowed areas only when the placing scripts asks for it. As a result, your new solution should improve the performance of the <code class="literal">Game Manager</code>.</li><li class="listitem"><strong>Improving the allowed areas (Part II)</strong>: This exercise is independent from part I. In the allowed areas system, we have considered only the mouse. What about if you want to export the game on a mobile platform, such as on an Android device? In this situation, should the allowed area system be completely redesign or changed? As such, design and implement a system which is suitable for as many platforms as possible.</li><li class="listitem"><strong>Improving the allowed areas (Part III)</strong>: This exercise is independent from Parts I and II. The system of allowed areas we came up with is not really easy to use for a multi-level game (something that, most likely, you have), since you cannot place colliders in the <code class="literal">Game Manager Prefab</code> as they depend on the particular level. Can you think of an easier solution for level designers to tell the <code class="literal">Game Manager</code> which areas are allowed, level by level? Once you have designed such a system, implement it in our tower defense game.</li><li class="listitem"><strong>Improving the allowed areas (Part IV)</strong>: Consider all the solutions you have found for the different problems faced in Parts I, II, and III. Try to merge them together into an ultimate solution for the allowed areas. The goal is to create a system which is efficient (from a computational point of view), easy-to-use (for game and level designers), and multi-platform (so as to deploy the game on more than one platform) at the same time.</li><li class="listitem"><strong>Feedback to the player (Part I)</strong>: This is a series of exercises all independent of each other, and they aim to improve the feedback that the game provides to the player, which is of vital importance for a game to be appealing. When the player trades, he/she sells, buys, or upgrades towers, but there is no feedback that the operation was a success. Therefore, you need to implement some visual feedback. Consider the following as smaller exercises:<div><ul class="itemizedlist"><li class="listitem">When sugar is detracted or added to the <code class="literal">Sugar Meter</code>, add an animation so that a big number appears on the <code class="literal">Sugar Meter</code> showing the quantity that changed. Moreover, consider changing the color of this number based on the amount, and whether it is added or subtracted.</li><li class="listitem">When the sugar is detracted or added to the <code class="literal">Sugar Meter</code>, add an animation to show the numbers of the <code class="literal">Sugar Meter</code> changing, instead of suddenly changing the number displayed.</li><li class="listitem">When a tower is upgraded, consider placing an animation that plays on the tower. Same for when the tower is sold or placed (after have bought it).</li></ul></div></li><li class="listitem"><strong>Feedback to the player (Part II)</strong>: This is a series of exercises all independent of each other, and they aim to improve the feedback that the game provides to the player, which is of vital importance for a game to be appealing.When the player trades, he/she sells, buys, or upgrades towers, but there is no feedback about what the operations are going to do/change, such as: which one is the price of buying a tower? Therefore, you need to implement some visual feedback. Consider the following as smaller exercises:<div><ul class="itemizedlist"><li class="listitem">When the player hovers over one of the trading buttons, make the price (or the value in case of the selling button) appear somewhere (which needs to be decided carefully, since it impacts the design we did in <a class="link" title="Chapter 3. Communicating with the Player – the User Interface" href="part0043.xhtml#aid-190861">Chapter 3</a>, <em>Communicating with the Player – the User Interface</em>), so the player can read it before, to perform the action.</li><li class="listitem">When no tower is selected, both the selling and the upgrading buttons shouldn't be displayed as active. Change this, to display a disable button when the <code class="literal">currentActiveTower</code> variable is null.</li></ul></div></li><li class="listitem"><strong>Implementing a setting menu (Part I)</strong>: In this chapter, we left this as an exercise, so let's see what we need to do. The first thing to decide is what settings the player can change and how (a toggle? A slider? A drop-down menu?). In particular, you should have at least an audio toggle, and a quality settings drop-down menu, plus any options you would like to include. Then, make a complete design of the UI. Finally, in Unity create a new scene (or screen, whichever you prefer) and implement the settings screen by using UI elements.</li><li class="listitem"><strong>Implementing a setting menu (Part II)</strong>: In Part I, we did the design and implemented it within Unity. Now, we need to implement the functionalities (except the audio for now, which is left for the next chapter). So, create a script, and similar to what we did with the main menu, implement all the functionalities there, and link them to the UI elements through the use of events in the <strong>Inspector</strong>. To modify the quality settings and the audio settings, search the official documentation on how to do it (this is part of the exercise). Moreover, keep in mind that the next chapter might give you some other ideas of the kind of settings to implement.</li><li class="listitem"><strong>Magic numbers (Part I)</strong>: We already have encountered magic numbers in the previous chapters. They are numbers that appear within a script and without an explanation, and good practice says that it is better to avoid them as much as possible. Also in this chapter, we have left many of them; let's try to remove them. The first magic number is the number <em>7</em> from the placing script when we create a new vector for the position of our tower. This number depends on the position of the camera and where the tower should be placed along the <em>z</em>-axis. As such, add some lines of code to calculate this number in a dynamic way (so if we decide to change the camera position or the <em>z</em>-depth of the towers, we can do it without changing the script, as a bonus, you will have the possibility of also having different kinds of towers on different z-depth layers, which can be useful to you in the same way). In particular, you need to subtract the <em>z</em>-axis of the tower from the <em>z</em>-axis of the camera.</li><li class="listitem"><strong>Magic numbers (Part II)</strong> : We have also left some magic numbers in the <code class="literal">Upgrade()</code> function of the <code class="literal">CupcakeTowerScript</code>. Create variables that can be set in the <strong>Inspector</strong>, to remove any magic numbers that are left (such as increasing the selling value or the upgrade cost).</li></ol><div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec90"/>Summary</h1></div></div></div><p>In this chapter, we have explored many techniques to exchange information and data between different scripts. In doing so, we have finished the implementation of our tower defense game.</p><p>The Pandas walk towards the player's cake to eat it, the cupcake towers shoot at them, and so Pandas die and they are periodically spawned as well. The player can buy, sell, and upgrade cupcake towers. A main menu is present and the player can either win or lose. So, our game is complete. Or is it not? Can we go even further? Let's find it out in the next chapter.</p></div></body></html>