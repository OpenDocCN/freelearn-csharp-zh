- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: 'Interface Brilliance: Designing User-Friendly UI'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 界面精彩：设计用户友好的UI
- en: Everything that is shown on the screen and transmitted through the speakers
    of a computer is a form of communication. In previous chapters, we used 3D models
    to let the user know that they are in a base in the middle of the mountains, and
    we reinforced that idea with the appropriate sound and music. But for our game,
    we need to communicate other information, such as the amount of life the player
    has left and the current score, and sometimes, it is difficult to express these
    things using the in-game graphics (there are some successful cases that manage
    to do this, such as *Dead Space*, but let’s keep things simple).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上显示的以及通过电脑扬声器传输的一切都是一种交流形式。在前几章中，我们使用3D模型让用户知道他们身处山中一个基地，并通过适当的声音和音乐强化了这个想法。但对我们这款游戏来说，我们需要传达其他信息，例如玩家剩余的生命值和当前得分，有时，使用游戏内的图形来表达这些事情是困难的（有一些成功的案例能够做到这一点，例如*死亡空间*，但让我们保持简单）。
- en: In order to transmit this information, we need to add another layer of graphics
    on top of our scene, which is usually called the **User Interface** (**UI**).
    This will contain different visual elements, such as text fields, bars, and buttons,
    to prepare the user to make an informed decision, based on things such as fleeing
    to a safe place when their life is low.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了传输这些信息，我们需要在我们的场景上添加另一层图形，这通常被称为**用户界面**（**UI**）。它将包含不同的视觉元素，如文本框、条形图和按钮，以便用户根据诸如生命值低时逃往安全地点等因素做出明智的决定。
- en: 'In this chapter, we will explore the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Understanding the Canvas and RectTransform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Canvas和RectTransform
- en: Canvas object types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canvas对象类型
- en: Creating a responsive UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建响应式UI
- en: Right now, these terms may mean nothing to you, but to simplify, think of the
    Canvas and RectTransform as the respective stage and actors of your UI drama.
    They’re crucial, and we’ll dive deep into how they work and play together.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这些术语可能对你来说毫无意义，但为了简化，可以将Canvas和RectTransform想象成你的UI戏剧中的相应舞台和演员。它们至关重要，我们将深入探讨它们的工作方式和协同作用。
- en: By the end of this chapter, you will be able to use the Unity UI system to create
    interfaces capable of informing the user about the state of the game, allowing
    them to take action by pressing buttons.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用Unity UI系统创建能够通知用户游戏状态的界面，并允许他们通过按按钮采取行动。
- en: We’re about to unravel how the Canvas and RectTransform work in unison to bring
    your game’s interface to life. It’s a bit like choreographing a dance – every
    element has its place and movement.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将揭示Canvas和RectTransform如何协同工作，使你的游戏界面生动起来。这有点像编排舞蹈——每个元素都有其位置和动作。
- en: Understanding the Canvas and RectTransform
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Canvas和RectTransform
- en: We are only going to focus on the in-game UI to communicate different information
    to the player using the Unity GUI system (or uGUI). At the time of writing, a
    new GUI system called UI Toolkit has been released. Even though we will introduce
    UI Toolkit, remember that uGUI isn’t going anywhere anytime soon. It’s crucial
    to grasp both to be versatile in your UI design approach. We will explore UI Toolkit
    in the next chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只关注游戏内的UI，使用Unity GUI系统（或uGUI）向玩家传达不同的信息。在撰写本文时，一个新的GUI系统名为UI Toolkit已经发布。尽管我们将介绍UI
    Toolkit，但请记住，uGUI在不久的将来不会消失。掌握两者对于你在UI设计方法上的灵活性至关重要。我们将在下一章中探讨UI Toolkit。
- en: If you are going to work with Unity UI, you first need to understand its two
    main concepts—the **Canvas** and **RectTransform**. The **Canvas** is the master
    object that will contain and render our UI, and **RectTransform** is the feature
    in charge of positioning and adapting each UI element on our screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用Unity UI，首先你需要理解其两个主要概念——**Canvas**和**RectTransform**。**Canvas**是包含并渲染我们UI的主对象，而**RectTransform**是负责在屏幕上定位和调整每个UI元素的特性。
- en: 'In this section, we will be:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将：
- en: Creating a UI with the Canvas
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Canvas创建UI
- en: Positioning elements with RectTransform
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RectTransform定位元素
- en: Let’s start by using the Canvas component to create our UI.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用Canvas组件来创建我们的UI开始。
- en: Creating a UI with the Canvas
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Canvas创建UI
- en: Let’s put theory into practice by creating a Canvas-based UI. We’ll start with
    something simple to get the ball rolling.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将理论付诸实践，通过创建基于Canvas的UI。我们将从简单的事情开始，以推动进展。
- en: In Unity UI, each image, text, and element you see in the UI is a GameObject
    with a set of proper components, but in order for them to work, they must be a
    child of a master GameObject with the Canvas component. This component is responsible
    for triggering the UI generation and drawing iterations over each child object.
    We can configure this component to specify exactly how that process works and
    adapt it to different possible requirements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity UI中，你看到的每个图像、文本和UI元素都是一个具有一组适当组件的GameObject，但为了使它们能够工作，它们必须是具有Canvas组件的主GameObject的子对象。这个组件负责触发UI生成并在每个子对象上绘制迭代。我们可以配置这个组件以指定该过程的确切工作方式并适应不同的可能需求。
- en: To start, you can simply create a canvas with the **GameObject** | **UI** |
    **Canvas** option. After doing that, you will see a rectangle in the scene, which
    represents the user’s screen, so you can put elements inside it and preview where
    they will be located relative to the user’s monitor.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以简单地使用**GameObject** | **UI** | **Canvas**选项创建一个画布。完成之后，你会在场景中看到一个矩形，它代表用户的屏幕，因此你可以将元素放入其中并预览它们相对于用户监视器的位置。
- en: You are probably wondering two things here. First, “*Why is the rectangle in
    the middle of the scene? I want it to always be on the screen!*” Don’t worry,
    because that will be exactly the case. When you edit the UI, you will see it as
    part of the level, as an object inside it, but when you play the game, it will
    always be projected over the screen, on top of every object. Also, you may be
    wondering why the rectangle is huge, and that’s because one pixel of the screen
    map corresponds to one meter on the scene when using the default **Canvas** **Render
    Mode**, the one called **Screen Space - Overlay**. There are other modes, but
    discussing them is outside of the scope of this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在这里有两个疑问。首先，“*为什么矩形在场景的中间？我想让它始终在屏幕上!*”不必担心，因为情况确实如此。当你编辑UI时，你会将其视为关卡的一部分，作为其中的一个对象，但当你玩游戏时，它将始终投影在屏幕上，覆盖在所有对象之上。此外，你可能想知道为什么矩形这么大，这是因为在使用默认的**Canvas**
    **Render Mode**，即称为**Screen Space - Overlay**时，屏幕映射中的一个像素对应场景中的一米。有其他模式，但讨论它们超出了本章的范围。
- en: 'Again, don’t worry about that; you will see all your UI elements with their
    proper size and position on the user’s screen when you see the game in the **Game**
    view. Consider setting the **Game** view size prior to editing it in the **Scene**
    view, given that the **Scene** view will follow the **Game** view dimensions.
    You can do that by clicking the dropdown saying **Free Aspect** at the top part
    of the **Game** panel and selecting the desired resolution or aspect ratio, **16:9
    Aspect** being the most used option:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，不必担心这一点；当你从**Game**视图中查看游戏时，你会看到所有UI元素及其适当的大小和位置在用户的屏幕上。考虑到**Scene**视图将遵循**Game**视图的尺寸，建议在**Scene**视图中编辑之前先设置**Game**视图的大小。你可以通过点击**Game**面板顶部的**Free
    Aspect**下拉菜单并选择所需的分辨率或纵横比来完成此操作，**16:9 Aspect**是最常用的选项：
- en: '![](img/B21361_15_01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_01.png)'
- en: 'Figure 15.1: A default image UI element—a white box'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：默认图像UI元素——一个白色框
- en: Before adding elements to our UI, it’s worth noting that when you created the
    UI, a second object was created alongside the Canvas, called **EventSystem**.
    This object is not necessary to render a UI but is necessary if you want the UI
    to be interactable, which means including actions such as clicking buttons, introducing
    text in fields, or navigating the UI with the joystick. The **EventSystem** component
    is responsible for sampling the user input, such as with a keyboard, mouse, or
    joystick, and sending that data to the UI to react accordingly. We can change
    the exact buttons to interact with the UI, but the defaults are OK for now, so
    just know that you need this object if you want to interact with the UI. If for
    some reason you delete the object, you can recreate it again in **GameObject**
    | **UI** | **Event System**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在将元素添加到我们的UI之前，值得注意的是，当你创建UI时，与Canvas一起创建了一个名为**EventSystem**的第二个对象。这个对象对于渲染UI不是必需的，但如果你想让UI可交互，即包括点击按钮、在字段中输入文本或使用摇杆导航UI等操作，则是必需的。**EventSystem**组件负责采样用户输入，例如使用键盘、鼠标或摇杆，并将这些数据发送到UI以做出相应反应。我们可以更改与UI交互的确切按钮，但默认设置目前是可接受的，所以只需知道，如果你想与UI交互，你需要这个对象。如果由于某种原因你删除了这个对象，你可以在**GameObject**
    | **UI** | **Event System**中重新创建它。
- en: You’re building a great foundation. Keep this momentum going, as the principles
    you’re learning now will be vital as you advance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在建立一个坚实的基础。保持这种势头，因为你现在学习的原则在你进步的过程中将至关重要。
- en: Positioning elements with RectTransform
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RectTransform定位元素
- en: In Unity UI, each image, text, and element you see in the UI is a GameObject
    with a set of proper components according to its usage, but you will see that
    most of them have one component in common—**RectTransform**. Each piece of the
    UI is essentially a rectangle filled with text or images and has different behavior,
    so it is important to understand how the **RectTransform** component works and
    how to edit it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity UI中，你看到的每个图像、文本和UI元素都是一个GameObject，根据其用途具有一组适当的组件，但你将看到它们大多数都有一个共同的组件——**RectTransform**。UI的每一部分本质上都是一个填充文本或图像的矩形，并且具有不同的行为，因此理解**RectTransform**组件的工作原理以及如何编辑它非常重要。
- en: 'In order to experiment with this component, let’s create and edit the position
    of a simple white box element for the UI as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验这个组件，让我们按照以下步骤创建并编辑UI中一个简单的白色框元素的定位：
- en: 'Go to **GameObject | UI | Image**. After that, you will see that a new GameObject
    is created within the **Canvas** element. Unity will take care of setting any
    new UI element as a child of the Canvas; outside it, the element will not be visible:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**GameObject | UI | Image**。之后，你将看到在**Canvas**元素内创建了一个新的GameObject。Unity将负责将任何新的UI元素设置为Canvas的子元素；否则，该元素将不可见：
- en: '![](img/B21361_15_02_PE.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_02_PE.png)'
- en: 'Figure 15.2: A default image UI element—a white box'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：默认图像UI元素——一个白色框
- en: 'Click on the **2D** button in the top bar of the **Scene** view. This will
    just change the perspective of the **Scene** view to one that is better suited
    to edit the UI (and also 2D games):'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**场景**视图顶部栏中的**2D**按钮。这将仅更改**场景**视图的视角，使其更适合编辑UI（以及2D游戏）：
- en: '![A picture containing screenshot, text, font, number  Description automatically
    generated](img/B21361_15_03_PE.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、文本、字体、数字的图片，自动生成描述](img/B21361_15_03_PE.png)'
- en: 'Figure 15.3: The 2D button location'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：2D按钮位置
- en: Double-click on the Canvas in the **Hierarchy** window to make the UI fit entirely
    in the **Scene** view. This will allow us to edit the UI clearly. You can also
    navigate the UI using the mouse scroll wheel to zoom, and click and drag the scroll
    wheel to pan the camera.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**层次结构**窗口中的Canvas，使UI完全适应**场景**视图。这将允许我们清楚地编辑UI。您还可以使用鼠标滚轮导航UI进行缩放，并单击并拖动滚轮进行相机平移。
- en: Enable the **RectTransform** tool, which is the fifth button in the top-left
    part of the Unity Editor (or press the *T* key). This will enable the rectangle
    gizmo, which allows you to move, rotate, and scale 2D elements. While the transform
    tools we have used so far work with the UI, they are not ideal. One example is
    that changing the size of a UI element is not the same as scaling the element;
    we want to modify the width and height of the element but keep its scale for animations,
    preventing distortion in 9-sliced images (there’s more on this later in this chapter).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**RectTransform**工具，这是Unity编辑器左上角第五个按钮（或按*T*键）。这将启用矩形操纵，允许您移动、旋转和缩放2D元素。虽然我们迄今为止使用的变换工具与UI一起工作，但它们并不理想。一个例子是，改变UI元素的大小并不等同于缩放元素；我们希望修改元素的宽度和高度，但保持其缩放以进行动画，防止9切片图像变形（关于这一点，本章后面将详细介绍）。
- en: '![A picture containing text, screenshot, design  Description automatically
    generated](img/B21361_15_04_PE.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、设计的图片，自动生成描述](img/B21361_15_04_PE.png)'
- en: 'Figure 15.4: The rectangle gizmo button'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：矩形操纵按钮
- en: 'Using the rectangle gizmo, drag the object to move it, use the blue dots to
    change its size, or locate the mouse in a position near the blue dots until the
    cursor becomes a curved arrow to rotate it. Consider that resizing the object
    using this gizmo is not the same as scaling the object (there’ll be more on that
    shortly):'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用矩形操纵，拖动对象进行移动，使用蓝色点更改其大小，或将鼠标定位在蓝色点附近，直到光标变成曲线箭头以旋转它。请注意，使用此操纵器调整对象大小并不等同于缩放对象（关于这一点，稍后将详细介绍）：
- en: '![](img/B21361_15_05_PE.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_05_PE.png)'
- en: 'Figure 15.5: The rectangle gizmo for editing 2D elements'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：编辑2D元素的矩形操纵
- en: 'In the **Inspector** window, notice that after changing the size of the UI
    element, the **Rect Transform** settings’ **Scale** property is still at `1`,
    `1`, `1`, but you can see how the **Width** and **Height** properties changed.
    **RectTransform** is essentially a classic transform but with **Width** and **Height**
    added (among other properties that we’ll explore later). You can set the exact
    values you want here, expressed in pixels:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，注意在更改UI元素的大小后，**RectTransform**设置的**缩放**属性仍然是`1`，`1`，`1`，但您可以看到**宽度**和**高度**属性是如何变化的。**RectTransform**本质上是一个经典的变换，但增加了**宽度**和**高度**（以及其他我们稍后会探索的属性）。您可以在这里设置您想要的精确值，以像素为单位表示：
- en: '![](img/B21361_15_06_PE.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_06_PE.png)'
- en: 'Figure 15.6: The Rect Transform properties'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6：RectTransform属性
- en: Now that we know the very basics of how to position any UI object, let’s explore
    the different types of elements you can add to the Canvas.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何定位任何UI对象的基础知识，让我们探索您可以添加到Canvas的不同类型的元素。
- en: Canvas object types
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Canvas对象类型
- en: So far, we have used the simplest Canvas object type—a white box—but there are
    plenty of other object types we can use, such as images, buttons, and text. All
    of them use **RectTransform** to define their display area, but each one has its
    own concepts and configurations to understand.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了最简单的Canvas对象类型——一个白色框，但还有许多其他对象类型我们可以使用，例如图像、按钮和文本。所有这些都使用**RectTransform**来定义它们的显示区域，但每个都有其自己的概念和配置需要理解。
- en: 'In this section, we will explore the following Canvas object concepts:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索以下Canvas对象概念：
- en: Integrating assets for the UI
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成UI的资产
- en: Creating UI controls
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建UI控件
- en: Let’s first start exploring how we can integrate images and fonts to use in
    our Canvas so that we can integrate them in our UI, using the **Images** and **Text**
    UI object types.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先探索如何将图像和字体集成到Canvas中使用，这样我们就可以使用**图像**和**文本**UI对象类型将它们集成到我们的UI中。
- en: Integrating assets for the UI
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成UI的资产
- en: 'Before making our UI use nice graphics assets, we need to integrate them properly
    into Unity to use them in our UI. In the following screenshot, you will find the
    UI design we propose for our game:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作我们的UI使用漂亮的图形资产之前，我们需要将它们正确集成到Unity中，以便在UI中使用。在下面的截图中，您将找到我们为游戏提出的UI设计：
- en: '![](img/B21361_15_07_PE.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_07_PE.png)'
- en: 'Figure 15.7: UI design'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7：UI设计
- en: 'On top of that, we will add a **Pause** menu, which will be activated when
    the user presses *Esc*. It will look like the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将添加一个**暂停**菜单，当用户按下*Esc*键时将被激活。它看起来如下截图所示：
- en: '![](img/B21361_15_08_PE.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_08_PE.png)'
- en: 'Figure 15.8: The Pause menu design'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8：暂停菜单设计
- en: 'Based on these designs, we can determine that we will need the following assets:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些设计，我们可以确定我们需要以下资产：
- en: The hero’s avatar image
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英雄的化身图像
- en: A health bar image
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康条图像
- en: A **Pause** menu background image
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停菜单背景图像
- en: A **Pause** menu button image
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停菜单按钮图像
- en: Font for the text
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本的字体
- en: 'As always, we can find the required assets on the internet or in the Asset
    Store. In my case, I will use a mixture of both. Let’s start with the simplest
    one—the avatar. Follow the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们可以在互联网上或资产商店中找到所需的资产。在我的情况下，我将使用两者的混合。让我们从最简单的一个开始——头像。按照以下步骤操作：
- en: Download the avatar you want from the internet, such as an image with the face
    of a character.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从互联网上下载您想要的头像，例如一个角色的面部图像。
- en: Add it to your project, either by dragging it to the **Project** window or by
    using the **Assets | Import New Asset** option. Add it to the `Sprites` folder.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其添加到您的项目中，无论是通过将其拖动到**项目**窗口，还是通过使用**资产 | 导入新资产**选项。将其添加到`精灵`文件夹中。
- en: Select the texture, and in the **Inspector** window, set the **Texture Type**
    setting to **Sprite (2D and UI)**. All textures are prepared for use in 3D by
    default. This option prepares our texture to be used in 2D contexts, like the
    UI and also 2D games.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择纹理，并在**检查器**窗口中，将**纹理类型**设置设置为**精灵（2D和UI）**。默认情况下，所有纹理都为3D使用做好了准备。此选项将我们的纹理准备用于2D环境，如UI和2D游戏。
- en: For the bars, buttons, and the window background, I’ll show you how to pick
    the right assets from the Asset Store. It’s a goldmine for UI elements, and I’ll
    point out a few gems. In my case, I found the package in the following screenshot
    a good one to use with my UI. As usual, remember that this exact package might
    not be available right now.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于条形、按钮和窗口背景，我将向您展示如何从资源商店中选择正确的资源。这是一个UI元素的宝库，我会指出一些宝石。在我的情况下，我发现以下截图中的包非常适合我的UI。像往常一样，请记住，这个确切的包可能现在不可用。
- en: 'If so, remember to look for another similar package, or pick the sprites from
    the GitHub repo:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，请记得寻找另一个类似的包，或者从GitHub仓库中选择精灵：
- en: '![A screenshot of a video game  Description automatically generated](img/B21361_15_09_PE.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏截图，自动生成描述](img/B21361_15_09_PE.png)'
- en: 'Figure 15.9: Selected UI pack'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9：选定的UI包
- en: At first, the package contains lots of images configured the same way, as sprites,
    but we can further modify the import settings to achieve advanced behavior, which
    we will need for the buttons. The button asset comes with a fixed size, but what
    happens if you need a bigger button? One option is to use other button assets
    with different sizes, but this will lead to a lot of repetitions of the buttons
    and other assets, such as different-sized backgrounds for different windows, which
    will unnecessarily consume RAM.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该包包含大量配置相同的图像，作为精灵，但我们可以进一步修改导入设置以实现高级行为，这对于按钮是必需的。按钮资源具有固定的大小，但如果您需要一个更大的按钮怎么办？一个选项是使用具有不同大小的其他按钮资源，但这会导致按钮和其他资源（如不同大小的窗口背景）的大量重复，这会不必要地消耗RAM。
- en: Another option is to use the **9-slicing** method, which consists of splitting
    an image so that the corners are separated from the other parts. This allows Unity
    to stretch the middle parts of the image to fit different sizes, keeping the corners
    at their original size, which, when combined with an image prepared for the 9-slices
    technique, can be used to create almost any size you need.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用**9分割**方法，该方法包括将图像分割，使角落与其他部分分离。这允许Unity拉伸图像的中间部分以适应不同的大小，同时保持角落的原始大小，当与为9分割技术准备的图像结合使用时，可以用来创建几乎任何所需的大小。
- en: 'In *Figure 15.10*, you can see a shape with nine slices in the bottom-left
    corner, and in the bottom-right corner of the same diagram, you can see the shape
    is stretched but keeps its corners at their original size. The top-right corner
    shows the shape stretched without slices. You can see how the non-sliced version
    is distorted:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图15.10*中，您可以看到左下角有一个九个分割的形状，在相同图表的右下角，您可以看到形状被拉伸但保持了原始大小的角落。右上角显示了没有分割的拉伸形状。您可以看到非分割版本是如何变形的：
- en: '![A picture containing screenshot, rectangle, square, line  Description automatically
    generated](img/B21361_15_10_PE.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、矩形、正方形、线的图片，自动生成描述](img/B21361_15_10_PE.png)'
- en: 'Figure 15.10: Sliced versus non-sliced image stretching'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10：分割与非分割图像拉伸对比
- en: 'In this case, we can apply the nine slices to the button and the panel background
    images to use them in different parts of our game. In order to do this, do the
    following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以将九分割应用于按钮和面板背景图像，以便在游戏的各个部分使用它们。为了做到这一点，请按照以下步骤操作：
- en: Open Package Manager using the **Window | Package Manager** option.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**窗口 | 包管理器**选项打开包管理器。
- en: Verify that Package Manager shows all the packages, by setting the dropdown
    to the right of the **+** button in the top-left part of the window to **Unity
    Registry**.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将窗口左上角**+**按钮右侧的下拉菜单设置为**Unity Registry**，验证包管理器是否显示了所有包。
- en: Install the 2D Sprite package to enable the sprite editing tools (if it is not
    already installed).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装2D精灵包以启用精灵编辑工具（如果尚未安装）。
- en: 'Select the button sprite in the **Project** window, and click on the **Sprite
    Editor** button in the **Inspector** window:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中选择按钮精灵，然后在**检查器**窗口中点击**精灵编辑器**按钮：
- en: '![](img/B21361_15_11_PE.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_11_PE.png)'
- en: 'Figure 15.11: The Sprite Editor button in the Inspector window'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11：检查器窗口中的精灵编辑器按钮
- en: In the **Sprite Editor** window, locate and drag the green dots at the edges
    of the image to move the slice rulers. Try to ensure that the slices are not located
    in the middle of the edges of the button. One thing to notice is that, in our
    case, we will work with three slices instead of nine because our button won’t
    be stretched vertically. If you don’t see the dots, try clicking the image to
    make them appear.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**精灵编辑器**窗口中，找到并拖动图像边缘的绿色点来移动切片标尺。尽量确保切片不在按钮边缘的中间。要注意的一点是，在我们的情况下，我们将使用三个切片而不是九个，因为我们的按钮不会垂直拉伸。如果你看不到点，尝试点击图像使它们出现。
- en: Note that after dragging the green dots, the **Border** properties (**L**, **T**,
    **R**, and **B**, which are left, top, right, and bottom, respectively) in the
    bottom-right corner changed. Those are the exact values you set by moving the
    green dots. Feel free to change them to more round numbers to allow the nine slices
    to work evenly. In our case, left and right became a round **60**, and top and
    bottom **50**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在拖动绿色点之后，底右角的**边框**属性（**L**、**T**、**R**和**B**，分别是左、上、右和下）发生了变化。这些就是通过移动绿色点设置的精确值。你可以随意将它们改为更圆的数字，以便九个切片均匀工作。在我们的情况下，左右变成了圆整的**60**，上下变成了**50**。
- en: 'Click on the **Apply** button in the top-right corner of the window and close
    it:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口右上角的**应用**按钮并关闭它：
- en: '![](img/B21361_15_12_PE.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_12_PE.png)'
- en: 'Figure 15.12: Nine slices in the Sprite Editor window'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12：精灵编辑器窗口中的九个切片
- en: Repeat *steps 4* to *6* for the **Background** panel image. In my case, you
    can see in *Figure 15.13* that this background is not completely prepared with
    nine slices in mind because all the middle areas of the image can be made smaller
    to save memory.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对**背景**面板图像重复*步骤4*到*6*。在我的情况下，你可以在*图15.13*中看到这个背景并不是完全按照九个切片来准备的，因为图像的所有中间区域都可以缩小以节省内存。
- en: 'When displaying this image with a smaller width, the 9-slicing method will
    stretch the middle part and will look the same, so essentially, this is wasted
    memory:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当以较小的宽度显示此图像时，9切片方法会拉伸中间部分，看起来相同，所以本质上，这是浪费的内存：
- en: '![](img/B21361_15_13_PE.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_13_PE.png)'
- en: 'Figure 15.13: Nine slices in the Sprite Editor window'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13：精灵编辑器窗口中的九个切片
- en: By removing the middle parts, the image will look almost the same, but a big
    part of the memory was saved, as seen in the following image.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除中间部分，图像看起来几乎相同，但节省了大量的内存，如以下图像所示。
- en: '![](img/B21361_15_14.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_14.png)'
- en: 'Figure 15.14: Optimized 9-slices background. The middle part will be a 1px
    strip of pixels that will expand'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14：优化的9切片背景。中间部分将是一个1像素宽的像素条，将会扩展
- en: Now that we have prepared our sprites, we can find a font to customize the text
    of our UI. Before discussing how to import fonts, it is worth mentioning that
    we will use **TextMesh Pro**, a Unity package (already included in the project)
    that provides a text rendering solution much better than the old text component.
    If you have never used that component before, you shouldn’t worry about this detail.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了精灵，我们可以找到一个字体来自定义UI的文本。在讨论如何导入字体之前，值得提一下，我们将使用**TextMesh Pro**，这是一个Unity包（已包含在项目中），它提供了一个比旧文本组件更好的文本渲染解决方案。如果你之前从未使用过该组件，你不必担心这个细节。
- en: 'You must get fonts in the `.ttf` or `.otf` formats and import them into Unity.
    You can find lots of good, free font websites on the internet. I am used to working
    with the classic DaFont.com site, but there are plenty of other sites that you
    can use. In my case, I will work with the `Militech` font:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须获取`.ttf`或`.otf`格式的字体并将它们导入Unity。互联网上有很多好的免费字体网站。我习惯于使用经典的DaFont.com网站，但还有很多其他你可以使用的网站。在我的情况下，我将使用`Militech`字体：
- en: '![A picture containing text, font, screenshot, graphics  Description automatically
    generated](img/B21361_15_15_PE.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、截图、图形的图片，描述自动生成](img/B21361_15_15_PE.png)'
- en: 'Figure 15.15: My chosen font from DaFont.com to use in the project'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15：我在DaFont.com上选择的字体，用于项目
- en: 'If the font download comes with more than one file, you can just drag them
    all into Unity and then use the one that you like the most. Also, as usual, try
    to put the font inside a folder called `Fonts`. Now, these files’ format is not
    compatible with TextMesh Pro, our text rendering solution, so we must convert
    it using the **Font Asset Creator** window, as illustrated in the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字体下载包含多个文件，你只需将它们全部拖入Unity，然后使用你最喜欢的一个。同样，像往常一样，尽量将字体放在名为`Fonts`的文件夹中。现在，这些文件的格式与我们的文本渲染解决方案TextMesh
    Pro不兼容，因此我们必须使用**字体资产创建器**窗口进行转换，如下面的步骤所示：
- en: Go to **Window | TextMesh Pro | Font Asset** Creator.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**窗口 | TextMesh Pro | 字体资产**创建器。
- en: 'If this is the first time you have used TextMesh Pro in your project, a window
    will appear. You must click the **Import TMP Essentials** option and wait for
    the import process to finish:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你第一次在你的项目中使用TextMesh Pro，会出现一个窗口。你必须点击**导入 TMP 基础组件**选项，并等待导入过程完成：
- en: '![](img/B21361_15_16_PE.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_16_PE.png)'
- en: 'Figure 15.16: TextMesh Pro first-run initialization'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16：TextMesh Pro首次运行初始化
- en: Close the **TMP Importer** window.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**TMP 导入器**窗口。
- en: In **Font Asset Creator**, drag your font from the **Project** view to **Source
    Font File**, or select it by clicking the **Target** button on the right (the
    circle with the point at the center).
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**字体资产创建器**中，将你的字体从**项目**视图拖到**源字体文件**，或者通过点击右侧的**目标**按钮（中心带点的圆圈）来选择它。
- en: 'Click the **Generate Font Atlas** button and wait a moment:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**生成字体图集**按钮，稍等片刻：
- en: '![](img/B21361_15_17_PE.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_17_PE.png)'
- en: 'Figure 15.17: Converting font assets to TextMesh Pro'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.17：将字体资产转换为TextMesh Pro
- en: 'Click the **Save** button, and save the converted font in the **Assets | TextMesh
    Pro | Fonts** folder. Saving here is important, so don’t forget to pick the correct
    folder:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**按钮，并将转换后的字体保存到**资产 | TextMesh Pro | 字体**文件夹。在这里保存很重要，所以不要忘记选择正确的文件夹：
- en: '![](img/B21361_15_18.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_18.png)'
- en: 'Figure 15.18: Saving the converted font in the correct folder (Mac)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.18：在正确的文件夹中保存转换后的字体（Mac）
- en: You’ve got the groundwork set up. Let’s add more elements and see our UI come
    to life. The skills you’re learning here will be invaluable as you progress to
    the later chapters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经搭建好了基础。让我们添加更多元素，看看我们的UI如何变得生动。你在这里学到的技能在你进入后面的章节时将非常有价值。
- en: Creating UI controls
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建UI控件
- en: 'Each UI component, a blend of images and text, needs thoughtful configuration.
    Let’s dive into how these elements come together to form an intuitive interface.
    We already have an image in our UI—the white rectangle we created previously.
    If you select it and look at the **Inspector** window, you will notice that it
    has an **Image** component, like the one in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个UI组件，图像和文本的混合，都需要仔细的配置。让我们深入了解这些元素如何组合在一起形成一个直观的界面。在我们的UI中已经有一个图像——我们之前创建的白色矩形。如果你选择它并查看**检查器**窗口，你会注意到它有一个**图像**组件，就像以下截图中的那样：
- en: '![](img/B21361_15_19_PE.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_19_PE.png)'
- en: 'Figure 15.19: The Image component’s Inspector window'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.19：图像组件的检查器窗口
- en: 'Understanding these settings is crucial for optimal UI display. We’ll begin
    with the hero’s avatar, focusing on how to best represent it within our UI:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些设置对于最佳的UI显示至关重要。我们将从英雄的头像开始，关注如何在我们的UI中最好地表示它：
- en: 'Using the rectangle gizmo, move the white rectangle to the top-left part of
    the UI:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用矩形操纵杆，将白色矩形移动到UI的左上角：
- en: '![A picture containing screenshot, rectangle, line, square  Description automatically
    generated](img/B21361_15_20_PE.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![包含截图、矩形、线条、方形的图片  描述由中等置信度自动生成](img/B21361_15_20_PE.png)'
- en: 'Figure 15.20: The white rectangle located in the top-left part of the UI'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.20：位于UI左上角的白色矩形
- en: 'In the **Inspector** window, click on the circle to the right of the **Source
    Image** property and pick the downloaded hero avatar sprite:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，点击**源图像**属性右侧的圆圈，并选择下载的英雄头像精灵：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_15_21_PE.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由中等置信度自动生成](img/B21361_15_21_PE.png)'
- en: 'Figure 15.21: Setting the sprite of our Image component'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.21：设置图像组件的精灵
- en: 'Keeping the right aspect ratio ensures the image looks consistent on different
    screen sizes, avoiding any visual distortion. One way to do this is to click the
    **Set Native Size** button at the bottom of the Ima**ge** component to make the
    image use the same size as the original sprite. However, by doing this, the image
    can become too big, so you can reduce the image size by pressing *Shift* to modify
    both the **Width** and **Height** values. Another option is to check the **Preserve
    Aspect** checkbox to make sure the image fits the rectangle without stretching.
    In my case, I will use both:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持正确的宽高比确保图像在不同屏幕尺寸上看起来一致，避免任何视觉扭曲。一种方法是点击图像组件底部的**设置原生大小**按钮，使图像使用与原始精灵相同的大小。然而，这样做会使图像变得过大，因此您可以按*Shift*键修改**宽度**和**高度**值以减小图像大小。另一种选项是勾选**保持宽高比**复选框以确保图像适合矩形而不拉伸。在我的情况下，我将使用两者：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_15_22_PE.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动生成，中等置信度](img/B21361_15_22_PE.png)'
- en: 'Figure 15.22: The Preserve Aspect and Set Native Size image options'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.22：保持宽高比和设置原生大小的图像选项
- en: 'Creating an intuitive life bar is crucial for the player experience. Let’s
    create the life bars by doing the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建直观的生命条对于玩家体验至关重要。让我们通过以下步骤创建生命条：
- en: Create another **Image** component using the **GameObject** | **UI** | **Image**
    option.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**GameObject**|**UI**|**图像**选项创建另一个**图像**组件。
- en: 'Set the **Source Image** property to the life bar image you downloaded:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**源图像**属性设置为下载的生命条图像：
- en: '![](img/B21361_15_23_PE.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B21361_15_23_PE.png]'
- en: 'Figure 15.23: The avatar and life bar'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.23：头像和生命条
- en: Set the **Image Type** property to **Filled**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**图像类型**属性设置为**填充**。
- en: Set the **Fill Method** property to **Horizontal**.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**填充方法**属性设置为**水平**。
- en: 'Drag the **Fill Amount** slider to see how the bar is cut according to the
    value of the slider. We will change that value via scripting later in *Chapter
    18*, *Performance Wizardry: Optimizing Your Game with Profiler Tools*:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动**填充量**滑块以查看根据滑块值如何切割条。我们将在第*18*章中通过脚本更改该值，*性能巫术：使用分析工具优化您的游戏*：
- en: '![](img/B21361_15_24_PE.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B21361_15_24_PE.png]'
- en: 'Figure 15.24: The Fill Amount slider, cutting the image width to 73% of its
    size'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.24：填充量滑块，切割图像宽度至其大小的73%
- en: 'In my case, the bar image also comes with a bar frame, which lets you create
    another image, set the sprite, and position it on top of the life bar to frame
    it. The order in the hierarchy here impacts the visual stacking of these elements.
    This positioning is key for achieving the desired visual effect. So, in my case,
    I need to be sure the frame GameObject is below the health bar image in the hierarchy.
    Also, note that the bar frame image is not sliced, so there’s no need to use the
    **Sliced** **Image** **Type** in this case. Feel free to try slicing it and see
    the results:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我的情况下，条图像还附带了一个条框架，这允许您创建另一个图像，设置精灵，并将其放置在生命条上方以框架它。这里的层次结构顺序会影响这些元素的视觉堆叠。这种定位对于实现所需的视觉效果至关重要。因此，在我的情况下，我需要确保框架GameObject在层次结构中位于健康条图像下方。此外，请注意，条框架图像未切片，因此在这种情况下不需要使用**切片****图像****类型**。您可以随意尝试切片它并查看结果：
- en: '![](img/B21361_15_25_PE.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B21361_15_25_PE.png]'
- en: 'Figure 15.25: Putting one image on top of the other to create a frame effect'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.25：将一个图像放在另一个图像上方以创建框架效果
- en: 'Repeat *steps 1* to *6* to create the base bar at the bottom, or just copy
    and paste the bar and the frame and place it at the bottom of the screen:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤 1*到*6*以创建底部的基线条，或者只需复制并粘贴条和框架，并将其放置在屏幕底部：
- en: '![](img/B21361_15_26_PE.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B21361_15_26_PE.png]'
- en: 'Figure 15.26: The player’s and player’s base health bars'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.26：玩家和玩家基地生命条
- en: Click on the **+** button in the **Project** window and select the **Sprites**
    | **Square** option. This will create a simple squared sprite with a 4x4 resolution.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中点击**+**按钮，并选择**精灵**|**正方形**选项。这将创建一个具有4x4分辨率的简单方形精灵。
- en: Set the sprite as the base bar of the player’s base health bar instead of the
    downloaded bar sprite. This time, we will use a plain-white image for the bar
    because, in my case, the original one is red, and tinting the color of a red image
    to green is not possible. However, a white image can be easily tinted. Take into
    account the details of the original bar—for example, the little shadow in my original
    bar won’t be present here.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将精灵设置为玩家基础生命条的基础条，而不是下载的条精灵。这次，我们将使用纯白色图像作为条，因为在我的情况下，原始的是红色，将红色图像的颜色调整为绿色是不可能的。然而，白色图像可以被轻松着色。考虑到原始条的具体细节——例如，我原始条中的小阴影在这里将不会出现。
- en: 'Select the base health bar and set the **Color** property to green:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择基础生命条并将**颜色**属性设置为绿色：
- en: '![](img/B21361_15_27_PE.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_27_PE.png)'
- en: 'Figure 15.27: A bar with a squared sprite and green tint'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.27：一个带有方形精灵和绿色色调的条
- en: One optional step would be to convert the bar frame image into a 9-sliced image
    to allow us to change the original width to fit the screen.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个可选步骤是将条框图像转换为9切片图像，以便我们可以更改原始宽度以适应屏幕。
- en: 'Now, let’s add the text fields for the **Score**, **Bullets**, **Remaining
    Waves**, and **Remaining Enemies** labels by doing the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过以下步骤添加**得分**、**子弹**、**剩余波次**和**剩余敌人**标签的文本字段：
- en: Create a text label using the **GameObject** | **UI** | **Text - TextMesh Pro**
    option (avoid the option that only says **Text**). This will be the **Score**
    label.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**GameObject** | **UI** | **Text - TextMesh Pro**选项创建一个文本标签（避免只说**Text**的选项）。这将作为**得分**标签。
- en: Position the label in the top-right part of the screen.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签放置在屏幕的右上角。
- en: 'In the **Inspector** window, set the content of the **Text Input** property
    to `Score: 0`.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在**Inspector**窗口中，将**Text Input**属性的内容设置为`Score: 0`。'
- en: Set the **Font Size** property to `20`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**字体大小**属性设置为`20`。
- en: Apply the converted font by clicking on the circle to the right of the **Font
    Asset** property and selecting the desired font.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**Font Asset**属性右侧的圆圈并选择所需的字体来应用转换后的字体。
- en: 'In the **Alignment** property, select the **Horizontal Right Align** icon (the
    third button in the first row) and the **Vertical Center Align** icon (the second
    button in the second row):'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**对齐**属性中，选择**水平右对齐**图标（第一行的第三个按钮）和**垂直居中对齐**图标（第二行的第二个按钮）：
- en: '![](img/B21361_15_28_PE.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_28_PE.png)'
- en: 'Figure 15.28: The settings for a text label'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.28：文本标签的设置
- en: 'Repeat *steps 1* to *6* to create the other three labels (or just copy and
    paste the score three times). For the **Remaining Waves** label, you can use the
    left alignment option to better match the original design:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤1*到*6*以创建其他三个标签（或者只需复制粘贴得分三次）。对于**剩余波次**标签，可以使用左对齐选项以更好地匹配原始设计：
- en: '![](img/B21361_15_29_PE.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_29_PE.png)'
- en: 'Figure 15.29: All the labels for our UI'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.29：我们UI中的所有标签
- en: Set the color of all the labels to white, as our scene will be mainly dark.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有标签的颜色设置为白色，因为我们的场景将主要是暗色调。
- en: 'Now that we have completed the original UI design, we can create the **Pause**
    menu:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了原始UI设计，我们可以创建**暂停**菜单：
- en: Create an **Image** component for the menu’s background (**GameObject** | **UI**
    | **Image**).
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为菜单的背景创建一个**Image**组件（**GameObject** | **UI** | **Image**）。
- en: Set the **Background** panel sprite with the nine slices we made earlier.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前制作的九个切片设置**Background**面板的精灵。
- en: Set the **Image Type** property to **Sliced** if it is not already. This mode
    will apply the 9-slice scaling method to prevent the corners from stretching.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未设置，将**Image Type**属性设置为**Sliced**。此模式将应用9切片缩放方法以防止角落拉伸。
- en: There’s a chance that the image will stretch the corners anyway, which happens
    because sometimes the corners are quite big compared to the **RectTransform**
    settings’ **Size** property that you are using, so Unity has no option other than
    to do that. In this scenario, the correct solution is to have an artist who creates
    assets tailored to your game, but sometimes we don’t have that option. This time,
    we can just increase the **Pixels Per Unit** value of the sprite file, which will
    reduce the scale of the original image while preserving its resolution. In the
    following two screenshots, you can see the background image with a **Pixels Per
    Unit** value of `100`, and then again with `700`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有可能无论如何图像都会拉伸角落，这是因为有时角落相对于您使用的**RectTransform**设置的**大小**属性相当大，所以Unity别无选择，只能这样做。在这种情况下，正确的解决方案是让一位艺术家为您创建适合您游戏的资产，但有时我们并没有这样的选择。这次，我们可以简单地增加精灵文件的**每单位像素**值，这将减小原始图像的缩放，同时保持其分辨率。在下面的两个截图中，您可以看到具有**每单位像素**值为`100`的背景图像，然后再次设置为`700`。
- en: 'Remember to only do this for the 9-sliced or tiled-image types, or if you don’t
    have an artist to adjust it for you:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住，只为9分割或平铺图像类型做这件事，或者如果您没有艺术家来调整它：
- en: '![A screenshot of a video game  Description automatically generated](img/B21361_15_30_PE.png)'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![视频游戏截图  自动生成描述](img/B21361_15_30_PE.png)'
- en: 'Figure 15.30: On top, a large 9-sliced image in a small RectTransform component,
    which is small enough to shrink the corners, and at the bottom, the same image
    with Pixels Per Unit set to 700'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.30：顶部，一个大的9分割图像在一个小的RectTransform组件中，它足够小以至于可以缩小角落，底部，相同的图像，将**每单位像素**设置为700
- en: Create a **TextMesh Pro** text field, position it where you want the **Pause**
    label to be in your diagram, set it to display the **Pause** text, and set the
    font. Remember that you can change the text color with the **Color** property.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**TextMesh Pro**文本字段，将其放置在您想要在图中显示**暂停**标签的位置，设置为显示**暂停**文本，并设置字体。请记住，您可以使用**颜色**属性更改文本颜色。
- en: 'Drag the text field onto the background image. The parenting system in **Canvas**
    works the same—if you move the parent, the children will move with it. The idea
    is that if we disable the panel, it will also disable the buttons and all its
    content:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本字段拖到背景图像上。**Canvas**中的父子关系系统工作方式相同——如果您移动父项，子项也会随之移动。想法是，如果我们禁用面板，它也会禁用按钮及其所有内容：
- en: '![](img/B21361_15_31_PE.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_31_PE.png)'
- en: 'Figure 15.31: The Pause label'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.31：暂停标签
- en: Create two buttons by going to **GameObject** | **UI** | **Button - TextMesh
    Pro** (avoid using the one that only says **Button**). Position them where you
    want them on the background image.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**GameObject** | **UI** | **Button - TextMesh Pro**（避免使用只说**按钮**的那个）创建两个按钮。将它们放置在背景图像上您想要的位置。
- en: Set them as children of the **Pause** background image by dragging them into
    the **Hierarchy** window.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将它们拖入**层次结构**窗口，将它们设置为**暂停**背景图像的子项。
- en: Select the buttons, and set the **Source Image** property of their **Image**
    components to use the button sprite that we downloaded earlier. Remember our **Pixels
    Per Unit** fix from *step 4* in this list if you have the same problem as before.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择按钮，并将它们**Image**组件的**源图像**属性设置为使用我们之前下载的按钮精灵。如果您遇到之前的问题，请记住我们*步骤4*中的**每单位像素**修复。
- en: 'You will see that the button is essentially an image with a child **TextMesh
    Pro** text object. Change the font of each button and the text in each one to
    `Resume` and `Quit`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会看到按钮本质上是一个带有子**TextMesh Pro**文本对象的图像。将每个按钮和每个文本的字体更改为`Resume`和`Quit`：
- en: '![](img/B21361_15_32_PE.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_32_PE.png)'
- en: 'Figure 15.32: The Pause menu implementation'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.32：暂停菜单实现
- en: 'Remember that you can hide the panel, by unchecking the checkbox to the right
    of the object name in the top part of the **Inspector** window:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，您可以通过取消勾选**检查器**窗口顶部对象名称右侧的复选框来隐藏面板：
- en: '![A screenshot of a computer menu  Description automatically generated with
    medium confidence](img/B21361_15_33_PE.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![计算机菜单截图  自动生成描述，中等置信度](img/B21361_15_33_PE.png)'
- en: 'Figure 15.33: Disabling a GameObject'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.33：禁用GameObject
- en: Today, I still remember my first sessions of playtesting, where I handed my
    game over to unknown people with the dream of amazing them with my great game,
    just to discover it wasn’t quite the case. Among lots of things you will discover
    that are missing in your game is User Experience (also known as UX). The key to
    it is to understand how the game flow feels and improve it. While the UX is not
    restricted to the UI only, I recommend researching this concept before designing
    UIs for your game, as it will help your user to better understand your game and
    the information the UI tries to give.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我仍然记得我的第一次游戏测试，当时我把我的游戏交给了一些陌生人，希望用我出色的游戏让他们感到惊讶，结果却发现并非如此。在游戏中你会发现很多缺失的东西，其中之一就是用户体验（也称为UX）。关键在于理解游戏流程的感觉并改进它。虽然用户体验不仅仅局限于用户界面，但我建议在为你的游戏设计用户界面之前研究这个概念，因为它将帮助用户更好地理解你的游戏以及用户界面试图传达的信息。
- en: In this section, we discussed how to import images and fonts to be integrated
    through the **Image**, **Text**, and **Button** components to create a rich and
    informative UI. Having done that, let’s discuss how to make them responsive.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何通过**图像**、**文本**和**按钮**组件导入图像和字体，以创建丰富且信息丰富的UI。完成这些后，让我们讨论如何使它们具有响应性。
- en: Creating a responsive UI
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建响应式用户界面
- en: Nowadays, it is almost impossible to design a UI in a single resolution, and
    our target audience display devices can vary a lot. A PC has a variety of different
    kinds of monitors with different resolutions (such as 1080p and 4K) and aspect
    ratios (such as 16:9, 16:10, and ultra-wide), and the same goes for mobile devices.
    We need to prepare our UI to adapt to the most common displays, and Unity UI has
    the tools needed to do so.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，几乎不可能在单个分辨率下设计UI，我们的目标受众的显示设备可能会有很大的差异。一台PC有多种不同类型的显示器，具有不同的分辨率（如1080p和4K）和纵横比（如16:9、16:10和超宽），移动设备也是如此。我们需要准备我们的UI以适应最常见的显示，Unity
    UI有完成这一任务的工具。
- en: 'In this section, we will explore the following UI responsiveness concepts:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下用户界面响应性概念：
- en: Adapting object positions
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整对象位置
- en: Adapting object sizes
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整对象大小
- en: We are going to explore how the UI elements can adapt their position and size
    to different screen sizes using the advanced features of the **Canvas** and **RectTransform**
    components, such as **Anchors** and **Scalers**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索如何使用**画布**和**RectTransform**组件的高级功能，如**锚点**和**缩放器**，来使UI元素适应不同的屏幕尺寸。
- en: Adapting object positions
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整对象位置
- en: To ensure our UI adjusts correctly across different devices, let’s focus on
    adapting object positions using anchors.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的用户界面能够正确地适应不同的设备，让我们专注于使用锚点来调整对象位置。
- en: 'Right now, if we play our game, we will see how the UI fits nicely onto our
    screen. However, if for some reason we change the **Game** view size, we will
    see how objects start to disappear from the screen. In the following screenshots,
    you can see different-sized game windows and how the UI looks nice in one but
    bad in the others:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果我们运行我们的游戏，我们会看到用户界面如何很好地适应我们的屏幕。然而，如果由于某种原因我们改变了**游戏**视图的大小，我们会看到对象开始从屏幕上消失。在下面的屏幕截图中，你可以看到不同大小的游戏窗口以及用户界面在一个窗口中看起来很棒，而在其他窗口中则不好：
- en: '![](img/B21361_15_34_PE.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_34_PE.png)'
- en: 'Figure 15.34: The same UI but on different-sized screens'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.34：相同的UI但在不同大小的屏幕上
- en: The problem is that we created the UI using whatever resolution we had in the
    editor, but as soon as we changed it slightly, the UI kept its design for the
    previous resolution. Also, if you look closely, you will see that the UI is always
    centered, such as in the second image, where the UI is cropped at its sides, or
    in the third image, where extra space is visible along the borders of the screen.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们使用编辑器中拥有的任何分辨率创建了UI，但一旦我们稍微改变它，UI就保持了之前分辨率的布局。此外，如果你仔细看，你会看到UI总是居中的，比如在第二张图片中，UI在两侧被裁剪，或者在第三张图片中，屏幕边缘可以看到额外的空间。
- en: 'This happens because every single element in the UI has its own anchor, a little
    cross you can see when you select an object, such as the one in the following
    screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为UI中的每个元素都有自己的锚点，当你选择一个对象时，你可以看到一个小的十字，如下面的屏幕截图所示：
- en: '![](img/B21361_15_35_PE.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_35_PE.png)'
- en: 'Figure 15.35: An anchor cross in the bottom-right part of the screen belonging
    to the hero avatar in the top-left part of the screen'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.35：屏幕右上角属于屏幕左上角英雄头像的锚点十字
- en: The *x* and *y* position of the object is measured as a distance to that anchor,
    and the anchor has a position relative to the screen, with its default position
    being at the center of the screen. This means that on an *800 x 600* screen, the
    anchor will be placed at the *400 x 300* position, and on a *1920 x 1080* screen,
    the anchor will be located at the *960 x 540* position. If the *x* and *y* position
    of the element (the one in **RectTransform**) is **0**, the object will always
    be at a distance of 0 from the center. In the second screenshot of the previous
    three examples, the hero avatar falls outside of the screen because its distance
    from the center is greater than half the screen, and the current distance was
    calculated based on the previous bigger screen size. So, what we can do about
    that? Move the anchor!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的*x*和*y*位置是以到该锚点的距离来测量的，锚点相对于屏幕有一个位置，其默认位置是屏幕中心。这意味着在一个*800 x 600*的屏幕上，锚点将被放置在*400
    x 300*的位置，在一个*1920 x 1080*的屏幕上，锚点将位于*960 x 540*的位置。如果元素的*x*和*y*位置（在**RectTransform**中的那个）是**0**，则对象将始终与中心保持0的距离。在前三个示例的第二张截图中，英雄头像超出了屏幕范围，因为其与中心的距离大于屏幕的一半，而当前距离是基于之前更大的屏幕尺寸计算的。那么我们能做什么呢？移动锚点！
- en: By setting a relative position, we can position the anchor at different parts
    of our screen and make that part of the screen our reference position. In the
    case of our hero avatar, we can place the anchor in the top-left corner of the
    screen to guarantee that our avatar will be at a fixed distance from that corner.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置相对位置，我们可以将锚点放置在屏幕的不同部分，并使该部分成为我们的参考位置。在我们的英雄头像的情况下，我们可以将锚点放置在屏幕的左上角，以确保我们的头像将始终与该角落保持固定距离。
- en: 'We can do that by following these steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤实现：
- en: Select your player avatar.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的玩家头像。
- en: Expand the **RectTranform** component in **Inspector**, if not expanded yet,
    in a way that you can see its properties. This will reveal the anchors in the
    **Scene** view.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未展开，请在**检查器**中展开**RectTranform**组件，以便可以看到其属性。这将揭示**场景**视图中的锚点。
- en: 'Drag the anchor cross with your mouse to the top-left part of the screen. If,
    for some reason, the anchor breaks into pieces when you drag it, undo the change
    (press *Ctrl* + *Z*, or *Command* + *Z* on Mac) and try to drag it by clicking
    in the center. We will break the anchor later. Check the avatar image **RectTransform**
    component to verify that the **Anchors** property’s **Min** and **Max** sub-properties
    have the same values as in *Figure 15.36*, meaning the object has correctly configured
    the anchors to be in the top-left part of the screen:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用鼠标将锚点十字形拖动到屏幕的左上角。如果由于某种原因，在拖动锚点时它断裂成几块，撤销更改（按*Ctrl* + *Z*，或在Mac上按*Command*
    + *Z*）并尝试通过点击中心来拖动它。我们稍后会断开锚点。检查头像图像的**RectTransform**组件，以验证**锚点**属性的**最小值**和**最大值**子属性与*图15.36*中的值相同，这意味着对象已正确配置锚点以位于屏幕的左上角：
- en: '![](img/B21361_15_36_PE.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_36_PE.png)'
- en: 'Figure 15.36: An image with an anchor in the top-left part of the screen'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.36：屏幕左上角带有锚点的图像
- en: Put the anchor of the **Health Bar** object and its frame in the same position.
    We want the bar to always be at the same distance from that corner so that it
    will move alongside the hero avatar if the screen size changes.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**生命条**对象的锚点和其框架放在相同的位置。我们希望条形始终与该角落保持相同的距离，以便在屏幕大小改变时它将随英雄头像移动。
- en: Place the anchor in the bottom-center part of the screen for the **Boss Bar**
    object so that it will always be centered. Later, we will deal with adjusting
    its size.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Boss Bar**对象的锚点放置在屏幕的底部中央，以便它始终居中。稍后我们将处理调整其大小的问题。
- en: 'Put the **Remaining Waves** label in the bottom-left corner, and **Remaining
    Enemies** in the bottom-right corner:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**剩余波**标签放在左下角，**剩余敌人**放在右下角：
- en: '![](img/B21361_15_37_PE.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_37_PE.png)'
- en: 'Figure 15.37: The anchors for the life bar and the labels'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.37：生命条和标签的锚点
- en: 'Put the **Score** and **Bullets** anchors in the top-right corner:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**得分**和**子弹**的锚点放在右上角：
- en: '![](img/B21361_15_38_PE.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_38_PE.png)'
- en: 'Figure 15.38: The anchors for the Score and Bullets labels'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.38：得分和子弹标签的锚点
- en: 'Select any element, and drag the sides of the Canvas rectangle with your mouse
    to preview how the elements will adapt to their positions. Take into account that
    you must select any object that is a direct child of the Canvas; the text within
    the buttons won’t have that option:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何元素，并使用鼠标拖动画布矩形的边缘来预览元素将如何适应其位置。请注意，你必须选择Canvas的直接子对象；按钮内的文本不会有这个选项：
- en: '![](img/B21361_15_39_PE.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_39_PE.png)'
- en: 'Figure 15.39: Previewing the Canvas resizing'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.39：预览Canvas调整大小
- en: Now that our UI elements have adapted to their positions, let’s consider scenarios
    where the object size must adapt as well.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将UI元素调整到它们的位置，让我们考虑那些对象大小也必须适应的场景。
- en: Adapting object sizes
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整对象大小
- en: The first thing to consider when dealing with different aspect ratios is that
    our screen elements may not only move from their original design position (which
    we fixed in the previous section) but also may not fit into the original design.
    In our UI, we have the case of the health bar, where the bar clearly doesn’t adapt
    to the screen width when we preview it on a wider screen. We can fix this by breaking
    our anchors.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 处理不同宽高比时首先要考虑的是，我们的屏幕元素不仅可能从它们原始的设计位置（我们在上一节中固定了该位置）移动，还可能无法适应原始设计。在我们的UI中，我们遇到了健康条的情况，当我们在更宽的屏幕上预览时，条显然没有适应屏幕宽度。我们可以通过断开锚点来解决这个问题。
- en: 'When we break our anchors, the position and size of our object are calculated
    as a distance relative to the different anchor parts. If we split the anchor horizontally,
    instead of having **X** and **Width** properties we will have **Left** and **Right**
    properties, representing the distance between the left and right anchor. We can
    use this in the following way:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们断开锚点时，我们的对象的位置和大小是相对于不同锚点部分的距离来计算的。如果我们水平分割锚点，那么我们将有**左**和**右**属性，而不是**X**和**宽度**属性，它们代表左右锚点之间的距离。我们可以用以下方式使用它：
- en: Select the health bar, and drag the left part of the anchor all the way to the
    left part of the screen and the right part to the right part of the screen.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择健康条，并将锚点的左侧拖动到屏幕的左侧，右侧拖动到屏幕的右侧。
- en: 'Do the same for the health bar frame:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对健康条框架也做同样的操作：
- en: '![](img/B21361_15_40_PE.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_40_PE.png)'
- en: 'Figure 15.40: The splitter anchor in the health bar'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.40：健康条中的分割锚点
- en: 'Check the **Rect Transform** settings’ **Left** and **Right** properties in
    the **Inspector** window, which represent the current distance to their respective
    anchors. If you want, you can add a specific value, especially if your health
    bars are displayed outside the screen:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中检查**矩形变换**设置的**左**和**右**属性，它们代表到相应锚点的当前距离。如果你想，你可以添加一个特定的值，特别是如果你的健康条显示在屏幕外：
- en: '![](img/B21361_15_41_PE.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_41_PE.png)'
- en: 'Figure 15.41: The Left and Right properties of a split anchor'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.41：分割锚点的左和右属性
- en: Using the Canvas Scaler effectively helps maintain UI element proportions across
    various resolutions, a crucial aspect of modern game design.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有效地使用Canvas缩放器有助于在不同分辨率下保持UI元素的比例，这是现代游戏设计的一个关键方面。
- en: 'This way, the object will always be at a fixed distance of a relative position
    to the screen—in this case, the sides of the screen. If you are working with a
    child object, as is the case with the **Text** and **Image** components of the
    buttons, the anchors are relative to the parent. If you pay attention to the anchors
    of the text, they are not only split horizontally but also vertically. This allows
    the text to adapt its position to the size of the button, so you won’t have to
    change it manually:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，对象将始终保持在屏幕相对位置的一个固定距离——在这个例子中，是屏幕的边缘。如果你正在处理子对象，例如按钮的**文本**和**图像**组件，锚点相对于父对象。如果你注意文本的锚点，它们不仅在水平方向上分割，还在垂直方向上分割。这允许文本根据按钮的大小调整其位置，因此你不需要手动更改它：
- en: '![](img/B21361_15_42_PE.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_42_PE.png)'
- en: 'Figure 15.42: The split anchors of the text of the button'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.42：按钮文本的分割锚点
- en: Now, this solution is not suitable for all scenarios. Let’s consider a case
    where the hero avatar is displayed in a higher resolution than what it was designed
    for. Even if the avatar is correctly placed, it will be displayed smaller because
    the screen has more pixels per inch than screens with lower resolutions and the
    same physical size. You could consider using split anchors, but the width and
    height anchors could be scaled differently on different aspect ratio screens,
    so the original image becomes distorted. Instead, we can use the **Canvas Scaler**
    component.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个解决方案并不适用于所有场景。让我们考虑一个英雄头像显示的分辨率高于其设计分辨率的案例。即使头像放置正确，它也会显示得更小，因为屏幕每英寸像素数比分辨率较低的屏幕多，并且物理尺寸相同。你可以考虑使用分割锚点，但宽度和高度锚点在不同宽高比屏幕上可能以不同的方式缩放，因此原始图像会变形。相反，我们可以使用**画布缩放器**组件。
- en: The **Canvas Scaler** component defines what one pixel means in our scenario.
    If our UI design resolution is 1080p but we see it on a 4K display (which is twice
    the horizontal and vertical resolution of 1080p, meaning four times the number
    of pixels), we can scale the UI so that a pixel becomes two pixels, adapting its
    size to keep the same proportional size as the original design. Basically, the
    idea is that if the screen is bigger, our elements should also be bigger.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**画布缩放器**组件定义了在我们的场景中一个像素代表什么。如果我们的UI设计分辨率为1080p，但我们看到它在一个4K显示器上（这意味着水平方向和垂直方向分辨率是1080p的两倍，即像素数是四倍），我们可以缩放UI，使一个像素变为两个像素，调整其大小以保持与原始设计相同的比例大小。基本上，这个想法是，如果屏幕更大，我们的元素也应该更大。'
- en: 'We can use this component by doing the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式使用此组件：
- en: Select the **Canvas** object, and locate the **Canvas Scaler** component in
    the **Inspector** window.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**画布**对象，并在**检查器**窗口中定位**画布缩放器**组件。
- en: Set the **UI Scale Mode** property to **Scale With Screen Size**.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**UI缩放模式**属性设置为**随屏幕大小缩放**。
- en: If working with an artist, set the reference resolution to the resolution in
    which the artist created the UI, keeping in mind that it must be the highest target
    device resolution (this isn’t the case for us). In our case, we are not sure which
    resolution the artist of the downloaded assets had in mind, so we can select `1920
    x 1080`, which is the full HD resolution size and is very common nowadays.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果与艺术家合作，将参考分辨率设置为艺术家创建UI的分辨率，同时记住它必须是最高目标设备分辨率（对我们来说并非如此）。在我们的例子中，我们不确定下载的资产艺术家心中所想的分辨率，因此我们可以选择`1920
    x 1080`，这是全高清分辨率大小，并且现在非常常见。
- en: Set the **Match** property to **Height**. The idea of this property is that
    it sets which side of the resolution will be considered when carrying out the
    scaling calculation. In our case, if we are playing the game in 1080p resolution,
    1 UI pixel equals 1 real screen pixel. However, if we are playing in 720p resolution,
    1 UI pixel will be 0.6 real pixels, so the elements will be smaller on smaller-resolution
    screens, keeping the correct size. We didn’t choose a **Width** value in this
    case because we can have extreme widths of screens, such as ultra-wide, and if
    we picked that option, those screens would scale the UI unnecessarily. Another
    option is to set this value to `0.5` to consider the two values, but on a PC,
    this doesn’t make too much sense. On a mobile device, you should choose this based
    on the orientation of the game, setting the height for landscape mode and the
    width for portrait mode.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**匹配**属性设置为**高度**。此属性的目的是在执行缩放计算时确定要考虑的分辨率哪一侧。在我们的例子中，如果我们以1080p分辨率玩游戏，1个UI像素等于1个实际屏幕像素。然而，如果我们以720p分辨率玩游戏，1个UI像素将是0.6个实际像素，因此元素在较小分辨率的屏幕上会变得更小，保持正确的尺寸。我们没有选择**宽度**值，因为我们可能遇到极端的屏幕宽度，例如超宽屏幕，如果我们选择了该选项，这些屏幕将不必要地缩放UI。另一个选项是将此值设置为`0.5`以考虑两个值，但在PC上这并没有太多意义。在移动设备上，你应该根据游戏的方向来选择，为横屏模式设置高度，为竖屏模式设置宽度。
- en: 'Try previewing a wider and higher screen to see how this setting works:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试预览一个更宽更高的屏幕，以查看此设置如何工作：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_15_43_PE.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动生成描述，置信度低](img/B21361_15_43_PE.png)'
- en: 'Figure 15.43: Canvas Scaler with the correct settings for standard PC games'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.43：适用于标准PC游戏的Canvas缩放器设置
- en: You will find that your UI will be smaller than your original design, which
    is because we should have set these properties before. Right now, the only fix
    is to resize everything again. Take this into account the next time you try this
    exercise; we only followed this order for learning purposes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现你的UI将比原始设计更小，这是因为我们本应该在此之前设置这些属性。现在，唯一的解决办法是再次调整所有元素的大小。下次尝试这个练习时要考虑到这一点；我们只遵循这个顺序是为了学习目的。
- en: 'Another way to make your UI adapt to its contents is by using layout components,
    like Horizonal Layout. These components will automatically adapt the size and
    position of their child elements to follow certain rules, like making sure all
    elements are next to each other. This is especially useful in things like item
    lists, where you add and remove elements, and you can expect the list to adapt
    to these changes. For more info, check out this documentation: [https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/comp-UIAutoLayout.html](mailto:https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/comp-UIAutoLayout.html)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的UI适应其内容的另一种方法是使用布局组件，如水平布局。这些组件将自动调整其子元素的大小和位置，以遵循某些规则，例如确保所有元素都相邻。这在像物品列表这样的地方特别有用，你可以在其中添加和删除元素，并期望列表适应这些变化。更多信息，请参阅此文档：[https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/comp-UIAutoLayout.html](mailto:https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/comp-UIAutoLayout.html)
- en: With this knowledge, you are now ready to start scripting the UI to reflect
    what’s happening in the game.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识后，你现在可以开始编写脚本以反映游戏中的情况来构建用户界面了。
- en: Scripting the UI
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写UI脚本
- en: 'We previously created a UI layout with elements such as bars, text, and buttons,
    but so far, they are static. We need to make them adapt to the game’s actual state.
    In this section, we are going to discuss the following UI scripting concepts:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建了一个包含条、文本和按钮等元素的UI布局，但到目前为止，它们是静态的。我们需要让它们适应游戏的实际状态。在本节中，我们将讨论以下UI脚本概念：
- en: Showing information in the UI
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UI中显示信息
- en: Programming the Pause menu
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程暂停菜单
- en: We will start by seeing how to display and update dynamic information in our
    UI, using scripts that modify the text and images that are displayed with Canvas
    elements. After that, we will create thepause functionality, which will be used
    throughout the UI. Developing the pause functionality is more than just adding
    a feature; it’s about enhancing user control and game interaction, a key aspect
    of the UX.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解如何使用修改Canvas元素显示的文本和图像的脚本来显示和更新UI中的动态信息。之后，我们将创建暂停功能，该功能将在整个UI中使用。开发暂停功能不仅仅是添加一个功能；它关乎增强用户控制和游戏交互，这是用户体验的关键方面。
- en: Armed with this understanding, you’re set to bring your game’s UI to an interactive
    level. It’s time to make your UI not just a visual element but also an integral
    part of your game’s storytelling.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这种理解，你已经准备好将你的游戏UI提升到交互式水平。现在是时候让你的UI不仅仅是一个视觉元素，而是成为你游戏叙事的有机组成部分了。
- en: Showing information in the UI
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在UI中显示信息
- en: 'We’ve touched on using the UI to convey critical game data. Now, let’s dive
    into the practical aspect: scripting the UI to dynamically reflect the player’s
    health status in real time, using the `Life` script we created earlier:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何使用UI传达关键游戏数据。现在，让我们深入实际方面：使用我们之前创建的`Life`脚本，实时动态地反映玩家的健康状态：
- en: 'Add a new script called **Life Bar** to the **HealthBar** Canvas child object,
    which is the UI **Image** component we created earlier to represent the life bar:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个名为**生命条**的新脚本添加到**健康条**画布子对象中，这是我们之前创建的UI **图像**组件，用于表示生命条：
- en: '![](img/B21361_15_44_PE.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_44_PE.png)'
- en: 'Figure 15.44: The Life Bar component in the player’s HealthBar Canvas'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.44：玩家健康条画布中的生命条组件
- en: 'In `LifeBar`, the script adds a `Life` type field. This way, our script will
    ask the editor which `Life` component we will be monitoring. Save the script:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LifeBar`脚本中，添加了一个`Life`类型字段。这样，我们的脚本将询问编辑器我们将监控哪个`Life`组件。保存脚本：
- en: '![](img/B21361_15_45_PE.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_45_PE.png)'
- en: 'Figure 15.45: Editor-configurable reference to a Life component'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.45：编辑器可配置的生命条组件引用
- en: 'In the editor, drag the **Player** GameObject from the **Hierarchy** window
    to the **Target Life** property to make the life bar reference the player’s life,
    and remember to have the **HealthBar** object selected before dragging **Player**.
    This way, we tell our **LifeBar** script which Life component to check to see
    how much life the player has remaining. Something interesting here is that the
    enemies have the same Life component, so we can easily use this component to create
    life bars for every other object that has a life in our game:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，从**层次结构**窗口拖动**Player**GameObject到**目标生命**属性，使生命条引用玩家的生命，记得在拖动**Player**之前选择**HealthBar**对象。这样，我们就告诉我们的**LifeBar**脚本检查哪个生命组件以查看玩家剩余的生命。这里有趣的是，敌人也有相同的生命组件，因此我们可以轻松地使用这个组件为游戏中所有有生命的其他对象创建生命条：
- en: '![A screen shot of a computer  Description automatically generated with low
    confidence](img/B21361_15_46_PE.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成，置信度低](img/B21361_15_46_PE.png)'
- en: 'Figure 15.46: Dragging Player to reference its Life component'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.46：拖动玩家以引用其生命组件
- en: 'Add the `using UnityEngine.UI;` line right after the `using` statements in
    the first few lines of the script. This will tell C# that we will interact with
    the UI scripts:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本的前几行`using`语句之后添加`using UnityEngine.UI;`行。这将告诉C#我们将与UI脚本交互：
- en: '![](img/B21361_15_47_PE.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_47_PE.png)'
- en: 'Figure 15.47: All the using statements in our script. We are not going to use
    them all, but let’s keep them for now'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.47：我们脚本中的所有使用语句。我们不会使用它们全部，但现在让我们保留它们
- en: 'Create a `private` field (without the `public` keyword) of the `Image` type.
    We will save the reference to the component here shortly:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`private`类型的`Image`字段（不使用`public`关键字）。我们很快就会在这里保存组件的引用：
- en: '![](img/B21361_15_48_PE.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_48_PE.png)'
- en: 'Figure 15.48: Private reference to an image'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.48：对图像的私有引用
- en: 'Using `GetComponent` in `Awake`, access the reference to the `Image` component
    in our GameObject (`HealthBar`) and save it in the `image` field. As usual, the
    idea is to get this reference just once and save it for later use in the `Update`
    function. Of course, this will always work when you put this component in an object
    with an `Image` component. If not, the other option would be to create a public
    field of the `Image` type and drag the image component into it:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`中使用`GetComponent`获取我们GameObject（`HealthBar`）中的`Image`组件引用，并将其保存在`image`字段中。通常，我们的想法是只获取这个引用一次，并在`Update`函数中稍后使用。当然，当你把这个组件放在一个带有`Image`组件的对象中时，这总是可行的。如果不是这样，另一种选择是创建一个`Image`类型的公共字段，并将图像组件拖入其中：
- en: '![A picture containing text, font, screenshot, line  Description automatically
    generated](img/B21361_15_49_PE.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、屏幕截图、行描述的图片，自动生成](img/B21361_15_49_PE.png)'
- en: 'Figure 15.49: Saving the reference to the Image component in this object'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.49：在此对象中保存Image组件的引用
- en: Let’s set up an `Update` event function in the `LifeBar` script. This function
    will be the heart of our UI update logic, keeping the health bar in sync with
    the player’s health.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`LifeBar`脚本中设置一个`Update`事件函数。这个函数将是我们的UI更新逻辑的核心，使生命条与玩家的健康保持同步。
- en: In the `Update` event, divide the amount of life by `100` to have our current
    life percentage expressed in the `0` to `1` range (assuming our maximum life is
    `100`), and set the result in the `fillAmount` field of the `Image` component,
    as shown in the following screenshot. Remember that `fillAmount` expects a value
    between `0` and `1`, with `0` signaling that the bar is empty and `1` signaling
    that the bar is at its full capacity:![A picture containing text, font, screenshot,
    line  Description automatically generated](img/B21361_15_50_PE.png)
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`事件中，将生命量除以`100`，以便将当前生命百分比表示在`0`到`1`的范围内（假设最大生命值为`100`），并将结果设置在`Image`组件的`fillAmount`字段中，如以下截图所示。请记住，`fillAmount`期望一个介于`0`和`1`之间的值，其中`0`表示条是空的，`1`表示条已满：![包含文本、字体、屏幕截图、行描述的图片，自动生成](img/B21361_15_50_PE.png)
- en: 'Figure 15.50: Updating the fill amount of the LifeBar script’s Image component
    according to the Life component'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.50：根据生命组件更新LifeBar脚本Image组件的填充量
- en: Using a specific number like 100 directly in the code is a classic example of
    hardcoding. To maintain flexibility, consider referencing a `Maximum Life` field
    or using a constant.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在代码中直接使用特定的数字，如100，是硬编码的经典例子。为了保持灵活性，考虑引用`Maximum Life`字段或使用一个常量。
- en: 'Save the script, and in the editor, select the player and play the game. During
    **Play** mode, press *Esc* to regain access to the mouse, and change the player’s
    health in the **Inspector** window to see how the life bar updates accordingly.
    You can also test this by making the player receive damage somehow, such as by
    making enemies spawn bullets (there’ll be more on enemies later):'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，并在编辑器中选择玩家并开始游戏。在**Play**模式下，按*Esc*键以恢复鼠标访问权限，并在**Inspector**窗口中更改玩家的健康值以查看生命条如何相应更新。你也可以通过让玩家以某种方式受到伤害来测试这一点，例如让敌人发射子弹（稍后会有更多关于敌人的内容）：
- en: '![](img/B21361_15_51_PE.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_51_PE.png)'
- en: 'Figure 15.51: Full LifeBar script'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.51：完整的LifeBar脚本
- en: In the previous chapter, we explored the concept of events to detect changes
    in the state of other objects. The life bar is another example of using an event,
    as we can change the fill amount of the image when the life actually changes.
    I challenge you to try to create an event when the life changes and implement
    this script using the one we looked at in the previous chapter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了事件的概念，用于检测其他对象状态的变化。生命条是使用事件的另一个例子，因为当生命值实际变化时，我们可以改变图像的填充量。我挑战你尝试在生命值变化时创建一个事件，并使用我们在上一章中查看的脚本实现此脚本。
- en: You may be thinking that this UI behavior could be directly coded within the
    `Life` component, and that’s completely possible, but the idea here is to create
    simple scripts with little pressure to keep our code separated. Each script should
    have just one reason to be modified, and mixing UI behavior and gameplay behavior
    in a single script would give the script two responsibilities, which results in
    two possible reasons to change our script. With this approach, we can also set
    the player’s base life bar at the bottom by just adding the same script to its
    life bar but dragging the **Base Damage** object, which we created in the previous
    chapter, as the target life this time.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，这种UI行为可以直接在`Life`组件中编码，这是完全可能的，但这里的想法是创建简单的脚本，减少对代码的压力，使代码分离。每个脚本应该只有一个修改的理由，将UI行为和游戏行为混合在单个脚本中会给脚本两个责任，从而导致两个可能改变脚本的原因。采用这种方法，我们也可以通过将相同的脚本添加到玩家的生命条上，并将我们在上一章中创建的**Base
    Damage**对象作为这次的目标生命值，来设置玩家的基础生命条在底部。
- en: 'For those using visual scripting, here’s a breakdown of what you’ll need to
    integrate. It’s about translating our C# logic into a more visual, node-based
    format:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用视觉脚本的玩家，以下是你需要集成的分解。这是将我们的C#逻辑转换为一个更直观、基于节点的格式：
- en: '![](img/B21361_15_52_PE.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_52_PE.png)'
- en: 'Figure 15.52: Full LifeBar visual graph'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.52：完整的LifeBar视觉图表
- en: First, we added a `targetLife` variable of type `GameObject` to the **Variables**
    component of our life bar image. Then, we dragged our **Player** GameObject (called
    **Robot** so far) to this variable; the life bar now has a reference to the object
    from which we want to display its life. Then, we added a **LifeBar** visual graph;
    in the **Update** node, it calls the **Set Fill Amount** node in order to update
    the fill amount of the image. Remember that, in this case, just calling the **Set
    Fill Amount** node will show that we refer to the image component where this visual
    graph is located, so there’s no need to use **GetComponent** here. In order to
    calculate the fill amount, we get the **targetLife** GameObject reference, and,
    using a second **Get Variable** node, we extract the life variable of that object.
    Finally, we divide that by 100 (we needed to create a **Float Literal** node in
    order to represent the value **100**) and pass that to the **Set Fill Amount**
    node. As usual, you can check the complete version on the GitHub repository.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在生命条图片的**变量**组件中添加了一个类型为`GameObject`的`targetLife`变量。然后，我们将我们的**Player**
    GameObject（目前称为**Robot**）拖拽到这个变量上；生命条现在有了我们想要显示其生命值的对象的引用。接着，我们添加了一个**LifeBar**视觉图表；在**Update**节点中，它调用**Set
    Fill Amount**节点来更新图像的填充量。记住，在这种情况下，仅仅调用**Set Fill Amount**节点就会显示我们引用的是这个视觉图表所在的位置的图像组件，因此在这里不需要使用**GetComponent**。为了计算填充量，我们获取**targetLife**
    GameObject的引用，并使用第二个**Get Variable**节点提取该对象的生命变量。最后，我们将这个值除以100（我们需要创建一个**Float
    Literal**节点来表示值**100**）并将结果传递给**Set Fill Amount**节点。像往常一样，你可以在GitHub仓库中查看完整的版本。
- en: The principle we applied here – single object responsibility – is part of the
    broader **SOLID** principles in object-oriented programming. These principles
    are foundational for robust and scalable code architecture. If you don’t know
    what SOLID is, I strongly recommend you search for `SOLID programming principles`
    on the internet to improve your programming best practices.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里应用的原则——单一对象职责——是面向对象编程中更广泛的**SOLID**原则的一部分。这些原则是构建健壮和可扩展代码架构的基础。如果您不知道SOLID是什么，我强烈建议您在网上搜索`SOLID编程原则`以提高您的编程最佳实践。
- en: 'Now that we have sorted out the player’s life bar, let’s make the `Bullets`
    label update according to the player’s remaining bullets. Something to consider
    here is that our current `PlayerShooting` script has unlimited bullets, so let’s
    change that by following these steps:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理好了玩家的生命条，让我们让`Bullets`标签根据玩家的剩余子弹更新。这里需要考虑的是，我们当前的`PlayerShooting`脚本具有无限子弹，所以让我们通过以下步骤来改变这一点：
- en: Add a public `int` type field to the `PlayerShooting` script, called `bulletsAmount`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerShooting`脚本中添加一个公共的`int`类型字段，命名为`bulletsAmount`。
- en: In the `if` statement that checks the pressure of the left mouse button, add
    a condition to check whether the number of bullets is greater than `0`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查左鼠标按钮压力的`if`语句中，添加一个条件来检查子弹数量是否大于`0`。
- en: 'Inside the `if` statement, reduce the number of bullets by `1`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if`语句中，将子弹数量减少`1`：
- en: '![](img/B21361_15_53_PE.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_53_PE.png)'
- en: 'Figure 15.53: Limiting the number of bullets to shoot'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.53：限制射击子弹的数量
- en: 'In the visual scripting version, the modified shooting condition of the **PlayerShooting**
    visual graph will look like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在视觉脚本版本中，**PlayerShooting**视觉图的修改后的射击条件将看起来像这样：
- en: '![](img/B21361_15_54_PE.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_15_54_PE.png)'
- en: 'Figure 15.54: Shooting only if bullets are available and reducing the number
    of bullets after shooting'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.54：仅在子弹可用时射击，并在射击后减少子弹数量
- en: 'As you can see, we simply check if the new **bullets** variable we added is
    greater than zero and then use an **If** node condition for the execution of the
    **Instantiate** node. The bullet decrement will look like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是检查我们添加的新**子弹**变量是否大于零，然后使用**If**节点条件来执行**Instantiate**节点。子弹递减将看起来像这样：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21361_15_55_PE.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、聊天或文本消息  自动生成的描述](img/B21361_15_55_PE.png)'
- en: 'Figure 15.55: Decrementing the bullet count in the visual graph'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.55：在视觉图中递减子弹计数
- en: We simply subtract one from the **bullets** variable and set the bullets again
    with this value.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是从**子弹**变量中减去一个，然后用这个值再次设置子弹。
- en: 'With a dedicated counter for bullets in place, our next step is to bring this
    element to life in the UI. Visualizing the bullet count is not just a feature
    – it’s an essential aspect of gameplay that keeps players tactically aware:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在子弹计数器就位后，我们的下一步是将这个元素在UI中激活。可视化子弹计数不仅是一个功能，而且是游戏玩法的一个基本方面，它使玩家在战术上保持警觉：
- en: Add a `PlayerBulletsUI` script to the bullet’s `Text` GameObject. In my case,
    I called it `Bullets Label`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PlayerBulletsUI`脚本添加到子弹的`Text`GameObject中。在我的例子中，我将其命名为`Bullets Label`。
- en: Add the `using TMPro;` statement at the beginning of the file, given that we
    will modify the `TextMesh Pro` component of our label.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件开头添加`using TMPro;`语句，因为我们将会修改标签的`TextMesh Pro`组件。
- en: 'Add a private field of the `TMP_Text` type, saving it in the reference to the
    `Text` component in `Awake`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`TMP_Text`类型的私有字段，在`Awake`中将它保存到`Text`组件的引用中：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21361_15_56_PE.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、电子邮件  自动生成的描述](img/B21361_15_56_PE.png)'
- en: 'Figure 15.56: Caching the reference to the Text component'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.56：缓存Text组件的引用
- en: Create a `public` field of the `PlayerShooting` type called `targetShooting`,
    and drag **Player** to this property in the Editor. As was the case for the `LifeBar`
    component, the idea is that our UI script will access the script that has the
    remaining bullets to update the text, bridging the two scripts (`Text` and `PlayerShooting`)
    to keep their responsibilities separated.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`targetShooting`的`PlayerShooting`类型的公共字段，并在编辑器中将**Player**拖到这个属性上。与`LifeBar`组件的情况一样，我们的想法是UI脚本将访问具有剩余子弹的脚本以更新文本，连接两个脚本（`Text`和`PlayerShooting`），以保持它们职责的分离。
- en: 'Create an `Update` statement, and inside it, set the `text` field of the text
    reference (I know, confusing) with a concatenation of `"Bullets: "` and the `bulletsAmount`
    field of the `targetShooting` reference. This way, we will replace the text of
    the label according to the current amount of bullets:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个`Update`语句，并在其中设置文本引用的`text`字段（我知道，有点混乱）为`"Bullets: "`和`targetShooting`引用的`bulletsAmount`字段的连接。这样，我们将根据当前子弹数量替换标签的文本：'
- en: '![A picture containing chart  Description automatically generated](img/B21361_15_57_PE.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![包含图表的图片，描述自动生成](img/B21361_15_57_PE.png)'
- en: 'Figure 15.57: Updating the Bullets text label'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.57：更新子弹文本标签
- en: A key coding principle to remember is that string concatenation allocates memory.
    To maintain optimal performance, it’s prudent to concatenate strings only when
    it’s essential – a strategic approach to memory management in game development.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个关键编码原则是字符串连接会分配内存。为了保持最佳性能，仅在必要时连接字符串——这是游戏开发中内存管理的策略性方法。
- en: 'Regarding visual scripting, before actually setting the text, we need to add
    support for TextMesh Pro in visual scripting. Visual scripting requires manually
    specifying which Unity systems and packages we are going to use, and as TextMesh
    Pro is not strictly a core Unity feature, it might not be included by default.
    We can add support for TextMesh Pro in visual scripting by doing the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本，在实际上设置文本之前，我们需要在视觉脚本中添加对TextMesh Pro的支持。视觉脚本需要手动指定我们将要使用的Unity系统和包，由于TextMesh
    Pro不是严格的核心Unity功能，它可能默认不包含。我们可以通过以下方式在视觉脚本中添加对TextMesh Pro的支持：
- en: Go to **Edit | Project Settings** and select the **Visual Scripting** category.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**编辑 | 项目设置**并选择**视觉脚本**类别。
- en: Expand the **Node Library** option using the arrow to its left.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用左侧的箭头展开**节点库**选项。
- en: Check if you have **Unity.TextMesh Pro** in that list. If you do, feel free
    to skip the rest of these steps.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查列表中是否有**Unity.TextMesh Pro**。如果有，请随意跳过以下步骤。
- en: Use the **+** button at the bottom of the list to add a new library.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用列表底部的**+**按钮添加一个新的库。
- en: Click where it says (**No Assembly**), and search for **Unity.TextMesh Pro**.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击显示为（**无需组装**）的位置，并搜索**Unity.TextMesh Pro**。
- en: 'Click the **Regenerate Nodes** button, and wait until the regeneration process
    is done:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**重新生成节点**按钮，等待直到生成过程完成：
- en: '![](img/B21361_15_58_PE.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_58_PE.png)'
- en: 'Figure 15.58: Adding TextMesh Pro support to visual scripting'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.58：将TextMesh Pro支持添加到视觉脚本
- en: 'After making those settings, this is what the visual graph to add to the **Bullets**
    text GameObject will look like:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些设置后，这将是要添加到**子弹**文本GameObject的视觉图：
- en: '![](img/B21361_15_59_PE.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_15_59_PE.png)'
- en: 'Figure 15.59: Updating the Bullets text label in visual scripting'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.59：在视觉脚本中更新子弹文本标签
- en: 'As usual, we need a reference to the player to check its bullets, so we created
    a `targetBullets` variable of type **GameObject** and dragged the **Player** there.
    Then, we use a **Get Variable** node to extract the bullets amount from that reference
    and concatenate the string `"Bullets: "`, using the **String Literal** node, with
    the amount of bullets using the **Concat** node. That node will do the same as
    when we added two strings together using the **+** operator in C#. Finally, we
    use the **Set Text (Source Text, Sync Text InputBox)** node to update the text
    of our text field.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '如同往常，我们需要一个对玩家的引用来检查其子弹，所以我们创建了一个类型为**GameObject**的`targetBullets`变量并将**玩家**拖放到那里。然后，我们使用**获取变量**节点从该引用中提取子弹数量，并使用**字符串字面量**节点和**连接**节点将字符串`"Bullets:
    "`与子弹数量连接起来。该节点将执行与我们在C#中使用**+**运算符将两个字符串连接起来时相同的功能。最后，我们使用**设置文本（源文本，同步文本输入框）**节点来更新文本字段的文本。'
- en: If you look at the two scripts, you will find a pattern. You can access the
    **UI** and **Gameplay** components and update the **UI** component accordingly,
    and most UI scripts will behave in the same way. Keeping this in mind, I challenge
    you to create the necessary scripts to make the **Score**, **Enemies**, and **Waves**
    counters work. Remember to add `using TMPro;` to use the `TMP_Text` component.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这两个脚本，你会找到一个模式。你可以访问**UI**和**游戏玩法**组件，并相应地更新**UI**组件，并且大多数UI脚本的行为方式相同。记住这一点，我挑战你创建必要的脚本，使**得分**、**敌人**和**波**计数器工作。记得添加`using
    TMPro;`以使用`TMP_Text`组件。
- en: 'After finishing this, you can compare your solution with the one in the following
    screenshot, starting with `ScoreUI`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，你可以将你的解决方案与以下截图中的解决方案进行比较，从`ScoreUI`开始：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21361_15_60_PE.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，自动生成描述](img/B21361_15_60_PE.png)'
- en: 'Figure 15.60: The ScoreUI script'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.60：ScoreUI脚本
- en: 'Also, we need the `WavesUI` component:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要`WavesUI`组件：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21361_15_61_PE.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件，自动生成描述](img/B21361_15_61_PE.png)'
- en: 'Figure 15.61: The WavesUI script'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.61：WavesUI脚本
- en: 'Finally, we need `EnemiesUI`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要`EnemiesUI`：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21361_15_62_PE.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件，自动生成描述](img/B21361_15_62_PE.png)'
- en: 'Figure 15.62: The EnemiesUI script'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.62：EnemiesUI脚本
- en: Note how we took advantage of the existence of the **onChanged** events in the
    **WavesManager** and **EnemyManager** scripts to only update the text fields when
    needed. Also, note how we didn’t need to drag a reference to get the values to
    display, as all these scripts use managers to get that info.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何利用**WavesManager**和**EnemyManager**脚本中存在的**onChanged**事件的存在，仅在需要时更新文本字段。同时，注意我们不需要拖动引用来获取要显示的值，因为这些脚本都使用管理者来获取这些信息。
- en: 'Regarding visual scripting, we have the **ScoreUI** script:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本，我们有**ScoreUI**脚本：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21361_15_63_PE.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，聊天或文本消息，自动生成描述](img/B21361_15_63_PE.png)'
- en: 'Figure 15.63: The ScoreUI visual script'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.63：ScoreUI可视化脚本
- en: 'Then, the **WavesUI** script:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，**WavesUI**脚本：
- en: '![Graphical user interface, application  Description automatically generated](img/B21361_15_64_PE.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成描述](img/B21361_15_64_PE.png)'
- en: 'Figure 15.64: The WavesUI visual script'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.64：WavesUI可视化脚本
- en: 'And finally, the **EnemiesUI** script:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**EnemiesUI**脚本：
- en: '![Graphical user interface, application  Description automatically generated](img/B21361_15_65_PE.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成描述](img/B21361_15_65_PE.png)'
- en: 'Figure 15.65: The EnemiesUI visual script'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.65：EnemiesUI可视化脚本
- en: As you can see, we have used the events already coded in the managers to change
    the UI only when necessary. Also, note how we used **Scene** variables to get
    the info to display. With our UI labels and bars in place, our next step is to
    bring the Pause menu to life. This involves scripting interactions that enhance
    the game’s interactivity.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经使用在管理者中已经编码的事件来仅在必要时更改UI。同时，注意我们是如何使用**场景**变量来获取要显示的信息。有了我们的UI标签和条形图就绪，我们的下一步是将暂停菜单激活。这涉及到编写增强游戏交互性的脚本。
- en: Programming the Pause menu
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程暂停菜单
- en: 'Let’s revisit our previously designed Pause menu, which is ready to be brought
    to life. Coding a pause feature might seem intricate, but with a strategic approach,
    we can simplify the process. So again, we will use a simple approach to pause
    most behaviors, which is stopping time! Remember that most of our movement scripts
    use time functionality, such as **Delta Time** (which we discussed in *Chapter
    2*, *Crafting Scenes and Game Elements*), as a way to calculate the amount of
    movement to apply. There is also a way to simulate time going slower or faster,
    which is by setting `timeScale`. This field will affect Unity’s time system’s
    speed, and we can set it to `0` to simulate that time has stopped, which will
    pause animations, stop particles, and reduce **Delta Time** to `0`, making our
    movements stop. So let’s do it:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下之前设计的暂停菜单，它已经准备好被激活。编写暂停功能可能看起来很复杂，但采用战略方法，我们可以简化这个过程。所以，我们再次将使用简单的方法暂停大多数行为，即停止时间！记住，我们的大多数移动脚本使用时间功能，如**Delta
    Time**（我们在*第2章*，*构建场景和游戏元素*中讨论过），作为计算要应用的运动量的方式。还有一种方法可以模拟时间变慢或变快，那就是通过设置`timeScale`。这个字段将影响Unity的时间系统速度，我们可以将其设置为`0`来模拟时间已停止，这将暂停动画，停止粒子，并将**Delta
    Time**减少到`0`，使我们的动作停止。所以，让我们来做吧：
- en: Create a script called `Pause`, and add it to a new GameObject called `Pause`.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Pause`的脚本，并将其添加到一个名为`Pause`的新GameObject中。
- en: Add the `using UnityEngine.InputSystem;` statement at the beginning of the script
    file to be able to read input.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本文件开头添加`using UnityEngine.InputSystem;`语句，以便能够读取输入。
- en: 'In `Update`, detect when the *Esc* key is pressed. We can add a mapping to
    our **Player Input** asset file and read the input, as we did in *Chapter 2*,
    *Crafting Scenes and Game Elements*, but to learn a new way of using the input
    system, we will use the `Keyboard.current` variable to directly read the state
    of a key in the **Update** method, instead of using mapping. Consider that it
    is always recommended to use input mapping, but let’s do this for learning purposes.
    You can set the `Time.timeScale` variable to `0` when the *Esc* key is pressed,
    as you can see in the following image:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Update` 中检测 *Esc* 键是否被按下。我们可以向我们的 **Player Input** 资产文件中添加一个映射并读取输入，就像我们在
    *第2章*，*构建场景和游戏元素* 中做的那样，但为了学习使用输入系统的新方法，我们将使用 `Keyboard.current` 变量直接在 **Update**
    方法中读取键的状态，而不是使用映射。请考虑，始终推荐使用输入映射，但让我们这样做以供学习。当按下 *Esc* 键时，您可以设置 `Time.timeScale`
    变量为 `0`，如下面的图像所示：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21361_15_66_PE.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、电子邮件  自动生成的描述](img/B21361_15_66_PE.png)'
- en: 'Figure 15.66: Stopping time to simulate a pause'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.66：停止时间以模拟暂停
- en: 'Save and test this by playing the game and pressing the *Esc* key. You will
    notice that almost everything will stop, like animations of characters’ movement,
    but you can see how the shoot functionality still works. That’s because the `PlayerShooting`
    script is not time-dependent. One solution here could be to simply check whether
    `Time.timeScale` is greater than `0` to prevent this:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过玩游戏并按下 *Esc* 键来保存并测试此操作。您会注意到几乎一切都会停止，比如角色移动的动画，但您可以看到射击功能仍然正常工作。这是因为 `PlayerShooting`
    脚本不是时间依赖的。这里的一个解决方案可能是简单地检查 `Time.timeScale` 是否大于 `0` 以防止这种情况：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21361_15_67_PE.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序  自动生成的描述](img/B21361_15_67_PE.png)'
- en: 'Figure 15.67: Checking Pause in the player shooting script'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.67：在玩家射击脚本中检查暂停
- en: The same needs to be done in our `EnemyFSM` `Shoot` method.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `EnemyFSM` `Shoot` 方法中也需要做同样的事情。
- en: As usual, we have pursued the simplest way here, but there is a better approach.
    I challenge you to try to create `PauseManager` with a Boolean, indicating whether
    the game is paused or not and changing `timeScale` in the process.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们在这里追求最简单的方法，但有一个更好的方法。我挑战你尝试创建一个带有布尔值的 `PauseManager`，指示游戏是否已暂停，并在过程中更改
    `timeScale`。
- en: 'Now that we have a simple but effective way to pause the game, let’s make the
    **Pause** menu visible to resume the game by doing the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了一种简单但有效的方法来暂停游戏，让我们通过以下步骤使**暂停**菜单可见，以便通过以下操作恢复游戏：
- en: Add a field of the `GameObject` type, called `pauseMenu`, in the `Pause` script.
    The idea is to drag the **Pause** menu here so that we have a reference to enable
    and disable it.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Pause` 脚本中添加一个名为 `pauseMenu` 的 `GameObject` 类型的字段。想法是将**暂停**菜单拖到这里，以便我们有一个引用来启用和禁用它。
- en: In `Awake`, add `pauseMenu.SetActive(false);` to disable the **Pause** menu
    at the beginning of the game. Even if we disabled the **Pause** menu in the Editor,
    we add this just in case we re-enable it by mistake. It must always start as disabled.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Awake` 中添加 `pauseMenu.SetActive(false);` 以在游戏开始时禁用**暂停**菜单。即使我们在编辑器中禁用了**暂停**菜单，我们也添加这个，以防我们不小心重新启用它。它必须始终以禁用状态开始。
- en: 'Using the same function but passing `true` as the first parameter, enable the
    **Pause** menu in the *Esc* key pressure check:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的函数，但将第一个参数传递为 `true`，在 *Esc* 键按下检查中启用**暂停**菜单：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21361_15_68_PE.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序、聊天或文本消息  自动生成的描述](img/B21361_15_68_PE.png)'
- en: 'Figure 15.68: Enabling the Pause menu when pressing the Esc key'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.68：按下 Esc 键时启用暂停菜单
- en: 'Now, we need to make the **Pause** menu buttons work. If you recall, we explored
    the concept of events, implementing them with UnityEvents in the different managers.
    Our **Pause** menu buttons use the same class to implement the `onClick` event,
    which is an event that informs us that a specific button has been pressed. Let’s
    resume the game when pressing those buttons by doing the following:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要使**暂停**菜单按钮工作。如果您还记得，我们探讨了事件的概念，通过不同的管理器使用 UnityEvents 来实现。我们的 **暂停**菜单按钮使用相同的类来实现
    `onClick` 事件，这是一个通知我们特定按钮已被按下的事件。让我们通过以下操作在按下这些按钮时恢复游戏：
- en: Create a field of the `Button` type in our `Pause` script called `resumeButton`,
    and drag `resumeButton` to it; this way, our `Pause` script has a reference to
    the button.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`Pause`脚本中创建一个`Button`类型的字段，命名为`resumeButton`，并将`resumeButton`拖拽到该字段上；这样，我们的`Pause`脚本就有一个按钮的引用。
- en: In `Awake`, add a listener function called `OnResumePressed` to the `onClick`
    event of `resumeButton`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`中，向`resumeButton`的`onClick`事件添加一个名为`OnResumePressed`的监听函数。
- en: 'Make the `OnResumePressed` function set `timeScale` to `1` and disable the
    **Pause** menu, as we did in `Awake`:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使`OnResumePressed`函数将`timeScale`设置为`1`并禁用**Pause**菜单，就像我们在`Awake`中做的那样：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21361_15_69_PE.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21361_15_69_PE.png)'
- en: 'Figure 15.69: Unpausing the game'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.69：取消暂停游戏
- en: 'If you save and test this, you will notice that you cannot click the **Resume**
    button because we disabled the cursor at the beginning of the game, so make sure
    you re-enable it while in `Pause` mode and disable it when you resume:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您保存并测试此操作，您将注意到您无法点击**Resume**按钮，因为我们已经在游戏开始时禁用了光标，所以请确保在**Pause**模式下重新启用它，并在恢复时禁用它：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21361_15_70_PE.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![Graphical user interface, text, application  Description automatically generated](img/B21361_15_70_PE.png)'
- en: 'Figure 15.70: Showing and hiding the cursor while in pause mode'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.70：在暂停模式下显示和隐藏光标
- en: 'One final thing to consider is that we want to set the time scale to `1` again
    on the **OnDestroy** method. This method gets executed when the **Pause** object
    is destroyed, which will happen when we manually destroy the object via scripting
    or, most importantly in this case, if we change scenes. The idea is to make sure
    to resume the time system if we change scenes while in the **Pause** menu so that
    the next scene can play the game properly:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要考虑的一件事是我们希望在**OnDestroy**方法中将时间尺度重新设置为`1`。此方法在**Pause**对象被销毁时执行，这将在我们通过脚本手动销毁对象时发生，或者在这种情况下最重要的是，如果我们更改场景。我们的想法是确保在**Pause**菜单中更改场景时恢复时间系统，以便下一个场景可以正确地播放游戏：
- en: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B21361_15_71_PE.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B21361_15_71_PE.png)'
- en: 'Figure 15.71: Resetting the time scale when leaving the scene'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.71：离开场景时重置时间尺度
- en: 'Regarding the visual scripting version of the **Pause** script, note that we
    don’t have an equivalent to `Keyboard.current`, so we will need to replace using
    the input mappings. In order to add an input mapping for the *Esc* key, do the
    following:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**Pause**脚本的视觉脚本版本，请注意我们没有`Keyboard.current`的等价物，因此我们需要使用输入映射来替换。为了为*Esc*键添加输入映射，请执行以下操作：
- en: Double-click the **Player Input** asset to edit it. You can find it by selecting
    the **Player** GameObject, and then clicking the box at the right of the **Actions**
    property of the **PlayerInput** component in the Inspector.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**Player Input**资源来编辑它。您可以通过选择**Player**游戏对象，然后点击检查器中**PlayerInput**组件的**Actions**属性右侧的框来找到它。
- en: 'Using the **+** button in the top-right corner of the **Actions** list (the
    middle list), create a new action called `Pause`:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Actions**列表（中间列表）右上角的**+**按钮创建一个名为`Pause`的新动作：
- en: '![Graphical user interface, application, table  Description automatically generated](img/B21361_15_72_PE.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![Graphical user interface, application, table  Description automatically generated](img/B21361_15_72_PE.png)'
- en: 'Figure 15.72: Creating a new input mapping'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.72：创建新的输入映射
- en: Click the **<No Binding>** item inside the **Pause** action we just created
    (below it).
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击我们刚刚创建的**Pause**动作中的**<No Binding>**项（在其下方）。
- en: 'In the **Path** property in the **Binding Properties** section (on the right
    side of the screen), click the empty rectangle at its left, and search and select
    the **Escape [Keyboard]** button:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕右侧的**Binding Properties**部分（屏幕右侧）的**Path**属性中，点击其左侧的空矩形，并搜索并选择**Escape [Keyboard]**按钮：
- en: '![Graphical user interface, application  Description automatically generated](img/B21361_15_73_PE.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![Graphical user interface, application  Description automatically generated](img/B21361_15_73_PE.png)'
- en: 'Figure 15.73: Adding a key to the mapping'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.73：将键添加到映射
- en: Click the **Save Asset** button in the top-middle part of the screen.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕顶部中间部分的**Save Asset**按钮。
- en: 'Now, you can add the following graph, this time to the **Player** GameObject,
    as we need to read input from it:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以添加以下图表，这次是添加到**Player**游戏对象上，因为我们需要从它读取输入：
- en: '![](img/B21361_15_74_PE.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![img/B21361_15_74_PE.png]'
- en: 'Figure 15.74: Pausing when Esc is pressed'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.74：按下Esc键时暂停
- en: So far, nothing new; we detect that *Esc* is pressed, when it happens, we call
    **Set Time Scale** and specify the `0` value. Then, we activate the **Pause**
    menu (having a reference via a variable, `pauseMenu`, in the **Variables** component),
    and we enable the cursor. Finally, we set the time scale to `1` when the object
    is destroyed.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有什么新的；我们检测到按下*Esc*键，当它发生时，我们调用**设置时间缩放**并指定`0`值。然后，我们激活**暂停**菜单（通过在**变量**组件中的变量`pauseMenu`进行引用），并启用光标。最后，当对象被销毁时，我们将时间缩放设置为`1`。
- en: 'Regarding the **Resume** behavior, the nodes to add to the same **Pause** graph
    will look like this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**恢复**行为，要添加到相同**暂停**图表中的节点将看起来像这样：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21361_15_75_PE.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，自动生成的描述](img/B21361_15_75_PE.png)'
- en: 'Figure 15.75: Unpausing when the Resume button is clicked'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.75：点击“恢复”按钮时暂停
- en: The only new element on this graph is the usage of the **On Button Click** node.
    As you might expect, that node is an event, and anything connected to it will
    execute under the pressure of a button. The way to specify which button we refer
    to is by connecting the **Button** reference variable to the input pin of **On
    Button Click**. You can see how we created a variable of type **Button** called
    `resumeButton` in the **Variables** component to do this.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中唯一的新元素是**点击按钮**节点的使用。正如你所预期的那样，这个节点是一个事件，任何连接到它的东西都会在按钮的压力下执行。指定我们指的是哪个按钮的方法是将**按钮**引用变量连接到**点击按钮**的输入引脚。你可以看到我们如何在**变量**组件中创建了一个名为`resumeButton`的**按钮**类型的变量来完成这个操作。
- en: Now that you know how to code buttons, I challenge you to code the `Exit` button’s
    behavior. Again, remember to add `using UnityEngine.UI`. Also, you will need to
    call `Application.Quit();` to exit the game, but take into account that this will
    do nothing in the editor; we don’t want to close the editor while creating the
    game. This function only works when you build the game.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何编写按钮的代码，我挑战你编写`退出`按钮的行为。再次提醒，记得添加`using UnityEngine.UI`。此外，你需要调用`Application.Quit();`来退出游戏，但请注意，在编辑器中这不会做任何事情；我们不想在创建游戏时关闭编辑器。这个函数只有在构建游戏时才有效。
- en: 'So, for now, just call it, and if you want to print a message to be sure that
    the button works properly, you can; a solution is provided in the following screenshot:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在就调用它吧，如果你想打印一条消息来确保按钮正常工作，你可以；以下截图提供了一个解决方案：
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21361_15_76_PE.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，聊天或文本消息，自动生成的描述](img/B21361_15_76_PE.png)'
- en: 'Figure 15.76: The Quit button script'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.76：退出按钮的脚本
- en: This solution proposes that you add this script directly to the **Quit** button
    GameObject itself so that the script listens to the `onClick` event on its `Button`
    sibling component and, when receiving the event, it executes the `Quit` function.
    You could also add this behavior to the `Pause` script, and while that will work,
    remember that if a script can be split into two because it does two unrelated
    tasks, it is always best to split it so that separate behavior is unrelated. Here,
    the pause behavior is not related to the quit behavior.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案建议你直接将此脚本添加到**退出**按钮的GameObject本身，以便脚本监听其`Button`兄弟组件上的`onClick`事件，并在接收到事件时执行`Quit`函数。你还可以将此行为添加到`Pause`脚本中，虽然这会起作用，但请记住，如果一个脚本可以分成两个，因为它执行两个不相关的任务，那么最好将其拆分，以便分离的行为不相关。在这里，暂停行为与退出行为不相关。
- en: 'Regarding the visual scripting version, the graph to add to the **Quit** button
    would look like this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，要添加到**退出**按钮的图表将看起来像这样：
- en: '![Graphical user interface, application  Description automatically generated](img/B21361_15_77_PE.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，自动生成的描述](img/B21361_15_77_PE.png)'
- en: 'Figure 15.77: The Quit button visual script'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.77：退出按钮的视觉脚本
- en: Simple, right? As we put this in the button itself, we don’t even need to specify
    which button it is, as it automatically detects that we refer to ourselves.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，对吧？因为我们把它放在按钮本身中，所以我们甚至不需要指定是哪个按钮，因为它会自动检测我们指的是自己。
- en: Now that we have our pause system set up using the UI and buttons, we are ready
    for the next chapter, where we will continue to look at other visual and auditive
    ways to make our player aware of what has happened.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用UI和按钮设置了暂停系统，我们准备进入下一章，我们将继续探讨其他视觉和听觉方式，让玩家意识到发生了什么。
- en: Summary
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we introduced the basics of the UI, understanding the **Canvas**
    and **RectTransform** components to locate objects onscreen and create a UI layout.
    We also covered different kinds of UI elements, mainly **Image** and **Text**,
    to give life to our UI layout and make it appealing to the user. Finally, we discussed
    how to adapt UI objects to different resolutions and aspect ratios to make our
    UI adapt to different screen sizes, even though we cannot predict the exact monitor
    our user will play the game on. All of this allows us to create any UI we will
    need in our game using the Canvas.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了UI的基础知识，理解**Canvas**和**RectTransform**组件以在屏幕上定位对象并创建UI布局。我们还涵盖了不同类型的UI元素，主要是**图像**和**文本**，以使我们的UI布局生动起来，并吸引用户。最后，我们讨论了如何使UI对象适应不同的分辨率和宽高比，使我们的UI能够适应不同的屏幕尺寸，尽管我们无法预测用户将使用哪种确切显示器玩游戏。所有这些使我们能够使用Canvas创建游戏中需要的任何UI。
- en: In the next chapter, we will explore how to create UIs using UI Toolkit instead,
    another Unity system to create UIs, and compare both the Canvas and UI Toolkit
    to see when to use which.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用UI Toolkit来创建UI，这是Unity系统中另一种用于创建UI的工具，并将Canvas和UI Toolkit进行比较，以了解何时使用哪一个。
- en: Learn more on Discord
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多信息
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家以及作者本人一起阅读这本书。提出问题，为其他读者提供解决方案，通过“问我任何问题”的环节与作者聊天，等等。扫描二维码或访问链接加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1498477041053909218.png)'
