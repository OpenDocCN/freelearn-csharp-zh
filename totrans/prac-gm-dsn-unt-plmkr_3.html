<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Components and State Machines</h1></div></div></div><p>In the previous chapter, we learned about Unity's interface, and the way things are organized and displayed in the Editor. You added a FSM to a game object and briefly looked at the interface elements related to Playmaker. You also manipulated game objects and components using such interface elements as the <strong>Hierarchy</strong> and <strong>Inspector</strong> panels, as well as the <strong>Scene</strong> view. In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Component-based approach to game development that Unity relies on</li><li class="listitem" style="list-style-type: disc">Game objects, components, and their properties in more detail</li><li class="listitem" style="list-style-type: disc">The interchangeable nature of game objects when using components to define appearance and behavior</li><li class="listitem" style="list-style-type: disc">Finite state machines, actions, and transitions</li><li class="listitem" style="list-style-type: disc">Making simple game mechanics using Playmaker</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Game objects, components, and properties</h1></div></div></div><p>Unity works using a popular and common approach for game development, which is called the <a id="id67" class="indexterm"/>component-based architecture. This approach is widely used in software development to make things more reusable and easier to manage.</p><p>Let us talk about the way things are organized in Unity. Some of them have already been mentioned in previous chapters, but I will repeat them briefly so that you can see the game objects, components, and their properties in the larger context.</p><p>First of all, you have a project, which is essentially a folder that contains all of the files and information about your game. Some of the files are called <a id="id68" class="indexterm"/>scenes (think of them as levels). A scene contains a number of game objects that you have added to it. The contents of your scenes are determined by you, and you can have as many of them as you want. You can also make your game switch between different scenes, thus making different sets of game objects active.</p><p>On a smaller scale, you have game objects and components. A game object<a id="id69" class="indexterm"/> by itself is simply an invisible container that does not do anything. Without adding appropriate components to it, it cannot, for instance, appear in the scene, receive input from the player, or move and interact with other objects. Using components, you can easily assemble powerful game objects while reusing several small parts, each responsible for a simple task or behavior—rendering the game object, handling the input, taking damage, playing an audio effect, and so on—making your game much simpler to develop and manage. Unity relies heavily on this approach, so the better you grasp it, the faster you will get good at it.</p><p>The only <a id="id70" class="indexterm"/>component that each and every game object in Unity has attached to it by default is <strong>Transform</strong>. It lets you define the game object's position, rotation, and scale. Normally, you can attach, detach, and destroy components in any given game object at will, but you cannot remove <strong>Transform</strong>.</p><p>Each component has a number of properties that you can access and change: these can be integer or floating point numbers, strings of text, textures, scripts, references to game objects or other components. They are used to change the way a certain component behaves, to influence its appearance or interaction. Some of the properties that you have already encountered in <a class="link" href="ch02.html" title="Chapter 2. Unity's and Playmaker's User Interface">Chapter 2</a>, <em>Unity's and Playmaker's</em> <em>User Interface</em>, include the position, rotation, and scale properties of the <strong>Transform</strong> component. There are others that you have seen, including FSM, that we will talk about later in this chapter.</p><p>The following screenshot shows the <strong>Wall</strong> game object with the <strong>Transform</strong>, <strong>Mesh Filter</strong>, <strong>Box Collider</strong>, <strong>Mesh Renderer</strong>, and <strong>Script</strong> components attached to it. the properties of <strong>Transform</strong> are displayed. In order to reveal or hide a component's properties you need to left-click on its name or on the small arrow on the left of its icon.</p><div><img src="img/8108OT_03_01.jpg" alt="Game objects, components, and properties"/></div><p>Unity has a number of predefined <a id="id71" class="indexterm"/>game objects that already have components attached to them, such as cameras, lights, and primitives. You can access them by choosing <strong>GameObject</strong> | <strong>Create </strong>from the main menu. Alternatively, you can create empty game objects by pressing <em>command</em> + <em>Shift</em> + <em>N</em> (<em>Ctrl</em> + <em>Shift</em> + <em>N</em> in Windows) and attach components to them using the <strong>Components</strong> submenu.</p><p>The following figure shows the project structure that we have discussed. Note that there can be any number of scenes within a single project, any number of game objects within a single scene, any number of components attached to a single game object, and finally, any number of properties within a single component.</p><div><img src="img/8108OT_03_02.jpg" alt="Game objects, components, and properties"/></div><p>One final thing that you need to know about components right now is that you can copy them by right-clicking on the name of the component in the <strong>Inspector</strong> panel and selecting <strong>Copy Component</strong> from the contextual menu shown in the following screenshot. You can also reset the <a id="id72" class="indexterm"/>properties <a id="id73" class="indexterm"/>of the components to their default values, remove components, and move them up or down for your convenience.</p><div><img src="img/8108OT_03_03.jpg" alt="Game objects, components, and properties"/></div><p>The <a id="id74" class="indexterm"/>copied <a id="id75" class="indexterm"/>component can be pasted by right-clicking any component's name in the <strong>Inspector</strong> panel and selecting either <strong>Paste Component As New</strong> or <strong>Paste Component Values</strong> from the same contextual menu. The difference between these two commands is that the former will add a new component identical to the one that you have copied, while the latter will simply transfer the values of all the properties. These commands become active once you have copied a component.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Working with prefabs</h1></div></div></div><p>In order to create multiple<a id="id76" class="indexterm"/> instances of a game object with the same components and properties, or access the same game object from different scenes, you can save it as a file in your <code class="literal">Assets</code> folder. These files are called prefabs in Unity and act like game object templates. To create an empty prefab, right-click on the empty space in the <strong>Project</strong> panel, then select <strong>Create</strong> | <strong>Prefab</strong> from the contextual menu. A new file called <code class="literal">New Prefab</code> should appear in the <strong>Project</strong> panel. Call this prefab <code class="literal">Wall</code>. Now create an empty folder called <code class="literal">Prefabs</code> and put the <code class="literal">Wall</code> prefab in this folder.</p><p>Right now the prefab is empty.</p><div><ol class="orderedlist arabic"><li class="listitem">In the <strong>Hierarchy</strong> panel, select the <strong>Wall</strong> game object that you created in <a class="link" href="ch02.html" title="Chapter 2. Unity's and Playmaker's User Interface">Chapter 2</a>, <em>Unity's and Playmaker's</em> <em>User Interface</em>. Click and drag it into the <code class="literal">Wall</code> prefab in the <strong>Project</strong> panel.</li><li class="listitem">The name of the <strong>Wall</strong> game object will become blue in <strong>Hierarchy</strong>, and when you select the <code class="literal">Wall</code> prefab, you will see all of the components that the original <strong>Wall</strong> game object had in the <strong>Inspector</strong> panel.</li></ol></div><p>Now, if you drag-and-drop the <code class="literal">Wall</code> prefab into the scene, a new object called <strong>Wall</strong> will be created with exactly the same properties as those defined in the prefab.</p><p>Moreover, if you change some of the components and/or properties in the prefab using the <strong>Inspector</strong> panel, these changes will be automatically applied to all the instances of the prefab in the scene. This can save you a lot of time if you have multiple objects of the same type (that is, walls, monsters, trees, and so on) as you do not have to select them one-by-one in the <strong>Hierarchy</strong> and make the same changes multiple times.</p><p>You can also modify your prefab (and, by extension, all of its instances in the scene) by selecting one of the instances in <strong>Hierarchy</strong>, making your changes, and clicking the <strong>Apply</strong> button near the top of the <strong>Inspector</strong> panel. You can also undo all of the changes by clicking on the <strong>Revert</strong> button. This will reset the currently selected instance to the way its prefab was set up.</p><p>This works <a id="id77" class="indexterm"/>because, in fact, all the components and properties of an instance are linked to the ones of the prefab. Only when you change them in the instance they become unlinked, which means that further updates of that property on the prefab won't be applied to this instance. These unlinked properties can be distinguished because their name becomes bold in the <strong>Inspector</strong> panel. If you want to re-link a specific unlinked property you can right-click on it and select <strong>Revert value to Prefab</strong>.</p><p>Besides the <strong>Apply</strong> and <strong>Revert</strong> buttons, all prefab instances also have a <strong>Select</strong> button. This button lets you select and highlight the prefab corresponding to the currently selected instance in the <strong>Project</strong> panel, so you can access it more easily. Moreover, as we saw earlier, a prefab instance can be easily identified by its blue tinted name in the <strong>Hierarchy</strong> panel. The alternative way of creating a prefab is even simpler: you can simply drag-and-drop a game object from the <strong>Hierarchy</strong> panel into the <strong>Project</strong> panel. An appropriately named file will be created in the <code class="literal">Assets</code> folder.</p><p>Another very important thing to know about prefabs is that they can be copied and shared on the Web, since they are little more than the files recognized by Unity that contain information about components and properties. Now, follow these steps to modify the <code class="literal">Wall</code> prefab to suit our needs better:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new folder in the <strong>Project</strong> panel and call it <code class="literal">Materials</code>. It will contain material files that contain information about textures, shaders, and colors of your game objects.</li><li class="listitem">Create a new material file by clicking on the <strong>Create</strong> button in the top-left corner of the <strong>Project</strong> panel and selecting <strong>Material</strong> from the drop-down list.</li><li class="listitem">Name the new material <code class="literal">WallMaterial</code> and put it inside the <code class="literal">Materials</code> folder.</li><li class="listitem">Select <strong>WallMaterial</strong> in the <strong>Project</strong> panel, then in <strong>Inspector</strong>, click on the rectangle next to the text that says <strong>Main Color</strong>. In the <strong>Color</strong> window that appears, select the black color and close the <strong>Color</strong> window. The following screenshot shows the <strong>Material</strong> modification interface as well as the <strong>Color</strong> window:<div><img src="img/8108OT_03_04.jpg" alt="Working with prefabs"/></div></li><li class="listitem">Now that you <a id="id78" class="indexterm"/>have this new material set up, select the <code class="literal">Wall</code> prefab, then drag-and-drop <strong>WallMaterial</strong> into the <strong>Element 0</strong> element of the <strong>Materials</strong> property of the prefab's <strong>Mesh Renderer</strong> component. It should replace <strong>Default Diffuse</strong>. The following screenshot shows what the <strong>Mesh Renderer</strong> component should look like once your are done assigning the new material.<div><img src="img/8108OT_03_05.jpg" alt="Working with prefabs"/></div></li><li class="listitem">Now all of the instances of the <code class="literal">Wall</code> prefab will be black.</li><li class="listitem">Also, set the X scale property of the <strong>Transform</strong> component to <code class="literal">15</code>. This will make all the new walls longer.</li><li class="listitem">Select the <strong>Main Camera</strong> game object and set its <strong>Projection</strong> property of the <strong>Camera</strong> component to <strong>Orthographic</strong> using the <strong>Inspector</strong> panel. This will make the view of the camera flat; the game view will now appear two-dimensional.</li><li class="listitem">Set the <strong>Size</strong> property to <code class="literal">5</code>. You can adjust the look later, but for now this will help us focus on gameplay.</li></ol></div><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>It is often a good idea to restrict yourself to simple primitives, color-coded untextured materials, and orthographic projection cameras in the beginning of the design process, because it will let you focus on gameplay. This way, if your game is fun, you will know about it, and if it is not, you will not get distracted by fancy visuals.</p></div></div><p>Make four <a id="id79" class="indexterm"/>walls and arrange them in the scene so that what you see in the <strong>Game</strong> view looks like the following screenshot. If this is not the case, you can go back to the table in <a class="link" href="ch02.html" title="Chapter 2. Unity's and Playmaker's User Interface">Chapter 2</a>, <em>Unity's and Playmaker's</em> <em>User Interface</em>, and see if your <strong>Main Camera</strong> game object is positioned and rotated correctly. Its position should be set to (<code class="literal">0</code>, <code class="literal">10</code>, <code class="literal">0</code>) and rotation to (<code class="literal">90</code>, <code class="literal">0</code>, <code class="literal">0</code>). Don't forget that you can rotate the objects to precise values such as <code class="literal">90</code> and <code class="literal">180</code> degrees by changing their rotation angle in the <strong>Transform</strong> component. Also make sure that the Y position of all the walls remains equal to <code class="literal">0.5</code>.</p><div><img src="img/8108OT_03_06.jpg" alt="Working with prefabs"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Finite state machines, states, and actions</h1></div></div></div><p>We have talked about game objects and components. Now it is time to have a look at Playmaker FSMs, states, and actions in them.</p><p>An FSM<a id="id80" class="indexterm"/> in Playmaker is a graph that consists of states and transitions between them, attached to a game object. It allows for a way of visual programming using different states of the graph and events that trigger transitions to other states.</p><p>If you select the <code class="literal">Wall</code> prefab and open the <strong>playMaker</strong> panel, you will see that its FSM has two states: the default <strong>Start</strong> state where everything begins and another one called <strong>State 1</strong> by default, with an arrow connecting the former to the latter. The arrow is a transition. You cannot remove the Start state or the one it is connected to, because if you could you would not need the FSM attached to the object. However, you can create new states and define transitions to them.</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>You can navigate the FSM view almost exactly the same way you would do the <strong>Scene</strong> view. Use the middle mouse button to drag the view. Use the left mouse button to move the states around. This does not change anything in the logic of the state machine, but lets you organize everything the way that makes sense to you, as well as look at the parts of the graph that you are most interested in at the moment if the whole state machine is too big to be shown at once.</p></div></div><p>A state<a id="id81" class="indexterm"/> in FSM is empty by default and does not do anything, a lot like an empty game object without any components attached to it. In order to make a state do something, you need to attach actions to it.</p><p>As we have seen in <a class="link" href="ch02.html" title="Chapter 2. Unity's and Playmaker's User Interface">Chapter 2</a>, <em>Unity's and Playmaker's</em> <em>User Interface</em>, you can add an FSM to an object by selecting the latter, right-clicking in the FSM view of the <strong>playMaker</strong> panel, and then selecting <strong>Add FSM</strong> from the contextual menu. You can remove an object from the Playmaker control by right-clicking the header of the Playmaker FSM (<strong>Script</strong>) component in <strong>Inspector</strong> and selecting <strong>Remove Component</strong> from the contextual menu. This will remove the FSM and erase all of the changes you made to it, including added states and transitions. An object has an FSM attached to it if there is a red Playmaker hieroglyph icon (<img src="img/8108OT_03_07.jpg" alt="Finite state machines, states, and actions"/>) next to its name in the <strong>Hierarchy</strong> panel.</p><p>As an example for this book, we will be making a version of the classic air hockey game. In order to begin, we will need to add a puck and a mallet. In this chapter, you will make the mallet move based on the mouse position and push the puck as you would expect it to do in real life.</p><p>Right now in your scene there are four walls, a background quad, a camera, and a directional light (created in <a class="link" href="ch02.html" title="Chapter 2. Unity's and Playmaker's User Interface">Chapter 2</a>, <em>Unity's and Playmaker's User Interface</em>). Now it is time to make things interactive. Let us start with a mallet.</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new cylinder primitive by selecting <strong>GameObject</strong> | <strong>Create Other</strong> | <strong>Cylinder</strong> in the main menu.</li><li class="listitem">Rename this game object to <code class="literal">Mallet</code> and make a dark green (RGB color set to <code class="literal">10</code>, <code class="literal">155</code>, <code class="literal">10</code> in the <strong>Color</strong> window) material called <strong>MalletMaterial</strong> for it, then assign the material to it, as you did for the <code class="literal">Wall</code> prefab before.</li><li class="listitem">Set the scale of <strong>Mallet</strong> to (<code class="literal">1.35</code>, <code class="literal">1.35</code>, <code class="literal">1.35</code>) and its position to (<code class="literal">-6.5</code>, <code class="literal">1.45</code>, <code class="literal">0</code>).</li><li class="listitem">Now we are going to make the<a id="id82" class="indexterm"/> mallet move. First of all, we need to add a component called <strong>Character Controller</strong> to it. This component is in charge of character physics. Select <strong>Mallet</strong>, then click on the <strong>Add Component</strong> button near the bottom of the <strong>Inspector</strong> panel. Type <code class="literal">Character Controller</code> in the search bar, and then double-click on the <strong>Character Controller</strong> item in the list (as shown in the following screenshot). When Unity asks you if you want to replace the existing <strong>CapsuleCollider</strong> component, click on <strong>Replace</strong>.<div><img src="img/8108OT_03_08.jpg" alt="Finite state machines, states, and actions"/></div></li><li class="listitem">In the <strong>Character Controller</strong> <a id="id83" class="indexterm"/>component, set the <strong>Skin Width</strong> property to <code class="literal">0</code> (it will be set to the minimum possible value, which is <code class="literal">0.0001</code>). We are doing this to make sure that our mallet's collisions look precise.</li><li class="listitem">Add an FSM to Mallet by selecting it, right-clicking in the FSM view of the <strong>playMaker</strong> panel, and selecting <strong>Add FSM</strong> from the contextual menu.</li><li class="listitem">Select <strong>State 1</strong>, then in the <strong>State</strong> tab on the right of the <strong>playMaker</strong> panel enter <code class="literal">Move</code> in the first text field from the top. It is responsible for the name of the currently selected state. When you enter the new name, you should see the state change in the FSM view as well.</li><li class="listitem">Keeping the <strong>Move</strong> state selected, open the <strong>Actions</strong> panel (it should be attached to the same area of the <strong>Editor</strong> window as the <strong>Inspector</strong> panel; alternatively, click on the <strong>Action Browser</strong> button on the bottom-right of the <strong>State</strong> tab) and find the <strong>Mouse Pick</strong> action under the <strong>Input</strong> category. Click on it, then click on the <strong>Add Action To State</strong> button in the bottom-right corner of the panel. You should notice that the <strong>Mouse Pick</strong> action appeared in the <strong>State</strong> tab of the <strong>playMaker</strong> panel.<p>This action gets the cursor position in 3D space when you hover an object. Under the hood it draws an invisible ray (this action is called <a id="id84" class="indexterm"/>
<strong>raycast</strong>) from the mouse position on the camera's near clipping plane (you can see it as one of the white gizmo rectangles in the <strong>Scene</strong> view when you select <strong>Main Camera</strong>). If there is something in the way of the ray, a ray hit gets detected, and Unity finds out where exactly it happened. In our case, we will use the background quad to get the position of the mouse cursor, and then make the mallet follow it.</p></li><li class="listitem">In order to pick a correct <a id="id85" class="indexterm"/>ray-hit position, we need to make sure that nothing else gets in the way of the ray. To do this, we will tell the ray to interact only with the background quad. Select the <strong>Quad</strong> game object and rename it <code class="literal">Background</code> for clarity. Then find the <strong>Layer</strong> drop-down menu in the top-right corner of the <strong>Inspector</strong> panel, click on the drop-down button that says <strong>Default</strong> by default, and press <strong>Add Layer…</strong> in it. The appearance of <strong>Inspector</strong> should now change to reveal a list of tags and layers as shown in the following screenshot:<div><img src="img/8108OT_03_09.jpg" alt="Finite state machines, states, and actions"/></div><p>This menu is called <strong>TagManager</strong>. Click on the right of <strong>User Layer 8</strong> and enter <code class="literal">Background</code> in the edit field that appears, then press <em>Return</em> on your keyboard. Select the <strong>Background</strong> object again and set its layer to <strong>Background</strong> by choosing the appropriate element from the drop-down <strong>Layer</strong> list you used to access the <strong>TagManager</strong> before.</p></li><li class="listitem">Select <a id="id86" class="indexterm"/><strong>Mallet</strong> again. In the <strong>Mouse Pick</strong> action of the <strong>Move</strong> state, set the <strong>Layer Mask</strong> parameter to <code class="literal">1</code>. This determines how many layers you will set to interact with the raycast. <strong>Element 0</strong> should appear below. In the drop-down list to its right, select the <strong>Background</strong> layer you created before.</li><li class="listitem">From now on, the raycast in the <strong>Mouse Pick</strong> action will ignore all objects that are not in the <strong>Background</strong> layer. Now we need to store the ray-hit position in a variable. Go to the <strong>Variable</strong> tab of the <strong>playMaker</strong> panel and enter <code class="literal">mousePos</code> in the <strong>New Variable</strong> field on the bottom. Click on the <strong>Add</strong> button. Set the <strong>Variable Type</strong> to <strong>Vector3</strong>. A <strong>Vector 3</strong> variable contains three numbers: <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong>.</li><li class="listitem">Go back to the <strong>State</strong> tab and set the <strong>Store Point</strong> property of the <strong>Mouse Pick</strong> action to <strong>mousePos</strong>. This will save the position of the ray hit in the <strong>Vector3</strong> type variable that you just created. Finally, check the <strong>Every Frame</strong> property checkbox on the bottom of the <strong>Mouse Pick</strong> action to make sure that the mouse position is updated continuously as opposed to just once in the beginning of the game.</li><li class="listitem">Add the action called <strong>Controller Simple Move</strong> located under the <strong>Character</strong> category of the <strong>Actions</strong> panel to your <strong>Move</strong> state. It should appear just below the <strong>Mouse Pick</strong> action. If it appears above it, you can move it down by clicking and dragging it by its header.<p>It is important to note that the order of actions in the state matters: the actions mentioned earlier will be executed before the ones that are mentioned later, so if you want to use a variable set in the <strong>Mouse Pick</strong> action, you must make sure that <strong>Mouse Pick</strong> is above whatever action is going to use it (in our case it is <strong>Controller Simple Move</strong>).</p></li><li class="listitem">Set the <strong>Move Vector</strong> property of the <strong>Controller Simple Move</strong> action to <strong>mousePos</strong>. Leave the rest of the properties at their default values.</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Interaction between game objects</h1></div></div></div><p>Now that the mallet moves, we are <a id="id87" class="indexterm"/>going to make it interact with a puck. When the mallet touches the puck, we are going to apply a force to it in the opposite direction.</p><p>You can click the Play button in the toolbar and see how the mallet moves based on the mouse position. You will notice that it collides with the walls, follows the mouse cursor smoothly, and changes its movement speed based on how fast and far you move your mouse.</p><div><ol class="orderedlist arabic"><li class="listitem">Create another cylinder called <strong>Puck</strong> and place it in (<code class="literal">-3</code>, <code class="literal">0.85</code>, <code class="literal">0</code>). Set its scale to (<code class="literal">1</code>, <code class="literal">0.7</code>, <code class="literal">1</code>).</li><li class="listitem">Add a <strong>Rigidbody</strong> component to it (<strong>Component | Physics | Rigidbody</strong>). Set the <strong>Mass</strong> property to <code class="literal">0.1</code>, uncheck <strong>Use Gravity</strong>, open the <strong>Constraints</strong> section, and check <strong>Freeze Position Y</strong> and <strong>Freeze Rotation X</strong>, <strong>Y</strong> and <strong>Z</strong>.</li><li class="listitem">Make a new dark grey (<code class="literal">65</code>, <code class="literal">60</code>, <code class="literal">60</code>) material (<strong>Assets</strong> | <strong>Create</strong> | <strong>Material</strong>) called <strong>PuckMaterial</strong> and assign it to the puck's <strong>Mesh Renderer</strong>.</li><li class="listitem">Now that the puck is all set, we will make the mallet push it. Go to the mallet's <strong>Move</strong> state in FSM and add an action called <strong>Collision Event</strong> (under Physics) to it. Set the <strong>Collision</strong> property to <strong>On Controller Collider Hit</strong>.<div><img src="img/8108OT_03_10.jpg" alt="Interaction between game objects"/></div></li><li class="listitem">Open <strong>TagManager</strong> by selecting the <strong>Puck</strong> game object and choosing <strong>Add Tag...</strong> from the <strong>Tag</strong> drop-down menu in <strong>Inspector</strong>. Create a tag called <strong>Puck</strong> by adding a new tag the same way you did with a layer for the background. Tags are situated near the top of <strong>TagManager</strong>. You can have as many as you want if you modify the <strong>Size</strong> variable. Set the <strong>Puck</strong> game object's tag to <strong>Puck</strong>.</li><li class="listitem">Go back to the <strong>Move</strong> state in Mallet's FSM. Set the <strong>Collide Tag</strong> property of the <strong>Collision Event</strong> action to <strong>Puck</strong>.</li><li class="listitem">Open the <strong>Events</strong> tab in the <strong>playMaker</strong> panel, enter <code class="literal">Push</code> in the <strong>Add Event</strong> field near the bottom of the tab, and press <em>Return</em> on your keyboard.</li><li class="listitem">Open the <strong>State</strong> tab again and set the <strong>Send Event</strong> property of the <strong>Collision Event</strong> action to <strong>Push</strong>.</li><li class="listitem">Now we have to tell the FSM what will happen once the event is called. Create a new state in the Mallet's FSM by right-clicking anywhere in the FSM view and selecting <strong>Add State</strong> from the context menu. Name the new state <code class="literal">Push Puck</code>. Right-click on the <strong>Move</strong> state in the FSM view and select <strong>Add Transition</strong> | <strong>Push</strong> from the contextual menu. A new light label saying <strong>Push</strong> should appear below the <strong>Move</strong> state. Click on it and drag the line that appears to the <strong>Push Puck</strong> state. This line is the transition that will happen once the <strong>Push</strong> event is called in the <strong>Move</strong> state. Add a <strong>FINISHED</strong> event to the <strong>Push Puck</strong> state the same way. You do not need to create it, because it is a default Playmaker event.</li><li class="listitem">Make a transition from the <a id="id88" class="indexterm"/><strong>FINISHED</strong> event to the <strong>Move</strong> state to make sure that when the puck is pushed the mallet will remain under the player's control. The following figure shows what your FSM is supposed to look like:<div><img src="img/8108OT_03_11.jpg" alt="Interaction between game objects"/></div></li><li class="listitem">Add the following actions to the <strong>Push Puck</strong> state in Mallet's FSM one-by-one: <strong>Get Controller Hit Info</strong>, <strong>Get Position</strong>, <strong>Vector3 Subtract</strong>, <strong>Vector3 Normalize</strong>, <strong>Vector3 Multiply</strong>, and <strong>Add Force</strong>. Keep in mind that the order of the actions matters, because the ones higher on the list will get executed earlier. The following screenshot shows the correct order of the actions.<div><img src="img/8108OT_03_13.jpg" alt="Interaction between game objects"/></div></li><li class="listitem">Create the following variables using the <strong>Variables</strong> tab of the <strong>playMaker</strong> panel: <strong>hitPos</strong> (<strong>Vector3</strong>), <strong>pushDir</strong> (<strong>Vector3</strong>), <strong>pushMag</strong> (<strong>Float</strong>). Select <strong>pushMag</strong> and set its <strong>Float Value</strong> to <code class="literal">20</code>. This value will determine how hard the mallet pushes the puck.</li><li class="listitem">Back in the <strong>State</strong> tab, set the <strong>Contact Point</strong> property of <strong>Get Controller Hit Info</strong> action to <strong>hitPos</strong>.</li><li class="listitem">Drag the <strong>Puck</strong> game object from <strong>Hierarchy</strong> to the <strong>Game Object</strong> slot of the <strong>Get Position</strong> action, then set <strong>Vector</strong> to <strong>pushDir</strong>.</li><li class="listitem">
In <strong>Vector3 Subtract</strong> action, set <strong>Vector3 Variable</strong> to <code class="literal">pushDir</code>. Click on the small option (<img src="img/8108OT_03_12.jpg" alt="Interaction between game objects"/>) icon next to <strong>Subtract Vector</strong>. This will allow you to pick a variable from the list instead of using a numeric value. Set <strong>Subtract Vector</strong> to <code class="literal">hitPos</code>.
</li><li class="listitem">In <strong>Vector3 Normalize</strong> action, set <strong>Vector3 Variable</strong> to <strong>pushDir</strong>.</li><li class="listitem">In <strong>Vector3 Multiply</strong> action, set <strong>Vector3 Variable</strong> to <strong>pushDir</strong> and <strong>Multiply By</strong> to <strong>pushMag</strong>. Click on the small option icon to show the FSM variables if needed.</li><li class="listitem">Finally, in <strong>Add Force</strong>, set the <strong>Game Object</strong> property to <strong>Specify Game Object</strong> and drag the <strong>Puck</strong> game object into the slot that will appear below. Set <strong>Vector</strong> to <strong>pushDir</strong>. Click on the option icons next to <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong> and leave them at <strong>None</strong> to make sure they are not reset to <code class="literal">0</code> and are simply not assigned instead. Click the small option icon to show the <strong>None</strong> option if needed. Then set <strong>Space</strong> to <strong>World</strong>.</li></ol></div><p>Your puck should now<a id="id89" class="indexterm"/> become interactive if you click on play and make the Mallet collide with it. I realize that the last bit was a lot of actions at once, so we will discuss what exactly happens in those actions in the next chapter. This is an example of some complex logic that we will look into when we talk more about game mechanics. For now consider it an exercise to familiarize yourself with actions and variables and the way they are added and assigned in the <strong>playMaker</strong> panel.</p><p>As another exercise, save your scene, create a few new game objects with FSMs, and try to experiment with different actions and variables, see how they are added and assigned. Don't worry if your actions do not do much. Try to familiarize yourself with the Playmaker interface and remember how to add, move, and remove actions, create new variables and events, and assign them.</p><p>Once you feel like you are comfortable with these actions, you can delete the objects you used for practice or simply reload the scene without saving it by double-clicking the <code class="literal">Scene1</code> file in the <strong>Project</strong> panel.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Summary</h1></div></div></div><p>In this chapter, we discussed the project structure in Unity: scenes, game objects, components, and properties. We also took a closer look at the Playmaker interface: actions, events, variables, and transitions. You took the first step in creating an air hockey game by implementing a real game mechanic—a mallet that is moved with the mouse and a puck that is pushed when the mallet touches it. In the next chapter, we will add even more game mechanics, explain the ones already implemented in more detail, and try to make the game more fun and pretty.</p></div></body></html>