- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Input/Output and File Handling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入/输出和文件处理
- en: In the previous chapter, we laid out the foundations of `System.CommandLine`
    library to infuse CLI capabilities into the application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为将 CLI 功能注入应用程序奠定了 `System.CommandLine` 库的基础。
- en: For now, our CLI application only contains one command (`link`), which allows
    for managing bookmarks by adding new ones or listing, updating, or removing existing
    ones.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的 CLI 应用程序只包含一个命令（`link`），允许通过添加新书签或列出、更新或删除现有书签来管理书签。
- en: 'With this chapter, we are working toward two goals:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们致力于两个目标：
- en: To go a bit deeper with options to further control input values for our CLI
    application’s command options.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步控制 CLI 应用程序命令选项的输入值，让我们更深入地探讨选项。
- en: To see how to handle input and output files in a CLI application. This might
    be handy for import and export operations, making it easier to back up and restore
    our application’s data and share it with other applications.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要了解如何在 CLI 应用程序中处理输入和输出文件。这可能对导入和导出操作很有用，使备份和恢复我们的应用程序数据以及与其他应用程序共享数据变得更加容易。
- en: 'Specifically, we’ll cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主要主题：
- en: Controlling input values for an option, determining when to use required versus
    non-required options, setting default values for options, controlling the set
    of allowed values for an option, and validating input values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制选项的输入值，确定何时使用必填或非必填选项，设置选项的默认值，控制选项允许的值集合，以及验证输入值
- en: Working with files passed as parameters to the CLI application, both as input
    and output files, which will be useful for adding import and export capabilities
    to our CLI application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 CLI 应用程序作为参数传递的文件一起工作，这些文件作为输入和输出文件，这将有助于为我们的 CLI 应用程序添加导入和导出功能
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter05](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter05).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书附带的 GitHub 仓库中找到，[https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter05](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter05)。
- en: Controlling input values for an option
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制选项的输入值
- en: Parameters are at the heart of any application. They allow users to indicate
    what command they want to execute and provide values to the input parameters.
    This is why, in this section and its subsections, we will cover the subtleties
    of dealing with these parameters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是任何应用程序的核心。它们允许用户指示他们想要执行哪个命令，并为输入参数提供值。这就是为什么在本节及其子节中，我们将介绍处理这些参数的细微差别。
- en: Required versus non-required options
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 必填与非必填选项
- en: In its current state, adding a new bookmark requires both the name and the URL
    to be provided, which is, obviously, what we want.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，添加新书签需要提供名称和 URL，这显然是我们想要的。
- en: 'This means that if we call the `link add` command without passing one of these
    options or their values, we should get an error such as the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们调用 `link add` 命令而没有传递这些选项或它们的值，我们应该得到如下错误：
- en: '![Figure 5.1 – The name and URL for a bookmark should be required](img/B22400_05_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 书签的名称和 URL 应该是必填项](img/B22400_05_01.jpg)'
- en: Figure 5.1 – The name and URL for a bookmark should be required
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 书签的名称和 URL 应该是必填项
- en: 'However, if we run the program without passing these two options, we currently
    get the following result:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们运行程序而不传递这两个选项，我们目前得到以下结果：
- en: '![Figure 5.2 – The name and URL for the added bookmark are currently optional](img/B22400_05_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 添加的书签的名称和 URL 目前是可选的](img/B22400_05_02.jpg)'
- en: Figure 5.2 – The name and URL for the added bookmark are currently optional
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 添加的书签的名称和 URL 目前是可选的
- en: Notice how a new bookmark with no name and no URL is added to the collection
    of bookmarks. This is clearly not what we want!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何将没有名称和 URL 的新书签添加到书签集合中。这显然不是我们想要的！
- en: Fortunately, the `Option` class provides a Boolean value to specify whether
    it should be required or optional.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`Option` 类提供了一个布尔值来指定它应该是必填还是可选的。
- en: 'To make the name and URL options required, let’s set their respective `IsRequired`
    property to `true`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要使名称和 URL 选项成为必填项，让我们将它们各自的 `IsRequired` 属性设置为 `true`：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we now run the program without passing in an option or its value, we get
    an error message:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行程序而不传递选项或其值，我们会得到一个错误消息：
- en: '![Figure 5.3 – The name and URL for the added bookmark are now required](img/B22400_05_03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 添加的书签的名称和URL现在是必需的](img/B22400_05_03.jpg)'
- en: Figure 5.3 – The name and URL for the added bookmark are now required
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 添加的书签的名称和URL现在是必需的
- en: Also note that the help menu clearly states that these two options are required.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，帮助菜单清楚地说明了这两个选项是必需的。
- en: So far, we have two required options. Let’s add an optional one.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有两个必需的选项。让我们添加一个可选的选项。
- en: When an option is not required (i.e., optional), the application should not
    return an error if we don’t pass that option or its value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个选项不是必需的（即可选的）时，如果未传递该选项或其值，应用程序不应返回错误。
- en: Let’s take an illustrative example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个示例来说明。
- en: Let’s say we want to classify our bookmarks by category. By doing so, we can
    imagine that we may want to list only the bookmarks that belong to a specific
    category.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要按类别对我们的书签进行分类。通过这样做，我们可以想象我们可能只想列出属于特定类别的书签。
- en: 'For that matter, we will first add a `Category` property to the `Bookmark`
    class, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先将一个`Category`属性添加到`Bookmark`类中，如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we will add an option for the category and pass it to the `add` command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将为类别添加一个选项，并将其传递给`add`命令：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we update the handler method and its association with the command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新处理方法及其与命令的关联：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, do not forget to update `BookmarkService` so it handles the `Category`
    property accordingly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要忘记更新`BookmarkService`，以便它相应地处理`Category`属性。
- en: 'Now, if we execute the application without passing the category, no error is
    returned:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们不传递类别就执行应用程序，不会返回错误：
- en: '![Figure 5.4 – The Category option is optional](img/B22400_05_04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 类别选项是可选的](img/B22400_05_04.jpg)'
- en: Figure 5.4 – The Category option is optional
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 类别选项是可选的
- en: And, of course, if we pass a category, it works too. 😊
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们传递一个类别，它也会正常工作。😊
- en: '![Figure 5.5 – Assigning a category to the newly added bookmark](img/B22400_05_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 为新添加的书签分配类别](img/B22400_05_05.jpg)'
- en: Figure 5.5 – Assigning a category to the newly added bookmark
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 为新添加的书签分配类别
- en: However, since the category is now optional, if we don’t pass it, what would
    its value be?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于类别现在是可选的，如果我们不传递它，它的值会是什么？
- en: Double or single dash?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 双横线还是单横线？
- en: You might be wondering when we should use double versus single dashes. Do we
    even have to use both?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道何时应该使用双横线与单横线。我们甚至需要使用两者吗？
- en: The answer is no! You only use both if you want to provide both a long and a
    short form for passing in an option, but you can definitely opt for only one of
    these options.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的！只有当你想为传递选项提供长格式和短格式时，你才需要使用两者，但你绝对可以选择其中之一。
- en: For example, while `--set-max-concurrent-requests` might be more self-explanatory
    to someone new to your CLI, if they often use your CLI application, having to
    type this long form again and again may become frustrating. That’s why a short
    form, such as `-m`, will be more appropriate.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，虽然`--set-max-concurrent-requests`可能对刚接触你的CLI的用户来说更易于理解，但如果他们经常使用你的CLI应用程序，反复输入这种长格式可能会变得令人沮丧。这就是为什么简短的形式，如`-m`，将更加合适。
- en: In the real world, you will notice that users who are just starting to use your
    CLI application will rely on long-form options and gradually transition to short
    forms as they become more experienced with your CLI application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，你会注意到刚开始使用你的CLI应用程序的用户会依赖于长格式选项，并随着他们对CLI应用程序的熟悉程度提高，逐渐过渡到短格式。
- en: 'So, for example, a junior user of Bookmarkr will prefer this syntax:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，Bookmarkr的初级用户可能会更喜欢这种语法：
- en: '`bookmarkr link add --name "Packt Publishing" --``url "https://packtpub.com"`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`bookmarkr link add --name "Packt Publishing" --url "https://packtpub.com"`'
- en: 'An experienced user, on the other hand, is likely to prefer this syntax:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，经验丰富的用户可能会更喜欢这种语法：
- en: '`bookmarkr link add -n "Packt Publishing" -``u "https://packtpub.com"`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`bookmarkr link add -n "Packt Publishing" -u "https://packtpub.com"`'
- en: What about arguments?
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，参数怎么样？
- en: Ah! I can see that you’ve learned about arguments. Arguments are instances of
    the `Argument` class, and they represent required parameters that are essential
    to the execution of a command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！我可以看出你已经学习了关于参数的知识。参数是`Argument`类的一个实例，它们代表了执行命令所必需的参数。
- en: But wait… why not use arguments instead of options for required parameters?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等…为什么不用参数而不是选项来传递必需参数？
- en: You could, of course! But I don’t like these because they are *positional* parameters
    and not *named* parameters. This means that only their position instructs the
    user about their purpose, which, to me, sacrifices the readability of the CLI
    request.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然可以！但我不喜欢这些，因为它们是*位置参数*而不是*命名参数*。这意味着只有它们的顺序指导用户了解它们的目的，对我来说，这牺牲了CLI请求的可读性。
- en: 'To illustrate my point, here is what the call to the `link add` command would
    look like if it relied on arguments rather than parameters:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我的观点，以下是将`link add`命令的调用方式，如果它依赖于参数而不是参数：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: See how this is way less readable than our previous request (which relies on
    options)?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这比我们之前的请求（依赖于选项）的可读性差多少？
- en: That’s why I don’t like arguments and prefer to use options, specifying which
    ones are required and which ones are optional.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我不喜欢参数，而更喜欢使用选项，指定哪些是必选的，哪些是可选的。
- en: So, let’s get back to exploring options.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回到探索选项。
- en: Setting a default value for an option
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置选项的默认值
- en: Well, as you may have guessed, the default value for an option will be (by default)
    the default value for its data type (are you still with me?).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，正如你可能猜到的，一个选项的默认值将是（默认情况下）其数据类型的默认值（你还在吗？）。
- en: Since the `Category` option is of type `string`, its default value is `null`.
    However, the `Option` class allows us to define a default value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Category`选项是`string`类型，其默认值是`null`。然而，`Option`类允许我们定义一个默认值。
- en: 'Let’s set the default value for the `Category` option to `"Read later"`. This
    can be done by calling the `SetDefaultValue` method and passing in the default
    value:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`Category`选项的默认值设置为`"以后阅读"`。这可以通过调用`SetDefaultValue`方法并传入默认值来完成：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we run the program without providing a value for the `Category` option,
    we can see that its default value is used:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不提供`Category`选项的值来运行程序，我们可以看到它将使用默认值：
- en: '![Figure 5.6 – Using the default value for the category option](img/B22400_05_06.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – 使用类别选项的默认值](img/B22400_05_06.jpg)'
- en: Figure 5.6 – Using the default value for the category option
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 使用类别选项的默认值
- en: 'However, if we do provide a value for the category, we can see that this value
    is actually used:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们为类别提供了值，我们可以看到实际上使用了这个值：
- en: '![Figure 5.7 – Using the provided value for the category option](img/B22400_05_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – 使用提供的类别选项值](img/B22400_05_07.jpg)'
- en: Figure 5.7 – Using the provided value for the category option
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 使用提供的类别选项值
- en: Should we provide default values for required options?
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们是否应该为必选选项提供默认值？
- en: No, we should not! This is because if we do that, a required option will no
    longer behave as a required one but rather as an optional one.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们不应该这样做！这是因为如果我们这样做，必选选项将不再表现为必选，而是表现为可选。
- en: Why? Because if we do not provide a value for it, the default value will be
    used.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为我们没有提供它的值，所以将使用默认值。
- en: This is why default values should only be used with optional options.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么默认值应该只与可选选项一起使用。
- en: Note that in the previous example, the user can specify any string value for
    the `Category` option. But what if we wanted to control the set of allowed values?
    This is where the `FromAmong` method comes in.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在先前的例子中，用户可以为`Category`选项指定任何字符串值。但如果我们想控制允许的值集呢？这就是`FromAmong`方法发挥作用的地方。
- en: Controlling the allowed values for an option
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制选项的允许值
- en: Let’s pretend for a moment that we only allow a set of categories in our application.
    Yes, in real life, we would allow users to create as many categories as they want,
    but this will serve our purpose of explaining how to only allow a specific set
    of values for an option.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设在我们的应用程序中我们只允许一组类别。是的，在现实生活中，我们会允许用户创建他们想要的任何数量的类别，但这将服务于我们解释如何只允许选项的一组特定值的用途。
- en: 'Let’s say we allow the following categories:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们允许以下类别：
- en: Read later (which serves as the default one)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以后阅读（作为默认值）
- en: Tech books
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 科技书籍
- en: Cooking
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 烹饪
- en: Social media
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交媒体
- en: 'We will do this by passing these values to the `FromAmong` method as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将这些值传递给`FromAmong`方法来完成这项工作，如下所示：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we run the application by passing in an allowed category, everything works
    fine:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过传递一个允许的类别来运行应用程序，一切都会正常工作：
- en: '![Figure 5.8 – Passing in an allowed value for the category](img/B22400_05_08.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 为类别传递一个允许值](img/B22400_05_08.jpg)'
- en: Figure 5.8 – Passing in an allowed value for the category
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 为类别传递一个允许值
- en: 'However, if we do pass an unallocated category value, we will get an error
    message:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们传递一个未分配的类别值，我们会得到一个错误消息：
- en: '![Figure 5.9 – Passing in an unallowed value for the category](img/B22400_05_09.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 为类别传递不允许的值](img/B22400_05_09.jpg)'
- en: Figure 5.9 – Passing in an unallowed value for the category
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 为类别传递不允许的值
- en: 'Notice that the error message indicates the allowed values. We can also see
    the allowed values from the help menu:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，错误消息指示了允许的值。我们还可以从帮助菜单中看到允许的值：
- en: '![Figure 5.10 – Seeing the allowed values in the help menu](img/B22400_05_10.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10 – 在帮助菜单中查看允许的值](img/B22400_05_10.jpg)'
- en: Figure 5.10 – Seeing the allowed values in the help menu
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 在帮助菜单中查看允许的值
- en: Using `FromAmong` can be particularly useful for ensuring data integrity and
    guiding user input, especially in scenarios where options need to conform to a
    predefined set of valid values.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FromAmong`可以特别有用，以确保数据完整性和指导用户输入，尤其是在选项需要符合预定义的有效值集的场景中。
- en: Okay, so let’s recap. Our CLI application has required and optional parameters.
    It specifies a default value for its optional parameter, along with allowed values.
    However, we are missing something, something important. Can you guess what it
    is?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么让我们回顾一下。我们的CLI应用程序有必需和可选参数。它为它的可选参数指定了一个默认值，以及允许的值。然而，我们仍然缺少一些东西，一些重要的事情。你能猜到是什么吗？
- en: Yes, exactly, the ability to ensure that the provided value for a specific parameter
    is valid.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，正是这样，确保为特定参数提供的值是有效的。
- en: Validating input values
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证输入值
- en: When adding a new bookmark, we need to pass a URL for it. But, until now, we
    haven’t checked whether the provided value is indeed a valid URL. Let’s fix this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加新的书签时，我们需要为其传递一个URL。但是，到目前为止，我们还没有检查提供的值是否确实是一个有效的URL。让我们解决这个问题。
- en: The `Option` class allows us to configure a validator function. We will then
    add a validator method for `urlOption` to ensure it only gets valid URLs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`类允许我们配置验证函数。然后我们将为`urlOption`添加一个验证方法，以确保它只能获取有效的URL。'
- en: 'This can be achieved by calling the `AddValidator` method, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过调用`AddValidator`方法来实现，如下所示：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code snippet, the `AddValidator` method uses an inline delegate
    to ensure that the value provided to `urlOption` is valid. In this case, it ensures
    that it is actually present (that’s what the `if` section is checking) and that
    it is a valid URL (that’s what the `else if` section is checking).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`AddValidator`方法使用内联委托来确保提供给`urlOption`的值是有效的。在这种情况下，它确保它实际上是存在的（这就是`if`部分检查的内容）并且它是一个有效的URL（这就是`else
    if`部分检查的内容）。
- en: 'So now, if we execute the program with both an invalid and a valid URL, we
    can see that it behaves as expected:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用无效和有效的URL执行程序，我们可以看到它表现如预期：
- en: '![Figure 5.11 – Validating the input value for the URL option](img/B22400_05_11.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11 – 验证URL选项的输入值](img/B22400_05_11.jpg)'
- en: Figure 5.11 – Validating the input value for the URL option
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 – 验证URL选项的输入值
- en: More advanced validation
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的验证
- en: Validation could be more advanced than that. Our application is intended to
    collect bookmarks from everywhere on the web. However, if you would like to restrict
    its usage to, let’s say, your organization only, you may want to check (in your
    validation process) that the bookmarked URLs are only referring to your corporate
    domain and dismiss everything else.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 验证可能比这更复杂。我们的应用程序旨在从网络上的任何地方收集书签。然而，如果您希望将其使用限制在，比如说，您的组织内，您可能希望在验证过程中检查书签的URL是否仅指向您的企业域名，并忽略其他所有内容。
- en: Perfect! So now, Bookmarkr allows us to manage bookmarks, ensuring that only
    valid information can be passed to (and stored in) the CLI application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在，Bookmarkr允许我们管理书签，确保只有有效信息可以被传递到（并存储在）CLI应用程序中。
- en: However, up to this point, we can still only add one bookmark at a time. Wouldn’t
    it be nice if we could provide a set of names and URLs as part of the same request
    and have Bookmarkr add them in one go?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止，我们仍然一次只能添加一个书签。如果我们能够作为同一请求的一部分提供一组名称和URL，并且让Bookmarkr一次性添加它们，那不是很好吗？
- en: '`System.CommandLine` has a feature that allows us to do just that 😉.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.CommandLine`有一个功能允许我们做到这一点 😉。'
- en: Adding multiple elements in one go
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次性添加多个元素
- en: 'Let’s try passing in multiple names and URLs to the same request, such as this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试向同一个请求传递多个名称和URL，例如：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But if we do this, we will get the following error:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们这样做，我们会得到以下错误：
- en: '![Figure 5.12 – Name and URL options expect only one value by default](img/B22400_05_12.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 名称和 URL 选项默认只期望一个值](img/B22400_05_12.jpg)'
- en: Figure 5.12 – Name and URL options expect only one value by default
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 名称和 URL 选项默认只期望一个值
- en: This is due to the arity of these options.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这些选项的参数数量。
- en: '**What is an** **arity, anyway?**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**那么，参数数量究竟是什么意思呢？**'
- en: The arity of an option represents the number of values that can be passed if
    that option is specified. It is expressed with a minimum value and a maximum value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 选项的参数数量表示如果指定了该选项，可以传递的值的数量。它用最小值和最大值来表示。
- en: This is of great importance if your CLI application supports bulk operations
    through one or many of its commands. In our example, we want to perform a bulk
    operation for adding multiple bookmarks at the same time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 CLI 应用程序通过一个或多个命令支持批量操作，这非常重要。在我们的例子中，我们想要同时添加多个书签的批量操作。
- en: In the case of an option of type `string`, the minimum and maximum values are
    both set to `1`, which means that if we specify the option, we must provide a
    value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型为 `string` 的选项，最小值和最大值都设置为 `1`，这意味着如果我们指定了选项，我们必须提供一个值。
- en: 'A Boolean option will have a minimum value of `0` and a maximum value of `1`
    since we don’t need to pass in a value as both these syntaxes are valid:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔选项的最小值是 `0`，最大值是 `1`，因为我们不需要传递值，因为这两种语法都是有效的：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the same way, a list of elements has a minimum arity of 1 and a maximum of
    (by default) 100,000.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个元素列表的最小参数数量为 1，默认最大值为 100,000。
- en: 'In order to specify the arity of an option, `System.CommandLine` provides an
    enumeration named `ArgumentArity`, which has these values:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定选项的参数数量，`System.CommandLine` 提供了一个名为 `ArgumentArity` 的枚举，它包含以下值：
- en: '`Zero`, meaning no values are allowed. So, `--force` would be valid but not
    `--``force true`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Zero`，意味着不允许任何值。所以，`--force` 是有效的，但 `--force true` 则不是。'
- en: '`ZeroOrOne`, meaning a minimum of zero and a maximum of one value is allowed.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZeroOrOne`，意味着允许零个或一个值。'
- en: '`ZeroOrMore`, meaning either zero, one, or many values are allowed.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZeroOrMore`，意味着允许零个、一个或多个值。'
- en: '`ExactlyOne`, meaning a minimum of one and a maximum of one value is allowed.
    This is the case for our string options, name, and URL.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExactlyOne`，意味着至少一个且最多一个值是被允许的。对于我们的字符串选项，名称和 URL 就是这种情况。'
- en: '`OneOrMore`, meaning either one or multiple values are allowed.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OneOrMore`，意味着允许一个或多个值。'
- en: 'To set the arity of an option, we can then use one of the values provided by
    the `ArgumentArity` enumeration, like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置一个选项的参数数量，我们可以使用 `ArgumentArity` 枚举提供的值之一，如下所示：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So now, we should be able to provide multiple values for a given option. Let’s
    try this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够为给定选项提供多个值。让我们试试这个：
- en: '![Figure 5.13 – Failing to provide multiple values for a given option](img/B22400_05_13.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 未为给定选项提供多个值](img/B22400_05_13.jpg)'
- en: Figure 5.13 – Failing to provide multiple values for a given option
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 未为给定选项提供多个值
- en: Oops, this is not what we expected, right?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，这不是我们预期的结果，对吧？
- en: The problem here is that even though `nameOption` can accept more than one value,
    it is not clear to the program how to convert those values into a single string.
    This is why the error message is referring to a custom binder (so it is told how
    to perform such a conversion).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题在于，尽管 `nameOption` 可以接受多个值，但程序并不清楚如何将这些值转换成一个字符串。这就是为什么错误信息提到了自定义绑定器（因此它被告知如何执行这种转换）。
- en: 'In order to fix this problem, we need to tell the program to treat each of
    these inputs as a separate argument. This is done by setting the `AllowMultipleArgumentsPerToken`
    property to `true`, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要告诉程序将这些输入视为单独的参数。这是通过将 `AllowMultipleArgumentsPerToken` 属性设置为 `true`
    来实现的，如下所示：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Also, let’s get rid of the arity for a moment by commenting out the corresponding
    line of code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过注释掉相应的代码行来暂时去掉参数数量。
- en: Now, if we run the program, we can see that the error is gone but we are still
    not getting the expected result…
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行程序，我们可以看到错误已经消失了，但我们仍然没有得到预期的结果…
- en: '![Figure 5.14 – nameOption is now accepting multiple values](img/B22400_05_14.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – nameOption 现在接受多个值](img/B22400_05_14.jpg)'
- en: Figure 5.14 – nameOption is now accepting multiple values
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – nameOption 现在接受多个值
- en: Notice how only the last pair of names and URLs were considered and added to
    the list of bookmarks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有最后的一对名称和 URL 被考虑并添加到书签列表中。
- en: What happened, in fact, is that `System.CommandLine` noticed that we have two
    occurrences of the name and URL, so the last ones have overridden the first ones
    and only those last ones were actually passed to the `Handler` method. This is
    why we only get one bookmark added with the information of the last pair of names
    and URL values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上发生的情况是，`System.CommandLine`注意到我们有两个名称和URL的出现，所以最后的那些覆盖了第一个，只有最后的那些实际上被传递给了`Handler`方法。这就是为什么我们只添加了一个带有最后对名称和URL值信息的书签。
- en: But what if we want to be able to pass a list of names and URLs and have the
    `Handler` method add as many bookmarks as the number of name and URL pairs?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要能够传递一个名称和URL的列表，并且让`Handler`方法添加与名称和URL对数量相等的书签，那会怎么样呢？
- en: To do this, we need two things. First, let’s uncomment the lines of code that
    set the arities for `nameOption`, `urlOption`, and `categoryOption`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要两样东西。首先，让我们取消注释设置`nameOption`、`urlOption`和`categoryOption`的arity的代码行。
- en: 'Next, let’s change the declaration of the name, URL, and category options along
    with the validator and the signature of the `Handler` method so that they accept
    a list of strings rather than a single string:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更改名称、URL和类别选项的声明，以及验证器和`Handler`方法的签名，以便它们接受字符串列表而不是单个字符串：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, if we run the program, things work (finally) as expected! 😊
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行程序，事情（终于）按预期工作！😊
- en: '![Figure 5.15 – Bookmarkr accepts a list of bookmarks](img/B22400_05_15.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图5.15 – Bookmarkr接受书签列表](img/B22400_05_15.jpg)'
- en: Figure 5.15 – Bookmarkr accepts a list of bookmarks
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15 – Bookmarkr接受书签列表
- en: 'Since each option accepts multiple values, let’s take a look at whether we
    can simplify the following CLI request:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个选项都接受多个值，让我们看看我们是否可以简化以下CLI请求：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We’ll simplify it as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下方式简化它：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that we only need to specify `--name`, `--url`, and `--``category` once.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只需要指定一次`--name`、`--url`和`--category`。
- en: 'Since both CLI requests are equivalent, they lead to the same result:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个CLI请求是等效的，它们导致相同的结果：
- en: '![Figure 5.16 – Simplified CLI request](img/B22400_05_16.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图5.16 – 简化的CLI请求](img/B22400_05_16.jpg)'
- en: Figure 5.16 – Simplified CLI request
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16 – 简化的CLI请求
- en: Excellent! This works just great!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这工作得非常好！
- en: But… typing a list of names, URLs, and categories might quickly become tedious
    as the list grows.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但是……当列表增长时，输入一系列名称、URL和类别可能会很快变得繁琐。
- en: Wouldn’t it be nice if we could simply provide the path to a file as a parameter
    that contains all the names, URLs, and categories and let the application read
    that file and create the bookmarks accordingly?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够简单地提供一个包含所有名称、URL和类别的文件路径作为参数，让应用程序读取该文件并相应地创建书签，那岂不是很好？
- en: In the same way, wouldn’t it be nice if we could specify the path to an output
    file to store all the bookmarks our CLI application is holding?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们能够指定一个输出文件的路径来存储CLI应用程序持有的所有书签，那岂不是很好？
- en: Working with files passed in as options values
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理作为选项值传递的文件
- en: Files can be provided as options values to serve as input or output parameters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 文件可以作为选项值提供，作为输入或输出参数。
- en: As an input parameter, a file’s content can be read to import data into the
    CLI application. In our case, we could import bookmarks from other browsers, such
    as Chrome or Firefox, into Bookmarkr.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输入参数，可以读取文件内容以将数据导入CLI应用程序。在我们的例子中，我们可以将来自其他浏览器（如Chrome或Firefox）的书签导入到Bookmarkr中。
- en: As an output parameter, a file can be created to export the data that is held
    by Bookmarkr, which in turn can be imported into other browsers, such as Chrome
    or Firefox.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出参数，可以创建一个文件来导出Bookmarkr持有的数据，该数据反过来可以导入到其他浏览器，如Chrome或Firefox。
- en: Together, these two capabilities can enable backup and restore but also data
    sharing and exchange scenarios.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个功能结合在一起可以启用备份和恢复，也可以实现数据共享和交换场景。
- en: Let’s build these features into Bookmarkr!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这些功能构建到Bookmarkr中！
- en: Important note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Browsers, such as Chrome or Firefox, have their own proprietary structure to
    import and export bookmarks.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器，如Chrome或Firefox，都有自己的专有结构来导入和导出书签。
- en: We won’t be performing parsing or conversion to these formats for the sake of
    simplicity. Our goal is to focus on working with input and output files as part
    of a CLI application. We will, however, import and export bookmarks in JSON format.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们不会对这些格式进行解析或转换。我们的目标是专注于将输入和输出文件作为CLI应用程序的一部分进行处理。然而，我们将以JSON格式导入和导出书签。
- en: Let’s begin with the `export` command.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`export`命令开始。
- en: This command is meant to take all bookmarks managed by Bookmarkr and save them
    in a JSON file whose path is specified as a value to the `--file` option. This
    option is, of course, required.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to create an option of type `FileInfo`, and it will be
    required:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we will need to create a new command and add it to the `root` command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we need to set a `Handler` method for the `export` command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Handler` method calls `BookmarkService` to get the list of all bookmarks,
    then converts them to JSON and saves that JSON content into the provided file.
    If the file already exists, it is overwritten.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you’ll need to import this namespace for the code to compile:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let’s try it and see whether it works as expected!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Exporting all bookmarks](img/B22400_05_17.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Exporting all bookmarks
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Perfect! This is exactly what we expected!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: But how can we ensure that the provided file has a valid name?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'We could certainly create a validator method to check this, but `System.CommandLine`
    already provides an extension method for that matter (and I wanted to let you
    know 😉):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s try calling the `export` command with an invalid file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Handling invalid files](img/B22400_05_18.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – Handling invalid files
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: See? That error has been raised because of the call to the `LegalFileNamesOnly`
    method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Okay! Now let’s move on to adding the `import` command!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, the syntax to import bookmark data from an existing file is
    as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Since many of the steps involved are very similar to the ones we followed to
    create the `export` command, let’s just share the code here and discuss the differences:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The main difference is the call to the `ExistingOnly` method. This method ensures
    that `inputfileOption` will only accept values corresponding to existing files,
    otherwise an error is raised.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'The other difference is how the `OnImportCommand` handler method operates:
    it reads the content of the file, converts it from JSON to a list of items of
    type `Bookmark`, and then passes it to `BookmarkService` to add these items to
    the list of bookmarks it manages (by calling its `Import` method).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s try this code!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Importing bookmarks from a file](img/B22400_05_19.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – Importing bookmarks from a file
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: What happens if the file doesn’t exist?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Handling a non-existent file](img/B22400_05_20.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – Handling a non-existent file
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we can see that we are getting the expected result! 😊
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: And that’s a wrap! You now know how to work with input and output files in your
    CLI applications. Congratulations! Let’s now conclude this chapter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we improved our CLI application, Bookmarkr, by adding better
    control for the input values for its command’s options (by explicitly indicating
    what options are required, setting default values where appropriate, designing
    validators to ensure the input values comply with the expected type, format, or
    range of values, and enabling auto-completion to make things simpler for the user).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过添加对命令选项输入值的更好控制来改进了我们的CLI应用程序Bookmarkr（通过明确指出哪些选项是必需的，在适当的地方设置默认值，设计验证器以确保输入值符合预期的类型、格式或值范围，并启用自动完成以简化用户操作）。
- en: We also added the ability to import and export application data from and to
    a file. This makes it easier to back up and restore data and even share it offline.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了从文件导入和导出应用程序数据的功能。这使得备份和恢复数据以及离线共享数据变得更加容易。
- en: 'In the upcoming chapter, we will see how to implement a very important feature
    in every application: logging and error handling.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到如何实现每个应用程序都非常重要的功能：日志记录和错误处理。
- en: Your turn!
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮到你了！
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随提供的代码是一种通过实践学习的好方法。
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the Bookmarkr application by adding the following features.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的方法是挑战自己完成任务。因此，我挑战你通过添加以下功能来改进Bookmarkr应用程序。
- en: 'Task #1 – validating the format and the ability to access the input file'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #1 – 验证输入文件的格式和访问能力'
- en: 'As a reminder, the syntax to import bookmark data from an existing file is
    as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，从现有文件导入书签数据的语法如下：
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the input file cannot be accessed, or if its data is not in the expected
    format, then the application should display a corresponding error message to the
    user. Otherwise, the application should import all the bookmarks from the input
    file and display a success message to the user indicating how many bookmarks have
    been imported.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法访问输入文件，或者其数据不是预期的格式，那么应用程序应向用户显示相应的错误消息。否则，应用程序应从输入文件导入所有书签并向用户显示成功消息，指示已导入多少个书签。
- en: 'Task #2 – merging existing links from the input file'
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #2 – 合并输入文件中的现有链接'
- en: When importing bookmarks from an existing file, it is possible that some of
    them already exist in the bookmarks held by the application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当从现有文件导入书签时，可能其中一些已经存在于应用程序持有的书签中。
- en: In such a situation, it is a best practice for a CLI application to provide
    the user with an option to control whether they want to merge those existing links
    or simply discard them and not import them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对于CLI应用程序来说，向用户提供一个选项来控制他们是否想要合并那些现有链接或简单地丢弃它们而不导入它们，是一种最佳实践。
- en: In this task, I challenge you to implement this best practice by adding an optional
    `--merge` option to the `import` command.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我挑战你通过在`import`命令中添加一个可选的`--merge`选项来实现这一最佳实践。
- en: 'Hence, the syntax for the `import` command with the `--merge` option will be
    as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，带有`--merge`选项的`import`命令的语法如下：
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the `--merge` option is specified, the expected behavior of the `import`
    command is that for each bookmark in the provided input file, the following apply:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定`--merge`选项时，`import`命令的预期行为是对于提供的输入文件中的每个书签，以下适用：
- en: If its URL already exists in the list of bookmarks held by the application,
    the name of the existing bookmark should be updated with the name corresponding
    to this URL in the input file
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其URL已存在于应用程序持有的书签列表中，则现有书签的名称应更新为与输入文件中此URL对应的名称
- en: Otherwise, the bookmark should simply be added to the list of bookmarks held
    by the application
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，书签应简单地添加到应用程序持有的书签列表中
