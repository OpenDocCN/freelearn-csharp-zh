<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Multiplayer Setup</h1>
                
            
            <article>
                
<p class="calibre3">The desire of every indie game developer is to make a multiplayer game. The reality is, creating multiplayer games is difficult. There are a lot of scenarios that you need to take into consideration as a game designer/developer. Besides the technical complexities that are involved in the nature of creating online multiplayer games, there are also game-play elements that you will need to consider.</p>
<p class="calibre3">The purpose of this chapter is to give you a good overview of the out-of-box networking functionality using the new Unity networking paradigm. This is a complex topic, and as such we cannot cover everything in this chapter. A whole new book will be required to really dive into the details.</p>
<p class="calibre3">Having said that, I have prepared this chapter to include one simple project, which will be used to illustrate the fundamentals of networking. I will then show you how to network-enable our own game objects.</p>
<p class="calibre3">In this chapter, we will cover the following:</p>
<ul class="calibre11">
<li class="calibre12">Heads-up display</li>
<li class="calibre12">Completing a HUD design</li>
<li class="calibre12">Integrating the code</li>
</ul>
<p class="calibre3">Here we go!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Challenges of a multiplayer game</h1>
                
            
            <article>
                
<p class="calibre3">A general rule of thumb is, if you don't need to enable your game to be multiplayer, don't! It just adds a whole lot of complexity and extra requirements and specifications that you will need to start worrying about. But if you must, then you must!</p>
<p class="calibre3">You probably know by now that creating even the simplest multiplayer game has its own challenges you will need to address as the game designer. There are different types of online multiplayer game design, as follows:</p>
<ul class="calibre11">
<li class="calibre12">Real-time multiplayer games</li>
<li class="calibre12">Turn-based multiplayer games</li>
<li class="calibre12">Asynchronous multiplayer games</li>
<li class="calibre12">Local multiplayer games</li>
</ul>
<p class="calibre3">The most challenging out of all the different types of multiplayer games is real-time multiplayer gaming. This is because all players have to be synchronized in a proper and effective way with the latest game state at any given time.</p>
<p class="calibre3">That is, if we have Player A perform a specific action, Player B will see the action at the same time on his or her screen. Now, consider we have another player join, say Player C; Players A and B will need to synchronize with Player C, and in turn Player C will need to synchronize its own environment with Player A's and Player B's state.</p>
<p class="calibre3">Not only does the actual position/rotation of the players have to be synchronized, but also all of the player data. Now, imagine what will happen when you multiply this by 100, 1,000, or 1,000,000 connected players.</p>
<p class="calibre3">For a real-world multiplayer game, what we will cover here is not enough, and what Unity provides out of the box is not enough either. Chances are you will need to write your own server-side code to handle the player data.</p>
<p class="calibre3">Now you can see the challenge involved in designing and developing multiplayer games, we can start by building our first multiplayer game.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Initial multiplayer game</h1>
                
            
            <article>
                
<p class="calibre3">The best way to learn about multiplayer games is by looking at a simple example. The following project is based on the Unity networking tutorial but has been extended to have some other features implemented that will be helpful in the implementation of networking in our RPG.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Fundamental networking components</h1>
                
            
            <article>
                
<p class="calibre3">Since the first edition of the book, a lot of technical and architectural changes have occurred within the Unity engine. Networking is one of the areas that has improved drastically since the publication of the first edition.</p>
<p class="calibre3">Let's take a look and see how we can quickly get started. The first thing you will need to do is download the <em class="calibre14"><span class="calibre6">Network Lobby</span></em> asset from the Asset Store, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00169.jpeg" class="calibre126"/></div>
<p class="calibre3">This is a great starting point, as we have a generic network lobby to start off with, so we don't have to waste time creating everything from scratch!</p>
<p class="calibre3">We need to get familiar with some networking components that will be used for the creation of our network-enabled games. These components are as follows:</p>
<ul class="calibre11">
<li class="calibre12">Network Manager: <kbd class="calibre13">NetworkManager</kbd> is a high-level class that allows you to control the state of a networked game. It provides an interface in the editor to control the configuration of the network, the prefabs used for spawning, and the scenes to use for different network game states.</li>
<li class="calibre12">Network Lobby Manager: <kbd class="calibre13">NetworkLobbyManager</kbd> is a specialized type of <kbd class="calibre13">NetworkManager</kbd> that provides a multiplayer lobby before entering the main play scene of the game. Ideal for matchmaking.</li>
<li class="calibre12">Network Manager HUD: This provides a default user interface for controlling the network state of the game. It also shows information about the current state of <kbd class="calibre13">NetworkManager</kbd> in the editor.</li>
<li class="calibre12">Network Identity: The <kbd class="calibre13">NetworkIdentity</kbd> component is at the heart of the new networking system. This component controls an object's network identity, and it makes the networking system aware of it.</li>
<li class="calibre12">Network Transform: The <kbd class="calibre13">NetworkTransform</kbd> component synchronizes the movement of game objects across the network. This component takes authority into account, so <kbd class="calibre13">LocalPlayer</kbd> objects synchronize their position from the client to the server, then out to other clients. Other objects (with server authority) synchronize their position from the server to clients.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">My tank networking project</h1>
                
            
            <article>
                
<p class="calibre3">It is assumed that you have downloaded and imported the Network Lobby asset. We will be using two scenes to illustrate the concept. The first scene will be the lobby scene, and the second scene will be where the game will take place.</p>
<p class="calibre3">Go ahead and create a scene, and name it <kbd class="calibre13">NetworkingGameLobby</kbd>. This is where the game will start. Take a look at the following screenshot:</p>
<div class="mce-root1"><img src="../images/00170.jpeg" class="calibre45"/></div>
<div class="mce-root2">My tank network lobby</div>
<p class="calibre3">Add the <kbd class="calibre13">LobbyManager</kbd> prefab to the scene. Select the <kbd class="calibre13">LobbyManager</kbd> GameObject in the scene, and note the <kbd class="calibre13">LobbyManager</kbd> component in the <span class="calibre6">Inspector</span> window. There are several things to notice here. First, you will need to assign the <span class="calibre6">Lobby Scene</span> and the Play Scene properties. We need to assign our <kbd class="calibre13">NetworkingGameLobby</kbd> scene to the <span class="calibre6">Lobby Scene</span> property, and the <kbd class="calibre13">NetworkingGamePlay</kbd> scene to the <span class="calibre6">Play Scene</span> property. Next, you will need to assign the <kbd class="calibre13">Game Player</kbd> Prefab property with the <kbd class="calibre13">Player</kbd> prefab. Don't worry, we will create the <kbd class="calibre13">Player</kbd> prefab next. Finally, we need to configure the Spawn Info section, and register the prefabs (GameObjects) that will be spawned during game time; in our case, these will be the Bullet and the Enemy Tanks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding a player character</h1>
                
            
            <article>
                
<p class="calibre3">We will now add a simple player character. You can really use any primitive GameObject to represent your PC; I will create my player to take the shape of a simple tank. Take a look at the following screenshot:</p>
<div class="mce-root1"><img src="../images/00171.jpeg" class="calibre127"/></div>
<p class="calibre3">The following screenshot will illustrate the hierarchy of the <kbd class="calibre13">Tank</kbd> GameObject:</p>
<div class="mce-root1"><img src="../images/00172.jpeg" class="calibre128"/></div>
<p class="calibre3"/>
<p class="calibre3">I will not cover how to create the GameObject, as you should be able to do that very easily by now. What I will cover, is how to enable the new network-enabled<span class="calibre6"> </span>Tank GameObject.</p>
<p class="calibre3">We will attach two network components to the <kbd class="calibre13">Tank</kbd> GameObject. The first one will be <kbd class="calibre13">NetworkIdentity</kbd>, which can be added by selecting the <kbd class="calibre13">Tank</kbd> GameObject, and from within the <span class="calibre6">Inspector</span> window, select <span class="calibre6">Add Component</span> | <span class="calibre6">Network</span> | <span class="calibre6">Network Identity</span>.</p>
<p class="calibre3">When you are done adding the component, make sure to check the <span class="calibre6">Local Player Authority</span> property checkbox, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00173.jpeg" class="calibre129"/></div>
<p class="calibre3"><span class="calibre6">Local Player Authority</span> allows the object to be controlled by the client that owns it.</p>
<p class="calibre3">Next, we need to add the <kbd class="calibre13">NetworkTransform</kbd> component to the Tank GameObject. Again, selecting the <kbd class="calibre13">Tank</kbd> GameObject, from the <span class="calibre6">Inspector</span> window, click <span class="calibre6">Add Component</span> | <span class="calibre6">Network</span> | <span class="calibre6">NetworkTransform</span> to add the component:</p>
<div class="mce-root1"><img src="../images/00174.jpeg" class="calibre130"/></div>
<p class="calibre3">We will keep the default values for the <kbd class="calibre13">NetworkTransform</kbd> component. With the exception of the rotation properties, since we are only rotating on the <em class="calibre14">Y</em>-axis, we don't have to send all XYZ information, so change that to <span class="calibre6">Y</span> (<span class="calibre6">Top-Down 2D</span>) and increase the interpolate Rotation field to 15, and change the Compress Ratio to High. You can read more about the different properties on your own using the online documentation. The main attribute you might want to adjust is the <span class="calibre6">Network Send Rate</span>.</p>
<p class="calibre3">Next, we want to create a script that will allow us to control the movement of the Tank. Go ahead and create a new C# script and name it <kbd class="calibre13">MyPlayerController.cs</kbd>.</p>
<p class="calibre3">Here is a listing of the script:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/>using UnityEngine.Networking;<br class="title-page-name"/>using System.Collections;<br class="title-page-name"/>public class MyPlayerController : NetworkBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>public Transform mainCamera;<br class="title-page-name"/>public float cameraDistance = 16f;<br class="title-page-name"/>public float cameraHeight = 16f;<br class="title-page-name"/>public Vector3 cameraOffset;<br class="title-page-name"/>[SyncVar]<br class="title-page-name"/>public Color myColor;<br class="title-page-name"/>public GameObject bulletPrefab;<br class="title-page-name"/>public Transform bulletSpawn;<br class="title-page-name"/>private void Start()<br class="title-page-name"/>{<br class="title-page-name"/>GetComponent&lt;MeshRenderer&gt;().material.color = myColor;<br class="title-page-name"/>cameraOffset = new Vector3(0f, cameraHeight, -cameraDistance);<br class="title-page-name"/>mainCamera = Camera.main.transform;<br class="title-page-name"/>MoveCamera();<br class="title-page-name"/>}<br class="title-page-name"/>void Update()<br class="title-page-name"/>{<br class="title-page-name"/>// only execute the following code if local player ...<br class="title-page-name"/>if (!isLocalPlayer)<br class="title-page-name"/>return;<br class="title-page-name"/>#if UNITY_EDITOR<br class="title-page-name"/>var x = Input.GetAxis("Horizontal") * Time.deltaTime * 150.0f;<br class="title-page-name"/>var z = Input.GetAxis("Vertical") * Time.deltaTime * 3.0f;<br class="title-page-name"/>#else<br class="title-page-name"/>var x = ETCInput.GetAxis("Horizontal") * Time.deltaTime * 150.0f;<br class="title-page-name"/>var z = ETCInput.GetAxis("Vertical") * Time.deltaTime * 3.0f;<br class="title-page-name"/>#endif<br class="title-page-name"/>transform.Rotate(0, x, 0);<br class="title-page-name"/>transform.Translate(0, 0, z);<br class="title-page-name"/>#if UNITY_EDITOR<br class="title-page-name"/>if (Input.GetKeyDown(KeyCode.Space))<br class="title-page-name"/>{<br class="title-page-name"/>CmdFire();<br class="title-page-name"/>}<br class="title-page-name"/>#else<br class="title-page-name"/>if (ETCInput.GetButtonDown("ButtonFire"))<br class="title-page-name"/>{<br class="title-page-name"/>CmdFire();<br class="title-page-name"/>}<br class="title-page-name"/>#endif<br class="title-page-name"/>MoveCamera();<br class="title-page-name"/>}<br class="title-page-name"/>[Command]<br class="title-page-name"/>void CmdFire()<br class="title-page-name"/>{<br class="title-page-name"/>// Create the Bullet from the Bullet Prefab<br class="title-page-name"/>var bullet = Instantiate(<br class="title-page-name"/>bulletPrefab,<br class="title-page-name"/>bulletSpawn.position,<br class="title-page-name"/>bulletSpawn.rotation) as GameObject;<br class="title-page-name"/>// Add velocity to the bullet<br class="title-page-name"/>bullet.GetComponent&lt;Rigidbody&gt;().velocity = bullet.transform.forward *6;<br class="title-page-name"/>bullet.GetComponent&lt;Bullet&gt;().myColor = myColor;<br class="title-page-name"/>// Spawn the bullet on the Clients<br class="title-page-name"/>NetworkServer.Spawn(bullet);<br class="title-page-name"/>// Destroy the bullet after 2 seconds<br class="title-page-name"/>Destroy(bullet, 2.0f);<br class="title-page-name"/>}<br class="title-page-name"/>void MoveCamera()<br class="title-page-name"/>{<br class="title-page-name"/>mainCamera.position = transform.position;<br class="title-page-name"/>mainCamera.rotation = transform.rotation;<br class="title-page-name"/>mainCamera.Translate(cameraOffset);<br class="title-page-name"/>mainCamera.LookAt(transform);<br class="title-page-name"/>}<br class="title-page-name"/>}</pre>
<p class="calibre3">The code is straightforward, but there are some important concepts that we need to discuss. First and foremost, you will notice that we are inheriting from <kbd class="calibre13">NetworkBehaviour</kbd> instead of <kbd class="calibre13">MonoBehaviour</kbd>.</p>
<p class="calibre3"><kbd class="calibre13">NetworkBehaviour</kbd> is used to work with objects with the <kbd class="calibre13">NetworkIdentiy</kbd> component. This allows you to perform network-related functions such as <kbd class="calibre13">Commands</kbd>, <kbd class="calibre13">ClientRPCs</kbd>, <kbd class="calibre13">SyncEvents</kbd>, and <kbd class="calibre13">SyncVars</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Variable synchronization</h1>
                
            
            <article>
                
<p class="calibre3">Synchronizing variables is one of the important aspects of a multiplayer game. If you recall, one of the challenges of multiplayer games is the ability to make sure all of the key data for the game is synchronized across the server and the clients. This is accomplished by the <kbd class="calibre13">SyncVar</kbd> attribute. You will see how this is applied in the next script, which we will create for the health of the unity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Network callbacks</h1>
                
            
            <article>
                
<p class="calibre3">Network callbacks are functions that are invoked on the <kbd class="calibre13">NetworkBehaviour</kbd> script for various network events. They are listed as follows:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">OnStartServer()</kbd> is called when an object is spawned on the server, or when the server is started for objects in the scene</li>
<li class="calibre12"><kbd class="calibre13">OnStartClient()</kbd> is called when the object is spawned on the client, or when the client connects to a server for objects in the scene</li>
<li class="calibre12"><kbd class="calibre13">OnSerialize()</kbd> is called to gather state to send from the server to the clients</li>
<li class="calibre12"><kbd class="calibre13">OnDeSerialize()</kbd> is called to apply state to objects on clients</li>
<li class="calibre12"><kbd class="calibre13">OnNetworkDestroy()</kbd> is called on clients when the server tells the object to be destroyed</li>
<li class="calibre12"><kbd class="calibre13">OnStartLocalPlayer()</kbd> is called on clients for player objects for the local client only</li>
<li class="calibre12"><kbd class="calibre13">OnRebuildObservers()</kbd> is called on the server when the set of observers for an object is rebuilt</li>
<li class="calibre12"><kbd class="calibre13">OnSetLocalVisibility()</kbd> is called on a host when the visibility of an object changes for the local client</li>
<li class="calibre12"><kbd class="calibre13">OnCheckObserver()</kbd> is called on the server to check the visibility state for a new client</li>
</ul>
<p class="calibre3">In the <kbd class="calibre13">PlayerController.cs</kbd> script, you will notice that we are using <kbd class="calibre13">OnStartClient()</kbd> to highlight the local player by changing its material color to blue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sending commands</h1>
                
            
            <article>
                
<p class="calibre3">Commands are how clients request a function to be performed on the server. In a server authoritative system, clients can only do things through commands. Commands are run on the player object on the server that corresponds to the client that sent the command. This routing happens automatically, so it is impossible for a client to send a command for a different player.</p>
<p class="calibre3">A command must begin with the prefix "Cmd" and have the <kbd class="calibre13">[Command]</kbd> custom attribute on it.</p>
<p class="calibre3">In our <kbd class="calibre13">PlayerController.cs</kbd> script, when the player fires, it sends a Command to the server using the <kbd class="calibre13">CmdFire()</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Client RPC calls</h1>
                
            
            <article>
                
<p class="calibre3">Client RPC calls are a way for server objects to cause things to happen on client objects. This is the reverse direction to how commands send messages, but the concepts are the same. Client RPC calls, however, are not only invoked on player objects; they can also be invoked on any <kbd class="calibre13">NetworkIdentity</kbd> object. They must begin with the prefix "Rpc" and have the <kbd class="calibre13">[ClientRPC]</kbd> custom attribute.</p>
<p class="calibre3">You will see an example of this on the <kbd class="calibre13">Health.cs</kbd> script, which we will be creating next.</p>
<p class="calibre3">We will also need a way to keep track of our player character's health. This will be done using a new script called <kbd class="calibre13">Health.cs</kbd>.</p>
<p class="calibre3">A listing of the script is as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/>using UnityEngine.Networking;<br class="title-page-name"/>public class Health : NetworkBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>public const int maxHealth = 100;<br class="title-page-name"/>[SyncVar(hook = "OnChangeHealth")]<br class="title-page-name"/>public int currentHealth = maxHealth;<br class="title-page-name"/>public RectTransform healthBar;<br class="title-page-name"/>public bool destroyOnDeath;<br class="title-page-name"/>public GameObject[] listOfPlayers;<br class="title-page-name"/>private void Start()<br class="title-page-name"/>{<br class="title-page-name"/>healthBar.sizeDelta = new Vector2(currentHealth, healthBar.sizeDelta.y);<br class="title-page-name"/>}<br class="title-page-name"/>public void TakeDamage(int amount)<br class="title-page-name"/>{<br class="title-page-name"/>currentHealth -= amount;<br class="title-page-name"/>if (currentHealth &lt;= 0)<br class="title-page-name"/>{<br class="title-page-name"/>if (destroyOnDeath)<br class="title-page-name"/>{<br class="title-page-name"/>RpcDied();<br class="title-page-name"/>listOfPlayers = GameObject.FindGameObjectsWithTag("Player");<br class="title-page-name"/>if (listOfPlayers.Length &lt; 1)<br class="title-page-name"/>{<br class="title-page-name"/>Invoke("BackToLobby", 3.0f);<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>else<br class="title-page-name"/>{<br class="title-page-name"/>currentHealth = maxHealth;</pre>
<pre class="calibre18"><br class="title-page-name"/>// called on the Server, will be invoked on the Clients<br class="title-page-name"/>RpcRespawn();<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>void OnChangeHealth(int health)<br class="title-page-name"/>{<br class="title-page-name"/>healthBar.sizeDelta = new Vector2(health, healthBar.sizeDelta.y);<br class="title-page-name"/>}<br class="title-page-name"/>[ClientRpc]<br class="title-page-name"/>void RpcRespawn()<br class="title-page-name"/>{<br class="title-page-name"/>if (isLocalPlayer)<br class="title-page-name"/>{<br class="title-page-name"/>// move back to zero location<br class="title-page-name"/>transform.position = Vector3.zero;<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>[ClientRpc]<br class="title-page-name"/>void RpcDied()<br class="title-page-name"/>{<br class="title-page-name"/>gameObject.tag = "Untagged";<br class="title-page-name"/>GetComponent&lt;Renderer&gt;().material.color = Color.black;<br class="title-page-name"/>if (GetComponent&lt;MyPlayerController&gt;() != null)<br class="title-page-name"/>{<br class="title-page-name"/>GetComponent&lt;MyPlayerController&gt;().enabled = false;<br class="title-page-name"/>}<br class="title-page-name"/>if (GetComponent&lt;EnemyController&gt;() != null)<br class="title-page-name"/>{<br class="title-page-name"/>GetComponent&lt;EnemyController&gt;().enabled = false;<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>void BackToLobby()<br class="title-page-name"/>{<br class="title-page-name"/>FindObjectOfType&lt;NetworkLobbyManager&gt;().ServerReturnToLobby();<br class="title-page-name"/>}<br class="title-page-name"/>}</pre>
<p class="calibre3">Notice that, in this script, we are also inheriting from <kbd class="calibre13">NetworkBehaviour</kbd>. The two main items I want to bring to your attention are the <kbd class="calibre13">SyncVar</kbd>, the <kbd class="calibre13">ClientRpc</kbd>, and the <kbd class="calibre13">Start()</kbd> functions.</p>
<p class="calibre3">We want to synchronize the player's health across the network. To do this, we use the <kbd class="calibre13">SyncVarNetworkBehaviour</kbd>. <kbd class="calibre13">SyncVar</kbd> can be any basic type, not classes, lists, or other collections.</p>
<p class="calibre3">When the value of <em class="calibre14">SyncVar</em> is changed on the server, it will be sent to all of the ready clients in the game. When objects are spawned, they are created on the client with the latest state of all <em class="calibre14">SyncVars</em> from the server.</p>
<p class="calibre3">The <kbd class="calibre13">OnStartClient()</kbd> function makes sure that each object with the <kbd class="calibre13">Health.cs</kbd> script attached to it will have the most up-to-date value to display on the health bar UI.</p>
<p class="calibre3">I want to take a moment and make sure I give you a crucial pointer here. Assume we are running a networked game session, and we have the <kbd class="calibre13">Host</kbd>, <kbd class="calibre13">Player A</kbd>, and <kbd class="calibre13">Player B</kbd> connected and going about their business. During the gameplay, <kbd class="calibre13">Player A</kbd> and <kbd class="calibre13">Player B</kbd> have their health value changed. Now, we have a third player connect to the game, <kbd class="calibre13">Player C</kbd>. If <kbd class="calibre13">Start()</kbd> is not implemented, the client for <kbd class="calibre13">Player C</kbd> will have the correct data synchronized for all of the GameObjects with the <kbd class="calibre13">Health.cs</kbd> script; however, the data will not reflect correctly on the UI because we need to have a trigger for that to happen. This can be handled in the <kbd class="calibre13">Start()</kbd> function, as shown in the code.</p>
<p class="calibre3">The next function is the <kbd class="calibre13">RpcRespawn()</kbd> function. In the <kbd class="calibre13">TakeDamage()</kbd> function, we check the health of the current GameObject. If the health drops below zero, we check to see if the <kbd class="calibre13">destroyOnDeath</kbd> Boolean variable is set. If it is not set, we go ahead and reset the <kbd class="calibre13">currentHealth</kbd> value to <kbd class="calibre13">maxHealth</kbd> value, and we use the <kbd class="calibre13">RpcRespawn()</kbd> method to re-spawn the player at the origin. Remember this function is executed on all clients!</p>
<p class="calibre3">Within the function, we check to see if the caller is the local player by checking the <kbd class="calibre13">isLocalPlayer</kbd><em class="calibre14"> </em><span class="calibre6">variable</span>. Yes, creating a multiplayer game does get confusing! This will become more apparent as you start experimenting with it more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating the cannonball for the tank</h1>
                
            
            <article>
                
<p class="calibre3">Let's create a prefab that will represent our cannonballs! Very simply, create a sphere and make it the same size as the nozzle of your tank gun.</p>
<p class="calibre3">We will need to attached the following components to the Canon Ball GameObject: <kbd class="calibre13">NetworkIdentity</kbd>, <kbd class="calibre13">NetworkTransform</kbd>, <kbd class="calibre13">Rigidbody</kbd>, and <kbd class="calibre13">Bullet.cs</kbd> scripts.</p>
<p class="calibre3">Make sure that you set the <kbd class="calibre13">Use Gravity</kbd> property to <kbd class="calibre13">False</kbd> on the <kbd class="calibre13">Rigidbody</kbd> component. Also, make sure that both <span class="calibre6">Server Only</span> and <span class="calibre6">Local Player Authority</span> properties are <em class="calibre14">False</em> on the <kbd class="calibre13">NetworkIdentity</kbd> component. On the <kbd class="calibre13">NetworkTransform</kbd> component, change <kbd class="calibre13">Network Send Rate</kbd> to <kbd class="calibre13">0</kbd>. Once we generate the object on the server, the physics will take care of the motion on each client.</p>
<p class="calibre3">Create a new C# script called <kbd class="calibre13">Bullet.cs</kbd>.</p>
<p class="calibre3">The listing for the script is as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/>using UnityEngine.Networking;<br class="title-page-name"/>public class Bullet : NetworkBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>[SyncVar]<br class="title-page-name"/>public Color myColor;<br class="title-page-name"/>private void Start()<br class="title-page-name"/>{<br class="title-page-name"/>GetComponent&lt;MeshRenderer&gt;().material.color = myColor;<br class="title-page-name"/>}<br class="title-page-name"/>void OnCollisionEnter(Collision collision)<br class="title-page-name"/>{<br class="title-page-name"/>var hit = collision.gameObject;<br class="title-page-name"/>var health = hit.GetComponent&lt;Health&gt;();<br class="title-page-name"/>if (health != null)<br class="title-page-name"/>{<br class="title-page-name"/>health.TakeDamage(10);<br class="title-page-name"/>}<br class="title-page-name"/>Destroy(gameObject);<br class="title-page-name"/>}<br class="title-page-name"/>}</pre>
<p class="calibre3">All we are doing here is detecting a collision. If there is a collision, we get the <kbd class="calibre13">Health</kbd> component. If the <kbd class="calibre13">Health</kbd> component is not null, we call the <kbd class="calibre13">TakeDamage()</kbd> function and pass it a value.</p>
<p class="calibre3">If you recall from the <kbd class="calibre13">Health.cs</kbd> script, the <kbd class="calibre13">TakeDamage()</kbd> function reduces <kbd class="calibre13">currentHealth</kbd> of the player, which in return is a <kbd class="calibre13">SyncVar</kbd> that gets updated on all active clients.</p>
<p class="calibre3">One item we did not discuss is the idea of a <kbd class="calibre13">hook</kbd>. A <kbd class="calibre13">SyncVar</kbd> can have a <kbd class="calibre13">hook</kbd>. Think of a hook as an event handler. The hook attribute can be used to specify a function to be called when the <kbd class="calibre13">SyncVar</kbd> changes value on the client:</p>
<pre class="calibre18">[SyncVar(hook = "OnChangeHealth")]<br class="title-page-name"/>public int currentHealth = maxHealth;</pre>
<p class="calibre3">The <kbd class="calibre13">OnChangeHealth()</kbd> function is responsible for updating the UI canvas for displaying our health value:</p>
<pre class="calibre18">void OnChangeHealth(int health)<br class="title-page-name"/>{<br class="title-page-name"/>healthBar.sizeDelta = new Vector2(health, healthBar.sizeDelta.y);<br class="title-page-name"/>}</pre>
<p class="calibre3">Go ahead and also make a prefab of the cannonball and delete the instance from the scene.</p>
<p class="calibre3">Make sure you have assigned the proper prefab associations that are required on each script. For instance, the <kbd class="calibre13">Tank</kbd> GameObject's <kbd class="calibre13">PlayerController.cs</kbd> script needs a reference to the cannonball prefab, and also the canon spawn location. The <kbd class="calibre13">Health.cs</kbd> script needs a reference to the HealthBar foreground image and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating the tank prefab and configuring the network lobby manager</h1>
                
            
            <article>
                
<p class="calibre3">Now that we have created our <kbd class="calibre13">Tank</kbd> GameObject and attached all of the necessary components and scripts to it, we need to make a prefab of it. This is because we will let <kbd class="calibre13">NetworkLobbyManger</kbd> spawn our player character, and in order for it to be able to do so, it needs to refer to a prefab that is a representation of your player character.</p>
<p class="calibre3">The <kbd class="calibre13">NetworkLobbyManager</kbd> has a <kbd class="calibre13">Spawn Info</kbd> section that you can assign the <kbd class="calibre13">Player</kbd> Prefab, determine if the <kbd class="calibre13">NetworkLobbyManager</kbd> can Auto Create Player and the <kbd class="calibre13">Player Spawn</kbd> Method.</p>
<p class="calibre3">There is also a section for <kbd class="calibre13">Registered Spawnable</kbd> Prefabs. We need to register all of the GameObjects that will be spawned by the <kbd class="calibre13">NetworkServer</kbd>. For instance, the Canon Ball prefab will need to be registered here so that we can spawn it across the network on different clients.</p>
<p class="calibre3">Select the <kbd class="calibre13">Network Lobby Manager</kbd> GameObject in the scene, and in the <span class="calibre6">Inspector</span> window assign the appropriate prefabs as needed.</p>
<p class="calibre3">Here is a screenshot of how the <kbd class="calibre13">NetworkLobbyManager</kbd> should look at this point:</p>
<div class="mce-root1"><img src="../images/00175.jpeg" class="calibre45"/></div>
<div class="mce-root2">Lobby manager</div>
<p class="calibre3">At this point, you are ready to test out what we have built so far. Go ahead and create a stand-alone version of your game using the <span class="calibre6">Build Settings</span> window. Once you have your build ready, launch two instances of the application. We will use one instance to host the game, and the other to connect as a client, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00176.jpeg" class="calibre131"/></div>
<p class="calibre3">The following screenshot illustrates how your game instance will look when you run it:</p>
<div class="mce-root1"><img src="../images/00177.jpeg" class="calibre132"/></div>
<p class="calibre3">The following screenshots illustrate how your screen will look during runtime. The game is created on an Android tablet:</p>
<div class="mce-root1"><img src="../images/00178.jpeg" class="calibre45"/></div>
<p class="calibre3">The second player selects <span class="calibre6">LIST SERVERS</span> and gets available matches, and clicks <span class="calibre6">JOIN</span> to enter the room, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00179.jpeg" class="calibre133"/></div>
<p class="calibre3">Once everyone is ready, the game starts. Notice that each player has a unique tank color assign based on their color selection in the lobby.</p>
<p class="calibre3">In the preceding screenshot, note that each client has highlighted the player character it controls, that is, the tank it controls. It will be difficult to capture the fire command, but you can go ahead and use the Space Bar to fire the canon, and it will be triggered accordingly on all active clients.</p>
<p class="calibre3">You will also notice that the health of each tank will be reflected accurately if they do get a hit. Now we are ready to create an enemy to illustrate the non-player character in the game.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding the enemy tank</h1>
                
            
            <article>
                
<p class="calibre3">Now it is time to add some of the non-player characters to our multiplayer demo. Adding the Enemy Tank will be simple as we will use our Tank prefab as a base. Go ahead and drop the Tank prefab into the scene, and change the name to <kbd class="calibre13">TankEnemy</kbd>.</p>
<p class="calibre3">Remove the <kbd class="calibre13">MyPlayerCharacter.cs</kbd> script from the GameObject. We will create a separate script as the controller for the enemy tank. I have also gone ahead and applied different material to the enemy tank so that we can visually distinguish which tanks will be controlled by players and which ones will be non-player. Take a look at the following screenshot:</p>
<div class="mce-root1"><img src="../images/00180.jpeg" class="calibre45"/></div>
<div class="mce-root2">Enemy tank setup</div>
<p class="calibre3">The preceding screenshot illustrates how your <kbd class="calibre13">Tank</kbd> and <kbd class="calibre13">TankEnemy</kbd> prefabs should look. The main difference between the two is the controller script. Tank has the <kbd class="calibre13">MylayerController.cs</kbd> script, and <kbd class="calibre13">TankEnemy</kbd> has the <kbd class="calibre13">EnemyController.cs</kbd> script.</p>
<p class="calibre3">A listing of the <kbd class="calibre13">EnemyController.cs</kbd> script is as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/>using UnityEngine.Networking;<br class="title-page-name"/>public class EnemyController : NetworkBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>public GameObject bulletPrefab;<br class="title-page-name"/>public Transform bulletSpawn;<br class="title-page-name"/>public float distance = 1000;<br class="title-page-name"/>public GameObject[] listOfPlayers;<br class="title-page-name"/>[SyncVar(hook = "OnChangePlayerToAttack")<br class="title-page-name"/>public GameObject playerToAttack;<br class="title-page-name"/>float coolOffTime = 0.0f;<br class="title-page-name"/>void Update()<br class="title-page-name"/>{<br class="title-page-name"/>// only execute the following code if local player ...<br class="title-page-name"/>if (!isServer)<br class="title-page-name"/>return;<br class="title-page-name"/>listOfPlayers = GameObject.FindGameObjectsWithTag("Player");<br class="title-page-name"/>if (listOfPlayers.Length &gt; 0)<br class="title-page-name"/>{<br class="title-page-name"/>float distance = 100f;<br class="title-page-name"/>foreach (var player in listOfPlayers)<br class="title-page-name"/>{<br class="title-page-name"/>float d = Vector3.Distance(transform.position, player.transform.position);<br class="title-page-name"/>if (d &lt; distance)<br class="title-page-name"/>{<br class="title-page-name"/>distance = d;<br class="title-page-name"/>playerToAttack = player;<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>if (playerToAttack != null)<br class="title-page-name"/>{<br class="title-page-name"/>Vector3 direction = playerToAttack.transform.position - transform.position;<br class="title-page-name"/>transform.rotation =<br class="title-page-name"/>Quaternion.Slerp(transform.rotation,<br class="title-page-name"/>Quaternion.LookRotation(direction), 0.1f);<br class="title-page-name"/>float d = Vector3.Distance(transform.position, playerToAttack.transform.position);<br class="title-page-name"/>if (d &lt; 15.0f)<br class="title-page-name"/>{<br class="title-page-name"/>if(coolOffTime&lt;Time.time)<br class="title-page-name"/>{<br class="title-page-name"/>CmdFire();<br class="title-page-name"/>coolOffTime = Time.time + 1.0f;<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>void OnChangePlayerToAttack(GameObject player)<br class="title-page-name"/>{<br class="title-page-name"/>playerToAttack = player;<br class="title-page-name"/>}<br class="title-page-name"/>[Command]<br class="title-page-name"/>void CmdFire()<br class="title-page-name"/>{<br class="title-page-name"/>// Create the Bullet from the Bullet Prefab<br class="title-page-name"/>var bullet = Instantiate(<br class="title-page-name"/>bulletPrefab,<br class="title-page-name"/>bulletSpawn.position,<br class="title-page-name"/>bulletSpawn.rotation) as GameObject;<br class="title-page-name"/>// Add velocity to the bullet<br class="title-page-name"/>bullet.GetComponent&lt;Rigidbody&gt;().velocity = bullet.transform.forward * 6;<br class="title-page-name"/>// Spawn the bullet on the Clients<br class="title-page-name"/>NetworkServer.Spawn(bullet);<br class="title-page-name"/>// Destroy the bullet after 2 seconds<br class="title-page-name"/>Destroy(bullet, 2.0f);<br class="title-page-name"/>}<br class="title-page-name"/>}</pre>
<p class="calibre3">The script continuously searches for all players that are active in the scene and makes a list of them. Then it finds the closest one to itself. Once it determines which player is closest, it rotates to face the player.</p>
<p class="calibre3">After that, it calculates the distance between itself and the selected player; if the distance is shorter than the acceptable threshold, then it starts firing at the player. Each time the enemy tank fires, it actually calls a <kbd class="calibre13">[Command]</kbd> named <kbd class="calibre13">CmdFire()</kbd>.</p>
<p class="calibre3">This function is run on the server; it instantiates a cannonball prefab and spawns it on the network.</p>
<p class="calibre3">The <kbd class="calibre13">EnemyController.cs</kbd> script also has a <kbd class="calibre13">SyncVar</kbd> for the <kbd class="calibre13">playertoAttack</kbd> variable, with a <kbd class="calibre13">hook</kbd> attached as an <kbd class="calibre13">OnChangePlayerToAttack()</kbd> function. This, in turn, makes sure that all clients get updated with the latest data on each Enemy <kbd class="calibre13">Tank</kbd> GameObject.</p>
<p class="calibre3">The <kbd class="calibre13">Health.cs</kbd> script works the same as it does on the <kbd class="calibre13">Tank</kbd> GameObject.</p>
<p class="calibre3">There is one more item we need to cover: the spawning of the <kbd class="calibre13">Enemy Tanks</kbd> by the server. We can do this easily by creating another empty GameObject and naming it <kbd class="calibre13">Enemy Spawner</kbd>. We need to attach a <kbd class="calibre13">NetworkIdentity</kbd> component and make sure we set the <kbd class="calibre13">Server Only</kbd> property to <kbd class="calibre13">True</kbd>. This will make sure that only the server can instantiate the enemy objects.</p>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3"/>
<p class="calibre3">The next step is to create the <kbd class="calibre13">EnemySpawner.cs</kbd> scripts. The listing is as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/>using UnityEngine.Networking;<br class="title-page-name"/>public class EnemySpawner : NetworkBehaviour {<br class="title-page-name"/>public GameObject enemyPrefab;<br class="title-page-name"/>public int numberOfEnemies;<br class="title-page-name"/>public override void OnStartServer()<br class="title-page-name"/>{<br class="title-page-name"/>for (int i = 0; i &lt; numberOfEnemies; i++)<br class="title-page-name"/>{<br class="title-page-name"/>var spawnPosition = new Vector3(<br class="title-page-name"/>Random.Range(-20.0f, 20.0f),<br class="title-page-name"/>0.0f,<br class="title-page-name"/>Random.Range(-20.0f, 20.0f));<br class="title-page-name"/>var spawnRotation = Quaternion.Euler(<br class="title-page-name"/>0.0f,<br class="title-page-name"/>Random.Range(0, 180),<br class="title-page-name"/>0.0f);<br class="title-page-name"/>var enemy = (GameObject)Instantiate(enemyPrefab, spawnPosition, spawnRotation);<br class="title-page-name"/>NetworkServer.Spawn(enemy);<br class="title-page-name"/>}<br class="title-page-name"/>}<br class="title-page-name"/>}</pre>
<p class="calibre3">This code technically takes the prefab provided as the enemy tank and randomly spawns each enemy tank within a range over the network.</p>
<p class="calibre3">Make sure all of your prefabs have been assigned in the <span class="calibre6">Inspector</span> window for both the <kbd class="calibre13">Enemy Spawner</kbd> GameObject and the <kbd class="calibre13">TankEnemy</kbd> GameObject. Create a prefab of your <kbd class="calibre13">TankEnemy</kbd> if you have not done so already, and delete it from the scene. Do not delete the <kbd class="calibre13">Enemy Spawner</kbd>.</p>
<p class="calibre3">We need to register the <kbd class="calibre13">TankEnemy</kbd> prefab with the <kbd class="calibre13">NetworkLobbyManager</kbd>. Go ahead and select the <kbd class="calibre13">Network Manager</kbd> GameObject, and from the <span class="calibre6">Inspector</span><em class="calibre14"> </em>window, add a new Prefab to the <kbd class="calibre13">Registered Spawnable</kbd> Prefabs option.</p>
<p class="calibre3">Your <kbd class="calibre13">Network Manager</kbd> should now look as follows:</p>
<div class="mce-root1"><img src="../images/00181.jpeg" class="calibre45"/></div>
<div class="mce-root2">Lobby Network Manager Setup</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building and testing</h1>
                
            
            <article>
                
<p class="calibre3">We are ready to do our final test. Go ahead and build the stand-alone version of the project, and launch a new instance of the game. <span class="calibre6">Player 1</span> will create the room, and the rest of the players will join the game, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00182.jpeg" class="calibre134"/></div>
<div class="mce-root2">Joining a game demo</div>
<p class="calibre3">You will also notice that right after initialization, all of the enemy tanks will rotate toward the player character tank and if within range, they will start firing at it.</p>
<p class="calibre3">The following screenshot illustrates the runtime of the game:</p>
<div class="mce-root1"><img src="../images/00183.jpeg" class="calibre135"/></div>
<p class="calibre3">Notice that while I was trying to capture the screen, the enemy tanks were merciless and fired at <span class="calibre6">Player 4</span> continuously. You can see that my health bar has reduced drastically. You can also see that one of the enemy tanks has also received some damage.</p>
<p class="calibre3">I assure you that I had nothing to do with the damage taken by the enemy tank; it was actually caused by friendly fire. Yes, at the moment, the enemy tanks are not smart enough to hold fire if another team member is in the line of fire!</p>
<p class="calibre3">I will let you handle the implementation of that on your own. Shouldn't be too complex.</p>
<div class="packt_infobox">Use Raycasting to make sure there is no object between the enemy tank and the player prior to firing.</div>
<p class="calibre3">Congratulations! You have just created your first multiplayer game! As mentioned previously, creating, maintaining, and hosting a multiplayer game is no small task, and covering every single aspect on how to do it is simply impossible in a few pages.</p>
<p class="calibre3">The idea here is to give you the foundation and the fundamentals that you can take and expand upon. I would encourage you to take some time to study what we have just covered and do some more reading on the material, even though not much exists. The truth is that you will need to do a lot of experimentation and trial and error on your own.</p>
<p class="calibre3">Now that we know the basics, let's go ahead and apply what we have learned to our RPG assets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Network-enabling RPG characters</h1>
                
            
            <article>
                
<p class="calibre3">In order to make life easier, I have decided to create a new scene that will be used to test and implement our network-enabled characters. This example will show you how to network-enable the player character, and also how to synchronize the player character data such as inventory items across the network, as well as provide you with the ability to network-enable the non-player character and make it synchronize its data across the clients.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a scene for our RPG</h1>
                
            
            <article>
                
<p class="calibre3">Just like the tank demo in the previous section, we will use two new scenes to illustrate the RPG networking concept here. We will create two scenes, one called <kbd class="calibre13">NetworkingMenu</kbd> and the other <kbd class="calibre13">DeathMatchMultiplayer</kbd>.</p>
<p class="calibre3">The <kbd class="calibre13">NetworkingMenu</kbd> scene is our lobby scene, so it will be exactly the same as the Tank Multiplayer lobby scene, with the exception that the player character will be replaced by the Barbarian prefab, and the <kbd class="calibre13">Registered Spawnable</kbd> Prefabs will be different. We shall see this later.</p>
<p class="calibre3">In the <kbd class="calibre13">DeathMatchMultiplayer</kbd> scene, I have the following level design:</p>
<div class="mce-root1"><img src="../images/00184.jpeg" class="calibre45"/></div>
<div class="mce-root2">Level design spawn enemy</div>
<p class="calibre3">Your lobby scene should look something like the following:</p>
<div class="mce-root1"><img src="../images/00185.jpeg" class="calibre45"/></div>
<p class="calibre3">The next step is to make sure our GameObjects are network-enabled.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Networked player character</h1>
                
            
            <article>
                
<p class="calibre3">Go ahead and drag the player prefab you have created into the scene. We will use it as a base to create a new prefab, which will be used for the networked version of the game.</p>
<p class="calibre3">Go ahead and remove the existing <kbd class="calibre13">BarbarianCharacterController.cs</kbd> and <kbd class="calibre13">BarbarianCharacterCustomization.cs</kbd> components from the instance. We will create new scripts that are network-enabled and use them. Rename the <kbd class="calibre13">PC</kbd> GameObject instance to <kbd class="calibre13">PC-C6-Network</kbd>. Now make a prefab of the instance. You should now have a new prefab named <kbd class="calibre13">PC-C6-Network</kbd>.</p>
<p class="calibre3">Go ahead and attach the following components to the prefab: <kbd class="calibre13">NetworkIdentiy</kbd>, <kbd class="calibre13">NetworkTransform</kbd>, and <kbd class="calibre13">NetworkAnimator</kbd>, by using the <kbd class="calibre13">Inspector</kbd> Window and selecting <span class="calibre6">Add Components</span> <em class="calibre14">|</em> <span class="calibre6">Network</span> <em class="calibre14">|</em> <span class="calibre6">&lt;component name&gt;</span>.</p>
<p class="calibre3">On the <kbd class="calibre13">NetworkIdentity</kbd> component, set <kbd class="calibre13">Local Player Authority</kbd> to <kbd class="calibre13">True</kbd>. On the <kbd class="calibre13">NetworkTransform</kbd> component, change <span class="calibre6">Transform Sync Mode</span> to <span class="calibre6">Sync Rigidbody 3D</span>. On the <kbd class="calibre13">NetworkAnimator</kbd> component, you will need to drag the <kbd class="calibre13">Animator</kbd> components attached to the GameObject into the <kbd class="calibre13">Animator</kbd> slot.</p>
<div class="packt_infobox">You will need to select the <kbd class="calibre85">Animator</kbd> component and drag it right down into the <kbd class="calibre85">Animator</kbd> slot on the <kbd class="calibre85">NetworkAnimator</kbd> components.</div>
<p class="calibre3">Next, we need to create a new character controller so that it is network compatible.</p>
<p class="calibre3">Create a new C# script and call it <kbd class="calibre13">BarbarianCharacterNetworkController.cs</kbd>. Attach the script to the <kbd class="calibre13">PC-C6-Network</kbd> prefab. The new character controller is a stripped-down version of the original character controller.</p>
<p class="calibre3">The listing for it is as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/>using UnityEngine.Networking;<br class="title-page-name"/>namespace com.noorcon.rpg2e<br class="title-page-name"/>{<br class="title-page-name"/>public class BarbarianCharacterNetworkController : NetworkBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>public Transform mainCamera;<br class="title-page-name"/>public float cameraDistance = 16f;<br class="title-page-name"/>public float cameraHeight = 16f;<br class="title-page-name"/>public Vector3 cameraOffset;<br class="title-page-name"/>public Animator animator;<br class="title-page-name"/>public float directionDampTime;<br class="title-page-name"/>public float speed = 6.0f;<br class="title-page-name"/>public float h = 0.0f;<br class="title-page-name"/>public float v = 0.0f;<br class="title-page-name"/>bool attack = false;<br class="title-page-name"/>bool punch = false;<br class="title-page-name"/>bool run = false;<br class="title-page-name"/>bool jump = false;<br class="title-page-name"/>[HideInInspector]<br class="title-page-name"/>public bool die = false;<br class="title-page-name"/>bool dead = false;<br class="title-page-name"/>[SyncVar]<br class="title-page-name"/>public bool EnemyInSight;<br class="title-page-name"/>public GameObject EnemyToAttack;<br class="title-page-name"/>Quaternion StartingAttackAngle = Quaternion.AngleAxis(-25, Vector3.up);<br class="title-page-name"/>Quaternion StepAttackAngle = Quaternion.AngleAxis(5, Vector3.up);<br class="title-page-name"/>Vector3 AttackDistance = new Vector3(0, 0, 2);<br class="title-page-name"/>// Use this for initialization<br class="title-page-name"/>void Start()<br class="title-page-name"/>{<br class="title-page-name"/>cameraOffset = new Vector3(0f, cameraHeight, -cameraDistance);<br class="title-page-name"/>mainCamera = Camera.main.transform;<br class="title-page-name"/>MoveCamera();<br class="title-page-name"/>animator = GetComponent&lt;Animator&gt;() as Animator;<br class="title-page-name"/>EnemyInSight = false;<br class="title-page-name"/>}<br class="title-page-name"/>// Update is called once per frame<br class="title-page-name"/>private Vector3 moveDirection = Vector3.zero;<br class="title-page-name"/>void Update()<br class="title-page-name"/>{<br class="title-page-name"/>if (!isLocalPlayer)<br class="title-page-name"/>return;<br class="title-page-name"/>if (dead)<br class="title-page-name"/>{<br class="title-page-name"/>animator.SetBool("Die", false);<br class="title-page-name"/>return;<br class="title-page-name"/>}<br class="title-page-name"/>if (Input.GetKeyDown(KeyCode.C))<br class="title-page-name"/>{<br class="title-page-name"/>attack = true;<br class="title-page-name"/>this.GetComponent&lt;IKHandle&gt;().enabled = false;<br class="title-page-name"/>}<br class="title-page-name"/>if (Input.GetKeyUp(KeyCode.C))<br class="title-page-name"/>{<br class="title-page-name"/>attack = false;<br class="title-page-name"/>this.GetComponent&lt;IKHandle&gt;().enabled = true;<br class="title-page-name"/>}<br class="title-page-name"/>animator.SetBool("Attack", attack);<br class="title-page-name"/>if (Input.GetKeyDown(KeyCode.P))<br class="title-page-name"/>{<br class="title-page-name"/>punch = true;<br class="title-page-name"/>this.GetComponent&lt;IKHandle&gt;().enabled = false;<br class="title-page-name"/>}<br class="title-page-name"/>if (Input.GetKeyUp(KeyCode.P))<br class="title-page-name"/>{<br class="title-page-name"/>punch = false;<br class="title-page-name"/>this.GetComponent&lt;IKHandle&gt;().enabled = true;<br class="title-page-name"/>}<br class="title-page-name"/>animator.SetBool("Punch", punch);<br class="title-page-name"/>if (Input.GetKeyDown(KeyCode.LeftShift))<br class="title-page-name"/>{<br class="title-page-name"/>this.run = true;<br class="title-page-name"/>this.GetComponent&lt;IKHandle&gt;().enabled = false;<br class="title-page-name"/>}<br class="title-page-name"/>if (Input.GetKeyUp(KeyCode.LeftShift))<br class="title-page-name"/>{<br class="title-page-name"/>this.run = false;<br class="title-page-name"/>this.GetComponent&lt;IKHandle&gt;().enabled = true;<br class="title-page-name"/>}<br class="title-page-name"/>animator.SetBool("Run", run);<br class="title-page-name"/>if (Input.GetKeyDown(KeyCode.Space))<br class="title-page-name"/>{<br class="title-page-name"/>jump = true;<br class="title-page-name"/>this.GetComponent&lt;IKHandle&gt;().enabled = false;<br class="title-page-name"/>}<br class="title-page-name"/>if (Input.GetKeyUp(KeyCode.Space))<br class="title-page-name"/>{<br class="title-page-name"/><a href="https://github.com/PacktPublishing/Building-an-RPG-with-Unity-2018-Second-Edition" class="calibre83">...</a></pre>
<p class="calibre3">The first thing you should notice is that we are inheriting from <kbd class="calibre13">NetworkBehaviour</kbd> instead of <kbd class="calibre13">MonoBehaviour</kbd>. This is necessary if we want to enable certain network behaviors on the GameObject. Take a look at the following screenshot:</p>
<div class="mce-root1"><img src="../images/00186.jpeg" class="calibre45"/></div>
<div class="mce-root2">Level setup for RPG network</div>
<p class="calibre3">Next, let's look at some of the variables that need to be synchronized across the network for each player character that is connected. These variables are <kbd class="calibre13">enemyToAttack</kbd> and <kbd class="calibre13">Health</kbd>. There are two more variables, <kbd class="calibre13">Shield</kbd> and <kbd class="calibre13">Helmet</kbd>, which we will discuss later.</p>
<p class="calibre3">In the <kbd class="calibre13">Update()</kbd> function, we need a way to check and make sure that it is the local player before giving the controller the chance to execute the player. This is done by having the following code check to see if the current client is the local player:</p>
<pre class="calibre18">if (!isLocalPlayer)<br class="title-page-name"/>return;</pre>
<p class="calibre3">This will make sure that the code runs only for the current client (player). The rest of the code in the <kbd class="calibre13">Update()</kbd> function checks to see if the enemy is in sight, and makes sure the player character is facing the enemy to attack.</p>
<p class="calibre3">If the player is in attack mode and the enemy is in our view, we set <kbd class="calibre13">enemyInSight</kbd> to <kbd class="calibre13">True</kbd> and <kbd class="calibre13">enemyToAttack</kbd> to the enemy GameObject, which is stored in the <kbd class="calibre13">hitAttack</kbd> variable of type <kbd class="calibre13">RacastHit</kbd>. The important element here is the <kbd class="calibre13">CmdEnemyToAttack()</kbd> function. The client needs to send a command to the server telling the server who the target of attack is:</p>
<pre class="calibre18">[Command]<br class="title-page-name"/>void CmdEnemyToAttack(GameObject go)<br class="title-page-name"/>{<br class="title-page-name"/>this.enemyInSight = true;<br class="title-page-name"/>this.enemyToAttack = go;<br class="title-page-name"/>}</pre>
<p class="calibre3">This will make sure that the data is registered correctly on the server and that it is synchronized to other clients. We also have another function, called <kbd class="calibre13">CmdEnemyTakeDamage()</kbd>, which is used to reduce the health of the enemy character on the server. The server then calls the <kbd class="calibre13">RpcEnemyTakeDamage()</kbd> function to synchronize<span class="calibre6"> the health value of the enemy</span> across all clients:</p>
<pre class="calibre18">[Command]<br class="title-page-name"/>void CmdEnemyTakeDamage(float value)<br class="title-page-name"/>{<br class="title-page-name"/>RpcEnemyTakeDamage(value);<br class="title-page-name"/>}<br class="title-page-name"/>[ClientRpc]<br class="title-page-name"/>void RpcEnemyTakeDamage(float value)<br class="title-page-name"/>{<br class="title-page-name"/>if(this.enemyToAttack != null)<br class="title-page-name"/>this.enemyToAttack.GetComponent&lt;NPC_Movement_Network&gt;().Damage(value);<br class="title-page-name"/>}</pre>
<p class="calibre3">This idea is a bit confusing at first, but it will be clearer as you start to study it more carefully.</p>
<p class="calibre3">We also have the following function to send commands to the server when the player dies:</p>
<pre class="calibre18">[Command]<br class="title-page-name"/>void CmdPlayerCharacterIsDead()<br class="title-page-name"/>{<br class="title-page-name"/>RpcPlayerCharacterIsDead();<br class="title-page-name"/>}<br class="title-page-name"/>[ClientRpc]<br class="title-page-name"/>void RpcPlayerCharacterIsDead()<br class="title-page-name"/>{<br class="title-page-name"/>this.die = true;<br class="title-page-name"/>Destroy(this.gameObject, 2.0f);<br class="title-page-name"/>}</pre>
<p class="calibre3">The preceding functions make sure that the player character is dead and destroyed on all connected clients at the moment of the game.</p>
<p class="calibre3">And finally, the following hook functions are used by the <kbd class="calibre13">SyncVar</kbd> on the Health and <kbd class="calibre13">enemyToAttack</kbd> variables:</p>
<pre class="calibre18">// Var Sync hook function ...<br class="title-page-name"/>void OnChangePlayerHealth(float health)<br class="title-page-name"/>{<br class="title-page-name"/>this.Health = health;<br class="title-page-name"/>}<br class="title-page-name"/>// Var Sync hook function<br class="title-page-name"/>void OnChangeEnemyToAttack(GameObject enemy)<br class="title-page-name"/>{<br class="title-page-name"/>this.enemyToAttack = enemy;<br class="title-page-name"/>}</pre>
<p class="calibre3">This idea is also a bit confusing at first, but it will be clearer as you start to study it more carefully.</p>
<p class="calibre3">If you have not done so already, apply and save all of your changes to your <kbd class="calibre13">PC-CC-Network</kbd> prefab.</p>
<p class="calibre3">At this stage, your character is ready to be integrated with <kbd class="calibre13">NetworkManager</kbd><em class="calibre14">;</em> you can drag and drop the prefab into the <kbd class="calibre13">Player</kbd> Prefab slot, and build a stand-alone version to test out your character movement and synchronization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Networked non-player character</h1>
                
            
            <article>
                
<p class="calibre3">Just like the player character network-enabled prefab, we will use the non-player character prefab as our base to get started. Go ahead and create an instance of your NPC in the scene.</p>
<p class="calibre3">Go ahead and remove the existing <kbd class="calibre13">NPC_Movement.cs</kbd> component from the prefab. Rename the Prefab to <kbd class="calibre13">B1-Network</kbd> and attach the following components to it: <kbd class="calibre13">NetworkIdentity</kbd>, <kbd class="calibre13">NetworkTransform</kbd>, and <kbd class="calibre13">NetworkAnimator</kbd>, by selecting <kbd class="calibre13">Add Component</kbd> <em class="calibre14">|</em> <span class="calibre6">Network</span> <em class="calibre14">|</em> <span class="calibre6">&lt;component name&gt;</span> from the <span class="calibre6">Inspector</span> window.</p>
<p class="calibre3">On the <kbd class="calibre13">NetworkIdentity</kbd> component, set <kbd class="calibre13">Local Player Authority</kbd> to <kbd class="calibre13">True</kbd><em class="calibre14">;</em> in the <kbd class="calibre13">NetworkTransform</kbd> component, set <kbd class="calibre13">Transform Sync Mode</kbd> to <kbd class="calibre13">Sync Transform</kbd>; and for the <kbd class="calibre13">NetworkAnimator</kbd> component, set the <kbd class="calibre13">Animator</kbd> slot to the <kbd class="calibre13">Animator</kbd> controller attached to the prefab, by dragging it and dropping into the slot, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00187.jpeg" class="calibre45"/></div>
<p class="calibre3">We now need to create a new script for our NPC movement that is network-enabled. Go ahead and create a new C# script, and name it <kbd class="calibre13">NPC_Movement_Network.cs</kbd>. A listing of the scripts is as follows:</p>
<pre class="calibre18">using UnityEngine; 
using UnityEngine.Networking; 
 
using System.Collections; 
 
public class NPC_Movement_Network : NetworkBehaviour { 
  // reference to the animator 
  public Animator animator; 
 
  public bool jump = false;     // used for jumping 
 
  [SyncVar(hook ="OnNPCIsDead")] 
  public bool die = false;      // are we alive? 
 
<a href="https://github.com/PacktPublishing/Building-an-RPG-with-Unity-2018-Second-Edition" class="calibre83">...</a>
 
  // what is the field of view for our NPC? 
  // currently set to 110 degrees 
  [SyncVar] 
  public float fieldOfViewAngle = 110.0f; 
 
  // calculate the angle between PC and NPC 
  [SyncVar] 
  public float calculatedAngle; 
 
  [SyncVar(hook = "OnChangePlayerToAttackInNPC")] 
  public GameObject playerToAttack; 
 
  [SyncVar(hook = "OnChangeNPCHealth")] 
  public float Health = 100.0f; 
 
  void Awake() 
  { 
    // get reference to the animator component 
    this.animator = GetComponent&lt;Animator&gt;() as Animator; 
 
    // get reference to nav mesh agent  
    this.nav = GetComponent&lt;NavMeshAgent&gt;() as NavMeshAgent; 
 
    // get reference to the sphere collider 
    this.col = GetComponent&lt;SphereCollider&gt;() as SphereCollider; 
 
    // we don't see the player by default 
    this.playerInSight = false; 
  } 
 
  void Update() 
  { 
    // only execute the following code if local player ... 
    if (!isServer) 
      return; 
 
    this.CmdUpdateNetwork(); 
  } 
 
  [Command] 
  void CmdUpdateNetwork() 
  { 
    this.RpcUpdateNetwork(); 
  } 
 
 
  [ClientRpc] 
  void RpcUpdateNetwork() 
  { 
    // if player is in sight let's slerp towards the player 
    if(this.playerToAttack!=null) 
    { 
      if (playerInSight) 
      { 
        this.transform.rotation = 
            Quaternion.Slerp(this.transform.rotation, 
            Quaternion.LookRotation(direction), 0.1f); 
 
        if (this.playerToAttack.transform.GetComponent&lt;CharacterController_Network&gt;().die) 
        { 
          animator.SetBool("Attack", false); 
          animator.SetFloat("Speed", 0.0f); 
          animator.SetFloat("AngularSpeed", 0.0f); 
          this.playerInSight = false; 
          this.playerToAttack = null; 
        } 
      } 
    } 
 
    if(this.Health&lt;=0.0f) 
    { 
      this.die = true; 
      this.Health = 0.0f; 
 
      animator.SetBool("Attack", false); 
      animator.SetFloat("Speed", 0.0f); 
      animator.SetFloat("AngularSpeed", 0.0f); 
      this.playerInSight = false; 
      this.playerToAttack = null; 
    }</pre>
<pre class="calibre18">    animator.SetBool("Die", die); 
  } 
<a href="https://github.com/PacktPublishing/Building-an-RPG-with-Unity-2018-Second-Edition" class="calibre83">...</a></pre>
<p class="calibre3"><span class="calibre6">There are a few variables that have been indicated as </span><kbd class="calibre13">SyncVars</kbd><em class="calibre14">;</em><span class="calibre6"> these are: </span><kbd class="calibre13">die</kbd>, <kbd class="calibre13">distance</kbd>, <kbd class="calibre13">direction</kbd>, <kbd class="calibre13">angle</kbd>, <kbd class="calibre13">playerInSight</kbd>, <kbd class="calibre13">fieldOfViewAngle</kbd>, <kbd class="calibre13">calculatedAngle</kbd>, <kbd class="calibre13">playerToAttack</kbd>, and <kbd class="calibre13">Health</kbd><span class="calibre6">.</span></p>
<p class="calibre3">Take a look at the following code:</p>
<pre class="calibre18">  void OnTriggerExit(Collider other) 
  { 
    if (other.transform.tag.Equals("Player")) 
    { 
      distance = 0.0f; 
      angle = 0.0f; 
      this.attack1 = false; 
      this.playerInSight = false; 
 
      this.playerToAttack = null; 
    } 
  } 
 
  // this is a helper function at this point 
  // in the future we will use it to calculate distance around the corners 
  // it currently is also used to draw the path of the nav mesh agent in the  
  // editor 
  float CalculatePathLength(Vector3 targetPosition) 
  { 
    // Create a path and set it based on a target position. 
    NavMeshPath path = new NavMeshPath(); 
    if (nav.enabled) 
      nav.CalculatePath(targetPosition, path); 
 
    // Create an array of points which is the length of the number of corners in the path + 2. 
    Vector3[] allWayPoints = new Vector3[path.corners.Length + 2]; 
 
    // The first point is the enemy's position. 
    allWayPoints[0] = transform.position; 
 
    // The last point is the target position. 
    allWayPoints[allWayPoints.Length - 1] = targetPosition; 
 
    // The points inbetween are the corners of the path. 
    for (int i = 0; i &lt; path.corners.Length; i++) 
    { 
      allWayPoints[i + 1] = path.corners[i]; 
    } 
 
    // Create a float to store the path length that is by default 0. 
    float pathLength = 0; 
 
    // Increment the path length by an amount equal to the distance between each waypoint and the next. 
    for (int i = 0; i &lt; allWayPoints.Length - 1; i++) 
    { 
      pathLength += Vector3.Distance(allWayPoints[i], allWayPoints[i + 1]); 
 
      if (DEBUG_DRAW) 
        Debug.DrawLine(allWayPoints[i], allWayPoints[i + 1], Color.red); 
    } 
 
    return pathLength; 
  } 
} </pre>
<p class="calibre3">Some of the <kbd class="calibre13">SyncVars</kbd> have a <kbd class="calibre13">hook</kbd><em class="calibre14">;</em> these are <kbd class="calibre13">Health</kbd>, <kbd class="calibre13">playerToAttack</kbd>, <kbd class="calibre13">playerInSight</kbd>, and <kbd class="calibre13">die</kbd>.</p>
<p class="calibre3">In the <kbd class="calibre13">Update()</kbd> function, we check to make sure we are the server by the following line:</p>
<pre class="calibre18">// only execute the following code if server ...<br class="title-page-name"/>if (!isServer)<br class="title-page-name"/>return;</pre>
<p class="calibre3">If we are the server, we use the <kbd class="calibre13">CmdUpdateNetwork()</kbd> and <kbd class="calibre13">RpcUpdateNetwork()</kbd> functions to perform our duties. These are just for the movement and action for the NPC. The key here is the <kbd class="calibre13">SyncVars</kbd> and <kbd class="calibre13">hook</kbd> functions that are used to synchronize the NPC data to all clients:</p>
<pre class="calibre18">public void OnChangePlayerPlayerInSight(bool value)<br class="title-page-name"/>{<br class="title-page-name"/>this.playerInSight = value;<br class="title-page-name"/>}<br class="title-page-name"/>// Var Sync hook function ...<br class="title-page-name"/>void OnChangeNPCHealth(float health)<br class="title-page-name"/>{<br class="title-page-name"/>this.Health = health;<br class="title-page-name"/>}<br class="title-page-name"/>void OnNPCIsDead(bool value)<br class="title-page-name"/>{<br class="title-page-name"/>die = true;<br class="title-page-name"/>}<br class="title-page-name"/>void OnChangePlayerToAttackInNPC(GameObject player)<br class="title-page-name"/>{<br class="title-page-name"/>this.playerToAttack = player;<br class="title-page-name"/>}</pre>
<p class="calibre3">That is all we need for the NPC. Go ahead and add the script to the prefab and apply the changes. Save it.</p>
<p class="calibre3">Your new NPC prefab should have the following components attached:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Synchronizing player customization and items</h1>
                
            
            <article>
                
<p class="calibre3">In order for this to work, we need to perform configure and create several more new inventory item prefabs. I will use two inventory items to demonstrate this particular point.</p>
<p class="calibre3">I will use one of the <kbd class="calibre13">Helmet</kbd> prefabs from my inventory items. Duplicate it, and remove the <kbd class="calibre13">InventoryItemAgent.cs</kbd> component. We will create a new script that is network-enabled, as we did for our PC and NPC.</p>
<p class="calibre3">Attach the following components to the instance: <kbd class="calibre13">NetworkIdentity</kbd> and <kbd class="calibre13">NetworkTransform</kbd>, using <span class="calibre6">Add Component</span> | <span class="calibre6">Network</span> | <span class="calibre6">&lt;component name&gt;</span> from the <span class="calibre6">Inspector</span> window<em class="calibre14">:</em></p>
<div class="mce-root1"><img src="../images/00188.jpeg" class="calibre136"/></div>
<p class="calibre3">Create a new script named <kbd class="calibre13">InventoryItemAgent_Network.cs</kbd>. The listing is as follows:</p>
<pre class="calibre18">using UnityEngine; 
using UnityEngine.Networking; 
using System.Collections; 
 
public class InventoryItemAgent_Network : NetworkBehaviour { 
 
  public InventoryItem ItemDescription; 
 
  public void OnTriggerEnter(Collider c) 
  { 
    // make sure we are colliding with the player 
    if (c.gameObject.tag.Equals("Player")) 
    { 
      // Make a copy of the Inventory Item Object 
      InventoryItem myItem = new InventoryItem(); 
      myItem.CopyInventoryItem(this.ItemDescription); 
 
      c.gameObject.GetComponent&lt;CharacterController_Network&gt;().PlayerArmourChanged(myItem); 
    } 
  } 
} </pre>
<p class="calibre3">All this script does is assign the inventory item to the player character using the <kbd class="calibre13">PlayerArmourChanged()</kbd> function in the <kbd class="calibre13">CharacterController_Network.cs</kbd> script.</p>
<p class="calibre3">The <kbd class="calibre13">PlayerArmourChanged()</kbd> function uses another script we need to create that is network enabled, and that is the <kbd class="calibre13">CharacterCustomization_Network.cs</kbd> script. I will not list the script here as it is very long. You can look at the script in the code supplied with the book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Spawning NPCs and other items</h1>
                
            
            <article>
                
<p class="calibre3">We need a way to spawn our NPC as well as the inventory items we will be using for the next demonstration.</p>
<p class="calibre3">In the <span class="calibre6">Hierarchy</span> window, right-click and select <span class="calibre6">Create Empty</span><em class="calibre14">;</em> this will create an <kbd class="calibre13">Empty</kbd> GameObject. Rename it <kbd class="calibre13">SpawnEnemy</kbd>, and add a <kbd class="calibre13">NetworkIdentity</kbd> component to it by selecting <span class="calibre6">Add Component</span> | <span class="calibre6">Network</span> | <span class="calibre6">NetworkIdentity</span> from the <span class="calibre6">Inspector</span> window.</p>
<p class="calibre3">We will create a new script called <kbd class="calibre13">EnemySpawn_Network.cs</kbd>. The listing is as follows:</p>
<pre class="calibre18">using UnityEngine; 
using UnityEngine.Networking; // used for chapter 8 
 
using System.Collections; 
 
public class EnemySpawn_Network : NetworkBehaviour 
{ 
  public GameObject enemyPrefab; 
  public Transform spawnLocation; 
 
  public GameObject inventoryItemPrefab; 
  public GameObject inventoryItemShield; 
 
  public override void OnStartServer() 
  { 
    GameObject go = GameObject.Instantiate(enemyPrefab, spawnLocation.position, Quaternion.identity) as GameObject; 
    NetworkServer.Spawn(go); 
 
 
    GameObject goInventoryItem1 = GameObject.Instantiate(inventoryItemPrefab, new Vector3(2, 1, 2), Quaternion.identity) as GameObject; 
    NetworkServer.Spawn(goInventoryItem1); 
 
    GameObject goInventoryItem2 = GameObject.Instantiate(inventoryItemShield, new Vector3(3, 1, 2), Quaternion.identity) as GameObject; 
    NetworkServer.Spawn(goInventoryItem2); 
 
  } 
} </pre>
<p class="calibre3">The script is very simple, as you can see. We are just referencing the GameObjects that represent the prefabs for the NPC and inventory items prefab.</p>
<p class="calibre3">Attach the new script to the <kbd class="calibre13">SpawnEnemy</kbd> prefab in the <span class="calibre6">Hierarchy</span> Window.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing our network-enabled PC and NPC</h1>
                
            
            <article>
                
<p class="calibre3">At this point, we have all of the assets needed to test out our network-enabled RPG characters. There is one final step that we need to perform if you have not done so already.</p>
<p class="calibre3">Select the <kbd class="calibre13">NetworkManager</kbd> GameObject in the <span class="calibre6">Hierarchy</span> window, and from the <span class="calibre6">Inspector</span> window, you will need to make sure certain things have been assigned in the <em class="calibre14">Spawn</em> <span class="calibre6">Info</span> section.</p>
<p class="calibre3"><em class="calibre14">Player Prefab</em> should be assigned to your player character prefab. Mine is named <kbd class="calibre13">PC-CC-Network-1</kbd>. Make sure <span class="calibre6">Auto Create Player</span> is set to <kbd class="calibre13">True</kbd>.</p>
<p class="calibre3">You will also register your NPC prefabs and other network-enabled non-character prefabs in the <span class="calibre6">Registered Spawnable</span> Prefabs. I have the barbarian prefab named <kbd class="calibre13">B1-Network-1</kbd> assigned, <kbd class="calibre13">barbarian_helmet_01_LOD0_Network</kbd>, and <kbd class="calibre13">shield_01_LOD0_Networ</kbd><em class="calibre14">k</em>.</p>
<p class="calibre3">Take a look at the following screenshot:</p>
<div class="mce-root1"><img src="../images/00189.jpeg" class="calibre45"/></div>
<p class="calibre3">Alright, at last, we can do a build. Let's go ahead and make a stand-alone build of our game. Make sure that the current scene is in the build configuration:</p>
<div class="mce-root1"><img src="../images/00190.jpeg" class="calibre137"/></div>
<p class="calibre3">Go ahead and launch two instances of the build. Make one of them the host, and the other the client.</p>
<p class="calibre3">Take a look at the following screenshot:</p>
<p class="cdpaligncenter"><img src="../images/00191.jpeg" class="calibre138"/></p>
<p class="calibre3">In the preceding screenshot, we have started a client as a server and the player character has picked up one of the inventory items, a shield. When we connect the second client, it should correctly take into consideration the current state of all PCs and NPCs active in the game:</p>
<div class="mce-root1"><img src="../images/00192.jpeg" class="calibre139"/></div>
<p class="calibre3">Keeping both of the instances running, use the Unity IDE to connect the third client. You can use the client to perform debugging on the client end, and also to see what is going on.</p>
<p class="calibre3">Take a look at the following screenshot:</p>
<div class="mce-root1"><img src="../images/00193.jpeg" class="calibre45"/></div>
<p class="calibre3">In the preceding screenshot, you can see all of the player characters and how they have been accurately synchronized with one another. Select B1-Network-1 GameObject from the Hierarchy Window, and use one of the client instances to take the player character and attack the NPC.</p>
<p class="calibre3">We will pause the editor and inspect the variables and how they have been properly synchronized, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="../images/00194.jpeg" class="calibre140"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What's next?</h1>
                
            
            <article>
                
<p class="calibre3">As you have witnessed, network programming is simple, but at the same time, it can be difficult. The difficulty lies in managing and understanding the synchronization of the data between all players in an efficient and meaningful way.</p>
<p class="calibre3">It can actually get a bit more involved if you are truly considering creating a game with a large number of clients. Unity networking will not be able to handle that; you will need to create your own backend server managers and messaging systems.</p>
<p class="calibre3">What we have covered in this chapter will give you a good understanding to take it to the next level. Keep on coding until we meet again!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">In this chapter, we looked at network programming using the Unity networking components. The main objective of the chapter was to introduce you to the fundamentals of networking in Unity by implementing two samples.</p>
<p class="calibre3">We started the chapter by discussing some of the challenges you will face as a game designer and developer for a multiplayer game. One of the main questions raised is whether you really need to invest the time and energy to create a multiplayer mode for your game. Assuming you really do want or need to create a multiplayer game, we started by looking at the different types of multiplayer games popular today.</p>
<p class="calibre3">We then went on with our first example of a simplified multiplayer game. The multiplayer game we developed are real-time, that is, all clients are synchronized with one another based on the activity on each active player's state; namely, the position, rotation, movement, and other important data needs to be synchronized with all clients connected to the game session.</p>
<p class="calibre3">We looked at the fundamentals of Unity's networking components, such as the Network Manager, Network Manager HUD, Network Identity, and Network Transform. These are the base components that are used to illustrate multiplayer programming in Unity. Once we understood what these components are used for, we started with a simple sample.</p>
<p class="calibre3">We created a simple tank game that demonstrated how to put together all of the essential components for a multiplayer game. We created the necessary player character prefab with the appropriate network-enabled scripts and components. We also created the non-player character prefab with its own network-enabled scripts. The game demonstrates how to spawn, and how to synchronize between the player characters and non-player characters.</p>
<p class="calibre3">During the construction of the tank game, we covered how to synchronize variables and use network callbacks that are crucial for the development of a multiplayer game. We also covered what <em class="calibre14">Commands</em> and <em class="calibre14">ClientRPC</em> calls are and how to use them properly.</p>
<p class="calibre3">Next, we applied what we learned to the RPG characters we developed in previous chapters. We used the existing prefabs as a base, and extended them to include the networking components and create new network-enabled scripts to handle the character movement, character customization, and NPC movement scripts.</p>
<p class="calibre3">One of the crucial elements that we covered is the synchronization of each player character's inventory items visually with the rest of the players. We closed the chapter by testing and discussing how to debug your code on the client and the server while developing your multiplayer game.</p>


            </article>

            
        </section>
    </body></html>