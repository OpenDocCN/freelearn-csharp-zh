<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Using Asynchronous I/O"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Using Asynchronous I/O</h1></div></div></div><p>In this chapter, we will review asynchronous I/O operations in detail. You will learn the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with files asynchronously</li><li class="listitem" style="list-style-type: disc">Writing an asynchronous HTTP server and client</li><li class="listitem" style="list-style-type: disc">Working with a database asynchronously</li><li class="listitem" style="list-style-type: disc">Calling a WCF service asynchronously</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec78"/>Introduction</h1></div></div></div><p>In the previous chapters, we already discussed how important it is to use asynchronous I/O operations properly. Why does it matter so much? To have a solid understanding, let's consider two kinds of applications.</p><p>When we run an <a id="id372" class="indexterm"/>application on a client, one of the most important things is to have a responsive user interface. This means that no matter what is happening with the application, all user interface elements, such as buttons and progress bars, keep running fast, and the user gets an immediate reaction from the application. This is not easy to achieve! If you try to open the Notepad text editor in Windows and try to load a text document that is several megabytes in size, the application window will be frozen for a significant amount of time because the whole text is being loaded from the disk first, and only then does the program start to process user input.</p><p>This is an extremely important issue, and in this situation, the only solution is to avoid blocking the UI thread at all costs. This in turn means that to prevent the blocking of the UI thread, every UI-related API must allow only asynchronous calls. This is the key reason behind redesigning APIs in the Windows 8 operating system by replacing almost every method with asynchronous analogs. But does it affect the performance if our application uses multiple threads to achieve this goal? Of course, it does! However, we could pay the price considering that we have only one user. It is good to have the application using all the power of the computer to be more effective, as all this power is intended for the single user who runs the application.</p><p>Let's look at the second case, then. If we run the application on a server, we have a completely different situation. We have scalability as a top priority, which means that a single user should consume as little resource as possible. If we start to create many threads for each user, we simply cannot scale well. It is a very complex problem to balance our application resource consumption in an efficient way. For example, in ASP.NET, which is a web application platform from Microsoft, we use a pool of worker threads to serve client requests. This pool has a limited number of worker threads, and we have to minimize the<a id="id373" class="indexterm"/> use time for each worker thread to achieve scalability. This means that we have to return it to the pool as soon as possible so that it can serve another request. If we start an asynchronous operation that requires computation, we will have a very inefficient workflow. First, we take a worker thread from the thread pool to serve a client request. Then, we take another worker thread and start an asynchronous operation on it. Now, we have two worker threads serving our request, but we really need the first thread to be doing something useful! Unfortunately, the common situation is that we simply wait for the asynchronous operation to complete, and we consume two worker threads instead of one. In this scenario, asynchrony is actually worse than synchronous execution! We do not need to load all the CPU cores as we are already serving many clients and thus are using all the CPU computing power. We do not need to keep the first thread responsive as we have no user interface. Then, why should we use asynchrony in server applications?</p><p>The answer is that we should use asynchrony when there is an asynchronous I/O operation. Today, modern computers usually have a hard disk drive that stores files and a network card that sends and receives data over the network. Both of these devices have their own microcomputers that manage I/O operations on a very low level and signal the operating system about the results. This is again quite a complicated topic; but to keep the concept clear, we could say that there is a way for programmers to start an I/O operation and provide the operating system with code to callback when the operation is completed. Between starting an I/O task and its completion, there is no CPU work involved; it is done in the corresponding disk and network controller microcomputers. This way of executing an I/O task is called an I/O thread; they are implemented using the .NET thread pool and in turn use an infrastructure from the operating system called I/O completion ports.</p><p>In ASP.NET, as soon as an asynchronous I/O operation is started from a worker thread, it can be returned immediately to the thread pool! While the operation is going on, this thread can serve other clients. Finally, when the operation signals completion, the ASP.NET infrastructure gets a free worker thread from the thread pool (which could be different from the one that started the operation), and it finishes the operation.</p><p>All right; we now understand how important I/O threads are for server applications. Unfortunately, it is very hard to check whether any given API uses I/O threads under the hood. The only way<a id="id374" class="indexterm"/> (besides studying the source code) is simply to know which .NET Framework class library leverages I/O threads. In this chapter, we <a id="id375" class="indexterm"/>will see how to use some of those APIs. You will learn how to work with files asynchronously, how to use network I/O to create an HTTP server and call the <span class="strong"><strong>Windows Communication Foundation</strong></span> (<span class="strong"><strong>WCF</strong></span>) service, and how to work with an asynchronous API to query a database.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Another important issue to consider is parallelism. For a number of reasons, an intensive parallel disk operation might have very poor performance. Be aware that parallel I/O operations are often very ineffective, and it might be reasonable to work with I/O sequentially, but in an asynchronous manner.</p></div></div></div></div>
<div class="section" title="Working with files asynchronously"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec79"/>Working with files asynchronously</h1></div></div></div><p>This recipe walks us<a id="id376" class="indexterm"/> through how to create a file and how to read and write data asynchronously.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec197"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter9\Recipe1</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec198"/>How to do it...</h2></div></div></div><p>To understand how to work with files asynchronously, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static System.Console;
using static System.Text.Encoding;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">const int BUFFER_SIZE = 4096;

static async Task ProcessAsynchronousIO()
{
  using (var stream = new FileStream(
    "test1.txt", FileMode.Create, FileAccess.ReadWrite, FileShare.None, BUFFER_SIZE))
  {
    WriteLine($"1. Uses I/O Threads: {stream.IsAsync}");

    byte[] buffer = UTF8.GetBytes(CreateFileContent());
    var writeTask = Task.Factory.FromAsync(
      stream.BeginWrite, stream.EndWrite, buffer, 0, buffer.Length, null);

    await writeTask;
  }

  using (var stream = new FileStream("test2.txt", FileMode.Create, FileAccess.ReadWrite,FileShare.None, BUFFER_SIZE, FileOptions.Asynchronous))
  {
    WriteLine($"2. Uses I/O Threads: {stream.IsAsync}");

    byte[] buffer = UTF8.GetBytes(CreateFileContent());
    var writeTask = Task.Factory.FromAsync(
      stream.BeginWrite, stream.EndWrite, buffer, 0, buffer.Length, null);

    await writeTask;
  }

  using (var stream = File.Create("test3.txt", BUFFER_SIZE, FileOptions.Asynchronous))
  using (var sw = new StreamWriter(stream))
  {
    WriteLine($"3. Uses I/O Threads: {stream.IsAsync}");
    await sw.WriteAsync(CreateFileContent());
  }

  using (var sw = new StreamWriter("test4.txt", true))
  {
    WriteLine($"4. Uses I/O Threads: {((FileStream)sw.BaseStream).IsAsync}");
    await sw.WriteAsync(CreateFileContent());
  }

  WriteLine("Starting parsing files in parallel");

  var readTasks = new Task&lt;long&gt;[4];
  for (int i = 0; i &lt; 4; i++)
  {
    string fileName = $"test{i + 1}.txt";
    readTasks[i] = SumFileContent(fileName);
  }

  long[] sums = await Task.WhenAll(readTasks);

  WriteLine($"Sum in all files: {sums.Sum()}");

  WriteLine("Deleting files...");

  Task[] deleteTasks = new Task[4];
  for (int i = 0; i &lt; 4; i++)
  {
    string fileName = $"test{i + 1}.txt";
    deleteTasks[i] = SimulateAsynchronousDelete(fileName);
  }

  await Task.WhenAll(deleteTasks);

  WriteLine("Deleting complete.");
}

static string CreateFileContent()
{
  var sb = new StringBuilder();
  for (int i = 0; i &lt; 100000; i++)
  {
    sb.Append($"{new Random(i).Next(0, 99999)}");
    sb.AppendLine();
  }
  return sb.ToString();
}

static async Task&lt;long&gt; SumFileContent(string fileName)
{
  using (var stream = new FileStream(fileName, FileMode.Open, FileAccess.Read,FileShare.None, BUFFER_SIZE, FileOptions.Asynchronous))
  using (var sr = new StreamReader(stream))
  {
    long sum = 0;
    while (sr.Peek() &gt; -1)
    {
      string line = await sr.ReadLineAsync();
      sum += long.Parse(line);
    }

    return sum;
  }
}

static Task SimulateAsynchronousDelete(string fileName)
{
  return Task.Run(() =&gt; File.Delete(fileName));
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var t = ProcessAsynchronousIO();
t.GetAwaiter().GetResult();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec199"/>How it works...</h2></div></div></div><p>When the program runs, we create four files in different ways and fill them up with random data. In the<a id="id377" class="indexterm"/> first case, we use the <code class="literal">FileStream</code> class and its methods, converting an Asynchronous Programming Model API to a task; in the second case, we do the same, but we provide <code class="literal">FileOptions.Asynchronous</code> to the <code class="literal">FileStream</code> constructor.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>It is very important to use the <code class="literal">FileOptions.Asynchronous</code> option. If we omit this option, we can still work with the file in an asynchronous manner, but this is just an asynchronous delegate invocation on a thread pool! We use the I/O asynchrony with the <code class="literal">FileStream</code> class only if we provide this option (or bool <code class="literal">useAsync</code> in another constructor overload).</p></div></div><p>The third case uses some simplifying APIs, such as the <code class="literal">File.Create</code> method and the <code class="literal">StreamWriter</code> class. It still uses I/O threads, which we are able to check using the <code class="literal">stream.IsAsync</code> property. The last case illustrates that oversimplifying is also bad. Here, we do not leverage the I/O asynchrony by imitating it with the help of asynchronous delegate invocation.</p><p>Now, we perform parallel asynchronous reading from files, sum up their content, and then sum it with each other. Finally, we<a id="id378" class="indexterm"/> delete all the files. As there is no asynchronous delete file in any non-Windows store application, we simulate the asynchrony using the <code class="literal">Task.Run</code> factory method.</p></div></div>
<div class="section" title="Writing an asynchronous HTTP server and client"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec80"/>Writing an asynchronous HTTP server and client</h1></div></div></div><p>This recipe <a id="id379" class="indexterm"/>shows you how to create a simple asynchronous HTTP server.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec200"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter9\Recipe2</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec201"/>How to do it...</h2></div></div></div><p>The following steps demonstrate how to create a simple asynchronous HTTP server:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">Add a reference to the <code class="literal">System.Net.Http</code> framework library.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.IO;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using static System.Console;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static async Task GetResponseAsync(string url)
{
  using (var client = new HttpClient())
  {
    HttpResponseMessage responseMessage = await client.GetAsync(url);
    string responseHeaders = responseMessage.Headers.ToString();
    string response = await responseMessage.Content.ReadAsStringAsync();

    WriteLine("Response headers:");
    WriteLine(responseHeaders);
    WriteLine("Response body:");
    WriteLine(response);
  }
}

class AsyncHttpServer
{
  readonly HttpListener _listener;
  const string RESPONSE_TEMPLATE = 
        "&lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Testpage&lt;/h2&gt;" +
"&lt;h4&gt;Today is: {0}&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;";

  public AsyncHttpServer(int portNumber)
  {
    _listener = new HttpListener();
    _listener.Prefixes.Add($"http://localhost:{portNumber}/");
  }

  public async Task Start()
  {
    _listener.Start();

    while (true)
    {
      var ctx = await _listener.GetContextAsync();
      WriteLine("Client connected...");
      var response = string.Format(RESPONSE_TEMPLATE, DateTime.Now);

      using (var sw = new StreamWriter(ctx.Response.OutputStream))
      {
        await sw.WriteAsync(response);
        await sw.FlushAsync();
      }
    }
  }

  public async Task Stop()
  {
    _listener.Abort();
  }
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">var server = new AsyncHttpServer(1234);
var t = Task.Run(() =&gt; server.Start());
WriteLine("Listening on port 1234. Open http://localhost:1234 in your browser.");
WriteLine("Trying to connect:");
WriteLine();

GetResponseAsync("http://localhost:1234").GetAwaiter().GetResult();

WriteLine();
WriteLine("Press Enter to stop the server.");
ReadLine();

server.Stop().GetAwaiter().GetResult();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec202"/>How it works...</h2></div></div></div><p>Here, we implement a <a id="id380" class="indexterm"/>very simple web server using the <code class="literal">HttpListener</code> class. There is also a <code class="literal">TcpListener</code> class for the TCP socket I/O operations. We configure our listener to accept connections from any host to the local machine on port <code class="literal">1234</code>. Then, we start the listener in a separate worker thread so that we can control it from the main thread.</p><p>The asynchronous I/O operation happens when we use the <code class="literal">GetContextAsync</code> method. Unfortunately, it does not accept <code class="literal">CancellationToken</code> for cancelation scenarios; so, when we want to stop the server, we just call the <code class="literal">_listener.Abort</code> method, which abandons the connection and stops the server.</p><p>To perform an asynchronous request on this server, we use the <code class="literal">HttpClient</code> class located in the <code class="literal">System.Net.Http</code> assembly and the same namespace. We use the <code class="literal">GetAsync</code> method to issue an asynchronous HTTP <code class="literal">GET</code> request. There are methods for other HTTP requests such as <code class="literal">POST</code>, <code class="literal">DELETE</code>, and <code class="literal">PUT</code> as well. <code class="literal">HttpClient</code> has many other options such as serializing and deserializing an object using different formats, such as XML and JSON, specifying a proxy server address, credentials, and so on.</p><p>When you run the program, you can see that the server has been started up. In the server code, we use the <code class="literal">GetContextAsync</code> method to accept new client connections. This method returns when a new client connects, and we simply output a very basic HTML language with the current date and time to the response. Then, we request the server and print the response headers and content. You can also open your browser and browse to <code class="literal">http://localhost:1234/</code>. Here, you will see the same response displayed in the browser window.</p></div></div>
<div class="section" title="Working with a database asynchronously"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec81"/>Working with a database asynchronously</h1></div></div></div><p>This recipe walks<a id="id381" class="indexterm"/> us through the process of creating a database, populating it with data, and reading data asynchronously.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec203"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. No other prerequisites are required. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter9\Recipe3</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec204"/>How to do it...</h2></div></div></div><p>To understand the process of creating a database, populating it with data, and reading data asynchronously, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Reflection;
using System.Threading.Tasks;
using static System.Console;</pre></div></li><li class="listitem">Add the following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">static async Task ProcessAsynchronousIO(string dbName)
{
  try
  {
    const string connectionString =
            @"Data Source=(LocalDB)\MSSQLLocalDB;Initial Catalog=master;" +
            "Integrated Security=True";

    string outputFolder = Path.GetDirectoryName(
            Assembly.GetExecutingAssembly().Location);

    string dbFileName = Path.Combine(outputFolder, $"{dbName}.mdf");
    string dbLogFileName = Path.Combine(outputFolder, $"{dbName}_log.ldf");

    string dbConnectionString = 
      @"Data Source=(LocalDB)\MSSQLLocalDB;" +
      $"AttachDBFileName={dbFileName};Integrated Security=True;";

    using (var connection = new SqlConnection(connectionString))
    {
      await connection.OpenAsync();

      if (File.Exists(dbFileName))
      {
        WriteLine("Detaching the database...");

        var detachCommand = new SqlCommand("sp_detach_db", connection);
        detachCommand.CommandType = CommandType.StoredProcedure;
        detachCommand.Parameters.AddWithValue("@dbname", dbName);

        await detachCommand.ExecuteNonQueryAsync();

        WriteLine("The database was detached succesfully.");
        WriteLine("Deleting the database...");

        if(File.Exists(dbLogFileName)) File.Delete(dbLogFileName);
        File.Delete(dbFileName);

        WriteLine("The database was deleted succesfully.");
      }

      WriteLine("Creating the database...");
      string createCommand = 
                $"CREATE DATABASE {dbName} ON (NAME = N'{dbName}', FILENAME = " +
                $"'{dbFileName}')";
      var cmd = new SqlCommand(createCommand, connection);

      await cmd.ExecuteNonQueryAsync();
      WriteLine("The database was created succesfully");
    }

    using (var connection = new SqlConnection(dbConnectionString))
    {
      await connection.OpenAsync();

      var cmd = new SqlCommand("SELECT newid()", connection);
      var result = await cmd.ExecuteScalarAsync();

      WriteLine($"New GUID from DataBase: {result}");

      cmd = new SqlCommand(
@"CREATE TABLE [dbo].[CustomTable]( [ID] [int] IDENTITY(1,1) NOT NULL, " + 
"[Name] [nvarchar](50) NOT NULL, CONSTRAINT [PK_ID] PRIMARY KEY CLUSTERED " + 
" ([ID] ASC) ON [PRIMARY]) ON [PRIMARY]", connection);

            await cmd.ExecuteNonQueryAsync();

      WriteLine("Table was created succesfully.");

      cmd = new SqlCommand(
@"INSERT INTO [dbo].[CustomTable] (Name) VALUES ('John');
INSERT INTO [dbo].[CustomTable] (Name) VALUES ('Peter');
INSERT INTO [dbo].[CustomTable] (Name) VALUES ('James');
INSERT INTO [dbo].[CustomTable] (Name) VALUES ('Eugene');", connection);
      await cmd.ExecuteNonQueryAsync();

      WriteLine("Inserted data succesfully");
      WriteLine("Reading data from table...");

      cmd = new SqlCommand(@"SELECT * FROM [dbo].[CustomTable]", connection);
      using (SqlDataReader reader = await cmd.ExecuteReaderAsync())
      {
        while (await reader.ReadAsync())
        {
          var id = reader.GetFieldValue&lt;int&gt;(0);
          var name = reader.GetFieldValue&lt;string&gt;(1);

          WriteLine("Table row: Id {0}, Name {1}", id, name);
        }
      }
    }
  }
  catch(Exception ex)
  {
    WriteLine("Error: {0}", ex.Message);
  }
}</pre></div></li><li class="listitem">Add the following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">const string dataBaseName = "CustomDatabase";
var t = ProcessAsynchronousIO(dataBaseName);
t.GetAwaiter().GetResult();
Console.WriteLine("Press Enter to exit");
Console.ReadLine();</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec205"/>How it works...</h2></div></div></div><p>This program works <a id="id382" class="indexterm"/>with software called SQL Server 2014 LocalDb. It is installed with Visual Studio 2015 and should work fine. However, in case of errors, you might want to repair this component from the installation wizard.</p><p>We start with configuring paths to our database files. We place database files in the program-execution folder. There will be two files: one for the database itself and another for the transaction log file. We also configure two connection strings that define how we connect to our databases. The first one is to connect to the LocalDb engine to detach our database; if it already exists, delete and then recreate it. We leverage the I/O asynchrony while opening the connection and while executing the SQL commands using the <code class="literal">OpenAsync</code> and <code class="literal">ExecuteNonQueryAsync</code> methods, respectively.</p><p>After this task is completed, we attach a newly created database. Here, we create a new table and insert some data in it. In addition to the previously mentioned methods, we use <code class="literal">ExecuteScalarAsync</code> to asynchronously get a scalar value from the database engine, and we use the <code class="literal">SqlDataReader.ReadAsync</code> method to read a data row from the database table asynchronously.</p><p>If we had a large table with large binary values in its rows in our database, then we would use the <code class="literal">CommandBehavior.SequentialAcess</code> enumeration to create the data reader and the <code class="literal">GetFieldValueAsync</code> method to get large field values from the reader asynchronously.</p></div></div>
<div class="section" title="Calling a WCF service asynchronously"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Calling a WCF service asynchronously</h1></div></div></div><p>This recipe will describe how to create a WCF service, how to host it in a console application, how to <a id="id383" class="indexterm"/>make service metadata available to clients, and how to consume it in an asynchronous way.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec206"/>Getting ready</h2></div></div></div><p>To step through this recipe, you will need Visual Studio 2015. There are no other prerequisites. The source code for this recipe can be found at <code class="literal">BookSamples\Chapter9\Recipe4</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec207"/>How to do it...</h2></div></div></div><p>To understand how to work with a WCF service, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start Visual Studio 2015. Create a new C# console application project.</li><li class="listitem">Add references to the <code class="literal">System.ServiceModel</code> library. Right-click on the <code class="literal">References</code> folder in the project and select the <span class="strong"><strong>Add reference…</strong></span> menu option. Add references to the <code class="literal">System.ServiceModel</code> library. You can use the search function in the reference manager dialog, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/B05292_09_01.jpg" alt="How to do it..."/></div></li><li class="listitem">In the <code class="literal">Program.cs</code> file, add the following <code class="literal">using</code> directives:<div class="informalexample"><pre class="programlisting">using System;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.Threading.Tasks;
using static System.Console;</pre></div></li><li class="listitem">Add the <a id="id384" class="indexterm"/>following code snippet below the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">const string SERVICE_URL = "http://localhost:1234/HelloWorld";

static async Task RunServiceClient()
{
  var endpoint = new EndpointAddress(SERVICE_URL);
  var channel = ChannelFactory&lt;IHelloWorldServiceClient&gt;
        .CreateChannel(new BasicHttpBinding(), endpoint);

  var greeting = await channel.GreetAsync("Eugene");
  WriteLine(greeting);
}

[ServiceContract(Namespace = "Packt", Name = "HelloWorldServiceContract")]
public interface IHelloWorldService
{
  [OperationContract]
  string Greet(string name);
}

[ServiceContract(Namespace = "Packt", Name = "HelloWorldServiceContract")]
public interface IHelloWorldServiceClient
{
  [OperationContract]
  string Greet(string name);

  [OperationContract]
  Task&lt;string&gt; GreetAsync(string name);
}

public class HelloWorldService : IHelloWorldService
{
  public string Greet(string name)
  {
    return $"Greetings, {name}!";
  }
}</pre></div></li><li class="listitem">Add the<a id="id385" class="indexterm"/> following code snippet inside the <code class="literal">Main</code> method:<div class="informalexample"><pre class="programlisting">ServiceHost host = null;

try
{
  host = new ServiceHost(typeof (HelloWorldService), new Uri(SERVICE_URL));
  var metadata = host.Description.Behaviors.Find&lt;ServiceMetadataBehavior&gt;() 
        ?? new ServiceMetadataBehavior();

  metadata.HttpGetEnabled = true;
  metadata.MetadataExporter.PolicyVersion = PolicyVersion.Policy15;
  host.Description.Behaviors.Add(metadata);

  host.AddServiceEndpoint(ServiceMetadataBehavior.MexContractName, 
        MetadataExchangeBindings.CreateMexHttpBinding(), "mex");

  var endpoint = host.AddServiceEndpoint(typeof (IHelloWorldService),new BasicHttpBinding(), SERVICE_URL);

  host.Faulted += (sender, e) =&gt; WriteLine("Error!");

  host.Open();

  WriteLine("Greeting service is running and listening on:");
  WriteLine($"{endpoint.Address} ({endpoint.Binding.Name})");

  var client = RunServiceClient();
  client.GetAwaiter().GetResult();

  WriteLine("Press Enter to exit");
  ReadLine();
}
catch (Exception ex)
{
  WriteLine($"Error in catch block: {ex}");
}
finally
{
  if (null != host)
  {
    if (host.State == CommunicationState.Faulted)
    {
      host.Abort();
    }
    else
    {
      host.Close();
    }
  }
}</pre></div></li><li class="listitem">Run the program.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec208"/>How it works...</h2></div></div></div><p>WCF is a framework that allows us to call remote services in different ways. One of them, which was very popular some time ago, was used to call remote<a id="id386" class="indexterm"/> services via HTTP using an XML-based protocol called the <span class="strong"><strong>Simple Object Access Protocol</strong></span> (<span class="strong"><strong>SOAP)</strong></span>. It is quite common when a server application calls another remote service, and this could be done using I/O threads as well.</p><p>Visual Studio 2015 has<a id="id387" class="indexterm"/> rich support for WCF services; for example, you can add references to such services with the <span class="strong"><strong>Add Service Reference</strong></span> menu option. You could do this with our service as well because we provide service metadata.</p><p>To create such a service, we need to use a <code class="literal">ServiceHost</code> class that will host our service. We describe what service we will be hosting by providing a service implementation type and the base URI by which the service will be addressed. Then, we configure the metadata endpoint and the service endpoint. Finally, we handle the <code class="literal">Faulted</code> event in case of errors and run the host service.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Be aware that we need to have administrator privileges to run the service, since it uses HTTP bindings, which in turn use <code class="literal">http.sys</code> and thus require special permissions to be created. You can run Visual Studio under an administrator or run the following command in the elevated command prompt to add the necessary permissions:</p><div class="informalexample"><pre class="programlisting">netsh http add urlacl url=http://+:1234/HelloWorld user=machine\user</pre></div></div></div><p>To consume this service, we create a client, and here is where the main trick happens. On the server side, we have a service with the usual synchronous method called <code class="literal">Greet</code>. This method is defined in the service contract, <code class="literal">IHelloWorldService</code>. However, if we want to leverage an asynchronous network I/O, we have to call this method asynchronously. We can do that by creating a new service contract with a matching namespace and service name, where we define both the synchronous and task-based asynchronous methods. In spite of the fact that we do not have an asynchronous method definition on the server side, we follow the naming convention, and the WCF infrastructure understands that we want to create an <a id="id388" class="indexterm"/>asynchronous proxy method.</p><p>Therefore, when we create an <code class="literal">IHelloWorldServiceClient</code> proxy channel, and WCF correctly routes an asynchronous call to the server-side synchronous method, if you leave the application running, you can open the browser and access the service using its URL, that is, <code class="literal">http://localhost:1234/HelloWorld</code>. A service description will be opened, and you can browse to the XML metadata that allows us to add a service reference from Visual Studio 2012. If you try to generate the reference, you will see slightly more complicated code, but it is autogenerated and easy to use.</p></div></div></body></html>