- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to .NET Aspire and Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to creating a solution consisting of Microservices. The first chapter
    provides the foundations for the microservices solution that will be developed
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will learn which features .NET Aspire offers for microservices. In
    this book, we create the **Codebreaker** solution. You will learn what Codebreaker
    is and the parts it consists of. In the last section of this chapter, you’ll learn
    which Azure services are used while we create the application on the tour up to
    the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The first chapter lays the foundation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the advantages that are offered by .NET
    Aspire on creating microservices and you will gain the foundational knowledge
    needed to work with this technology, including how to define the app model, what
    it means for development and deployment, how service discovery is used, and how
    Azure resources are deployed while debugging the solution locally.
  prefs: []
  type: TYPE_NORMAL
- en: You will get an overview of the application we built in this book, the parts
    of the solution, and how the different services are connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating .NET Aspire projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parts of the Codebreaker solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Microsoft Azure with .NET Aspire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure services used by the Codebreaker solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you need .NET 8 with the .NET Aspire workload, either Visual
    Studio or Visual Studio Code, Docker Desktop, and a Microsoft Azure subscription.
    Information about the installation is explained in this chapter and the readme
    file of the source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in this GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ch01` folder, you’ll see the projects with the results of this chapter.
    You’ll see these folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Aspire`: This folder contains four projects created with a .NET Aspire template
    to run a .NET Aspire project including one service and a web application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Azure`: This folder contains the same four projects from the previous folder,
    enhanced by using an Azure resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with .NET Aspire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Aspire is a new .NET technology offering tools and libraries that help
    create, debug, and deploy .NET solutions built using microservices. With all the
    chapters of this book, we’ll take advantage of .NET Aspire.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll get a core understanding of how .NET Aspire works. In
    all the other chapters, we’ll make use of .NET Aspire and get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: You can install it using the .NET **Command Line Interface** (**CLI**) or using
    Visual Studio 2022\. The first version of .NET Aspire is based on .NET 8, thus
    at least .NET 8 is required to use .NET Aspire.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET Aspire requires .NET 8, and can be installed by installing a .NET workload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the workloads installed, and the version of .NET Aspire, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you use Visual Studio, use the Visual Studio Installer, and select the **.NET
    Aspire SDK** component to install .NET Aspire.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Aspire apps are designed to run in containers. Running the application
    locally, projects run directly on the system without the need for a Docker engine.
    Docker containers are used when deploying the solution. We can (and will) use
    available Docker images as part of the application. Here, the container runtime
    is required to run locally. In this book, we use the most used container runtime
    – **Docker Desktop**. Docker Desktop is free for personal use and for small companies.
    .NET Aspire also supports running containers with **Podman**.
  prefs: []
  type: TYPE_NORMAL
- en: After the installation of .NET Aspire, create a new project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .NET Aspire project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When .NET Aspire is installed, you can create a new project containing an API
    service and a Blazor client application using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With this template, four projects are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AspireSample.ApiService`: This project contains a REST service that uses ASP.NET
    Core minimal APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AspireSample.Web`: An ASP.NET Core Blazor application that sends requests
    to the API service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AspireSample.ServiceDefaults`: A library project with shared initialization
    code for all services of the solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AspireSample.AppHost`: The app host project defines the app model of the solution,
    and how all the resources are connected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s build and start the solution next.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET Aspire dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you start the newly created project (the AppHost project needs to be the
    starting project), a console opens, showing the logs of the AppHost, and the browser
    opens a dashboard that shows the resources of the project, as you can see in *Figure
    1**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Aspire dashboard](img/B21217_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Aspire dashboard
  prefs: []
  type: TYPE_NORMAL
- en: With the .NET Aspire dashboard, you can see the resources running (`apiservice`
    and `webfrontend` in this image), the state of the resources, and the endpoints,
    and can access details and logs. In the left pane, you have access to logs, traces,
    and metrics data. While the dashboard is typically not used in production environments
    (we have **Prometheus**, **Grafana**, **Azure Application Insights**, and other
    environments), it’s great to know all this information during development time.
    Are there memory leaks with services? How does the interaction with services happen?
    Where are the bottlenecks? You can find this information using the dashboard.
    This is discussed in detail in [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Because the .NET Aspire dashboard is that great, it’s available as a Docker
    image and can be used in small scenarios in production as well, but it has limitations
    outside of the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: When you click on the link of the `webfrontend`, the application opens. In case
    you already created Blazor applications, you already know the links from the application,
    as shown in *Figure 1**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – webfrontend](img/B21217_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – webfrontend
  prefs: []
  type: TYPE_NORMAL
- en: As you click the `webfrontend` makes a request to `apiservice` for random weather
    information.
  prefs: []
  type: TYPE_NORMAL
- en: The app is running, so let’s get into the generated code for .NET Aspire next.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET Aspire app model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start digging into .NET Aspire, you need to learn the app model:'
  prefs: []
  type: TYPE_NORMAL
- en: AspireSample.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you are used to the app builder pattern with .NET applications and the `Host`
    class to configure the DI container, app configuration, and logging, you can see
    some similarities. Here, a `DistributedApplication` class is used to create `IDistributedApplicationBuilder`
    with the `CreateBuilder` method. The returned builder is used to define all the
    resources needed by the solution. With the generated code, two projects are mapped
    using the `AddProject` method. The projects are referenced with a generic type,
    for example, `Projects.AspireSample_ApiService`. This type was created by adding
    a project reference to the `AspireSample.ApiService` project. You can see the
    reference when you open the `AspireSample.AppHost.csproj` project file.
  prefs: []
  type: TYPE_NORMAL
- en: Using project types with `AddProject` is convenient, but it’s not a requirement.
    You can also pass a string of a directory where the project resides.
  prefs: []
  type: TYPE_NORMAL
- en: Other than adding projects, it’s possible to add executables (`AddExecutable`)
    or Docker images (`AddContainer`).
  prefs: []
  type: TYPE_NORMAL
- en: .NET Aspire also offers a huge list of predefined resources, for example, RabbitMQ,
    Kafka, Redis, and SQL Server, and resources running within Microsoft Azure, such
    as Azure Cosmos DB, Azure Key Vault, and Azure Event Hub. To add resources to
    the app model, NuGet packages are prefixed with `Aspire.Hosting` and `Aspire.Hosting.Azure`
    needs to be added.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this book, many new resources are added to the Codebreaker solution. [*Chapter
    3*](B21217_03.xhtml#_idTextAnchor063) adds SQL Server and Azure Cosmos DB, [*Chapter
    5*](B21217_05.xhtml#_idTextAnchor110) adds Docker containers, [*Chapter 7*](B21217_07.xhtml#_idTextAnchor162)
    adds Azure App Configuration and Azure Key Vault, [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263)
    adds Azure Log Analytics, Prometheus, and Grafana, [*Chapter 13*](B21217_13.xhtml#_idTextAnchor317)
    adds Azure SignalR Services, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The name `"apiservice"` that’s passed as a parameter passed to the `AddProject`
    method defines the name of the resource. We’ll use this name later in the *Using
    service* *discovery* section.
  prefs: []
  type: TYPE_NORMAL
- en: '`AddProject` returns an object of the `IResourceBuilder<ProjectResource>` type.
    The `IResourceBuilder` objects can be used to connect multiple resources within
    the app model. The `ProjectResource` type derives from the `Aspire.Hosting.ApplicationModel.Resource`
    base class and implements several resource interface types, such as `IResourceWithEnvironment`
    and `IResourceWithServiceDiscovery`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use this resource object to connect another resource:'
  prefs: []
  type: TYPE_NORMAL
- en: Aspire/AspireSample.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `apiService` variable returned from the first `AddProject` method is referenced
    with the second project – a web frontend – using the `WithReference` method. This
    allows accessing the web frontend to access the API service. The URL of the API
    service is assigned as an environment variable to the web frontend – this is what
    the `IResourceWithServiceDiscovery` interface is used for. While the API service
    does not need to be accessed externally (only the web frontend needs access),
    the web frontend should be accessible from the outside. That’s why the `WithExternalHttpEndpoints`
    method is used with the web frontend project. This configuration information is
    used to specify how the Ingress controller added as a proxy to the resource is
    configured.
  prefs: []
  type: TYPE_NORMAL
- en: Before looking into the projects that are referenced by the AppHost, let’s get
    into the shared `AspireSample.ServiceDefaults` project.
  prefs: []
  type: TYPE_NORMAL
- en: The shared project for common configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `AspireSample.ServiceDefaults` project is a library with a common configuration
    that can be used by all the resource projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Aspire/AspireSample.ServiceDefaults/Extensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This shared project contains the `AddServiceDefaults` extension method that
    implements a common configuration for the resource applications. With the implementation,
    `ConfigureOpenTelemetry` is invoked, which is another extension method defined
    by the `Extensions` class. The parts that are common for logging, metrics, and
    distributed tracing are implemented here. This is covered in [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263).
    `AddDefaultHealthChecks` configures health checks for the services, which can
    include health checks for the .NET Aspire components that are used.
  prefs: []
  type: TYPE_NORMAL
- en: '`AddServiceDiscovery` makes use of the `Microsoft.Extensions.ServiceDiscovery`
    library, which is also new since the first release of .NET Aspire, but can also
    be used independently of .NET Aspire. The `AddServiceDiscovery` method registers
    default service endpoint resolvers. Service discovery is not only configured with
    the DI container but also with the configuration of the HTTP client, with the
    lambda parameter of the `ConfigureHttpClientDefaults` method. Service discovery
    is discussed in the next section. `ConfigureHttpClientDefaults` is part of the
    `Microsoft.Extensions.Http` library, the HTTP client factory. The package that’s
    referenced from the `ServiceDefaults` library is `Microsoft.Extensions.Http.Resiliency`.
    This library is new since .NET 8 and offers extensions to the Polly library. With
    a distributed application, invocations sometimes fail on transient issues. Retrying
    invocations to these resources can succeed when invoked another time. This functionality
    is built into .NET Aspire with default resiliency configuration in `AddStandardResilienceHandler`.'
  prefs: []
  type: TYPE_NORMAL
- en: But now, let’s get into service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Using service discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`webfrontend` needs to know about the link of `apiservice` to get the weather
    information. This link is different depending on the environment the solution
    is running with. Running the application locally on the development system, we
    use localhost links with different port numbers, and depending on the environments
    where the solution is running (for example, Azure Container App environments,
    Kubernetes, etc.), different configurations are required.'
  prefs: []
  type: TYPE_NORMAL
- en: With the new service discovery, logical names can be used for the services,
    which are resolved using different providers. Thus, the same functionality works
    in different environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Blazor client application configures `HttpClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: Aspire/AspireSample.Web/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `apiservice` name comes from the app model definition – the name that has
    been passed to the `AddProject` method. Before the colon, the schema, for example,
    `http` or `https` can be specified. Separating schemas with `+` allows the use
    of multiple schemas, and the first one is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AddServiceDiscovery` method that was added to the DI container earlier
    adds a configuration-based endpoint resolver by default. With this, the configuration
    can be added to a JSON configuration file, for example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With the configuration, the section needs to be named `Services`. Within the
    `Services` section, the named service is looked for (`apiservice`), and there,
    the values below the schema name (`https`) are resolved. The port numbers are
    randomly created and will differ with your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the AppHost, as `apiservice` is referenced from the web frontend, the
    URIs to the API service are added as environment variables. Open the .NET Aspire
    dashboard, and in the `webfrontend`. There, you can see the `services__apiservice_http__0`
    and `services__apiservice_https_0` environment variables, and the `http://localhost:5395`,
    and `https://localhost:7313` values. The URIs are specified within `Properties/launchsettings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: Aspire/AspireSample.ApiService/Properties/launchSettings.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `applicationUrl` setting defines the URLs used on starting the application,
    and this is the link that is used to add it to the environment variable. Because
    environment variables are part of the .NET configuration, these values are retrieved
    by the service discovery configuration provider.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Container Apps and Kubernetes offer service discovery features without
    using a service discovery library. With applications deployed there, a pass-through
    provider is configured using `DnsEndPoint`.
  prefs: []
  type: TYPE_NORMAL
- en: Running the .NET Aspire solution locally, the process of `webfrontend` and `apiservice`
    use random ports. A reverse proxy is automatically added before these processes,
    and the reverse proxy is accessible via the configured launch settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows the changing of the number of replicas with the app model:'
  prefs: []
  type: TYPE_NORMAL
- en: Aspire/AspireSample.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With the app model configuration in the AppHost, using `WithReplicas(3)` starts
    three instances of the service using three random ports, and the same port number
    from the reverse proxy as shown in *Figure 1**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Multiple replicas](img/B21217_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Multiple replicas
  prefs: []
  type: TYPE_NORMAL
- en: You can see three `apiservice-` services running with different postfixes, and
    three processes with the same port number, as shown with the endpoints. The endpoint
    defined from the launch settings is the endpoint of the reverse proxy. When you
    open **Details**, you can see different target ports with every service. The reverse
    proxy acts as a load balancer to choose one of the replicas.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To start the solution with the `http` launch profile, you need to add the `ASPIRE_ALLOW_UNSECURED_TRANSPORT`
    environment variable to the launch settings of the AppHost project and set it
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: This was an important core functionality from .NET Aspire. However, there’s
    more.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Aspire components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET Aspire components make it easy to use Microsoft and third-party features
    and services from within the applications that are configured. Azure Cosmos DB,
    Pomelo MySQL Entity Framework Core, and SQL Server are components available to
    access databases, and RabbitMQ, Apache Kafka, and Azure Service Bus are components
    for messaging. There’s a list available at [https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/components-overview](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/components-overview).
  prefs: []
  type: TYPE_NORMAL
- en: To use a component, typically with the AppHost, a resource needs to be configured
    by adding a host NuGet package, for example, for the Azure Cosmos DB EF Core component,
    you would add the `Aspire.Hosting.Azure.CosmosDB` package. The component itself
    is then used by adding the `Aspire.Microsoft.EntityFrameworkCore.Cosmos` package
    to the service that accesses the database, for example, the API service.
  prefs: []
  type: TYPE_NORMAL
- en: What does a component have to offer? Do you know what names are used by a technology
    to turn on logging metrics data? Aspire components know this, and it’s easy to
    configure it. When an Azure Cosmos DB resource is added to the app model, and
    is referenced by a service project, the connection string is configured as an
    environment variable (or stored within a secret store) and can be accessed by
    the project that needs the connection.
  prefs: []
  type: TYPE_NORMAL
- en: In many of the book chapters, we’ll add some new components, thus we don’t get
    into more details here.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the app model manifest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the app model defined in the `AppHost` project, we can create a JSON manifest
    file that describes the resources. You need to stop the project to allow a rebuild
    if it’s still running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'An extract of this manifest file is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Aspire/AspireSample.AppHost/aspire-manifest.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The manifest contains information about the resource type, environment variables,
    binding, and more. With the app model, we can also specify the use of Azure resources.
    This manifest file can now be used by tools to deploy the solution, (e.g., by
    using the Azure Developer CLI to deploy it to Microsoft Azure). Creating Azure
    resources is covered in [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137) and continued
    from there in other chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Using Aspir8 (an open-source project, see [https://github.com/prom3theu5/aspirational-manifests/](https://github.com/prom3theu5/aspirational-manifests/)),
    it’s possible to deploy the solution to a Kubernetes cluster. This is used in
    [*Chapter 16*](B21217_16.xhtml#_idTextAnchor373).
  prefs: []
  type: TYPE_NORMAL
- en: The app model can be customized based on different launch profiles. With this,
    different manifest files can be created to deploy to (e.g., Azure and use specific
    Azure resources and to an on-premises Kubernetes cluster).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The AppHost project containing the app model is used when starting and debugging
    the project during development. For deployment, the manifest of the app model
    is used. When running the solution in the production environment, the app host
    is no longer in action.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Aspire is used in this book from the first to the last chapter. Let’s look
    into what we are building.
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker – the solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Codebreaker solution is a traditional game to solve a set of colors. With
    one game type, the player needs to place four colors (which can be duplicates)
    from a list of six different colors. The correct colors are chosen randomly by
    the game service. With every move the player makes, an answer is returned: for
    every color that is correct and positioned at the correct place, a black peg is
    returned. For every color that is correct but wrongly positioned, a white peg
    is returned. The player now has up to 12 moves to find the correct solution. *Figure
    1**.4* shows a game run using a Blazor client application.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Blazor client application](img/B21217_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Blazor client application
  prefs: []
  type: TYPE_NORMAL
- en: This gameplay shows that the solution was found after five moves. In this case,
    the correct result was yellow – black – red – black. The first selection was red
    – green – blue – yellow, with a result of two white pegs. With the fifth move,
    yellow – black – red – black was selected and four black pegs were returned, which
    means this is the correct move.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Creating client applications is not part of this book (just a simple console
    application accessing the API is done in [*Chapter 4*](B21217_04.xhtml#_idTextAnchor092)).
    However, the source code for several client applications is available at [https://github.com/codebreakerapp](https://github.com/codebreakerapp).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service to run some game rules seems like a simple task that doesn’t
    need a microservices architecture. However, there’s more, as shown in the sequence
    diagrams in *Figure 1**.5* and *Figure 1**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – The Codebreaker play games sequence](img/B21217_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – The Codebreaker play games sequence
  prefs: []
  type: TYPE_NORMAL
- en: Multiple services are needed with the solution. The game API service is not
    only invoked by UIs used by human players; a bot service, which can be triggered
    on receiving a message, plays multiple games on its own, and the game API service
    writes information about games and every move set to a database.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Codebreaker game completion sequence](img/B21217_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Codebreaker game completion sequence
  prefs: []
  type: TYPE_NORMAL
- en: On completion of a game, the game API service not only writes this information
    to a database but also sends events. These events are received by a live service
    and a ranking service. The live service is used by live clients to monitor running
    games using ASP.NET Core SignalR. The ranking service writes completed games to
    its own database, which can be used by clients to get daily, weekly, and monthly
    game ranks. A service running Microsoft YARP is used as well to authenticate users
    and forward requests to the different services.
  prefs: []
  type: TYPE_NORMAL
- en: The Codebreaker solution makes use of several Azure services, as discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Using Microsoft Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create and run the code from this book, you also need to have an Azure subscription.
    You can activate Microsoft Azure for free at [https://azure.microsoft.com/free](https://azure.microsoft.com/free),
    which gives you an amount of about $200 Azure credits that are available for the
    first 30 days and several services that can be used for free for the time after.
  prefs: []
  type: TYPE_NORMAL
- en: 'What many developers miss is that if you have a Visual Studio Professional
    or Enterprise subscription, you also have a free amount of Azure resources every
    month. You just need to activate this with your Visual Studio subscription: [https://visualstudio.microsoft.com/subscriptions/](https://visualstudio.microsoft.com/subscriptions/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create and manage resources, we use the Azure Portal, the Azure CLI, and
    the Azure Developer CLI. On Windows, you can install them with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To install these tools on Mac and Linux, check [https://learn.microsoft.com/en-us/cli/azure/install-azure-cli](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli)
    and [https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/install-azd](https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/install-azd).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the resources used with Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Azure resources used by Codebreaker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see what Azure resources are used, check *Figure 1**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Azure resources for Codebreaker](img/B21217_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Azure resources for Codebreaker
  prefs: []
  type: TYPE_NORMAL
- en: 'The compute services where the solution is running is an Azure Container App
    environment. This is a service that abstracts a Kubernetes cluster. The bot service,
    game APIs, live service, ranking service, and the gateway using YARP run within
    Azure Container Apps. The Azure Storage queue is used from the bot service: as
    a message arrives in the queue, the bot service is triggered to play a series
    of games. The bot service can be used from all client apps as well – indirectly
    via a gateway, implemented with YARP. The game API service writes games to the
    Azure Cosmos DB and caches games with a Redis cluster. As games are completed,
    game events are pushed to the Azure Event Hub. The live service and ranking service
    are subscribers to the Event Hub. The live service uses ASP.NET Core SignalR,
    and to reduce the load of this service, the Azure SignalR service is used.'
  prefs: []
  type: TYPE_NORMAL
- en: What’s commonly used is the Azure App Configuration for application configuration
    values and feature management, Azure Key Vault to store secrets, Azure Active
    Directory B2C for user registrations, and Log Analytics and Application Insights
    to monitor the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Starting with a small version of Codebreaker, not that many Azure services would
    be required to use. For a flexible and scalable solution, which might be accessed
    worldwide, and to learn about all the different aspects of microservices, all
    these services are in use. Don’t be afraid of the cost when deploying the services
    with your Azure subscription. As long as you don’t create a huge load (which we
    do in [*Chapter 12*](B21217_12.xhtml#_idTextAnchor294)), the cost stays very small,
    and by far you will not use the full $200 available with the free subscription
    when you delete the resources again after use.
  prefs: []
  type: TYPE_NORMAL
- en: Azure provisioning from the development environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your .NET Aspire solution can easily integrate with Microsoft Azure and deploy
    resources while debugging the solution.
  prefs: []
  type: TYPE_NORMAL
- en: By debugging the solution locally, not all resources need to be deployed to
    Azure. The service projects can run locally while testing and don’t need to be
    deployed. With Azure Cosmos DB, a Docker container or a locally installed emulator
    is available. This is not possible with all resources, for example, Azure Key
    Vault or Azure Application Insights.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy these resources automatically, .NET Aspire needs access to your subscription.
    To do this, first, log in to your Azure subscription with the Azure CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This opens a browser, and you can log in with your Azure subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you have multiple subscriptions, check the Azure CLI is set to the
    current one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This shows the current active subscription. In case a different one should be
    used, use `az account list` to list all subscriptions, and `az account set –subscription
    <your subscription id>` to set the current subscription to a different one. Remember
    the value that’s listed with `id` – this is the subscription ID that’s needed
    with the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to connect the project to the subscription and specify some settings.
    It’s best to put this information within user secrets; this shouldn’t be put into
    source code repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case user secrets are not configured yet with the `AppHost`, initialize
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The configurations we need are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With `SubscriptionId`, you specify the subscription where resources are created.
    The resource group you specify with the value for `ResourceGroup` is used to create
    all the resources needed. The resource group will be created if you set `AllowResourceGroupCreation`
    to `true`. Otherwise, you need to create the resource group first. With the `Location`
    setting, specify your preferred location. To see the locations available with
    your subscription, use `az account list-locations -``o table`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `CredentialSource` setting to `AzureCli` specifies that you are
    using the same account you just used to log in with the Azure CLI to create the
    resources. Without this setting, `DefaultAzureCredential` will be used, which
    tries to use multiple account types with a predefined list until one succeeds.
    This includes Visual Studio, Azure CLI, PowerShell, Azure Developer CLI, and other
    credentials. Here, credentials might be used which don’t have access to the subscription.
    In my experience, it’s better to supply the credentials explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see all the secrets, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio, you can connect the project to Azure by using the Solution
    Explorer. Within the AppHost project, select **Connected Services**, open the
    context menu, and select **Azure Resource Provisioning Settings**. This opens
    a dialog to select the subscription, location, and resource group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s add the `Aspire.Hosting.Azure.KeyVault` NuGet package to the AppHost
    project, and update the app model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `AddAzureKeyVault` method creates a key vault named `secrets`. This is referenced
    from the `apiservice` project.
  prefs: []
  type: TYPE_NORMAL
- en: When you start the AppHost now, the key vault will be created within Azure.
    Opening the Azure portal at [https://portal.azure.com](https://portal.azure.com),
    you will see the resource group, and within the resource group, the Azure Key
    Vault is created. If you check the user secrets again, an `Azure:Deployments`
    section is added, which contains links to the resources created. This information
    is used to find the resources again, and they don’t need to be published again
    the next time you start the application.
  prefs: []
  type: TYPE_NORMAL
- en: When you are finished with this chapter, just delete the complete resource group
    from the portal, so no additional cost applies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To publish all the resources including the projects to Azure, you can use the
    Azure Developer CLI. This is covered in [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the core features of .NET Aspire, which includes
    tooling, orchestration, and Aspire components. You learned how resources are connected
    by the Aspire app model, and how service discovery is done. You’ve seen how to
    create a manifest describing the app model, which can be used by tools to deploy
    the solution.
  prefs: []
  type: TYPE_NORMAL
- en: With the Codebreaker solution, you learned about the rules of the game and the
    parts of the application that are created from the second to the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you know the different Microsoft Azure services that are used by the Codebreaker
    solution when running in Azure. An alternative to these services is offered as
    well to run the complete solution in an on-premises environment (which can also
    be hosted in the Azure cloud this way).
  prefs: []
  type: TYPE_NORMAL
- en: From the next chapter on, we’ll start developing the Codebreaker solution. In
    [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031), we will create REST services
    using ASP.NET Core minimal APIs to play games. We’ll test this API using HTTP
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET Aspire setup and** **tooling**: [https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/setup-tooling](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/setup-tooling)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET Aspire** **components**: [https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/components-overview](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/components-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET Aspire manifest** **format**: [https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format](https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub repository for** **Aspir8**: [https://github.com/prom3theu5/aspirational-manifests](https://github.com/prom3theu5/aspirational-manifests)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
