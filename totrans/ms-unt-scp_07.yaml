- en: Chapter 7. Artificial Intelligence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 人工智能
- en: 'This chapter takes a highly practical and specialized focus. Here, we''ll cover
    the development of a single Unity project from start to finish in creating a maze
    scene that features enemy characters with **Artificial Intelligence** (**AI**);
    these characters have the ability to search for and chase us, attack us, and also
    flee from us while looking for health-restore potions. The following screenshot
    shows the maze scene in Unity:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章采用高度实用和专业的视角。在这里，我们将从开始到结束全面覆盖单个Unity项目的开发，创建一个具有**人工智能**（**AI**）的敌人角色的迷宫场景；这些角色具有搜索和追逐我们、攻击我们以及寻找恢复生命药水的逃逸能力。以下截图显示了Unity中的迷宫场景：
- en: '![Artificial Intelligence](img/0655OT_07_01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![人工智能](img/0655OT_07_01.jpg)'
- en: The maze scene
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 迷宫场景
- en: Tip
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The AI project for this book can be found in the book's companion files (code
    bundle) in the `ai` folder of this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的人工智能项目可以在本书的配套文件（代码包）中找到，位于本章的`ai`文件夹中。
- en: In creating this project, we'll apply nearly all the concepts and ideas seen
    so far in an isolated and pure form, looking at how they come together in the
    project, alongside a unique range of AI concepts, such as **Finite State Machines**
    (**FSMs**), navigation meshes, line of sight, and more. To follow this chapter
    and get the most from it, I recommend that you create a new and blank Unity project
    and take each step from start to finish. The final, completed project arrived
    at by the end of this chapter can be found in the book's companion files (code
    bundle) in the `ai` folder of this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建此项目时，我们将几乎应用到目前为止所看到的所有概念和想法，以孤立和纯粹的形式审视它们如何在项目中结合，同时结合一系列独特的AI概念，如**有限状态机**（**FSMs**）、导航网格、视线等。为了跟上本章内容并从中获得最大收益，我建议您创建一个新的空白Unity项目，并从头到尾完成每个步骤。本章结束时，最终完成的项目可以在本书的配套文件（代码包）中找到，位于本章的`ai`文件夹中。
- en: Artificial Intelligence in games
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏中的人工智能
- en: 'The concept of intelligence can be understood in many senses: psychological,
    scientific, philosophical, spiritual, sociological, and others. Many of them are
    profound. However, in video games, it''s primarily about appearances, namely,
    the appearance of intelligence. Perhaps, this is why the word "artificial" enters
    the title. The idea is that video games are primarily about having fun and interesting
    experiences. This means that the believability of a game for the gamer rests on
    how engaged they are with the events actually happening in the game. Thus, whenever
    a **non-player character** (**NPC**), such as an enemy wizard in an RPG, does
    something "silly" (like walking through solid walls for no good reason or aimlessly
    walking back and forth as though stuck), then the gamer perceives that something
    is wrong. They regard the characters as not acting intelligently just because
    the character''s behavior, in those specific circumstances, is not appropriate
    and cannot be explained reasonably with reference to anything else happening in
    the game. The "mistake" or "silliness" of the character''s behavior forces the
    player to recognize a glitch, and in doing so, the gamer is removed from the experience,
    becoming aware that it''s just a game. The upshot of this is that for games, AI
    largely consists of making characters respond appropriately to their situation
    whenever the gamer is looking. In games where AI is for enemies or opponents,
    this consists largely of tweaking difficulty, that is, not making the AI too easy
    or too hard. Seen in this way, AI is not about building a mathematical model of
    the human mind and consciousness that simulates what happens to us while thinking
    from an inward or internal perspective. It''s only about creating behaviors, making
    characters act as we''d expect them to under those specific conditions, as shown
    in the following screenshot. Consequently, there''s something "hollow" about AI
    for games, but this philosophical observation need not concern us here any further.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 智能的概念可以从许多角度来理解：心理的、科学的、哲学的、精神的、社会学的，等等。其中许多都是深刻的。然而，在视频游戏中，它主要关乎外观，即智能的外观。也许这就是为什么标题中出现了“人工”这个词。其想法是，视频游戏主要是关于有趣和有趣的体验。这意味着游戏的可信度取决于玩家对游戏实际发生事件的参与程度。因此，每当一个**非玩家角色**（**NPC**），如RPG中的敌人法师，做一些“愚蠢”的事情（比如毫无理由地穿过固体墙壁，或者像被卡住一样盲目地来回走动），玩家就会感觉到有问题。他们认为角色之所以不聪明，是因为在特定情况下角色的行为不合适，并且无法用游戏中的其他任何事情来合理解释。角色行为的“错误”或“愚蠢”迫使玩家意识到一个漏洞，在这个过程中，玩家就会从体验中脱离出来，意识到这只是一个游戏。结果是，对于游戏来说，AI在很大程度上是让角色在玩家观察时对他们的处境做出适当的反应。在AI用于敌人或对手的游戏中，这主要涉及调整难度，即不要让AI太容易或太难。从这种角度来看，AI不是关于构建一个模拟人类思维和意识的数学模型，从内心或内部视角模拟我们思考时发生的事情。它只是关于创造行为，让角色在特定条件下表现得像我们预期的那样，如下面的截图所示。因此，游戏的AI有一种“空洞”的感觉，但这个哲学观察在这里不必再进一步关注。
- en: '![Artificial Intelligence in games](img/0655OT_07_02.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![游戏中的人工智能](img/0655OT_07_02.jpg)'
- en: The enemy AI character to be created using the Unity constructor mesh
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Unity构造者网格创建的敌人AI角色
- en: In this chapter, we'll create a first-person sample game set inside a maze environment.
    Here, the player can attack enemies, and enemies can attack the player. The enemy
    mesh itself is based on the animated constructor character that ships with Unity
    and features the walk, run, and jump animations. The constructor character (not
    class constructors) will search the environment, look for the player, and when
    they are found, chase and attack them. The constructor can also be attacked, and
    when attacked, they will flee and search for power-ups if their health runs low.
    So, let's get started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个设置在迷宫环境中的第一人称样本游戏。在这里，玩家可以攻击敌人，敌人也可以攻击玩家。敌人网格本身基于Unity附带的可动画构造者角色，并具有行走、奔跑和跳跃动画。构造者角色（不是类构造函数）将在环境中搜索，寻找玩家，一旦找到，就会追逐并攻击他们。构造者也可以被攻击，当被攻击时，如果他们的健康值降低，他们会逃跑并寻找增强道具。所以，让我们开始吧！
- en: Starting the project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始项目
- en: To start, create a blank, new Unity project with a new scene. For this sample,
    I've imported several Unity asset packages via the file menu command by selecting
    the **Import Package** option from **Asset**. The packages are **Character** **Controller**,
    **Skyboxes**, and **Particles**, as shown in the following screenshot. **Character
    Controllers** features the constructor mesh and animations, as well as a first-person
    controller prefab.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个空白的新Unity项目和一个新场景。对于这个示例，我已经通过文件菜单命令从**Asset**中选择**Import Package**选项导入了几个Unity资产包。这些包是**Character
    Controller**、**Skyboxes**和**Particles**，如图下所示。**Character Controllers**包含构造网格和动画，以及一个第一人称控制器预制体。
- en: The **Skyboxes** package adds some eye candy for a sky that the camera will
    see, and the **Particles** package will be used to create a teleporter device,
    as we'll see.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Skyboxes**包为相机将看到的场景添加了一些视觉效果，而**Particles**包将被用来创建传送装置，正如我们将看到的。'
- en: '![Starting the project](img/0655OT_07_03.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![启动项目](img/0655OT_07_03.jpg)'
- en: Importing assets into the project
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将资产导入到项目中
- en: Also, add a first-person controller and the maze mesh to the scene (the mesh
    is included in the book's companion files in the `assets` folder of this chapter)
    and create some lighting and light mapping to make things look good initially.
    The mesh was created in a 3D modeling program, in this case, Blender ([http://www.blender.org/](http://www.blender.org/)).None
    of these assets are, however, critical to AI per se, but they create a presentable
    gray-box scenario with which you can work. Lightmapping details are outside the
    scope of this book, but Lightmapping features can be accessed by selecting **Lightmapping**
    in the **Window** option from the application menu, as shown in the following
    screenshot.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将一个第一人称控制器和迷宫网格添加到场景中（网格包含在本章的书籍配套文件中的`assets`文件夹中）并创建一些照明和光照贴图，以使事物看起来最初就很好。这个网格是在一个3D建模程序中创建的，在这个例子中，是Blender
    ([http://www.blender.org/](http://www.blender.org/))。然而，这些资产本身对于AI本身并不是关键的，但它们创建了一个可展示的灰盒场景，你可以在这个场景中工作。光照贴图的细节超出了本书的范围，但可以通过从应用程序菜单中选择**Window**选项中的**Lightmapping**来访问光照贴图功能，如图下所示。
- en: More details on Lightmapping can be found in the online Unity documentation
    at [http://docs.unity3d.com/Manual/Lightmapping.html](http://docs.unity3d.com/Manual/Lightmapping.html).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于光照贴图的信息可以在在线Unity文档中找到，网址为[http://docs.unity3d.com/Manual/Lightmapping.html](http://docs.unity3d.com/Manual/Lightmapping.html)。
- en: '![Starting the project](img/0655OT_07_04.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![启动项目](img/0655OT_07_04.jpg)'
- en: Creating the initial scene
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建初始场景
- en: Baking a navigation mesh
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航网格烘焙
- en: The enemy to be created needs to walk intelligently around the level to find
    and chase the player as well as to find health-restore power-ups. The AI cannot
    simply walk in a straight line between any two points, as there might be intervening
    obstacles such as walls and other characters. The AI should instead navigate around
    these objects when they're encountered. To achieve this in the long term, a navigation
    mesh should be used. This is an invisible mesh asset that Unity generates automatically
    to approximate all walkable, horizontal surfaces in the level, that is, surfaces
    classified as a floor. The navigation mesh itself contains no AI. It does not
    make anything walk. The navigation mesh is rather a mathematical model that contains
    all the necessary data that allows AI units to successfully calculate and travel
    a path that avoids obstacles as and when required. To generate a navigation mesh
    for the level, select the **Navigation** option from the **Window** tab of the
    application menu. This displays the **Navigation Mesh** tab, which can be docked
    into the Object Inspector.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建的敌人需要在关卡中智能地行走，以找到并追逐玩家，以及找到恢复生命力的道具。AI不能简单地从任何两点之间直线行走，因为可能会有墙壁和其他角色等障碍物。当遇到这些物体时，AI应该绕过这些物体导航。为了长期实现这一点，应该使用导航网格。这是一个不可见的网格资产，Unity会自动生成，以近似关卡中所有可通行的水平表面，即被分类为地面的表面。导航网格本身不包含AI。它不会使任何事物行走。导航网格实际上是一个数学模型，它包含所有必要的用于AI单位成功计算和避开障碍物路径的数据。要为关卡生成导航网格，请从应用程序菜单的**Window**选项卡中选择**Navigation**选项。这将显示**Navigation
    Mesh**选项卡，它可以停靠到对象检查器中。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For the basics on navigation mesh baking, see the online Unity documentation
    at [http://docs.unity3d.com/Manual/Navmeshes.html](http://docs.unity3d.com/Manual/Navmeshes.html).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关于导航网格烘焙的基础知识，请参阅在线Unity文档，网址为[http://docs.unity3d.com/Manual/Navmeshes.html](http://docs.unity3d.com/Manual/Navmeshes.html)。
- en: 'When baking a navigation mesh, there are some additional details to keep in
    mind, as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在烘焙导航网格时，需要注意一些额外的细节，如下面的截图所示：
- en: '![Baking a navigation mesh](img/0655OT_07_05.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![烘焙导航网格](img/0655OT_07_05.jpg)'
- en: Preparing to bake a navigation mesh
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 准备烘焙导航网格
- en: 'First, the **Radius** setting will likely require adjusting from its default.
    In short, this setting defines an imaginary circle around the feet of your characters;
    this circle indicates their approximate size as walking agents. If the radius
    is too large, the navigation mesh appears broken or fractured, and if it is too
    small, the mesh takes a long time to generate, and additionally, your agents will
    penetrate through walls while walking. A certain degree of trial and error and
    refinement lets you reach a value that works best for your project. For this sample,
    a value of 0.2 works best. If the radius is too high, your navigation mesh will
    fracture in narrow areas, which is not good because agents cannot travel across
    gaps, as shown in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，**半径**设置可能需要从默认值进行调整。简而言之，此设置定义了一个围绕角色脚部的想象中的圆圈；这个圆圈表示它们作为步行代理的大致尺寸。如果半径太大，导航网格看起来会断裂或破碎，如果太小，网格生成将花费很长时间，此外，你的代理在行走时可能会穿透墙壁。通过一定程度的试错和细化，你可以找到一个最适合你项目的值。对于这个示例，0.2
    的值效果最佳。如果半径过高，你的导航网格在狭窄区域会断裂，这并不好，因为代理无法穿越缝隙，如下面的截图所示：
- en: '![Baking a navigation mesh](img/0655OT_07_06.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![烘焙导航网格](img/0655OT_07_06.jpg)'
- en: Navigation mesh fracture in narrow areas
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 狭小区域的导航网格断裂
- en: Second, a navigation mesh (once generated) might appear raised above or offset
    upwards, away from the true mesh floor. If this happens, you could reduce the
    **Height Inaccuracy %** setting to `1` from the **Advanced** group, as shown in
    the following screenshot. This prevents your agents from appearing to hover in
    midair. Remember that after adjusting any settings, you need to rebake the navigation
    mesh to apply the changes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，生成的导航网格（一旦生成）可能会出现在真实网格地板之上或向上偏移。如果发生这种情况，你可以将**高度误差百分比**设置从**高级**组中的`1`降低，如下面的截图所示。这可以防止你的代理看起来在空中悬浮。记住，在调整任何设置后，你需要重新烘焙导航网格以应用更改。
- en: '![Baking a navigation mesh](img/0655OT_07_07.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![烘焙导航网格](img/0655OT_07_07.jpg)'
- en: Reducing Height Inaccuracy % moves the generated navigation mesh closer to the
    true floor
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 降低高度误差百分比将生成的导航网格移动到真实地板更近的位置
- en: From the figures, you can see that the maze scene features two separate maze
    areas (left and right) with no connecting mesh between them that allows the creation
    of a path. For this sample, the intelligent agents should be able to move freely
    between each section using a teleporter to transport them from one area to another,
    if required.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中可以看出，迷宫场景有两个独立的迷宫区域（左和右），它们之间没有连接的网格，不允许创建路径。对于这个示例，智能代理应该能够通过传送器在各个部分之间自由移动，如果需要的话，将它们从一个区域传送到另一个区域。
- en: 'To achieve a connection like this between a break in the navigation mesh that
    allows the AI to compute valid paths across surfaces, we could use off-mesh links.
    Add a new mesh to the level that should act as a teleporter pad or platform when
    stepped upon. For this example, I used a standard box mesh with a particle system
    for enhanced effect, but this is not essential. Then, attach an off-mesh link
    component to the mesh object, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在导航网格的断裂处实现这种连接，允许AI在表面上计算有效路径，我们可以使用离网链接。为应该作为传送平台或平台使用的级别添加一个新的网格。在这个示例中，我使用了一个标准的盒子网格和一个粒子系统以增强效果，但这不是必需的。然后，将离网链接组件附加到网格对象上，如下所示：
- en: '![Baking a navigation mesh](img/0655OT_07_08.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![烘焙导航网格](img/0655OT_07_08.jpg)'
- en: Creating a teleporter pad using off-mesh links
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用离网链接创建传送平台
- en: Repeat the procedure for the destination teleporter pad. For each teleporter,
    assign the object's transform to the **Start** field of the off-mesh link component.
    This indicates the selected teleporter as the start point. Then, for the **End**
    field, assign the destination transform. This establishes a connection between
    the two teleporters that creates a path between them. When the connection is established,
    a connection arrow should be drawn in-between the scene viewport when the **Navigation**
    panel is open and active in the editor, as shown in the following screenshot.
    You can also generate off-mesh links automatically. For more information, visit
    [https://www.youtube.com/watch?v=w3-sSozYph4](https://www.youtube.com/watch?v=w3-sSozYph4).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对目的地传送器垫重复此过程。对于每个传送器，将对象的变换分配给离网格链接组件的**开始**字段。这表示选定的传送器为起点。然后，对于**结束**字段，分配目标变换。这在这两个传送器之间建立连接，创建它们之间的路径。当连接建立时，当在编辑器中打开并激活**导航**面板时，应在场景视图中绘制一个连接箭头，如图所示。您还可以自动生成离网格链接。有关更多信息，请访问[https://www.youtube.com/watch?v=w3-sSozYph4](https://www.youtube.com/watch?v=w3-sSozYph4)。
- en: '![Baking a navigation mesh](img/0655OT_07_09.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![烘焙导航网格](img/0655OT_07_09.jpg)'
- en: Defining a connection between off-mesh links
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 定义离网格链接之间的连接
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The starting project for this chapter, ready for AI coding, can be found in
    the book's companion files (code bundle) in the `Start` folder of this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起始项目，准备好进行AI编码，可以在本书的配套文件（代码包）中找到，位于本章的`Start`文件夹中。
- en: Starting an NPC agent
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动NPC代理
- en: Now, let's create an AI agent for the level, something that can interact with
    the player. First, the agent needs a physical mesh representation in the scene.
    For this, I used the `Constructor` mesh, which is part of the Unity **Character
    Controllers** package imported earlier. Drag-and-drop this from the **Project**
    panel into the scene and then remove any animator component that might be created,
    as shown in the following screenshot. The animations will be important, but a
    custom-made animator controller will be created later.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为关卡创建一个AI代理，一个可以与玩家交互的实体。首先，代理需要在场景中有一个物理网格表示。为此，我使用了`Constructor`网格，它是之前导入的Unity
    **Character Controllers**包的一部分。从**项目**面板拖放此网格到场景中，然后移除可能创建的任何动画组件，如图所示。动画将很重要，但稍后将会创建一个定制的动画控制器。
- en: '![Starting an NPC agent](img/0655OT_07_10.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![启动NPC代理](img/0655OT_07_10.jpg)'
- en: Adding a constructor mesh for the enemy character
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为敌人角色添加构造网格
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that we're not using the third-person controller prefab; it's just
    the constructor mesh alone.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们并没有使用第三人称控制器预制件；这里仅使用构造网格。
- en: Next, add a `NavMeshAgent` component to the object by navigating to **Component**
    | **Navigation** | **Nav Mesh Agent**. This allows the object to work with the
    navigation mesh, and it is able to find and travel paths when instructed. Set
    both the **Radius** and **Height** values of the component to match the dimensions
    of the mesh. Set the **Stopping Distance** to `2`; this controls how close to
    a destination that the player should reach before stopping, as shown in the following
    screenshot. Of course, for your own projects, the **Stopping Distance** value
    will probably need to be edited.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过导航到**组件** | **导航** | **Nav Mesh Agent**为对象添加`NavMeshAgent`组件。这允许对象与导航网格一起工作，并在被指示时能够找到并旅行路径。将组件的**半径**和**高度**值设置为与网格尺寸相匹配。将**停止距离**设置为`2`；这控制玩家在停止前应该到达目的地有多近，如图所示。当然，对于你自己的项目，**停止距离**的值可能需要编辑。
- en: '![Starting an NPC agent](img/0655OT_07_11.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![启动NPC代理](img/0655OT_07_11.jpg)'
- en: Configuring a NavMeshAgent component for pathfinding
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 配置NavMeshAgent组件以进行路径查找
- en: Now, add a `Rigidbody` component and enable the **Is Kinematic** checkbox, as
    shown in the following screenshot. This allows the object to enter trigger volumes
    and be a part of the physics system by both causing and receiving physics events.
    However, with **Is Kinematic** checked, Unity will not override the object's transformation
    (position, rotation, and scale). This allows the `NavMeshAgent` exclusively to
    control the movement of the character.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一个`Rigidbody`组件并勾选**Is Kinematic**复选框，如图所示。这允许对象进入触发体积，并通过引起和接收物理事件成为物理系统的一部分。然而，当勾选**Is
    Kinematic**时，Unity不会覆盖对象的变换（位置、旋转和缩放）。这允许`NavMeshAgent`专门控制角色的移动。
- en: '![Starting an NPC agent](img/0655OT_07_12.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![启动NPC代理](img/0655OT_07_12.jpg)'
- en: Configuring a Rigidbody component for physics
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为刚体组件配置物理属性
- en: 'Now, add a `BoxCollider` component to the object and enable the **Is Trigger**
    checkbox to convert it into a trigger volume, that is, a volume that allows physical
    objects to pass through as opposed to blocking them. This will be used by the
    AI to approximate an agent''s field of view or viewing area. It will follow the
    agent, and only other objects entering its field are classified as worthy of further
    consideration. To size the volume to the agent''s field of view, use the **X**,
    **Y**, and **Z** size fields, as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向对象添加一个`BoxCollider`组件，并启用**Is Trigger**复选框将其转换为触发体积，即允许物理对象通过而不是阻止它们的体积。这将由AI用来近似代理的视野或观察区域。它将跟随代理，并且只有进入其视野的其他对象才被视为值得进一步考虑。为了将体积调整到代理的视野大小，使用**X**、**Y**和**Z**大小字段，如图所示：
- en: '![Starting an NPC agent](img/0655OT_07_13.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![启动NPC代理](img/0655OT_07_13.jpg)'
- en: Using a BoxCollider component to configure the field of view for an enemy agent
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用BoxCollider组件为敌人代理配置视野
- en: Finally, create a new C# script file, `AI_Enemy.cs`, in the project to define
    the enemy intelligence. This script will encapsulate the complete AI for the enemy
    character and will be developed over the course of this chapter. Once the file
    is initially created, attach it to the enemy object in the scene. We're now ready
    to jump into the AI coding and graph building! We'll start by creating FSMs and
    their attendant states that specify how the enemy should behave.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在项目中创建一个新的C#脚本文件，名为`AI_Enemy.cs`，以定义敌人的智能。此脚本将封装敌人角色的完整AI，并将在本章的整个过程中开发。一旦文件最初创建，将其附加到场景中的敌人对象上。我们现在准备好跳入AI编码和图形构建了！我们将从创建FSM及其相关状态开始，这些状态指定了敌人应该如何行为。
- en: Finite State Machines in Mecanim
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mecanim中的有限状态机
- en: From this point onwards, we'll concentrate mainly on coding AI for the enemy
    character both in C# and in terms of visual coding for a Mecanim graph. Mecanim
    refers to the Unity's Animation System ([http://docs.unity3d.com/Manual/MecanimAnimationSystem.html](http://docs.unity3d.com/Manual/MecanimAnimationSystem.html)).
    In the upcoming sections, we'll piece together a complete class that looks at
    and discusses specific sections of code, and the full class source code will be
    pieced together as we go along. It can be viewed in the completed project in the
    `AI_Enemy.cs` file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将主要集中讨论在C#中为敌人角色编写AI，以及从视觉编码的角度为Mecanim图进行编码。Mecanim指的是Unity的动画系统([http://docs.unity3d.com/Manual/MecanimAnimationSystem.html](http://docs.unity3d.com/Manual/MecanimAnimationSystem.html))。在接下来的章节中，我们将逐步构建一个完整的类，该类将查看并讨论特定的代码部分，并且完整的类源代码将随着我们的进展逐步组合。它可以在完成的项目中的`AI_Enemy.cs`文件中查看。
- en: To start, let's examine FSMs conceptually. When thinking about the enemy character,
    we can observe in them a specific set of behaviors. The enemy begins the scene
    by standing idle and then proceeds to wander around on patrol. During their patrol,
    they might see the player character. If they do so, they'll chase the player until
    the player comes into attack range. When the player enters attack range, they'll
    attack the player. Now, the only exception to these rules is if the enemy sustains
    serious health damage that brings them close to death. On reaching critical levels
    like this, the enemy will, instead of acting aggressively, flee and search for
    a health-restore potion until their health level is returned to normal.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从概念上考察有限状态机（FSM）。当思考敌人角色时，我们可以观察到它们具有一组特定的行为。敌人开始场景时是站立不动的，然后开始巡逻。在巡逻期间，他们可能会看到玩家角色。如果他们这样做，他们会追逐玩家，直到玩家进入攻击范围。当玩家进入攻击范围时，他们会攻击玩家。现在，这些规则唯一的例外是如果敌人受到严重的健康伤害，使他们接近死亡。达到这种临界水平时，敌人将不会采取攻击性行为，而是逃跑并寻找恢复健康的药水，直到他们的健康水平恢复正常。
- en: 'In summarizing the enemy behavior sets like this, we''ve identified a number
    of discrete and critical states for enemy intelligence. These are idle, patrol,
    chase, attack, and flee. The enemy can be in one and only one of these states
    at any one time, and each state determines how the enemy will behave. To implement
    this logic, we can use an FSM design. This refers not to a specific class or object
    type (such as `MonoBehaviour` or `ScriptableObject`) but rather to a design pattern,
    a way of coding. An FSM begins with a finite set of states (idle, patrol, chase,
    and so on, as mentioned earlier) and then manages how the states are connected
    to one another logically. This determines when and how one state changes to another.
    The enemy for our situation here will depend, in fact, on two-state machines under
    the hood: one in C# code and the other in a Mecanim animator graph. The latter
    controls only the animation that should play for the enemy mesh during each state.
    Let''s build the Mecanim graph first.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样总结敌人行为集合时，我们识别出了一系列离散且关键的敌人智能状态。这些状态包括空闲、巡逻、追逐、攻击和逃跑。敌人在任何时刻只能处于这些状态中的一个，并且每个状态决定了敌人的行为方式。为了实现这种逻辑，我们可以使用有限状态机（FSM）设计。这并不是指特定的类或对象类型（如`MonoBehaviour`或`ScriptableObject`），而是一种设计模式，一种编码方式。FSM从一个有限的状态集合（空闲、巡逻、追逐等，如前所述）开始，然后管理这些状态之间逻辑上的连接。这决定了何时以及如何从一个状态转换到另一个状态。实际上，我们这里的敌人将取决于底层的两个状态机：一个在C#代码中，另一个在Mecanim动画师图表中。后者仅控制每个状态下敌人网格应播放的动画。让我们首先构建Mecanim图表。
- en: 'Right-click on the **Project** panel and create a new **Animator Controller**
    asset. Open the asset inside the **Animator** window that is accessible by selecting
    the **Animator** option in **Window** from the application main menu, as shown
    here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击**项目**面板，创建一个新的**动画控制器**资产。在**动画**窗口中打开该资产，该窗口可通过从应用程序主菜单中选择**窗口**中的**动画**选项访问，如图所示：
- en: '![Finite State Machines in Mecanim](img/0655OT_07_14.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Mecanim中的有限状态机](img/0655OT_07_14.jpg)'
- en: Accessing the animation graph
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 访问动画图表
- en: 'The Mecanim animator graph defines all the possible animation states for the
    mesh, and these should correspond to the enemy states already outlined, namely,
    idle, patrol, chase, attack, and flee. To configure the animations for these states,
    select the **Constructor** mesh asset in the **Project** panel and make all animations
    loopable by enabling the **Loop Time** and **Loop Pose** checkboxes in the Object
    Inspector, as shown in the following screenshot. This prevents the character animations
    from stopping after playing only once:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Mecanim动画师图表定义了网格的所有可能的动画状态，并且这些状态应该与已经概述的敌人状态相对应，即空闲、巡逻、追逐、攻击和逃跑。为了配置这些状态的动画，在**项目**面板中选择**构造器**网格资产，并在对象检查器中启用**Loop
    Time**和**Loop Pose**复选框，如图所示。这可以防止角色动画在播放一次后停止：
- en: '![Finite State Machines in Mecanim](img/0655OT_07_15.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Mecanim中的有限状态机](img/0655OT_07_15.jpg)'
- en: Preparation of animation assets for a Mecanim FSM
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为Mecanim FSM准备动画资产
- en: Now, let's add animation states to the graph, one animation per state. For the
    **Idle** state, the idle animation should play. For the **Patrol** state, the
    walk animation should play as the character should be walking around. For the
    **Chase** and **Flee** states, the run animation should play, and for the **Attack**
    state, the jump animation should play. The **Constructor** model lacks a dedicated
    animation for attacks, so (for this sample) the jump animation will suffice as
    an attack animation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向图表中添加动画状态，每个状态一个动画。对于**空闲**状态，应播放空闲动画。对于**巡逻**状态，应播放行走动画，因为角色应该四处走动。对于**追逐**和**逃跑**状态，应播放跑步动画，而对于**攻击**状态，应播放跳跃动画。**构造器**模型缺少专门的攻击动画，因此（在这个示例中）跳跃动画将足够作为攻击动画。
- en: 'Go ahead and add these to the graph by dragging-and-dropping each animation
    from the **Project** panel into the Graph Editor, and name each state as appropriate,
    as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些动画通过拖放从**项目**面板拖到图表编辑器中，并为每个状态适当地命名，如图所示：
- en: '![Finite State Machines in Mecanim](img/0655OT_07_16.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Mecanim中的有限状态机](img/0655OT_07_16.jpg)'
- en: Building an FSM in the Animator window
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画窗口中构建FSM
- en: 'In addition to the standard animation states added so far, let''s add an additional
    empty state too. This will be the initial and default state of the enemy; this
    state plays no animation and represents, effectively, a stateless state until
    we explicitly put the enemy into a specific state at level startup. To create
    an empty and default state, right-click on the empty space inside the Graph Editor
    and choose the **Empty** option in **Create State** from the context menu (rename
    it appropriately to `Start` or `Init`), and then make it the default state by
    right-clicking on the state and choosing **Set As Default**, as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了迄今为止添加的标准动画状态外，我们再添加一个额外的空状态。这将成为敌人的初始和默认状态；此状态不播放任何动画，实际上代表了一个无状态的状态，直到我们在关卡启动时明确地将敌人放入特定的状态。要创建一个空和默认状态，右键单击图编辑器内的空白区域，从上下文菜单中选择**创建状态**中的**空**选项（适当地重命名为`Start`或`Init`），然后右键单击状态并选择**设置为默认状态**，如图所示：
- en: '![Finite State Machines in Mecanim](img/0655OT_07_17.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Mecanim中的有限状态机](img/0655OT_07_17.jpg)'
- en: Setting the empty node as the default state
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将空节点设置为默认状态
- en: The graph now features one animation per state for the character, but the states
    are not connected; each state is isolated. Specifically, there's no logic that
    governs the conditions by which one state moves to another. To fix this, create
    five new triggers using the **Parameters** box in the bottom-left corner of the
    Mecanim window. A trigger variable is a special Boolean type that Unity will automatically
    reset to `false`; every time it's made `true`, it allows behaviors to be initiated
    once, such as state changes. The triggers, as we'll see, can be accessed in C#
    code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图现在为角色每个状态定义了一个动画，但状态之间没有连接；每个状态都是孤立的。具体来说，没有逻辑来控制一个状态如何移动到另一个状态的条件。为了解决这个问题，使用Mecanim窗口左下角的**参数**框创建五个新的触发器。触发器变量是一种特殊的布尔类型，Unity会自动将其重置为`false`；每次将其设置为`true`时，它允许行为被启动一次，例如状态更改。正如我们将看到的，可以在C#代码中访问触发器。
- en: 'For now, create five triggers: **Idle**, **Patrol**, **Chase**, **Attack**,
    and **SeekHealth**, as shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建五个触发器：**空闲**、**巡逻**、**追逐**、**攻击**和**寻找健康**，如图所示：
- en: '![Finite State Machines in Mecanim](img/0655OT_07_18.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Mecanim中的有限状态机](img/0655OT_07_18.jpg)'
- en: Creating a Trigger variable for each animation state
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个动画状态创建一个触发器变量
- en: 'With both the states and triggers created, the connection between the states
    in the graph can now be defined more precisely. Specifically, the **Idle** state
    should change to the **Patrol** state when the trigger **Patrol** is activated,
    the **Patrol** to the **Chase** state when trigger **Chase** is activated, the
    **Chase** state to the **Attack** state when trigger **Attack** is activated,
    and so on. In addition, there''s a two-way linkage between most states: **Patrol**
    can transition to **Chase** (such as when the enemy sees the player) and **Chase**
    can transition back to **Patrol** (when the enemy loses sight of the player).
    To create connections between states, right-click on a state, select **Make Transition**
    from the context menu, and then click on the destination state to which a connection
    should be made.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建好状态和触发器之后，现在可以在图中更精确地定义状态之间的连接。具体来说，当触发器**巡逻**被激活时，**空闲**状态应转换为**巡逻**状态，当触发器**追逐**被激活时，**巡逻**状态转换为**追逐**状态，当触发器**攻击**被激活时，**追逐**状态转换为**攻击**状态，依此类推。此外，大多数状态之间存在双向链接：**巡逻**可以转换为**追逐**（例如，当敌人看到玩家时），而**追逐**可以转换回**巡逻**（当敌人失去对玩家的视线时）。要创建状态之间的连接，右键单击一个状态，从上下文菜单中选择**创建转换**，然后单击应建立连接的目标状态。
- en: '![Finite State Machines in Mecanim](img/0655OT_07_19.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Mecanim中的有限状态机](img/0655OT_07_19.jpg)'
- en: Setting the condition for a state transition
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 设置状态转换的条件
- en: The graph now defines a complete animation state machine (FSM) for an enemy
    object. Attaching this to the enemy object in the scene is simple.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图现在定义了一个完整的动画状态机（FSM）用于敌人对象。将其附加到场景中的敌人对象上很简单。
- en: 'Add an **Animator** component to the object and then drag-and-drop the **Animator**
    controller from the **Project** panel into the **Controller** field on the **Animator**
    component, as shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将**Animator**组件添加到对象上，然后从**项目**面板中将**Animator**控制器拖放到**Animator**组件的**控制器**字段中，如图所示：
- en: '![Finite State Machines in Mecanim](img/0655OT_07_20.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Mecanim中的有限状态机](img/0655OT_07_20.jpg)'
- en: Attaching Animator to an enemy object
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将动画器附加到敌人对象上
- en: Finite State Machines in C# – getting started
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#中的有限状态机 – 入门
- en: 'Now that the FSM for animation is completed, we should turn our attention to
    an FSM in C# that governs the behavior of the enemy as well as initiates our triggers
    in the Mecanim graph to play the appropriate animations (walk and run) at the
    right time. To begin the implementation, add the following public enumeration
    to the top of the `AI_Enemy.cs` script file, as shown in the following code sample
    7-1\. This enumeration defines all the possible states in the FSM for the enemy,
    and each state is assigned its unique string hash code; that is, the `IDLE` state
    is assigned the value of `2081823275`, which is the hash code for the string `IDLE`,
    and so on. This will be important later to work with Mecanim and specifically
    to initiate triggers. You can retrieve the hash code for a string using the `StringToHash`
    function of the `Animator` class, as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在动画的 FSM 已经完成，我们应该将注意力转向 C# 中的 FSM，该 FSM 管理敌人的行为，并在 Mecanim 图中启动触发器，以在正确的时间播放适当的动画（行走和跑步）。为了开始实现，请将以下公共枚举添加到
    `AI_Enemy.cs` 脚本文件的顶部，如下面的代码示例 7-1 所示。此枚举定义了敌人 FSM 中所有可能的状态，并且每个状态都分配了其唯一的字符串哈希码；即，`IDLE`
    状态分配了 `2081823275` 的值，这是字符串 `IDLE` 的哈希码，以此类推。这将在以后与 Mecanim 一起工作，特别是启动触发器时非常重要。您可以使用
    `Animator` 类的 `StringToHash` 函数检索字符串的哈希码，如下所示：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information can be found online at [http://docs.unity3d.com/ScriptReference/Animator.StringToHash.html](http://docs.unity3d.com/ScriptReference/Animator.StringToHash.html).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在网上找到：[http://docs.unity3d.com/ScriptReference/Animator.StringToHash.html](http://docs.unity3d.com/ScriptReference/Animator.StringToHash.html)。
- en: 'On the basis of the enumeration `AI_ENEMY_STATE`, the `AI_Enemy` class will
    maintain a public variable `CurrentState`, which expresses the active state of
    the enemy object right now. This variable will change over time as the states
    change, as shown in the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 `AI_ENEMY_STATE` 枚举，`AI_Enemy` 类将维护一个公共变量 `CurrentState`，该变量表示敌人对象当前的活动状态。随着时间的推移，状态的变化，该变量将发生变化，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Like most objects, the class `AI_Enemy` features an `Awake` function to retrieve
    cached component references to other components, including the `NavMeshAgent`
    and the local `Transform`, as well as to other objects in the scene, such as the
    `Player` object. These references will be used elsewhere in the script, as shown
    in the following code sample 7-2:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数对象一样，类 `AI_Enemy` 具有用于检索缓存的组件引用的 `Awake` 函数，包括 `NavMeshAgent` 和本地 `Transform`，以及场景中的其他对象，例如
    `Player` 对象。这些引用将在脚本的其他地方使用，如下面的代码示例 7-2 所示：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'This code uses cached variables: `ThisAnimator`, `ThisTransform`, `ThisAgent`,
    and `ThisCollider`. This lets us retrieve immediate and direct references to attached
    components at level startup, which saves us from having to call C# property functions
    (`get` and `set`) every time we need access to an object. Thus, `This.Transform`
    carries a greater performance overhead than the optimized, cached variable, `ThisTransform`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用缓存的变量：`ThisAnimator`、`ThisTransform`、`ThisAgent` 和 `ThisCollider`。这使得我们能够在级别启动时立即检索附加组件的直接引用，从而节省了我们每次需要访问对象时调用
    C# 属性函数（`get` 和 `set`）的需要。因此，`This.Transform` 比优化后的、缓存的变量 `ThisTransform` 带有更大的性能开销。
- en: Each state in the FSM will be coded as a separate Coroutine, one Coroutine per
    state. The Coroutine will loop infinitely and exclusively as long as the state
    is active, defining all behaviors for the enemy in that state. The primary job
    of the state machine is to select and initiate the appropriate state under the
    correct conditions. Let's start by creating the `Idle` state—the default or normal
    state for the enemy.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: FSM 中的每个状态都将编码为一个单独的 Coroutine，每个状态一个 Coroutine。Coroutine 将无限期且专一地循环，只要状态处于活动状态，定义该状态下敌人的所有行为。状态机的主要任务是选择并启动正确的状态，以满足正确的条件。让我们首先创建
    `Idle` 状态——敌人的默认或正常状态。
- en: Creating the Idle state
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建空闲状态
- en: 'The enemy object begins in the `Idle` state (a "doing nothing" state), which
    is primarily transitional. In this state, the enemies stand where they are, playing
    the idle animation. The state is entered once at scene startup, but we''ll also
    return to it when exiting some other states, as an intermediary step before moving
    onto a new state. Effectively, in this state, the enemy should always play the
    idle animation just once and then leave the state when the animation is completed.
    The enemy can further move to the `Patrol` state automatically, where they begin
    searching the scene for the player. This involves a two-step process. First, we''ll
    need to start playing the idle animation as the `Idle` state begins. Second, we''ll
    need to be notified when the idle animation has completed, to initiate a change
    to the `Patrol` state. Refer to the following code sample 7-3 for the `Idle` state:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 敌对对象开始于 `Idle` 状态（一个“无所事事”的状态），这主要是过渡性的。在这个状态下，敌人站在原地，播放空闲动画。状态在场景启动时只进入一次，但当我们退出其他状态时，我们也会返回到它，作为进入新状态的前一个中间步骤。实际上，在这个状态下，敌人应该只播放空闲动画一次，然后在动画完成后离开状态。敌人还可以自动移动到
    `Patrol` 状态，在那里他们开始搜索场景中的玩家。这涉及两个步骤。首先，我们需要在 `Idle` 状态开始时开始播放空闲动画。其次，我们需要在空闲动画完成时得到通知，以启动对
    `Patrol` 状态的改变。请参阅以下代码示例 7-3 中的 `Idle` 状态：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following are the comments for code sample 7-3:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 7-3 的注释：
- en: '**Line 03**: `State_Idle` is coded as a Coroutine. For more information on
    Coroutines, see the online Unity documentation at [http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html).
    In short, a Coroutine works like an asynchronous function (as a code block that
    runs in the background, parallel to other functions). For this reason, the infinite
    loop in line 15 will not cause a crash because a Coroutine runs like a separate
    thread. Coroutines always return type `IEnumerator` and always feature a yield
    statement somewhere within their body.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第03行**: `State_Idle` 被编码为一个 Coroutine。有关协程的更多信息，请参阅 Unity 在线文档[http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html)。简而言之，Coroutine
    的工作方式类似于异步函数（作为一个在后台运行的代码块，与其他函数并行）。因此，第 15 行中的无限循环不会导致崩溃，因为 Coroutine 的工作方式就像一个单独的线程。Coroutine
    总是返回类型 `IEnumerator`，并且它们体内总是包含一个 `yield` 语句。'
- en: '**Line 09**: The animator `SetTrigger` function is called in this line; it
    passes the hash code for the string `Idle` as an argument to set the `Idle` trigger
    in the Mecanim graph, initiating a playback of the idle animation. This links
    the C# FSM to the Mecanim FSM. Notice that in line 12, the `Stop` function is
    called for the `NavMeshAgent` component to stop any movement that the object might
    have been performing. This is because while the idle animation is playing, the
    enemy should not be moving.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第09行**: 在这一行调用了动画器 `SetTrigger` 函数；它将字符串 `Idle` 的哈希码作为参数传递，以在 Mecanim 图中设置
    `Idle` 触发器，从而开始播放空闲动画。这将 C# FSM 连接到 Mecanim FSM。注意，在第 12 行，调用了 `Stop` 函数来停止 `NavMeshAgent`
    组件可能正在执行的所有动作。这是因为当空闲动画播放时，敌人不应该移动。'
- en: '**Line 15**: Here, the `State_Idle` function enters an infinite loop; that
    is, it''ll loop frame by frame as long as the enemy is in an `Idle` state. While
    the `Idle` state is active, everything within the loop executes every frame that
    allows the object to update and change its behavior over time.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第15行**: 在这里，`State_Idle` 函数进入了一个无限循环；也就是说，只要敌人处于 `Idle` 状态，它就会逐帧循环。当 `Idle`
    状态处于活动状态时，循环内的所有内容都会在每一帧执行，允许对象更新并随时间改变其行为。'
- en: '**Line 18**: One exit condition for the `Idle` state, other than waiting for
    the idle animation to complete, is if the player is seen in the interim. Player
    visibility is determined by the Boolean variable `CanSeePlayer` (the details of
    line of sight are considered later). If `CanSeePlayer` is `true`, the `Chase`
    state is activated using the `StartCoroutine` function, and the `Idle` state is
    terminated with a call to yield break.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第18行**: 除了等待空闲动画完成之外，`Idle` 状态的一个退出条件是如果在期间看到了玩家。玩家可见性由布尔变量 `CanSeePlayer`（视线的细节将在稍后考虑）确定。如果
    `CanSeePlayer` 为 `true`，则使用 `StartCoroutine` 函数激活 `Chase` 状态，并通过调用 `yield break`
    终止 `Idle` 状态。'
- en: 'The `Idle` state, as implemented so far, loops infinitely and never changes
    to another state unless the player is seen. However, the `Idle` state should only
    be temporary; the idle animation should play once and then notify us of its completion.
    To achieve this playback notification, we can use Animation Events. To configure
    this, select the **Constructor** character mesh in the **Project** panel and open
    the **Animation** tab to examine the idle animation in the Object Inspector. From
    here, open the **Events** tab, as shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 目前实现的`Idle`状态会无限循环，除非看到玩家，否则不会改变到其他状态。然而，`Idle`状态应该是临时的；空闲动画应该播放一次，然后通知我们其完成。为了实现这种回放通知，我们可以使用动画事件。为此，在**项目**面板中选择**构造器**角色网格，打开**动画**选项卡，在对象检查器中检查空闲动画。从这里，打开**事件**选项卡，如下面的截图所示：
- en: '![Creating the Idle state](img/0655OT_07_21.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![创建空闲状态](img/0655OT_07_21.jpg)'
- en: Expanding the Events tab in the Object Inspector
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象检查器中展开事件选项卡
- en: 'Then, double-click on the animation timeline at time **1** (at the end) to
    insert a function call at that time. This sends a message to the enemy object
    when the animation completes, as shown in the following screenshot. For this purpose,
    I''ve coded a method `OnIdleAnimCompleted` inside the `AI_Enemy` class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在时间**1**（在末尾）处双击动画时间轴，在该时间插入一个函数调用。当动画完成时，这会向敌人对象发送消息，如下面的截图所示。为此，我在`AI_Enemy`类中编写了一个名为`OnIdleAnimCompleted`的方法：
- en: '![Creating the Idle state](img/0655OT_07_22.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![创建空闲状态](img/0655OT_07_22.jpg)'
- en: Calling a function at animation end
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画结束时调用函数
- en: 'The function `OnIdleAnimCompleted` is called automatically by Unity when the
    idle animation completes. The following code sample 7-4 shows how this method
    is implemented:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当空闲动画完成时，Unity会自动调用`OnIdleAnimCompleted`函数。以下代码示例7-4显示了此方法的实现方式：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating the Patrol state
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建巡逻状态
- en: In the `Patrol` state, the enemy should wander the environment and look for
    the player. This state can be entered from the `Idle` state, after the idle animation
    is completed, and also from the `Chase` state, if the enemy loses sight of the
    player during a chase. Patrol involves a looping logic. Specifically, the enemy
    should pick a random destination somewhere on the navigation mesh and then travel
    to that destination. When the destination is reached, the process should repeat
    and so on. The only condition that causes the enemy to leave this state is a sighting
    of the player, which demands a `Chase` state.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Patrol`状态中，敌人应该在环境中徘徊并寻找玩家。此状态可以从`Idle`状态进入，在空闲动画完成后，也可以从`Chase`状态进入，如果敌人在追逐过程中失去对玩家的视线。巡逻涉及循环逻辑。具体来说，敌人应该在导航网格上的某个随机目的地选择一个目的地，然后前往该目的地。当到达目的地时，该过程应该重复，依此类推。唯一导致敌人离开此状态的条件是看到玩家，这要求进入`Chase`状态。
- en: 'Though simple to explain, this state relies on two more complex issues: first,
    a random location must be selected and second, a player visibility check should
    be performed. First, let''s consider the random location selection.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然解释起来很简单，但此状态依赖于两个更复杂的问题：首先，必须选择一个随机位置，其次，应执行玩家可见性检查。首先，让我们考虑随机位置选择。
- en: 'In the **Scene** tab, I created a collection of waypoints (empty game objects)
    that are tagged **Waypoint** and do nothing but mark locations on the `NavMesh`
    floor. Together, these represent all the possible locations to which an enemy
    could travel during a patrol. The enemy, therefore, needs to randomly select one
    of these destinations, as shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在**场景**选项卡中，我创建了一个由标记为**航点**的空游戏对象组成的集合。这些对象除了在`NavMesh`地板上标记位置外，什么都不做。这些共同代表了一个敌人巡逻期间可能前往的所有可能位置。因此，敌人需要随机选择这些目的地之一，如下所示：
- en: '![Creating the Patrol state](img/0655OT_07_23.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![创建巡逻状态](img/0655OT_07_23.jpg)'
- en: Creating Waypoint destinations in the Scene tab
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在**场景**选项卡中创建航点目的地
- en: 'To implement the destination selection for a `Patrol` state, the `Awake` function
    of `AI_Enemy` will first retrieve a list of all waypoints in the scene to be used
    later. We can do this using `Linq`, as shown in the following code sample 7-5\.
    This example code retrieves a static array of all transforms for waypoints in
    the scene, in a private variable named `Waypoints`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`Patrol`状态的目的地选择，`AI_Enemy`的`Awake`函数将首先检索场景中所有要使用的航点列表。我们可以使用`Linq`来完成此操作，如下面的代码示例7-5所示。此示例代码检索场景中所有航点的静态变换数组，在名为`Waypoints`的私有变量中：
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Having retrieved a list of all waypoints, the `Patrol` state can be coded,
    as shown in the following code sample 7-6, which regularly selects waypoints as
    move new targets:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索到所有航点列表后，可以编写 `Patrol` 状态，如下面的代码示例 7-6 所示，该示例定期选择航点作为新的移动目标：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following are the comments for code sample 7-6:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例 7-6 的注释：
- en: '**Line 12**: Here, the `Random.Range` function selects a random destination
    from the `Waypoints` array. This is passed as a destination argument to the `SetDestination`
    function of the `NavMeshAgent` component that sends the enemy to the destination.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 12**: 在这里，`Random.Range` 函数从 `Waypoints` 数组中随机选择一个目标。这个目标作为参数传递给 `NavMeshAgent`
    组件的 `SetDestination` 函数，该函数将敌人发送到目标位置。'
- en: '**Line 28**: The function `Vector3.Distance` is used to determine whether the
    agent has reached the destination. This does not check for equality between the
    enemy position and destination position, because floating-point inaccuracy means
    we cannot guarantee that the two will ever be the same. Instead, it checks whether
    the enemy has come within a specified distance of the destination (`DistEps`),
    classifying that as having arrived.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 28**: 使用 `Vector3.Distance` 函数来确定代理是否到达目的地。这并不检查敌人位置和目的地位置之间的相等性，因为浮点数的不精确性意味着我们无法保证它们永远相同。相反，它检查敌人是否已经到达目的地指定距离内（`DistEps`），将其分类为已到达。'
- en: '**Line 32**: If the destination is reached, the enemy would return to `Idle`.
    After waiting for one cycle of the idle animation, the enemy would again enter
    into the `Patrol` state.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 32**: 如果达到目标，敌人将返回到 `Idle` 状态。在等待空闲动画的一个周期后，敌人将再次进入 `Patrol` 状态。'
- en: '**Line 21**: Again, the `Patrol` state depends on whether the player is visible
    to the enemy. If so, they enter the `Chase` state.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 21**: 再次，`Patrol` 状态取决于玩家是否对敌人可见。如果是，他们进入 `Chase` 状态。'
- en: 'The Boolean variable `CanSeePlayer` indicates, for any frame, whether the player
    is currently visible to the enemy. This variable is updated on each frame. The
    process for this begins inside the `Update` function, as shown in the following
    code sample 7-7:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔变量 `CanSeePlayer` 表示，对于任何一帧，玩家是否当前对敌人可见。这个变量在每一帧都会更新。这个过程从 `Update` 函数内部开始，如下面的代码示例
    7-7 所示：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The key question for the `Update` function is whether the player is inside
    the box collider attached to the enemy; this box collider represents the enemy''s
    view or range. If the player is inside that box, the player could possibly be
    visible to the enemy. In this case, further checks are required to be sure. This
    is where the `HaveLineSightToPlayer` function is essential. This function returns
    a Boolean (`true`/`false`) value that indicates whether the player is visible
    to the enemy, as shown in the following code sample 7-8:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update` 函数的关键问题是玩家是否在附加到敌人的盒子碰撞体内；这个盒子碰撞体代表敌人的视野或范围。如果玩家在这个盒子内，玩家可能对敌人可见。在这种情况下，需要进一步的检查以确保这一点。这就是
    `HaveLineSightToPlayer` 函数至关重要的地方。这个函数返回一个布尔值（`true`/`false`），表示玩家是否对敌人可见，如下面的代码示例
    7-8 所示：'
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we saw in the earlier chapters, visibility is determined by a two-stage process.
    First, the angle between the enemy look at vector and the normalized vector, which
    points from the enemy to the player, decides the visibility. If the angle is less
    than the enemy's field-of-view angle, then the player would be in front of the
    enemy and they would be seen, provided no obstacles, such as walls, lie between
    the enemy and the player. The second test, performed by `Physics.Linecast`, determines
    whether an unbroken line can be drawn between the enemy and the player. If it
    can, then no obstacle would exist between them and the player would be seen.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，可见性是通过两个阶段的过程确定的。首先，敌人视线向量与指向玩家方向的归一化向量之间的角度决定了可见性。如果角度小于敌人的视野角度，那么玩家就会在敌人前方，并且会被看到，前提是没有障碍物，例如墙壁，位于敌人和玩家之间。第二个测试由
    `Physics.Linecast` 执行，确定是否可以在敌人和玩家之间画一条不间断的直线。如果可以，那么他们之间就没有障碍物，玩家就会被看到。
- en: Creating the Chase state
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `Chase` 状态
- en: 'If the player is seen by the enemy and is not within attacking distance, the
    enemy would run to attack the player. This state, in which the enemy runs towards
    the player with hostile intent, is the `Chase` state. There are two main exit
    conditions for this state. If the enemy reaches attacking distance, they should
    change from the `Chase` state to the `Attack` state. In contrast, if the player
    disappears from sight, the enemy should continue to chase as best as they can
    for a while and then give up the chase if, after an interval, the player still
    cannot be sighted. Refer to the following code sample 7-9:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果敌人看到玩家但不在攻击距离内，敌人会跑向玩家进行攻击。这种敌人带着敌意跑向玩家的状态就是`Chase`状态。这个状态有两个主要的退出条件。如果敌人到达攻击距离，他们应该从`Chase`状态变为`Attack`状态。相反，如果玩家从视线中消失，敌人应该尽可能地继续追逐一段时间，然后在一段时间后如果玩家仍然没有被看到，就放弃追逐。请参考以下代码示例7-9：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following are the comments for code sample 7-9:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例7-9的注释：
- en: '**Lines 17-48**: During this phase, the `State` loop determines that the player
    visibility has been lost. When this happens, the enemy will continue to chase
    the player for a period of `ChaseTimeOut`. After this time elapses, the enemy
    checks for player visibility again. If the player is sighted at that time, the
    chase resumes as it did earlier. Otherwise, the enemy changes to the `Idle` state,
    ready to begin a new patrol in search of the player again.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第17-48行**: 在这个阶段，`State`循环确定玩家已经失去可见性。当这种情况发生时，敌人将继续追逐玩家一段时间，这段时间为`ChaseTimeOut`。在这段时间过去后，敌人再次检查玩家的可见性。如果在那时看到玩家，追逐将像之前一样继续。否则，敌人将变为`Idle`状态，准备再次开始巡逻寻找玩家。'
- en: '**Lines 51-59**: Here, the `Chase` state checks whether the enemy has come
    within the attack range (`DistEps`). If so, the FSM would enter `State_Attack`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第51-59行**: 在这里，`Chase`状态检查敌人是否进入了攻击范围（`DistEps`）。如果是这样，有限状态机（FSM）将进入`State_Attack`状态。'
- en: Creating the Attack state
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建攻击状态
- en: 'In the `Attack` state, the enemy continually attacks the player as long as
    they''re visible. After an attack, the enemy must recover before launching a new
    attack. The only exit condition for this state is losing sight of the player.
    When this happens, the enemy returns to the `Chase` state and, from there, they
    either go back to the attack state or into `Idle`, depending on whether the player
    has been found, as shown in the following code sample 7-10:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Attack`状态中，只要敌人可见，敌人就会不断地攻击玩家。攻击后，敌人必须恢复才能发起新的攻击。这个状态唯一的退出条件是失去对玩家的视线。当这种情况发生时，敌人将返回`Chase`状态，然后根据玩家是否被找到，他们要么回到攻击状态，要么进入`Idle`状态，如下面的代码示例7-10所示：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating the Seek-Health (or flee) state
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建寻找健康（或逃跑）状态
- en: 'The `Seek-Health` state occurs when the enemy runs low on health and can restore
    it by collecting a medikit. This state is unlike most others, in that, it can
    be reached or entered from any state. The entering of this state doesn''t depend
    on its relationship to others, but only on the player''s health. Specifically,
    this state should be entered when the enemy''s health is reduced beyond a minimum
    floor. As a result of this configuration, be sure to hook up the `Seek-Health`
    animation state in the Mecanim graph to the **Any State** node that allows the
    run animation to be triggered in any state, as shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人健康值降低到一定程度以下并可以通过收集医疗包来恢复时，就会进入`Seek-Health`状态。这个状态与大多数其他状态不同，因为它可以从任何状态到达或进入。进入这个状态不依赖于它与其他状态的关系，而只依赖于玩家的健康。具体来说，当敌人的健康值降低到最低阈值以下时，应该进入这个状态。由于这种配置，请确保将`Seek-Health`动画状态在Mecanim图中连接到允许在任何状态下触发跑步动画的**Any
    State**节点，如下所示：
- en: '![Creating the Seek-Health (or flee) state](img/0655OT_07_24.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![创建寻找健康（或逃跑）状态](img/0655OT_07_24.jpg)'
- en: The Seek-Health state can be accessed from Any State
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seek-Health`状态可以从任何状态访问'
- en: 'Each enemy maintains a `Health` variable; this variable is adjusted either
    up or down, depending on whether the enemy finds a medikit or is attacked. The
    change occurs inside the method `ChangeHealth`, and this is where we can determine
    whether a `SeekHealth` state must be initiated. The `ChangeHealth` function is
    public; it allows `SendMessage` and `BroadcastMessage` to trigger it as an event,
    if required, as shown in the following code sample 7-11:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个敌人都有一个`Health`变量；这个变量会根据敌人是否找到医疗包或被攻击而上下调整。这种变化发生在`ChangeHealth`方法内部，这也是我们确定是否必须启动`SeekHealth`状态的地方。`ChangeHealth`函数是公开的；它允许`SendMessage`和`BroadcastMessage`在需要时将其作为事件触发，如下面的代码示例7-11所示：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `State_SeekHealth` method can be coded, as shown in the following code
    sample 7-12:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像以下代码示例7-12所示那样编写`State_SeekHealth`方法：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following are the comments for code sample 7-12:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例7-12的注释：
- en: '**Line 17**: The `Health-Seek` state begins by finding the nearest medikit
    in the scene and uses it for the agent destination. This is, in a sense, cheating,
    because (of course) without remote viewing powers, the enemy should not be able
    to know where the nearest medikit is. However, remember that what matters is not
    what the enemy really knows but how it appears to the gamer. If the gamer doesn''t
    know about this logic and cannot learn about it from appearances, then it would
    be of no significance. Also note that it''s possible for the player or another
    enemy to collect the medikit before the enemy arrives at the destination. For
    this reason, on each frame, the enemy must determine whether the destination medikit
    is still valid, and if not, they must pick the next, nearest one.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 17**：`Health-Seek`状态首先在场景中找到最近的急救包，并将其用作代理的目标。这在某种程度上是作弊，因为（当然）没有远程观察能力，敌人不应该能够知道最近的急救包在哪里。然而，记住重要的是敌人实际上知道什么，而不是它对玩家看起来如何。如果玩家不知道这个逻辑，并且无法从外观上了解它，那么这就没有任何意义。此外，还请注意，玩家或另一个敌人可能在敌人到达目的地之前收集急救包。因此，在每个帧上，敌人必须确定目标急救包是否仍然有效，如果不是，他们必须选择下一个最近的急救包。'
- en: '**Line 23**: If there is no medikit available or the health has been restored
    to safe limits, the enemy would return to the `Idle` state.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行 23**：如果没有急救包可用或健康值已恢复到安全极限，敌人将返回到`空闲`状态。'
- en: 'The `SeekHealth` state demands that we find and retrieve a reference to the
    nearest medikit in the scene. This is achieved using a `GetNearestHealthRestore`
    method, as shown in the following code sample 7-13:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeekHealth`状态要求我们找到并检索场景中最近的急救包的引用。这是通过使用`GetNearestHealthRestore`方法实现的，如下面的代码示例7-13所示：'
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'The complete AI project created in this chapter can be found in the book''s
    companion files (code bundle) in the `ai` folder of this chapter. I recommend
    that you open it and then test it out. Using the first-person controller, the
    player can navigate the level, avoid enemies, and also attack when enemies are
    in range using the Space bar, as shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本章创建的完整AI项目可以在本书的配套文件（代码包）中找到，位于本章的`ai`文件夹中。我建议您打开它并进行测试。使用第一人称控制器，玩家可以导航关卡，避开敌人，并且当敌人进入射程时可以使用空格键进行攻击，如下所示：
- en: '![Summary](img/0655OT_07_25.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![总结](img/0655OT_07_25.jpg)'
- en: Testing the AI_Enemy class
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 测试AI_Enemy类
- en: There are, nonetheless, many ways in which the project can be improved further,
    for example, by adding multiple enemy types as well as varied strategies for each
    type, from taking cover to playing dead, and so on. However, nonetheless, we've
    come a long way and have developed Artificial Intelligence that relies on both
    a C# FSM as well as on a Mecanim FSM for animation playback.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，还有很多方法可以进一步改进项目，例如，通过添加多种敌人类型以及每种类型的多种策略，从躲避到装死，等等。然而，尽管如此，我们已经走了很长的路，并开发了依赖于C#
    FSM以及Mecanim FSM进行动画播放的人工智能。
- en: In the next chapter, we'll leap out of the world of AI and into the world of
    editor customization to make game development smoother!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将跳出AI的世界，进入编辑器自定义的世界，以使游戏开发更加顺畅！
