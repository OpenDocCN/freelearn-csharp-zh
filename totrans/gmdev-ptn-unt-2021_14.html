<html><head></head><body>
        

                            
                    Using the Decorator to Implement a Weapon System
                
            
            
                
<p class="mce-root">In this chapter, we are going to build a customizable weapon system. Throughout the game, the player will be able to upgrade its bike's primary weapon by purchasing attachments that will augment specific properties, such as range and strength. The primary weapon is mounted on the front of the bike and has two expansion slots for attachments that the player can use to build various combinations. To build this system, we are going to use the Decorator pattern. It should not be a surprise because its name implies its use, as we will see further in the chapter.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The basic principles behind the Decorator pattern</li>
<li>The implementation of a weapon system with attachments</li>
</ul>
<h1 id="uuid-9cf36e12-27cd-4af2-b706-c557b068ca60">Technical requirements</h1>
<p class="mce-root">You will need to have a basic understanding of Unity and C#.</p>
<p class="mce-root">We will be using the following Unity engine and C# language concepts:</p>
<ul>
<li>Constructors</li>
<li>ScriptableObjects</li>
</ul>
<p>If you are unfamiliar with these concepts, please review <a href="c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml">Chapter 3</a>, <em>A Short Primer to Programming in Unity</em>.</p>
<p>The code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter12">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter12</a>.<a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition"/></p>
<p>Check out the following video to see the code in action:<a href="https://bit.ly/3r9rvJD"> https://bit.ly/3r9rvJD</a>.</p>
<p>We often use <strong>ScriptableObjects</strong> in the code examples in this book because we want to establish an authoring workflow for our designers to create new weapon attachments or configure existing ones without modifying a single line of code. It's good practice to make your systems, ingredients, and mechanics easy to configure for non-programmers.</p>
<h1 id="uuid-b69b6978-feb9-414b-ba89-c2be92f6fe32">Understanding the Decorator pattern</h1>
<p>In short, the Decorator is a pattern that permits the addition of new functionalities to an existing object without altering it. And this is made possible by creating a decorator class that wraps the original class. And with this mechanism, we easily attach but also detach new behaviors to an object.</p>
<p class="mce-root">Let's review the following diagram to visualize the Decorator's structure before diving deeply into the subject matter:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/06a1b37f-1842-42c4-a927-a15c3e7f6eaf.png" style="width:38.17em;height:27.75em;"/></p>
<p>Figure 12.1 – UML diagram of the Decorator pattern</p>
<p>The <kbd>IWeapon</kbd> interface establishes an implementation contract that will maintain a consistent method signature between the decorated object and its decorators. <kbd>WeaponDecorator</kbd> wraps the target object, and the concrete decorator classes (<kbd>WithGrip</kbd> and <kbd>WithStabilizer</kbd>) decorate it by enhancing or overriding its behaviors.</p>
<p class="mce-root">The method signatures and the overall structure of the <em>decorated</em> object are not modified during the process, just its behaviors or property values. Thus, we can easily remove decorations from an object and return it to its initial form.</p>
<p class="mce-root">Most textbook examples of this pattern are heavily dependent on the class constructor. However, native Unity API base classes, such as <kbd>MonoBehaviour</kbd> and <kbd>ScriptableObject</kbd>, don't use the concept of a constructor to initialize an instance of an object. Instead, in the case of MonoBehaviours, the engine takes care of initializing the classes that are attached to GameObjects. And any initialization code is expected to be implemented in the <kbd>Awake()</kbd> or <kbd>Start()</kbd> callbacks.</p>
<p class="mce-root">Therefore, we are challenged to find a way to adapt the Decorator pattern so that it will use core Unity API features while not losing its primary benefits.</p>
<h2 id="uuid-800ff329-1978-4bb4-9fb0-27d8c1e64936">Benefits and drawbacks of the Decorator pattern</h2>
<p>The following are some of the benefits of the Decorator pattern:</p>
<ul>
<li><strong>Alternative to subclassing</strong>: Inheritance is a static process. Unlike the Decorator pattern, it doesn't permit extending an existing object's behavior at runtime. You can only replace an instance with another with the same parent class that has the desired behavior. Therefore, the Decorator pattern is a more dynamic alternative to subclassing and overcomes the limits of inheritance.</li>
<li><strong>Runtime dynamics</strong>: The Decorator pattern permits us to add functionality to an object at runtime by attaching decorators to it. But this also means that the reverse is possible, and you can restore an object back to its original form by removing its decorators. </li>
</ul>
<p>The following are some of the potential drawbacks of the Decorator pattern:</p>
<ul>
<li><strong>Relationship complexity</strong>: Keeping track of the chain of initialization and the relationships between decorators can become very complicated if there are multiple layers of decorators around an object.</li>
</ul>
<ul>
<li><strong>Code complexity</strong>: Depending on how you implement the Decorator pattern, it can add complexity to your code base as you might need to maintain several little decorator classes. But when and how this becomes an actual drawback is very contextual and not a constant. In the upcoming code example that we will review, this is not an issue as each decorator is a <kbd>ScriptableObject</kbd> instance that we save as a configurable asset.</li>
</ul>
<p>The Decorator pattern is a part of the structural design pattern family; some of its members include the Adapter, Bridge, Façade, and Flyweight patterns.</p>
<h2 id="uuid-8a76f31f-a980-4ea9-a465-a8c9907d520c">When to use the Decorator pattern</h2>
<p>In this chapter, we are implementing a weapon system with attachments. We have a couple of specifications to consider, such as the following:</p>
<ul>
<li>We need to be able to attach multiple attachments to a weapon.</li>
<li>We need to be able to add and remove them at runtime.</li>
</ul>
<p>The Decorator pattern offers us a way to fulfill these two core requirements. Therefore, it's a pattern to consider when implementing a system in which we need to support the ability to add and remove behaviors to an individual object in a dynamic manner. </p>
<p>For instance, if we are assigned to work on a <strong>CCG</strong> (<strong>collectible card game</strong>), we might have to implement a mechanism in which the player can augment a base card's powers with artifact cards stacked on top of each other. Another use case is imagining having to implement a wardrobe system in which players can decorate their armor with accessories to buff specific stats.</p>
<p>In both cases, using the Decorator pattern could be a good starting point to build these types of mechanics and systems. Now that we have a basic understanding of the Decorator pattern, we will review the design of our weapon attachment system before writing code.</p>
<h1 id="uuid-885e0fb7-8571-4c23-8a49-85b39e767fab">Designing a weapon system</h1>
<p class="mce-root">By default, every bike model in our game comes equipped with a front-mounted gun that fires laser beams. The player can use this weapon to destroy obstacles that might be in the way, and very skilled players can shoot at flying drones while doing wheelies. The player can also purchase various attachments that boost the basic stats of the bike's weapon, as illustrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/41a64774-90d0-4763-a64b-a09aecd8f27a.png" style="width:20.33em;height:22.92em;"/></p>
<p>Figure 12.2 – Diagram of the weapon attachment system</p>
<p>Let's review a shortlist of potential attachments that the player could buy:</p>
<ul>
<li><strong>Injector</strong>: A plasma injector that amplifies the weapon's damage capacity.</li>
<li><strong>Stabilizer</strong>: An attachment that reduces vibrations caused when the bike hits its top speed. It stabilizes the weapon's shooting mechanism and expands its range.</li>
<li><strong>Cooler</strong>: A water-cooling system that attaches itself to the weapon's firing mechanism. It enhances the rate of fire and reduces the cool-down duration.</li>
</ul>
<p>These examples are high-level concepts of potential attachment variations. Each of these attachments modifies or, in other words, "decorates" specific properties of the weapon.</p>
<p>Another requirement to keep in mind while implementing our system is that our weapon will have a maximum of two expansion slots for attachments. The player must be able to add and remove them dynamically when adjusting the settings on their vehicle.</p>
<p>Now that we have a good overview of the requirements of the design of our system, it's time to translate this into code, which we will do in the next section.</p>
<h1 id="uuid-bba29745-4da8-463f-b390-6b48827852a6">Implementing a weapon system</h1>
<p>In this section, we are going to implement the core classes of our weapon system. However, please note that we are not going to write the weapon's core behaviors for reasons of brevity. We want to keep the focus on understanding how the Decorator pattern works. But if you wish to review a more advanced version of this code example, check out the <kbd>FPP</kbd> folder in this book's GitHub repo. The link can be found in the <em>Technical requirements</em> section.</p>
<h2 id="uuid-17339506-265d-4000-ba97-3f61624de480">Implementing the weapon system</h2>
<p class="mce-root">Many steps need to be performed as we have a lot of code to review together:</p>
<ol>
<li>To start, we are going to implement the <kbd>BikeWeapon</kbd> class. Because it's quite long, we will split it up into three segments:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections;<br/><br/>namespace Chapter.Decorator<br/>{<br/>    public class BikeWeapon : MonoBehaviour<br/>    {<br/>        public WeaponConfig weaponConfig;<br/>        public WeaponAttachment mainAttachment;<br/>        public WeaponAttachment secondaryAttachment;<br/><br/>        private bool _isFiring;<br/>        private IWeapon _weapon;<br/>        private bool _isDecorated;<br/><br/>        void Start() <br/>        {<br/>            _weapon = new Weapon(weaponConfig);<br/>        }</pre>
<p style="padding-left: 60px">The first segment is the initialization code. Note that we are setting the weapon's configuration at the <kbd>Start()</kbd>.</p>
<p style="padding-left: 60px">For the second segment of the class, it is just <kbd>GUI</kbd> labels that will help us with debugging:</p>
<pre style="padding-left: 60px">void OnGUI()<br/>{<br/>    GUI.color = Color.green;<br/><br/>    GUI.Label (<br/>        new Rect (5, 50, 150, 100), <br/>        "Range: "+ _weapon.Range);<br/><br/>    GUI.Label (<br/>        new Rect (5, 70, 150, 100), <br/>        "Strength: "+ _weapon.Strength);<br/><br/>    GUI.Label (<br/>        new Rect (5, 90, 150, 100), <br/>        "Cooldown: "+ _weapon.Cooldown);<br/><br/>    GUI.Label (<br/>        new Rect (5, 110, 150, 100), <br/>        "Firing Rate: " + _weapon.Rate);<br/><br/>    GUI.Label (<br/>        new Rect (5, 130, 150, 100), <br/>        "Weapon Firing: " + _isFiring);<br/><br/>    if (mainAttachment &amp;&amp; _isDecorated)<br/>        GUI.Label (<br/>            new Rect (5, 150, 150, 100), <br/>            "Main Attachment: " + mainAttachment.name);<br/><br/>    if (secondaryAttachment &amp;&amp; _isDecorated)<br/>        GUI.Label (<br/>            new Rect (5, 170, 200, 100), <br/>            "Secondary Attachment: " + secondaryAttachment.name);<br/>}</pre>
<p style="padding-left: 60px">However, it is in the last segment that things start to get interesting:</p>
<pre style="padding-left: 60px">        public void ToggleFire() {<br/>            _isFiring = !_isFiring;<br/><br/>            if (_isFiring)<br/>                StartCoroutine(FireWeapon());<br/>        }<br/><br/>        IEnumerator FireWeapon() {<br/>            float firingRate = 1.0f / _weapon.Rate;<br/><br/>            while (_isFiring) {<br/>                yield return new WaitForSeconds(firingRate);<br/>                Debug.Log("fire");<br/>            }<br/>        }<br/><br/>        public void Reset() {<br/>            _weapon = new Weapon(weaponConfig);<br/>            _isDecorated = !_isDecorated;<br/>        }<br/><br/>        public void Decorate() {<br/>            if (mainAttachment &amp;&amp; !secondaryAttachment)<br/>                _weapon = <br/>                    new WeaponDecorator(_weapon, mainAttachment);<br/><br/>            if (mainAttachment &amp;&amp; secondaryAttachment)<br/>                _weapon = <br/>                    new WeaponDecorator(<br/>                        new WeaponDecorator(<br/>                            _weapon, mainAttachment), <br/>                                    secondaryAttachment);<br/><br/>            _isDecorated = !_isDecorated;<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The <kbd>Reset()</kbd> method resets the weapon to its initial configurations by initializing a new <kbd>Weapon</kbd> with its default weapon configurations. This is a quick and simple way to remove the attachments that we set in the <kbd>Decorate()</kbd> method. It's not always the best approach, but it works in the context of this example.</p>
<p style="padding-left: 60px" class="mce-root">However, <kbd>Decorate()</kbd> is where the magic happens, and the Decorator pattern mechanism is triggered. You might notice that we can stack attachments over one another by chaining them in the constructor, as we see here:</p>
<pre>            if (mainAttachment &amp;&amp; secondaryAttachment)<br/>                _weapon = <br/>                    new WeaponDecorator(<br/>                        new WeaponDecorator(<br/>                            _weapon, mainAttachment), <br/>                                    secondaryAttachment);</pre>
<p style="padding-left: 60px">That's a little trick that the Decorator and constructors permit us to do. How it works will be made more apparent when we start implementing the other classes.</p>
<ol start="2">
<li>The next class to implement is the <kbd>Weapon</kbd> class. Notice that it's not a <kbd>MonoBehaviour</kbd>. Therefore, we will initialize it with its constructor:</li>
</ol>
<pre style="padding-left: 60px">namespace Chapter.Decorator<br/>{<br/>    public class Weapon : IWeapon<br/>    { <br/>        public float Range<br/>        {<br/>            get { return _config.Range; }<br/>        }<br/><br/>        public float Rate<br/>        {<br/>            get { return _config.Rate; }<br/>        }<br/><br/>        public float Strength<br/>        {<br/>            get { return _config.Strength; }<br/>        }<br/><br/>        public float Cooldown<br/>        {<br/>            get { return _config.Cooldown; }<br/>        }<br/><br/>        private readonly WeaponConfig _config;<br/><br/>        public Weapon(WeaponConfig weaponConfig)<br/>        {<br/>            _config = weaponConfig;<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Unlike <kbd>BikeWeapon</kbd>, the <kbd>Weapon</kbd> class doesn't implement any behaviors; it's just a representation of the configurable properties of a weapon. This is the object we will decorate with attachments. In its constructor, we are passing an instance of a <kbd>WeaponConfig</kbd> object. As we are going to see further on, this is a <kbd>ScriptableObject</kbd>.</p>
<ol start="3">
<li>We need a common interface between the decorator class and the weapon, so we are going to implement one named <kbd>IWeapon</kbd>:</li>
</ol>
<pre style="padding-left: 60px">namespace Chapter.Decorator<br/>{<br/>    public interface IWeapon<br/>    {<br/>        float Range { get; }<br/>        float Duration { get; }<br/>        float Strength { get; }<br/>        float Cooldown { get; }<br/>    }<br/>}</pre>
<ol start="4">
<li>Now that we have a standard interface that defines a set of properties that we can decorate, we can implement a <kbd>WeaponDecorator</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">namespace Chapter.Decorator<br/>{<br/>    public class WeaponDecorator : IWeapon<br/>    {<br/>        private readonly IWeapon _decoratedWeapon;<br/>        private readonly WeaponAttachment _attachment;<br/><br/>        public WeaponDecorator(<br/>            IWeapon weapon, WeaponAttachment attachment) {<br/><br/>            _attachment = attachment;<br/>            _decoratedWeapon = weapon;<br/>        }<br/><br/>        public float Rate {<br/>            get { return _decoratedWeapon.Rate <br/>                         + _attachment.Rate; }<br/>        }<br/><br/>        public float Range {<br/>            get { return _decoratedWeapon.Range <br/>                         + _attachment.Range; }<br/>        }<br/><br/>        public float Strength {<br/>            get { return _decoratedWeapon.Strength <br/>                         + _attachment.Strength; }<br/>        }<br/><br/>        public float Cooldown<br/>        {<br/>            get { return _decoratedWeapon.Cooldown <br/>                         + _attachment.Cooldown; }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Notice how <kbd>WeaponDecorator</kbd> is wrapping itself around an instance of an object that shares a similar interface, in this case, the <kbd>IWeapon</kbd> interface. It never modifies directly the object that's its wrapping; it's only decorating its public properties with those of a <kbd>WeaponAttachment</kbd>.</p>
<p style="padding-left: 60px">Keep in mind that in our code example, we are just modifying the values of the properties of a weapon. And this fits with our design because the attachments don't alter the weapon's core mechanism. Instead, they just enhance specific properties through an attachment slot. </p>
<p style="padding-left: 60px" class="mce-root">One last detail to keep in mind is the fact that we are defining the weapon's behavior inside the <kbd>BikeWeapon</kbd> class and its behavior is determined by the properties set in an instance of a <kbd>Weapon</kbd> object. Therefore, by decorating the <kbd>Weapon</kbd> object, we are modifying how the bike weapon behaves.</p>
<ol start="5">
<li>The following step is where we are starting to deviate from a traditional implementation of the Decorator pattern. Instead of defining individual concrete decorator classes, we are going to implement a <kbd>ScriptableObject</kbd> named <kbd>WeaponConfig</kbd>. This approach will permit us to author separate attachments and configure their properties through the inspector. Then, we will use these attachment assets to decorate the weapon, as we can see here:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.Decorator<br/>{<br/>    [CreateAssetMenu(fileName = "NewWeaponAttachment", <br/>        menuName = "Weapon/Attachment", order = 1)]<br/>    public class WeaponAttachment : ScriptableObject, IWeapon <br/>    {<br/>        [Range(0, 50)]<br/>        [Tooltip("Increase rate of firing per second")]<br/>        [SerializeField] public float rate;<br/><br/>        [Range(0, 50)]<br/>        [Tooltip("Increase weapon range")]<br/>        [SerializeField] float range;<br/><br/>        [Range(0, 100)]<br/>        [Tooltip("Increase weapon strength")]<br/>        [SerializeField] public float strength;<br/><br/>        [Range(0, -5)]<br/>        [Tooltip("Reduce cooldown duration")]<br/>        [SerializeField] public float cooldown;<br/><br/>        public string attachmentName;<br/>        public GameObject attachmentPrefab;<br/>        public string attachmentDescription;<br/><br/>        public float Rate {<br/>            get { return rate;  }<br/>        }<br/><br/>        public float Range {<br/>            get { return range; }<br/>        }<br/><br/>        public float Strength {<br/>            get { return strength;  }<br/>        }<br/><br/>        public float Cooldown {<br/>            get { return cooldown; }<br/>        }<br/>    }<br/>}<br/></pre>
<p style="padding-left: 60px">It's important to note that <kbd>WeaponAttachment</kbd> implements the <kbd>IWeapon</kbd> interface. This keeps it consistent with <kbd>WeaponDecorator</kbd> and <kbd>Weapon</kbd> classes as all three of them share the same interface.</p>
<ol start="6">
<li>And for our last step, we are going to implement the <kbd>ScriptableObject</kbd> class named <kbd>WeaponConfig</kbd>. We are using to it create various configurations for our <kbd>Weapon</kbd> object that we can then configure with attachments:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.Decorator<br/>{<br/>    [CreateAssetMenu(fileName = "NewWeaponConfig", <br/>        menuName = "Weapon/Config", order = 1)]<br/>    public class WeaponConfig : ScriptableObject, IWeapon<br/>    {<br/>        [Range(0, 60)]<br/>        [Tooltip("Rate of firing per second")]<br/>        [SerializeField] private float rate;<br/><br/>        [Range(0, 50)]<br/>        [Tooltip("Weapon range")]<br/>        [SerializeField] private float range;<br/><br/>        [Range(0, 100)]<br/>        [Tooltip("Weapon strength")]<br/>        [SerializeField] private float strength;<br/><br/>        [Range(0, 5)]<br/>        [Tooltip("Cooldown duration")]<br/>        [SerializeField] private float cooldown;<br/><br/>        public string weaponName;<br/>        public GameObject weaponPrefab;<br/>        public string weaponDescription;<br/><br/>        public float Rate {<br/>            get { return rate;  }<br/>        }<br/><br/>        public float Range {<br/>            get { return range; }<br/>        }<br/><br/>        public float Strength {<br/>            get { return strength;  }<br/>        }<br/><br/>        public float Cooldown {<br/>            get { return cooldown; }<br/>        }<br/>    }<br/>}</pre>
<p>We now have all the key ingredients for our weapon attachment system, and it's time to test them inside the Unity engine.</p>
<h2 id="uuid-dbab32aa-2037-486a-be60-dbb25d1451e3">Testing the weapon system</h2>
<p>If you wish to test the code we just reviewed in your own instance of Unity, you need to follow these steps:</p>
<ol>
<li>Copy all the classes we just reviewed in your Unity project.</li>
<li>Create an empty Unity scene.</li>
</ol>
<ol start="3">
<li>Add a new GameObject to the scene.</li>
<li>Attach the following client script to the new GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Chapter.Decorator<br/>{<br/>    public class ClientDecorator : MonoBehaviour<br/>    {<br/>        private BikeWeapon _bikeWeapon;<br/>        private bool _isWeaponDecorated;<br/><br/>        void Start() {<br/>            _bikeWeapon = <br/>                (BikeWeapon) <br/>                FindObjectOfType(typeof(BikeWeapon));<br/>        }<br/><br/>        void OnGUI() <br/>        {<br/>            if (!_isWeaponDecorated) <br/>                if (GUILayout.Button("Decorate Weapon")) {<br/>                    _bikeWeapon.Decorate();<br/>                    _isWeaponDecorated = !_isWeaponDecorated;<br/>                }<br/><br/>            if (_isWeaponDecorated)<br/>                if (GUILayout.Button("Reset Weapon")) {<br/>                    _bikeWeapon.Reset();<br/>                    _isWeaponDecorated = !_isWeaponDecorated;<br/>                }<br/><br/>            if (GUILayout.Button("Toggle Fire"))<br/>                _bikeWeapon.ToggleFire();<br/>        }<br/>    }<br/>}</pre>
<ol start="5">
<li>Add to the new GameObject the <kbd>BikeWeapon</kbd> script we implemented in the previous section.</li>
<li>Under the <strong>Assets</strong> | <strong>Create</strong> | <strong>Weapon</strong> menu option, create a new <strong>Config</strong> and configure it as you wish.</li>
<li>Under the <strong>Assets</strong> | <strong>Create</strong> | <strong>Weapon</strong> menu option, create several <strong>Attachment</strong> variations with various configurations.</li>
</ol>
<ol start="8">
<li>You can now add <kbd>WeaponConfig</kbd> and <kbd>WeaponAttachment</kbd> assets to the <kbd>BikeWeapon</kbd> component properties in <kbd>Inspector</kbd>, as seen in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/eff3396f-8fe2-4109-9670-00320555bbe2.png" style="width:32.75em;height:49.33em;"/></p>
<p>Figure 12.3 – BikeWeapon component properties</p>
<p>When you start your scene, you should see the following buttons in the top-left corner of the screen, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/372aed4f-bb8d-4731-ad96-fd9b270cbec5.png" style="width:67.67em;height:41.75em;"/></p>
<p>Figure 12.4 – Screenshot of the code example in action inside Unity</p>
<p>You now test the weapon attachment system and adjust it as you wish by pressing the buttons and look at the weapon stats change as you modify the decorator's settings.</p>
<h2 id="uuid-3d1b28d4-6a50-4914-a1d7-440e457e7ec1">Reviewing the weapon system</h2>
<p>Our Decorator implementation is unorthodox because we are mixing native C# language features such as constructors while trying to utilize the best parts of the Unity API. By converting decorator classes into configurable <kbd>ScriptableObject</kbd> assets, we gain the ability to make our weapon attachments authorable and configurable by non-programmers. And under the hood, our attachment system is constructed on the foundation of a solid design pattern.</p>
<p class="mce-root">Therefore, we endeavored to strike a balance between usability and maintainability. However, as we are going to see in the next section, there are always alternative approaches.</p>
<p>Design patterns are guidelines, not commandments. Therefore, it's OK to experiment with patterns and test out different ways of implementing them. The code example in this chapter is experimental because it's not a traditional implementation of the Decorator pattern. But we encourage you, as the reader, to continue experimenting with the patterns showcased in this book and find new ways of using them in Unity.</p>
<h1 id="uuid-739b937f-2488-462d-b493-a90d5703d7c6">Reviewing alternative solutions</h1>
<p>In the context of the use case presented in this chapter, we could have implemented the weapon system without the Decorator pattern and with ScriptableObjects only. We could have iterated through a list of acquired weapon attachments and apply each of their properties to those of a <kbd>Weapon</kbd> class. We would lose the ability of chaining decorators, but our code will be more straightforward.</p>
<p class="mce-root">The core benefit of using the Decorator pattern in our case was that it gave us a structured and repeatable approach to implementing our system. Still, in consequence, we added additional complexity to our code base.</p>
<h1 id="uuid-9d35a0d4-ad4d-43aa-9bd3-1b8ce3c4d7bd">Summary</h1>
<p>In this chapter, we implemented a weapon attachment system that's authorable and configurable. Non-programmers will be able to create and adjust new attachments without writing a single line of code. Therefore, we can focus on building systems while designers work on balancing them. The Decorator pattern has proven itself to be a handy pattern for game development, and so it's a pattern to keep in our programmer's toolbox.</p>
<p>In the next chapter, we will explore the Spatial Partition pattern—a subject matter that's quite important to understand when building games with large maps.</p>


            

            
        
    </body></html>