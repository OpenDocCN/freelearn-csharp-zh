- en: Chapter 8. Building a Camera Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached the end of an era, learning the ins and outs of cross-platform
    development using the `Xamarin` platform.
  prefs: []
  type: TYPE_NORMAL
- en: In our last chapter, we are going to walk-through the final `Xamarin.Forms`
    project. We will introduce Effects, Triggers, and how they apply to UI elements.
    Then, we will build a `CustomRenderer` for each platform camera. The following
    topics will be covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expected knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Xamarin.Forms`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# threading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HashMap data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CustomRenderers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INotifiedPropertyChanged` framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Solution setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the `MainPageViewModel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the `INotifiedPropertyChanged` implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the custom UI objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the `FocusView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Xamarin.Forms` animations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Xamarin.Forms` compound animations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the `CameraView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a control for the iOS camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the iOS `CameraRenderer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the Android Camera2 framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the `CameraViewRenderer` in Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling native touch events through the `FocusView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RX to handle events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a `VisualElementRenderer` for iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the `CustomImageRenderer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the `UIImageEffect` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the `CustomImageRenderer` for Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the `CameraPage`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding native orientation events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin by creating a new `Xamarin.Forms` project and calling it `Camera`.
    We also want to create the `Camera.Portable` project. Now that we have built up
    several `Xamarin.Forms` applications, we have a lot of reusable parts that will
    be brought across to this application.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the `Camera.Portable` project, we want to copy in the `IoC`, `Extras`,
    and `Logging` folders used in [Chapter 7](ch07.html "Chapter 7.  Building a File
    Storage Application"), *Building a File Storage Application*. Make sure all the
    files contained in these folders are copied in accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to update namespaces in each code sheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we want to add the following NuGet packages for every project:'
  prefs: []
  type: TYPE_NORMAL
- en: Autofac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we want to create a folder called **Enums**. Add in a new folder called
    `PageNames.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Like our other projects, this will be used in the navigation setup. In this
    folder, we also want to add another file called `Orientation.cs` and implement
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This `enum` will be used with orientation settings on our `CameraPage`. Each
    different orientation setting will be handled for adjusting camera preview surface
    areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to create a new folder called `UI` and copy in the `INavigationService.cs`.
    We also want to add another file called `AlertArgs.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class will be used inside all alerts that are invoked inside our
    view-models. We use a `TaskCompletionSource` object to await the method that fires
    the alert, and the `Message` object for every alert message.
  prefs: []
  type: TYPE_NORMAL
- en: Building the MainPageViewModel class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the `ViewModelBase` class, which will contain the `AlertArgs` event.
    Create a new folder called `ViewModels`, add in a new file called `ViewModelBase.cs`,
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `ViewModelBase` class will be similar to the other `Xamarin.Forms` projects.
    We have the `INotifiedPropertyChanged` requirements, another `EventHandler` for
    alerts, and the `INavigationService` for navigation control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Improving the INotifiedPropertyChanged implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have noticed from previous projects, our standard property implementation
    for handling property changes looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The repeated code in every public property makes our view-model code look much
    bigger than it actually is. In all your code sheets, a good coding practice to
    think about is how you can reduce the amount of lines of code and, especially
    repeated code. The following function `SetProperty` is an example of how we can
    turn 13 lines of code into just two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In all properties, we always check first if the value being assigned is different
    to the current value before firing the `OnPropertyChanged` function. Since this
    is a generic type function, the same logic can be used for any property on all
    view-models. Now the `DescriptionMessage` property will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the rest of the `ViewModelBase` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding functions are the same from previous implementations. Take note
    of how we fire the `Alert` event. Since we now have access to C# 6.0, we can turn
    a standard null check on an event like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It looks much cleaner, meaning we can remove all the `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add a new file called `MainPageViewModel.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Exactly like the other `MainPageViewModel` objects, the `MainPage` layout is
    the same, with two buttons, an image, and a label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the `public` properties. We are going to use the new `SetProperty`
    function for each `public` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the constructor, we are going to use the `Command` factory again to
    instantiate our binded `Command`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s build the next view-model for the `CameraPage`. Add a new file called
    `CameraPageViewModel.cs` to the `ViewModels` folder and implement the private
    properties to begin with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `CameraPage` is going to include an `Orientation` property for adjusting
    `Grid` rows and columns using converters. The `_photoData` property will be used
    for recording the image taken as bytes, we will also be using these bytes to bind
    to an `ImageSource`. The `_loadingMessage` and `_cameraLoading` properties are
    used when displaying a view showing the native camera hardware is busy. The `_isFlashOn`
    will be used to control UI elements displaying the status of the flash. The `CameraPage`
    will also have a target image representing the focus target. Then finally, the
    `_canCapture` is used to determine whether the camera has loaded and we are ready
    to take photos, and the `_photoEditOn` is used to bind the visibility status of
    a view showing the photo just taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the `public` properties; following are two to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the `public` functions, we have the `AddPhoto` function, this will
    take the image as bytes from the native side, and the `PhotoData` is assigned
    for the `ImageSource` binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have a function for resetting the variables used in the current photo
    taken. When the `PhotoEditOn` is `false`, this means we remove the view that is
    displaying the current photo taken. When the `PhotoData` property is assigned
    an empty byte array, this means we have freed the data of the image that is currently
    displaying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have two more functions that are called when the page appears and
    disappears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `OnAppear` function simply resets the `CameraLoading` property to `false`,
    and the `OnDisappear` function resets the entire view-model; when we return to
    this page, the state is the same as the starting point (that is, the camera is
    not loading, no photo is showing)
  prefs: []
  type: TYPE_NORMAL
- en: 'Excellent! Now that we have built our view-models, let''s add the `PortableModule`
    for our IoC container as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's begin building the user interface screens.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the custom UI objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jump back in the `Camera` project and let''s begin adding a new folder called
    `Controls`. Add in a new file called `OrientationPage.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In our previous chapter, we created an `ExtendedContentPage` for handling alerts.
    This time, the `ExtendedContentPage` will inherit the `OrientationPage`, meaning
    it will be handling orientation events as well. The `CameraPage` is going to use
    this `OrientationPage` to track orientation events to resize camera preview areas,
    and rotate the camera view.
  prefs: []
  type: TYPE_NORMAL
- en: Our next control is the `FocusView`. It is going to be used for custom rendering
    purposes so that we are able to record touch point (*x*, *y*) coordinates on a
    view plane. These touch points will then be used to focus the camera at that particular
    (*x*, *y*) coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next custom control is an extension to the `Image` class. Add another file
    into the `Controls` folder called `CustomImage.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These custom bindings will be used for tinting. Since this view will be used
    for a `CustomRenderer`, we will have access to native tinting features. This is
    where we will add some advanced techniques to our  `CustomRenderer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to add two more custom bindings. The `Path` property will
    be used for the absolute path of the file, and the `Aspect` property will be used
    for the image aspect ratio so we can change the image aspect natively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Have a look at the delegate function passed in as the last parameter for each
    `Create` function. This will be called every time the property changes; the `bindable`
    object that comes from the first parameter of this delegate function is the object
    itself. We retrieve the `CustomPropertyChangedEventHandler` and fire a new event
    to signal that a property on this object has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following to the `CustomImage` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That's all for the `CustomImage` class; let's move on to the next custom control.
  prefs: []
  type: TYPE_NORMAL
- en: Building the FocusView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FocusView` is going to be used as an overlay view with a target image for
    touching focus points. This will be a `CustomRenderer` as we have to use native
    libraries for retrieving specific (*x*, *y*) coordinates on touch points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with adding a new file into the `Controls` folder called `FocusView.cs`
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first part we see here are two `Point` objects for specific (*x*, *y*) coordinates
    for portrait and landscape orientation starting points. These two points will
    be set when the view first loads. Both points will be set to the center of the
    view in both landscape and portrait orientations. We also have the _`startingPointsAssigned`
    Boolean to ensure we only set the starting focus points once.
  prefs: []
  type: TYPE_NORMAL
- en: The `CustomImage` object is used for the actual image of the target. We will
    be using the tinting properties each time a user touches to focus. The `_isAnimating`
    property is used for tracking progress of current animations (we will be animating
    the scale of the image each time a touch is detected). The constant property is
    used to hard set the height and width of the target image, and we have two events
    for detecting all user touch events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have a single public property for the orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Xamarin.Forms animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Xamarin.Forms` has multiple functions for animating views. We have access
    to the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FadeTo`: This is used to animate opacity (that is, fade in/out).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RotateTo`: This is used to animate rotations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScaleTo`: This is used to animate size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TranslateTo`: This is used to animate (*x*, *y*) positions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LayoutTo`: This is used to animate *x*, *y*, width, and height.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stay away from the `LayoutTo` function. Jason Smith (the creator of `Xamarin.Forms`)
    recommends you stick with the `TranslateTo` instead. The issue with `LayoutTo`
    is the parent of the view you are calling `LayoutTo` on will not be aware of the
    translation/resize that happened and will simply overwrite it at the next layout
    cycle (like when you rotate the device). This is because `LayoutTo` is calling
    the same method Layouts call to position children.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to use a few of these animation functions to animate our target
    image when a use touches to focus. The `AnimateFocalTarget` function will be responsible
    for performing the animations every time a user touches the view. At first, it
    will change the tint color of the image to green, then translate the (*x*, *y*)
    coordinate to the starting position, expand the scale, fade the image, contract
    the scale, and wait a second until the tint color changes back to white:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: All these await functions, is there a cleaner way?
  prefs: []
  type: TYPE_NORMAL
- en: In a lot of cases, you will need to combine multiple transitions at any one
    time. Let's replace the preceding combination of animations with a compound animation.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Forms compound animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compound animations give you the ability to combine multiple animations as
    a storyboard. Let''s replace the preceding function with our new implementation
    using a compound animation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Each `Animation` object has the property we are animating, a start point and
    an end point, and `easing` (linear, bounce in, bounce out). All `Animation` objects
    are then added to the storyboard. The first two parameters of the `Add` function
    are the start time and finish time of that particular animation. Finally, we call
    the commit, and instead of awaiting the `Commit` function, we will use a `TaskCompletionSource`
    object to await the commit until it is finished. The `finished` action is called
    after the length of 300 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Isn't that much nicer than our previous implementation?
  prefs: []
  type: TYPE_NORMAL
- en: We should use this approach when we have multiple animations to commit at any
    one time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the `Reset` functions to our `FocusView`. This will be called
    whenever an orientation has occurred, we will use the assign the focus point to
    the correct orientation starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NotifyFocus` function is responsible for controlling the entire touch
    animation; this is where we will set the starting state of the `_focalTarget`
    image, call the `AddFocualTargetImg` function, and then fire the `TouchFocus`
    event. This event will be used to focus the `CameraView` through the custom renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the `SetFocusPoints` function to assign the starting focus
    points in each orientation (landscape and portrait). These starting points will
    always be the center of the `CameraView`. This is to ensure that the `_focalTarget`
    image is centered inside the `CameraView` on every change in orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That's everything for our `FocusView`. Let's add our next custom UI element,
    the `CameraView`.
  prefs: []
  type: TYPE_NORMAL
- en: Building the CameraView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our next custom element is the UI object for rendering the native camera. Let''s
    add a new file into the `Controls` folder called `CameraView.cs` and implement
    the first part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There are many events to manage because we have to handle events coming from
    the `Xamarin.Forms` object in order for the native object to respond to, and vice-versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the public properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first `bool` is set when we receive events for the `AvailabilityChangeEventHandler`.
    The `Orientation` property is assigned every time the screen orientation changes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Screen orientation changes will come from the native side, these events will
    come from the `AppDelegate` (iOS), `MainActivity` (Android), and `MainPage.xaml.cs`
    (Windows).
  prefs: []
  type: TYPE_NORMAL
- en: Then we have the `CameraButtonContainerWidth`, this will only be relevant for
    iOS as we need to resize the preview layer for the iOS camera when the orientation
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next functions are all for notifying the preceding events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent! Now we have the final custom control to build. Add a new `ContentView.xaml`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the CameraView](img/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the `LoadingView.xaml` file and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The layout of the `FocusView` consists of a `Grid` containing another `StackLayout`,
    which is centered both horizontally and vertically inside the `Grid`. The `StackLayout`
    contains an `ActivityIndicator`, which will be running every time this view is
    shown, and a `Label` to display a loading message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, expand the `LoadingView.xaml.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This view will be used on the `CameraPage`. When the camera is loading or processing
    an image, the entire screen will be cast black, displaying the `ActivityIndicator`
    and loading message, to show the user that the camera is processing.
  prefs: []
  type: TYPE_NORMAL
- en: Building a control for the iOS camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have built the `CameraView` object in the `Xamarin.Forms` PCL,
    we are going to build the `CustomRenderer` for iOS. Jump into the **Camera.iOS**
    project and add a new folder called `Renderers`, and then add a new file called
    `CameraiOS.cs` and implement the following private properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `_tag` and `_log` properties will be used for all logging that occurs when
    an exception occurs. The `_previewLayer` is used to display the video input from
    the camera; this will be set to the entire width and height of the `CameraView`.
    The `_captureSession` is used in conjunction with an `AVCaptireVideoPreviewLayer`
    object for capturing an image from the video input. The `_input` object is used
    in conjunction with an `AVCaptureDevice` and `CaptureSession`; this provides the
    video stream input, which the `CaptureSession` will use to capture an image. We
    also have an `AVCaptureStillImageOutput` object called `_output`; this is used
    to capture high-quality still images with accompanying metadata.
  prefs: []
  type: TYPE_NORMAL
- en: An `AVCaptureStillImageOutput` object also contains `AVCaptureConnections`,
    which we use for controlling the video stream orientation. Then finally, we have
    the `_device` property, which is the object that represents a physical capture
    device. In our example, we are going to use the rear camera. We will see how the
    remaining properties are used through the other functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we have to add three events that will be notified when the camera is busy,
    when the camera is available, and when a photo is taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The constructor will start with retrieving the `ILogger` object from the `IoC`
    container and assigning the `_tag` to the type name using C# 6\. Then we retrieve
    the system version information and create a new `UIView`. Setting the `AutoresizingMask`
    to `UIViewAutoresizing.FlexibleMargins` ensures that the `CameraiOS` view adjusts
    to the entire bounds of the `CustomRenderer`. Then we instantiate a new `AvCaptureSession`
    and an `AVCaptureVideoPreviewLayer`, we pass the `AVCaptureSession` object into
    the new `AVCaptureVideoPreviewLayer,` and add this layer to the `mainView` layer.
    We then retrieve the physical camera device using the `RetrieveCameraDevice` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add this function in below the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'On this line, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is used to retrieve the physical rear-view camera.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's get back to the constructor. After we retrieved the physical device,
    we simply add the `mainView` to the `CameraiOS` view and set the layout constraints
    of the `mainView` to fill the bounds of the `CameraiOS` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the `private` functions. Our first function `AdjustPreviewLayer`
    is responsible for setting the bounds of the layer to fill the `CameraiOS` view
    when an orientation change occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a function for setting the starting orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the `SetBusy` function, which will invoke the `Busy` EventHandler
    and set the `private` variable to keep the busy status locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the `CaptureImageWithMetadata` function. This is called every
    time the user clicks to take a picture (this function will be called from the
    public method `TakePhoto`). When we call the `CaptureImageWithMetadata` function,
    we must pass in an `AVCaptureStillImageOutput` object and an `AVCaptureConnection`.
    From the `AVCaptureStillImageOutput` object, we call the `CaptureStillImageTaskAsync`
    function on the `AVCaptureConnection`. The connection we pass in is linked to
    the `_previewLayer` connection. After this call is successful, we retrieve the
    raw image as a JPEG and retrieve the raw bytes to invoke the `Photo` EventHandler.
    We also use the `RotateImage` function for rotating the original `UIImage` image
    to the correct orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the `RotateImage` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, we use the `UIGraphics` context for rebuilding and
    rotating the `UIImage` image. We start with a new `CGImage`, gather the orientation
    from the original `UIImage`, and transform this image, then redraw using the `UIGraphics.GetImageFromCurrentImageContext()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we add the public methods. Start with overriding the `Draw` function so
    that we can assign the most recent frame on the `_previewLayer`. The `Draw` function
    is called every time the screen rotates. We want to ensure the `_previewLayer`
    frame fills the bounds of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the `TakePhoto` function. This will retrieve the current `AVCaptureConnection`
    from the `AVCaptureStillImageOutput`, set the connection orientation to the `_previewLayer`
    orientation, and pass the connection and output to the `CaptureImageWithMetadata`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to look at the exception handling occurring for all functions.
    Sometimes, bizarre errors can occur (null connections, device retrieval fails)
    when dealing with camera hardware, so we must handle all exceptions that may occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `SwitchFlash` function, which is used to turn the flash on/off
    using the `AVCaptureDevice` configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the `SetBounds` function. This is called from the `OnElementPropertyChanged`
    method of the `CustomRenderer`, on any height and with property changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `ChangeFocusPoint` function is used for focusing the camera to the touch
    point received from the user. First, we must lock the `AVCaptureDevice` configurations
    before making any changes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we make changes to the `AVCaptureDevice` configurations, we must first
    call `LockForConfiguration` to notify the device that we are making changes and
    then, once we are finished, call `UnlockForConfiguration` for the changes to take
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we check to see if the `FocusPointOfInterestSupported` is `true` and set
    the `FocusPointOfInterest` to a new `CGRect` point. We also do the same with exposure
    by first checking the `ExposurePointOfInterestSupported` is `true` and setting
    the `ExposurePointOfInterest` to a new `CGRect` point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next function is `InitializeCamera`, which we use to set up the `AVCaptureDevice`.
    We set the focus mode to `ContinuousAuto` and create a new `AVCaptureDeviceInput`
    using the instance of the `AVCaptureDevice`. We then create a new `AvCaptureStillImageOutput`
    object. Both the `AVCaptureDeviceInput` and `AvCaptureStillImageOutput` objects
    are assigned to the input/output of the `AVCaptureSession`, respectively. After
    this, the new `NSDictionary` is created with a key to set the video CODEC to JPEG
    (all still images taken will be in this format). Finally, the `Connection` object
    from the `_previewLayer` is retrieved, the starting orientation is set accordingly,
    and we call the `StartRunning` method on the `AVCaptureSession`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next function is `SetWidths`, which will assign the local `_cameraButtonConatinerWidth`
    property accordingly. This `local` property is used as an extra reduction on the
    camera stream width to ensure that the camera stream does not fall behind the
    black button panel on the `CameraPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Next, the last function is `HandleOrientationChange`, which will be called from
    the `CustomRenderer` every time an orientation occurs because we must update the
    `VideoOrientation` property of the `AVCaptureConnection` object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though `Xamarin.Forms` automatically handles the orientation changes of
    the views for you, with this `CustomRenderer` view, the video stream from the
    `AVCaptureVideoPreviewLayer` does not rotate unless we change the underlying `CALayers`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the `StopAndDispose` method. This will be called from the
    `Dipose` method of the `CustomRenderer`. It is responsible for freeing up all
    the resources involved with the camera stream, and switching off the flash if
    it is on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Well done! Now we have built the native camera control, we are going to use
    this as the control for our CustomRenderer.
  prefs: []
  type: TYPE_NORMAL
- en: Building the iOS CameraRenderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s create the actual `CustomRenderer` that will use this custom iOS
    object. Add a new file into **Renderers** | **CameraView**, call it `CameraViewRenderer.cs`,
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of our `CustomRenderer` shows the `OnElementChanged` override.
    In all custom renderers, the `OnElementChanged` function may be called multiple
    times, so care must be taken to avoid any memory leaks that can lead to performance
    impact. Following is the approach that should be taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now back to the `OnElementChanged` implementation, we instantiate a new `CameraiOS`
    and register the EventHandlers to the `Xamarin.Forms``CameraView` functions. This
    will fire another event that will be handled on our `CameraPage`. We then call
    `SetNativeControl` to assign the `CameraiOS` object to the `CustomRenderer` control,
    so when `CameraView` object is displayed on a `ContentPage`, a `CameraiOS` view
    will appear on top. We then register events and unregister events in both the
    if blocks to correctly dispose and assign the `CameraView` EventHandlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the next override for `OnElementPropertyChanged` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This function will be called for every property change on the `CameraView`.
    We will call the `SetBounds` method on the `CameraiOS` object so that our `AVCapturePreviewVideoLayer`
    always retains the latest height and width update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we must add the `EventHandler` functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: All these functions will respond to events fired from the `CameraView` and call
    their respect native functions to handle control on the native camera.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have implemented control over the iOS camera, let's do the same
    for Android.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the Android Camera2 framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new `Camera2` framework was introduced in API 21 (5.0 Lollipop) and provides
    a wide featured framework for controlling camera devices connected to any Android
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by setting up the folder structure **Renderers** | **CameraView** inside
    the `Camera.Droid` project. Inside the `CameraView` folder, add a file called
    `CameraCaptureListener.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: All we need to do is fire an event every time the `OnCaptureCompleted` function
    is called. This function is called after all the image capture processing is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to create a callback for receiving updates about the state of
    a camera capture session. We will listen for both the `OnConfigured` and `OnConfigureFailed`
    and fire two different events so that we can handle any errors that may occur
    with the configuration of the capture session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next class is another callback for receiving updates about the state of
    the camera device. Here we will be firing events for camera availability so that
    we can pass down the availability state of the native camera to our `CameraView`
    view in the `Xamarin.Forms` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the new `Camera2` callback objects provide excellent control with error
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: The `CameraDroid` class will be rendered on top of the `CustomRenderer`, which
    is equivalent to the `CameraiOS` object. We want to pass an instance of the `CameraDroid`
    class to the `CameraStateListener`, when the state of the camera changes, we update
    the availability status on the `CameraDroid` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must add another callback instance for handling image availability.
    This is where the raw image bytes will come from. Add a new file called `ImageAvailableListener.cs`
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: When the `OnImageAvailable` function is called, this means we have the raw image
    available. We call `AcquireLatestImage` on the `ImageReader` object to acquire
    the last image taken, pull the raw bytes into a `ByteBuffer`, and convert the
    `ByteBuffer` into an array of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `ByteBuffer` comes from the `Java.Lang` framework, which we use when we want
    to implement fast low-level I/O.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to implement the `CameraDroid` class. Add in a new file called
    `CameraDroid.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `CameraDroid` class inherits `FrameLayout` and `TextureView.ISurfaceTextureListener`.
    The static `ORIENTATIONS` property is a `SpareIntArray`, which works similar to
    a `HashMap`, but it can only map integers to integers. This will be used when
    a picture is taken. We must rotate images based upon screen orientation for the
    picture orientation to appear correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We also have three event handlers like our `CameraiOS` these, are used to track
    whether the camera has taken a photo, is busy or is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the following `private` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `_tag` and `_log` properties are used for logging like our other classes.
    We are also going to include an instance of all our callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have the `public` properties. Every time the `OpeningCamera` property
    is assigned, it will fire a `Busy` event. Now we can track the busy state of the
    camera inside the `CameraPage` containing the `CameraView`. We also have an instance
    of the `CameraDevice`, which represents the actual device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the constructor. We must first pass in the context, since we
    will be using this locally through the class. Then the `LoadShutterSound` function
    is called, which will return a Boolean once the sound has been loaded. We then
    assign `_log` from the `IoC` container and set `_tag` using the C# 6 method `GetType`.
    Using the `LayoutInflator`, we create a new `CameraLayout` and set the local `_cameraTexture`
    object. The `SurfaceTextureListener` property of the `_cameraTexture` must be
    set to the `CameraDroid` instance itself. This is why the `CameraDroid` class
    implements the `TextureView.ISurfaceTextureListener` framework. We then instantiate
    a new `CameraStateListener` and set the `Camera` property to the `CameraDroid`
    instance using the `this` keyword, and, add the orientation to rotation mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s move on to the `private` methods. We are going to start with `UpdatePreview`.
    This is responsible for starting the video stream through the surface texture.
    If we have both a session and camera object in play, we use the `CameraRequest.Builder`
    instance to set the capture request mode to auto. The `Handler` object that is
    created is required to run the `CameraPreview` on the main UI thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next function is responsible for loading the click sound. The `LoadShutterSound`
    method is used above in the constructor. When it returns `true`, this means we
    have successfully loaded the `MediaActionSoundType.ShutterClick`, so every time
    a user takes a photo, the shutter sound will play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we move on to the `public` methods. Our first function `OpenCamera` will
    be called when the `CameraPage` appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Before opening the camera, we first check if the `_context` is null and that
    we are not already opening the camera. We then flag `OpeningCamera` to true and
    retrieve the camera device from the context using the `GetSystemService` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `GetSystemService` method can be used to retrieve all hardware services.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our `CameraManager` object, we call the `GetCameraIdList` method
    and retrieve the first camera ID from the list. We use this camera ID to retrieve
    the camera's characteristics that will be used for retrieving camera output sizes.
    We first use the camera output size to set the aspect ratio of the `_cameraTexture`
    and then we call `OpenCamera`, where we pass in the `cameraId` and `CameraStateListener`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have to add a function for taking photos. We start by checking if the
    `_context` and `cameraDevice` is not null. We then invoke a `Busy` event to communicate
    to our `CameraView` and check if the shutter click sound has been loaded, then
    play if it has loaded successfully.. Then we use the camera's characteristics
    to retrieve JPEG output sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On every Android device, a camera will have supported output sizes for video
    streams and picture sizes. When we assign height, width, and ratio properties
    of camera display, they must be mapped to supported sizes.
  prefs: []
  type: TYPE_NORMAL
- en: We then set the first output size to the function's `width` and `height` properties.
    If the characteristics fail to show any JPEG output sizes, we start with the default
    width and height (640, 480).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use an `ImageReader` to retrieve and image from the `_cameraDevice`.
    We start with creating a new instance of an `ImageReader` and pass in our required
    width and height properties. An `ImageRenderer` also requires a surface, which
    is mapped to the output of a camera. When we take a picture, the `ImageReader`
    knows it will be reading from the output of the camera. We create a new `CaptureRequest.Builder`,
    which is created from the `CreateCaptureRequest` method of the `_cameraDevice`.
    Then we set the surface target to the surface we created earlier. Now the builder
    knows we are mapped to the output of the camera. We also set the capture request
    to auto, so most of the setup is taken care of. We then get the current orientation
    of the window from the `WindowManager` property (this is another service pulled
    from the `_context` using the `GetSystemService` method), and using the current
    orientation, set the rotation of the image accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we have to change the orientation of the image? If we take an image on
    the current orientation, why is the image in a different orientation?
  prefs: []
  type: TYPE_NORMAL
- en: This is something we cannot control; the current orientation of the camera display
    does not map exactly how the image is interpreted when we take a picture, so we
    have to apply some minor rotation to bring the image into the same orientation
    as the camera surface.
  prefs: []
  type: TYPE_NORMAL
- en: This is a lot of work for the camera to do to prepare for capturing an image,
  prefs: []
  type: TYPE_NORMAL
- en: It takes a lot of work to prepare a capture session
  prefs: []
  type: TYPE_NORMAL
- en: how do we know when an image is actually taken?
  prefs: []
  type: TYPE_NORMAL
- en: All the work we have done so far is all for preparing the camera to take an
    image. We use our `ImageAvailableListener` for letting us know when the image
    is ready. Since we set up an event to hand us the image bytes, we can assign a
    delegate that will fire the `CameraDroid` so that the image bytes are passed back
    to the `CameraView` object.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the Handler?
  prefs: []
  type: TYPE_NORMAL
- en: The handler is used to handle the resulting JPEG in a background thread.
  prefs: []
  type: TYPE_NORMAL
- en: We then create an instance of our `CameraCaptureListener` to let us know capture
    operations have completed and assign a delegate function to restart the camera
    stream when the `PhotoComplete` event has been invoked. A new `CameraCaptureStateListener`
    object is passed into the `CreateCaptureSession` method to start the capture session
    and we assign a delegate to the `OnConfiguredAction` that will store the current
    `CameraCaptureSession`. We call the `Capture` method on the session and then call
    the `Build` method on the `captureBuilder` we created earlier. This occurs every
    time the `Capture` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `captureListener` object and the handler are passed into the `Capture` method
    so that all capture processing is done on a background thread.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means that when a picture is taken, the processing time in between preparing
    a photo will not lock the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: It takes a lot of work to prepare a capture session on an Android camera using
    the `Camera2` framework, but the advantage is we have is the ability to control
    every single step separately, and handle any exceptions that occur at any point
    during the capture operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next function will be responsible for changing the focus point of the camera,
    when a touch on the `CameraView` occurs, this function will be called to change
    the focus point of the native camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ChangeFocusPoint` function starts with retrieving the `cameraId` from
    the `CameraManager`. We then call the `Get` method of the camera characteristics
    to retrieve a rectangle and size of the active region of the camera sensor (that
    is, the region that actually receives light from the scene). We then retrieve
    the right and bottom bounds of this region and get the width and height of the
    `_cameraTexture`. When a user touches to focus, the point coordinate (*x*, *y*)
    passed into this function is used as the center of the focus region. As we have
    the middle point, we calculate the left and bottom points and we also use the
    `Clamp` function to make sure these points are within the width and height bounds
    of the `_cameraTexture`. We then create a new `Rect` representing the new active
    region for the camera sensor. Then, to perform the actual focus on the camera
    device, we must first disable the autofocus by calling the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Then assign the camera sensor''s active region by calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, reset the autofocus by calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The operation works by disabling the autofocus, setting the active region, and
    then recalling autofocus. When the autofocus is started again, we have a new focus
    point in which the camera will adjust its focus point too.
  prefs: []
  type: TYPE_NORMAL
- en: We also call the `UpdatePreview` function for resetting the camera control to
    auto.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `Clamp` function, which is responsible for forcing the value
    passed in to be between a range. We use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the `StartPreview` function, this will be responsible for starting
    the camera stream through the `TextureView`. We won''t call this unit the camera
    has been opened previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The function starts with configuring the size of the default buffer to be the
    size of the camera preview. Then we want to create a new `Surface` object for
    the output surface of the camera, which is then assigned to a new `CaptureRequest.Builder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget we have another function to control the flash of the camera.
    We simply adjust the flash mode through `CaptureRequest.Builder` object and, based
    upon the `flashOn bool` passed in, we assign either `FlashMode.Torch` or `FlashMode.Off`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have a public function to invoke the `Available` event, which we need
    for the `CmaptureStateListener` callback so that we keep track of the camera availability
    during a capture session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have the `ConfigureTransform` function, which is responsible for transforming
    the texture view. Here we are handling surface orientations and matrix rotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the functions that are required by every `TextureView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnSurfaceTextureAvailable` function will call configure the texture''s
    transformation matrix based upon the current window''s orientation and call `StartPreview`
    to start the video stream through the texture view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to configure the texture''s transformation matrix when the surface
    size changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Wow! That was one huge implementation. Configuring the camera is not an easy
    task; it involves a lot of step-by-step procedures that must be taken correctly
    for starting the camera stream and creating a capture session. Those are the two
    most important operations of any camera implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Building the CameraViewRenderer in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we must add the CustomRenderer for the Android camera. In the `Renderers`
    folder, add a new file called `CameraViewRender.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Our renderer contains only one private instance of the `CameraDroid` class.
    Then we override the `OnElementChanged` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inside Android `CustomRenderers`, there is a bug with disposal using the `OnElementChanged`
    method. In some cases, this method is not called when the view is disposed, so
    we are going to override the `Dispose` method.
  prefs: []
  type: TYPE_NORMAL
- en: Here we follow the correct structure in the `OnElementChanged` method and instantiate
    the new control when the `Control` property is null. We also register our events
    when the new element is not null (events are registered on both the `CameraDroid`
    and `CameraView` objects).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the override to handle the disposal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we simply unregister the events for both the `CameraView` and `CameraDroid`
    objects. Next, we have the `private` event delegate methods for calling the native
    camera methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Great! We have completed our camera implementations for both iOS and Android.
    Now we have to create another renderer for the `FocusView`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling native touch events through the FocusView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since our camera implementation is handling focus changes from touch events,
    we are required to receive these touch events from the native side. `Xamarin.Forms`
    does not have touch events that give (*x*, *y*) coordinates, so we have to do
    some more custom rendering on the `FocusView`. Let''s start with the Android implementation
    this time, inside the `Renderers` folder, add a new folder called `FocusView`,
    and add a new file called `FocusViewGestureDetector.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class is very similar to the gesture detector we created for the
    `CarouselView` in the last chapter. We only use this object to retrieve the `MotionEvent`
    object from the `OnDown` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add in another file called `FocusViewRender.c` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `FocusViewRenderer` will contain an instance of our `FocusViewGestureDetector`
    and `GestureDetector` for handling touches on the `FocusView`. We also have a
    `LinearLayout`, which is going to be the control assigned to the `FocusView`.
    This `LinearLayout` will be blank and will only be used to receive the native
    touch events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we add the override to the `OnElementChanged` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: When the `Control` is null, before we call the `SetNativeControl` method, we
    set up the gesture detectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we must handle disposal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add the remaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Using RX to handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have a look at the `SetGestureDetectorListener` function where we are using
    the `FromEventPattern` method from the `Observable` framework. The function must
    be typed with a particular object (that is, `MotionEvent`) that contains an `EventHandler`
    property, in this case `Touch`. Every time a `Touch` event is fired, using the
    `Window` method, we wait 0.7 seconds before doing anything (this ensures that
    we only respond to the first event taken every period set in the `Window` method).
    Once this period is reached, `SelectMany` is called and the first `Touch` event
    is retrieved from the observable sequence via the `Take` method. Then we call
    `Subscribe` to assign the `NotifyFocus` method, and pass in the `MotionEvent`
    object taken from the `SelectMany` method.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, the `FromEventPattern` method is very useful for controlling multiple
    events and responding with specific actions. We have applied this technique with
    touch events because we want to make sure only one touch event is processed every
    0.7 seconds. If we used a simply delegate function, a user could very fast, and
    for every touch event, the camera would run through the `ChangeFocusPoint` operation
    every time before the previous has finished, eventually crashing the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now turn attention to the `ConvertPixelsToDp` method. We have to translate the
    pixel points into DPI when translating position coordinates (*x*, *y*) between
    native Android and `Xamarin.Forms` views. This will be called for every touch
    event for both x and y before we pass the coordinate to the `CameraView`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1 DP equals 1.5 physical pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Building a VisualElementRenderer for iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To handle native touch events on iOS, we are going to build a `VisualElementRenderer`.
    These work similar to CustomRenderers, but instead of rendering and replacing
    the entire control, we are able to render specific attributes, so we are able
    to attach native attributes to a `Xamarin.Forms` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with adding a new folder inside the `Renderers` folder called
    `FocusView`. Add in a new file called `FocusViewRendererTouchAttribute.cs` and
    implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to add the assembly line above the namespace like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: When the element is rendered, we will now have the access to the `TouchesBegan`
    override. Inside this function, we have access to the render object (`FocusView`),
    where we can call the `NotifyFocus` function and pass the current touch (*x*,
    *y*) coordinate back to the `FocusView`.
  prefs: []
  type: TYPE_NORMAL
- en: That's all for our `FocusView` renderers. Let's now move on to the `CustomImageRenderer`
    so that we can apply color tinting to an image.
  prefs: []
  type: TYPE_NORMAL
- en: Building the CustomImageRenderers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to start with the iOS implementation of the `CustomImage`. Inside
    the `Renderers` folder, add a new folder called `CustomImage`, add a new file
    called `CustomImageRenderer.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at our `private` properties, we have the logging objects again, an
    integer property to hold the current system version (that is, iOS version), and
    an `UIImageView` to use as the native control. Next we have to override the `OnElementChanged`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember we have to follow the same structure for instantiating the control,
    and registering and deregistering EventHandlers. In this renderer, we are going
    to apply event handling a little differently. Instead of registering multiple
    events in the `OnElementChanged` method, we only have to register and deregister
    the `CustomPropertyChanged` event. In our `CustomImage` view, with each custom
    binding, when a property is changed, we assigned a delegate that would fire this
    event with the property name for every property. Therefore, we add one delegate
    function on the renderer side called `HandleCustomPropertyChanged`, and in this
    function, we will check what property has changed and respond with an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Much cleaner than handling multiple events right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time the `Path` property is changed, we call a new method called `LoadImage`.
    Before we add this function in, we are going to add a `private` method for setting
    the image aspect ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This will take a `Xamarin.Forms` image aspect ratio value and return the related
    native image aspect ratio. This value will then be used for the aspect of the
    `UIImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add the `LoadImage` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is responsible for using the `Path` property to load an image
    into the `UIImageView`. Inside this function, we also use the `systemVersion`
    property to handle backward compatibility with color tinting. Only if the iOS
    device is using an iOS version greater than or equal to iOS 7, we apply the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This tells the `UIImageView` that its `Image` should always draw as a template
    image, ignoring its color information. We have to do this before we can apply
    a tinted color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we have to add the `ReadBitmapImageFromStorage` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Using the `File.OpenRead` method, we retrieve the files stream and load it into
    a new `NSData` object, and then from this `NSData` we load this into a new `UIImage`
    and return it to the caller (that is, the `LoadImage` function).
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also add the `UpdateControlColor` function for assigning the tint color
    to the `UIImageView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using another `static` class, which will take a color and the image
    and return a new image tinted to the color passed in.
  prefs: []
  type: TYPE_NORMAL
- en: Building the UIImageEffects class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our final part to the image tinting on iOS is implementing the class that will
    return a tinted image from a template image and color. Create a new folder in
    the iOS project called `Helpers`, add a new file called `UIImageEffects.cs`, and
    implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The function starts with creating a new `UIImage` and setting it to null. We
    then create a new image context by calling `BeginImageContext` and passing in
    the image size from the `UIImage` we pass in to the function. We then wrap the
    current context in a using statement to make sure we free memory taken from image
    processing in the context. We use the current context to assign correct (*x*,
    *y*) translation and scale to match the `UIImage` passed in. After this, we create
    a new `Rect` to match the bounds of the `UIImage` we passed into the function.
    We then call `SetBlendMode` to assign the image's transparency and call `DrawImage`
    to draw the image. Now that we have drawn the image within the context, we then
    call `SetBlendMode` again to using the `CGBlendMode.SourceIn` so that it only
    draws on the nontransparent pixels. We then set the fill color of the context
    to the color we passed into the function, which will be the tint color. The image
    context will then fill the bounds of the `Rect` we created earlier. Finally, we
    end the image processing by calling `EndImageContext` and return the new `colouredImage`
    to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Fantastic! We have now used the native `UIGraphics` framework to perform image
    tinting for iOS; let's do the same for Android.
  prefs: []
  type: TYPE_NORMAL
- en: Building the CustomImageRenderer for Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a new folder into the `Renderers` folder called `CusotmImage`, add a new
    file called `CustomImageRenderer.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use an `ImageView` as the native control. We also have a local
    `CustomImage`, which will reference the element we are rendering on. We also have
    a local `Bitmap`, which will be the image we are tinting. Then we have the `_log`
    and `tag` properties again for logging any exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add the `OnElementChanged` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a new `ImageView` as the control. When the `NewElement` is not
    null, we assign it to `_customImage`, set the aspect ratio of the `ImageView`,
    add the tint color, and load the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to handle disposal by overriding the `Dispose` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add the `private` methods. We are going to start with the `SetAspect`
    function. Like our iOS implementation, we will map the `Xamarin.Forms` image aspect
    value to the native `ImageViewScaleType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the `delegate` function for handling all our property changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `LoadImage` is a bit better than the iOS version because it loads the image
    asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: We only call the `SetImageBitmap` on the `ImageView` if the `ImageView` and
    `Bitmap` is not null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we have the `UpdateControlColor` function for tinting the image. Android
    offers a much simpler solution for tinting using the `SetColorFilter` function.
    We must pass in a `PorterDuff.Mode`, which the `SetColorFilter` will use to determine
    how to compose the image based on the alpha value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Next we have the `ReadBitmapImageFromStorage` function, where we will be loading
    a `Bitmap` from the `Path` property of the `CustomImage`. We use the `GetIdentifier`
    function from the `Resources` framework to retrieve the integer ID of the image
    resource we want to load.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, the image must be inside our `drawable` or `mipmap` folder for the
    image to be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then open the raw file as a stream using the `OpenRawResource` function,
    and using the `BitmapFactory` framework, we can use the raw resource stream to
    decode a `Bitmap` object that will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Great! We have now built all our `CustomRenderers` for the solution. Let's see
    how we use these with our user interface screens.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first page will consist of two buttons, an image, a label, and extra additional
    UI functionality known as **triggers**. Triggers are declarative objects used
    in XAML, which contain actions executed when certain conditions or events occur.
    The main advantage of triggers is we can box up these handle actions for as many
    UI elements that need to perform the same actions. We have the option of the following
    four different types of triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Property trigger**: This is executed when a property on a control is set
    to a particular value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data trigger**: This is same as the property trigger but uses data binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event trigger**: This is occurs when an event occurs on the control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi trigger**: This is allows multiple trigger conditions to be set before
    an action occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our solution, we are going to add two event triggers for button click events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with adding a new folder called `Triggers` into the `Camera` project,
    add a new file called `ButtonClickTrigger.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Our first trigger is for handling the `Clicked` event on the `CameraButton`.
    When this button is clicked, the background and text color of the button will
    change. We must override the `Invoke` function to claim the `Button` performing
    the action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add another folder for the `Pages`, add a new file called `MainPage.xaml`,
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: We must include the namespace reference to location of the `Triggers` folder.
    Then turn attention to the `CameraButton`, where we will attach the `ButtonClickedTrigger`.
    When the button is touched, the `Invoke` method of the trigger will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next trigger we add will perform a nice warping animation to a button when
    it is clicked. Let''s add another file called `VisualElementPopTriggerAction.cs`
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Anchor` property is used for the point (*x*, *y*) in which the `ScaleTo`
    function will reference. Since the reference points `X` and `Y` are `0.5`, when
    animate an expansion on the button, it will expand evenly on both the left/right
    and top/bottom. The `Invoke` method will be called when the button is clicked
    to begin the animation. We are also using the Sin easing for each animation:'
  prefs: []
  type: TYPE_NORMAL
- en: Easing.SinIn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starts slow and speeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Easing.SinIn](img/image_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Easing.SinOut
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starts fast and slows down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Easing.SinOut](img/image_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at how we will use the `VisualElementPopTriggerAction` inside
    a style. Add in the `App.Xaml` file and implement the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Can you see what technique we are using here?
  prefs: []
  type: TYPE_NORMAL
- en: This is known as **style inheritance**. The `ButtonStyleWithTrigger` style inherits
    all the styling properties of the `BaseButtonStyle` by using the `BasedOn` property.
  prefs: []
  type: TYPE_NORMAL
- en: Wait! Aren't we missing the `DescriptionLabel` from the `MainPage`?
  prefs: []
  type: TYPE_NORMAL
- en: We still have one more element to add to the `MainPage`. But first we are going
    to talk about another object used in XAML known as **PlatformEffects**.
  prefs: []
  type: TYPE_NORMAL
- en: Platform effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Platform effects are used to simplify native control customization, reducing
    the need to create `CustomRenderers` for small styling changes. This means we
    don't have to create a custom renderer every single time we want native customization.
    To implement a `PlatformEffect`, we first create a class that subclasses the `PlatformEffect`
    framework. Then we have to write platform-specific implementations for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a small overview of how the rendering process will look among
    the different projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Platform effects](img/image_08_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add a new folder called `Effects` inside the `Camera` project, add in
    a new file called `LabelShadowEffect.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Our `LabelShadowEffect` must inherit the `PlatformEffect` framework. The `Radius`
    property is responsible for the corner radius of the shadow. Then we have the
    `Color` property that will set the color of the shadow. Finally, we have the `DistanceX`
    and `DistanceY` properties for assigning the position of the shadow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we must create the platform implementations. Let''s start with iOS, add
    in a new folder called `Effects`, add in a new file called `LabelShadowEffectiOS.cs`,
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: All `PlatformEffects` must override the `OnAttached` and `OnDetached` methods.
    The `OnAttached` method is where we set up all native shadow effects. We start
    with retrieving the first `PlatformEffect` from the `Effects` list of the `Element`
    object. Like our `CustomRenderers`, we have access to the original `Xamarin.Forms`
    element that we are customizing. In the `OnDetached` method, we would normally
    dispose any objects that are no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also add assembly lines above the namespace block like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: We must add a `ResolutionGroupName` to specify the namespace for the effects;
    this prevents collisions with other effects of the same name. We also add the
    `ExportEffect` attribute to register the effect with a unique ID that is used
    by `Xamarin.Forms`, along with the group name, to locate the effect prior to applying
    it to a control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the equivalent for Android. Add a new folder in the `Camera.Droid`
    project, add a new file called `LabelShadowEffectDroid.cs`, and implement the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: In our Android implementation, we start with retrieving the control as a native
    `TextView`. We then retrieve the first `LabelShadowEffect` object from the list
    of effects from the `Element`. We then use the method `SetShadowLayer` to create
    native shadowing on the `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Now we have our native implementations, let''s add the `DescriptionLabel`
    object to the `MainPage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are able to attach the effect inside our XAML. We must also add the
    namespace to the `Effects` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the `MainPage` will look once complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Platform effects](img/image_08_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building the CameraPage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now for the final page of the solution, the `CameraPage` introduces some new
    tricks to handle orientation changes with `Grid` positions. We will be using `Converters`
    to change rows and columns on the `Grid` to reposition elements when we change
    orientation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start with adding some converters to the project. Let''s create
    a new folder in the `Camera` project, add a new file called `NotConverter.cs`,
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first converter is responsible for taking a Boolean value and returning
    the opposite. Next we have the `OrientationToBoolConverter`. Add a new file and
    implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'This converter uses the `Orientation``enum` we created at the start of the
    chapter. It will receive an `Orientation` value and a string as the parameter
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Converters can take parameters as well as values, so passing a string containing
    multiple cases allows us to use a set of specific return values to map to the
    values passed in.
  prefs: []
  type: TYPE_NORMAL
- en: We will then use the `Split` method to break up the string by the comma character,
    meaning we will have two strings that will be parsed in as a Boolean. These will
    be used as the return cases for the different orientations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add another converter, which will convert a Boolean into a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: We will use this on the camera page when the flash is turned on/off. If the
    flash is on, the string *on* will be returned. If the flash is off, we will return
    the string *off*. We use the same method as the `OrientationToBoolConverter` as
    we pass in a string value for the return cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add another file called `BoolToPartialConverter.cs` and implement the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: This will be used for updating opacity based upon the value being `true` or
    `false`. We use a string for the opacity values being returned for each Boolean
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next converter `OrientationToIntConverter` is responsible for converting
    Orientation values into integers. This is the converter that will be responsible
    for changing the rows and columns numbers when the orientation changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Again, we are using a string to contain the return cases, which we parse into
    a new integer using the `Int32.Parse` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last converter will be responsible for converting a byte array into an
    `ImageSource`. This is used for the binding created from the `CameraViewModel`
    in our `Camera.Portable` project. Since we don''t have the `ImageSource` framework
    in our portable project, we will use byte arrays to hold the image data received
    from the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: In the `Convert` method, we check to see if the byte array is not null and contains
    data, and if so, we use the `FromStream` method from the `ImageSource` framework
    to create a new `MemoryStream` from the byte array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all our converters, we must add these to the `App.xaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! Let's build the interface for the `CameraPage`. We will see how these
    converters are used on each UI element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new file called `CameraPage.xaml` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with an empty `Grid`, which has seven rows and six columns. The first
    element to add is the `CameraView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Here we can see the use of the `OrientationToIntConverter`. The `PageOrientation`
    property from the view-model. When this property is set, and the `OnPropertyChanged`
    method is called. The `Convert` method will return a new integer, changing the
    number of rows the `CameraView` will take up. This is the same on the `ColumnSpan`
    property; the amount of columns taken by the `CameraView` will change when the
    orientation changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we add the `FocusView` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: This will match the entire space of the `CameraView`. The `FocusView` will lay
    on top of the `CameraView` to receive the touch events and pass the (x, y) coordinate
    down to the `CameraView` to perform a focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to add another `Grid` for containing the flash and photo
    buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Here we see the use of the `CustomImage` instead of a button because we want
    to be able to show a specific image for each button.
  prefs: []
  type: TYPE_NORMAL
- en: 'This panel is positioned under the `CameraView` like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the CameraPage](img/image_08_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next we have the `LoadingView` for displaying status of camera activity for
    initialization and taking photos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to add another element for the camera buttons in landscape mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the `CameraPage` in landscape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the CameraPage](img/image_08_007-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last element to add is another `Grid` that will appear when we take a photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the CameraPage](img/image_08_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The `Grid` contains the `Image` that will be bound to the `PhotoData` property
    on the view-model. This is where we use the `ByteArrayToImageSourceConverter`.
    Whenever the byte array is changed and the `OnPropertyChanged` method is called,
    a new image will be created from the byte array in the view-model. There is also
    a `CustomImage` that will add another button for closing the screen, deleting
    the image data, and returning to the camera to take another photo.
  prefs: []
  type: TYPE_NORMAL
- en: Adding native orientation events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next step is to add the notifications that are going to fire every time
    an orientation occurs. These events will come from the native side, so in order
    to have these pass down to our `Xamarin.Forms` project, we are going to use the
    static events on the `OrientationPage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the iOS project. Open the `AppDelegate.cs` file and add the
    following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The `DidChangeStatusBarOrientation` function is contained in all `AppDelegate`
    objects. When we override this, we reference the exact orientation in the `UIApplication.SharedApplication.StatusBarOrientation`
    property of the `AppDelegate`. Every time an orientation occurs, this method will
    be called and we will then call the static method `NotifyOrientationChange` on
    the `OrientationPage` to fire the event back to the `Xamarin.Forms` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do the same for Android. Open the `MainActivity.cs` file and add the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately for Android, we can only gather whether the orientation is in
    landscape or portrait. IOS has the ability to determine whether we are in landscape
    left or landscape right.
  prefs: []
  type: TYPE_NORMAL
- en: Like the `DidChangeStatusBarOrientation` function, the Android `OnConfigurationChanged`
    method will be called whenever the orientation changes. We use a switch statement
    again to call the static method on the `OrientationPage`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now add the logic behind the `CameraPage`. Here we will be responding
    to the native orientation events when they occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `CameraPage.xaml.cs` file and implement the private properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: We use the `CAMERA_BUTTON_CONTAINER_WIDTH` property when we render the camera
    stream on iOS, to make sure the stream bounds do not render behind the button
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the camera is rendered for iOS, we have to reduce the render bound width
    by a certain amount to make sure that the camera bounds don't render behind the
    button container. Every time the orientation changes, we will use this value to
    reduce the width of the render bounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have the `CameraPageViewModel` to keep locally when we retrieve it
    from the IoC container. Let''s add the constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Here we retrieve the `CameraPageViewModel` from the IoC container. We also register
    event functions when the page appears and disappears. We also register event functions
    on the `CameraView` when we take a photo, when the camera initialization occurs,
    when the camera is loading, and when the camera is busy. Then, we register one
    event for the `TouchFocus` event on the `FocusView`. Every time a new point (*x*,
    *y*) is received, we pass this to the `CameraView` to perform a focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `EventHandler` functions for page appearing and disappearing.
    Here we will register and deregister to the orientation `OrientationHandler` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the `HandleOrientationChange` method for updating the button container
    width by resizing the width of the `ColumnDefinition`. After we resize the `ColumnDefinition`,
    we then call `Reset` on the `FocusView` object; if the camera is ready to take
    a photo, we center the focus point of the camera to the middle of the screen.
    Then call the `NotifyOrientationChange` on the `CameraView` to update the renderer
    camera stream bounds and rotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the `HandleBusy` and `HandleLoading` functions, which simply
    set the `CameraLoading` property on the view-model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the `HandleShutter`, which will call the `NotifyShutter` method on
    the `CameraView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the `HandleFlash` function responsible for updating the `FlashOn`
    property of the view-model and calling the `NotifyFlash` method on the `CameraView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HandlePictureTaken` function is called every time the camera button is
    touched and data is received from the native camera. We then pass the byte array
    back to the view-model using the `AddPhoto` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Next we have the `HandleCameraAvailability` method, which is called when the
    native camera availability status changes. If the camera is available, we the
    set the view-model properties, assign the starting orientation, and set up `IsVisible`
    bindings on the camera button containers to the `PageOrientation` property of
    the view-model.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We must set up the `IsVisible` bindings after the camera has become available
    because a layout pass is not called on items that are invisible when the page
    is loaded. We need the height and width to be set on these items even if the items
    are invisible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Now we must add the `OnNavigatedTo` method. Here we will set a new binding on
    the `IsVisible` property of the `LoadingView`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, we must set the `IsVisible` binding after the page has done the layout
    so that the `LoadingView` bounds are set correctly according to the `Grid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also call the `SetFocusPoints` on the `FocusView` to set the starting
    focus points in both landscape and portrait. These starting points will be calculated
    from the height and width properties to get the center of the screen. Then we
    call `NotifyOpenCamera` to begin the process on the native camera to initialize
    it and open the camera. On only for iOS do we call the `NotifyWidths` method,
    so the widths of the button container are passed to the iOS native camera class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we have the `HandleDelete` method for removing the photo edit view
    and clearing the image bytes to free memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! We now have implemented our entire `CameraPage` and native camera
    implementation for iOS and Android.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have built almost everything in the `Camera.Portable` and `Camera` projects,
    but there are still pieces missing. Here is another challenge. Fill in the missing
    pieces of the solution and get it compiling The remaining files are the exact
    same from all our other `Xamarin.Forms` solutions, but now it is your turn to
    finish off the project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see the finished version, refer to [https://github.com/flusharcade/chapter8-camera](https://github.com/flusharcade/chapter8-camera).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built complete control over the native camera hardware for
    iOS and Android. We looked at implementing Grid changes using Converters, and
    built `CustomRenderers` for accessing native tinting features and touch events.
    We also created event triggers for buttons and `PlatformEffects` for creating
    shadow on a Label on the `MainPage`.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We have made it to the end of our Xamarin journey.
  prefs: []
  type: TYPE_NORMAL
