- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Using Logging to Identify Errors
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用日志来识别错误
- en: In this chapter, we will begin to learn about the logging tools that .NET provides
    us with. A logger is one of the tools that developers must use to debug an application
    or understand its failure in production. The log library has been built into ASP.NET
    with several features enabled by design. The purpose of this chapter is to delve
    into the things we take for granted and add more information as we go.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始了解.NET为我们提供的日志工具。日志器是开发者必须使用来调试应用程序或理解其在生产中的失败的工具之一。日志库已经内置到ASP.NET中，并启用了设计中的几个功能。本章的目的是深入探讨我们视为理所当然的事情，并在过程中添加更多信息。
- en: 'The themes we will touch on in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涉及的主题如下：
- en: Exploring logging in .NET
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索.NET中的日志记录
- en: Leveraging the logging framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用日志框架
- en: Storing a structured log with Serilog
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Serilog存储结构化日志
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As reported in the previous chapters, it will be necessary to have the .NET
    6 development framework.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，将需要 .NET 6 开发框架。
- en: There are no special requirements in this chapter for beginning to test the
    examples described.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始测试所描述的示例没有特殊要求。
- en: All the code samples in this chapter can be found in the GitHub repository for
    this book at [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter05](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter05).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都可以在本书的GitHub仓库中找到，网址为 [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter05](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter05)。
- en: Exploring logging in .NET
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索.NET中的日志记录
- en: '**ASP.NET Core** templates create a **WebApplicationBuilder** and a **WebApplication**,
    which provide a simplified way to configure and run web applications without a
    startup class.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**ASP.NET Core** 模板创建了一个 **WebApplicationBuilder** 和一个 **WebApplication**，这提供了一种简化配置和运行Web应用程序的方法，无需启动类。'
- en: As mentioned previously, with .NET 6, the `Startup.cs` file is eliminated in
    favor of the existing `Program.cs` file. All startup configurations are placed
    in this file, and in the case of **minimal APIs**, endpoint implementations are
    also placed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在 .NET 6 中，为了替代现有的 `Program.cs` 文件，删除了 `Startup.cs` 文件。所有启动配置都放置在这个文件中，在
    **最小API** 的情况下，端点实现也放置在这里。
- en: What we have just described is the starting point of every .NET application
    and its various configurations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的是每个.NET应用程序及其各种配置的起点。
- en: Logging into an application means tracking the evidence in different points
    of the code to check whether it is running as expected. The purpose of logging
    is to track over time all the conditions that led to an unexpected result or event
    in the application. Logging in an application can be useful both during development
    and while the application is in production.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志记录到应用程序中意味着跟踪代码不同点的证据，以检查其是否按预期运行。日志的目的是在时间上跟踪导致应用程序中出现意外结果或事件的全部条件。在开发期间以及应用程序在生产中时，应用程序中的日志记录都可能非常有用。
- en: 'However, for logging, as many as four providers are added for tracking application
    information:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于日志记录，为了跟踪应用程序信息，添加了多达四个提供者：
- en: '**Console**: The Console provider logs output to the console. This log is unusable
    in production because the console of a web application is usually not visible.
    This kind of log is useful during development to make logging fast when you are
    running your app under Kestrel on your desktop machine in the app console window.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台**：Console提供者将输出记录到控制台。这种日志在生产中不可用，因为Web应用程序的控制台通常不可见。这种类型的日志在开发期间很有用，当你在你桌面上运行应用程序时，可以在应用程序控制台窗口中快速记录日志。'
- en: '`System.Diagnostics.Debug` class. When we develop, we are used to seeing this
    section in the *Visual Studio* output window.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Diagnostics.Debug` 类。当我们开发时，我们习惯于在 *Visual Studio* 输出窗口中看到这个部分。'
- en: 'Under the Linux operating system, information is tracked depending on the distribution
    in the following locations: `/var/log/message` and `/var/log/syslog`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux操作系统下，信息根据发行版在以下位置进行跟踪：`/var/log/message` 和 `/var/log/syslog`。
- en: '**EventSource**: On Windows, this information can be viewed in the **EventTracing**
    window.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EventSource**：在Windows上，此信息可以在 **EventTracing** 窗口中查看。'
- en: '**EventLog** (only when running on Windows): This information is displayed
    in the native Windows window, so you can only see it if you run the application
    on the Windows operating system.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EventLog**（仅在Windows上运行时）：此信息显示在原生Windows窗口中，因此只有当你在Windows操作系统上运行应用程序时才能看到它。'
- en: A new feature in the latest .NET release
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最新.NET版本中的新功能
- en: New logging providers have been added in the latest versions of .NET. However,
    these providers are not enabled within the framework.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET的最新版本中添加了新的日志提供程序。然而，这些提供程序在框架内部并未启用。
- en: 'Use these extensions to enable new logging scenarios: `AddSystemdConsole`,
    `AddJsonConsole`, and `AddSimpleConsole`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些扩展来启用新的日志场景：`AddSystemdConsole`、`AddJsonConsole`和`AddSimpleConsole`。
- en: 'You can find more details on how to configure the log and what the basic ASP.NET
    settings are at this link: [https://docs.microsoft.com/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/aspnet/core/fundamentals/host/generic-host).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此链接中找到有关如何配置日志和基本ASP.NET设置更多详细信息：[https://docs.microsoft.com/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/aspnet/core/fundamentals/host/generic-host)。
- en: 'We’ve started to see what the framework gives us; now we need to understand
    how to leverage it within our applications. Before proceeding, we need to understand
    what a logging layer is. It is a fundamental concept that will help us break down
    information into different layers and enable them as needed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始看到框架为我们提供的内容；现在我们需要了解如何在我们的应用程序中利用它。在继续之前，我们需要了解什么是日志层。这是一个基本概念，它将帮助我们将信息分解为不同的层次，并在需要时启用它们：
- en: '![Table 5.1 – Log levels ](img/B17902_Table1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![表5.1 – 日志级别](img/B17902_Table1.jpg)'
- en: Table 5.1 – Log levels
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 – 日志级别
- en: '*Table 5.1* shows the most verbose levels down to the least verbose level.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*表5.1*显示了从最详细到最不详细的日志级别。'
- en: 'To learn more, you can read the article titled *Logging in .NET Core and ASP.NET
    Core*, which explains the logging process in detail here: [https://docs.microsoft.com/aspnet/core/fundamentals/logging](https://docs.microsoft.com/aspnet/core/fundamentals/logging/)/.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息，您可以阅读题为*在.NET Core和ASP.NET Core中的日志记录*的文章，该文章详细解释了这里的日志记录过程：[https://docs.microsoft.com/aspnet/core/fundamentals/logging](https://docs.microsoft.com/aspnet/core/fundamentals/logging)/。
- en: If we select our log level as `Information`, everything at this level will be
    tracked down to the `Critical` level, skipping `Debug` and `Trace`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将日志级别设置为`Information`，则此级别的所有内容都将追踪到`Critical`级别，跳过`Debug`和`Trace`。
- en: We’ve seen how to take advantage of the log layers; now, let’s move on to writing
    a single statement that will log information and can allow us to insert valuable
    content into the tracking system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何利用日志层；现在，让我们继续编写一个可以记录信息并允许我们将有价值的内容插入跟踪系统的单个语句。
- en: Configuring logging
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置日志
- en: To start using the logging component, you need to know a couple of pieces of
    information to start tracking data. Each logger object (`ILogger<T>`) must have
    an associated category. The log category allows you to segment the tracking layer
    with a high definition. For example, if we want to track everything that happens
    in a certain class or in an ASP.NET controller, without having to rewrite all
    our code, we need to enable the category or categories of our interest.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用日志组件，您需要了解一些信息以开始跟踪数据。每个日志对象（`ILogger<T>`）都必须有一个关联的类别。日志类别允许您以高分辨率分割跟踪层。例如，如果我们想跟踪某个类或ASP.NET控制器中发生的所有事件，而无需重写所有代码，我们需要启用我们感兴趣的类别或类别。
- en: A category is a `T` class. Nothing could be simpler. You can reuse typed objects
    of the class where the log method is injected. For example, if we’re implementing
    `MyService`, and we want to track everything that happens in the service with
    the same category, we just need to request an `ILogger<MyService>` object instance
    from the dependency injection engine.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 类别是一个`T`类。没有什么比这更简单了。您可以在注入日志方法所在的类中重用该类的类型化对象。例如，如果我们正在实现`MyService`，并且我们想使用相同的类别跟踪服务中发生的所有事件，我们只需从依赖注入引擎请求一个`ILogger<MyService>`对象实例。
- en: Once the log categories are defined, we need to call the `ILogger<T>` object
    and take advantage of the object’s public methods. In the previous section, we
    looked at the log layers. Each log layer has its own method for tracking information.
    For example, `LogDebug` is the method specified to track information with a `Debug`
    layer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了日志类别，我们需要调用`ILogger<T>`对象并利用对象的公共方法。在前一节中，我们探讨了日志层。每个日志层都有自己的信息跟踪方法。例如，`LogDebug`是用于跟踪`Debug`层信息的指定方法。
- en: 'Let’s now look at an example. I created a record in the `Program.cs` file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个例子。我在`Program.cs`文件中创建了一个记录：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This record is used to define a particular category of logs that I want to track
    only when necessary. To do this, it is advisable to define a class or a record
    as an end in itself and enable the necessary trace level.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此记录用于定义我想要仅在必要时跟踪的特定日志类别。为此，建议定义一个类或记录作为目的本身，并启用必要的跟踪级别。
- en: A record that is defined in the `Program.cs` file has no namespace; we must
    remember this when we define the `appsettings` file with all the necessary information.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中定义的记录没有命名空间；当我们定义包含所有必要信息的 `appsettings` 文件时，我们必须记住这一点。
- en: 'If the log category is within a namespace, we must consider the full name of
    the class. In this case, it is `LoggingSamples.Categories.MyCategoryAlert`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日志类别在命名空间内，我们必须考虑类的全名。在这种情况下，它是 `LoggingSamples.Categories.MyCategoryAlert`：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we do not specify the category, as in the following example, the selected
    log level is the default:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有指定类别，如以下示例所示，则选定的日志级别是默认的：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Anything that comprises infrastructure logs, such as Microsoft logs, stays in
    special categories such as `Microsoft.AspNetCore` or `Microsoft.EntityFrameworkCore`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 包括基础设施日志（如 Microsoft 日志）在内的任何内容都保留在特殊类别中，例如 `Microsoft.AspNetCore` 或 `Microsoft.EntityFrameworkCore`。
- en: 'The full list of Microsoft log categories can be found at the following link:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 日志类别的完整列表可以在以下链接中找到：
- en: '[https://docs.microsoft.com/aspnet/core/fundamentals/logging/#aspnet-core-and-ef-core-categories](https://docs.microsoft.com/aspnet/core/fundamentals/logging/#aspnet-core-and-ef-core-categories)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/aspnet/core/fundamentals/logging/#aspnet-core-and-ef-core-categories](https://docs.microsoft.com/aspnet/core/fundamentals/logging/#aspnet-core-and-ef-core-categories)'
- en: Sometimes, we need to define certain log levels depending on the tracking provider.
    For example, during development, we want to see all the information in the log
    console, but we only want to see errors in the log file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要根据跟踪提供者定义某些日志级别。例如，在开发期间，我们希望在日志控制台中看到所有信息，但只想在日志文件中看到错误。
- en: 'To do this, we don’t need to change the configuration code but just define
    its level for each provider. The following is an example that shows how everything
    that is tracked in the Microsoft categories is shown from the `Information` layer
    to the ones below it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们不需要更改配置代码，只需为每个提供者定义其级别即可。以下是一个示例，展示了在 Microsoft 类别中跟踪的所有内容是如何从 `Information`
    层级显示到其下层的：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we’ve figured out how to enable logging and how to filter the various
    categories, all that’s left is to apply this information to a minimal API.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何启用日志记录以及如何过滤各种类别，剩下要做的就是将这些信息应用到最小 API 中。
- en: 'In the following code, we inject two `ILogger` instances with different categories.
    This is not a common practice, but we did it to make the example more concrete
    and show how the logger works:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们注入了两个不同类别的 `ILogger` 实例。这不是一个常见的做法，但我们这样做是为了使示例更加具体，并展示日志记录器的工作原理：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding snippet, we inject two instances of the logger with different
    categories; each category tracks a single piece of information. The information
    is written according to a template that we will describe shortly. The effect of
    this example is that based on the level, we can show or disable the information
    displayed for a single category, without changing the code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们注入了两个具有不同类别的日志记录器实例；每个类别跟踪一条信息。信息是按照我们将简要描述的模板编写的。这个示例的效果是，基于级别，我们可以显示或禁用单个类别的信息显示，而无需更改代码。
- en: We started filtering the logo by levels and categories. Now, we want to show
    you how to define a template that will allow us to define a message and make it
    dynamic in some of its parts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始根据级别和类别过滤日志。现在，我们想向您展示如何定义一个模板，它将允许我们定义消息，并在其某些部分使其动态化。
- en: Customizing log message
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义日志消息
- en: 'The message field that is asked by the log methods is a simple string object
    that we can enrich and serialize through the logging frameworks in proper structures.
    The message is therefore essential to identify malfunctions and errors, and inserting
    objects in it can significantly help us to identify the problem:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 日志方法请求的消息字段是一个简单的字符串对象，我们可以通过日志框架以适当的结构丰富和序列化它。因此，消息对于识别故障和错误至关重要，在其中插入对象可以显著帮助我们识别问题：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The message template contains placeholders that interpolate content into the
    textual message.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 消息模板包含占位符，可以将内容插入到文本消息中。
- en: In addition to the text, it is necessary to pass the arguments to replace the
    placeholders. Therefore, the order of the parameters is valid but not the name
    of the placeholders for the substitution.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文本外，还需要传递参数以替换占位符。因此，参数的顺序是有效的，但不是替换占位符的名称。
- en: 'The result then considers the positional parameters and not the placeholder
    names:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将考虑位置参数，而不是占位符名称：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now you know how to customize log messages. Next, let us learn about infrastructure
    logging, which is essential while working in more complex scenarios.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何自定义日志消息。接下来，让我们了解基础设施日志记录，这在处理更复杂的场景时至关重要。
- en: Infrastructure logging
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施日志记录
- en: 'In this section, we want to tell you about a little-known and little-used theme
    within ASP.NET applications: the **W3C log**.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们想向您介绍 ASP.NET 应用程序中一个鲜为人知且很少使用的主题：**W3C 日志**。
- en: This log is a standard that is used by all web servers, not only **Internet
    Information Services** (**IIS**). It also works on NGINX and many other web servers
    and can be used on Linux, too. It is also used to trace various requests. However,
    the log cannot understand what happened inside the call.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此日志是一个所有网络服务器都使用的标准，不仅包括**互联网信息服务**（**IIS**）。它也适用于 NGINX 和许多其他网络服务器，并且可以在 Linux
    上使用。它还用于跟踪各种请求。然而，日志无法理解调用内部发生了什么。
- en: Thus, this feature focuses on the infrastructure, that is, how many calls are
    made and to which endpoint.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此功能侧重于基础设施，即调用次数以及调用哪些端点。
- en: In this section, we will see how to enable tracking, which, by default, is stored
    on a file. The functionality takes a little time to find but enables more complex
    scenarios that must be managed with appropriate practices and tools, such as **OpenTelemetry**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何启用跟踪，默认情况下，跟踪数据存储在文件中。该功能需要一点时间来查找，但可以启用更复杂的场景，这些场景必须使用适当的实践和工具来管理，例如
    **OpenTelemetry**。
- en: OpenTelemetry
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry
- en: 'OpenTelemetry is a collection of tools, APIs, and SDKs. We use it to instrument,
    generate, collect, and export telemetry data (metrics, logs, and traces) to help
    analyze software performance and behavior. You can learn more at the OpenTelemetry
    official website: [https://opentelemetry.io/](https://opentelemetry.io/).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 是一系列工具、API 和 SDK 的集合。我们使用它来对软件性能和行为进行仪表化、生成、收集和导出遥测数据（指标、日志和跟踪），以帮助分析软件性能和行为。您可以在
    OpenTelemetry 官方网站上了解更多信息：[https://opentelemetry.io/](https://opentelemetry.io/)。
- en: To configure W3C logging, you need to register the `AddW3CLogging` method and
    configure all available options.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 W3C 日志记录，您需要注册 `AddW3CLogging` 方法并配置所有可用选项。
- en: To enable logging, you only need to add `UseW3CLogging`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用日志记录，您只需添加 `UseW3CLogging`。
- en: 'The writing of the log does not change; the two methods enable the scenario
    just described and start writing data to the W3C log standard:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 日志的编写方式没有改变；这两种方法启用了前面描述的场景，并开始将数据写入 W3C 日志标准：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We report the header of the file that is created (the headers of the information
    will be tracked later):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们报告创建的文件头（信息头将在稍后跟踪）：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ve seen how to track information about the infrastructure hosting our application;
    now, we want to increase log performance with new features in .NET 6 that help
    us set up standard log messages and avoid errors.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何跟踪关于托管我们应用程序的基础设施的信息；现在，我们希望使用 .NET 6 中的新功能来提高日志性能，这些功能可以帮助我们设置标准日志消息并避免错误。
- en: Source generators
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源生成器
- en: One of the novelties of .NET 6 is the source generators; they are performance
    optimization tools that generate executable code at compile time. The creation
    of executable code at compile time, therefore, generates an increase in performance.
    During the execution phase of the program, all structures are comparable to code
    written by the programmer before compilation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 的一个新特性是源生成器；它们是性能优化工具，在编译时生成可执行代码。因此，在编译时生成可执行代码，从而提高了性能。在程序的执行阶段，所有结构都相当于编译前程序员编写的代码。
- en: 'String interpolation using `$””` is generally great, and it makes for much
    more readable code than `string.Format()`, but you should almost *never* use it
    when writing log messages:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `$””` 进行字符串插值通常很好，它比 `string.Format()` 编写的代码可读性更高，但您几乎**永远**不应该在编写日志消息时使用它：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of this method to the Console will be the same when using string
    interpolation or structural logging, but there are several problems:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法向控制台输出的结果在使用字符串插值或结构化日志记录时相同，但存在几个问题：
- en: You lose the *structured* logs and you won’t be able to filter by the format
    values or archive the log message in the custom field of NoSQL products.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会失去*结构化*日志，并且无法通过格式值进行筛选，也无法在NoSQL产品的自定义字段中存档日志消息。
- en: Similarly, you no longer have a constant *message template* to find all identical
    logs.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，你不再有一个常量*消息模板*来查找所有相同的日志。
- en: The serialization of the person is done ahead of time before the string is passed
    into `LogInformation`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将字符串传递到`LogInformation`之前，会提前进行人员的序列化。
- en: The serialization is done even though the log filter is not enabled. To avoid
    processing the log, it is necessary to check whether the layer is active, which
    would make the code much less readable.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使日志过滤器未启用，序列化操作仍然会进行。为了避免处理日志，有必要检查层是否处于活动状态，这将使代码的可读性大大降低。
- en: 'Let us say you decide to update the log message to include `Age` to clarify
    why the log is being written:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你决定更新日志消息以包含`Age`以明确为什么写入日志：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous code snippet, I added `Age` in the message template but not
    in the method signature. At compile time, there is no compile-time error, but
    when this line is executed, an exception is thrown due to the lack of a third
    parameter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我在消息模板中添加了`Age`，但没有在方法签名中添加。在编译时没有编译错误，但执行此行时，由于缺少第三个参数，会抛出异常。
- en: '`LoggerMessage` in .NET 6 comes to our rescue, automatically generating the
    code to log the necessary data. The methods will require the correct number of
    parameters and the text will be formatted in a standard way.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`.NET 6中的`LoggerMessage`为我们提供了帮助，自动生成记录必要数据的代码。这些方法将需要正确数量的参数，文本将以标准方式格式化。'
- en: 'To use the `LoggerMessage` syntax, you can take advantage of a partial class
    or a static class. Inside the class, it will be possible to define the method
    or methods with all the various log cases:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`LoggerMessage`语法，你可以利用部分类或静态类。在类内部，将可以定义具有所有各种日志情况的方法或方法：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the previous example, we created a partial class, injected the logger and
    its category, and implemented two methods. The methods are used in the following
    code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个部分类，注入了日志及其类别，并实现了两个方法。这些方法在以下代码中使用：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how in the second method, we also have the possibility to define the
    log level at runtime.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在第二个方法中，我们也有可能在运行时定义日志级别。
- en: 'Behind the scenes, the `[LoggerMessage]` source generator generates the `LoggerMessage.Define()` code
    to optimize your method call. The following output shows the generated code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`[LoggerMessage]`源生成器会生成`LoggerMessage.Define()`代码以优化你的方法调用。以下输出显示了生成的代码：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this section, you have learned about some logging providers, different log
    levels, how to configure them, what parts of the message template to modify, enabling
    logging, and the benefits of source generators. In the next section, we will focus
    more on logging providers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了一些日志提供程序、不同的日志级别、如何配置它们、要修改的消息模板部分、启用日志以及源生成器的优势。在下一节中，我们将更多地关注日志提供程序。
- en: Leveraging the logging framework
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用日志框架
- en: The logging framework, as mentioned at the beginning of the chapter, already
    has by design a series of providers that do not require adding any additional
    packages. Now, let us explore how to work with these providers and how to build
    custom ones. We will analyze only the Console log provider because it has all
    the sufficient elements to replicate the same reasoning on other log providers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，日志框架已经设计了一系列不需要添加任何额外包的提供程序。现在，让我们探索如何使用这些提供程序以及如何构建自定义提供程序。我们将仅分析控制台日志提供程序，因为它具有复制到其他日志提供程序上的相同推理所需的所有足够元素。
- en: Console log
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制台日志
- en: The `Console` log provider is the most used one because, during the development,
    it gives us a lot of information and collects all the application errors.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console`日志提供程序是最常用的一个，因为在开发过程中，它为我们提供了大量信息，并收集了所有应用程序错误。'
- en: Since .NET 6, this provider has been joined by the `AddJsonConsole` provider,
    which, besides tracing the errors like the console, serializes them in a JSON
    object readable by the human eye.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 自.NET 6以来，此提供程序已由`AddJsonConsole`提供程序加入，除了像控制台一样跟踪错误之外，它还将它们序列化为人类可读的JSON对象。
- en: 'In the following example, we show how to configure the `JsonConsole` provider
    and also add indentation when writing the JSON payload:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们展示了如何配置`JsonConsole`提供程序，并在写入JSON有效负载时添加缩进：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As we’ve seen in the previous examples, we’re going to track the information
    with the message template:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的示例中所看到的，我们将使用消息模板来跟踪信息：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, an important note: the `Console` and `JsonConsole` providers do not
    serialize objects passed via the message template but only write the class name.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个重要的注意事项：`Console`和`JsonConsole`提供程序不会序列化通过消息模板传递的对象，而只写入类名。
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is definitely a limitation of providers. Thus, we suggest using structured
    logging tools such as **NLog**, **log4net**, and **Serilog**, which we will talk
    about shortly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是提供程序的一个限制。因此，我们建议使用结构化日志工具，如**NLog**、**log4net**和**Serilog**，我们将在稍后讨论。
- en: 'We present the outputs of the previous lines with the two providers just described:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了之前几行中两个提供程序的输出：
- en: '![Figure 5.1 – AddJsonConsole output ](img/Figure_5.1_B17902.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – AddJsonConsole 输出](img/Figure_5.1_B17902.jpg)'
- en: Figure 5.1 – AddJsonConsole output
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – AddJsonConsole 输出
- en: '*Figure 5.1* shows the log formatted as JSON, with several additional details
    compared to the traditional console log.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.1* 展示了格式化为JSON的日志，与传统控制台日志相比，包含了一些额外的细节。'
- en: '![Figure 5.2 – Default logging provider Console output ](img/Figure_5.2_B17902.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 默认日志提供程序 Console 输出](img/Figure_5.2_B17902.jpg)'
- en: Figure 5.2 – Default logging provider Console output
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 默认日志提供程序 Console 输出
- en: '*Figure 5.2* shows the default logging provider Console output.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.2* 展示了默认日志提供程序`Console`的输出。'
- en: Given the default providers, we want to show you how you can create a custom
    one that fits the needs of your application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认提供程序的情况下，我们想向您展示如何创建一个符合您应用程序需求的自定义提供程序。
- en: Creating a custom provider
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义提供程序
- en: The logging framework designed by Microsoft can be customized with little effort.
    Thus, let us learn how to create a **custom provider**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 微软设计的日志框架可以轻松地进行定制。因此，让我们学习如何创建一个**自定义提供程序**。
- en: Why create a custom provider? Well, put simply, to not have dependencies with
    logging libraries and to better manage the performance of the application. Finally,
    it also encapsulates some custom logic of your specific scenario and makes your
    code more manageable and readable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要创建自定义提供程序？简单来说，是为了避免与日志库的依赖关系，并更好地管理应用程序的性能。最后，它还封装了特定场景的一些自定义逻辑，使代码更易于管理和阅读。
- en: In the following example, we have simplified the usage scenario to show you
    the minimum components needed to create a working logging provider for profit.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用场景简化，以向您展示创建一个用于盈利的日志提供程序所需的最小组件。
- en: One of the fundamental parts of a provider is the ability to configure its behavior.
    Let us create a class that can be customized at application startup or retrieve
    information from `appsettings`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 提供程序的一个基本部分是能够配置其行为。让我们创建一个可以在应用程序启动时进行自定义或从`appsettings`中检索信息的类。
- en: 'In our example, we define a fixed `EventId` to verify a daily rolling file
    logic and a path of where to write the file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们定义了一个固定的`EventId`来验证每日滚动文件逻辑以及文件的写入路径：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The custom provider we are writing will be responsible for writing the log information
    to a text file. We achieve this by implementing the log class, which we call `FileLogger`,
    which implements the `ILogger` interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写的自定义提供程序将负责将日志信息写入文本文件。我们通过实现名为`FileLogger`的日志类，该类实现了`ILogger`接口，来实现这一点。
- en: In the class logic, all we do is implement the log method and check which file
    to put the information in.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在类逻辑中，我们所做的只是实现日志方法并检查将信息放入哪个文件。
- en: 'We put the directory verification in the next file, but it’s more correct to
    put all the control logic in this method. We also need to make sure that the log
    method does not throw exceptions at the application level. The logger should never
    affect the stability of the application:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将目录验证放在下一个文件中，但更正确的方法是将所有控制逻辑放在这个方法中。我们还需要确保日志方法不会在应用程序级别抛出异常。日志记录器永远不应该影响应用程序的稳定性：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we need to implement the `ILoggerProvider` interface, which is intended
    to create one or more instances of the logger class just discussed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现`ILoggerProvider`接口，该接口旨在创建一个或多个之前讨论过的日志类实例。
- en: 'In this class, we check the directory we mentioned in the previous paragraph,
    but we also check whether the settings in the `appsettings` file change, via `IOptionsMonitor<T>`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，我们检查了上一段提到的目录，同时也检查了`appsettings`文件中的设置是否发生变化，这是通过`IOptionsMonitor<T>`实现的：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, to simplify its use and configuration during the application startup
    phase, we also define an extension method for registering the various classes
    just mentioned.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了简化在应用程序启动阶段的使用和配置，我们还定义了一个扩展方法来注册前面提到的各种类。
- en: 'The `AddFile` method will register `ILoggerProvider` and couple it to its configuration
    (very simple as an example, but it encapsulates several aspects of configuring
    and using a custom provider):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddFile`方法将注册`ILoggerProvider`并将其与其配置（作为一个例子非常简单，但它封装了配置和使用自定义提供者的几个方面）相关联：'
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We record everything seen in the `Program.cs` file with the `AddFile` extension
    as shown:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`AddFile`扩展记录了`Program.cs`文件中看到的所有内容，如下所示：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is shown in *Figure 5.3*, where we can see both Microsoft log categories
    in the first five lines (this is the classic application startup information):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在*图5.3*中，我们可以看到前五行中的Microsoft日志类别（这是经典的应用程序启动信息）：
- en: '![Figure 5.3 – File log provider output ](img/Figure_5.3_B17902.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 文件日志提供者输出](img/Figure_5.3_B17902.jpg)'
- en: Figure 5.3 – File log provider output
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 文件日志提供者输出
- en: Then, the handler of the minimal APIs that we reported in the previous sections
    is called. As you can see, no exception data or data passed to the logger is serialized.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用前面章节中报告的最小API的处理程序。正如你所看到的，没有异常数据或传递给记录器的数据被序列化。
- en: To add this functionality as well, it is necessary to rewrite `ILogger formatter`
    and support serialization of the object. This will give you everything you need
    to have in a useful logging framework for production scenarios.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加此功能，还需要重写`ILogger formatter`并支持对象的序列化。这将为你提供一个有用的日志框架，适用于生产场景。
- en: We’ve seen how to configure the log and how to customize the provider object
    to create a structured log to send to a service or storage.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何配置日志以及如何自定义提供者对象以创建结构化日志发送到服务或存储。
- en: In the next section, we want to describe the Azure Application Insights service,
    which is very useful for both logging and application monitoring.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们想要描述Azure Application Insights服务，这对于日志记录和应用程序监控都非常有用。
- en: Application Insights
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Application Insights
- en: 'In addition to the already seen providers, one of the most used ones is **Azure
    Application Insights**. This provider allows you to send every single log event
    in the Azure service. In order to insert the provider into our project, all we
    would have to do is install the following NuGet package:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经看到的提供者之外，最常用的之一是**Azure Application Insights**。这个提供者允许你发送Azure服务中的每一个日志事件。为了将提供者插入到我们的项目中，我们只需要安装以下NuGet包：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Registering the provider is very easy.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注册提供者非常简单。
- en: We first register the Application Insights framework, `AddApplicationInsightsTelemetry`,
    and then register its extension on the `AddApplicationInsights` logging framework.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先注册Application Insights框架，`AddApplicationInsightsTelemetry`，然后在其`AddApplicationInsights`日志框架上注册其扩展。
- en: 'In the NuGet package previously described, the one for logging the component
    to the logging framework is also present as a reference:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面描述的NuGet包中，用于将组件记录到日志框架的那个包也作为参考存在：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To register the instrumentation key, which is the key that is issued after
    registering the service on Azure, you will need to pass this information to the
    registration method. We can avoid hardcoding this information by placing it in
    the `appsettings.json` file using the following format:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册仪表化密钥，这是在Azure上注册服务后发放的密钥，你需要将此信息传递给注册方法。我们可以通过将信息放在`appsettings.json`文件中以以下格式来避免硬编码此信息：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This process is also described in the documentation ([https://docs.microsoft.com/it-it/azure/azure-monitor/app/asp-net-core#enable-application-insights-server-side-telemetry-no-visual-studio](https://docs.microsoft.com/it-it/azure/azure-monitor/app/asp-net-core#enable-application-insights-server-side-telemetry-no-visual-studio)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程也在文档中有所描述（[https://docs.microsoft.com/it-it/azure/azure-monitor/app/asp-net-core#enable-application-insights-server-side-telemetry-no-visual-studio](https://docs.microsoft.com/it-it/azure/azure-monitor/app/asp-net-core#enable-application-insights-server-side-telemetry-no-visual-studio)）。
- en: By launching the method already discussed in the previous sections, we have
    all the information hooked into Application Insights.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动前面章节中讨论的方法，我们已经将所有信息连接到Application Insights。
- en: Application Insights groups the logs under a particular trace. A trace is a
    call to an API, so everything that happens in that call is logically grouped together.
    This feature takes advantage of the `WebServer` information and, in particular,
    `TraceParentId` issued by the W3C standard for each call.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Application Insights 将日志分组在特定的跟踪之下。跟踪是对 API 的调用，因此在该调用中发生的所有事情在逻辑上都被分组在一起。这个功能利用了
    `WebServer` 信息，特别是 W3C 标准为每个调用发布的 `TraceParentId`。
- en: In this way, Application Insights can bind calls between various minimal APIs,
    should we be in a microservice application or with multiple services collaborating
    with each other.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，Application Insights 就可以绑定各种最小 API 之间的调用，无论是我们处于微服务应用程序中还是多个服务相互协作。
- en: '![Figure 5.4 – Application Insights with a standard log provider ](img/Figure_5.4_B17902.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 使用标准日志提供程序的 Application Insights](img/Figure_5.4_B17902.jpg)'
- en: Figure 5.4 – Application Insights with a standard log provider
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 使用标准日志提供程序的 Application Insights
- en: We notice how the default formatter of the logging framework does not serialize
    the `PayloadData` object but only writes the text of the object.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，日志框架的默认格式化程序并没有序列化 `PayloadData` 对象，而只是写出了对象的文本。
- en: In the applications that we will bring into production, it will be necessary
    to also trace the serialization of the objects. Understanding the state of the
    object on time is fundamental to analyzing the errors that occurred during a particular
    call while running queries in the database or reading the data read from the same.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将投入生产的应用程序中，还需要跟踪对象的序列化。及时了解对象的状态对于分析在数据库中运行查询或读取从同一数据源读取的数据时发生的特定调用中的错误至关重要。
- en: Storing a structured log with Serilog
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Serilog 存储结构化日志
- en: As we just discussed, tracking structured objects in the log helps us tremendously
    in understanding errors.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才讨论的，在日志中跟踪结构化对象极大地帮助我们理解错误。
- en: 'We, therefore, suggest one of the many logging frameworks: **Serilog**.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们建议使用众多日志框架之一：**Serilog**。
- en: Serilog is a comprehensive library that has many **sinks** already written that
    allow you to store log data and search it later.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Serilog 是一个综合性的库，已经编写了许多 **接收器**，允许您存储日志数据并在以后搜索它。
- en: Serilog is a logging library that allows you to track information on multiple
    data sources. In Serilog, these sources are called sinks, and they allow you to
    write structured data inside the log applying a serialization of the data passed
    to the logging system.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Serilog 是一个日志库，允许您跟踪多个数据源上的信息。在 Serilog 中，这些源被称为接收器，它们允许您在日志中写入结构化数据，并应用传递给日志系统的数据的序列化。
- en: 'Let’s see how to get started using Serilog for a minimal API application. Let’s
    install these NuGet packages. Our goal will be to track the same information we’ve
    been using so far, specifically `Console` and `ApplicationInsights`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何开始使用 Serilog 为最小 API 应用程序。让我们安装这些 NuGet 包。我们的目标将是跟踪我们迄今为止一直在使用的信息，具体是
    `Console` 和 `ApplicationInsights`：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first package is the one needed for the `ApplicationInsights` SDK in the
    application. The second package allows us to register Serilog in the ASP.NET pipeline
    and to be able to exploit Serilog. The third package allows us to configure the
    framework in the `appsettings` file and not have to rewrite the application to
    change a parameter or code. Finally, we have the package to add the `ApplicationInsights`
    sink.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包是应用程序中 `ApplicationInsights` SDK 所需的包。第二个包允许我们在 ASP.NET 管道中注册 Serilog 并能够利用
    Serilog。第三个包允许我们在 `appsettings` 文件中配置框架，而无需重写应用程序来更改参数或代码。最后，我们有添加 `ApplicationInsights`
    接收器的包。
- en: 'In the `appsettings` file, we create a new `Serilog` section, in which we should
    register the various sinks in the `Using` section. We register the log level,
    the sinks, the enrichers that enrich the information for each event, and the properties,
    such as the application name:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `appsettings` 文件中，我们创建一个新的 `Serilog` 部分，在 `Using` 部分中注册各种接收器。我们注册了日志级别、接收器、丰富每个事件信息的丰富器以及如应用程序名称之类的属性：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we just have to register `Serilog` in the ASP.NET pipeline:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需在 ASP.NET 管道中注册 `Serilog`：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With the `builder.Logging.AddSerilog()` statement, we register Serilog with
    the logging framework to which all logged events will be passed with the usual
    `ILogger` interface. Since the framework needs to register the `TelemetryConfiguration`
    class to register `ApplicationInsights`, we are forced to hook the configuration
    to the static `Logger` object of Serilog. This is all because Serilog will turn
    the information from the Microsoft logging framework over to the Serilog framework
    and add all the necessary information.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`builder.Logging.AddSerilog()`语句，我们将Serilog注册到日志框架中，所有已记录的事件将通过常规的`ILogger`接口传递。由于框架需要注册`TelemetryConfiguration`类以注册`ApplicationInsights`，我们被迫将配置钩子连接到Serilog的静态`Logger`对象。这一切都是因为Serilog会将来自Microsoft日志框架的信息转换为Serilog框架，并添加所有必要的信息。
- en: The usage is very similar to the previous one, but this time, we add an `@`
    (at) to the message template that will tell Serilog to serialize the sent object.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法与之前类似，但这次我们在消息模板中添加了一个`@`（在）符号，这将告诉Serilog序列化发送的对象。
- en: 'With this very simple `{@Person}` wording, we will be able to achieve the goal
    of serializing the object and sending it to the `ApplicationInsights` service:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个非常简单的`{@Person}`表述，我们将能够实现序列化对象并将其发送到`ApplicationInsights`服务的目标：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, we have to find the complete data, serialized with the JSON format,
    in the Application Insights service.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在Application Insights服务中找到完整的数据，这些数据以JSON格式序列化。
- en: '![Figure 5.5 – Application Insights with structured data ](img/Figure_5.5_B17902.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 带有结构化数据的Application Insights](img/Figure_5.5_B17902.jpg)'
- en: Figure 5.5 – Application Insights with structured data
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 带有结构化数据的Application Insights
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen several logging aspects of the implementation
    of minimal APIs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了最小API实现中的一些日志方面。
- en: We started to appreciate the ASP.NET churned logging framework, and we understood
    how to configure and customize it. We focused on how to define a message template
    and how to avoid errors with the source generator.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始欣赏ASP.NET生成的日志框架，并了解了如何配置和自定义它。我们关注了如何定义消息模板以及如何避免使用源生成器时的错误。
- en: We saw how to use the new provider to serialize logs with the JSON format and
    create a custom provider. These elements turned out to be very important for mastering
    the logging tool and customizing it to your liking.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用新的提供程序以JSON格式序列化日志并创建自定义提供程序。这些元素最终证明对于掌握日志工具并按您的喜好进行自定义非常重要。
- en: Not only was the application log mentioned but also the infrastructure log,
    which together with Application Insights becomes a key element to monitoring your
    application. Finally, we understood that there are ready-made tools, such as Serilog,
    that help us to have ready-to-use functionalities with a few steps thanks to some
    packages installed by NuGet.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅提到了应用程序日志，还提到了基础设施日志，这两者与Application Insights结合，成为监控应用程序的关键元素。最后，我们了解到有一些现成的工具，如Serilog，通过NuGet安装的一些包，只需几步就能提供现成的功能。
- en: In the next chapter, we will present the mechanisms for validating an input
    object to the API. This is a fundamental feature to return a correct error to
    the calls and discard inaccurate requests or those promoted by illicit activities
    such as spam and attacks, aimed at generating load on our servers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍验证API输入对象的机制。这是返回正确错误给调用并丢弃不准确请求或由垃圾邮件和攻击等非法活动推动的请求的基本功能，这些活动旨在对我们的服务器产生负载。
