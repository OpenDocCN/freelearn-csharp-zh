- en: Implementing Code Reusability in C# 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code reusability is one of the most important topics in software architecture.
    This chapter aims to discuss ways to enable code reuse and understand how .NET
    Standard goes in this direction to solve the problem of managing and maintaining
    a reusable library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the principles of code reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of working with .NET Standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: You need Visual Studio 2017 or the 2019 free community edition or better with
    all the database tools installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A free Azure account: The *Creating an Azure Account* section in [Chapter 1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding
    the Importance of Software Architecture*, explains how to create one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An Azure DevOps account: The *What is Azure DevOps?* section in [Chapter 3](bc26065f-b001-4123-9524-3bbfa87bfadd.xhtml), *Documenting
    Requirements with Azure DevOps*, explains how to create one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will find the sample code of this chapter at [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch11](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch11).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the principles of code reusability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a single reason that you can always use to justify code reuse—you cannot
    spend your valuable time recreating the wheel if it is already running well in
    other scenarios. That is why most engineering domains are based on reusability
    principles. Think about the light switch you have in your house.
  prefs: []
  type: TYPE_NORMAL
- en: Can you imagine the number of applications that can be made with the same interface
    components? The fundamentals of code reuse are the same. Again, it is a matter
    of planning a good solution so part of it can be reused later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In software engineering, code reuse is one of the techniques that can bring
    to software project a bunch of advantages, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: There's confidence in the software, considering that the reused piece of code
    was already tested in another application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's better usage of software architects since they can be dedicated to solving
    this kind of problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's the possibility of bringing to the project a pattern that's already accepted
    by the market
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development speed goes up due to the already implemented components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintenance is easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These aspects indicate that code reuse shall be done whenever it is possible.
    It is your responsibility, as a software architect, to ensure the preceding advantages
    and, more than that, to incentivize your team to enable reuse in the software
    they are creating.
  prefs: []
  type: TYPE_NORMAL
- en: What is not code reuse?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you have to understand is that code reuse does not mean copying
    and pasting code from one class to another. Even if this code was written by another
    team or project, this does not indicate you are properly working with reusability
    principles. Let's imagine a scenario that we will find in this book's use case,
    the WWTravelClub evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project scenario, you may want to evaluate different kinds of subjects,
    such as the Package, Destination Expert, City, Comments, and so on. The process
    for getting the evaluation average is the same, no matter which subject you are
    referring to. Due to this, you may want to *enable* reuse by copying and pasting
    the code for each evaluation. The (bad) result will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e162496d-58fb-41be-a669-778be8f1316d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the process for calculating the evaluation average
    is decentralized, which means that the same code will be duplicated in different
    classes. This will cause a lot of trouble, especially if the same approach starts
    happening in other applications. For instance, if there is a new specification
    about how you have to calculate the average or if you just get a bug in the calculation
    formula, you will have to fix it in all instances of code.
  prefs: []
  type: TYPE_NORMAL
- en: What is code reuse?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution to the problem mentioned in the last section is quite simple.
    You have to analyze your code and select the parts of it that it would be a good
    idea to decouple from your application. The greatest reason why you should decouple
    it is related to how you are sure that this code can be reused in other parts
    of the application or even in another application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb4e6ffc-dda0-4379-847f-24cbfa7ded04.png)'
  prefs: []
  type: TYPE_IMG
- en: The centralization of the code brings to you, as a software architect, a different
    responsibility for it. You will have to keep in mind that a bug or an incompatibility
    of this code can cause damage to many parts of the application or different applications.
    On the other hand, once you have this code tested and running, you will be able
    to propagate its usage with no worries. Besides, if you need to evolve the average
    calculation process, you will have to change the code in a single class.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that the more you use the same code, the cheaper this
    development will become. Cost needs to be mentioned because, in general, the conception
    of reusable software costs more in the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting reusability into your development cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you understood that reusability will take you to another level of code implementation,
    you should have been thinking about how to make this technique available in your
    development cycle. As a matter of fact, creating and maintaining a component library
    is not very easy, due to the responsibility you will have and the lack of good
    tools to support the search for existent components.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, there are some things that you may consider implementing
    in your software development process every time you initiate a new development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use** already implemented components from your user library, selecting features in
    the software requirements specification that need them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identify **features in the software requirements specification that are candidates
    to be designed as library components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modify** the specification considering that these features will be developed
    using reusable components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design** the reusable components and be sure that they have the appropriate
    interfaces to be used in many projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build** the project architecture with the new component library version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document** the component library version so every developer and team knows
    about it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *use-identify-modify-design-build* process is a technique that you may consider
    implement every time you need to enable software reuse. As soon as you have the
    components you need to write for this library, you will need to decide on the
    technology that will provide these components.
  prefs: []
  type: TYPE_NORMAL
- en: During the history of software development, there were many approaches for doing
    this; some of them are discussed in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml),
    *Applying a Microservice Architecture to Your Enterprise Application*, in the
    *Microservices as the evolution of the concept of modul**e* section.
  prefs: []
  type: TYPE_NORMAL
- en: Using .NET Standard for code reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET has evolved a lot since its first version. This evolution is not only related
    to the number of commands and performance issues, but the supported platforms
    too. As discussed in [Chapter 1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding
    the Importance of Software Architecture*, you can run C# .NET in billions of devices,
    even if they are running Linux, Android, macOS, or iOS. For this reason, .NET
    Standard was first announced together with .NET Core 1.0, but the breaking changes
    happened with .NET Standard 2.0, when .NET Framework 4.6, .NET Core, and Xamarin
    were compatible with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key point is that .NET Standard is not only a kind of Visual Studio project.
    More than that, it is a formal specification available to all .NET implementations.
    As you can see in the following table, it covers everything from the .NET Framework
    to Unity ([https://github.com/dotnet/standard/tree/master/docs/versions](https://github.com/dotnet/standard/tree/master/docs/versions)):'
  prefs: []
  type: TYPE_NORMAL
- en: '| .NET Standard | 1.0 | 1.1 | 1.2 | 1.3 | 1.4 | 1.5 | 1.6 | 2.0 | 2.1 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Core | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 2.0 | 3.0 |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Framework | 4.5 | 4.5 | 4.5.1 | 4.6 | 4.6.1 | 4.6.1¹ | 4.6.1¹ | 4.6.1¹
    | N/A² |'
  prefs: []
  type: TYPE_TB
- en: '| Mono | 4.6 | 4.6 | 4.6 | 4.6 | 4.6 | 4.6 | 4.6 | 5.4 | 6.2 |'
  prefs: []
  type: TYPE_TB
- en: '| Xamarin.iOS | 10.0 | 10.0 | 10.0 | 10.0 | 10.0 | 10.0 | 10.0 | 10.14 | 12.12
    |'
  prefs: []
  type: TYPE_TB
- en: '| Xamarin.Mac | 3.0 | 3.0 | 3.0 | 3.0 | 3.0 | 3.0 | 3.0 | 3.8 | 5.12 |'
  prefs: []
  type: TYPE_TB
- en: '| Xamarin.Android | 7.0 | 7.0 | 7.0 | 7.0 | 7.0 | 7.0 | 7.0 | 8.0 | 9.3 |'
  prefs: []
  type: TYPE_TB
- en: '| Unity | 2018.1 | 2018.1 | 2018.1 | 2018.1 | 2018.1 | 2018.1 | 2018.1 | 2018.1
    | TBD |'
  prefs: []
  type: TYPE_TB
- en: '| Universal Windows Platform | 8.0 | 8.0 | 8.1 | 10.0 | 10.0 | 10.0.16299 |
    10.0.16299 | 10.0.16299 | TBD |'
  prefs: []
  type: TYPE_TB
- en: The preceding table indicates that if you build a class library that's compatible
    with this standard, you will be able to reuse it in any of the platforms presented.
    Think about how fast your development process can become if you plan to do so
    in all your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, some components are not included in .NET Standard, but its evolution
    is continuous. It is worth mentioning that Microsoft's official documentation
    indicates that *the higher the version, the more APIs are available to you*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .NET Standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is quite simple to create a class library compatible with .NET Standard.
    Basically, you need to choose the following project when creating the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00882bf3-8b23-4eae-9648-94bd40168c5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have concluded this part, you will notice that the only difference
    between a common class library and the one you created is the target framework
    defined in the project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As soon as your project is loaded, you can start coding the classes that you
    intend to reuse. The advantage of building reusable classes using this approach
    is that you will be able to reuse the written code in all of the project types
    we checked before. On the other hand, you will find out that some APIs that are
    available in .NET Framework do not exist in this type of project. You can follow
    the future of the standard at [https://github.com/dotnet/standard/tree/master/docs/planning/netstandard-2.1](https://github.com/dotnet/standard/tree/master/docs/planning/netstandard-2.1).
  prefs: []
  type: TYPE_NORMAL
- en: How does C# deal with code reuse?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many approaches where C# helps us deal with code reuse. The ability
    to build libraries, as we checked in the last topic, is one of them. The most
    important one is the fact that the language is object-oriented. Besides, it is
    worth mentioning the facilities that generics brought to C# language. This topic
    will discuss the last two mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The object-oriented analysis approach gives us the ability to reuse code in
    different ways, from the facility of inheritance to the changeability of polymorphism.
    Complete adoption of object-oriented programming. will let you implement abstraction
    and encapsulation too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot presents using the object-oriented approach to make
    reuse easier. As you can see, there are different ways to calculate the grades
    of an evaluation, considering you can be a basic or a prime user of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b8c4c20-f04e-4b81-a553-3305d15e75c4.png)'
  prefs: []
  type: TYPE_IMG
- en: There are two aspects to be analyzed as code reuse in this design. The first
    is that there's no need to declare the properties in each child class since inheritance
    is doing it for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second is the opportunity we have to use polymorphism, enabling different
    behaviors for the same method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check in the preceding code the usage of the polymorphism principle,
    where the calculation of evaluation for prime users will increase by 20%. Now,
    take a look at how easy it is to call different objects inherited by the same
    class. Since the collection content implements the same interface, `IContentEvaluated`,
    it can have basic and prime users too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Object-oriented adoption can be considered mandatory when using C#. However,
    more specific usage will need study and practice. You, as a software architect,
    shall always incentivize your team to study object-oriented analysis. The more
    they have good abstraction abilities, the easier code reuse will become.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics were introduced in C# in version 2.0, and it is definitely considered
    an approach that increases code reuse. It also maximizes type safety and performance.
  prefs: []
  type: TYPE_NORMAL
- en: The basic principle of generics is that you can define in an interface, class,
    method, property, event, delegate, or even a placeholder that will be replaced
    with a specific type at a later time when one of the preceding entities will be
    used. The opportunity you have with this feature is incredible since you can use
    the same code to run different versions of the type, generically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a modification of `EvaluationService`, which was presented
    in the last section. The idea here is to enable the generalization of the service,
    giving the opportunity to define the goal of evaluation since its creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This declaration indicates that any class that implements the `IContentEvaluaded` interface can
    be used for this service. Besides, the service will be responsible for creating
    the evaluated content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code implements exactly the evaluated content created since the
    construction of the service. This code uses `System.Reflection` and the generic
    definition from the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth mentioning that this code will work because all of the classes
    are in the same assembly. The result of this modification can be checked in the
    instance creation of the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The good news is that now you have a generic service that will automatically
    instantiate the list object with the evaluations of the content you need. It worth
    mentioning that generics obviously will need more time dedicated to the first
    project construction. However, after the design is done, you will have a good,
    fast, and easy-to-maintain code. This is what we call reuse!
  prefs: []
  type: TYPE_NORMAL
- en: Use case – reusing code as a fast track to deliver good and safe software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final design of the solution for evaluating content for WWTravelClub can
    be checked as follows. This approach consists of the usage of many topics that
    were discussed in this chapter. First, all of the code is placed in a .NET Standard
    class library. This means that you can add this code to different types of solutions,
    such as .NET Core web apps and Xamarin apps for the Android and iOS platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68fc31e7-4bde-409d-a30a-b6f1d2d55f2c.png)'
  prefs: []
  type: TYPE_IMG
- en: This design makes use of object-oriented principles such as inheritance, so
    you do not need to write properties and methods more than once that can be used
    in many classes; and polymorphism, so that you can change the behavior of the
    code without changing the name of the method.
  prefs: []
  type: TYPE_NORMAL
- en: To finish, the design abstracts the idea of the content by introducing generics
    as a tool that can facilitate the manipulation of similar classes, such as the
    ones we have in WWTravelClub to evaluate contents regarding cities, comments,
    destination experts, and travel packages.
  prefs: []
  type: TYPE_NORMAL
- en: The big difference between a team that incentivizes code reuse and one that
    does not is the velocity of delivering good software to end users. Of course,
    beginning this approach is not easy, but rest assured that you will get good results
    after some time working with it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter aimed to help you understand the advantages of code reuse. It also
    gave you an idea about what is not properly reused code. This chapter also presented
    approaches for reusing code.
  prefs: []
  type: TYPE_NORMAL
- en: Considering that technology without process does not take you anywhere, a process
    was presented to enable code reuse. This process is related to using already finished components
    from your library; identifying features in the software requirements specification
    that are candidates to be designed as library components; modifying the specification
    considering these features; designing the reusable components; and building the
    project architecture with the new component library version.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish, this chapter presented .NET Standard libraries as an approach to
    reuse code for different C # platforms, reinforced the principles of object-oriented
    programming as a way to reuse code, and presented generics as a sophisticated
    implementation to simplify the treatment of objects with the same characteristics. In
    the next chapter, we will be seeing how to apply **service-oriented architecture**
    (**SOA**) with .NET Core.'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that SOA is considered a way to implement code reuse
    in sophisticated environments.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can copy-and-paste be considered code reuse? What are the impacts of this approach?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you make use of code reuse without copying and pasting code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there a process that can help code reuse?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between .NET Standard and .NET Core?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of creating a .NET Standard library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does object-oriented analysis help with code reuse?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do generics help with code reuse?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are some books and websites where you will find more information about
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Clean Architecture: A Craftsman''s Guide to Software Structure and Design*
    by Martin, Robert C. Pearson Education, 2018.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erica Gamma
    [et al.] Addison-Wesley, 1994.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Principles and Design Patterns* by Robert C. Martin, 2000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/introducing-net-standard/](https://devblogs.microsoft.com/dotnet/introducing-net-standard/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/net-standard-20-cookbook](https://www.packtpub.com/application-development/net-standard-20-cookbook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/dotnet/standard/blob/master/docs/versions.md](https://github.com/dotnet/standard/blob/master/docs/versions.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
