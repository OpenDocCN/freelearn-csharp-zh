<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Asynchronous Programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Asynchronous Programming</h1></div></div></div><p>This chapter deep-dives into the <a class="indexterm" id="id114"/>asynchronous and multithreaded programming concepts. We will discuss platform-specific problems and give an in-depth description of how threading scenarios are executed on different platforms. The chapter is divided into following sections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Multithreading on Xamarin</li><li class="listitem" style="list-style-type: disc">Asynchronous methods</li><li class="listitem" style="list-style-type: disc">Parallel execution</li><li class="listitem" style="list-style-type: disc">Patterns and best practices</li><li class="listitem" style="list-style-type: disc">Background tasks</li></ul></div><div class="section" title="Multithreading on Xamarin"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Multithreading on Xamarin</h1></div></div></div><p>Xamarin <a class="indexterm" id="id115"/>platforms together with Windows Runtime follow the basic principles of a single-threaded apartment model. In this model, in simple terms, a process is assigned a single thread which acts as the main trunk for all the other possible branches to be created from and yield back to.</p><p>While developers still have the ability to create and consume multiple threads, in modern applications on Xamarin target platforms, this model has been extended with concurrency implementations that delegate the responsibility of thread management to runtime and allow the developer only to define execution blocks which may or may not be executed on a separate thread.</p><div class="section" title="Single thread model"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Single thread model</h2></div></div></div><p>In<a class="indexterm" id="id116"/> Android and iOS, each mobile application is started and run on a single thread that is generally referred to as the main or the UI thread. Most of the UI interaction and process lifecycle event handlers and delegates are executed on this thread.</p><p>In this model, developers' main concern should be keeping the main thread accessible to UI interaction as long as possible. If we were to execute a blocking call on this thread, it immediately would be reflected to the user as a screen freeze or an application nonresponsive error, which <a class="indexterm" id="id117"/>will inevitably get terminated by the so-called watch-dog implementation of the underlying platform. In addition to the platform-specific restrictions, users also expect a responsive UI at all times and cannot tolerate frozen screens even for a fraction of a second. If the screen freeze lasts any longer, they will try to forcefully terminate the application (see the <span class="emphasis"><em>Feedback</em></span> section of <a class="link" href="ch07.html" title="Chapter 7. View Elements">Chapter 7</a>, <span class="emphasis"><em>View Elements</em></span>).</p><p>Developers can still create, consume, and monitor other threads from the main thread. It is possible to use background threads and invoke long running processes in the background. For this purpose, the <code class="literal">System.Threading</code> namespace and threading related classes are available on Xamarin.iOS and Xamarin.Android projects. Moreover, each platform has its own threading implementation under the hood.</p><p>For example, let's imagine we want to execute a long running process and we do not want this method to block the UI thread. With classic threading, the implementation would look similar to:</p><div class="informalexample"><pre class="programlisting">//var threadStart = new ThreadStart(MyLongRunningProcess);
//(new Thread(threadStart)).Start();

// Or simply
(new Thread(MyLongRunningProcess)).Start();</pre></div><p>Each <code class="literal">Thread</code> can give information about the current execution state, and it can be canceled, started, interrupted, or even joined by another thread. Developers can use the threading model for throttling their application and/or executing their code more efficiently without committing the cardinal sin of blocking the UI thread.</p><p>It might get a little complicated when the process you are executing on a separate thread needs to update a UI component. This would be a cross-thread violation.</p><p>For instance, if we wanted to update a UI component from a separate thread in an Android activity, we would need to execute it on the activity as follows (using <code class="literal">Activity.RunOnUiThread</code>):</p><div class="informalexample"><pre class="programlisting">this.RunOnUiThread(() =&gt; { UpdateUIComponent(); });</pre></div><p>The same execution on iOS would look similar to (using <code class="literal">NSObject.InvokeOnMainThread</code>):</p><div class="informalexample"><pre class="programlisting">this.InvokeOnMainThread(() =&gt; { UpdateUIComponent(); });</pre></div><p>For reference, on Windows Runtime the same execution would look like this:</p><div class="informalexample"><pre class="programlisting">CoreApplication.MainView
    .CoreWindow.Dispatcher.RunAsync(CoreDispatcherPriority.Normal, 
        () =&gt; { UpdateUIComponent(); });</pre></div><p>The <a class="indexterm" id="id118"/>implementation in classic threading gets even more complex when there is an exception or the operation has to be canceled, not to mention the fact that synchronization between threads and thread-safe data flow is completely left to developers or third-party implementations.</p><p>Another important mishap of using the <code class="literal">System.Threading</code> namespace and the classic threading model in Xamarin, is that this namespace and thread-related classes cannot be used in PCLs.</p></div><div class="section" title="Task-based Asynchronous Pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Task-based Asynchronous Pattern</h2></div></div></div><p>Since <a class="indexterm" id="id119"/>the introduction of the Tasks framework in .NET 4.0 and its later adoption by Mono, the <span class="strong"><strong>Task-based Asynchronous Pattern</strong></span> (<span class="strong"><strong>TAP</strong></span>) has <a class="indexterm" id="id120"/>become de-facto the main implementation strategy for mobile applications. While providing the required abstraction from the treading structure, it also gives the development teams the opportunity to create easily readable, manageable, and scalable application projects. As mentioned earlier, since each Xamarin target platform has the threading implemented according to the underlying runtime, this abstraction that the Tasks framework provides makes it the perfect candidate for asynchronous implementations in cross-platform projects and an invaluable part of portable class libraries.</p><p>In this pattern, each execution block is represented by a <code class="literal">Task</code> or a <code class="literal">Task&lt;T&gt;</code> according to the return value of the block (for example, if the block is returning void, it should be converted to return <code class="literal">Task</code> and if the block is returning an <code class="literal">int</code>, the method signature should be <code class="literal">Task&lt;int&gt;</code>). Tasks can be executed either synchronously or asynchronously, can be awaited for a result or executed as a promise with a callback on completion, can be pushed to another thread-pool or executed on the main thread taking processor time when available.</p><p>Tasks are especially suited for computationally intensive operations, since they provide excellent control over when and how the asynchronous method is executed. Cancellation and progress support on these methods makes long running processes easily manageable.</p></div><div class="section" title="Concurrency model on iOS"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Concurrency model on iOS</h2></div></div></div><p>Concurrency<a class="indexterm" id="id121"/> and operation blocks on iOS runtime are Apple's take on the same issues that the Tasks framework is trying to resolve. In essence, the Tasks framework and concurrency model on iOS are the solution to creating multitasking, robust, and easily scalable applications by creating an abstraction layer so that applications do not directly manage threads, but let the operating system decide on where and when to execute operations.</p><p>The iOS runtime uses operation or dispatch queues to asynchronously dispatch tasks in a <span class="strong"><strong>first-in-first-out</strong></span> (<span class="strong"><strong>FIFO</strong></span>)<a class="indexterm" id="id122"/> manner. This approach provides automatic thread-pool management as well as a simple programming interface.</p><p>While the iOS <a class="indexterm" id="id123"/>runtime constructs such as <code class="literal">NSOperation</code>, <code class="literal">NSBlockOperation</code>, and <code class="literal">NSOperationQueue</code> are implemented in the Xamarin.iOS framework and are ready to use, the implementations would only be targeting the iOS platform while Tasks can be used on all three platforms.</p></div></div></div>
<div class="section" title="Asynchronous methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Asynchronous methods</h1></div></div></div><p>The <a class="indexterm" id="id124"/>
<span class="strong"><strong>Task Parallel Library</strong></span> (<span class="strong"><strong>TPL</strong></span>) constitutes <a class="indexterm" id="id125"/>the core part of parallel computing in the .NET framework and has inherently the same stature in Xamarin runtime(s).</p><p>Asynchronous method execution, together with the <code class="literal">async</code> and <code class="literal">await</code> keywords (introduced with C# 5.0), can make the apps more responsive and efficient and decrease the complexity of implementing multithreading and synchronization. Without having the need to implement a parameterized thread, start and push are delegated to a background thread, with so called "awaitables." You can convert your methods to async promises easily with <code class="literal">Task</code> or <code class="literal">Task&lt;T&gt;</code> as the return type. In return, the runtime chooses the best time to execute the code and returns the result to your execution context.</p><p>For instance, the previous thread creation example with Tasks would be as simple as:</p><div class="informalexample"><pre class="programlisting">Task.Run(() =&gt; MyLongRunningProcess());

// Or
Task.Factory.StartNew(MyLongRunningProcess, TaskCreationOptions.LongRunning);</pre></div><p>However, the Tasks framework is not only about creating threads or executing non-blocking methods, but also about coordinating and managing these asynchronous tasks in the easiest way possible. There are many static helper methods as well as methods implemented for Tasks that help developers to easily implement some of these coordination scenarios.</p><div class="section" title="Continuation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Continuation</h2></div></div></div><p>The<a class="indexterm" id="id126"/> <code class="literal">ContinueWith</code> function on the <code class="literal">Task</code> class allows the developers to chain dependent Tasks together and execute them as one Task as a whole. The continuation delegate is executed once the result from the first task is posted back to the task scheduler. It is important to mention that the first task and the continuation methods are not necessarily executed on the same thread. The code is as follows:</p><div class="informalexample"><pre class="programlisting">Task.Run(() =&gt; MyLongRunningProcess())
    .ContinueWith(task =&gt; MySecondLongRunningProcess());</pre></div><p>In case <a class="indexterm" id="id127"/>the second task was dependent on the result from the first task:</p><div class="informalexample"><pre class="programlisting">Task.Run(() =&gt; MyLongRunningProcess())
            .ContinueWith(task =&gt; MySecondLongRunningProcess(task.Result));</pre></div></div><div class="section" title="Cancellation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Cancellation</h2></div></div></div><p><code class="literal">CancellationToken</code> and <code class="literal">CancellationTokenSource</code> are used as the remote token to control the<a class="indexterm" id="id128"/> execution lifetime of an async method, thread, or a number of threads and the event source that the token reflects the events of.</p><p>In simple terms, <code class="literal">CancellationTokenSource</code> is responsible for throwing either time-based or manual cancel events and these events can be retrieved through the token in the context of the asynchronous method.</p><p>You can create a cancellation source using the default constructor and time-based cancellation can be added to the token:</p><div class="informalexample"><pre class="programlisting">m_CancellationSource = new CancellationTokenSource();

var token = m_CancellationSource.Token;

// You can cancel it after a certain amount of time, which would trigger an OperationCanceledException
// m_CancellationSource.CancelAfter(2000);</pre></div><p>Once we are executing an async method, we can use the token from this source, or we can associate it with a <code class="literal">TaskFactory</code> to create a cooperating list of tasks:</p><div class="informalexample"><pre class="programlisting">Task.Run(() =&gt;
{
    // Executing my long running method
    if (token.IsCancellationRequested)
    {
        token.ThrowIfCancellationRequested();
    }
}, token);</pre></div><p>Or:</p><div class="informalexample"><pre class="programlisting">var taskFactory = new TaskFactory(m_CancellationSource.Token);
taskFactory.StartNew(() =&gt;
    {
        // Executing my long running method
        if (Task.Factory.CancellationToken != CancellationToken.None &amp;&amp; Task.Factory.CancellationToken.IsCancellationRequested)
        {
           Task.Factory.CancellationToken
               .ThrowIfCancellationRequested();
        }
    });</pre></div><p>Finally, you <a class="indexterm" id="id129"/>can also cancel the thread or a group of threads using the <code class="literal">Cancel</code> or <code class="literal">CancelAfter</code> (with a time delay) methods of <code class="literal">CancellationTokenSource</code>.</p></div><div class="section" title="Progress"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Progress</h2></div></div></div><p>Another <a class="indexterm" id="id130"/>asynchronous control feature that helps keep the user informed about the operations being invoked in the background is the progress callback implementation. Just like <code class="literal">CancellationToken</code>, we can supply the asynchronous tasks with an event handler for progress events that the asynchronous method can invoke to pass progress information back to the main thread.</p><p>For simple progress reporting, it is enough to expand asynchronous methods with an additional parameter that derives from the <code class="literal">IProgress&lt;T&gt;</code> interface.</p><p>For instance, if we were to implement a progress event handler in the <code class="literal">GetFibonacciRangeAsync</code> method, we could use the number of values to be calculated and the current ordinal being calculated to report an overall progress in percentages:</p><div class="informalexample"><pre class="programlisting">public async Task&lt;List&lt;int&gt;&gt; GetFibonacciRangeAsync(int firstOrdinal, int lastOrdinal, IProgress&lt;int&gt; progress = null)
{
    var results = new List&lt;int&gt;();

    for (var i = firstOrdinal; i &lt; lastOrdinal; i++)
    {
        results.Add(await GetFibonacciNumberAsync(i));
        
        decimal currentPercentage = (decimal) lastOrdinal - i/(decimal) lastOrdinal - firstOrdinal;

        if (progress != null)
            progress.Report((int)(currentPercentage * 100);
    }

    return results;
}</pre></div><p>In order to be able to use the progress value in our view model, we can make use of the <code class="literal">Progress&lt;T&gt;</code> class, which<a class="indexterm" id="id131"/> is the default implementation of <code class="literal">IProgress&lt;T&gt;</code>. The code is as follows:</p><div class="informalexample"><pre class="programlisting">Action&lt;int&gt; reportProgress = (value) =&gt;
{
    InfoText = string.Format("{0}% Completed", value);
};

var progress = new Progress&lt;int&gt;(reportProgress);

m_SourceAsync.GetFibonacciRangeAsync(numberOrdinal1, numberOrdinal2, progress)
    .ContinueWith(task =&gt;
    {
        Result = string.Join(",", task.Result.Select(val=&gt;val));
        InfoText = "";
    });</pre></div></div><div class="section" title="Task batches"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Task batches</h2></div></div></div><p>In<a class="indexterm" id="id132"/> task-based asynchronous pattern, there are other ways than continuation to execute tasks in a batch, even in parallel. The example from the previous section was awaiting each number calculation separately and executing the next call. However, the manner in which the inner methods were implemented made them independent from each other. Hence, it is not actually necessary to wait for them one by one to return the result. The code is as follows:</p><div class="informalexample"><pre class="programlisting">List&lt;Task&lt;int&gt;&gt; calculations = new List&lt;Task&lt;int&gt;&gt;();

Mvx.Trace("Starting Calculations");

for (var i = firstOrdinal; i &lt; lastOrdinal; i++)
{
    var currentOrdinal = i;
    calculations.Add(Task.Factory.StartNew(() =&gt; 
        GetFibonacciNumberInternal(currentOrdinal).Value, TaskCreationOptions.LongRunning));
}

Mvx.Trace("Starting When All", DateTime.Now);
int[] results = await Task.WhenAll(calculations);
Mvx.Trace("Calculations Completed", DateTime.Now);

return results.OrderBy(value=&gt;value).ToList();</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>The <code class="literal">Mvx</code> static class and the <code class="literal">Trace</code> method are provided by the MvvmCross library. It will be further discussed in later chapters.</p></div></div><p>Now, each <a class="indexterm" id="id133"/>Fibonacci number in the sequence is calculated in parallel and when the sequence range is complete, an array of result values is returned. Finally, we sort the array and return the list of values.</p><p>We can extend this implementation by adding a progress notifier with an interlocked (thread-safe) counter:</p><div class="informalexample"><pre class="programlisting">calculations.Add(Task.Factory.StartNew(() =&gt;
    GetFibonacciNumberInternal(currentOrdinal).Value, TaskCreationOptions.LongRunning)
    .ContinueWith(task =&gt;
    {
        if (progress != null)
        {
            var currentTotal = Interlocked.Increment(ref currentCount);
            decimal currentPercentage = (decimal) currentTotal/(decimal) totalCount;
            progress.Report((int)(currentPercentage * 100));
        }
        return task.Result;
    })); </pre></div><p>The resulting log traces from the calculations above are as follows:</p><div class="informalexample"><pre class="programlisting">09-07 21:18:29.232 I/mono-stdout( 3094): mvx:Diagnostic: 40.80 Starting Calculations
09-07 21:18:29.352 I/mono-stdout( 3094): mvx:Diagnostic: 40.92 Starting When All
09-07 21:18:30.432 I/mono-stdout( 3094): mvx:Diagnostic: 42.00 Calculations Completed</pre></div><p>The total time for the calculations was about 1.2 seconds.</p><p>Repeating the same calculations with an <code class="literal">await</code> on each method would give the following output (calculating ordinal 4 until 11):</p><div class="informalexample"><pre class="programlisting">09-07 21:26:58.716 I/mono-stdout( 3281): mvx:Diagnostic: 10.60 Starting Calculations
09-07 21:26:58.724 I/mono-stdout( 3281): mvx:Diagnostic: 10.61 Starting calculating ordinal 4
…
09-07 21:27:03.900 I/mono-stdout( 3281): mvx:Diagnostic: 15.78 Starting calculating ordinal 11
09-07 21:27:05.028 I/mono-stdout( 3281): mvx:Diagnostic: 16.91 Calculations Completed</pre></div><p>The same calculations took around 6.3 seconds overall.</p><p>On top of <code class="literal">WhenAll</code>, developers <a class="indexterm" id="id134"/>are also equipped with the <code class="literal">WhenAny</code>, <code class="literal">WaitAll</code>, <code class="literal">WaitAny</code> methods on the <code class="literal">Task</code> class and <code class="literal">ContinueWhenAll</code> and <code class="literal">ContinueWhenAny</code> on the <code class="literal">TaskFactory</code> class.</p></div></div>
<div class="section" title="Parallel execution"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Parallel execution</h1></div></div></div><p>In the<a class="indexterm" id="id135"/> previous section, the discussion was centered on the <code class="literal">System.Threading.Tasks</code> namespace and the <code class="literal">Task</code> class. Even though tasks are the cornerstone of the task-based asynchronous model and so-called Task Parallelism, the concurrent collections namespace makes up the Data Parallelism side of the async model and provides developers with tools to execute code most efficiently and in a thread-safe manner.</p><p><code class="literal">BlockingCollection&lt;T&gt;</code> is one of the concurrent collection implementations that encapsulates the core synchronization and coordination between threads and provides a thread-safe data storage to implement a provider-consumer model in Xamarin applications.</p><p>Using <code class="literal">BlockingCollection&lt;T&gt;</code>, we can easily implement a new method that makes use of the parallel execution from the previous example. In this implementation, our view model will be the consumer and the Fibonacci source and the range calculation tasks will be the provider.</p><p>If we were to rewrite the range calculation method using a blocking collection, our method signature would be similar to:</p><div class="informalexample"><pre class="programlisting">public async Task GetFibonacciRangeAsync(int firstOrdinal, int lastOrdinal, BlockingCollection&lt;int&gt; blockingCollection)</pre></div><p>So in a way, the consumer is going to create the blocking collection and will pass it to the provider to fill it up with the calculated values. The provider in return will need to push each calculated value from the parallel tasks with the <code class="literal">TryAdd</code> or <code class="literal">Add</code> methods. The code is as follows:</p><div class="informalexample"><pre class="programlisting">for (var i = firstOrdinal; i &lt; lastOrdinal; i++)
{
    var currentOrdinal = i;

    calculations.Add(Task.Factory.StartNew(() =&gt;
        GetFibonacciNumberInternal(currentOrdinal).Value, TaskCreationOptions.LongRunning)
        .ContinueWith(task =&gt;
        {
            blockingCollection.Add(task.Result);
            return task.Result;
        }));
}</pre></div><p>Finally, once all the calculations are completed, the provider needs to mark the collection as add-completed. The code is as follows:</p><div class="informalexample"><pre class="programlisting">//
// Collection is filled completely
await Task.WhenAll(calculations).ContinueWith(task =&gt;
{
    blockingCollection.CompleteAdding();
});</pre></div><p>While <a class="indexterm" id="id136"/>these tasks are being executed on the provider side, we can create the consumer in our view model with a <code class="literal">while</code> loop, checking on certain intervals if there is a new item with <code class="literal">TryTake</code> until it is completed. However, there is already an implemented method on the concurrent collection for this purpose: <code class="literal">GetConsumingEnumerable</code>. Using this method makes the execution on the consumer thread as simple as a <code class="literal">foreach</code> block. The code is as follows:</p><div class="informalexample"><pre class="programlisting">var blockingCollection = new BlockingCollection&lt;int&gt;();

var fibonacciTask = (new FibonacciSourceAsync())
    .GetFibonacciRangeAsync(numberOrdinal1,
        numberOrdinal2, blockingCollection);

fibonacciTask.ConfigureAwait(false);

//
// Starting the Consumer thread
Task.Factory.StartNew(() =&gt;
{
    foreach (var item in blockingCollection.GetConsumingEnumerable())
    {
        var currentItem = item;
        if (Result != string.Empty) Result += ",";

        Result += currentItem;
    }

    InfoText = "Done";

}, TaskCreationOptions.LongRunning);</pre></div><p>In this model, the provider thread (together with each parallel task being executed) and the consumer thread are executed almost instantaneously and the results are reflected to the UI almost immediately through the view model.</p><p>In the previous <a class="indexterm" id="id137"/>implementation, even though possibly multiple values are added to the blocking collection and the blocking collection's support for multiple consumers, the <code class="literal">foreach</code> loop follows a more linear execution. We can extend this model by adding multiple consumers using the <code class="literal">Parallel.ForEach</code> extension method from the <code class="literal">System.Threading.Tasks.Parallel</code> namespace. The code is as follows:</p><div class="informalexample"><pre class="programlisting">Task.Factory.StartNew(() =&gt;
{
    var result = Parallel.ForEach(blockingCollection.GetConsumingEnumerable(), item =&gt;
    {
        UpdateUIWithItem(item);
    }).IsCompleted;

    if (result) InfoText = "Done";
}, TaskCreationOptions.LongRunning);</pre></div><p>There are other constructs and implementation patterns that developers can use and adapt on concurrent scenarios such as <code class="literal">Partitioner</code>, <code class="literal">ActionBlock</code>, <code class="literal">ConcurrentScheduler</code>, among others. However, these concepts are beyond the scope of this book.</p></div>
<div class="section" title="Patterns and best practices"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Patterns and best practices</h1></div></div></div><p>It is possible <a class="indexterm" id="id138"/>to draw parallels with and even convert from the classic threading and eventing patterns while implementing asynchronous tasks. However, async <a class="indexterm" id="id139"/>methods have to be implemented with caution to avoid deadlocks and uncaught exceptions.</p><div class="section" title="Async pattern conversions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Async pattern conversions</h2></div></div></div><p>The Observer pattern—also known as the <a class="indexterm" id="id140"/>
<span class="strong"><strong>Event-based Asynchronous Pattern</strong></span> (<span class="strong"><strong>EAP</strong></span>)—used <a class="indexterm" id="id141"/>to be the main development tool for long running processes and service/remote application APIs. Events and delegates still make up a considerable amount of UI-related implementation in modern applications.</p><p>However, asynchronous tasks and awaitables provide a much more convenient way to deal with long running processes and chain completion methods.</p><p>Fortunately, it is possible to implement conversion patterns from other async patterns to task-based implementations. These types of scenarios involve using the <code class="literal">TaskCompletionSource</code> class.</p><p>In order to <a class="indexterm" id="id142"/>demonstrate this, we will be using a simplified version of the Fibonacci source implementation from previous examples:</p><div class="informalexample"><pre class="programlisting">public event EventHandler&lt;int&gt; CalculationCompleted;

public event EventHandler&lt;string&gt; CalculationFailed;

/// &lt;summary&gt;
/// Calculates n-th number in Fibonacci sequence
/// &lt;/summary&gt;
/// &lt;param name="ordinal"&gt;Ordinal of the number to calculate&lt;/param&gt;
public void GetFibonacciNumber(int ordinal)
{
    try
    {
        var result = GetFibonacciNumberInternal(ordinal);

        if (CalculationCompleted != null) CalculationCompleted(this, result);
    }
    catch (Exception ex)
    {
        if (CalculationFailed != null) CalculationFailed(this, ex.Message);
    }
}</pre></div><p>In this example, we have an event handler for successful calculations and another one for failed calculations (for example, if the ordinal is less than 0, it should throw an <code class="literal">ArgumentOutOfRangeException</code>).</p><p>Our aim here is to implement an asynchronous method, which we can execute and yield the result to the UI without having to subscribe to the event every time a new <code class="literal">FibonacciSource</code> is created.</p><p>For this purpose, we can implement a new version of <code class="literal">FibonacciSource</code> and expose only async methods instead of event-based methods. The code is as follows:</p><div class="informalexample"><pre class="programlisting">public class FibonacciSourceAsync : FibonacciSource
{
    public new Task&lt;int&gt; GetFibonacciNumberAsync(int ordinal)
    {
        var myTaskSource = new TaskCompletionSource&lt;int&gt;();

        EventHandler&lt;FibonacciItem&gt; onCalculationCompleted = null;
        EventHandler&lt;string&gt; onCalculationFailed = null;

        //
        // Subscribe to TaskCompleted: When the CalculationCompleted event is fired, set result.
        onCalculationCompleted = (sender, args) =&gt;
        {
            // Not forgetting to release the event handler
            CalculationCompleted -= onCalculationCompleted;
            myTaskSource.SetResult(args.Value);
        };

        //
        // Subscribe to TaskFailed: If there is an error in the execution, set error.
        onCalculationFailed = (sender, args) =&gt;
        {
            CalculationFailed -= onCalculationFailed;
            myTaskSource.SetException(new Exception(args));
        };

        CalculationCompleted += onCalculationCompleted;

        CalculationFailed += onCalculationFailed;

        // Finally execute the task and return the associated Task promise.
        base.GetFibonacciNumberAsync(ordinal);

        return myTaskSource.Task;

    }
}</pre></div><p>Now calls to <a class="indexterm" id="id143"/>calculate Fibonacci numbers would look similar to:</p><div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; CalculateFibonacciValueAsync(int ordinal)
{
    var fibonacciSource =  new FibonacciSourceAsync();

    try
    {
        return (await fibonacciSource.GetFibonacciNumberAsync(ordinal));
    }
    catch (Exception ex)
    {
        // TODO: Do something with exception 
    }
}</pre></div><p>This <a class="indexterm" id="id144"/>implementation can be further extended with progress and cancellation token implementations.</p></div><div class="section" title="Multi-threading with tasks"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Multi-threading with tasks</h2></div></div></div><p>One<a class="indexterm" id="id145"/> important thing to realize about asynchronous calls is that they don't necessarily run on a separate thread. As a matter of fact, calls are "scheduled" to run in a so-called Synchronization Context on the main thread unless they are instructed otherwise. Synchronization Context is the message queue that takes care of the scheduling of the async calls that need to be awaited. Once the async method (or <code class="literal">Task</code> in most of the cases) is successfully executed, the result is posted back onto the Synchronization Context (that is, the main UI thread).</p><p>For demonstration purposes, we will be using the async implementation (EAP conversion) from the previous example with some additional diagnostic calls to get additional information about the threads and synchronization contexts being used.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>The <code class="literal">TraceThreadInfo</code> method and the associated <code class="literal">ThreadInfo</code> class used in the examples here is a custom implementation used through dependency injection. The reason for this is that threading namespace only contains task-related classes in PCLs and the only way to actually get the current thread ID is to use platform-specific implementation. Platform-specific implementation patterns will be discussed in detail in later chapters.</p></div></div><p>In the tracing method, we will be logging the current thread ID and the current synchronization context:</p><div class="informalexample"><pre class="programlisting">public IThreadInfo ThreadInfo
{
    get { return Mvx.GetSingleton&lt;IThreadInfo&gt;(); }
}

private void TraceThreadInfo(string message)
{
    Debug.WriteLine("{0} on Thread '{1}'", message, ThreadInfo.CurrentThreadId);
    Debug.WriteLine("Current Synchronization Context is {0}", SynchronizationContext.Current);
}</pre></div><p>The<a class="indexterm" id="id146"/> calculation command attached to the calculate button is:</p><div class="informalexample"><pre class="programlisting">TraceThreadInfo("Begin DoCalculate");

if (!string.IsNullOrWhiteSpace(Input))
{
    int numberOrdinal;

    if (int.TryParse(Input, out numberOrdinal))
    {
        InfoText = "Calculating";

        TraceThreadInfo("Calling GetFibonacciNumberAsync");

        var result = await GetFibonacciNumberAsync(numberOrdinal);

        TraceThreadInfo("Response from GetFibonacciNumberAsync");

        Result = result.ToString();

        InfoText = string.Empty;

        TraceThreadInfo("End DoCalculate");

        return;
    }
}

InfoText = "Invalid Input";</pre></div><p>The associated trace log will look like this:</p><div class="mediaobject"><img alt="Multi-threading with tasks" src="graphics/B04693_03_01.jpg"/><div class="caption"><p>Trace for in-line execution of tasks</p></div></div><p>Looking<a class="indexterm" id="id147"/> at the trace messages of the execution stack above, one can easily see that in spite of the fact we are dealing with async tasks, the whole execution takes place on the main thread except for the actual call for the internal method of the source (that is, it is executed on Thread 106). The rest of the method calls have <code class="literal">Android.App.SyncContext</code> as the synchronization context and the execution order is no different than the call sequence that is implemented.</p><p>Changing the implementation a little bit and using the <code class="literal">ContinueWith</code> function of the <code class="literal">Task</code> item, we get slightly different results. The code is as follows:</p><div class="informalexample"><pre class="programlisting">TraceThreadInfo("Calling GetFibonacciNumberAsync");


await GetFibonacciNumberAsync(numberOrdinal).ContinueWith(task =&gt;
{
    TraceThreadInfo("Response from GetFibonacciNumberAsync");

    Result = task.Result.ToString();

    InfoText = string.Empty;
});

TraceThreadInfo("End DoCalculate");</pre></div><p>The trace log for this implementation looks like this:</p><div class="mediaobject"><img alt="Multi-threading with tasks" src="graphics/B04693_03_02.jpg"/><div class="caption"><p>Async execution of Tasks</p></div></div><p>As the trace log suggests, <code class="literal">ContinueWith</code> lambda is executed on a separate thread but the execution is still sequential.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>An important note here is that we are assigning the results back to the ViewModel on a separate thread. In this example, the cross-thread invocation is handled by the MvvmCross framework. If we were to deal with this assignment, the call would look similar to:</p><div class="informalexample"><pre class="programlisting">await GetFibonacciNumberAsync(numberOrdinal).ContinueWith(task =&gt;
{
    TraceThreadInfo("Response from GetFibonacciNumberAsync");

    this.RunOnUiThread(() =&gt;
    {
        txtResult.Text = task.Result.ToString();
    });

    txtInfo.Text = "";
});</pre></div></div></div><p>In the <a class="indexterm" id="id148"/>preceding example, once the execution gets onto a separate thread, the synchronization context is nullified. In .NET runtime, asynchronous tasks that are not tracked by the main synchronization context are actually assigned a <code class="literal">TaskScheduler</code> instance and the execution is done through this context. In this case, <code class="literal">TaskScheduler</code> is responsible to redirect the success post messages back to the main thread if the task is configured to use the same context (that is, <code class="literal">ConfigureAwait(true)</code>).</p><p>However, the way synchronization context works in .NET and the configured task invocations yield back to the main thread can cause deadlocks if the asynchronous tasks are called synchronously (that is, with <code class="literal">Task.Result</code> or <code class="literal">Task.Wait()</code>) on the main thread. In such a scenario, once the async call finishes executing and tries to yield back into the main context, the main context will still not be accessible since it is actually waiting for the async task itself to complete.</p><p><code class="literal">ConfigureAwait(false)</code> informs the scheduler not to look for and post back the result to the same execution context where the task was invoked, but rather just execute and run to completion on the execution context. This avoids the deadlock scenario.</p><p>This deadlock scenario is specific for .NET runtime and because of the way mono runtime on Android and Mono.Touch compiler deal with the task executions; the deadlocks currently do not happen on these platforms. However, it is important to follow the coding conventions associated with asynchronous tasks and awaitables to avoid any unexpected behavior.</p><p>In order to execute the whole task on a separate thread we can use <code class="literal">Task.Run</code> (which will push the task to the ThreadPool) or <code class="literal">Task.Factory.StartNew</code>. Using the <code class="literal">StartNew</code> method would let you define which type of a method you are about to execute in this task and let the runtime make an informed decision about using a different thread. The code is as follows:</p><div class="informalexample"><pre class="programlisting">var task = Task.Factory.StartNew(async () =&gt;
{
    TraceThreadInfo("Calling GetFibonacciNumberAsync");

    var result = await GetFibonacciNumberAsync(numberOrdinal);

    TraceThreadInfo("Response from GetFibonacciNumberAsync");

    Result = result.ToString();

    InfoText = string.Empty;

}, TaskCreationOptions.LongRunning);

task.ConfigureAwait(false);</pre></div><p>In the <a class="indexterm" id="id149"/>trace below, the biggest difference with the previous examples is that the <code class="literal">DoCalculate</code> method exits before even the execution starts for the task we created for the calculations. This type of execution would eloquently fit with the MVVM pattern applied on a cross platform mobile app project. It would avoid any UI blocking issues and create a sense of continuity for the user.</p><div class="mediaobject"><img alt="Multi-threading with tasks" src="graphics/B04693_03_03.jpg"/><div class="caption"><p>Starting a new async task</p></div></div><p>If we want to analyze the same execution on the iOS application (that is, calculate the number on the Fibonacci sequence on a certain ordinal), we can easily identify the threading pattern with the Xcode Instruments "System Trace" template.</p><div class="mediaobject"><img alt="Multi-threading with tasks" src="graphics/B04693_03_04.jpg"/><div class="caption"><p>Calculating four different Fibonacci numbers</p></div></div></div><div class="section" title="Exception handling"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Exception handling</h2></div></div></div><p>Handling <a class="indexterm" id="id150"/>exceptions can become cumbersome if correct asynchronous paths are not followed in multithreaded implementations. However, in most cases, the async/await language constructs take the load of the developers. If the async chain is not broken and calls are implemented correctly, catching exceptions in asynchronous context is no different than catching them with linear code.</p><p>Using our example from previous sections:</p><div class="informalexample"><pre class="programlisting">try
{
    var result = await GetFibonacciNumberAsync(numberOrdinal);

    Result = result.ToString();

    InfoText = "";
}
catch (Exception ex)
{
    Debug.WriteLine("Error:" + ex.Message);
    InfoText = "EX:" + ex.Message;
}</pre></div><p>In this <a class="indexterm" id="id151"/>example, if the ordinal we pass in as a parameter is a negative number, it would throw an exception with the message <span class="strong"><strong>Cannot calculate Fibonacci number for a negative number</strong></span> and we would be displaying the error message in the info textbox.</p><p>However, if we were to use the <code class="literal">ContinueWith</code> construct to execute the same code the outcome would have been a little different:</p><div class="informalexample"><pre class="programlisting">try
{
    await GetFibonacciNumberAsync(numberOrdinal).ContinueWith(result =&gt;
    {
        Result = result.Result.ToString();

        InfoText = string.Empty;
    });
}
catch (Exception ex)
{
    Debug.WriteLine("Error:" + ex.Message);
    InfoText = "EX:" + ex.Message;
}</pre></div><p>In this example, the exception message we would receive would be <span class="strong"><strong>One or more errors occurred</strong></span>. The reason for this is that the exception thrown in the second scenario is an <code class="literal">AggregateException</code> because of the async chain we created.</p><div class="mediaobject"><img alt="Exception handling" src="graphics/B04693_03_05.jpg"/><div class="caption"><p>AggregateException in async chain</p></div></div><p>The<a class="indexterm" id="id152"/> result would have been the same if we were using the <code class="literal">.Result</code> or <code class="literal">.Wait()</code> calls on the task itself.</p><p>The important part of this implementation is where we are calling <code class="literal">await</code> on the asynchronous method. The catch block would never have been called if this was not the case. Without the <code class="literal">await</code> keyword, the try/catch block would have been just checking if the preparation of the Task went as expected, not the actual execution.</p><p>Another type of async execution that cannot be caught with a try/catch block is the type of async methods that return <code class="literal">void</code> instead of a <code class="literal">Task</code> or <code class="literal">Task&lt;T&gt;</code>. Similar to having an exception thrown in an event handler, the only two places they would be caught are the <code class="literal">AppDomain.UnhandledException</code> or <code class="literal">Application.ThreadException</code> events. It is always a better practice for asynchronous methods to return <code class="literal">Task</code> and then return void.</p><p>However, in the <code class="literal">ContinueWith</code> implementation, with the reference to the <code class="literal">Task</code> at hand, we can also check for the status of the task once it runs to completion before we make the result assignment. This assignment is what actually causes the exception to bubble-up to upper layers. In this case, we do not need a try/catch block. The code is as follows:</p><div class="informalexample"><pre class="programlisting">await GetFibonacciNumberAsync(numberOrdinal).ContinueWith(result =&gt;
{
    TraceThreadInfo("Response from GetFibonacciNumberAsync");

    if (result.IsFaulted)
    {
        Result = string.Empty;

        InfoText = string.Join("\r\n", result.Exception
            .InnerExceptions.Select(exception =&gt; exception.Message));
    }
    else
    {
        Result = result.Result.ToString();

        InfoText = string.Empty;
    }
});</pre></div></div><div class="section" title="Initialization pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec49"/>Initialization pattern</h2></div></div></div><p>Especially <a class="indexterm" id="id153"/>in scenarios where a service is involved, a common requirement is to have an initialization function that would prepare the communication channel and/or make a "ping" or an authentication call. When developers are confronted with this type of a scenario, the biggest mistake they can make is to call the asynchronous initialization function in the constructor with a <code class="literal">.Result</code> and/or <code class="literal">.Wait()</code> statement (making it a synchronous call).</p><p>For this scenario, let's assume we have a service that implements an interface with two simple async method implementations.</p><div class="informalexample"><pre class="programlisting">public interface IService
{
    Task&lt;string&gt; AuthenticateAsync(string username, string password);

    Task&lt;int&gt; ServiceMethodAsync(string myParameter);
}</pre></div><p>In order to be able to call <code class="literal">ServiceMethodAsync</code>, we first need to make an <code class="literal">AuthenticateAsync</code> call and receive the authentication token from the service. The code is as follows:</p><div class="informalexample"><pre class="programlisting">public MyService(string username, string password)
{
    //
    // Following call would block the constructor
    // IMPORTANT: If it was being called from the main UI thread, it might cause a deadlock
    // Blocking Call Example 1:
    // AuthenticateAsync(username, password).Wait();
    // Blocking Call Example 2:
    m_Token = AuthenticateAsync(username, password).Result;
}</pre></div><p>In this<a class="indexterm" id="id154"/> example, we implemented the call for authentication in the constructor of the service. Even though the implementation might work in some cases, if the service constructor is called from the main UI thread, the thread would go into a deadlock as it was described in the previous section.</p><p>The easiest solution would be to either expose the initialization function to outer layers or have the service call initialization before each service call. For this purpose we can wrap the authentication call in an initialization method. The code is as follows:</p><div class="informalexample"><pre class="programlisting">public MyService(string username, string password)
{
    m_Username = username;
    m_Password = password;
}

private async Task EnsureInitializationAsync()
{
    if (string.IsNullOrEmpty(m_Token))
    {
        m_Token = await AuthenticateAsync(m_Username, m_Password);
    }
}</pre></div><p>The service method call would look similar to this:</p><div class="informalexample"><pre class="programlisting">public async Task&lt;int&gt; ServiceMethodAsync(string myParameter)
{
    await EnsureInitializationAsync();

    try
    {
        int result = await InternalServiceMethodAsync(myParameter);

        return result;
    }
    catch (Exception ex)
    {
        // TODO:
        throw;
    }
}</pre></div><p>As mentioned, we can also expose the initialization through an interface:</p><div class="informalexample"><pre class="programlisting">/// &lt;summary&gt;
/// Describes the service as requiring async initialization
/// &lt;/summary&gt;
public interface IAsyncInitialization
{
    /// &lt;summary&gt;
    /// The result of the asynchronous initialization.
    /// &lt;/summary&gt;
    Task Initialization { get; }
}

public class MyService : IService, IAsyncInitialization
{
...

    public Task Initialization { get; private set; }

    public MyService(string username, string password)
    {
        m_Username = username;
        m_Password = password;

        Initialization = EnsureInitializationAsync();
    }

    private async Task EnsureInitializationAsync()
    {
        if (string.IsNullOrEmpty(m_Token))
        {
            m_Token = await AuthenticateAsync(m_Username, m_Password);
        }
    }

...
}</pre></div><p>In this case, the caller <a class="indexterm" id="id155"/>method needs to check if the service needs async initialization and check for the required task results. The code is as follows:</p><div class="informalexample"><pre class="programlisting">if (serviceInstance is IAsyncInitialization)
{
    /// Wait for the results of the initialization
    await serviceInstance.Initialization;
}

await serviceInstance.ServiceMethodAsync("param");</pre></div></div><div class="section" title="Semaphores"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec50"/>Semaphores</h2></div></div></div><p>Synchronization <a class="indexterm" id="id156"/>and throttling methodology on the asynchronous context is a little different than the classic .NET runtime implementations. For instance, lock blocks are not allowed on async calls and you will not be able to use <code class="literal">Mutex</code> for synchronization. <code class="literal"> Mutex</code> is  inapplicable as a mutex can only be owned by a single thread and async executions are not guaranteed to complete on the same thread as they started. The code is as follows:</p><div class="informalexample"><pre class="programlisting">//
// Error: The 'await' operator cannot be used in the body of a lock statement
//lock (m_FibonacciSource)
//{   
//    var result = await GetFibonacciNumberAsync(numberOrdinal);
//}

//
// Warning: Might work but not guaranteed
m_Mutex.WaitOne(200);

await GetFibonacciNumberAsync(numberOrdinal).ContinueWith((task) =&gt;
{
    TraceThreadInfo("Response from GetFibonacciNumberAsync");

    Result = task.Result.ToString();

    InfoText = string.Empty;
});

m_Mutex.ReleaseMutex();</pre></div><p>In order to handle the non-deterministic execution and threading model of asynchronous tasks, a new construct was added to .NET: Semaphore. <code class="literal">Semaphore</code> (implementation of <code class="literal">WaitHandle</code>) and <code class="literal">SemaphoreSlim</code> (lightweight version of <code class="literal">Semaphore</code> that is implemented with monitors) types do not enforce thread identity on the <code class="literal">Wait</code> and <code class="literal">Release</code> calls and can be asynchronously awaited.</p><p>For instance, let's execute a number of parallel calculations orchestrated with a semaphore that allows 3 access count (<code class="literal">SemaphoreSlim(3)</code> or <code class="literal">SemaphoreSlim(3,3)</code>) such as:</p><div class="informalexample"><pre class="programlisting">var semaphoreSlim = new SemaphoreSlim(3);

int count = 11;

for (var i = 0; i &lt; 7; i++)
{
    Task.Factory.StartNew(() =&gt;
    {
        return semaphoreSlim.WaitAsync().ContinueWith((waitTask) =&gt;
        {
            return Task.Factory.StartNew(() =&gt;
            {
                return GetFibonacciNumberAsync(count = Interlocked.Increment(ref count)).ContinueWith(
                    (calculateTask) =&gt;
                    {
                        TraceThreadInfo(string.Format("Current count on Semaphore: {0}",
                            semaphoreSlim.Release() + 1));
                    });

            }, TaskCreationOptions.LongRunning);
        });
    }, TaskCreationOptions.LongRunning);</pre></div><p>This parallel <a class="indexterm" id="id157"/>execution can be easily spotted on the average system time view of Instruments' System Trace template. This is shown in the screenshot below where each ordinal calculation would give the exact number of peaks on the selected calculation threads):</p><div class="mediaobject"><img alt="Semaphores" src="graphics/B04693_03_06.jpg"/><div class="caption"><p>System time average on synchronized threads</p></div></div></div></div>
<div class="section" title="Background tasks"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Background tasks</h1></div></div></div><p>Threading <a class="indexterm" id="id158"/>and task solutions are not the only option when there is a need to execute a not time-bound, long running process. Moreover, both of these options are for executing code when your application is in the foreground or in an active state. When the application is entering the backgrounded or suspended state, the application might still require the execution of some longer method before the volatile data is lost, or it might require a process to be running in the background when the application is not in an interactive state.</p><p>For these types of scenarios, both iOS and Android offer backgrounding and background operation options.</p><div class="section" title="Background tasks on iOS"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec51"/>Background tasks on iOS</h2></div></div></div><p>Background tasks <a class="indexterm" id="id159"/>on iOS are the easiest way for your application to<a class="indexterm" id="id160"/> execute processing tasks without the need for the UI thread or having to respond to lifecycle delegates.</p><p>There are three types of background tasks that can be executed for different needs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Background-safe tasks</strong></span>: These<a class="indexterm" id="id161"/> tasks are the ones that can be executed at any stage of the process lifetime. They are not affected and/or interrupted by the application going into the background. The code is as follows:<div class="informalexample"><pre class="programlisting">nint taskId = UIApplication.SharedApplication
    .BeginBackgroundTask(() =&gt;
{
    // TODO: Do something if the allotted time runs out
});

// TODO: Implement the processing logic

if (taskId != UIApplication.BackgroundTaskInvalid)
{
    UIApplication.SharedApplication.EndBackgroundTask(taskId);
}</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>DidEnterBackground tasks</strong></span>: Another<a class="indexterm" id="id162"/> type of background task is executed to pass the state-save or clean-up logic to a background process. The <code class="literal">DidEnterBackground</code> lifetime delegate is used to initialize these tasks and continue processing even after the application goes into the background state. The creation of these tasks is similar to the background-safe tasks. The only difference is that the <code class="literal">EndBackgroundTask</code> method has to be called inside the execution block rather than the calling thread, since the calling process might have already returned not waiting for the execution of the background task. The code is as follows:<div class="informalexample"><pre class="programlisting">public override void DidEnterBackground (UIApplication application)
{
    nint taskId = UIApplication.SharedApplication
        .BeginBackgroundTask(() =&gt;
    {
        // TODO: Do something if the allotted time runs out
    });

    Task.Run(() =&gt;
    {
        // TODO: Implement the processing logic
        UIApplication.SharedApplication.EndBackgroundTask(taskId);
    });
}</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Background transfers</strong></span>: These<a class="indexterm" id="id163"/> tasks are specific to iOS 7+ and provide a longer processing time (a strict limit on other background tasks is 600 seconds, while background transfers can last up to 10,000 seconds). Background transfer tasks are used to perform long lasting network operations and upload/download large files over the wire.</li></ul></div></div><div class="section" title="Services (Android only)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec52"/>Services (Android only)</h2></div></div></div><p>On the <a class="indexterm" id="id164"/>Android platform, once the activities enter the backgrounded state, they cannot perform tasks and are usually stopped soon after entering the background. Services are application components introduced to provide an interface for developers to start and stop long running processes in the background.</p><p>Even though <a class="indexterm" id="id165"/>services are created as part of an application, they have their own separate lifecycle and can run even if the application and activity that started them was stopped or destroyed.</p><p>A service can take one or both of two forms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Started</strong></span>: A service is "started" when<a class="indexterm" id="id166"/> an activity explicitly starts it by calling the <code class="literal">StartService</code> method using an intent. A started service is generally used as a <code class="literal">BackgroundWorker</code> and once the processing operation is finished, the service itself or the activity stops it.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bound</strong></span>: A "bound" service<a class="indexterm" id="id167"/> generally acts as the provider to clients in the activities of the application or even other applications. A bound service is kept alive as long as another component is bound to it.</li></ul></div><p>Both of these initialization patterns use the callback methods similar but not limited to <code class="literal">OnStartCommand</code>, <code class="literal">OnBind</code>, <code class="literal">OnCreate</code>, and <code class="literal">OnDestroy</code> to start background processing and deal with its lifetime.</p><p>There are various base classes implemented in the Android namespace and according to the requirements, these base classes can be implemented and started or bound.</p><p>In order to implement a started service to do some background processing, the first step of the implementation process would be to create the <code class="literal">IntentService</code> class:</p><div class="informalexample"><pre class="programlisting">[Service]
[IntentFilter(new String[] { "com.xamarin.MyDemoService" })]
public class MyDemoService : IntentService
{
    public MyDemoService()
        : base("MyDemoService")
    {
    }

    protected override void OnHandleIntent(Intent intent)
    {
        var myParameter = intent.GetStringExtra("parameter");
            
        // Invoke long running process
        DoWork(myParameter);
    }
}</pre></div><p>The <code class="literal">IntentService</code> base<a class="indexterm" id="id168"/> class already deals with lifecycle events such as <code class="literal">OnStart</code>, so all we have to implement is the <code class="literal">OnHandleIntent</code> method to respond to intent requests from activities. The <a class="indexterm" id="id169"/>two attributes of the class, <code class="literal">Service</code> and <code class="literal">IntentFilter</code>, are used by Xamarin compiler to generate the entries in the application manifest. The debug build for this implementation gives out the following service entry in the application manifest. The code is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;service android:name="md5d06a1058f86cf8319abb1555c0b54fbf.MyDemoService"&gt;
    &lt;intent-filter&gt;
        &lt;action android:name="com.xamarin.MyDemoService" /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;</pre></div><p>With this implementation in an activity, the intent service can be started by either using the intent filter entry or using the type of the service.</p><div class="informalexample"><pre class="programlisting">//StartService (new Intent (this, typeof(MyDemoService)));
StartService(new Intent("com.xamarin.MyDemoService"));</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Summary</h1></div></div></div><p>Overall, asynchronous/concurrent implementation patterns and background tasks allow the developers to push the heavy-lifting away from the UI thread and create responsive applications in the single-threaded paradigm of modern mobile applications.</p><p>The Task-based Asynchronous Pattern provides an efficient and scalable way to implement asynchronous operations with ease. Moreover, progress, cancellation, and concurrent collections help monitor, scale, and manage the execution of these asynchronous blocks while providing a way to cooperate between each other. Implementing these blocks, developers do not need to carry the burden of threads, synchronization, and scaling the threads according to the hardware resources.</p><p>After analyzing memory and CPU-related topics so far in this book, in the next chapter we will discuss local storage and how to use it efficiently.</p></div></body></html>