<html><head></head><body>
        

                            
                    <h1 class="header-title">Exploring Threading</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will be looking at these recipes:</p>
<ul>
<li>Creating a library that can perform several things at once</li>
<li>Creating a .NET Core console application to use the library</li>
<li>Creating an async method with tasks</li>
<li>Creating a WPF application to use the library</li>
<li>Creating a thread pool</li>
<li>Creating a .NET console application to use the library</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>Readers should have a basic knowledge of C#. They should also have a basic knowledge of using Visual Studio, installing packages using NuGet, and referencing libraries within projects from other projects.</p>
<p class="mce-root">The code files for this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/DotNET-Standard-2-Cookbook/tree/master/Chapter06">https://github.com/PacktPublishing/DotNET-Standard-2-Cookbook/tree/master/Chapter06</a></p>
<p class="mce-root">Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/BhsEpf">https://goo.gl/BhsEpf</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Threading enables your C# application to do more than one operation at a time. Simply put, you can allow a user to input their personal information and monitor it while doing a background process. As an example, in strategy games, a character might be fetching some wood from a forest. At the same time, another one could be building a wall and another shooting at the enemy. Let's have a look at how threading works inside a .NET Standard 2.0 library.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a library that can perform several things at once</h1>
                
            
            
                
<p>In this recipe, we will be looking at the basics of threading and we will make use of the <kbd>System.Threading</kbd> namespace inside a .NET Standard 2.0 library.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Let's make sure we have the latest Visual Studio 2017 installed and configured for creating a .NET Standard 2.0 library before we get started building our library.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open Visual Studio 2017.</li>
<li>Click File | New | Project<strong> </strong>to create a project. </li>
</ol>
<ol start="3">
<li>In the New Project dialog box, expand the Other Project Types node in the left-hand pane and select Visual Studio Solutions. In the right-hand pane, select Blank Solution<strong>.</strong></li>
</ol>
<ol start="4">
<li>In the Name: textbox, type <kbd>Chapter6.Threads</kbd> and, in the Location: textbox, select a path from the drop-down box or click on the Browse... button to locate a path:</li>
</ol>
<div><img src="img/2880e605-1be4-47f5-81aa-b81f8ccdcd88.png"/></div>
<ol start="5">
<li>Click OK.</li>
<li>Now, the Solution Explorer (<em>Ctrl</em> + <em>Alt</em> + <em>L</em>) should look like this:</li>
</ol>
<div><img class="alignnone size-full wp-image-758 image-border" src="img/25fb32f2-0873-4565-8ef6-622f55b7782d.png" style="width:35.58em;height:9.83em;"/></div>
<ol start="7">
<li>Now, right-click on the <kbd>Chapter6.Threads</kbd> label in the Solution Explorer and select Add | New Project<strong>.</strong></li>
<li>In the New Project dialog box, expand the Visual C# node.</li>
</ol>
<ol start="9">
<li>Select .NET Standard in the left-hand pane and Class Library (.NET Standard) in the right-hand pane:</li>
</ol>
<div><img class="alignnone size-full wp-image-759 image-border" src="img/00db53de-12e7-4ba6-aa18-8a3bcde8596f.png" style="width:156.33em;height:108.83em;"/></div>
<ol start="10">
<li>Now, in the Name: textbox, type <kbd>Chapter6.Threads.ThreadLib</kbd>. Leave the other defaults as they are and click OK:</li>
</ol>
<div><img class="alignnone size-full wp-image-760 image-border" src="img/9ef38dd6-bab0-4a9e-a2d3-be6c956b4087.png" style="width:155.08em;height:14.33em;"/></div>
<ol start="11">
<li>Now, the Solution Explorer (<em>Ctrl</em> + <em>Alt</em> + <em>L</em>) should look like this:</li>
</ol>
<div><img class="alignnone size-full wp-image-761 image-border" src="img/3e5438cc-4c10-4eac-b598-4d096a7f572d.png" style="width:27.58em;height:12.00em;"/></div>
<ol start="12">
<li>Now, select <kbd>Class1.cs</kbd> in the Solution Explorer and press <em>F2</em> to rename the file <kbd>ThreadGenerator.cs</kbd>.</li>
<li>Answer Yes in the confirmation dialog box that asks to rename the class name as well.</li>
<li>Now, double-click on the <kbd>ThreadGenerator.cs</kbd> label in the Solution Explorer.</li>
<li>Let's scroll up in the code window and add the following <kbd>using</kbd> directive:</li>
</ol>
<pre>      using System.Threading;<br/>      using System.Text</pre>
<ol start="16">
<li> Now, let's add this class-level variable to store our text messages:</li>
</ol>
<pre>      StringBuilder messages = new StringBuilder(); </pre>
<ol start="17">
<li>Create this method inside the <kbd>ThreadGenerator</kbd> class:</li>
</ol>
<pre>      public StringBuilder StartThreads()<br/>      {<br/>          var mainThread = Thread.CurrentThread;<br/>          mainThread.Name = "MainThread";<br/><br/>          messages.Append($"This is the {mainThread.Name}\n");<br/><br/>          Thread anotherThread = new Thread(CountTo100);<br/>          messages.Append("Start a new thread\n");<br/>          anotherThread.Start();<br/><br/>          messages.Append($"Now call {mainThread.Name} will count to 50\n");<br/><br/>          for (int j=0; j&lt;50; j++)<br/>          {<br/>              messages.Append($"MT-{j + 1}\n");<br/>              Thread.Sleep(80);<br/>          }<br/><br/>          messages.Append($"{mainThread.Name} finished\n");<br/>    <br/>          return messages;<br/>      }</pre>
<ol start="18">
<li>Finally, create this support method for the main <kbd>StartThreads()</kbd> method:</li>
</ol>
<pre>      private void CountTo100()<br/>      {<br/>          for (int i=0; i&lt;100; i++)<br/>          {<br/>              messages.Append($"Thread 2 counting {i + 1}\n");<br/>              Thread.Sleep(100);<br/>          }<br/>      }</pre>
<ol start="19">
<li>Let's perform a quick build by pressing <em>Ctrl</em> + <em>Shift</em> + <em>B</em> to check the syntax.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In steps 1 to 14, we created a new blank solution and added a .NET Standard 2.0 class library. Then we gave the default template class a proper name. In step 15, we added the <kbd>using</kbd> directive required for threading support, which is <kbd>System.Threading</kbd>, and we have used the <kbd>System.Text</kbd> namespace to get the  <kbd>StringBuilder</kbd> class to store our messages.</p>
<p>We have used <kbd>StringBuilder</kbd> over <kbd>String</kbd>. If you are wondering why, it is because <kbd>StringBuilder</kbd> is mutable. When you perform operations such as insert, replace, or append, a <kbd>StringBuilder</kbd> object doesn't create a new instance every time. It will update one space in the memory without creating a new space in the memory. However, <kbd>String</kbd> is immutable, which means that if you create a <kbd>String</kbd> object, then you cannot modify it and it always creates a new <kbd>String</kbd> object in the memory.</p>
<p>In step 16, we created an instance of the <kbd>StringBuilder</kbd> class, which will handle all the messages and store them. Then, we created a method that returns a <kbd>StringBuilder</kbd>. This <kbd>StringBuilder</kbd> will contain all the messages generated during execution of the <kbd>StartThreads()</kbd> methods created in step 17.</p>
<p>In these three lines, we picked up the current running thread, which is the main thread, and gave it a name. Then, we stored a message in the <kbd>StringBuilder</kbd>:</p>
<pre>var mainThread = Thread.CurrentThread;<br/>mainThread.Name = "MainThread";<br/><br/>messages.Append($"This is the {mainThread.Name}\n");</pre>
<p>In these lines, we created another new thread and used the <kbd>helper</kbd> method created in step 18 to execute the thread. This <kbd>private helper</kbd> method loops through 100 steps, adds a message to the string builder, and sleeps for 100 milliseconds at each step:</p>
<pre>private void CountTo100()<br/>{<br/>    for (int i=0; i&lt;100; i++)<br/>    {<br/>        messages.Append($"Thread 2 counting {i + 1}\n");<br/>        Thread.Sleep(100);<br/>    }<br/>}</pre>
<p>It also stores the relevant message inside the <kbd>StringBuilder</kbd> as follows:</p>
<pre>Thread anotherThread = new Thread(CountTo100);<br/>messages.Append("Start a new thread\n");<br/>anotherThread.Start();</pre>
<p>In the final lines of code, we executed another loop in the main thread and stored messages inside the <kbd>StringBuilder</kbd> to identify which threads are being executed. Finally, we performed a quick build to check the syntax.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a .NET Core console application to use the library</h1>
                
            
            
                
<p>In this recipe, we will be building a .NET Core console application. This application will use the library we built in the previous recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Make sure you have completed the previous recipe and it builds correctly. Let's get started on the application to use the library.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open Visual Studio 2017.</li>
<li>Now, open the solution from the previous recipe. Click File | Open | Open Project/Solution, or press <em>Ctrl</em> + <em>Shift</em> + <em>O</em>, and select the <kbd>Chapter6.Threads</kbd> solution. </li>
<li>Press <em>Ctrl</em> + <em>Shift</em> + <em>B</em> for a quick build to check that everything is fine. </li>
<li>Click on the <kbd>Chapter6.Threads</kbd> solution label. Click File | Add | New Project.</li>
<li>In the Add New Project template dialog box, expand the Visual C# node in the left-hand pane. </li>
<li>Select .NET Core and select Console App (.NET Core) in the right-hand pane:</li>
</ol>
<div><img class="alignnone size-full wp-image-763 image-border" src="img/359af982-84dd-4ed7-a770-f7a0382aad2f.png" style="width:156.33em;height:108.08em;"/></div>
<ol start="7">
<li>Now, in the Name: textbox, type <kbd>Chapter6.Threads.ThreadsCore</kbd> as the name of the project. The rest of the fields should be left as they are: </li>
</ol>
<div><img class="alignnone size-full wp-image-764 image-border" src="img/f1f06b36-005a-457e-8c2b-4153b9c2de72.png" style="width:154.75em;height:14.58em;"/></div>
<ol start="8">
<li>Click OK.</li>
<li>Now, the Solution Explorer (press <em>Ctrl</em> + <em>Alt</em> + <em>L</em>) should display like this: </li>
</ol>
<div><img class="alignnone size-full wp-image-765 image-border" src="img/eb2e5d2b-7213-4736-a51c-58226db82457.png" style="width:28.50em;height:17.33em;"/></div>
<ol start="10">
<li>Right-click on the Dependencies label in the <kbd>Chapter6.Threads.ThreadsCore</kbd>.</li>
<li>Select Add Reference.</li>
</ol>
<p> </p>
<ol start="12">
<li>In the Reference Manager, click on the Projects label in the right-hand pane: </li>
</ol>
<div><img class="alignnone size-full wp-image-766 image-border" src="img/792d0cbe-5cf1-4beb-aea8-3779b0f870b8.png" style="width:130.58em;height:70.42em;"/></div>
<ol start="13">
<li>Check the <kbd>Chapter6.Threads.ThreadLib</kbd><strong> </strong>project in the left-hand pane.</li>
<li>Click OK.</li>
<li>Now, double-click on the <kbd>Program.cs</kbd> label in the Solution Explorer.</li>
<li>Scroll up in the code window and add the following <kbd>using</kbd> directive:</li>
</ol>
<pre>      using Chapter6.Threads.ThreadLib;</pre>
<ol start="17">
<li>Now, delete any existing code generated by Visual Studio in the <kbd>Main()</kbd> method and add the following code:</li>
</ol>
<pre>      var threads = new ThreadGenerator();<br/>      var output = threads.StartThreads();<br/><br/>      Console.WriteLine(output);<br/>      Console.ReadLine();</pre>
<ol start="18">
<li>Press <em>F5</em> to execute the app.</li>
</ol>
<ol start="19">
<li>You should see output like this:</li>
</ol>
<div><img class="alignnone size-full wp-image-767 image-border" src="img/e1df3453-705d-4118-bb2e-1d6075ba3f03.png" style="width:41.58em;height:34.92em;"/></div>
<ol start="20">
<li>Press <em>Enter</em> to exit.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In steps 1 to 9, we opened an existing solution with a .NET Standard 2.0 library project. Then, we added a .NET Core console application to that solution. In steps 10 to 14, we added the .NET Standard 2.0 library project as a dependency to the console application. Then, in step 16, we used the <kbd>using</kbd> directive to reference the class library. This will allow us to access the available functionality from the library.</p>
<p>In step 17, we created an instance of the <kbd>ThreadGenerator</kbd> class available in the class library. Then, we used its <kbd>StartThreads()</kbd> method and stored the returned <kbd>StringBuilder</kbd> in a variable. Finally, we displayed the output using <kbd>Console.WriteLine</kbd> and waited for a key press by the user in the last line. In steps 18 to 20, we executed the application and saw the output.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an async method with tasks</h1>
                
            
            
                
<p>In this recipe, we will be looking at the asynchronous programming capabilities found in the C# language. C# has language-level asynchronous capabilities, and therefore you don't have to rely on a third-party library. If you have I/O operations, such as reading data from a network or from a database, you can utilize asynchronous programming. You can also use asynchronous programming for CPU-bound, expensive calculations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Make sure you have Visual Studio 2017 updated. It is also assumed that you have prior experience in asynchronous programming and what it means.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open Visual Studio 2017.</li>
<li>Click File | New | Project<strong> </strong>to create a project. </li>
<li>In the New Project dialog box, expand the Other Project Types node in the left-hand pane and select Visual Studio Solutions. In the right-hand pane, select Blank Solution<strong>.</strong></li>
<li>In the Name: textbox, type <kbd>Chapter6.AsyncTasks</kbd> and, in the Location: textbox, select a path from the drop-down box or click on the Browse... button to locate a path:</li>
</ol>
<div><img class="alignnone size-full wp-image-768 image-border" src="img/1420cdf5-3731-4e51-9d79-704bab1a5435.png" style="width:155.58em;height:22.50em;"/></div>
<ol start="5">
<li>Click OK.</li>
<li>Now, the Solution Explorer (<em>Ctrl</em> + <em>Alt</em> + <em>L</em>) should look like this:</li>
</ol>
<div><img class="alignnone size-full wp-image-769 image-border" src="img/2a4f681f-46f2-4851-9371-ac7109934dbf.png" style="width:32.75em;height:9.25em;"/></div>
<ol start="7">
<li>Now, right-click on the <kbd>Chapter6.AsyncTasks</kbd> label in the Solution Explorer and select Add | New Project<strong>.</strong></li>
<li>In the New Project dialog box, expand the Visual C# node.</li>
<li>Select .NET Standard in the left-hand pane and Class Library (.NET Standard) in the right-hand pane:</li>
</ol>
<div><img class="alignnone size-full wp-image-770 image-border" src="img/fbce3b1b-3d8b-4cad-b90a-2992c2deeddc.png" style="width:44.25em;height:30.58em;"/></div>
<ol start="10">
<li>Now, in the Name: textbox, type <kbd>Chapter6.AsyncTasks.AsyncLib</kbd>. Leave the other defaults as they are and click OK:</li>
</ol>
<div><img class="alignnone size-full wp-image-771 image-border" src="img/f3f1fc01-8569-47f5-adc1-1db6e1daaf8e.png" style="width:155.08em;height:14.17em;"/></div>
<ol start="11">
<li>Now, the Solution Explorer (<em>Ctrl</em> + <em>Alt</em> + <em>L</em>) should look like this:</li>
</ol>
<div><img class="alignnone size-full wp-image-772 image-border" src="img/47c2d979-d33d-4e7c-83fd-4e6cf4684d07.png" style="width:29.00em;height:12.67em;"/></div>
<ol start="12">
<li>Now, select <kbd>Class1.cs</kbd> in the Solution Explorer and press <em>F2</em> to rename the file <kbd>SiteReader.cs</kbd>.</li>
<li>Answer Yes in the confirmation dialog box that asks to rename the class name as well.</li>
<li>Now, double-click on the <kbd>SiteReader.cs</kbd> label in the Solution Explorer.</li>
<li>Let's scroll up in the code window and add the following using directive:</li>
</ol>
<pre>      using System.Net.Http;<br/>      using System.Threading.Tasks;</pre>
<ol start="16">
<li>Now, let's add this class-level variable:</li>
</ol>
<pre>      private HttpClient _httpClient = new HttpClient();</pre>
<ol start="17">
<li>Add the following method inside the open and closed curly brackets of the <kbd>SiteReader</kbd> class:</li>
</ol>
<pre>      public async Task&lt;string&gt; ReadSiteContent(string url)<br/>      {<br/>          var htmlContent = await _httpClient.GetStringAsync(url);<br/><br/>          return htmlContent;<br/>      }</pre>
<ol start="18">
<li>Press <em>Ctrl</em> + <em>Shift</em> + <em>B</em> for a quick build.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In steps 1 to 12, we added a blank solution and then we added a .NET Standard 2.0 class library to the solution. In these steps, we assigned proper names to the solution and the project. In steps 13 and 14, we renamed the default class template to something more meaningful. You can also delete this class and create a new one.</p>
<p>In step 15, we added two namespaces to the code. In step 16, we created a class-level variable and created an instance of the <kbd>HttpClient</kbd> class. In step 17, we created an asynchronous public method that reads the given site content as a <kbd>string</kbd> and returns the read content.</p>
<p>Finally, we performed a quick build to check the syntax.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a WPF application to use the library</h1>
                
            
            
                
<p>In this recipe, we will be creating a Windows Presentation Foundation application to use the library. A basic user interface will be created to show the content.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Make sure you have opened the .NET Standard 2.0 class library we built in the previous recipe. If not, make sure you complete the previous recipe before we dive into this one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open Visual Studio 2017.</li>
<li>Now, open the solution from the previous recipe. Click File | Open | Open Project/Solution, or press <em>Ctrl</em> + <em>Shift</em> + <em>O</em>, and select the <kbd>Chapter6.AsyncTasks</kbd> solution. </li>
<li>Press <em>Ctrl</em> + <em>Shift</em> + <em>B</em> for a quick build to check that everything is fine. </li>
<li>Click on the <kbd>Chapter6.AsyncTasks</kbd> solution label. Click File | Add | New Project.</li>
<li>In the Add New Project template dialog box, expand the Visual C# node in the left-hand pane. </li>
<li>Select Windows Classic Desktop and select WPF App (.NET Framework) in the right-hand pane:</li>
</ol>
<div><img class="alignnone size-full wp-image-773 image-border" src="img/3db8aeb7-f568-469e-94c7-e3abe4c01430.png" style="width:156.08em;height:108.58em;"/></div>
<ol start="7">
<li>Now, in the Name: textbox, type <kbd>Chapter6.AsyncTasks.WPFSiteContent</kbd> as the name of the project. The rest of the fields can be left as they are: </li>
</ol>
<div><img class="alignnone size-full wp-image-774 image-border" src="img/dc1166bc-207b-4165-974a-3bd72617fbc0.png" style="width:155.08em;height:14.50em;"/></div>
<ol start="8">
<li>Click OK.</li>
<li>Now, the Solution Explorer (press <em>Ctrl</em> + <em>Alt</em> + <em>L</em>) should look like this: </li>
</ol>
<div><img class="alignnone size-full wp-image-775 image-border" src="img/570b9caf-66a4-464a-83a7-9389b27249bf.png" style="width:40.58em;height:30.83em;"/></div>
<ol start="10">
<li>Right-click on the References label in the <kbd>Chapter6.AsyncTasks.WPFSiteContent</kbd>.</li>
<li>Select Add Reference.</li>
<li>In the Reference Manager, click on the Projects label in the right-hand pane: </li>
</ol>
<div><img class="alignnone size-full wp-image-776 image-border" src="img/c0134b69-9335-480a-b832-2066baff73b9.png" style="width:130.58em;height:60.42em;"/></div>
<ol start="13">
<li>Check the <kbd>Chapter6.AsyncTasks.AsyncLib</kbd><strong> </strong>project in the left-hand pane.</li>
<li>Click OK.</li>
<li>Now, click on the <kbd>MainWindow.xaml</kbd> tab.</li>
<li>From the toolbox, add a TextBox control, a Button control, and a WebBrowser control to the MainWindow form:</li>
</ol>
<div><img class="alignnone size-full wp-image-777 image-border" src="img/47d81c33-d66d-4244-8859-661712286c41.png" style="width:30.67em;height:20.92em;"/></div>
<ol start="17">
<li>Select the TextBox and press <em>F4</em> to load the Properties window.</li>
<li>Change the following properties:<br/>
<table>
<tbody>
<tr>
<td><strong>Control</strong></td>
<td><strong>Property</strong></td>
<td><strong>Value</strong></td>
</tr>
<tr>
<td>TextBox</td>
<td>Name</td>
<td><kbd>UrlTextBox</kbd></td>
</tr>
<tr>
<td>TextBox</td>
<td>Text</td>
<td><kbd>Delete existing text and leave blank</kbd></td>
</tr>
<tr>
<td>Button</td>
<td>Name</td>
<td><kbd>GoButton</kbd></td>
</tr>
<tr>
<td>Button</td>
<td>Content</td>
<td><kbd>Go</kbd></td>
</tr>
<tr>
<td>WebBrowser</td>
<td>Name</td>
<td><kbd>ContentBrowser</kbd></td>
</tr>
</tbody>
</table>
</li>
<li>Double-click on the Go button to reach the code window.</li>
<li>Scroll up till you reach the <kbd>using</kbd> directives.</li>
<li>Add the following <kbd>using</kbd> directive to the last line of the directives:</li>
</ol>
<pre>      using Chapter6.AsyncTasks.AsyncLib;</pre>
<ol start="22">
<li>Scroll down and add the following code inside the <kbd>GoButton_Click()</kbd> event.</li>
<li>Change the <kbd>GoButton_Click</kbd><strong> </strong> as follows:</li>
</ol>
<pre>      private async void GoButton_Click(object sender, RoutedEventArgs e)</pre>
<ol start="24">
<li>Add this code inside the <kbd>GoButton_Click()</kbd> method:</li>
</ol>
<pre>      var url = UrlTextBox.Text;<br/>      var siteReader = new SiteReader();<br/>      var content = await siteReader.ReadSiteContent(url);<br/><br/>      ContentBrowser.NavigateToString(content);</pre>
<ol start="25">
<li>Press <em>F5</em> to execute the application.</li>
<li>Type a URL inside the textbox and click on the Go button.</li>
<li>You should see output similar to this:</li>
</ol>
<div><img class="alignnone size-full wp-image-778 image-border" src="img/ebdcc10c-e474-471c-88b4-d58bfe0e8167.png" style="width:42.00em;height:28.17em;"/></div>
<ol start="28">
<li>Close the application.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In steps 1 to 10, we opened the existing solution for the .NET Standard 2.0 library project. Then we added a WPF Project to the solution. In steps 11 to 14, we added a reference to the class library we built in the previous recipe. In steps 16 to 18, we added controls to the <kbd>MainWindow</kbd> of the WPF application and then we changed a few properties.</p>
<p>In step 21, we referenced the class library using a <kbd>using</kbd> directive. In step 23, we decorated the <kbd>GoButton_Click()</kbd> method with an <kbd>async</kbd> keyword. In step 24, the first three lines of code demonstrate that we have created a variable to store the URL from the TextBox after it created an instance of the <kbd>SiteReader</kbd> class. Then, we used the <kbd>ReadSiteConent()</kbd> asynchronous method to read the content of a given URL. Finally, we displayed that content in the <kbd>WebBrowser</kbd> control.</p>
<p>In steps 25 to 27, we tested the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a thread pool</h1>
                
            
            
                
<p>In this recipe, we will be looking at thread pools in C#. Basically, a thread pool is a collection of threads that can be used to perform tasks in the background. Once a thread completes its task, then it is sent to a pool of waiting threads, where it can be reused. Let's create a .NET Standard 2.0 library that uses thread pools.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Make sure you have the latest version of Visual Studio 2017 up and running.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open Visual Studio 2017.</li>
<li>Click File | New | Project<strong> </strong>to create a project. </li>
<li>In the New Project dialog box, expand the Other Project Types node in the left-hand pane and select Visual Studio Solutions. In the right-hand pane, select Blank Solution<strong>.</strong></li>
</ol>
<p> </p>
<ol start="4">
<li>In the Name: textbox, type <kbd>Chapter6.ThreadPools</kbd> and, in the Location: textbox, select a path from the drop-down box or click on the Browse... button to locate a path:</li>
</ol>
<div><img class="alignnone size-full wp-image-779 image-border" src="img/1e853955-d4b0-4b88-bc19-dd8629fe4c6e.png" style="width:155.42em;height:22.00em;"/></div>
<ol start="5">
<li>Click OK.</li>
<li>Now, the Solution Explorer (<em>Ctrl</em> + <em>Alt</em> + <em>L</em>) should look like this:</li>
</ol>
<div><img class="alignnone size-full wp-image-780 image-border" src="img/ec77958d-bbfa-42ce-88f8-b81d5464ea23.png" style="width:37.92em;height:10.92em;"/></div>
<ol start="7">
<li>Right-click on the <kbd>Chapter6.ThreadPools</kbd> label in the Solution Explorer and select Add | New Project<strong>.</strong></li>
<li>In the New Project dialog box, expand the Visual C# node.</li>
<li>Select .NET Standard in the left-hand pane and Class Library (.NET Standard) in the right-hand pane:</li>
</ol>
<div><img class="alignnone size-full wp-image-781 image-border" src="img/00b25aa5-02d0-4a4d-a786-410d907d5c73.png" style="width:156.92em;height:108.83em;"/></div>
<ol start="10">
<li>In the Name: textbox, type <kbd>Chapter6.ThreadPools.PoolLib</kbd>. Leave the other defaults as they are and click OK:</li>
</ol>
<div><img src="img/9bb4070b-d2be-4ae0-95b5-5cbc28093b2d.png"/></div>
<ol start="11">
<li>Now, the Solution Explorer (<em>Ctrl</em> + <em>Alt</em> + <em>L</em>) should look like this:</li>
</ol>
<div><img class="alignnone size-full wp-image-782 image-border" src="img/19ad79e3-3945-44b9-8cfd-590fdc5cac38.png" style="width:29.25em;height:13.33em;"/></div>
<ol start="12">
<li>Select <kbd>Class1.cs</kbd> in the Solution Explorer and press <em>F2</em> to rename the file <kbd>ThreadList.cs</kbd>.</li>
<li>Answer Yes in the confirmation dialog box that asks to rename the class name as well.</li>
<li>Double-click on the <kbd>ThreadList.cs</kbd> label in the Solution Explorer.</li>
<li>Let's scroll up in the code window and add the following using directive:</li>
</ol>
<pre>      using System.Text;<br/>      using System.Threading;</pre>
<ol start="16">
<li>Let's add a class-level variable that holds a <kbd>StringBuilder</kbd>:</li>
</ol>
<pre>      StringBuilder messages = new StringBuilder();</pre>
<ol start="17">
<li>Add a main <kbd>ProcessPool()</kbd> method to the class:</li>
</ol>
<pre>      public StringBuilder ProcessPool()<br/>      {<br/>          for (int i=0; i&lt;5; i++)<br/>          {<br/>              ThreadPool.QueueUserWorkItem(new WaitCallback(Process));<br/>          }<br/><br/>          for (int k=0; k&lt;10; k++)<br/>          {<br/>              messages.AppendLine($"Main Thread - {k + 1}");<br/>          }<br/><br/>          return messages;<br/>       }</pre>
<ol start="18">
<li>Finally, let's add the helper method to process the thread:</li>
</ol>
<pre>private void Process(object callback)<br/>{<br/>    for (int j=0; j&lt;10; j++)<br/>    {<br/>        messages.AppendLine($"Thread - {j + 1}");<br/>    }<br/>}</pre>
<ol start="19">
<li>Let's perform a quick build by pressing <em>Ctrl</em> + <em>Shift</em> + <em>B</em>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In steps 1 to 10, we created a blank solution and added a .NET Standard 2.0 library to the project. In between, we assigned meaningful names to the project and to the solution. In step 12, we renamed the default class created by Visual Studio. In step 15, we added the namespaces required to build the library.</p>
<p>In step 16, we created a variable to hold the messages using the <kbd>StringBuilder</kbd> class. This is a class-level variable that is shared across methods inside the class. In step 17, we created a method that creates a thread pool using a helper method in step 18. Inside that method, we use the <kbd>messages</kbd> variable to store the messages during the process.</p>
<p>Finally, in step 19, we performed a quick build to check for the correct syntax.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a .NET console application to use the library</h1>
                
            
            
                
<p>In this recipe, we will be looking at a .NET console-based application to use the library. This console app will reference the library created in the previous recipe and use it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Make sure you have completed the previous recipe. If you have completed it, open it using Visual Studio 2017 and perform a quick build to check that everything is fine.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open Visual Studio 2017.</li>
<li>Now, open the solution from the previous recipe. Click File | Open | Open Project/Solution, or press <em>Ctrl</em> + <em>Shift</em> + <em>O</em>, and select the <kbd>Chapter6.ThreadPools</kbd> solution. </li>
<li>Press <em>Ctrl</em> + <em>Shift</em> + <em>B</em> for a quick build to check that everything is fine. </li>
<li>Click on the <kbd>Chapter6.ThreadPools</kbd> solution label. Click File | Add | New Project.</li>
<li>In the Add New Project template dialog box, expand the Visual C# node in the left-hand pane. </li>
<li>Select Windows Classic Desktop and select Console App (.NET Framework) in the right-hand pane:</li>
</ol>
<div><img class="alignnone size-full wp-image-783 image-border" src="img/60ec763e-38da-4eb1-97cd-58217b461a73.png" style="width:156.67em;height:108.67em;"/></div>
<ol start="7">
<li>In the Name: textbox, type <kbd>Chapter6.ThreadPools.PoolConsole</kbd> as the name of the project. The rest of the fields can be left as they are: </li>
</ol>
<div><img src="img/295b12fa-c00f-4e0f-b878-3a5ff500fe12.png"/></div>
<ol start="8">
<li>Click OK.</li>
<li>Now, the Solution Explorer (press <em>Ctrl</em> + <em>Alt</em> + <em>L</em>) should look like this: </li>
</ol>
<div><img class="alignnone size-full wp-image-784 image-border" src="img/a2f3caf7-9a7d-4cb6-85cd-ea169ac486af.png" style="width:40.50em;height:28.92em;"/></div>
<ol start="10">
<li>Right-click on the References label in the <kbd>Chapter6.ThreadPools.PoolConsole</kbd>.</li>
<li>Select Add Reference.</li>
</ol>
<p> </p>
<ol start="12">
<li>In the Reference Manager, click on the Projects label in the right-hand pane: </li>
</ol>
<div><img class="alignnone size-full wp-image-785 image-border" src="img/21689d31-89ff-4731-ab0e-3bbf3806fa2c.png" style="width:130.75em;height:66.92em;"/></div>
<ol start="13">
<li>Check <kbd>Chapter6.ThreadPools.PoolLib</kbd><strong> </strong>project in the left-hand pane.</li>
<li>Click OK.</li>
<li>Double-click on the <kbd>Program.cs</kbd> label in the Solution Explorer.</li>
<li>Scroll up in the code window and add the following <kbd>using</kbd> directive:</li>
</ol>
<pre>      using Chapter6.ThreadPools.PoolLib;</pre>
<ol start="17">
<li> Let's add the code inside the <kbd>Main()</kbd> method:</li>
</ol>
<pre>      var pool = new ThreadList();<br/>      var output = pool.ProcessPool();<br/><br/>      Console.WriteLine(output);<br/><br/>      Console.ReadLine();</pre>
<ol start="18">
<li>Now, press <em>F5</em> to test our application:</li>
</ol>
<div><img class="alignnone size-full wp-image-786 image-border" src="img/cba65b5b-f6d9-42a5-859c-6c5f83119d7d.png" style="width:154.75em;height:85.92em;"/></div>
<ol start="19">
<li> Press <em>Enter</em> to exit the application.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In steps 1 to 9, we opened the solution created in the previous recipe. Then, we added a .NET console application to the project. In steps 10 to 14, we added a reference to the library we created in the previous recipe. In step 16, we created the reference in the code for the library. In step 17, we  added code to create an instance of the <kbd>ThreadList</kbd> class. We called the <kbd>ProcessPool()</kbd> and stored the return value in a variable.</p>
<p>Finally, we displayed the output in the console window and, in steps 18 and 19, we tested the application.</p>


            

            
        
    </body></html>