<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. ALM – Developers and QA</h1></div></div></div><p>This chapter provides an introduction to <a class="indexterm" id="id606"/>
<strong>Application Lifecycle Management</strong> (<strong>ALM</strong>) and continuous integration methodologies on Xamarin cross-platform applications. As the part of the ALM process that is most relevant for developers, unit test strategies will be discussed and demonstrated, as well as automated UI testing. This chapter is divided into the following sections:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Development pipeline</li><li class="listitem" style="list-style-type: disc">Troubleshooting</li><li class="listitem" style="list-style-type: disc">Unit testing</li><li class="listitem" style="list-style-type: disc">UI testing</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec59"/>Development pipeline</h1></div></div></div><p>The<a class="indexterm" id="id607"/> development pipeline can be described as the virtual production line that steers a project from a mere bundle of business requirements to the consumers. Stakeholders that are part of this pipeline include, but are not limited to, business proxies, developers, the QA team, the release and configuration team, and finally the consumers themselves. Each stakeholder in this production line assumes different responsibilities, and they should all function in harmony. Hence, having an efficient, healthy, and preferably automated pipeline that is going to provide the communication and transfer of deliverables between units is vital for the success of a project.</p><p>In the Agile project management framework, the <a class="indexterm" id="id608"/>development pipeline is cyclical rather than a linear delivery queue. In the application life cycle, requirements are inserted continuously into a backlog. The backlog leads to a planning and development phase, which is followed by testing and QA. Once the production-ready application is released, consumers can be made part of this cycle using live application telemetry instrumentation.</p><div><img alt="Development pipeline" src="img/B04693_10_01.jpg"/><div><p>Figure 1: Application life cycle management</p></div></div><p>In Xamarin <a class="indexterm" id="id609"/>cross-platform application projects, development teams are blessed with various tools and frameworks that can ease the execution of ALM strategies. From sketching and mock-up tools available for early prototyping and design to source control and project management tools that make up the backbone of ALM, Xamarin projects can utilize various tools to automate and systematically analyze project timeline.</p><p>The following <a class="indexterm" id="id610"/>sections of this chapter concentrate mainly on the lines of defense that protect the health and stability of a Xamarin cross-platform project in the timeline between the assignment of tasks to developers to the point at which the task or bug is completed/resolved and checked into a source control repository.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec60"/>Troubleshooting and diagnostics</h1></div></div></div><p>SDKs <a class="indexterm" id="id611"/>associated with Xamarin target platforms and development IDEs are equipped with comprehensive analytic tools. Utilizing these tools, developers can identify issues causing app freezes, crashes, slow response time, and other resource-related problems (for example, excessive battery usage).</p><p>Xamarin.iOS applications<a class="indexterm" id="id612"/> are analyzed using the XCode Instruments toolset. In this toolset, there are a number of profiling templates, each used to analyze a certain perspective of application execution (such as the allocations template that was used in <a class="link" href="ch02.html" title="Chapter 2. Memory Management">Chapter 2</a>, <em>Memory Management</em>, for memory profiling). Instrument templates can be executed on an application running on the iOS simulator or on an actual device.</p><div><img alt="Troubleshooting and diagnostics" src="img/B04693_10_02.jpg"/><div><p>Figure 2: XCode Instruments</p></div></div><p>Similarly, Android <a class="indexterm" id="id613"/>applications<a class="indexterm" id="id614"/> can be analyzed using the device monitor provided by the Android SDK. Using Android Monitor, memory profile, CPU/GPU utilization, and network usage can also be analyzed, and application-provided diagnostic information can be gathered. <strong>Android Debug Bridge</strong> (<strong>ADB</strong>) is a<a class="indexterm" id="id615"/> command-line tool that allows various manual or automated device-related operations.</p><p>For Windows Phone applications, Visual Studio provides a number of analysis tools for profiling CPU usage, energy consumption, memory usage, and XAML UI responsiveness. XAML diagnostic sessions in particular can provide valuable information on problematic sections of view implementation and pinpoint possible visual and performance issues:</p><div><img alt="Troubleshooting and diagnostics" src="img/B04693_10_03.jpg"/><div><p>Figure 3: Visual Studio XAML analyses</p></div></div><p>Finally, Xamarin Profiler, as a <a class="indexterm" id="id616"/>maturing application (currently in preview release), can help analyze memory allocations <a class="indexterm" id="id617"/>and execution time. Xamarin Profiler can be used with iOS and Android applications.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec61"/>Unit testing</h1></div></div></div><p>The <strong>test-driven development</strong> (<strong>TDD</strong>) pattern<a class="indexterm" id="id618"/> dictates that the business requirements and the granular use-cases defined by these requirements <a class="indexterm" id="id619"/>should be initially reflected on unit test fixtures. This allows a mobile application to grow/evolve within the defined borders of these assertive unit test models. Whether following a TDD strategy or implementing tests to ensure the stability of the development pipeline, unit tests are fundamental components of a development project.</p><div><img alt="Unit testing" src="img/B04693_10_04.jpg"/><div><p>Figure 4: Unit test project templates</p></div></div><p>Xamarin Studio and<a class="indexterm" id="id620"/> Visual Studio both provide a number of test project templates targeting different areas of a cross-platform project. In Xamarin cross-platform projects, unit tests can be categorized into two groups: platform-agnostic and platform-specific testing.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec123"/>Platform-agnostic unit tests</h2></div></div></div><p>Platform-agnostic components, <a class="indexterm" id="id621"/>such as portable class libraries containing shared logic for Xamarin applications, can be tested using the common unit test projects targeting the .NET framework. Visual Studio Test Tools or the NUnit test framework can be used according to the development environment of choice. It is also important to note that shared projects used to create shared logic containers for Xamarin projects cannot be tested with .NET unit test fixtures. For shared projects and the referencing platform-specific projects, platform-specific unit test fixtures should be prepared.</p><p>When following an MVVM pattern, view models are the focus of unit test fixtures since, as previously explained, view models can be perceived as a finite state machine where the bindable properties are used to create a certain state on which the commands are executed, simulating a specific use-case to be tested. This approach is the most convenient way to test the UI behavior of a Xamarin application without having to implement and configure automated UI tests.</p><p>While implementing unit tests for such projects, a mocking framework is generally used to replace the platform-dependent sections of the business logic. Loosely coupling these dependent components (see <a class="link" href="ch08.html" title="Chapter 8. Xamarin.Forms">Chapter 8</a>, <em>Xamarin.Forms</em>) makes it easier for developers to inject mocked interface implementations and increases the testability of these modules. The <a class="indexterm" id="id622"/>most popular mocking frameworks for unit testing are Moq and RhinoMocks.</p><div><div><h3 class="title"><a id="note36"/>Note</h3><p>Both Moq and RhinoMocks utilize reflection and, more specifically, the Reflection.Emit namespace, which is used to generate types, methods, events, and other artifacts in the runtime. Aforementioned iOS restrictions on code generation make these libraries inapplicable for platform-specific testing, but they can still be included in unit test fixtures targeting the .NET framework. For platform-specific implementation, the True Fakes library provides compile time code generation and mocking features.</p></div></div><p>Depending on the implementation specifics (such as namespaces used, network communication, multithreading, and so on), in some scenarios it is imperative to test the common logic implementation on specific platforms as well. For instance, some multithreading and parallel task implementations give different results on Windows Runtime, Xamarin.Android, and Xamarin.iOS. These variations generally occur because of the underlying platform's mechanism or slight differences between the .NET and Mono implementation logic. In order to ensure the integrity of these components, common unit test fixtures can be added as linked/referenced files to platform-specific test projects and executed on the test harness.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec124"/>Platform-specific unit tests</h2></div></div></div><p>In a <a class="indexterm" id="id623"/>Xamarin project, platform-dependent features cannot be unit tested using the conventional unit test runners available in Visual Studio Test Suite and NUnit frameworks. Platform-dependent tests are executed on empty platform-specific projects that serve as a harness for unit tests for that specific platform.</p><p>Windows Runtime application projects can be tested using the Visual Studio Test Suite. However, for Android and iOS, the NUnit testing framework should be used, since Visual Studio Test Tools are not available for the Xamarin.Android and Xamarin.iOS platforms.</p><div><img alt="Platform-specific unit tests" src="img/B04693_10_05.jpg"/><div><p>Figure 5: Test harnesses</p></div></div><p>The unit test <a class="indexterm" id="id624"/>runner for Windows Phone (Silverlight) and Windows Phone 8.1 applications uses a test harness integrated with the Visual Studio test explorer. The unit tests can be executed and debugged from within Visual Studio.</p><p>Xamarin.Android and Xamarin.iOS test project templates use NUnitLite implementation for the respective platforms. In order to run these tests, the test application should be deployed on the simulator (or the testing device) and the application has to be manually executed.</p><div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>It is possible to automate the unit tests on Android and iOS platforms through instrumentation; however, these methods will be discussed in the next chapter.</p></div></div><p>In each Xamarin target platform, the initial application lifetime event is used to add the necessary unit tests:</p><div><pre class="programlisting">[Activity(Label = "Xamarin.Master.Fibonacci.Android.Tests", MainLauncher = true, Icon = "@drawable/icon")]
public class MainActivity : TestSuiteActivity
{
    protected override void OnCreate(Bundle bundle)
    {
        // tests can be inside the main assembly
        //AddTest(Assembly.GetExecutingAssembly());
        // or in any reference assemblies
        AddTest(typeof(Fibonacci.Android.Tests.TestsSample).Assembly);

        // Once you called base.OnCreate(), you cannot add more assemblies.
        base.OnCreate(bundle);
    }
}</pre></div><p>In the <a class="indexterm" id="id625"/>Xamarin.Android implementation, the <code class="literal">MainActivity</code> class derives from the <code class="literal">TestSuiteActivity</code>, which implements the necessary infrastructure to run the unit tests and the UI elements to visualize the test results. On the Xamarin.iOS platform, the test application uses the default <code class="literal">UIApplicationDelegate</code>, and generally, the <code class="literal">FinishedLaunching</code> event delegate is used to create the <code class="literal">ViewController</code> for the unit test run fixture:</p><div><pre class="programlisting">public override bool FinishedLaunching(UIApplication application, NSDictionary launchOptions)
{
    // Override point for customization after application launch.
    // If not required for your application you can safely delete this method

    var window = new UIWindow(UIScreen.MainScreen.Bounds);
    var touchRunner = new TouchRunner(window);

    touchRunner.Add(System.Reflection.Assembly.GetExecutingAssembly());

    window.RootViewController = new UINavigationController(touchRunner.GetViewController());

    window.MakeKeyAndVisible();

    return true;
}</pre></div><p>The main shortcoming of executing unit tests this way is the fact that it is not easy to generate a code coverage report and archive the test results.</p><p>Neither of these testing methods provide the ability to test the UI layer. They are simply used to test platform-dependent implementations. In order to test the interactive layer, platform-specific <a class="indexterm" id="id626"/>or cross-platform (Xamarin.Forms) coded UI tests need to be implemented.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec62"/>UI testing</h1></div></div></div><p>In general terms, the<a class="indexterm" id="id627"/> code coverage of the unit tests directly correlates with the amount of shared code which amounts to, at the very least, 70-80 percent of the code base in a mundane Xamarin project. As explained in the previous chapters, one of the main driving factors of architectural patterns was to decrease the amount of logic and code in the view layer so that the testability of the project utilizing conventional unit tests reaches a satisfactory level. Coded UI (or automated UI acceptance) tests are used to test the uppermost layer of the cross-platform solution: the views.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec125"/>Xamarin.UITests and Xamarin Test Cloud</h2></div></div></div><p>The main<a class="indexterm" id="id628"/> UI testing framework used for Xamarin projects is the Xamarin.UITests testing framework. This testing component can be used on various platform-specific projects, varying from native mobile applications to Xamarin.Forms implementations, except for the Windows Phone platform and applications. Xamarin.UITests is an implementation based on the Calabash framework, which is an automated UI acceptance testing framework targeting mobile applications.</p><p>Xamarin.UITests is <a class="indexterm" id="id629"/>introduced to the Xamarin.iOS or Xamarin.Android applications using the publicly available NuGet packages. The included framework components are used to provide an entry point to the native applications. The entry point is the Xamarin Test Cloud Agent, which<a class="indexterm" id="id630"/> is embedded into the native application during the compilation. The cloud agent is similar to a local server that allows either the Xamarin Test Cloud or the test runner to communicate with the app infrastructure and simulate user interaction with the application.</p><div><div><h3 class="title"><a id="note37"/>Note</h3><p>Xamarin Test Cloud is<a class="indexterm" id="id631"/> a subscription-based service allowing Xamarin applications to be tested on real mobile devices using UI tests implemented via Xamarin.UITests. Xamarin Test Cloud not only provides a powerful testing infrastructure for Xamarin.iOS and Xamarin.Android applications with an abundant amount of mobile devices but can also be integrated into Continuous Integration workflows.</p></div></div><p>After installing the appropriate NuGet package, the UI tests can be initialized for a specific application on a specific device. In order to initialize the interaction adapter for the application, the app package and the device should be configured. On Android, the APK package path and the device serial can be used for the initialization:</p><div><pre class="programlisting">IApp app = ConfigureApp.Android.ApkFile("&lt;APK Path&gt;/MyApplication.apk")
                   .DeviceSerial("&lt;DeviceID&gt;")
                   .StartApp();</pre></div><p>For an iOS application, the procedure is similar:</p><div><pre class="programlisting">IApp app = ConfigureApp.iOS.AppBundle("&lt;App Bundle Path&gt;/MyApplication.app")
    .DeviceIdentifier("&lt;DeviceID of Simulator")
    .StartApp();</pre></div><p>Once <a class="indexterm" id="id632"/>the <code class="literal">App</code> handle has <a class="indexterm" id="id633"/>been created, each test written using NUnit should first create the pre-conditions for the tests, simulate the interaction, and finally test the outcome.</p><p>The <code class="literal">IApp</code> interface provides a set of methods to select elements on the visual tree and simulate certain interactions, such as text entry and tapping. On top of the main testing functionality, screenshots can be taken to document test steps and possible bugs.</p><p>Both Visual Studio and Xamarin Studio provide project templates for Xamarin.UITests.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec126"/>Xamarin Test Recorder</h2></div></div></div><p>Xamarin Test Recorder<a class="indexterm" id="id634"/> is an application that can ease the <a class="indexterm" id="id635"/>creation of automated UI tests. It is currently in its preview version and is only available for the Mac OS platform.</p><div><img alt="Xamarin Test Recorder" src="img/B04693_10_06.jpg"/><div><p>Figure 6: Xamarin Test Recorder</p></div></div><p>Using this application, developers can select the application in need of testing and the device/simulator that is going to run the application. Once the recording session starts, each interaction on the screen is recorded as execution steps on a separate screen, and these steps can be used to generate the preparation or testing steps for the Xamarin.UITests implementation.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec127"/>Coded UI tests (Windows Phone)</h2></div></div></div><p>Coded UI tests are<a class="indexterm" id="id636"/> used for automated UI testing on the Windows Phone platform. Coded UI Tests for Windows Phone and Windows Store applications are not any different than their counterparts for other .NET platforms such as Windows Forms, WPF, or ASP.Net. It is also important to note that only XAML applications support Coded UI tests.</p><p>Coded UI tests<a class="indexterm" id="id637"/> are generated on a simulator and written on an Automation ID premise. The Automation ID property is an automatically generated or manually configured identifier for Windows Phone applications (only in XAML) and the UI controls used in the application. Coded UI tests depend on the UIMap created for each control on a specific screen using the Automation IDs. While creating the UIMap, a crosshair tool can be used to select the application and the controls on the simulator screen to define the interactive elements:</p><div><img alt="Coded UI tests (Windows Phone)" src="img/B04693_10_07.jpg"/><div><p>Figure 7:- Generating coded UI accessors and tests</p></div></div><p>Once the UIMap has been created and the designer files have been generated, gestures and the generated XAML accessors can be used to create testing pre-conditions and assertions.</p><p>For <a class="indexterm" id="id638"/>Coded UI tests, multiple<a class="indexterm" id="id639"/> scenario-specific input values can be used and tested on a single assertion. Using the <code class="literal">DataRow</code> attribute, unit tests can be expanded to test multiple data-driven scenarios. The code snippet below uses multiple input values to test different incorrect input values:</p><div><pre class="programlisting">[DataRow(0,"Zero Value")]
[DataRow(-2, "Negative Value")]
[TestMethod]
public void FibonnaciCalculateTest_IncorrectOrdinal(int ordinalInput)
{
    // TODO: Check if bad values are handled correctly
}</pre></div><p>Automated tests can run on available simulators and/or a real device. They can also be included in CI build workflows and made part of the automated development pipeline.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec128"/>Calabash</h2></div></div></div><p>Calabash <a class="indexterm" id="id640"/>is an automated UI acceptance testing framework used to execute <a class="indexterm" id="id641"/>Cucumber tests. Cucumber tests provide an assertion strategy similar to coded UI tests, only broader and behavior oriented. The Cucumber test framework supports tests written in the Gherkin language (a human-readable programming grammar description for behavior definitions). Calabash makes up the necessary infrastructure to execute these tests on various platforms and application runtimes.</p><p>A simple declaration of the feature and the scenario that is previously tested on Coded UI using the data-driven model would look similar to the excerpt below. Only two of the possible test scenarios are declared in this feature for demonstration; the feature can be extended:</p><div><pre class="programlisting">Feature: Calculate Single Fibonacci number.
Ordinal entry should greater than 0.

Scenario: Ordinal is lower than 0.
    Given I use the native keyboard to enter "-2" into text field Ordinal
    And I touch the "Calculate" button
    Then I see the text "Ordinal cannot be a negative number."

Scenario: Ordinal is 0.
    Given I use the native keyboard to enter "0" into text field Ordinal
    And I touch the "Calculate" button
    Then I see the text "Cannot calculate the number for the 0th ordinal."</pre></div><p>Calabash <a class="indexterm" id="id642"/>test execution is possible on Xamarin target platforms since the Ruby API exposed by the Calabash framework has a bidirectional communication line with the Xamarin Test Cloud Agent embedded in Xamarin applications with NuGet packages.</p><p>Calabash/Cucumber tests<a class="indexterm" id="id643"/> can be executed on Xamarin Test Cloud on real devices since the communication between the application runtime and Calabash framework is maintained by Xamarin Test Cloud Agent, the same as Xamarin.UI tests.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec63"/>Summary</h1></div></div></div><p>Xamarin projects can benefit from a properly established development pipeline and the use of ALM principles. This type of approach makes it easier for teams to share responsibilities and work out business requirements in an iterative manner.</p><p>In the ALM timeline, the development phase is the main domain in which most of the concrete implementation takes place. In order for the development team to provide quality code that can survive the ALM cycle, it is highly advised to analyze and test native applications using the available tooling in Xamarin development IDEs.</p><p>While the common codebase for a target platform in a Xamarin project can be treated and tested as a .NET implementation using the conventional unit tests, platform-specific implementations require more particular handling. Platform-specific parts of the application need to be tested on empty shell applications, called test harnesses, on the respective platform simulators or devices.</p><p>To test views, available frameworks such as Coded UI tests (for Windows Phone) and Xamarin.UITests (for Xamarin.Android and Xamarin.iOS) can be utilized to increase the test code coverage and create a stable foundation for the delivery pipeline.</p><p>Most tests and analysis tools discussed in this chapter can be integrated into automated continuous integration processes. The infrastructure used for source control and continuous integration build and testing processes will be the topic of the next chapter.</p></div></body></html>