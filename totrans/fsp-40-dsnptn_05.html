<html><head></head><body>
<div class="chapter" title="Chapter&#xA0;5.&#xA0; Algebraic Data Types">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch05"/>
 Chapter 5.  Algebraic Data Types</h1>
</div>
</div>
</div>
<p>In this chapter, I turn to the F# features that are (almost) missing among mainstream programming languages, such as C#, that are collectively referred to in computer science as <span class="strong">
<strong>algebraic data types</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Algebraic_data_type">https://en.wikipedia.org/wiki/Algebraic_data_type</a>
 ). They advance primitive data types to the higher type level with the help of the composition of other types (primitive or in-turn composite) which are as follows:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<span class="strong">
<strong>Tuples</strong>
</span>
 and <span class="strong">
<strong>records</strong>
</span>
 that represent <span class="emphasis">
<em>product algebraic data types</em>
</span>
</li>
<li class="listitem">
<span class="strong">
<strong>Discriminated unions</strong>
</span>
 that represent <span class="emphasis">
<em>sum algebraic types</em>
</span>
</li>
</ul>
</div>
<p>I'll cover the same facets for each of these composite types as follows:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">Type composition</li>
<li class="listitem">Type equality and comparison</li>
<li class="listitem">Type decomposition</li>
<li class="listitem">Type augmentation</li>
</ul>
</div>
<p>I will revisit the pattern matching as a type decomposition facility that can often be applied outside of the <code class="literal">match</code>
 construction.</p>
<div class="section" title="Combining data with algebraic data types">
<div class="titlepage">
<div>
<div>
<h1 class="title" id="toc_1"><a id="ch05lvl1sec41"/>
 Combining data with algebraic data types</h1>
</div>
</div>
</div>
<p>Usually a conventional programmer considers the matter of data composition through the prism of the object-oriented paradigm.</p>
<p>Everyone usually intuitively understands that <span class="strong">
<strong>primitive data types</strong>
</span>
 are basic, built-in types supported by a compiler or library: <code class="literal">int64</code>
 , <code class="literal">string</code>
 , <code class="literal">bigint</code>
 (although if viewed with a rigor, <code class="literal">string</code>
 may be considered as <code class="literal">char</code>
 array, and <code class="literal">bigint</code>
 as a <span class="strong">
<strong>record</strong>
</span>
 ).</p>
<p>The next thing programmers learn is that instances of primitive types can be aggregated into collections such as <span class="strong">
<strong>arrays</strong>
</span>
 or <span class="strong">
<strong>lists</strong>
</span>
 . However, these collections are monomorphic. That is, the type of all collection members must be the same. Pretty limiting, huh?</p>
<p>The object-oriented paradigm extends primitive types with <span class="strong">
<strong>classes</strong>
</span>
 . The class just represents a custom type that hides the details of the data composition with the help of encapsulation and offers visibility to just the public properties. Typically, .NET libraries offer plenty of such composite types, for example, <code class="literal">System.DateTime</code>
 .</p>
<p>F# certainly supports this way of constructing composite data types as well. However, following the cumbersome and error-prone venue of <span class="strong">
<strong>Plain </strong>
</span>
 <span class="strong">
<strong>Old </strong>
</span>
 <span class="strong">
<strong>C </strong>
</span>
 <span class="strong">
<strong>Objects</strong>
</span>
 (<span class="strong">
<strong>POCO</strong>
</span>
 ) each time when a composite type is required is not in line with the F# promise of succinct and error-free code. What would be the way out? Welcome to algebraic data types!</p>
</div>
</div>


<div class="section" title="Product algebraic data types">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch05lvl1sec42"/>
 Product algebraic data types</h1>
</div>
</div>
</div>
<p>In the simplest case, consider that I use the analogy of <span class="emphasis">
<em>set product</em>
</span>
 to combine types <code class="literal">A</code>
 and <code class="literal">B</code>
 ; the result would be a set of data pairs where the first pair constituent is of type <code class="literal">A</code>
 , the second constituent is of type <code class="literal">B</code>
 , and the whole combination is a Cartesian product of A and B.</p>
<p>F# offers two product algebraic data types, that is, <span class="strong">
<strong>tuples</strong>
</span>
 and <span class="strong">
<strong>records</strong>
</span>
 .</p>
<div class="section" title="Tuples">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_1"><a id="ch05lvl2sec68"/>
 Tuples</h2>
</div>
</div>
</div>
<p>I have already touched tuples in previous chapters; now I'll go deeper into this subject.</p>
<div class="section" title="Tuple composition">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_2"><a id="ch05lvl3sec5"/>
 Tuple composition</h3>
</div>
</div>
</div>
<p>A tuple is a combination of two or more values of any type. The tuple value element type can be of anything: primitive types, other tuples, custom classes, and functions. For example, take a look at the following code line (<code class="literal">Ch5_1.fsx</code>
 ):</p>
<pre class="programlisting">let tuple = (1,"2",fun() -&gt;3) 
</pre>
<p>This represents a tuple assembled from three elements of type <code class="literal">int* string * (unit -&gt; int)</code>
 .</p>
<p>In order to belong to the same type of tuple, two tuple values must have the same number of elements with the similar types in the order of occurrence.</p>
</div>
<div class="section" title="Tuple equality and comparison">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_3"><a id="ch05lvl3sec6"/>
 Tuple equality and comparison</h3>
</div>
</div>
</div>
<p>F# automatically implements the structural equality for tuples if each element type supports the equality constraint. Tuples are equal if all their elements are equal pairwise as shown in the following code (<code class="literal">Ch5_1.fsx</code>
 ):</p>
<pre class="programlisting">let a = 1, "car" 
a = (1, "car") 
</pre>
<p>The preceding equality expression value is <code class="literal">true</code>
 . However, for the value of <code class="literal">tuple</code>
 bound above the following expression does not compile (<code class="literal">Ch5_1.fsx</code>
 ):</p>
<pre class="programlisting">tuple = (1,"2",fun() -&gt;3) 
</pre>
<p>The compiler complains that the <code class="literal">(unit -&gt; int)</code>
 type, which is the function forming the third element of the tuple, does not support the <code class="literal">'equality'</code>
 constraint. The equality relationship is not defined for the F# function values.</p>
<p>Structural comparison for tuples is similarly provided by F# out of the box and is based on pairwise comparisons of elements in a lexicographical order from left to right given that all element types fulfill the <code class="literal">'comparison'</code>
 constraint as shown in the following code (<code class="literal">Ch5_1.fsx</code>
 ):</p>
<pre class="programlisting">a &lt; (2,"jet") 
</pre>
<p>The preceding expression value is <code class="literal">true</code>
 .</p>
</div>
<div class="section" title="Tuple decomposition with pattern matching">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_4"><a id="ch05lvl3sec7"/>
 Tuple decomposition with pattern matching</h3>
</div>
</div>
</div>
<p>This chapter is the perfect place to keep the promise I made in <a class="link" title="Chapter 4.  Basic Pattern Matching" href="text00039.html#page">Chapter 4</a>
 , <span class="emphasis">
<em>Basic Pattern Matching</em>
</span>
 regarding pattern matching in the capacity of the data structure disassembling tool. The following code snippet demonstrates how value binding can carry the functionality of pattern matching outside of the <code class="literal">match</code>
 construction (<code class="literal">Ch5_1.fsx</code>
 ):</p>
<pre class="programlisting">let (elem1, elem2) = a 
printfn "(%i,%s)" elem1 elem2 
</pre>
<p>Here, <code class="literal">elem1</code>
 and <code class="literal">elem2</code>
 effectively acquire values of the first and second elements of tuple <code class="literal">a</code>
 , which is reflected by the <code class="literal">(1,car)</code>
 output.</p>
<p>Elements of a tuple that are of no interest within a particular tuple disassemble pattern may be omitted using the familiar match-all <code class="literal">_</code>
 template, as shown in the following code (<code class="literal">Ch5_1.fsx</code>
 ):</p>
<pre class="programlisting">let (_,_,f) = tuple in 
f() 
</pre>
<p>This snippet highlights how to obtain and invoke a function extracted from the third element of the tuple value; the first two tuple elements are simply ignored with the help of the <code class="literal">_</code>
 template.</p>
</div>
<div class="section" title="Tuple augmentation">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_5"><a id="ch05lvl3sec8"/>
 Tuple augmentation</h3>
</div>
</div>
</div>
<p>The tuple type does not have an explicit name. This fact effectively makes normal F# type augmentation impossible. Nevertheless, there is still some space left for a good hack. This one exploits the need to have interop with other .NET languages.</p>
<p>
<span class="strong">
<strong>Documentation</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233200.aspx">https://msdn.microsoft.com/en-us/library/dd233200.aspx</a>
 ) states that the compiled form of a tuple represents the corresponding overload of class <span class="strong">
<strong>Tuple</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/system.tuple.aspx">https://msdn.microsoft.com/en-us/library/system.tuple.aspx</a>
 ). Given this fact, I can augment the compiled presentation and apply the augmented method using the cast, as shown in the following code (<code class="literal">Ch5_1.fsx</code>
 ):</p>
<pre class="programlisting">let a = 1,"car" 
type System.Tuple&lt;'T1,'T2&gt; with 
  member t.AsString() = 
    sprintf "[[%A]:[%A]]" t.Item1 t.Item2 
(a |&gt; box :?&gt; System.Tuple&lt;int,string&gt;).AsString() 
</pre>
<p>Here, I have augmented a tuple of two generic elements that have type <code class="literal">System.Tuple&lt;'T1,'T2&gt; with</code>
 the <code class="literal">AsString</code>
 instance method, which allows a very distinctive presentation of the tuple value. Then, given the instance of the <code class="literal">int*string</code>
 tuple, I have upcasted it to <code class="literal">obj</code>
 type with the <code class="literal">box</code>
 function and then immediately downcasted it with <code class="literal">:?&gt;</code>
 operator to <code class="literal">System.Tuple&lt;int,string&gt;</code>
 type, followed by calling the <code class="literal">AsString</code>
 augmented method on the deceivingly constructed <code class="literal">System.Tuple&lt;int,string&gt;</code>
 class instance, getting the expected result, that is, <code class="literal">[[1]:["car"]]</code>
 .</p>
<p>Wrapping it up, I can conclude that tuples represent a simple algebraic data type that fits simple designs well. Using tuples instead of custom types for data composition is archetypal for idiomatic F# usage.</p>
</div>
</div>
<div class="section" title="Records">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_6"><a id="ch05lvl2sec69"/>
 Records</h2>
</div>
</div>
</div>
<p>Records represent the other F# native product algebraic data type. It addresses the matter that exceptional simplicity of tuples causing some deficiencies. The most unfavorable feature of tuples is the lack of binding of a tuple to a concrete kind of otherwise structurally similar tuple type. For the F# compiler, there is no difference between <code class="literal">(1,"car")</code>
 and <code class="literal">(10,"whiskey")</code>
 , which puts the burden of distinguishing the instance type upon the programmer. Would it be nice to supply structurally similar but semantically different types with explicit names? Also it would be helpful to label tuple constituents with unique names in order to stop relying just on the element position? Sure, welcome to F# <span class="strong">
<strong>records</strong>
</span>
 !</p>
<div class="section" title="Record composition">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_7"><a id="ch05lvl3sec9"/>
 Record composition</h3>
</div>
</div>
</div>
<p>F# records may be considered as the tuples of explicitly named types with labeled elements. Referring to the tuple sample given in the preceding script <code class="literal">Ch5_1.fsx</code>
 , it can be rewritten as follows (<code class="literal">Ch5_2.fsx</code>
 ):</p>
<pre class="programlisting">type transport = { code: int; name: string } 
let a = { code = 1; name = "car" } 
</pre>
<p>After placing the preceding snippet into FSI, you get the result shown in the following screenshot:</p>
<div class="mediaobject"><img src="Image00021.jpg" alt="Record composition"/>
<div class="caption">
<p>Defining the F# record type and instance</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>The preceding screenshot visually demonstrates the benefits of records over tuples when it comes to the unambiguous labeling of the whole and its parts.</p>
<p>Interestingly, the naming of record fields makes it unnecessary to stick to a certain order of field listing as shown in the following code (<code class="literal">Ch5_2.fsx</code>
 ):</p>
<pre class="programlisting">let b = { name = "jet"; code = 2 } 
</pre>
<p>Without any problems, value <code class="literal">b</code>
 is recognized as a binding of type <code class="literal">transport</code>
 .</p>
<p>After being constructed, F# records are genuinely immutable, similar to tuples. The language provides just another form of record construction off the existing instance using the <code class="literal">with</code>
 modifier as shown in the following code (<code class="literal">Ch5_2.fsx</code>
 ):</p>
<pre class="programlisting">let c = { b with transport.name = "plane" } 
</pre>
<p>This translates into an instance of <code class="literal">transport { code = 2; name = "plane" }</code>
 . Note the use of the "fully qualified" field name, <code class="literal">transport.name</code>
 . I put it this way in order to highlight how it can be possible to resolve ambiguity as different record types may have similarly named fields.</p>
</div>
<div class="section" title="Record equality and comparison">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_8"><a id="ch05lvl3sec10"/>
 Record equality and comparison</h3>
</div>
</div>
</div>
<p>No surprises here. F#, by default, provides structural equality and comparison for records in a manner similar to tuples. However, having an explicit type declaration allows more flexibility in this matter.</p>
<p>For example, if structural equality is not desired and reference equality is required for any reason, it is not a problem for records, which type definition may be decorated with <code class="literal">[&lt;ReferenceEquality&gt;]</code>
 attribute as shown in the following code snippet (<code class="literal">Ch5_2.fsx</code>
 ):</p>
<pre class="programlisting">[&lt;ReferenceEquality&gt;] 
type Transport = { code: int; name: string } 
let x = {Transport.code=5; name="boat" } 
let y = { x with name = "boat"} 
let noteq = x = y 
let eq = x = x 
</pre>
<p>The following screenshot illustrates what happens if running this code in FSI:</p>
<div class="mediaobject"><img src="Image00021.jpg" alt="Record equality and comparison"/>
<div class="caption">
<p>Referential equality for F# records</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Note that after decorating the <code class="literal">Transport</code>
 type with the <code class="literal">ReferenceEquality</code>
 attribute, two structurally equal records, <code class="literal">x</code>
 and <code class="literal">y</code>
 , are not considered equal anymore.</p>
<div class="note" title="Note">
<h3 class="title" id="toc_9"><a id="note7"/>
 Note</h3>
<p>It is worth noting that decorating a record type with the <code class="literal">[&lt;CLIMutable&gt;]</code>
 attribute makes the underlying record a standard mutable .NET CLI type for interoperability scenarios; in particular providing additionally a default parameterless constructor and elements mutability. See <span class="strong">
<strong>Core.CLIMutableAttribute Class (F#)</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.climutableattribute-class-%5Bfsharp%5D">https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.climutableattribute-class-%5Bfsharp%5D</a>
 ) for further details.</p>
</div>
</div>
<div class="section" title="Record decomposition with pattern matching">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_10"><a id="ch05lvl3sec11"/>
 Record decomposition with pattern matching</h3>
</div>
</div>
</div>
<p>Disassembling records with pattern matching is similar to the disassembling tuples and may work with or without the <code class="literal">match</code>
 construction. The latter case is preferable from the standpoint of succinctness as shown in the following code (<code class="literal">Ch5_2.fsx</code>
 ):</p>
<pre class="programlisting">let  { transport.code = _; name = aName } = a 
</pre>
<p>This discards the <code class="literal">code</code>
 field of <code class="literal">a</code>
 as not interesting and binds its <code class="literal">name</code>
 field with the <code class="literal">aName</code>
 value. The same effect can be achieved with even shorter code:</p>
<pre class="programlisting">let { transport.name = aname} = a 
</pre>
<p>If a single field value is required, then simple <code class="literal">let</code>
 <code class="literal">aName' = a.name</code>
 works too.</p>
</div>
<div class="section" title="Record augmentation">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_11"><a id="ch05lvl3sec12"/>
 Record augmentation</h3>
</div>
</div>
</div>
<p>Having an explicit type declaration for F# records allows a great deal of augmenting around. A nice example of augmenting a record type in order to implement a thread safe mutable <span class="strong">
<strong>singleton</strong>
</span>
 property can be found in the <span class="strong">
<strong>SqlClient Type provider code</strong>
</span>
 (<a class="ulink" href="https://github.com/fsprojects/FSharp.Data.SqlClient/blob/c0de3afd43d1f2fc6c99f0adc605d4fa73f2eb9f/src/SqlClient/Configuration.fs#L87">https://github.com/fsprojects/FSharp.Data.SqlClient/blob/c0de3afd43d1f2fc6c99f0adc605d4fa73f2eb9f/src/SqlClient/Configuration.fs#L87</a>
 ). A distilled snippet is represented as follows (<code class="literal">Ch5_3.fsx</code>
 ):</p>
<pre class="programlisting">type Configuration = { 
  Database: string 
  RetryCount: int 
} 
 
[&lt;CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)&gt;]  
[&lt;AutoOpen&gt;] 
module Configuration = 
  let private singleton = ref { Database  = "(local)"; RetryCount = 3 } 
  let private guard = obj() 
 
  type Configuration with 
    static member Current 
    with get() = lock guard &lt;| fun() -&gt; !singleton 
    and set value = lock guard &lt;| fun() -&gt; singleton := value 
 
printfn "Default start-up config: %A" Configuration.Current 
 
Configuration.Current &lt;- { Configuration.Current with Database =    ".\SQLExpress" } 
 
printfn "Updated config: %A" Configuration.Current 
</pre>
<p>Here, <code class="literal">Database</code>
 and <code class="literal">RetryCount</code>
 are kept as fields of the F# record that is placed as a thread safe static property backed by the <code class="literal">singleton</code>
 private reference. The beauty of the pattern is that at any moment, configuration can be changed programmatically at the same time keeping the singleton thread safe.</p>
</div>
</div>
</div>


<div class="section" title="Sum algebraic data types">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch05lvl1sec43"/>
 Sum algebraic data types</h1>
</div>
</div>
</div>
<p>In contrast to the product algebraic data types covered earlier, sum algebraic data types use the <span class="emphasis">
<em>set sum</em>
</span>
 operation for the composition of new types. The easiest case for this type is an <span class="emphasis">
<em>enumeration</em>
</span>
 composed of just a bunch of individual values. A more generic case is a type that groups a bunch of different types called <span class="emphasis">
<em>variants</em>
</span>
 . Each variant contributes a set of its possible values, which are created with the help of the <span class="emphasis">
<em>variant constructor</em>
</span>
 . All possible values of all variants combined with a set sum (union) constitute the sum type.</p>
<p>Another contrast with product types is that of all possible variants, only a <span class="emphasis">
<em>single</em>
</span>
 one can be a value for an instance of the sum type, while <span class="emphasis">
<em>all</em>
</span>
 fields constitute the value of a product type.</p>
<p>This may sound complicated, but the concept is quite simple. Let's dive in.</p>
<div class="section" title="Discriminated unions">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_1"><a id="ch05lvl2sec70"/>
 Discriminated unions</h2>
</div>
</div>
</div>
<p>Sum algebraic data types were introduced in F# by the native data type named <span class="emphasis">
<em>discriminated union</em>
</span>
 (<span class="strong">
<strong>DU</strong>
</span>
 ). The utter flexibility of discriminated unions makes them handy to represent pretty much anything in the world. For this particular reason, F# programmers use discriminated unions to build the domain-specific languages they come up with when approaching solutions for miscellaneous problems. The ability of discriminated unions to provide meaningful naming to entities of arbitrary complexity, along with the benefits of static typing, is indispensable for clarity in representing problems of any scale.</p>
<div class="section" title="Discriminated union composition">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_2"><a id="ch05lvl3sec13"/>
 Discriminated union composition</h3>
</div>
</div>
</div>
<p>The manner of discriminated union composition follows its most natural presentation: it is a list of variant cases called <span class="emphasis">
<em>constructors</em>
</span>
 , separated from each other by the OR sign (<code class="literal">|</code>
 ). Each case reflects the single variant (case). For example, take a look at the following definition (<code class="literal">Ch5_4.fsx</code>
 ):</p>
<pre class="programlisting">type ChargeAttempt =  
  | Original 
  | Retry of int 
</pre>
<p>This can serve as a natural reflection of the payment processing domain part that is concerned with the performing charge of a credit card. <code class="literal">ChargeAttempt</code>
 can be represented by a discriminated union that has two cases: <code class="literal">Original</code>
 , reflecting that the credit card was successfully charged on the first attempt, and <code class="literal">Retry</code>
 , reflecting that the charge had some unsuccessful attempts first and then eventually passed through. <code class="literal">Retry</code>
 reflects the overall amount of charge attempts, for example, <code class="literal">Retry 4</code>
 as shown in the following code (<code class="literal">Ch5_4.fsx</code>
 ):</p>
<pre class="programlisting">let cco = Original 
// equivalent let cco = ChargeAttempt.Original 
let ccr = Retry 4 
// equivalent let ccr = ChargeAttempt.Retry(4) 
</pre>
<p>In the preceding snippet, <code class="literal">cco</code>
 is a value of type <code class="literal">ChargeAttempt</code>
 that has the <code class="literal">Original</code>
 case value; <code class="literal">ccr</code>
 is a value of type <code class="literal">ChargeAttempt</code>
 too, but it has the case value of <code class="literal">Retry 4</code>
 .</p>
<div class="section" title="The empty constructor case">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a id="ch05lvl4sec0"/>
 The empty constructor case</h4>
</div>
</div>
</div>
<p>The <span class="emphasis">
<em>empty constructor</em>
</span>
 case variant represents the simplest case form. It is just a pure label without any kind of associated extra type. We already have used this case variant in the preceding code, it stands behind the solitary label <code class="literal">Original</code>
 .</p>
</div>
<div class="section" title="The single constructor case">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a id="ch05lvl4sec1"/>
 The single constructor case</h4>
</div>
</div>
</div>
<p>The <span class="emphasis">
<em>single constructor</em>
</span>
 case represents a discriminated union that has only one case. This is a very useful ubiquitous pattern that structures the underlying problem's domain and promotes type safety. For example, I need to represent an electric bulb that has characteristics such as electric voltage and optical brightness. Using single constructor cases, this can be achieved as follows (<code class="literal">Ch5_4.fsx</code>
 ):</p>
<pre class="programlisting">type Brightness = Brightness of int 
type Voltage = Voltage of int 
type Bulb = { voltage: Voltage; brightness: Brightness } 
 
let myBulb = { voltage = Voltage(110); brightness= Brightness(2500)} 
</pre>
<p>A person reading the preceding code instantaneously gets introduced to the key entities to operate with. Also, having the preceding numeric values wrapped into a discriminated union single constructor case creates an extra layer of type safety. That is, number <code class="literal">2500</code>
 wrapped into constructor <code class="literal">Brightness(2500)</code>
 can be used only for the <code class="literal">brightness</code>
 field of the <code class="literal">Brightness</code>
 type.</p>
</div>
</div>
<div class="section" title="Discriminated union equality and comparison">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_3"><a id="ch05lvl3sec14"/>
 Discriminated union equality and comparison</h3>
</div>
</div>
</div>
<p>Discriminated unions provide structural equality and comparison out of the box as shown in the following code (<code class="literal">Ch5_4.fsx</code>
 ):</p>
<pre class="programlisting">let lamp1br = Brightness(2500) 
lamp1br = Brightness(2500) // true 
lamp1br &lt; Brightness(2100) // false 
</pre>
</div>
<div class="section" title="Discriminated union decomposition with pattern matching">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_4"><a id="ch05lvl3sec15"/>
 Discriminated union decomposition with pattern matching</h3>
</div>
</div>
</div>
<p>Discriminated unions are aligned exceptionally well with pattern matching, so decomposing discriminated unions with the help of pattern matching is a breeze as shown in the following code (<code class="literal">Ch5_4.fsx</code>
 ):</p>
<pre class="programlisting">match myBulb.brightness with 
| Brightness(v) -&gt; v 
// retrieves back 2500 wrapped upon construction 
</pre>
</div>
<div class="section" title="Discriminated union augmentation">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_5"><a id="ch05lvl3sec16"/>
 Discriminated union augmentation</h3>
</div>
</div>
</div>
<p>Similarly to F# records, discriminated unions can be seriously augmented. Let's consider the following real-life augmentation example. In the electronic payments world, the payment amount may be discounted depending upon the chosen payment instrument. The quantity of the discount may be preset as follows (the whole setup and concrete numbers below are fictitious):</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">For a credit card, the discount is zero</li>
<li class="listitem">For a debit card, the discount is $0.35</li>
<li class="listitem">For ACH, the discount is $0.75</li>
</ul>
</div>
<p>Discounts are a part of the payment service configuration and may change from one marketing campaign to another.</p>
<p>Discount application depending upon the payment instrument can be achieved via the discriminated union augmentation as follows (<code class="literal">Ch5_5.fsx</code>
 ):</p>
<pre class="programlisting">type PaymentInstrumentDiscount = 
  | CreditCard of decimal  
  | DebitCard of decimal 
  | ACH of decimal 
 
  member x.ApplyDiscount payment = 
    match x with 
    | CreditCard d -&gt; payment - d 
    | DebitCard d -&gt; payment - d 
    | ACH d -&gt; payment - d 
</pre>
<p>Here, the particular discount amount is tied to each payment instrument case via the discriminated union case constructor: <code class="literal">CreditCard</code>
 , <code class="literal">DebitCard</code>
 , or <code class="literal">ACH</code>
 . Along with the distinct cases, the type shares the <code class="literal">ApplyDiscount</code>
 single instance method, which calculates the discounted amount for an original payment amount based on the current discount for the selected payment instrument. The results of running the preceding script in FSI are shown in the following figure, where discounted payment amounts are shown for a payment of $20.23 for each of the covered payment instruments:</p>
<div class="mediaobject"><img src="Image00022.jpg" alt="Discriminated union augmentation"/>
<div class="caption">
<p>Augmenting F# discriminated union</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
</div>
</div>
</div>


<div class="section" title="Summary">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch05lvl1sec44"/>
 Summary</h1>
</div>
</div>
</div>
<p>In this chapter you get familiar with extremely important F# features that represent algebraic data types. For each of the types, the topics of composition, decomposition, standard and custom equality and comparison, and augmentation are covered. In the end, you are expected to understand the reasons behind the superiority of F# data composition with native algebraic data types over custom POCOs.</p>
<p>In the next chapter, I'll turn to the exciting subject of F# sequences that represent data and calculation dualism.</p>
</div>
</body></html>