- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing Your Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Testing code** is an overloaded term when it comes to development. It can
    refer to several concepts, such as load testing, unit tests, or integration testing,
    just to name a few. All testing concepts are important for developers to understand
    regarding the **Software Development Life Cycle** (**SDLC**). Each has its purpose
    and is equally important to provide stability and confidence, and even provide
    documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding testing concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best approaches for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Entity Framework Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first section, we’ll cover the basic concepts of testing, including unit,
    integration, regression, load, system, and UI tests.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll review some best approaches when writing solid tests for software,
    including why tests are necessary, how many unit tests are required, using the
    **Arrange, Act, Assert** (**AAA**) technique when writing unit tests, why unit
    test scaffolding should be avoided, why to avoid large unit tests, how and why
    to avoid static methods, and, finally, how to use tests for documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll apply our knowledge of this chapter by creating a full integration
    test using Entity Framework Core.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We recommend using a favorite editor to view this book’s GitHub repository.
    Our recommendations include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio (preferably 2022, though any version is fine)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JetBrains Rider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The editor we’ll be using is Visual Studio 2022 Enterprise, but any version
    (Community or Professional) will work with the code.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter is located in Packt Publishing’s GitHub repository,
    which is located in the `Chapter07` folder, at [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).
  prefs: []
  type: TYPE_NORMAL
- en: Understand testing concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests are important to developers because they provide stability to software,
    confidence in their code, and the added benefit of documenting complex code. Unit
    tests provide numerous benefits, as we’ll see in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll review the concepts of testing and why each one is important
    to the stability and confidence in building a website.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The smallest test we can write to confirm the code functions as expected is
    a unit test. Unit tests are usually created to test small(-ish) methods, as well
    as to test multiple parameters sent into those methods and expect a certain result.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the types of unit tests to write is a simple process of finding
    conditions in a method and writing the relevant test for the behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following scenarios could justify unit tests throughout a method:'
  prefs: []
  type: TYPE_NORMAL
- en: Successful flow of a method (that is, the happy path)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure of a method’s behavior (that is, the unhappy path)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any branching or condition (if..then, switch, inline if, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different parameters passed into the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have a large system, the number of unit tests is expected to be in the
    hundreds since these small, granular methods comprise most of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows an extension method formatting a date/time object
    for display purposes. Since it’s self-contained, we can simply create a date/time
    object and test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a new date with a time. The unit test is formatted using the
    AAA technique (which we’ll cover in a bit) and returns a string to be displayed
    in our HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Once unit tests are in place, the next step is to provide integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next level of testing is integration tests, which require additional functionality
    as to how the system is tested. Integration tests involve grouping modules and
    the ability to test those components as a group, which contrasts with unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, the primary difference between integration and unit tests
    is external resources. If a unit test accesses an external resource (such as a
    disk drive, database, network call, or API), it can be considered an integration
    test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a simple integration test where we’re connecting
    to a local test database to confirm the connection of the database and returning
    a valid `IndexModel` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In `DbContextOptionsBuilder`, we created a connection to our local database,
    created a valid `AttractionService` while passing in our valid `ThemeParkDbContext`,
    and confirmed we have the right type of model.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, there are different ways to conduct integration tests, such as creating
    a mocked-up database or API, duplicating an environment, or even creating a new
    server for our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Regression tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regression tests are the functional and nonfunctional tests we’ve performed
    in the past. By nature, these are the past successful tests we ran against the
    system. Regression tests are types of tests that are conducted to confirm new
    features don’t break existing features. These include the unit tests and integration
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Load testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have the tests (unit and integration) running in the CI/CD pipeline
    (see [*Chapter 2*](B19493_02.xhtml#_idTextAnchor031)) and are expecting a large
    number of users to hit the site, it is advantageous to create load test(s) for
    the site.
  prefs: []
  type: TYPE_NORMAL
- en: When load testing a website, subject it to stress levels beyond what a single
    developer experiences when running the site standalone. Load testing simulates
    a large number of users hitting the website concurrently and reports on whether
    the site can handle a large influx of users.
  prefs: []
  type: TYPE_NORMAL
- en: The results of a load test may require several team members to help with the
    performance of the website. Not only would developers be involved, but **database
    administrators** (**DBAs**), system administrators, and even architects would
    be involved with fixing the performance of the site.
  prefs: []
  type: TYPE_NORMAL
- en: A continuous increase in performance should be the goal of the website and creating
    load tests to measure performance is key to that.
  prefs: []
  type: TYPE_NORMAL
- en: System testing (end-to-end or E2E)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System testing is based on certain scenarios and is a team effort. Users of
    the system test new features introduced into the system while other team members
    conduct regression system testing to confirm new features don’t break existing
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Members of the team create scenarios for users. These users are then asked to
    walk through each scenario and provide feedback on whether it works or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example scenario could be broken down into several categories, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shopping cart:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log in to the website
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Place an item into the shopping cart
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on checkout
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive a confirmation page with an order number
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the scenario succeeds, the top scenario (“shopping cart”) will contain a
    green checkmark, meaning all steps passed with no issues. If one of the steps
    failed, a red “X” with a reason underneath it would appear and be placed into
    the backlog for developers to examine later.
  prefs: []
  type: TYPE_NORMAL
- en: These types of tests require multiple users to go through the site and find
    issues with certain scenarios. There are times when manually testing a site is
    necessary, but if there’s time available, it may make sense to automate these
    scenarios using a **user interface** (**UI**) testing approach.
  prefs: []
  type: TYPE_NORMAL
- en: UI testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UI testing is visually conducted through a software tool such as Selenium or
    Cypress and automates an end user clicking around or a customer navigating the
    website based on a given scenario. This requires a tester to understand how the
    UI testing software works; they should know how to access elements on a page,
    know how to place values into those elements, and know how to activate events
    such as click and blur to simulate an end user clicking a button.
  prefs: []
  type: TYPE_NORMAL
- en: These types of tests are usually done after work hours through a CI/CD pipeline
    but can be run during work hours on a dedicated server (that is, a QA server)
    to identify issues early.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed various types of testing, including unit tests,
    integration tests, regression tests, load tests, system tests, and UI testing,
    and how each one is important and leverages the other.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at what developers are accustomed to when it
    comes to unit tests, including why we write unit tests, debunking the 100% test
    coverage myth, how using AAA is a great approach for unit tests, why we should
    write a unit test library, creating large unit tests, why unnecessary mocks should
    be avoided, and why unit tests have the added benefit of documentation. We’ll
    also learn how to identify slow integration tests, when to write a unit test,
    and how to avoid testing .NET code.
  prefs: []
  type: TYPE_NORMAL
- en: Best approaches for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every company has its way of testing software. Whether it’s manually or automated,
    it’s a requirement for developers. Developers are becoming more than just people
    who type code. We’re required to design, write, test, debug, document, build,
    and deploy software.
  prefs: []
  type: TYPE_NORMAL
- en: Automating tests using a CI/CD approach is where companies can save time and
    provide consistent stability and quality when releasing software to the public.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll cover the standards of why testing is important, how
    to avoid the 100% test coverage myth, what AAA is and why it’s a great approach
    for unit tests, how to avoid writing a unit test library, large unit tests, and
    unnecessary mocks. We’ll also learn about why tests have the added benefit of
    documentation, how to identify slow integration tests, when to write a unit test,
    and how to avoid testing .NET code.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we write tests?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While some believe testing starts with developers, I believe it should start
    with management.
  prefs: []
  type: TYPE_NORMAL
- en: Developers consider tests as an absolute requirement when writing software,
    but if management believes tests are a waste of time, it may be time to update
    the resume.
  prefs: []
  type: TYPE_NORMAL
- en: Management, and possibly some developers, have various opinions about the stability
    of their software and the impact tests have on timetables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for tests is simple: it allows developers to confirm the code they
    write to perform as expected. Further, if tests are providing a simple way to
    consume a certain module of code, those tests provide clarity to others as well
    as the original author, for that matter.'
  prefs: []
  type: TYPE_NORMAL
- en: The “100% test coverage” myth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we swing the pendulum to the other side, some managers require 100% test
    coverage. While some people believe it’s possible, 100% is not achievable or desirable.
  prefs: []
  type: TYPE_NORMAL
- en: Tests should be created where they are needed, not just for the sake of coverage.
    This creates a false metric and presents an illusion of “100% test coverage” if
    some unit tests are included to fulfill a metric. Developers may build tests just
    to “make their quota” to achieve this mythical metric. Each test should provide
    integrity with solid results and value.
  prefs: []
  type: TYPE_NORMAL
- en: This metric goes hand in hand with the **Line-Of-Code** (**LoC**) false metric
    as well because a developer who can write code with the least amount of lines
    is more efficient than a developer who writes less efficient code. More doesn’t
    always mean better.
  prefs: []
  type: TYPE_NORMAL
- en: Using AAA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we write our unit tests, the best way is to use the AAA technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: Initialize the code for a test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Act**: Perform the actual test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: Determine whether the result is the expected behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Arrange step should initialize the code and be as minimal as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The Act step should execute the code in question and should look similar to
    (if not exactly) like code in production.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Assert step compares the result with what we’re expecting back
    from the code.
  prefs: []
  type: TYPE_NORMAL
- en: The AAA technique provides the easiest way to identify how tests in a system
    are tested.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid writing unit test code for your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the AAA concept is a simple way of writing unit tests, there is another
    approach that I consider a code smell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine this scenario: the developer has to write a unit test where they have
    to make a database call using Entity Framework Core. The Arrange step has 30 lines
    of code to prepare the Act step to work properly. The developer takes these 30
    lines of code and moves them into a library, making them available for other unit
    tests.'
  prefs: []
  type: TYPE_NORMAL
- en: These 30 lines of code are the code smell I mentioned. It makes more sense to
    refactor the code and abstract it even further to simplify the code. The Arrange
    step should not include an additional library of custom code to run a unit test.
    It should focus on testing the production code already written, not writing additional
    testing code to make the code pass.
  prefs: []
  type: TYPE_NORMAL
- en: However, if there is a need for a helper library, it shouldn’t contain any branching
    statements, which would require the need to unit test the unit testing helper
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid large unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers have various definitions of what “large” is considered. Unit tests
    with more than one page (a screen) of code or more than 30 lines of code should
    be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'These types of unit test methods present a problem: they are one step away
    from creating a library for the Arrange step from our previous tip.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, it’s considered a code smell, where someone may need to take a step back
    and look at better ways to produce smaller setups instead of large code blocks
    of initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid unnecessary mocks, fakes, or stubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when a method on a class doesn’t have any dependencies and is
    completely isolated. When we encounter this, we may not need to create a mocked
    object to fully unit test the method.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking is when we want to test a predefined behavior where stubs return a predefined
    value. Fakes are fully populated objects with working implementations.
  prefs: []
  type: TYPE_NORMAL
- en: At the very beginning of this chapter, we mentioned what a unit test was. We
    also created a simple extension method called `.ToFormattedDateTime()`. Since
    it’s an isolated method, we don’t require a mocked date/time object. We simply
    call the method.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have a large library of extension methods that contain strings,
    we can create a unit test, create a string, pass it in, and check the return value
    is what is expected. If it requires further testing, rinse and repeat with different
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: When there’s a simple method, sometimes, it’s easier to test its functionality.
    No mock, fake, or stub is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Using tests as documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every unit test should contain some explanation of what is tested either in
    the method signature or in a comment explaining the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests should be informative to peers (and our future self) and indicate
    knowledge of what’s involved in the effort (or abstraction) of completing each
    unit test and how it relates to the production code under test.
  prefs: []
  type: TYPE_NORMAL
- en: Along with informative unit tests, directory structure can also act as documentation
    and can go a long way. We should mirror the directory structure of the application
    in the unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: If we see a folder in the application (or have a project) named `Data`, create
    a similar folder or project for the unit tests called `Data.Tests`. While this
    may be a simple concept, it helps our peers know immediately where and what the
    tests relate to in the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we look at a sample project with unit tests, you may have seen
    this type of structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Example of well-structured tests for a project](img/B19493_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Example of well-structured tests for a project
  prefs: []
  type: TYPE_NORMAL
- en: While some folders are missing in the `ThemePark.Tests` project, we can immediately
    see that the `Extensions`, `Pages`, and `Services` folders contain at least one
    type of test. The presence of test folders mirroring the project folders itself
    makes it known that they contain unit or integration tests and shows a need for
    additional tests to be included in the testing project.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying slow integration tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integration tests are performed using external resources such as a database,
    filesystem, or API. Therefore, integration tests will always run slower than unit
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: If we are working with a test environment to mimic another environment (such
    as arranging a QA environment to mimic production), the ability to detect slow
    connections provides a safeguard that an environment is working as expected. Ever
    heard the statement “It works in QA, but not in production” before?
  prefs: []
  type: TYPE_NORMAL
- en: However, if we’re working with an in-memory representation of an environment,
    it doesn’t make sense to identify whether a test is slow or not, does it? Compared
    to an actual environment, an in-memory representation of an environment will always
    run faster.
  prefs: []
  type: TYPE_NORMAL
- en: One example of this is using the `Stopwatch` class to gauge processes (a page
    or API) to determine whether they’re fast or *very* fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at our Entity Framework example from [*Chapter 5*](B19493_05.xhtml#_idTextAnchor114),
    and we add an integration test to the project, we can create a simple way to identify
    whether our page call is slow or not, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this integration test, we are testing the main page of our `ThemePark` application
    and finding out if it performs well or not. First, we arrange our classes, since
    `IndexModel` accepts `ILogger<PageModel>` and `IAttractionService`. Once we create
    our stopwatch, we call `IndexModel` (Act) and stop the stopwatch immediately.
    We convert it into seconds and conduct our Assert step.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we are performing an in-memory integration test for illustration
    purposes, but this concept is best suited to integration tests with external resources
    to identify latency issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, we can’t tell if it’s in memory or not just by reading
    the test. It’s encapsulated in `IndexModel` and its goal is meant to identify
    whether it performs quick or not.
  prefs: []
  type: TYPE_NORMAL
- en: Find a bug, write a test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit tests are vital to a stable product, regardless of whether it’s a web application
    or a smartphone app. Every developer will most definitely experience bugs in the
    application, so it makes sense to always keep the unit tests up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we (or the users) encounter a bug, repeat this mantra: *Find a bug, write
    a test*. This may be a simple concept, but it’s recommended.'
  prefs: []
  type: TYPE_NORMAL
- en: When anyone finds a bug in the application, immediately write a unit test about
    that bug. This gives us peace of mind when deploying an application. If we had
    a bug and confirmed a unit test fixed the problem, we’ll have enough confidence
    to say it was tested before being deployed. It’s one thing to fix the problem,
    but adding a test makes the code more bulletproof and provides confidence that
    the bug won’t happen again.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid testing .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET is a large framework. Unit tests are meant to test specific code. *YOUR
    code*. There is no need to create unit tests for .NET code (or other libraries/frameworks
    for that matter) when it’s already been tested by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if there is a test for determining whether a substring method returns
    the right value, this is testing the .NET framework. *Don’t write this* *unit
    test*.
  prefs: []
  type: TYPE_NORMAL
- en: Our efforts are better suited to a higher scope of the method. Focus on unit
    testing the calling method where our code lives as opposed to a .NET method.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we examined why creating unit tests is important and why 100%
    test coverage is a myth. We also learned about various common unit testing strategies,
    such as how to use an AAA scaffolding for our unit tests, why it’s considered
    a code smell to write additional unit test libraries when creating large unit
    tests, and why sometimes mocking libraries aren’t necessary for everything.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about using tests as documentation using comments and folders,
    identifying slow integration tests by adding stopwatches, finding a bug and immediately
    writing a test to bulletproof our code even further, and how to avoid testing
    .NET methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll review our strategies and apply them to our `ThemePark`
    application from [*Chapter 5*](B19493_05.xhtml#_idTextAnchor114).
  prefs: []
  type: TYPE_NORMAL
- en: Testing data access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, Entity Framework has strived to become unit testable and gives
    developers a better level of confidence when working with data access.
  prefs: []
  type: TYPE_NORMAL
- en: Building on when we created a sample database with Entity Framework Core in
    [*Chapter 5*](B19493_05.xhtml#_idTextAnchor114), in this section, we’ll cover
    a simple way to use a SQLite in-memory database to confirm the functionality of
    our application… even though we don’t have a database connection. Using the in-memory
    provider option, Microsoft has recommended avoiding this approach and using either
    SQLite to conduct database calls or using a production (or better, a QA) database
    for our queries.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid in-memory providers
  prefs: []
  type: TYPE_NORMAL
- en: 'Since in-memory is an extremely simplistic implementation of a database, Microsoft
    has recommended using alternative methods for testing and avoiding the in-memory
    provider for databases. Refer to the following URL for additional details: [https://learn.microsoft.com/en-us/ef/core/testing/testing-without-the-database](https://learn.microsoft.com/en-us/ef/core/testing/testing-without-the-database).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the SQLite provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we don’t have a way to access data yet in our tests, we have to add SQLite
    to get as close to an implementation as possible. Using NuGet, we have to add
    the following NuGet packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore.Sqlite`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore.InMemory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have those in our tests, we can proceed with creating our `AttractionService`
    and `LocationService` tests to confirm they work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AttractionService test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are using `AttractionService` as a “repository,” we only need to pass
    in `DbContext` for it to work as expected. Currently, `ThemeParkDbContext` creates
    seeded data for an empty database.
  prefs: []
  type: TYPE_NORMAL
- en: This is perfect for our needs because when passing in `ThemeParkDbContext`,
    `DbContext` could be an in-memory representation or an actual connection to a
    production database. In this case, we are creating an in-memory SQLite database
    for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The SQLite provider opens connections when a call is made and deletes the connection
    when it’s closed. We create the connection during setup and provide a `[Cleanup]`
    attribute to deallocate the connection. This is specifically for SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `AttractionService` integration test is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we tell our tests to run the setup method using the
    `[TestInitialize]` attribute and clean up our mess using the `[TestCleanup]` attribute.
    The `[TestInitialize]` attribute attaches to a method for initialization purposes.
    The `[TestCleanup]` attribute identifies a method to clean up what was initialized
    with the `[``TestInitialize]` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re using SQLite for our database, we must create a connection in the
    `Setup()` method and open the connection. Once we open it, we need to create `DbContextOptions`
    for our fake database. The final step is to ensure the databases were created
    for our tests.
  prefs: []
  type: TYPE_NORMAL
- en: There are two things to notice here. The first is that we didn’t need a mocked
    object for `DbContext`. In the `OnConfiguring()` configuration method of `DbContext`,
    if we have a configuration (such as an `appsettings.json` file), we should use
    it. If not, we should create a SQLite in-memory database for our testing.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to notice is our Act step in our integration test. This line
    should be the same one that we have in our production code. The closer we can
    get test calls to match what you have in production, the more confident we’ll
    feel about the code, along with the accuracy and value of those tests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the LocationService test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we have a structure of what our tests consist of now, we can use those
    tests for `LocationService`. Our `LocationService` test consists of two methods
    – `GetAllLocationsAsync()` and `GetLocationAsync(int)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Again, notice that we didn’t need to mock `DbContext`. We created `LocationService`
    by passing in `ThemeParkDbContext` and used it as we would in a production environment.
    The ability to set up and tear down a full database is one of the greatest ways
    to test the database’s functionality. While using an existing database would be
    as equally beneficial, this provides a quicker way of “setting up” and “tearing
    down” database functionality without the clutter or modifications when others
    update the database. If others are using an existing database, this could cause
    integration tests to fail in a CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to set up tests with SQLite and how to perform
    queries using an in-memory database to mimic a production database. We also gave
    three examples of testing Entity Framework Core.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing and documentation are often areas that get deprioritized or overlooked
    by development teams. However, testing is a requirement for code bases. As a final
    point, developers should make their tests as small and fast as possible using
    as close to production code in the Act step as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered the different types of testing, which include unit,
    integration, regression, load testing, system (or E2E tests), and UI testing.
  prefs: []
  type: TYPE_NORMAL
- en: Once we understood the difference between these types of testing, we examined
    why creating unit tests is important and why test coverage goals shouldn’t be
    100%. We then covered common unit testing strategies, such as how to use AAA scaffolding
    for our unit tests, why writing too much code for our unit tests is considered
    a code smell, and why mocking libraries aren’t required.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to supplement documentation by using comments and folders,
    how to identify slow integration tests by adding stopwatches, how to find a bug
    and immediately write a test to bulletproof our code even further, and how to
    avoid testing .NET methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll cover exception handling and some of the better ways
    to handle errors in the application.
  prefs: []
  type: TYPE_NORMAL
