# 十一、微服务简介

到目前为止，我们已经通过实践示例介绍了 RESTful api，并创建了小型应用。 在前一章中，我们开发了一个应用，并讨论了 RESTful API、安全性、测试、性能和部署。

本章简要介绍了微服务，它是我们 RESTful 服务之旅的下一站。 在本章中，我们将介绍微服务的基本组件，并使用一个正在转换为微服务的单一应用的例子。

我们将涵盖以下议题:

*   microservices 是什么?
*   交流 microservices
*   Microservices 测试策略
*   可伸缩性
*   ASP 中的微服务生态系统.NET Core

# 概述 microservices

简单地说，当将应用或模块划分为更小的、独立的服务时，其结果也称为**微服务**。 这些小部件也可以独立部署。

如果我们回顾历史，我们会发现微服务这个术语第一次被使用是在 2011 年的软件架构师研讨会上。 2012 年 3 月，詹姆斯·刘易斯(James Lewis)提出了他对“微服务”一词的一些看法。 到 2013 年底，IT 行业的各种团体已经开始讨论微服务，到 2014 年，微服务已经变得足够流行，被认为是大型企业的有力竞争者。

那么，到底什么是微服务呢? 有太多的定义，所以你可以根据自己对这个术语的理解或者你可能有什么样的用例和讨论来定义微服务。 让我们来看看官方网站对微服务的定义:(来源:[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview-microservices](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview-microservices))

<q>*"Microservice applications are composed of small, independently versioned, and scalable customer-focused services that communicate with each other over standard protocols with well-defined interfaces."*</q>

# Microservice 属性

在前一节中，我们看到微服务完全独立于系统中的其他服务，并在它们自己的进程中运行。 根据这个定义，有一些属性定义了微服务完全独立于其他组件。 让我们先看看核心属性是什么:

*   **独立功能**:不要试图在单个微服务中实现太多。 相反，设计它只有一个原因，并做好它。 这意味着设计应该尽量避免依赖于功能的任何其他部分。 在我看来，这部分非常重要，因为它为其他属性奠定了基础。
*   **隔离的数据和状态**:每个服务拥有自己的数据和状态。 它不与任何其他应用或部分共享所有权。
*   **独立部署**:上述各点的累积效应。 这有助于您进行连续部署。
*   **技术采用**:考虑了前两点后，这就容易多了，因为这对任何现有模块都不再有影响。 这里的美妙之处在于，你可以在两种不同的技术中拥有两种不同版本的微服务。 非常有益的。
*   **一致性和弹性**:它必须是完美的。 如果您不能指望某个服务在预期的时间内返回，或者指望它总是可用，那么它的全部目的就不复存在了。

# 理解 microservice 架构

我们已经讨论了微服务体系结构是如何开发包含一组较小服务的单个应用的。 这些服务是独立的，运行在它们自己的进程中。

换句话说，我们可以说微服务是隔离我们的服务的一种方式，这样它们就可以为设计、开发、部署和升级的目的而彼此独立地处理。

微服务有很多好处，具体如下:

*   **较小的代码库**:每个服务都较小，因此更容易作为一个单元进行开发和部署
*   **独立环境的易用性**:随着服务的分离，所有的开发人员都独立工作，独立部署，没有人担心任何模块依赖

# 交流 microservices

在处理微服务体系结构时，仔细考虑消息传递机制的选择非常重要。 如果忽略了这一方面，那么就会破坏使用微服务体系结构进行设计的整个目的。

让我们继续讨论同步和异步消息传递以及不同的消息传递格式的选择。

# 同步消息传递

当系统期望从服务中得到及时的响应，并且系统等待该响应，直到从服务接收到响应为止，它被称为**同步消息**。 REST 是微服务体系结构中最受欢迎的选择之一。 它很简单，并且支持 HTTP 请求-响应，因此不需要寻找替代方案。 这也是大多数微服务实现使用 HTTP(基于 api 的样式)的原因之一。

# 异步消息传递

当系统没有立即期待来自服务的响应时，它可以在不阻塞调用的情况下继续处理，它被调用为**异步消息**。

# 消息格式

在过去的几年里，使用 MVC 之类的东西让我迷上了 JSON 格式。 您还可以考虑 XML。 这两种格式都可以很好地处理带有 API 样式的 HTTP 资源。 如果需要使用二进制消息格式，也可以使用二进制消息格式。 我们在这里不推荐任何格式，您可以选择任何消息格式。

# 为什么我们应该使用微服务

人们已经探索了大量的模式和架构，其中一些受到欢迎，而另一些则在互联网流量之战中失利。 每个解决方案都有自己的优点和缺点，所以对于公司来说，快速响应可伸缩性、高性能和易于部署等基本需求变得越来越重要。 任何不具成本效益的单一方面都很容易对大型企业产生负面影响，从而决定企业是否盈利。 下图显示了选择微服务的优势:

![](assets/d5c09102-7af7-4006-bdbf-567d945b720c.png)

这就是我们看到微服务拯救企业系统架构师的地方。 在这种架构风格的帮助下，他们可以确保自己的设计没有任何问题。 同样重要的是要考虑到这一目标是以具有成本效益和及时的方式实现的。

# 微服务架构是如何工作的

在前面的部分中，我们讨论了微服务体系结构，并试图对这个术语进行更深入的阐述。 现在，您可以看到微服务架构可能如何工作; 您可以根据自己的设计方法使用任何组合。 在使用微服务架构时，需要记住以下几点:

*   它是为现代时代编写的程序，在这个时代我们应该遵循所有的 SOLID 原则。 它是面向对象编程(OOP)。
*   这是向其他或外部组件公开功能的最佳方式，以便任何编程语言都可以使用这些功能，而不依赖于任何用户界面或服务(web 服务、API、REST 服务等)。
*   整个系统是协同工作的，而不是相互联系和依赖的。
*   每个组件负责自己的功能。
*   它将代码。 分离的代码是可重用的。

# microservices 的优点

以下是微服务的一些优势:

*   您不需要投资来使整个应用具有可伸缩性。 对于购物车，我们可以简单地对产品搜索模块和订单处理模块进行负载平衡，而留下库存管理、订单取消和发货确认等不常用的操作服务。
*   我们可以很容易地匹配一个组织的部门层次。 由于大型企业中有不同的部门赞助产品开发，这可能是一个巨大的优势。
*   由于代码已经以一种不依赖于具有独立功能的其他模块的代码的方式完成，如果做得好，那么一个微服务中的更改影响另一个微服务的机会是非常小的。
*   由于整个应用更像是一组相互隔离的生态系统——如果需要，我们可以一次部署一个微服务。 任何一个服务的故障都不需要导致整个系统瘫痪。
*   你可以在一夜之间将一个微服务或一大堆微服务移植到不同的技术上，而你的用户甚至都不知道这一点。 不用说，你需要维护这些服务合同。
*   这是暗含的，但这里有必要提醒一下。 确保异步调用被很好地使用，并且同步调用没有真正阻塞整个信息流。 良好地使用数据分区。 我们稍后会讲到这个，所以现在不用担心。
*   在竞争激烈的环境中，这无疑是一个优势，因为如果您对新特性请求或系统中对新技术的采用反应缓慢，用户可能很快就会失去兴趣。

# 微服务体系结构的先决条件

在采用微服务架构达成一致后，明智的做法是具备以下先决条件:

*   随着开发的快速周转，需求变得更加苛刻。 它要求您尽可能快地部署和测试。 如果只是少量的服务，那就不是问题。 然而，随着服务数量的增加，这可能很快就会挑战现有的基础设施和实践。 例如，您的 Q/A 和登台环境可能不再足以测试从开发团队返回的构建的数量。
*   随着应用进入公共领域，用不了多久，开发与 Q/A 的古老脚本就会再次上演。 这次的不同之处在于，生意岌岌可危。 因此，您需要准备以自动方式快速响应，以便在需要时识别根本原因。
*   随着微服务数量的增加，您将很快需要一种方法来监控整个系统的运行和健康状况，以防止任何可能的瓶颈或问题。 如果没有监视已部署微服务的状态和由此产生的业务功能的方法，任何团队都不可能采取主动的部署方法。

# 扩展

扩展是任何企业在试图迎合日益增长的用户基础时所面临的最大挑战之一。

可伸缩性就是系统/程序处理不断增长的工作的能力。 换句话说，可伸缩性是指系统/程序可伸缩的能力。

系统的可伸缩性是它处理不断增加的工作负载的能力。 我们可以使用两种主要的可伸缩性策略或类型来扩展应用。

# 垂直扩展

在垂直扩展中，我们分析现有的应用，以找出由于执行时间较长而导致应用变慢的模块的哪些部分。 提高代码的效率可能是一种策略，这样可以减少内存的消耗。 这种减少内存消耗的做法可以适用于特定模块，也可以适用于整个应用。 另一方面，由于此策略中涉及的明显挑战，我们可以向现有 IT 基础设施添加更多资源，比如升级 RAM、添加更多磁盘驱动器，等等，而不是更改应用。 这两种垂直扩展路径的收益都有一定的限制，即在特定的时间点之后，所产生的收益将趋于稳定。 记住这一点很重要; 这种扩展需要停机时间。

# 水平扩展

在水平扩展中，我们将深入研究那些对整体性能影响较大的模块。 我们考虑诸如高并发性等因素，以使我们的应用能够服务于增加的用户基础。 我们还将实现负载平衡来处理更大量的工作。 向集群中添加更多服务器的选项不需要停机时间，这无疑是一个优势。 具体情况可能会有所不同，所以我们需要检查在电力、许可证和冷却方面的额外成本是否值得。

# DevOps 文化

在 DevOps 的帮助下，一个团队应该强调开发团队和另一个运营团队的协作。 我们应该建立一个系统，让开发、问答和基础设施团队协作。

# 自动化

基础设施设置可能是一项非常耗时的工作。 在基础设施准备就绪时，开发人员可以空闲。 在加入团队并做出贡献之前，他或她将等待一段时间。 基础设施设置的过程不应该阻止开发人员变得高效，因为它会降低整体生产力。 这应该是一个自动化的过程。 通过使用 Chef 或 PowerShell，我们可以轻松地创建虚拟机，并在需要时快速增加开发人员数量。 这样，我们的开发人员就可以从加入团队的第一天就开始工作。

# 测试

测试是任何应用的关键任务，而在使用微服务时则更为复杂。 我们必须将测试方法划分如下:

*   采用 TDD 时，开发人员需要测试他或她自己的代码。 测试只是验证功能是否按预期工作的另一段代码。 如果发现任何功能不能满足测试代码，相应的单元测试将失败。 该功能可以很容易地修复，因为它知道问题在哪里。 为了实现这一点，我们可以利用 MSTest 或单元测试等框架。
*   Q/A 团队可以使用脚本来自动化他们的任务。 他们可以利用 QTP 或 Selenium 框架来创建脚本。

# 部署

部署是一个巨大的挑战。 为了克服这个问题，我们可以引入 CI。 在这个过程中，我们需要设置一个 CI 服务器。 随着 CI 的引入，整个过程现在是自动化的。 任何团队成员只要使用版本控制 TFS 或 Git 检入代码，CI 过程就会开始工作。 它确保生成新代码，并在集成测试的同时运行单元测试。 在这两个场景中，不管是成功的构建还是其他情况，团队都会收到关于结果的警告。 这使得团队能够快速响应问题。

接下来，我们有连续部署。 在这里，我们介绍各种环境，即开发环境、登台环境、Q/ a 环境，等等。 现在，只要任何团队成员检入代码，持续集成就开始发挥作用。 它调用单元/集成测试套件，构建系统，并将其推出到我们已经设置的各种环境中。 这样，开发团队为 Q/ a 提供合适的构建的周转时间就减少了。

# ASP 中的微服务生态系统.NET Core

每当我想到 ASP 中的微服务生态系统.NET Core 系统我考虑了各种小 api、异步编程、回调、事件触发等等。 事实上，生态系统要大得多，而且不知何故也更复杂。

我们已经讨论过，微服务体系结构风格是一种为大型应用创建小型和独立单元的方式。 如果不使用各种工具和实用程序，这是不可能的。

下图是一个典型的微服务架构风格的示意图，描述了不同的客户端对不同服务的请求以及这个请求是如何验证的:

![](assets/7d146cdd-d566-4abe-8651-be846b45fae5.png)

一个典型的微服务生态系统由以下组件组成，您将在 ASP 中了解这些组件.NET Core。

# Azure 服务架构——微服务平台

平台是任何生态系统的必备组件。 它支持系统，工作顺利，并产生预期的结果。 Azure Service Fabric 只是微软提供的一个平台，它在微服务生态系统中非常受欢迎。 它提供容器部署和业务流程。

官方文件请参见:[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview)

"Azure Service Fabric is a distributed systems platform that makes it easy to package, deploy, and manage scalable and reliable microservices and containers."

# 无状态和有状态服务——一种服务编程模型

健壮的服务编程模型是微服务生态系统的支柱。 一个人应该知道他/她应该使用什么样的服务模型根据他/她的需求:

*   **Stateless**:服务在客户端请求之间不保持任何状态。 也就是说，服务不知道，也不关心后续的请求是否来自已经发出/没有发出前一个请求的客户端。 当我们有外部数据存储时，这是最好的服务编程模型。 我们的服务可以基于与外部数据库存储上的数据进行交互和持久化的无状态服务编程模型。
*   **有状态**:服务保持一种可变状态，主动处理或保留特定于服务所要处理的任务的状态数据。

# 通信——服务之间交换数据的一种方式

如果微服务都是关于服务的，那么服务之间的通信应该是健壮的。 通信是服务之间交换数据的一种方式。 服务使用 Rest API(即 HTTP 调用请求/响应)进行通信，它们本质上是同步的。

当服务彼此通信时，它们实际上是在交换数据，这也称为服务之间的消息传递。 在处理微服务体系结构时，仔细考虑消息传递机制的选择是非常重要的。 如果忽略了这一方面，那么就会危及使用微服务体系结构进行设计的整个目的。 在单片应用中，这不是一个问题，因为组件的业务功能是通过函数调用调用的。 另一方面，这是通过松散耦合的 web 服务级消息传递实现的，其中服务主要基于 SOAP。 微服务消息传递机制应该是简单和轻量级的。

在微服务体系结构的各种框架或协议之间进行选择，没有固定的规则。 然而，这里有几点值得考虑。 首先，它的实现应该足够简单，而不会给系统增加任何复杂性。 其次，它应该足够轻，记住微服务体系结构可能严重依赖于服务间消息传递这一事实。 让我们继续讨论同步和异步消息传递以及不同的消息传递格式的选择。

# 总结

微服务体系结构风格提供了某些好处。 它使开发变得又快又容易。 它允许 DevOps (CI 和 CD)团队在地理位置上分离，平稳地工作并同步。 应用被划分为小的服务组件或部件，因此维护很容易。 这允许开发团队让业务发起人选择首先响应什么行业趋势。 这将带来成本效益、更好的业务响应、及时的技术采用、有效的扩展和消除对人类的依赖。

在本章中，你已经了解了 ASP.NET 中典型的微服务体系结构风格和微服务生态系统。

现在，我建议你阅读以下关于微服务的内容，以提高你的技能:

*   *使用。net Core 2.0 构建微服务-第二版*by PACKT([https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition](https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition)
*   *微服务模式和最佳实践*by PACKT([https://www.packtpub.com/application-development/microservice-patterns-and-best-practices](https://www.packtpub.com/application-development/microservice-patterns-and-best-practices))