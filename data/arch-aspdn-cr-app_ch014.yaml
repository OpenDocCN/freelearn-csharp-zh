- en: 13 Understanding the Operation Result Design Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 理解操作结果设计模式
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的 Discord 书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“EARLY ACCESS SUBSCRIPTION”下的“architecting-aspnet-core-apps-3e”频道中查找）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file71.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file71.png)'
- en: This chapter explores the **Operation Result** pattern, starting simple and
    progressing to more complex cases. An operation result aims to communicate the
    success or failure of an operation to its caller. It also allows that operation
    to return both a value and one or more messages to the caller.Imagine any system
    where you want to display user-friendly error messages, achieve some small speed
    gain, or even handle failure easily and explicitly. The **Operation Result** design
    pattern can help you achieve these goals. One way to use it is to handle the result
    of a remote operation, such as after querying a remote web service.This pattern
    builds upon foundational object-oriented programming concepts. In this chapter,
    we iterate and design different possibilities incrementally. Of course, you should
    always base your final design on your needs, so learning multiple options will
    help you make the right choices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了**操作结果**模式，从简单开始，逐步过渡到更复杂的案例。操作结果旨在将操作的成功或失败传达给调用者。它还允许该操作返回一个值以及一个或多个消息给调用者。想象一下任何你想要显示用户友好错误信息、实现一些小的速度提升，或者甚至轻松且明确地处理失败的系统。**操作结果**设计模式可以帮助你实现这些目标。使用它的一种方法是处理远程操作的结果，例如在查询远程网络服务之后。此模式建立在面向对象编程的基础概念之上。在本章中，我们逐步迭代和设计不同的可能性。当然，你应该始终根据你的需求来设计最终的设计，因此学习多个选项将帮助你做出正确的选择。
- en: The Operation Result pattern is also known as the **Result Object Pattern**.
    I prefer Operation Result because the name specifies that it represents the result
    of an operation, while the Result Object has a broader meaning. Nonetheless, both
    are basically the same.
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 操作结果模式也被称为**结果对象模式**。我更喜欢操作结果，因为这个名字表明它代表了一个操作的结果，而结果对象有更广泛的意义。尽管如此，两者基本上是相同的。
- en: 'In this chapter, we cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: The Operation Result design pattern basics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作结果设计模式的基本知识
- en: The Operation Result design pattern returning a value
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值的操作结果设计模式
- en: The Operation Result design pattern returning error messages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回错误信息的操作结果设计模式
- en: The Operation Result design pattern returning messages with severity levels
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回具有严重级别信息的操作结果设计模式
- en: Using sub-classes and static factory methods for better isolation of successes
    and failures
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用子类和静态工厂方法以更好地隔离成功和失败
- en: The Operation Result pattern
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作结果模式
- en: The Operation Result design pattern can be very simple to more complex. In this
    section, we explore multiple ways to use this pattern. We start with its simplest
    form and build on that until we can return messages and values and add severity
    levels as the result of an operation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 操作结果设计模式可以从非常简单到更复杂。在本节中，我们将探讨使用此模式的不同方法。我们从其最简单形式开始，在此基础上构建，直到我们可以返回消息和值，并将严重级别作为操作的结果添加。
- en: Goal
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: 'The role of the **Operation Result** pattern is to give an operation (a method)
    the possibility to return a complex result (an object), which allows the consumer
    to:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作结果**模式的作用是赋予一个操作（一个方法）返回一个复杂结果（一个对象）的可能性，这允许消费者：'
- en: '[Mandatory] Access the success indicator of the operation (that is, whether
    the operation succeeded or not).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[必选] 访问操作的成功指示器（即操作是否成功）。'
- en: '[Optional] Access the operation result if there is one (the method''s return
    value).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可选] 如果有，访问操作结果（方法返回值）。'
- en: '[Optional] Access the cause of the failure if the operation was unsuccessful
    (error messages).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可选] 如果操作失败（错误信息），访问失败的原因。'
- en: '[Optional] Access other information that documents the operation’s result.
    This could be as simple as a list of messages or as complex as multiple properties.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可选] 访问记录操作结果的其它信息。这可能只是一个消息列表，也可能非常复杂，如多个属性。'
- en: This can go even further, such as returning the severity of a failure or adding
    any other relevant information for the specific use case. The success indicator
    could be binary (`true` or `false`), or there could be more than two states, such
    as success, partial success, and failure.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以更进一步，例如返回失败的严重性或为特定用例添加任何其他相关信息。成功指示器可以是二进制的（`true` 或 `false`），或者可能有超过两种状态，如成功、部分成功和失败。
- en: Always focus on your needs first, then use your imagination and knowledge to
    find the best solution. Software engineering is not only about applying techniques
    that others tell you to. It’s an art! The difference is that you are crafting
    software instead of painting or woodworking. And that most people won’t see any
    of that art (code) or get it even if they do.
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先关注您的需求，然后运用您的想象力和知识来找到最佳解决方案。软件工程不仅仅是应用别人告诉您的技术。它是一门艺术！区别在于您是在制作软件而不是绘画或木工。而且大多数人甚至看不到任何这种艺术（代码）或即使看到了也不理解。
- en: Design
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: It is easy to rely on throwing exceptions when an operation fails. However,
    the Operation Result pattern is an alternative way of communicating success or
    failure between components when you don’t want to use exceptions. One such reason
    could be that the messages are not errors or that treating an erroneous result
    is part of the main flow, not part of a side `catch` flow.A method must return
    an object containing one or more elements presented in the *Goal* section to be
    used effectively. As a rule of thumb, a method returning an operation result should
    not throw exceptions. This way, consumers don’t have to handle anything other
    than the operation result itself.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作失败时，依赖抛出异常是很常见的。然而，操作结果模式是当您不想使用异常时，在组件之间传达成功或失败的一种替代方式。其中一个原因可能是消息不是错误，或者处理错误结果是主流程的一部分，而不是“catch”流程的一部分。一个方法必须返回一个包含在“目标”部分中展示的一个或多个元素的对象，以便有效地使用。作为一个经验法则，返回操作结果的方法不应该抛出异常。这样，消费者只需处理操作结果本身，无需处理其他任何内容。
- en: You can throw exceptions for special cases, but at this point, it is a judgment
    call based on clear specifications or facing a real problem. For example, a critical
    event that happens, like the disk is full, would be a valid use case for an exception
    because it has nothing to do with the main flow, and the code must alert the rest
    of the program about the system failure.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以为特殊情况抛出异常，但在此阶段，这是一个基于明确规范或面对真实问题的判断。例如，一个关键事件发生，如磁盘已满，将是一个有效的异常使用案例，因为它与主流程无关，代码必须向程序的其他部分发出系统故障的警报。
- en: 'Instead of walking you through all of the possible UML diagrams, let’s jump
    into the code and explore multiple smaller examples after taking a look at the
    basic sequence diagram that describes the simplest form of this pattern, applicable
    to all examples:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是逐一向您展示所有可能的 UML 图，让我们先看看描述此模式最简单形式的基线序列图，然后探索多个更小的示例：
- en: '![Figure 13.1: Sequence diagram of the Operation Result design pattern](img/file72.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1：操作结果设计模式的序列图](img/file72.png)'
- en: 'Figure 13.1: Sequence diagram of the Operation Result design pattern'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：操作结果设计模式的序列图
- en: The preceding diagram shows that an operation returns a result (an object),
    and then the caller handles that result. The following examples cover what we
    can include in that result object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示表明，一个操作返回一个结果（一个对象），然后调用者处理该结果。以下示例涵盖了我们可以包含在该结果对象中的内容。
- en: Project – Implementing different Operation Result patterns
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 - 实现不同的操作结果模式
- en: In this project, a consumer (REST API) routes the HTTP requests to the correct
    handler. We are visiting each of those handlers one by one to create an incremental
    learning flow from simple to more complex operation results. This project shows
    you many ways to implement the Operation Result pattern to help you understand
    it, make it your own, and implement it as required in your projects.Let’s start
    with the REST API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，一个消费者（REST API）将 HTTP 请求路由到正确的处理器。我们逐个访问这些处理器，以从简单到更复杂的操作结果创建一个渐进式学习流程。这个项目向您展示了多种实现操作结果模式的方法，以帮助您理解它，使其成为您自己的，并在您的项目中按需实现。让我们从
    REST API 开始。
- en: The consumer
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 消费者
- en: 'The consumer of all examples is the `Program.cs` file. The following code from
    `Program.cs` routes the HTTP requests toward a handler:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例的消费者是 `Program.cs` 文件。以下来自 `Program.cs` 的代码将 HTTP 请求路由到处理器：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we cover each use case one by one.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们逐个覆盖每个用例。
- en: The simplest form of the Operation Result pattern
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 操作结果模式的简单形式
- en: 'The following diagram represents the simplest form of the Operation Result
    pattern:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了操作结果模式的简单形式：
- en: '![Figure 13.2: Class diagram of the Operation Result design pattern](img/file73.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2：操作结果设计模式的类图](img/file73.png)'
- en: 'Figure 13.2: Class diagram of the Operation Result design pattern'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：操作结果设计模式的类图
- en: 'We can translate that class diagram into the following blocks of code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个类图转换为以下代码块：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code handles the `/simplest-form` HTTP requests. The highlighted
    code consumes the following operation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码处理了 `/simplest-form` HTTP 请求。高亮显示的代码消费以下操作：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Executor` class contains the operation to execute represented by the `Operation`
    method. That method returns an instance of the `OperationResult` class. The implementation
    is based on a random number. Sometimes it succeeds, and sometimes it fails. You
    would usually code real application logic in that method instead. Moreover, in
    an actual application, the method should have a proper name representing the operation,
    like `PayRegistrationFees` or `CreateConcert`.The `OperationResult` record class
    represents the result of the operation. In this case, a simple read-only Boolean
    value is stored in the `Succeeded` property.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor` 类包含由 `Operation` 方法表示的操作。该方法返回 `OperationResult` 类的一个实例。实现基于随机数。有时它成功，有时它失败。你通常会在这个方法中编写实际的应应用程序逻辑。此外，在实际应用中，该方法应该有一个适当的名称来表示操作，如
    `PayRegistrationFees` 或 `CreateConcert`。《OperationResult》记录类表示操作的结果。在这种情况下，一个简单的只读布尔值存储在
    `Succeeded` 属性中。'
- en: I chose a record class because there is no reason for the result to change.
    To know more about record classes, have a look at *Appendix A*.
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我选择记录类，因为没有理由让结果发生变化。要了解更多关于记录类的信息，请参阅 *附录 A*。
- en: In this form, the difference between the `Operation` method returning a `bool`
    and an instance of `OperationResult` is small, but it exists nonetheless. By returning
    an `OperationResult` object, you can extend the return value over time, adding
    properties and methods to it, which you cannot do with a `bool` without updating
    all consumers.Next, we add an error message to the result.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种形式下，`Operation` 方法返回 `bool` 和 `OperationResult` 实例之间的区别很小，但确实存在。通过返回 `OperationResult`
    对象，你可以随着时间的推移扩展返回值，向其中添加属性和方法，而无需更新所有消费者是无法做到这一点的。接下来，我们向结果中添加一个错误消息。
- en: A single error message
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单个错误消息
- en: 'Now that we know whether the operation succeeded or not, we want to know what
    went wrong. To do that, we add an `ErrorMessage` property to the `OperationResult`
    record class.With that in place, we no longer need to set whether the operation
    succeeded or not; we can compute that using the `ErrorMessage` property instead.
    The logic behind this improvement goes as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道操作是否成功，我们就想了解出了什么问题。为了做到这一点，我们在 `OperationResult` 记录类中添加了一个 `ErrorMessage`
    属性。有了这个属性，我们就不再需要设置操作是否成功；我们可以使用 `ErrorMessage` 属性来计算这一点。这个改进背后的逻辑如下：
- en: When there is no error message, the operation succeeded.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有错误消息时，操作成功。
- en: When there is an error message, the operation failed.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有错误消息时，操作失败。
- en: 'The `OperationResult` record class implementing this logic looks like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此逻辑的 `OperationResult` 记录类看起来如下：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we have the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有以下内容：
- en: The `Succeeded` property checks for an error message.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Succeeded` 属性检查错误消息。'
- en: The `ErrorMessage` property contains an error message settable when instantiating
    the object.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrorMessage` 属性包含在实例化对象时可以设置的错误消息。'
- en: 'The executor of that operation looks similar but uses the new constructor,
    setting an error message instead of directly setting the success indicator:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该操作的执行者看起来相似，但使用新的构造函数，设置错误消息而不是直接设置成功指示器：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The consuming code does the same as in the previous sample but writes the error
    message in the response output instead of a generic failure string:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 消费代码与上一个示例相同，但在响应输出中写入错误消息而不是通用的失败字符串：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When looking at this example, we can begin to comprehend the Operation Result
    pattern’s usefulness. It furthers us from the simple success indicator that looked
    like an overcomplicated Boolean.Next, we add the possibility of setting a value
    when the operation succeeds.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看这个示例时，我们可以开始理解操作结果模式的有用性。它使我们远离了看似过于复杂的布尔值简单成功指示器。接下来，我们添加了在操作成功时设置值的可能性。
- en: Adding a return value
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加返回值
- en: 'Now that we have a reason for failure, we may want the operation to return
    a value. To achieve this, let’s build over the previous example and add a `Value`
    property to the `OperationResult` class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了失败的原因，我们可能希望操作返回一个值。为了实现这一点，让我们在之前的示例基础上构建，并向`OperationResult`类添加一个`Value`属性：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By adding a second `init`-only property, we can set the `Value` property when
    the operation succeeds and fails.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个仅初始化的第二个属性，我们可以在操作成功和失败时设置`Value`属性。
- en: In a real-world scenario, that `Value` property could be `null` in the case
    of an error, hence the nullable `int` property.
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在实际场景中，错误情况下`Value`属性可能是`null`，因此有一个可空的`int`属性。
- en: 'The operation is also very similar, but we are setting the `Value` property
    as well as using the object initializer in both cases (highlighted lines):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 操作也非常相似，但我们在这两种情况下都设置了`Value`属性，并使用了对象初始化器（高亮行）：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With that in place, the consumer can use the `Value` property. In our case,
    the program displays it when the operation succeeds:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，消费者就可以使用`Value`属性。在我们的例子中，程序在操作成功时显示它：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code displays the `ErrorMessage` property when the operation fails
    or uses the `Value` property when it succeeds. With this, the power of the Operation
    Result pattern continues to emerge.But we are not done yet, so let’s jump into
    the next evolution.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在操作失败或成功时显示`ErrorMessage`属性。有了这个，操作结果模式的强大功能继续显现。但我们还没有完成，所以让我们跳到下一个发展阶段。
- en: Multiple error messages
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多个错误消息
- en: 'Now we are at the point where we can transfer a `Value` and an `ErrorMessage`
    to the operation consumers; what about transferring multiple errors, such as validation
    errors? To achieve this, we can convert our `ErrorMessage` property from a `string`
    to an `IEnumerable<string>` or another type of collection that fits your needs
    better. Here I chose the `IReadOnlyCollection<string>` interface and the `ImmutableList<string>`
    class so we know that external actors can’t mutate the results:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到了可以传递`Value`和`ErrorMessage`到操作消费者的时候了；那么传递多个错误，比如验证错误怎么办？为了实现这一点，我们可以将我们的`ErrorMessage`属性从`string`转换为`IEnumerable<string>`或其他更适合你需求的集合类型。在这里，我选择了`IReadOnlyCollection<string>`接口和`ImmutableList<string>`类，这样我们知道外部行为者不能修改结果：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s look at the new pieces in the preceding code before continuing:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们看看前面代码中的新部分：
- en: The errors are now stored in `ImmutableList<string>` object and returned as
    an `IReadOnlyCollection<string>`.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误现在存储在`ImmutableList<string>`对象中，并以`IReadOnlyCollection<string>`的形式返回。
- en: The `Succeeded` property accounts for a collection instead of a single message
    and follows the same logic.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Succeeded`属性考虑了一个集合而不是单个消息，并遵循相同的逻辑。'
- en: The `HasErrors` method improves readability.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HasErrors`方法提高了可读性。'
- en: The default constructor represents the successful state.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认构造函数表示成功状态。
- en: The constructor that takes error messages as parameters represents a failed
    state and populates the `Errors` property.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收错误消息参数的构造函数表示失败状态，并填充`Errors`属性。
- en: 'Now that the operation result is updated, the operation itself can stay the
    same. The consumer stays almost the same as well (see the highlight in the code
    below), but we need to tell ASP.NET how to serialize the result:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在操作结果已经更新，操作本身可以保持不变。消费者几乎保持不变（见下面代码中的高亮部分），但我们需要告诉ASP.NET如何序列化结果：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We must specify the method returns an object (the highlighted code) so ASP.NET
    understands that the return value of our delegate can be anything. Without this,
    the return type could not be inferred, and the code would not compile. That makes
    sense since the function is returning a `string` in one path and an `IReadOnlyCollection<string>`
    in another.During the executing, ASP.NET serializes the `IReadOnlyCollection<string>
    Errors` property to JSON before outputting it to the client to help visualize
    the collection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须指定该方法返回一个对象（高亮代码），这样ASP.NET才能理解我们的委托返回值可以是任何类型。如果没有这个指定，返回类型无法推断，代码将无法编译。这是有道理的，因为函数在一个路径上返回`string`类型，在另一个路径上返回`IReadOnlyCollection<string>`类型。在执行过程中，ASP.NET在输出到客户端之前将`IReadOnlyCollection<string>
    Errors`属性序列化为JSON，以帮助可视化集合。
- en: Returning a `plain/text` string when the operation succeeds and an `application/json`
    array when it fails is not a good practice. I suggest avoiding this in real applications.
    Either return JSON or plain text. Do not mix content types in a single endpoint
    unless necessary per specifications. Mixing content types only creates avoidable
    complexity and confusion. Moreover, it is way easier for the consumers of the
    API to always expect the same content type.
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当操作成功时返回 `plain/text` 字符串，当操作失败时返回 `application/json` 数组，这不是一个好的做法。我建议在实际应用中避免这样做。要么返回
    JSON，要么返回纯文本。除非根据规范有必要，否则不要在单个端点中混合内容类型。混合内容类型只会创建可避免的复杂性和混淆。此外，对于 API 的消费者来说，始终期望相同的内容类型要容易得多。
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When designing system contracts, consistency and uniformity are usually better
    than incoherency, ambiguity, and variance.
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在设计系统合同时，一致性和统一性通常比不连贯、模糊和变化要好。
- en: Our Operation Result pattern implementation is getting better and better but
    still lacks a few features. One of those features is the possibility to propagate
    messages that are not errors, such as information messages and warnings, which
    we implement next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的操作结果模式实现正在变得越来越好，但仍然缺少一些功能。其中之一是传播非错误消息的可能性，例如信息消息和警告，这是我们接下来要实现的。
- en: Adding message severity
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加消息严重性
- en: 'Now that our operation result structure is materializing, let’s update our
    last iteration to support message severity.First, we need a severity indicator.
    An `enum` is a good candidate for this kind of work, but it could also be something
    else. In our case, we leverage an `enum` that we name `OperationResultSeverity`.Then
    we need a message class to encapsulate both the message and the severity level;
    let’s name that class `OperationResultMessage`. The new code looks like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们操作的结果结构正在形成，让我们更新我们的最后一次迭代以支持消息严重性。首先，我们需要一个严重性指示器。`enum` 是这类工作的良好候选，但也可能是其他东西。在我们的情况下，我们利用了一个名为
    `OperationResultSeverity` 的 `enum`。然后我们需要一个消息类来封装消息和严重级别；让我们称这个类为 `OperationResultMessage`。新的代码看起来是这样的：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, we have a simple data structure to replace our `string` messages.To
    ensure the enum gets serialized as string and make the output easier to read and
    consume, we must register the following converter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个简单的数据结构来替换我们的 `string` 消息。为了确保枚举被序列化为字符串，并使输出更容易阅读和消费，我们必须注册以下转换器：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we need to update the `OperationResult` class to use that new `OperationResultMessage`
    class instead. We then need to ensure that the operation result indicates a success
    only when there is no `OperationResultSeverity.Error`, allowing it to transmit
    the `OperationResultSeverity.Information` and `OperationResultSeverity.Warnings`
    messages:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更新 `OperationResult` 类以使用新的 `OperationResultMessage` 类。然后我们需要确保操作结果仅在不存在
    `OperationResultSeverity.Error` 时表示成功，从而允许它传输 `OperationResultSeverity.Information`
    和 `OperationResultSeverity.Warnings` 消息：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The highlighted lines represent the updated logic that sets the success state
    of the operation. The operation is successful only when no error exists in the
    `Messages` list. The `FindErrors` method returns messages with an `Error` severity,
    while the `HasErrors` method bases its decision on that method’s output.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行表示更新后的逻辑，该逻辑设置操作的成功状态。操作只有在 `Messages` 列表中没有错误时才成功。`FindErrors` 方法返回具有 `Error`
    严重性的消息，而 `HasErrors` 方法基于该方法的输出做出决定。
- en: The `HasErrors` method logic can be anything. In this case, this works.
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`HasErrors` 方法的逻辑可以是任何东西。在这种情况下，这是可行的。'
- en: 'With that in place, the `Executor` class is also revamped. Let’s have a look
    at those changes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，`Executor` 类也得到了改进。让我们看看这些变化：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we removed the tertiary operator. The `Operation` method
    also uses all severity levels.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们移除了三元运算符。`Operation` 方法也使用了所有严重级别。
- en: You should always aim to write code that is easy to read. It is OK to use language
    features, but nesting statements over statements on a single line has limits and
    can quickly become a mess.
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你应该始终致力于编写易于阅读的代码。使用语言特性是可以的，但将语句嵌套在单行上是有局限性的，并且很快就会变得混乱。
- en: 'In that last code block, both successes and failures return two messages:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个代码块中，成功和失败都返回两条消息：
- en: When the operation succeeds, the method returns an information and a warning
    message.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当操作成功时，该方法返回一个信息和警告消息。
- en: When the operation fails, the method returns an information and an error message.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当操作失败时，该方法返回一个信息和错误消息。
- en: 'From the consumer standpoint, we have a placeholder if-else block and return
    the operation result directly. Of course, we could handle this differently in
    a real application that needs to know about those messages, but in this case,
    all we want to see are those results, so this does it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从消费者的角度来看，我们有一个占位符的 if-else 块，并直接返回操作结果。当然，我们可以在需要了解这些消息的实际应用程序中以不同的方式处理这个问题，但在这个案例中，我们只想看到这些结果，所以这就足够了：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, it is still as easy to use, but now with more flexibility added
    to it. We can do something with the different types of messages, such as displaying
    them to the user, retrying the operation, and more.For now, when running the application
    and calling this endpoint, successful calls return a JSON string that looks like
    the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它仍然易于使用，但现在增加了更多的灵活性。我们可以对不同的消息类型做一些事情，例如向用户显示它们、重试操作等等。目前，当运行应用程序并调用此端点时，成功的调用返回一个类似以下的
    JSON 字符串：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Failures return a JSON string that looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 失败返回一个类似这样的 JSON 字符串：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Another idea to improve this design would be adding a `Status` property that
    returns a complex success result based on each message’s severity level. To do
    that, we could create another `enum`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 提高这个设计的另一个想法是添加一个 `Status` 属性，它根据每个消息的严重级别返回一个复杂的成功结果。为了做到这一点，我们可以创建另一个枚举：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then we could access that value through a new property named `Status`, on the
    `OperationResult` class. With this, a consumer could handle partial success without
    digging into the messages. I will leave you to play with this one on your own;
    for example, the `Status` property could replace the `Succeeded` property, or
    the `Succeeded` property could leverage the `Status` property similarly to what
    we did with the errors. The most important part is to define what would be a success,
    a partial success, and a failure. Think of a database transaction, for example;
    one failure could lead to the rollback of the transaction, while in another case,
    one failure could be acceptable.Now that we’ve expanded our simple example into
    this, what happens if we want the `Value` to be optional? To do that, we could
    create multiple operation result classes holding more or less information (properties);
    let’s try that next.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过在 `OperationResult` 类上创建一个名为 `Status` 的新属性来访问该值。有了这个属性，消费者可以处理部分成功而无需深入查看消息。我将把这个留给你自己尝试；例如，`Status`
    属性可以替换 `Succeeded` 属性，或者 `Succeeded` 属性可以像我们处理错误那样利用 `Status` 属性。最重要的是定义什么是成功、部分成功和失败。例如，考虑一个数据库事务；一次失败可能导致事务回滚，而在另一种情况下，一次失败可能是可接受的。现在我们已经将我们的简单示例扩展到这个程度，如果我们想使
    `Value` 成为可选的，会发生什么？为了做到这一点，我们可以创建多个包含或多或少信息的操作结果类（属性）；让我们尝试一下。
- en: Sub-classes and factories
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 子类和工厂
- en: In this iteration, we keep all the properties but instantiate the `OperationResult`
    objects using static factories. Moreover, we hide certain properties in the sub-classes,
    so each result type only contains the data it needs. The `OperationResult` class
    itself only exposes the `Succeeded` property in this scenario.A **static factory
    method** is nothing more than a static method that creates objects. It is handy
    and easy to use but less flexible.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们保留了所有属性，但使用静态工厂方法实例化 `OperationResult` 对象。此外，我们在子类中隐藏了某些属性，因此每个结果类型只包含它所需的数据。在这种情况下，`OperationResult`
    类本身只公开了 `Succeeded` 属性。**静态工厂方法**不过是一个创建对象的静态方法。它方便且易于使用，但灵活性较低。
- en: 'I cannot stress this enough: be careful when designing something `static`,
    or it could haunt you later; `static` members are not extensible and can make
    their consumers harder to test.'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我不能强调这一点：在设计 `static` 的时候要小心，否则可能会在以后困扰你；`static` 成员是不可扩展的，并且可能使它们的消费者更难测试。
- en: 'The `OperationResultMessage` class and the `OperationResultSeverity` `enum`
    remain unchanged. In the following code block, we do not consider the severity
    when computing the operation’s success or failure state. Instead, we create an
    abstract `OperationResult` class with two sub-classes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperationResultMessage` 类和 `OperationResultSeverity` 枚举保持不变。在下面的代码块中，我们计算操作的成功或失败状态时不考虑严重性。相反，我们创建了一个抽象的
    `OperationResult` 类，并有两个子类：'
- en: The `SuccessfulOperationResult` class represents successful operations.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SuccessfulOperationResult` 类表示成功的操作。'
- en: The `FailedOperationResult` class represents failed operations.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FailedOperationResult` 类表示失败的操作。'
- en: 'Then the next step is to force the use of the specifically designed classes
    by creating two static factory methods:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是通过创建两个静态工厂方法来强制使用专门设计的类：
- en: The static `Success` method returns a `SuccessfulOperationResult` object.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态`Success`方法返回一个`SuccessfulOperationResult`对象。
- en: The static `Failure` returns a `FailedOperationResult` object.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态`Failure`返回一个`FailedOperationResult`对象。
- en: 'This technique moves the responsibility of deciding whether the operation is
    a success from the `OperationResult` class to the `Operation` method that explicitly
    creates the expected result.The following code block shows the new `OperationResult`
    implementation (the static factories are highlighted):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术将决定操作是否成功的责任从`OperationResult`类转移到了显式创建预期结果的`Operation`方法。以下代码块展示了新的`OperationResult`实现（静态工厂被突出显示）：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After analyzing the code, there are a few closely related particularities:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 分析代码后，有几个密切相关的问题：
- en: The `OperationResult` class has a private constructor.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OperationResult`类有一个私有构造函数。'
- en: Both the `SuccessfulOperationResult` and `FailedOperationResult` classes are
    nested inside the `OperationResult` class, inherit from it, and are `private`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SuccessfulOperationResult`和`FailedOperationResult`类都嵌套在`OperationResult`类内部，继承自它，并且是`private`。'
- en: Nested classes are the only way to inherit from the `OperationResult` class
    because, like other members of the class, nested classes have access to their
    private members, including the constructor. Otherwise, it is impossible to inherit
    from `OperationResult`. Moreover, as private classes, they can only be accessed
    internally from the `OperationResult` class for the same reason and become inaccessible
    from the outside.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套类是继承自`OperationResult`类的唯一方式，因为，就像类中的其他成员一样，嵌套类可以访问它们的私有成员，包括构造函数。否则，从`OperationResult`继承是不可能的。此外，作为私有类，它们只能从`OperationResult`类内部访问，出于同样的原因，从外部变得不可访问。
- en: Since the beginning of the book, I have repeated **flexibility** many times;
    but you don’t always want flexibility. Even if most of the book is about improving
    flexibility, sometimes you want control over what you expose and what you allow
    consumers to do, whether to protect internal mechanisms (encapsulation) or for
    maintainability reasons.
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从本书开始，我多次重复提到**灵活性**；但并不是你总是想要灵活性。即使本书的大部分内容是关于提高灵活性，有时你希望控制你暴露的内容以及允许消费者执行的操作，无论是为了保护内部机制（封装）还是为了维护性原因。
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, allowing consumers to change the internal state of an object can
    lead to unexpected behaviors. Another example would be when managing a library;
    the larger the public API, the more chances of introducing a breaking change.
    Nonetheless, over-hiding elements can be a detrimental experience for the consumers;
    if you need something somewhere, the chances are that someone else will too (eventually).
  id: totrans-129
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，允许消费者更改对象的内部状态可能导致意外的行为。另一个例子是在管理库时；公开的API越大，引入破坏性变更的机会就越多。尽管如此，过度隐藏元素可能会给消费者带来不良体验；如果你需要某处的东西，其他人最终也可能需要（可能）。
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this case, we could have used a protected constructor instead or implemented
    a fancier way of instancing success and failure instances. Nonetheless, I decided
    to use this opportunity to show you how to lock a class in place without the sealed
    modifier, making extending by inheritance from the outside impossible. We could
    have built mechanisms in our classes to allow controlled extensibility (like the
    Template Method pattern), but for this one, let’s keep it locked in tight!
  id: totrans-131
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用受保护的构造函数，或者实现一种更花哨的方式来实例化成功和失败实例。然而，我决定利用这个机会向你展示如何在不使用`sealed`修饰符的情况下锁定类，使得从外部通过继承扩展变得不可能。我们可以在我们的类中构建机制以允许受控的可扩展性（如模板方法模式），但在这个例子中，让我们将其锁定在紧密的位置！
- en: 'From here, the only missing pieces are the operation itself and the consumer
    of the operation. Let’s look at the operation first:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，唯一缺少的部分是操作本身和操作的消费者。让我们先看看操作：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The two highlighted lines in the preceding code block show the elegance of
    this new improvement. I find this code very easy to read, which was the objective.
    We now have two methods that clearly define our intentions when using them: `Success`
    or `Failure`.The consumer uses the same code that we saw before in other examples,
    so I’ll omit it here. However, the output is different for a successful or a failed
    operation. Here is a successful output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码块中突出显示的两行展示了这种新改进的优雅之处。我发现这段代码非常易于阅读，这正是我们的目标。现在我们有两种方法可以清楚地定义使用时的意图：“成功”或“失败”。消费者使用我们在其他示例中看到的相同代码，所以在这里我将省略它。然而，对于成功或失败的操作，输出是不同的。以下是一个成功的输出：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is a failed output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个失败的输出：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As the two preceding JSON outputs show, each object's properties are different.
    The only shared property of the two is the `Succeeded` property. Beware that this
    type of class hierarchy is harder to consume directly since the interface (the
    `OperationResult` class) has a minimal API surface, which is good in theory, and
    each sub-class adds different properties, which are hidden from the consumers.
    For example, it would be hard to use the `Value` property of a successful operation
    directly in the endpoint handler code. Therefore, when hiding properties, as we
    did here, ensure those additional properties are optional. For example, we can
    use this technique when sending the result to another system over HTTP (like this
    project does) or publish the operation result as an event (see *Chapter 19*, *Introduction
    to Microservices Architecture*, where we introduce event-driven architecture).
    Nevertheless, learning to manipulate classes using polymorphism will be helpful
    the day you need it.Next, let’s peek at some advantages and disadvantages of the
    Operation Result pattern.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如前两个JSON输出所示，每个对象的属性都不同。这两个对象唯一的共有属性是`Succeeded`属性。请注意，这种类型的类层次结构直接消费起来更困难，因为接口（`OperationResult`类）具有最小的API表面，这在理论上是好的，而每个子类都添加了不同的属性，这些属性对消费者来说是隐藏的。例如，在端点处理代码中直接使用成功操作的`Value`属性可能会很困难。因此，当我们隐藏属性时，如我们在这里所做的那样，确保这些附加属性是可选的。例如，当通过HTTP（如本项目所做）将结果发送到另一个系统或发布操作结果作为事件（见*第19章*，*微服务架构简介*，其中我们介绍了事件驱动架构）时，我们可以使用这种技术。不过，学习使用多态操作类将有助于你真正需要它的时候。接下来，让我们看看操作结果模式的优缺点。
- en: Advantages and disadvantages
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: Here are a few advantages and disadvantages of the Operation Result design pattern.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是操作结果设计模式的一些优缺点。
- en: Advantages
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优点
- en: It is more explicit than throwing an `Exception` since the operation result
    type is specified explicitly as the method’s return type. That makes it more evident
    than knowing what type of exceptions the operation and its dependencies can throw.Another
    advantage is the execution speed; returning an object is faster than throwing
    an exception. Not that much faster, but faster nonetheless.Using operation results
    is more flexible than exceptions and gives us design flexibility; for example,
    we can manage different message types like warnings and information.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 它比抛出`Exception`更明确，因为操作结果类型被明确指定为方法的返回类型。这使得它比知道操作及其依赖可以抛出什么类型的异常更明显。另一个优点是执行速度；返回对象比抛出异常更快。虽然快不了多少，但确实更快。使用操作结果比异常更灵活，并给我们提供了设计灵活性；例如，我们可以管理不同类型的消息，如警告和信息。
- en: Disadvantages
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缺点
- en: Using operation results is more complex than throwing exceptions because we
    must *manually propagate it up the call stack* (i.e., the result object is returned
    by the callee and handled by the caller). This is especially true if the operation
    result must go up multiple levels, suggesting this pattern may not be the most
    suitable.It is easy to expose members not used by all scenarios, creating a bigger
    API surface than needed, where some parts are used only in some cases. But, between
    this and spending countless hours designing the perfect system, sometimes exposing
    an `int? Value { get; }` property is the best option. Nonetheless, always try
    to reduce that surface to a minimum and use your imagination and design skills
    to overcome those challenges!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用操作结果比抛出异常更复杂，因为我们必须**手动将其传播到调用栈**（即，结果对象由被调用者返回并由调用者处理）。这一点在操作结果必须向上传递多个层级时尤其如此，这表明这种模式可能不是最合适的。很容易暴露出所有场景都不使用的成员，从而创建比所需更大的API表面，其中某些部分只在某些情况下使用。但是，与花费无数小时设计完美的系统相比，有时暴露一个`int?
    Value { get; }`属性可能是最佳选择。不过，始终尽量将这种表面减少到最低限度，并运用你的想象力和设计技能来克服这些挑战！
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we visited multiple forms of the Operation Result pattern,
    from an augmented Boolean to a complex data structure containing messages, values,
    and success indicators. We also explored static factories and private constructors
    to control external access. Furthermore, after all that exploration, let’s conclude
    that there are almost endless possibilities around the Operation Result pattern.
    Each specific use case should dictate how to make it happen. From here, I am confident
    you have enough information about the pattern to explore the many possibilities
    yourself, and I highly encourage you to.The Operation Result pattern is perfect
    for crafting strongly typed return values that self-manage multiple states (error
    and success) or support complex states (like partial success). It is also ideal
    for transporting messages that are not necessarily errors, like information messages.
    Even in its simplest form, we can leverage the Operation Result pattern as a base
    for extensibility since we can add members to the result class over time, which
    would be impossible for a primitive type (or any type we don’t control).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了多种形式的Operation Result模式，从增强的布尔值到包含消息、值和成功指示器的复杂数据结构。我们还探讨了静态工厂和私有构造函数来控制外部访问。此外，在所有这些探索之后，让我们得出结论，围绕Operation
    Result模式几乎有无限的可能性。每个具体用例都应该决定如何实现它。从这里，我坚信你已经有足够的信息来探索这个模式的许多可能性，我强烈鼓励你这样做。Operation
    Result模式非常适合构建强类型返回值，这些返回值可以自我管理多个状态（错误和成功）或支持复杂状态（如部分成功）。它也非常适合传输不一定是错误的消息，如信息消息。即使在最简单的形式中，我们也可以利用Operation
    Result模式作为扩展的基础，因为我们可以在一段时间内向结果类添加成员，这对于原始类型（或任何我们无法控制的类型）是不可能的。
- en: The `HttpResponseMessage` class returned by the methods of the `HttpClient`
    class is an excellent example of a concrete implementation of the Operation Result
    pattern. It contains a single message exposed through the `ReasonPhrase` property.
    It exposes a complex success state through the `StatusCode` property and a simple
    success indicator through its `IsSuccessStatusCode` property. It also contains
    more information about the request and response through other properties.
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由`HttpClient`类的方法返回的`HttpResponseMessage`类是Operation Result模式具体实现的优秀示例。它通过`ReasonPhrase`属性暴露一个单一的消息。它通过`StatusCode`属性暴露一个复杂的成功状态，并通过其`IsSuccessStatusCode`属性暴露一个简单的成功指示器。它还通过其他属性包含有关请求和响应的更多信息。
- en: 'At this point, we would usually explore how the **Operation Result** pattern
    can help us follow the SOLID principles. However, it depends too much on the implementation,
    so here are a few key points instead:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们通常会探讨**Operation Result**模式如何帮助我们遵循SOLID原则。然而，它过于依赖于实现，所以这里有一些关键点：
- en: The `OperationResult` class encapsulates the result, extracting that responsibility
    from the other system’s components (SRP).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OperationResult`类封装了结果，从其他系统组件（SRP）中提取了这一责任。'
- en: We violated the ISP with the `Value` property in multiple examples. This infringement
    has a minor impact that we fixed as an example of overcoming this challenge.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个示例中，我们违反了ISP原则，在`Value`属性上。这种违规行为的影响很小，我们将其修复作为一个克服这一挑战的例子。
- en: We could compare an operation result to a DTO but returned by an operation (method)
    instead of a REST API endpoint. From there, we could add an abstraction or stick
    with returning a concrete class, but sometimes using concrete types makes the
    system easier to understand and maintain. Depending on the implementation, this
    may break different principles.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将操作结果与DTO进行比较，但它是通过操作（方法）而不是REST API端点返回的。从那里，我们可以添加一个抽象或坚持返回一个具体类，但有时使用具体类型可以使系统更容易理解和维护。根据实现方式，这可能会违反不同的原则。
- en: When the advantages surpass the minor impacts of those kinds of violations,
    it is acceptable to let them slide. Principles are ideals and are not applicable
    in every scenario—principles are not laws.
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当优势超过这种违规行为的微小影响时，可以接受让它们滑过去。原则是理想，并不适用于每个场景——原则不是法律。
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Most design decisions are trade-offs between two imperfect solutions, so you
    must choose which downsides you prefer to live with to gain the upsides.
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数设计决策是在两个不完美的解决方案之间的权衡，因此你必须选择你愿意忍受的缺点以获得优点。
- en: 'This chapter concludes *Section 3:* *Components Patterns* and leads to *Section
    4: Application Patterns*, where we explore higher-level design patterns.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了第3节：组件模式，并引出第4节：应用模式，在那里我们将探讨高级设计模式。
- en: Questions
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习题：
- en: Is returning an operation result when doing an asynchronous call, such as an
    HTTP request, a good idea?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行异步调用，如HTTP请求时，返回操作结果是一个好主意吗？
- en: What is the name of the pattern that we implemented using static methods?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用静态方法实现的模式叫什么名字？
- en: Is it faster to return an operation result than throw an exception?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回操作结果比抛出异常更快吗？
- en: In what scenario might the Operation Result pattern come in handy?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么场景下操作结果模式可能会派上用场？
- en: Further reading
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some links to build on what we learned in this chapter:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助我们巩固本章所学的内容：
- en: 'An article on my blog about exceptions (title: *A beginner guide to exceptions*
    | *The basics*): [https://adpg.link/PpEm](https://adpg.link/PpEm)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我博客上一篇关于异常的文章（标题：*异常入门指南* | *基础知识*）：[https://adpg.link/PpEm](https://adpg.link/PpEm)
- en: 'An article on my blog about Operation Result (title*: Operation result* | *Design
    Pattern*): [https://adpg.link/4o2q](https://adpg.link/4o2q)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我博客上一篇关于操作结果的文章（标题：*操作结果* | *设计模式*）：[https://adpg.link/4o2q](https://adpg.link/4o2q)
- en: Answers
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: Yes, asynchronous operations like HTTP are great candidates for the Operation
    Result pattern. For example, in the BCL, the `HttpResponseMessage` instance returned
    by the `Send` method of the `HttpClient` class is an operation result.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，异步操作，如HTTP，是操作结果模式的理想候选者。例如，在BCL中，`HttpClient`类的`Send`方法返回的`HttpResponseMessage`实例就是一个操作结果。
- en: We implemented two **static factory methods**.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了两个**静态工厂方法**。
- en: Yes, returning an object is marginally faster than throwing an exception.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，返回一个对象比抛出异常稍微快一点。
- en: The Operation Result pattern comes in handy when we want to return the state
    of the operation along with its return value as part of the main consumption flow.
    It is very suitable to return multiple properties describing the result of the
    process and is extensible.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们希望将操作的状态及其返回值作为主要消费流程的一部分返回时，操作结果模式非常有用。它非常适合返回描述过程结果的多个属性，并且是可扩展的。
