- en: Developing the Let's Chat Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 Let's Chat 网络应用程序
- en: 'In the previous chapter, we got the requirements and high level design of the
    Let''s Chat web application. We got started with the Let''s Chat web application
    by setting up project. We learned about the fundamental concepts of ASP.NET Core
    in the process. In this chapter, we will develop the Let''s Chat web application
    and learn about a few more concepts of ASP.NET Core. We will cover the following
    topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们获得了 Let's Chat 网络应用程序的需求和高级设计。我们通过设置项目开始了 Let's Chat 网络应用程序的开发。在这个过程中，我们学习了
    ASP.NET Core 的基本概念。在本章中，我们将开发 Let's Chat 网络应用程序，并了解 ASP.NET Core 的更多概念。本章我们将涵盖以下主题：
- en: ASP.NET Core 2.0 fundamentals
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 2.0 基础知识
- en: Implementing authentication through Facebook
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Facebook 实现身份验证
- en: ASP.NET Core 2.0 fundamentals
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 2.0 基础知识
- en: This section is a continuation of our journey of learning ASP.NET Core 2.0 fundamentals
    that we started in the previous chapter. We will (re)visit the fundamentals, so
    that we can use them correctly while coding the app. In this section, we will
    take a quick lap around MVC and we will further discuss routing, filters, error
    handling, and so on. Let's start with MVC.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是我们从上一章开始学习 ASP.NET Core 2.0 基础知识的旅程的延续。我们将（重新）回顾基础知识，以便在编码应用程序时能够正确使用它们。在本节中，我们将快速浏览
    MVC，并进一步讨论路由、过滤器、错误处理等内容。让我们从 MVC 开始。
- en: Quick lap around MVC
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速浏览 MVC
- en: '**MVC** stands for **Model**-**View**-**Controller**. The intent of this pattern
    is to achieve separation of concerns. In general terms, we can draw an analogy
    of MVC with "***Division of labour**"*. In this architectural pattern, the application
    is divided into three distinct components: the Model, the View, and the Controller.
    When a user requests a resource in the server, it is routed to a Controller which
    works with the Model to perform user actions and/or CRUD (**Create**, **Read**,
    **Update**, **Delete**) operations. The Controller then chooses the View to display
    the user interface to the user, and provides it with the required Model data.
    The following diagram displays the three main components:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVC** 代表 **模型**-**视图**-**控制器**。这种模式的目的是实现关注点的分离。一般而言，我们可以将 MVC 与“***劳动分工**”进行类比。在这种架构模式中，应用程序被划分为三个不同的组件：模型、视图和控制器。当用户在服务器上请求资源时，它会被路由到控制器，控制器与模型协同工作以执行用户操作和/或
    CRUD（**创建**、**读取**、**更新**、**删除**）操作。然后控制器选择视图向用户显示用户界面，并提供所需的模型数据。以下图表显示了三个主要组件：'
- en: '![](img/a6550793-3861-4a57-bb96-ce5695c89cd8.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6550793-3861-4a57-bb96-ce5695c89cd8.png)'
- en: 'We see that in the diagram, both the View and the Controller depend on the
    Model. However, the Model depends on neither of them. This is one of the key benefits
    of the pattern and also the golden rule for correct implementation of MVC. Using
    this separation, we can build and test the Model independently of the visual presentation.
    The **S** of the **SOLID** design principle, **single responsibility principle**
    (**SRP**), is at the heart of MVC. It also reiterates the **don''t repeat yourself**
    (**DRY**) principle. MVC is all about the separation of concerns to have better
    test-ability and maintainability. The responsibility of each of the components
    is clearly laid out:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在图表中，视图和控制器都依赖于模型。然而，模型不依赖于它们中的任何一个。这是该模式的一个关键优势，也是 MVC 正确实现的黄金法则。利用这种分离，我们可以独立于视觉表示来构建和测试模型。**S**OLID
    设计原则中的 **单一职责原则**（**SRP**）是 MVC 的核心。它还重申了 **不要重复自己**（**DRY**）原则。MVC 的一切都是关于关注点的分离，以实现更好的可测试性和可维护性。每个组件的责任都明确列出：
- en: '**Model** is the central component of this architectural pattern and represents
    the data. It maintains the data of the application.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**是这种架构模式的核心组件，代表数据。它维护应用程序的数据。'
- en: '**View** is the visual component and is the user interface for the model; that
    is, it displays the data of the model to the end user and also enables them to
    edit the data.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**是视觉组件，是模型的用户界面；也就是说，它向最终用户显示模型的数据，并使他们能够编辑数据。'
- en: '**Controller** is the controller of the request; that is, the request handler.
    Typically, users interact with the View for displaying, editing, adding, and deleting
    the data. This raises a corresponding URL request. This request is handled by
    a Controller. The Controller renders the appropriate View with the Model data
    as a response:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**是请求的控制器；也就是说，是请求处理器。通常，用户通过视图进行显示、编辑、添加和删除数据。这会引发相应的URL请求。这个请求由控制器处理。控制器使用模型数据渲染相应的视图作为响应：'
- en: '![](img/1a244219-e9fb-4ed4-be81-87f1db484713.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a244219-e9fb-4ed4-be81-87f1db484713.jpg)'
- en: 'The preceding diagram sums up the general working of the MVC pattern:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了MVC模式的一般工作原理：
- en: The client sends a request, which is routed to a **CONTROLLER**
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送请求，该请求被路由到**控制器**
- en: The **CONTROLLER** uses the **MODEL** to perform some *business* operations
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**控制器**使用**模型**执行一些*业务*操作'
- en: The **MODEL** returns the result of the operations back to the **CONTROLLER**
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模型**将操作的结果返回给**控制器**'
- en: The **CONTROLLER** decides which **VIEW** is to be rendered and sends it the
    model (data) that must be rendered
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**控制器**决定要渲染哪个**视图**，并发送必须渲染的模型（数据）'
- en: The **VIEW** renders the output and sends the response back to the client
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**视图**渲染输出并将响应发送回客户端'
- en: 'Let''s see an analogy of MVC in the real world, so that the new users of MVC
    find it link-able. Let''s think about a magazine. If I were to *loosely* fit a
    magazine cover in the MVC pattern, it would be as follows: the user sees the magazine.
    What we see as the cover of the magazine is the **View** (user interface). We
    see some text and an image; for example, a fashion model or a sports star in the
    View. This is the **Model** (data), and the photographer/editor would be the **Controller**
    as they have manipulated the data and displayed it in the cover. This hopefully
    demonstrates the gist of MVC.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看MVC在现实世界中的类比，以便MVC的新用户能够找到它。让我们考虑一本杂志。如果我要将杂志封面*粗略地*放入MVC模式中，它将是这样的：用户看到杂志。我们看到的是杂志的封面，这是我们所说的**视图**（用户界面）。我们看到一些文本和图像；例如，在视图中我们看到一个时装模特或体育明星。这是**模型**（数据），而摄影师/编辑将是**控制器**，因为他们已经操纵了数据并在封面上显示它。这希望展示了MVC的核心。
- en: 'A couple of trivia questions. When was MVC invented? The answer roughly would
    be 1979 (December 10). Who invented it? A Smalltalk programmer, named Trygve Reenskaug
    (read about him at: [https://en.wikipedia.org/wiki/Trygve_Reenskaug](https://en.wikipedia.org/wiki/Trygve_Reenskaug)),
    who maintains a web page to explain the history of MVC in his own words at: [http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html](http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html).
    It''s worth a read!'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 几个趣味问题。MVC是什么时候发明的？答案大约是1979年（12月10日）。是谁发明的？一个名为Trygve Reenskaug的Smalltalk程序员（了解更多关于他：[https://en.wikipedia.org/wiki/Trygve_Reenskaug](https://en.wikipedia.org/wiki/Trygve_Reenskaug)），他在自己的网页上维护一个页面，用他自己的话解释MVC的历史：[http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html](http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html)。值得一读！
- en: 'So far, we have discussed MVC as an architectural pattern. Since we are learning
    ASP.NET Core, let''s talk about the ASP.NET Core MVC framework. The ASP.NET Core
    MVC is a lightweight, open source, and highly testable presentation framework,
    that has been tailor-made for use with ASP.NET Core. It gives full control over
    the generated HTML markup and follows the latest web standards. To use it is pretty
    simple as well. We just need to add MVC in a services container, by writing `AddMVC`
    in the `ConfigureServices` method of `Startup.cs`, and then configure the pipeline
    to start using it by writing `UseMVC`, as shown in the following code snippets:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了MVC作为一个架构模式。由于我们正在学习ASP.NET Core，让我们谈谈ASP.NET Core MVC框架。ASP.NET
    Core MVC是一个轻量级、开源且高度可测试的表示框架，专为与ASP.NET Core一起使用而量身定制。它对生成的HTML标记有完全控制权，并遵循最新的网络标准。使用它也很简单。我们只需要在`Startup.cs`的`ConfigureServices`方法中添加MVC到服务容器中，通过写入`AddMVC`，然后通过写入`UseMVC`来配置管道以开始使用它，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`UseMvc` has two overloads:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseMvc`有两个重载：'
- en: '`UseMvc()`: This works only with attribute-based routes, which we will visit
    in a while.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseMvc()`: 这仅与基于属性的路线一起工作，我们将在稍后讨论。'
- en: '`UseMvc(Action<IRouteBuilder> configureRoutes)`: This works with both conventional
    and attribute- based routes. It has a `callback` method to configure the routes.
    We have used this overload in the preceding sample.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UseMvc(Action<IRouteBuilder> configureRoutes)`: 这与常规和基于属性的路线一起工作。它有一个`回调`方法来配置路线。我们在前面的示例中使用了这个重载。'
- en: 'This can be seen from the documentation of the API, which defines the `UseMvc`
    extension methods. The code can be seen at GitHub at: [https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Builder/MvcApplicationBuilderExtensions.cs](https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Builder/MvcApplicationBuilderExtensions.cs).[](https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Builder/MvcApplicationBuilderExtensions.cs)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以从 API 的文档中看出，它定义了 `UseMvc` 扩展方法。代码可以在 GitHub 上看到：[https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Builder/MvcApplicationBuilderExtensions.cs](https://github.com/aspnet/Mvc/blob/760c8f38678118734399c58c2dac981ea6e47046/src/Microsoft.AspNetCore.Mvc.Core/Builder/MvcApplicationBuilderExtensions.cs)。
- en: There is one more extension method, `UseMvcWithDefaultRoute`, which can be used
    to configure MVC to work with a default route named `default` and `template` as
    `'{controller=Home}/{action=Index}/{id?}'`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个扩展方法，`UseMvcWithDefaultRoute`，可以用来配置 MVC 以与默认路由 `default` 和模板 `'{controller=Home}/{action=Index}/{id?}'`
    一起工作。
- en: 'By using any of the preceding extension methods to use MVC middleware, we can
    start leveraging the goodness of ASP.NET Core MVC. Recall that by doing so, we
    are entering the last middleware/section of the request pipeline, as shown in
    the following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用前面提到的任何扩展方法来使用 MVC 中间件，我们可以开始利用 ASP.NET Core MVC 的优点。回想一下，这样做，我们就进入了请求管道的最后一个中间件/部分，如下面的图所示：
- en: '![](img/d3e9e282-a282-4411-95e7-87434e492097.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3e9e282-a282-4411-95e7-87434e492097.png)'
- en: We saw this diagram in the previous chapter as well. However, the clarification
    of this section, other middleware in the pipeline blurred out to indicate we are
    focusing on MVC middleware. Let's have a look at this in detail.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中也看到了这个图。然而，本节的澄清，将管道中的其他中间件模糊化以表明我们正在关注 MVC 中间件。让我们详细看看这个。
- en: 'The middleware resides in the `Microsoft.AspNetCore.Builder` namespace in the
    `Microsoft.AspNetCore.Mvc.Core` assembly. Let''s look at the code map diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件位于 `Microsoft.AspNetCore.Builder` 命名空间中的 `Microsoft.AspNetCore.Mvc.Core`
    程序集。让我们看看代码映射图：
- en: '![](img/dcd3c9f8-028b-4b7d-a684-49ccb07e4861.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcd3c9f8-028b-4b7d-a684-49ccb07e4861.png)'
- en: 'As we can see, there is so much that we can''t even see the association and
    inheritance relationships between the different components. Don''t worry about
    this complexity; it''s already baked in the framework and we just need to learn
    and use things of interest. ASP.NET Core MVC is rich in features and includes
    the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有太多内容我们甚至看不到不同组件之间的关联和继承关系。不用担心这种复杂性；它已经内置在框架中，我们只需要学习和使用感兴趣的东西。ASP.NET
    Core MVC 功能丰富，包括以下内容：
- en: Routing
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: Model binding
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型绑定
- en: Validation
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: Filters
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器
- en: Controller
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器
- en: Error handling
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: We will discuss them in the following sections.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论它们。
- en: Routing
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由
- en: ASP.NET Core MVC is a powerful URL-mapping software component as it stands on
    top of ASP.NET Core routing. As a result, we can build apps that have easily understandable
    and searchable URLs. This way, we can define our app's URL naming patterns that
    work well for **search engine optimization** (**SEO**) and link generation, without
    having to worry about how the files are physically organized in the server. In
    the ASP.NET Core MVC framework, routing is defined in the `Microsoft.AspNetCore.Mvc.Routing`
    namespace.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 是一个强大的 URL 映射软件组件，因为它建立在 ASP.NET Core 路由之上。因此，我们可以构建易于理解和搜索的
    URL 的应用程序。这样，我们可以定义我们应用程序的 URL 命名模式，这对于 **搜索引擎优化**（**SEO**）和链接生成非常有用，而无需担心文件在服务器上的物理组织方式。在
    ASP.NET Core MVC 框架中，路由是在 `Microsoft.AspNetCore.Mvc.Routing` 命名空间中定义的。
- en: 'Let''s look at the code map diagram for routing:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看路由的代码映射图：
- en: '![](img/459bbd68-f5a2-4208-8134-ae8d20685d16.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/459bbd68-f5a2-4208-8134-ae8d20685d16.png)'
- en: We see `HttpMethodAtribute`, which has the properties `Name`, `Template`, `HttpMethods,`and
    `Order` apart from the constructor. We see `UrlHelperFactory`, `UrlHelper`, `RouteValueAttribute`,
    and `KnownRouteValueConstraint` with their properties, constructors, and methods.
    Routing is the mechanism through which incoming requests are mapped to controllers
    and actions, that is, the controller and action can be deduced from the request
    URL.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 `HttpMethodAtribute` 除了构造函数外，还具有 `Name`、`Template`、`HttpMethods` 和 `Order`
    属性。我们看到了 `UrlHelperFactory`、`UrlHelper`、`RouteValueAttribute` 和 `KnownRouteValueConstraint`
    以及它们的属性、构造函数和方法。路由是将传入请求映射到控制器和操作的机制，也就是说，可以从请求 URL 推导出控制器和操作。
- en: For example, consider the request URL as `http://localhost:9596/packt/Books/Index`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑请求 URL 为 `http://localhost:9596/packt/Books/Index`。
- en: This maps to the books controller and index action. This mapping of controller
    and action from the request URL is the job of routing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将映射到书籍控制器和索引操作。从请求 URL 中映射控制器和操作是路由的工作。
- en: 'We already discussed that MVC is itself injected as a middleware in the request
    pipeline. The routing middleware makes use of routing templates to do the mapping.
    An example of a simple routing template is shown in the following code: `packt/{controller=Home}/{action=Index}/{id?}`.
    Routing templates use literals and tokens. Literals are matched exactly to the
    text in URL, whereas tokens are replaced when matching a route. Tokens are enclosed
    in `{}`. In the preceding example, we have three tokens:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过 MVC 本身作为中间件注入到请求管道中。路由中间件利用路由模板进行映射。以下代码展示了简单的路由模板示例：`packt/{controller=Home}/{action=Index}/{id?}`。路由模板使用文本和令牌。文本与
    URL 中的文本完全匹配，而令牌在匹配路由时会被替换。令牌用 `{}` 括起来。在上面的例子中，我们有三个令牌：
- en: '**Controller token:** `{controller=Home}`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器令牌:** `{controller=Home}`'
- en: '**Action token:** `{action=Index}`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作令牌:** `{action=Index}`'
- en: '**ID token:** `{id?}`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID 令牌:** `{id?}`'
- en: And `packt` is the literal which would be matched with the requested URL.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 `packt` 是与请求的 URL 匹配的文本。
- en: Matching a template requires a controller token and action token, as this is
    the key information routing middleware needs to locate the controller and action.
    Other tokens in the URL are mapped to the parameters of action methods using model
    binding, which we will see later. When adding a route mapping, default values
    can be provided for tokens. In the preceding example, `Home` is the default value
    of the controller token and `Index` is the value of the action token. Templates
    can also provide optional tokens for action parameters, such as `{id?}`. `?`,
    which here indicates that it is optional.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配模板需要控制器令牌和操作令牌，因为这是路由中间件需要定位控制器和操作的关键信息。URL 中的其他令牌将使用模型绑定映射到操作方法的参数中，我们将在后面看到。在添加路由映射时，可以为令牌提供默认值。在上面的例子中，`Home`
    是控制器令牌的默认值，`Index` 是操作令牌的值。模板还可以为操作参数提供可选令牌，例如 `{id?}`。`?`，在这里表示它是可选的。
- en: 'Now suppose a client requests the following URL:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设客户端请求以下 URL：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This URL would match the preceding template and would invoke the `Index` action
    with the `id` value as `2` on the `Books` controller. So, the code of `BooksController`
    would be roughly like:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 URL 将匹配前面的模板，并将调用 `Books` 控制器上的 `Index` 操作，`id` 值为 `2`。因此，`BooksController`
    的代码大致如下：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following client requests would also be served:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下客户端请求也将被服务：
- en: '`http://localhost:9596/packt/Books/Index`: The `id` parameter is optional'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:9596/packt/Books/Index`: `id` 参数是可选的'
- en: '`http://localhost:9596/packt/Books`: The default value of the `Index` would
    be used for the action'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:9596/packt/Books`: 对于操作使用 `Index` 的默认值'
- en: '`http://localhost:9596/packt`: The default value of the `Home` would be used
    for the controller and the `Index` for the action'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:9596/packt`: 对于控制器使用 `Home` 的默认值，对于操作使用 `Index`'
- en: These were all happy path scenarios, but what if the URL is `http://localhost:9596/packt/Books/Index/.NETCore2.0ByExample?`
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是愉快的路径场景，但如果 URL 是 `http://localhost:9596/packt/Books/Index/.NETCore2.0ByExample?`
- en: 'In this case, the controller would resolve to `BooksController`, and the action
    would resolve to `Index`. However, the last parameter is defined as `int`, which
    is not what we want. To ensure that `id` is always an integer for the mapping,
    we can use route constraint, as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，控制器将解析为 `BooksController`，操作将解析为 `Index`。然而，最后一个参数被定义为 `int` 类型，这不是我们想要的。为了确保
    `id` 在映射中始终是整数，我们可以使用路由约束，如下所示：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This ensures that the route maps to action only if `id` is specified as an
    optional `int`; otherwise, the URL would not map to this route. There are lots
    of constraints that can be used, such as:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了只有当 `id` 被指定为可选的 `int` 时，路由才会映射到操作；否则，URL 不会映射到此路由。有许多约束可以使用，例如：
- en: '`:bool`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:bool`'
- en: '`:datetime`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:datetime`'
- en: '`:decimal`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:decimal`'
- en: '`:guid`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:guid`'
- en: '`:int`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:int`'
- en: '`:length(min,max)`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:length(min,max)`'
- en: The comprehensive list of constraints can be seen in Microsoft route constraint
    reference at: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing#route-constraint-reference](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing#route-constraint-reference).[](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing#route-constraint-reference)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 Microsoft 路由约束参考中看到完整的约束列表：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing#route-constraint-reference](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing#route-constraint-reference)
- en: The URL strings are case-insensitive, so `packt` and `Packt` are treated the
    same.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: URL 字符串不区分大小写，因此 `packt` 和 `Packt` 被视为相同。
- en: 'The following is the code map diagram of `RouterMiddleware` and the extensions
    to use for this middleware:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `RouterMiddleware` 的代码映射图以及用于此中间件的扩展：
- en: '![](img/18685ea8-8c87-4c17-ba3d-66ed2b10e534.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18685ea8-8c87-4c17-ba3d-66ed2b10e534.png)'
- en: 'Now that we know about routing middleware and how the routing template works,
    let''s look at the types of routing. Broadly speaking, there are the following
    types of routing:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了路由中间件以及路由模板的工作方式，让我们看看路由的类型。从广义上讲，有以下几种类型的路由：
- en: Convention-based routing
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于约定的路由
- en: Attribute routing
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性路由
- en: Mixed routing; that is, a combination of the preceding two types
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合路由；即前两种类型的组合
- en: '**Convention-based routing** enables us to define the URL formats, which are
    understood by the application. Convention-based routing also lets us define how
    each of the URL formats maps to a specific action method on a controller. Once
    a request is received, the routing engine parses the URL and matches it to one
    of the defined URL formats. Based on the url format, the controller and action
    method is mapped and invoked by the routing engine. The code example that can
    be used in the `UseMvc` method that takes the `routeBuilder` action as a parameter
    in the `Configure` method of Startup.cs is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于约定的路由**使我们能够定义应用程序能够理解的 URL 格式。基于约定的路由还允许我们定义每个 URL 格式如何映射到控制器上的特定操作方法。一旦收到请求，路由引擎解析
    URL 并将其与定义的 URL 格式之一匹配。根据 URL 格式，控制器和操作方法由路由引擎映射并调用。以下是在 Startup.cs 的 `Configure`
    方法中，`UseMvc` 方法作为参数传递给 `routeBuilder` 操作的代码示例：'
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding method adds a route named `"default"`. We can specify multiple
    named routes and templates, and these would be executed in the order in which
    they are defined.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法添加了一个名为 `"default"` 的路由。我们可以指定多个命名路由和模板，并且它们将按照定义的顺序执行。
- en: 'The `MapRoute` method has several overloads. These can be seen in the following
    documentation:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapRoute` 方法有几个重载。这些可以在以下文档中看到：'
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Attribute routing** can be used to describe routing information by decorating
    the attributes on the controller and actions. This means that the route definitions
    of the controller are placed adjacent to the controller and action tokens with
    which they''re associated. This is done by using the `Route` attribute, which
    contains the route of the `controller`, as shown in the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性路由**可以通过装饰控制器和操作上的属性来描述路由信息。这意味着控制器的路由定义放置在与它们关联的控制器和操作标记相邻的位置。这是通过使用包含
    `controller` 路由的 `Route` 属性来完成的，如下面的代码所示：'
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also use any of the `Http` verbs, such as `HttpGet`, `HttpPut`, `HttpPost`,
    `HttpDelete`, and so on, to specify the attribute-based routes. The following
    code snippet illustrates the route specified for the `Index` action. Also note
    that we have multiple `HttpGet` attributes applied to the action, showing that
    multiple routes can map to a single action:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用任何 `Http` 动词，例如 `HttpGet`、`HttpPut`、`HttpPost`、`HttpDelete` 等，来指定基于属性的路线。以下代码片段说明了为
    `Index` 操作指定的路由。请注意，我们对操作应用了多个 `HttpGet` 属性，这表明多个路由可以映射到单个操作：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These `HttpGet` attributes with routes are referring to the following URL path.
    For example, if we are passing a blank inside `HttpGet`, it is taking us to the `http://localhost:9596/packt/Books`
    path and if we are passing `HttpGet("index")`, it will refer until the index page:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些带有路由的 `HttpGet` 属性指的是以下 URL 路径。例如，如果我们向 `HttpGet` 传递一个空字符串，它将带我们到 `http://localhost:9596/packt/Books`
    路径，如果我们传递 `HttpGet("index")`，它将指向索引页面：
- en: '`[HttpGet("index")]` matches `http://localhost:9596/packt/Books/index`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpGet("index")]` 匹配 `http://localhost:9596/packt/Books/index`'
- en: '`[HttpGet("")]` matches `http://localhost:9596/packt/Books`; that is, the default
    `action` of `controller`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpGet("")]` 匹配 `http://localhost:9596/packt/Books`；即 `controller` 的默认 `action`'
- en: '`[HttpGet("~/")]` matches `http://localhost:9596/packt/Books`; that is, the
    default `action` of `controller`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpGet("~/")]` 匹配 `http://localhost:9596/packt/Books`；即 `controller` 的默认
    `action`'
- en: Since we can have multiple routes, ordering can be applied to the route attributes
    to execute a general route or specific route as needed. The framework would look
    at the `Order` property and execute the routes in ascending order. The default
    `Order` of `0` would execute, followed by the route that is immediately higher
    than it, and so on.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以有多个路由，因此可以应用排序到路由属性，以执行所需的通用路由或特定路由。框架将查看 `Order` 属性并按升序执行路由。默认的 `Order`
    为 `0` 将执行，然后是比它高一级的路由，依此类推。
- en: '**Mixed routing** is a perfectly valid scenario as based on the requirements;
    we may have convention-based routing in some controllers and actions and attribute
    routing for others. However, we cannot have both for the same action. If an action
    uses attribute routing, no convention-based routes can map to that action. Placing
    a route attribute on the controller or the action makes it attribute routed. Actions
    that define attribute routes cannot be reached through the conventional routes
    and vice-versa.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**混合路由**是一个完全有效的场景，因为根据需求，我们可能在某些控制器和操作中使用基于约定的路由，而在其他操作中使用属性路由。然而，我们不能对同一个操作同时使用这两种路由。如果一个操作使用属性路由，则基于约定的路由无法映射到该操作。在控制器或操作上放置路由属性使其成为属性路由。定义属性路由的操作无法通过常规路由访问，反之亦然。'
- en: Next in the pipeline, after the request is routed, it maps to a controller action.
    We will close our discussion on routing here. The next hop on the request pipeline
    diagram is the authorization filter. We will skip it for now and discuss it when
    we discuss filters later in the chapter. Let's discuss model binding now, which
    comes into the picture after the authorization filter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求管道中的下一步，在请求被路由后，它映射到一个控制器操作。我们在这里结束对路由的讨论。请求管道图中的下一个步骤是授权过滤器。我们现在先跳过它，稍后在本章讨论过滤器时再讨论。现在让我们讨论模型绑定，这是在授权过滤器之后出现的。
- en: The request may be a `PUT`, `POST`, `DELETE`, or `GET` operation and, based
    on the operation it is meant to handle, the action may have parameters, which
    need to be populated by the framework from the client request data. The component
    that does this conversion is called the model binder. Let's have a look at it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请求可能是一个 `PUT`、`POST`、`DELETE` 或 `GET` 操作，并且根据要处理的操作，操作可能具有参数，这些参数需要由框架从客户端请求数据中填充。执行此转换的组件称为模型绑定器。让我们来看看它。
- en: Model binding
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型绑定
- en: 'As discussed, model binding maps the data from HTTP requests to action method
    parameters. These parameters, like any other C# method, can be simple types, such
    as `int`, `long`, `decimal`, `string`, or the complex classes. ASP.NET Core MVC
    has abstracted this logic away from the developers so that they need not worry
    about this request data to parameter conversion. This conversion is done by the
    framework in a predefined order. Let''s look at how the framework does this. The
    following is the code map diagram of the model binding subsystem:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，模型绑定将 HTTP 请求中的数据映射到操作方法参数。这些参数，就像任何其他 C# 方法一样，可以是简单类型，如 `int`、`long`、`decimal`、`string`，或者复杂类。ASP.NET
    Core MVC 将此逻辑从开发者那里抽象出来，使他们无需担心将请求数据转换为参数。这种转换由框架按照预定义的顺序完成。让我们看看框架是如何做到这一点的。以下是模型绑定子系统的代码映射图：
- en: '![](img/57145395-eb03-4383-b1bc-91726772f010.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57145395-eb03-4383-b1bc-91726772f010.png)'
- en: 'Important things to notice in the diagram are:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中需要注意的重要事项是：
- en: '`ParameterBinder`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParameterBinder`'
- en: '`ValueProvider` factories'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValueProvider` 工厂'
- en: Value providers
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价值提供者
- en: Attributes
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Extensions
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展
- en: 'The framework tries to bind the request data to the action parameters by name.
    To do so, it looks at the values for each parameter using the parameter name and
    the names of its public settable properties. In the preceding `GetBook` request
    URL example, the only action parameter was named `id`, which the framework binds
    to the value with the same name in the route values. The ASP.NET Core MVC framework uses
    three primary value providers or data sources to map HTTP request data to action
    parameters, in the following order:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 框架试图通过名称将请求数据绑定到操作参数。为此，它使用参数名称及其公共可设置属性的名称查看每个参数的值。在前面的`GetBook`请求URL示例中，唯一的操作参数名为`id`，框架将其绑定到路由值中具有相同名称的值。ASP.NET
    Core MVC框架使用三个主要值提供程序或数据源来按以下顺序将HTTP请求数据映射到操作参数：
- en: '**Form values** **(using** `FormValueProvider`**)**: The values in the form
    that came in the HTTP request body. These would generally be in `HttpPost` or
    `HttpPut`'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**表单值** **（使用** `FormValueProvider`**）**：HTTP请求正文中表单中的值。这些通常在`HttpPost`或`HttpPut`中'
- en: '**Route values (using** `RouteValueProvider`**)**: The values provided by the
    routing subsystem, which executes just before model binding is used'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**路由值（使用** `RouteValueProvider`**）**：由路由子系统提供的值，该子系统在模型绑定之前执行'
- en: '**Query string (using** `QueryStringValueProvider`**)**: The values found in
    the request URL query string are used'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查询字符串（使用** `QueryStringValueProvider`**）**：使用请求URL查询字符串中找到的值'
- en: All the preceding data is stored in name value pairs in corresponding dictionaries.
    If, after performing this exercise, the model binding fails for some reason, it
    does not throw an exception; it just sets the `IsValid` property of `ModelState`
    to `false`. It's up to the action method to handle such scenarios.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的数据都存储在相应的字典中的名称值对中。如果在执行此操作后，由于某种原因模型绑定失败，它不会抛出异常；它只是将`ModelState`的`IsValid`属性设置为`false`。处理此类情况的责任在于操作方法。
- en: 'Apart from the default model binding, the framework also provides a customized
    way to accomplish model binding by using attributes that we noted in the preceding
    code map diagram. We can use these attributes to alter the binding behavior of
    the property of a complex object, which is used as an action parameter, or to
    the parameter itself directly. Let''s look at these attributes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认的模型绑定之外，该框架还提供了一种通过使用我们在前面的代码映射图中提到的属性来自定义模型绑定的方法。我们可以使用这些属性来改变复杂对象属性（用作操作参数）的绑定行为，或者直接绑定到参数本身。让我们看看这些属性：
- en: '`[BindNever]`: This tells the model binder to ignore this parameter from binding'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[BindNever]`：这告诉模型绑定器忽略此参数进行绑定'
- en: '`[BindRequired]`: This attribute adds a model state error if the binding fails'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[BindRequired]`：此属性在绑定失败时添加模型状态错误'
- en: '`[FromBody]`: This tells the model binder to bind the data from the request
    body'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromBody]`：这告诉模型绑定器绑定请求正文中的数据'
- en: '`[FromForm]`: This tells the model binder that the value should be fetched
    through the form data'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromForm]`：这告诉模型绑定器应该通过表单数据获取值'
- en: '`[FromHeader]`: This tells the model binder that value should be fetched through
    a header'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromHeader]`：这告诉模型绑定器应该通过头部获取值'
- en: '`[FromQuery]`: This tells the model binder that the value should be fetched
    through a query string'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromQuery]`：这告诉模型绑定器应该通过查询字符串获取值'
- en: '`[FromRoute]`: This tells the model binder that the value should be fetched
    through the route data'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromRoute]`：这告诉模型绑定器应该通过路由数据获取值'
- en: '`[FromServices]`: This tells the model binder that dependency injection should
    be used to bind the parameter'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromServices]`：这告诉模型绑定器应该使用依赖注入来绑定参数'
- en: '`[ModelBinder]`: This attribute is used to override the default model binder,
    binding the source and name'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ModelBinder]`：此属性用于覆盖默认模型绑定器，绑定源和名称'
- en: The next hop of the request is validation, so let's have a look at validation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的下一个步骤是验证，让我们来看看验证。
- en: Validation
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: 'Validation is one of the key operations for any app working with data. Before
    we persist the data to the persistent store (database/filesystem), we should ensure
    the sanctity of the data, its format, type, size, and check if it complies to
    our rules and doesn''t pose any potential security threat. This is ensured through
    validation. This can be done at both the client and server side. I am a firm believer
    that validation should be performed at both the client and server side. The validation
    has been abstracted from the developers into validation attributes, which reduces
    the amount of code needed to perform the validation. Validation attributes are
    C# attributes that derive from `ValidationAttribute`. Most of the commonly used
    validation attributes can be found in the `System.ComponentModel.DataAnnotations`
    namespace. In case the already provided attribute does not suffice our needs,
    we can do either of the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 验证是任何与数据打交道的应用程序的关键操作之一。在我们将数据持久化到持久存储（数据库/文件系统）之前，我们应该确保数据的安全、格式、类型、大小，并检查它是否符合我们的规则，以及是否存在任何潜在的安全威胁。这通过验证来确保。这可以在客户端和服务器端进行。我坚信验证应该在客户端和服务器端都进行。验证已经从开发者那里抽象出来，变成了验证属性，这减少了执行验证所需的代码量。验证属性是派生自`ValidationAttribute`的C#属性。大多数常用的验证属性都可以在`System.ComponentModel.DataAnnotations`命名空间中找到。如果已经提供的属性不能满足我们的需求，我们可以执行以下操作之一：
- en: Create a new custom validation attribute that derives from `ValidationAttribute`
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的自定义验证属性，该属性从`ValidationAttribute`派生
- en: Implement the interface `IValidatableObject` in our model class
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的模型类中实现`IValidatableObject`接口
- en: 'The following code map diagram illustrates both the `ValidationAttribute` as
    well as the `IValidatableObject` interface:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码映射图展示了`ValidationAttribute`以及`IValidatableObject`接口：
- en: '![](img/b24d3896-f861-4c5c-96cb-ee1ac49a9333.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b24d3896-f861-4c5c-96cb-ee1ac49a9333.png)'
- en: '`IValidatableObject` is a simple interface with just the`Validate` method,
    while `ValidationAttribute` has a lot more to offer for customization and has
    `IsValid`, `Validate`, and `GetValidationResult` methods along with properties
    to meet the validation needs. We also see that there are numerous attributes already
    defined and derived from `ValidationAttribute`. Some of the most important ones
    are:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`IValidatableObject`是一个简单的接口，只有一个`Validate`方法，而`ValidationAttribute`提供了更多用于自定义的功能，并具有`IsValid`、`Validate`和`GetValidationResult`方法，以及用于满足验证需求的属性。我们还看到，已经定义了大量的属性，并且它们都派生自`ValidationAttribute`。其中一些最重要的属性包括：'
- en: '`UrlAttribute`: Validates that the property has a valid URL.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UrlAttribute`：验证属性是否具有有效的URL。'
- en: '`PhoneAttribute`: Validates that the property has a telephone format.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PhoneAttribute`：验证属性是否具有电话格式。'
- en: '`FileExtensionsAttribute`: Validates that the file extensions are valid as
    per the predefined set of file extensions.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileExtensionsAttribute`：验证文件扩展名是否根据预定义的文件扩展名集有效。'
- en: '`EmailAddressAttribute`: Validates that the property has a valid email format.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmailAddressAttribute`：验证属性是否具有有效的电子邮件格式。'
- en: '`CreditCardAttribute`: Validates that the property has a credit card format.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreditCardAttribute`：验证属性是否具有信用卡格式。'
- en: '`DataTypeAttribute`: Validates that the property has a valid data type, as
    specified by passing the `DataType` enumeration value. The `DataType` enumeration
    value can be seen at the top part of the preceding image.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataTypeAttribute`：验证属性是否具有有效的数据类型，该数据类型由传递的`DataType`枚举值指定。`DataType`枚举值可以在前一张图的顶部部分看到。'
- en: '`RangeAttribute`: Validates that the property value falls within the specified
    range.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RangeAttribute`：验证属性值是否在指定的范围内。'
- en: '`RegularExpressionAttribute`: Validates that the property value matches the
    given regular expression.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegularExpressionAttribute`：验证属性值是否与给定的正则表达式匹配。'
- en: '`RequiredAttribute`: Makes a property mandatory and hence the user would always
    have to provide its value.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequiredAttribute`：使属性成为必填项，因此用户始终必须提供其值。'
- en: '`CompareAttribute`: Validates two properties in a model match.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompareAttribute`：验证模型中的两个属性是否匹配。'
- en: '`StringLengthAttribute`: Validates that the string property value length does
    not exceed the maximum length.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringLengthAttribute`：验证字符串属性值长度不超过最大长度。'
- en: 'Applying only validation attributes to the model properties is not sufficient
    to perform the validation; we should ensure that on the server side in our action
    method, we also perform the `ModelState.IsValid` check to ensure that the input
    data validation passed or failed and act accordingly for pass and failed cases.
    The ASP.NET MVC Core framework sets the `ModelState` dictionary with errors after
    it performs the model binding from the HTTP request; if the validation does not
    pass, `ModelState.IsValid` would be false even if there is one validation error.
    This happens before the action execution starts, so we have the validation result
    available as soon as we enter the action method code. The framework, by default,
    continues validating properties until it reaches a maximum count of `200`. This
    number is configurable though by writing the following code in the `ConfigureServices`
    method of the `Startup.cs` method, which sets the maximum count to `20`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 仅将验证属性应用于模型属性不足以执行验证；我们应该确保在我们的动作方法中，服务器端也执行`ModelState.IsValid`检查，以确保输入数据验证通过或失败，并相应地处理通过和失败的情况。ASP.NET
    MVC Core 框架在从 HTTP 请求执行模型绑定后设置`ModelState`字典中的错误；如果验证未通过，即使有一个验证错误，`ModelState.IsValid`也会是假的。这发生在动作执行开始之前，因此我们可以在进入动作方法代码时立即获得验证结果。默认情况下，框架会继续验证属性，直到达到最大计数`200`。这个数字可以通过在`Startup.cs`方法的`ConfigureServices`方法中编写以下代码来配置，将最大计数设置为`20`：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In case we wish to perform some validations after the model binding and validations
    are completed, we can do so by manually invoking the validation using: `TryValidateModel(<<model
    to validate>>)`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在模型绑定和验证完成后执行一些验证，我们可以通过手动调用验证来实现：`TryValidateModel(<<要验证的模型>>)`。
- en: 'All this time, what we saw was the server-side validation, which involves a
    round trip to the server and hence takes time, so to do an additional validation
    in the client side makes sense so that if the validation fails, we do not even
    send the request to the server. We will have a quick discussion about client-side
    validation when we look at the Views, later in the chapter. Now that we have the
    concept and theory in mind, let''s do a quick implementation of the validation.
    Suppose we want to validate the book information, such as name, author, description,
    publisher, pages, release date, price, and so on, before saving the book information
    to the database. To do so, let''s create a model and controller. The model would
    look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些时间，我们看到的是服务器端验证，这涉及到一次往返服务器，因此需要时间，所以在客户端进行额外的验证是有意义的，这样如果验证失败，我们甚至不会向服务器发送请求。当我们查看本章后面的视图时，我们将在那里快速讨论客户端验证。现在我们已经有了概念和理论，让我们快速实现验证。假设我们想在将书籍信息保存到数据库之前验证书籍信息，如名称、作者、描述、出版社、页数、发布日期、价格等。为此，让我们创建一个模型和控制器。模型看起来如下所示：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And the controller would look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器看起来如下所示：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, there are two paths in the `SaveBookInfo` method. If `ModelState.IsValid` is
    true, the data is valid and the data can be saved to the persistent storage; otherwise,
    we return to the same `View`. Generally, the `View` would have a validation summary
    that would display the validation errors.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`SaveBookInfo`方法中有两条路径。如果`ModelState.IsValid`为真，数据有效，数据可以保存到持久存储中；否则，我们返回到相同的`View`。通常，`View`会有一个验证摘要，会显示验证错误。
- en: That's it! It is this easy to implement server-side validation. This concludes
    our discussion on validation. Let's move on to filters.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单！实现服务器端验证就这么容易。这结束了我们对验证的讨论。让我们继续讨论过滤器。
- en: Filters
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器
- en: Filters in ASP.NET Core MVC are the places where we can run the code before
    or after the action execution in the request processing pipeline. Filters run
    within the MVC action invocation pipeline, also known as **filter pipeline**.
    This pipeline comes into View after the framework chooses the action to be executed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core MVC 中，过滤器是在请求处理管道中执行代码的地点，在动作执行前后。过滤器在 MVC 动作调用管道中运行，也称为**过滤器管道**。这个管道在框架选择要执行的动作之后进入视图。
- en: 'The following list view code map diagram illustrates the actors involved in
    filters:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表视图代码映射图说明了过滤器中涉及的参与者：
- en: '![](img/7710e46c-b1fc-406b-9794-93343b071a91.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7710e46c-b1fc-406b-9794-93343b071a91.png)'
- en: 'On the right, we have attributes defined, which are abstract classes. On the
    left, there are abstractions and context classes. The filters execute at different
    stages in the action execution pipeline, based on the type of filter, which can
    be:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，我们定义了属性，它们是抽象类。在左侧，有抽象类和上下文类。根据过滤器的类型，过滤器在动作执行管道的不同阶段执行，可以是：
- en: '**Authorization filters**: These are the implementation of `IAuthorizationFilter`/`IAsyncAuthorizationFilter`
    and are run first to determine if the current user is authorized or not. They
    can short circuit the pipeline if the user in unauthorized.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权过滤器**：这些是`IAuthorizationFilter`/`IAsyncAuthorizationFilter`的实现，并且首先运行以确定当前用户是否有权限。如果用户未授权，它们可以短路管道。'
- en: '**Resource filters**: These are the implementation of `IResourceFilter`/`IAsyncResourceFilter`
    and are run immediately after the authorization filters. When these filters execute,
    model binding has not taken place in the pipeline so they can be used to alter
    the model binding. The most common use of these filters is that of caching.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源过滤器**：这些是`IResourceFilter`/`IAsyncResourceFilter`的实现，并且紧随授权过滤器之后运行。当这些过滤器执行时，管道中尚未进行模型绑定，因此它们可以用来修改模型绑定。这些过滤器最常见的使用是缓存。'
- en: '**Action filters**: These filters are the implementation of `IActionFilter` / `IAsyncActionFilter`
    or `ActionFilterAttribute` and are run immediately before and after an action
    execution. Due to their location in the pipeline, they are well-suited for any
    manipulation to action method parameters as well as to returned results from the
    action.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作过滤器**：这些过滤器是`IActionFilter` / `IAsyncActionFilter`或`ActionFilterAttribute`的实现，并且在动作执行前后立即运行。由于它们在管道中的位置，它们非常适合对动作方法参数以及从动作返回的结果进行任何操作。'
- en: '**Exception filters**: These filters are the implementation of `IExceptionFilter`
    / `IAsyncExceptionFilter` or `ExceptionFilterAttribute` and are used to apply
    exception handling to the code before the response is written.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常过滤器**：这些过滤器是`IExceptionFilter` / `IAsyncExceptionFilter`或`ExceptionFilterAttribute`的实现，并用于在写入响应之前对代码应用异常处理。'
- en: '**Result filters**: These are the implementation of `IResultFilter` / `IAsyncResultFilter`
    or `ResultFilterAttribute` and are run immediately before and after the execution
    of individual action results. They are run only if the action method successfully
    executes.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果过滤器**：这些是`IResultFilter` / `IAsyncResultFilter`或`ResultFilterAttribute`的实现，并且在执行单个动作结果前后立即运行。只有在动作方法成功执行时才会运行。'
- en: 'If we look closely, we can notice that there are multiple ways to implement
    the filter. There is filter interface, then there is async filter interface, and
    we have abstract attribute classes that we can implement. The framework first
    checks if the filter implements an async interface. If it does, it calls the async
    methods of the filter. If not, it calls the non-async methods, so either an async
    or synchronous interface should be implemented. If we implement both, only the
    async implementation would be called. This is also the case when we implement
    the abstract class. To summarize, the following is what the filter pipeline looks
    like:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察，会发现实现过滤器有多种方式。有过滤器接口，然后有异步过滤器接口，我们还有可以实现的抽象属性类。框架首先检查过滤器是否实现了异步接口。如果实现了，它将调用过滤器的异步方法。如果没有实现，它将调用非异步方法，因此应该实现异步或同步接口。如果我们同时实现两者，只有异步实现会被调用。在实现抽象类时也是如此。总结一下，过滤器管道看起来如下所示：
- en: '![](img/070d624a-8144-444e-b977-1debf8274afb.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/070d624a-8144-444e-b977-1debf8274afb.png)'
- en: We should write our custom filters based on the preceding flow, so that the
    desired operation code can be written at the right place in the filter pipeline.
    Next, we will see an implementation of the sample filter and different ways to
    implement a filter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该根据前面的流程编写我们的自定义过滤器，以便在过滤器管道中的正确位置编写所需的操作代码。接下来，我们将看到示例过滤器的实现以及实现过滤器的方法。
- en: 'Derive from `Attribute` and implement `IActionFilter`—filters are implemented
    as attributes and hence we need to derive from `Attribute` and implement `IActionFilter`
    for the class to be treated as a filter:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Attribute`派生并实现`IActionFilter`——过滤器作为属性实现，因此我们需要从`Attribute`派生并实现`IActionFilter`，以便类被视为过滤器：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Derive from `ActionFilterAttribute`—the `ActionFilterAttribute` class already
    derives from the `Attribute` class and implements `IActionFilter` and hence we
    can directly derive from `ActionFilterAttribute` and create a filter attribute.
    So, the preceding code would remain the same apart from the base class and interface
    with which we need to derive:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ActionFilterAttribute`派生——`ActionFilterAttribute`类已经从`Attribute`类派生，并实现了`IActionFilter`接口，因此我们可以直接从`ActionFilterAttribute`派生并创建一个过滤器属性。所以，除了我们需要派生的基类和接口之外，前面的代码将保持不变：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are few other ways to define the action filters, but we will not discuss
    them here. They can be seen from the reference link shared towards the end of
    the section. Likewise, Exception filters can be created by deriving from `ExceptionFilterAttribute`,
    `ResultFilter` by deriving from `ResultFilterAttribute`, and so on.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 定义动作过滤器还有其他几种方法，但在这里我们不会讨论它们。它们可以在本节末尾共享的参考链接中看到。同样，可以通过从`ExceptionFilterAttribute`派生来创建异常过滤器，通过从`ResultFilterAttribute`派生来创建结果过滤器，等等。
- en: 'For consuming the filters, they can be registered globally in the `ConfigureServices`
    method in the `Startup.cs` or by decorating the filter attribute in the controller
    or action, which is shown as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用过滤器，它们可以在`Startup.cs`中的`ConfigureServices`方法中全局注册，或者通过在控制器或动作中装饰过滤器属性来实现，如下所示：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since the filters can be registered both globally and at action level also,
    a definite question comes to mind, which is: in what order do they execute? The
    answer is simple:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过滤器既可以在全局范围内注册，也可以在动作级别注册，因此自然会想到一个问题，那就是：它们以什么顺序执行？答案是简单的：
- en: The action executing method of global filters runs first, then of action executing
    methods of filters registered at controller runs, and finally action executing
    methods of filters registered at action level.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全球过滤器的执行动作方法首先运行，然后是控制器中注册的过滤器的执行动作方法，最后是动作级别注册的过滤器的执行动作方法。
- en: While returning from action, the order is the other way round. The action executed
    method of filter registered at action level runs first, then action executed method
    of filter registered at controller level, and finally the action executed method
    of filter registered globally.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从动作返回时，顺序是相反的。首先运行在动作级别注册的过滤器已执行的动作方法，然后是控制器级别注册的过滤器已执行的动作方法，最后是全球范围内注册的过滤器已执行的动作方法。
- en: This is also referred to as Nesting Doll or Russian Doll model.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也被称为嵌套娃娃或俄罗斯娃娃模型。
- en: This is the default behaviour. ASP.NET Core provides a way to override the default
    order of execution by implementing `IOrderedFilter`, which exposes an `Order`
    property, specifying which can override the default order of execution.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是默认行为。ASP.NET Core提供了一种通过实现`IOrderedFilter`来覆盖默认执行顺序的方法，该接口公开了一个`Order`属性，指定了可以覆盖默认执行顺序。
- en: For a detailed and thorough discussion on filters, please read the documentation
    of filter at: [https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters](https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关于过滤器的一个详细和全面的讨论，请参阅过滤器文档：[https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters](https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters).
- en: 'With this note, we will move on to our next topic: Controllers.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个说明，我们将继续讨论下一个主题：控制器。
- en: Controllers
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: 'Broadly speaking, a controller is a class with a group of methods called actions.
    An action, also known as an action method, is a method that handles the request.
    As per the convention used by the ASP.NET Core MVC framework, a controller is
    a class that:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从广义上讲，控制器是一个包含一组称为动作的方法的类。动作，也称为动作方法，是一个处理请求的方法。根据ASP.NET Core MVC框架使用的约定，控制器是一个类，它：
- en: Is instantiable; that is, an instance of that class can be created
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可实例化；也就是说，可以创建该类的实例
- en: Resides in the project's root-level folder, named `Controllers`
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位于项目的根级文件夹中，命名为`Controllers`
- en: Inherits from an abstract class, `Microsoft.AspNetCore.Mvc.Controller`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承自抽象类，`Microsoft.AspNetCore.Mvc.Controller`
- en: 'The framework is flexible and would also treat an instantiable class as a controller
    if any one or more of the following holds good:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 框架很灵活，如果以下任何一个或多个条件成立，它也会将可实例化的类视为控制器：
- en: The class is decorated with the `[Controller]` attribute
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类被`[Controller]`属性装饰
- en: The class name is suffixed with `Controller`, such as `HomeController`
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名以`Controller`结尾，例如`HomeController`
- en: The class derives from a class, whose name ends with `Controller`
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类派生自一个以`Controller`结尾的类
- en: 'An important thing to note here is that we have a controller defined, even
    if we do not derive our controller from the `Controller` class. As discussed earlier,
    the role of a controller is to validate the request data and return the result
    in the form of a View or data. In the ASP.NET Core MVC project structure, we can
    see a `Controllers` folder at the project root level, as shown here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个重要事项是，即使我们没有从 `Controller` 类派生我们的控制器，我们仍然有一个控制器定义。如前所述，控制器的作用是验证请求数据并以视图或数据的形式返回结果。在
    ASP.NET Core MVC 项目结构中，我们可以在项目根级别看到一个 `Controllers` 文件夹，如下所示：
- en: '![](img/1351f77d-3710-4989-ad96-98ae345c4d60.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1351f77d-3710-4989-ad96-98ae345c4d60.png)'
- en: 'Let''s have a look at the code map diagram of the `Controller` class to understand
    it better:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Controller` 类的代码映射图，以更好地理解它：
- en: '![](img/23bfd90e-9b99-4e1c-8433-d7b3d455d99e.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23bfd90e-9b99-4e1c-8433-d7b3d455d99e.png)'
- en: 'The diagram reveals that the `Controller` class itself derives from the `ControllerBase`
    class, by which it gets access to `HttpContext` and `ControllerContext` properties.
    It has properties for `TempData`, `ViewData`, and `ViewBag`, which we will discuss
    when we discuss the Views in the next chapter. The class contains a bunch of methods,
    mostly for returning action results and executing action filters. Let''s have
    a look at them:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示 `Controller` 类本身是从 `ControllerBase` 类派生的，通过这种方式，它获得了对 `HttpContext` 和 `ControllerContext`
    属性的访问权限。它具有 `TempData`、`ViewData` 和 `ViewBag` 属性，我们将在下一章讨论视图时讨论这些属性。该类包含许多方法，主要用于返回操作结果和执行操作过滤器。让我们看看它们：
- en: '`PartialView`: Creates a `Microsoft.AspNetCore.Mvc.PartialViewResult` object
    that renders a partial View to the response'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PartialView`: 创建一个 `Microsoft.AspNetCore.Mvc.PartialViewResult` 对象，用于将部分视图渲染到响应中'
- en: '`View`: Creates a `Microsoft.AspNetCore.Mvc.ViewResult` object that renders
    a View to the response'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View`: 创建一个 `Microsoft.AspNetCore.Mvc.ViewResult` 对象，用于将视图渲染到响应中'
- en: '`Json`: Creates a `Microsoft.AspNetCore.Mvc.JsonResult` object that serializes
    the data to JSON'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Json`: 创建一个 `Microsoft.AspNetCore.Mvc.JsonResult` 对象，将数据序列化为 JSON'
- en: '`ViewComponent`: Creates a `Microsoft.AspNetCore.Mvc.ViewComponentResult` by
    specifying the name of a View component to render'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewComponent`: 通过指定要渲染的视图组件的名称来创建一个 `Microsoft.AspNetCore.Mvc.ViewComponentResult`'
- en: '`OnActionExecuting`: Called before the action method is invoked'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnActionExecuting`: 在调用操作方法之前被调用'
- en: '`OnActionExecuted`: Called after the action method is invoked'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnActionExecuted`: 在调用操作方法之后被调用'
- en: '`OnActionExecutionAsync`: Called before the action method is invoked in an
    async implementation'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnActionExecutionAsync`: 在异步实现中调用操作方法之前被调用'
- en: Not all methods defined in the `Controller` class are actions. Only `public`
    methods which are not decorated with the `[NonAction]` attribute are actions.
    An action method can return anything, but generally, we will see them return an
    instance of `IActionResult` (or `Task<IActionResult>` for `async` methods). An
    action method decides the kind of response it would return; it may be a View or
    formatted response data, such as JSON, or anything else.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Controller` 类中定义的所有方法并不都是操作。只有被标记为 `public` 且没有使用 `[NonAction]` 属性装饰的方法才是操作。一个操作方法可以返回任何内容，但通常我们会看到它们返回
    `IActionResult` 的实例（对于异步方法则是 `Task<IActionResult>`）。操作方法决定它将返回哪种类型的响应；它可能是一个视图或格式化的响应数据，例如
    JSON，或者任何其他内容。
- en: With the intent of separation of concerns and loose coupling, the `Controller`
    class should always have the dependencies injected to it, rather than creating
    the instance of it. If a type or service is required for only one action method,
    we can use the injection of a service directly in the action by using the `[FromServices]`
    attribute that we saw earlier; otherwise, the construction injection should be
    used.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现关注点分离和松散耦合，`Controller` 类应该始终注入依赖项，而不是创建其实例。如果一个类型或服务只用于一个操作方法，我们可以使用之前提到的
    `[FromServices]` 属性直接在操作中注入服务；否则，应使用构造函数注入。
- en: We will end our lap around MVC with an overview of error handling.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在对 MVC 的回顾中结束，概述错误处理。
- en: Error handling
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: Error handling is a particularly important piece in any reliable and stable
    software application, and ASP.NET Core applications are no different. The error
    handling strategy differs while the app is under development and when it is deployed.
    While developing, the developer wants to see highly detailed error messages so
    that he/she can go to the crux of the issue and fix it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是任何可靠和稳定软件应用程序中特别重要的一个环节，ASP.NET Core应用程序也不例外。错误处理策略在应用程序开发期间和部署时有所不同。在开发期间，开发者希望看到高度详细错误消息，以便他们可以深入问题核心并修复它。
- en: However, such a level of detailing would not be great in production as the end
    user would not understand any of that and it would give hackers too much information,
    which they could utilize to compromise your app. Also, the end user would rather
    appreciate a user-friendly message than some stack trace, which would be Greek
    to them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在生产环境中，这种详细程度可能并不理想，因为最终用户不会理解任何这些，并且会给黑客提供太多信息，他们可以利用这些信息来破坏您的应用程序。此外，最终用户更可能欣赏一个友好的消息，而不是一些对他们来说像是希腊文的堆栈跟踪。
- en: So, we display a developer exception page in the development environment and
    a more user-friendly error screen in the production environment. The old school
    ASP.NET programmers may be able to link this to the custom errors flag in the
    ancient versions of ASP.NET. Let's see how we can configure these pages.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在开发环境中显示开发者异常页面，在生产环境中显示更友好的错误屏幕。老式的ASP.NET程序员可能能够将此与ASP.NET古老版本中的自定义错误标志联系起来。让我们看看我们如何配置这些页面。
- en: 'To configure an app to display an error page to display the detailed exception,
    we need to have the `Microsoft.AspNetCore.Diagnostics` namespace. We need to add
    the following code in our `Configure` method of `Startup.cs`. Notice that this
    should be added before adding any other middleware, so that all the exceptions
    from the subsequently executed middleware are caught:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置应用程序以显示错误页面来显示详细的异常，我们需要有`Microsoft.AspNetCore.Diagnostics`命名空间。我们需要在`Startup.cs`的`Configure`方法中添加以下代码。请注意，这应该在添加任何其他中间件之前添加，以便捕获随后执行的中间件的所有异常：
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In case of an exception in the development environment, the developer exception
    page would be displayed, as shown in the following screenshot. I used the classical
    and easiest code to simulate the exception here—`divide by zero`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发环境中发生异常时，会显示开发者异常页面，如下截图所示。我在这里使用经典的、最简单的代码来模拟异常——`除以零`：
- en: '![](img/c58bfc06-3678-4b93-992f-3bc29c8a79b3.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c58bfc06-3678-4b93-992f-3bc29c8a79b3.jpg)'
- en: 'Notice that it has four tabs:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它有四个标签页：
- en: 'Stack: Displays the stack trace of the error'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stack：显示错误的堆栈跟踪
- en: 'Query: Displays the query string of the request'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Query：显示请求的查询字符串
- en: 'Cookies: Displays the cookies associated with a request, if any'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookies：显示与请求关联的cookie（如果有）
- en: 'Headers: Displays the header of the request, as shown in the following screenshot:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Headers：显示请求的头部，如下截图所示：
- en: '![](img/0d46657e-c83a-44bb-9b13-d0b64c59e32a.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d46657e-c83a-44bb-9b13-d0b64c59e32a.jpg)'
- en: 'In a non-development environment, we will see a generic error page, as shown
    in the following screenshot:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在非开发环境中，我们将看到一个通用错误页面，如下截图所示：
- en: '![](img/4d8afb44-70f1-431a-98be-b1c8693d1359.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d8afb44-70f1-431a-98be-b1c8693d1359.jpg)'
- en: Please note, an error in an error page can also throw an exception, which, if
    not properly handled, can crash your app. So, we should try and keep the error
    page content static.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，错误页面中的错误也可能抛出异常，如果不正确处理，可能会使您的应用程序崩溃。因此，我们应该尽量保持错误页面内容静态。
- en: If any exceptions occur during the app startup, they can only be handled in
    the hosting layer. When the error occurs after the host address / port binding,
    hosting can only show an error page for such captured startup errors. If any port/address
    binding fails for any reason, such as the address/port is already in use, the
    hosting layer logs a critical exception, the dotnet process crashes, and no error
    page is displayed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在应用程序启动过程中发生任何异常，它们只能在托管层中处理。当错误在主机地址/端口绑定之后发生时，托管层只能显示一个错误页面来捕获此类启动错误。如果由于任何原因（例如地址/端口已被占用）导致端口/地址绑定失败，托管层将记录一个关键异常，dotnet进程崩溃，并且不会显示错误页面。
- en: MVC error handling continues to work as it does, by using exception filters
    for exceptions and Model validations for validation failures. We have already
    seen these in our quick lap around MVC. We have one more important component of
    MVC, the visual element, Views, to discuss. We will discuss this when we do the
    implementation of our chat UI and Chat hub in the next chapter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: MVC错误处理继续按原样工作，通过使用异常过滤器处理异常和模型验证处理验证失败。我们已经在我们的MVC快速浏览中看到了这些。MVC还有一个重要的组件，即视图元素，我们需要讨论。我们将在下一章实现我们的聊天UI和聊天中心时进行讨论。
- en: This wraps up our quick lap around MVC. With all the fundamentals in place,
    we are now ready to dive into coding. We will begin by implementing authentication
    in our application, which we will do in the following section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对MVC的快速浏览。随着所有基础知识的建立，我们现在可以开始编码了。我们将从在应用程序中实现身份验证开始，这将在下一节中完成。
- en: Implementing authentication through Facebook
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Facebook实现身份验证
- en: 'Enough of the theory and samples. Time for us to convert the requirements into
    reality. We will start with the authentication module first. Recall that based
    on our discussion in the last chapter, this module needs to support a secure login,
    a forgotten password, as well as register user functionality. Once we are done
    with it, we will have completed a substantial part of our app, as per the following
    flowchart:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 理论和示例已经足够。现在是时候将需求转化为现实了。我们将首先从身份验证模块开始。回想一下，根据我们在上一章的讨论，这个模块需要支持安全登录、忘记密码以及注册用户功能。一旦我们完成它，我们将完成我们应用程序的大部分工作，如下面的流程图所示：
- en: '![](img/b1bb9f70-958e-48a4-8d49-ac00b2986611.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1bb9f70-958e-48a4-8d49-ac00b2986611.jpg)'
- en: 'We are going to leverage Facebook authentication to implement this module of
    our system. We could have used any of the other providers as well, such as Twitter,
    Google, Microsoft, and so on, but since it''s a fun chat app, Facebook is most
    appropriate. In [Chapter 7](ch07.html), *To the Cloud*, we will see how we can
    support multiple authentication providers and let the user decide which provider
    they wish to use for authentication. To code this module, we will perform the
    following steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用Facebook身份验证来实现我们系统的这个模块。我们也可以使用其他任何提供者，例如Twitter、Google、Microsoft等，但由于这是一个有趣的聊天应用程序，Facebook是最合适的。在[第7章](ch07.html)“云服务”中，我们将看到如何支持多个身份验证提供者，并让用户决定他们希望使用哪个提供者进行身份验证。为了编写这个模块，我们将执行以下步骤：
- en: 'To integrate Facebook with our app, we first need to create a Facebook App
    ID. So, go to [https://developers.facebook.com/apps/](https://developers.facebook.com/apps/)
    and click on Add a New App button. Please note, this requires us to sign in to
    our Facebook account, so you need to have a Facebook account to do this activity.
    If you don''t have a Facebook account, please create one. On clicking the button,
    the following screen will display:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将Facebook集成到我们的应用程序中，我们首先需要创建一个Facebook应用程序ID。因此，请访问[https://developers.facebook.com/apps/](https://developers.facebook.com/apps/)并点击“添加新应用”按钮。请注意，这需要我们登录到我们的Facebook账户，因此您需要有一个Facebook账户才能进行此活动。如果您没有Facebook账户，请创建一个。点击按钮后，将显示以下屏幕：
- en: '![](img/f5797887-6ce3-4378-9f47-cd93290de721.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f5797887-6ce3-4378-9f47-cd93290de721.png)'
- en: 'Enter Display Name and Contact Email, and click on the Create App ID button.
    It will display a **Completely Automated Public Turing Test to tell Computers
    and Humans A****part** (**CAPTCHA**) verification page. On successful verification,
    the App ID will get created and a products page will be displayed, as shown in
    the following screenshot:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入显示名称和联系电子邮件，然后点击“创建应用程序ID”按钮。它将显示一个**完全自动化的公共图灵测试，以区分计算机和人类**（CAPTCHA）验证页面。验证成功后，应用程序ID将被创建，并显示产品页面，如下面的截图所示：
- en: '![](img/94a8758d-0f66-4af1-b495-ce8420df401d.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94a8758d-0f66-4af1-b495-ce8420df401d.png)'
- en: 'We need to choose Facebook Login, so click on the Setup button, which will
    display when we hover over Facebook Login. On clicking Setup, Facebook will display
    a select platform page, as shown in the following screenshot:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要选择Facebook登录，因此点击鼠标悬停在Facebook登录上时显示的“设置”按钮。点击设置后，Facebook将显示一个选择平台页面，如下面的截图所示：
- en: '![](img/32ddd279-1c18-4a19-b3d6-6fde3fad3225.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32ddd279-1c18-4a19-b3d6-6fde3fad3225.png)'
- en: 'Choose Web and then enter the website URL in the next screen. This is the URL
    of your web app. Once we run our app using Visual Studio or `dotnet run`, we can
    see the URL (or we will directly see `launchSettings.json` or project properties).
    Copy the URL and paste it in the Site URL field, as shown in the following screenshot:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“Web”，然后在下一屏幕中输入网站 URL。这是您的 Web 应用的 URL。一旦我们使用 Visual Studio 或 `dotnet run`
    运行我们的应用，我们就可以看到 URL（或者我们将直接看到 `launchSettings.json` 或项目属性）。复制 URL 并将其粘贴到以下截图所示的“站点
    URL”字段中：
- en: '![](img/1e84a9ec-d148-4705-907d-5c90748a1590.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e84a9ec-d148-4705-907d-5c90748a1590.png)'
- en: 'Click the Save button. Now, click on the Facebook Login on the left navigation
    panel in the PRODUCTS section and make the following selections:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“保存”按钮。现在，在“产品”部分的左侧导航面板中点击“Facebook 登录”并做出以下选择：
- en: '![](img/47716981-1afa-46c3-b5dd-5f725ed1763f.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47716981-1afa-46c3-b5dd-5f725ed1763f.png)'
- en: 'OAuth redirect URIs should be correct; otherwise, the flow will not work. There
    is no point in putting the lock on the door and keeping the key alongside, similarly,
    there is no point in using authentication and using an HTTP protocol for OAuth.
    The URI should be using an HTTPS protocol. This is a demo app, so I have used
    the HTTP protocol. However, for any non-demo app, we should always use HTTPS.
    We can provide multiple URLs in the OAuth redirect URIs, so once we publish the
    app to Azure, we would need to add one more URL here. With this, our Facebook
    app is set up. We need an App ID and App Secret, which we will copy by navigating
    to the Dashboard of the app we just created. This can be done by clicking on the
    Dashboard in the left-hand side navigation. Copy the App ID and App Secret in
    a notepad for our use:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 重定向 URI 应该是正确的；否则，流程将不会工作。把锁放在门上，钥匙放在旁边，同样地，使用身份验证和使用 HTTP 协议进行 OAuth
    没有意义。URI 应该使用 HTTPS 协议。这是一个演示应用，所以我使用了 HTTP 协议。然而，对于任何非演示应用，我们始终应该使用 HTTPS。我们可以在
    OAuth 重定向 URI 中提供多个 URL，因此一旦我们将应用发布到 Azure，我们还需要在这里添加另一个 URL。这样，我们的 Facebook 应用就设置好了。我们需要一个
    App ID 和 App Secret，我们将通过导航到我们刚刚创建的应用仪表板来复制它们。这可以通过点击左侧导航中的“仪表板”来完成。将 App ID 和
    App Secret 复制到记事本中供我们使用：
- en: '![](img/bd67a454-4d6b-4556-ad14-06feff1934cd.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd67a454-4d6b-4556-ad14-06feff1934cd.png)'
- en: With this, we are done with the app setup in Facebook. We will come back to
    the portal again when we make our app public and publish it to Azure. For now,
    we will start coding. As discussed earlier, we will make use of middleware to
    perform authentication. The pattern to use middleware is also very simple. First,
    add the middleware in the `ConfigureServices` method and then use it in the `Configure`
    method of `Startup.cs`. The framework takes care of most of the heavy lifting,
    so the coding part is quite simple as well, as we will see.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些设置，我们在 Facebook 中的应用设置就完成了。当我们使我们的应用公开并发布到 Azure 时，我们还将再次回到这个门户。现在，我们将开始编码。如前所述，我们将使用中间件来执行身份验证。使用中间件的模式也非常简单。首先，在
    `ConfigureServices` 方法中添加中间件，然后在 `Startup.cs` 的 `Configure` 方法中使用它。框架负责大部分繁重的工作，因此编码部分也很简单，正如我们将看到的。
- en: 'We will use Facebook and cookie authentication. To use them, we add the following
    using directives in `Startup.cs`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 Facebook 和 cookie 身份验证。为了使用它们，我们在 `Startup.cs` 中添加以下使用指令：
- en: '[PRE15]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We need to use the App ID and App Secret to integrate Facebook authentication
    with our web app. To do so, we need to read the values of the App ID and App Secret.
    This can be done through reading from the `appsettings.json` or from the User
    Secret Manager tool in development. Essentially, these secrets should be kept
    way from the application code and real apps deployed on Azure should be fetched
    from the Azure Key-vault. We will use the User Secret Manager tool as well as
    Key-vault in [Chapter 7](ch07.html), *To the Cloud*. For the sake of simplicity,
    in this demo, we will make use of `asppsettings.json` to read these values (though
    its not recommended for actual systems), as shown here:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用 App ID 和 App Secret 将 Facebook 身份验证集成到我们的 Web 应用中。为此，我们需要读取 App ID 和
    App Secret 的值。这可以通过从 `appsettings.json` 读取或从开发中的用户密钥管理器工具中读取来完成。本质上，这些密钥应该远离应用程序代码，并且部署在
    Azure 上的真实应用应该从 Azure 密钥保管库中获取。我们将在第 7 章[**云之旅**](ch07.html)中使用用户密钥管理器工具以及密钥保管库。为了简单起见，在这个演示中，我们将使用
    `appsettings.json` 来读取这些值（尽管不推荐在实际系统中使用），如下所示：
- en: '[PRE16]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `ConfigureServices` method of `Startup.cs`, we will write the following
    lines of code to add the authentication middleware and read the App ID and App
    Secret from configuration, by using the following code:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Startup.cs`的`ConfigureServices`方法中，我们将编写以下代码行以添加认证中间件并从配置中读取App ID和App Secret，如下所示：
- en: '[PRE17]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The comments make it very clear that we would challenge the user through Facebook
    and sign in using cookie authentication. We have configured Facebook to use the
    App ID and App Secret from the `appsettings` and also added cookie authentication.
    Also, to keep the application secure, it''s highly recommended that we always
    enforce SSL; that is, use HTTPS. We can do so with the following line of code,
    while adding MVC:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注释清楚地表明，我们将通过Facebook进行挑战并通过cookie认证进行登录。我们已经配置了Facebook使用`appsettings`中的App
    ID和App Secret，并添加了cookie认证。为了保持应用程序的安全，强烈建议我们始终强制执行SSL；也就是说，使用HTTPS。我们可以在添加MVC时使用以下代码行来实现：
- en: '[PRE18]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `Configure` method of `Startup.cs`, write the following code between
    `app.UseStaticFiles` and `app.UseMvc`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Startup.cs`的`Configure`方法中，在`app.UseStaticFiles`和`app.UseMvc`之间编写以下代码：
- en: '[PRE19]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This ordering is important and will ensure that static resources, such as `js`,
    `css`, and `image` files, will not have to go through authentication. They would
    be served without authentication, while before any other page access request or
    authentication can kick in. If we run the app now, the authentication would still
    not kick in. We need to decorate the controller/controller action(s) with the `[Authorize]`
    attribute, which we only want the authenticated user to access. We can also configure
    this at the global level. We saw the sample for this in the last chapter.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这种排序很重要，将确保静态资源，如`js`、`css`和`image`文件，无需经过认证。它们将无需认证提供服务，而在任何其他页面访问请求或认证启动之前。如果我们现在运行应用程序，认证仍然不会启动。我们需要使用`[Authorize]`属性装饰控制器/控制器操作，我们只想让认证用户访问。我们也可以在全局范围内进行配置。我们在上一章中看到了这个示例。
- en: 'We will decorate the `Index` action of `HomeController` with the `[Authorize]`
    attribute, so that we can challenge the user if he/she is not logged in, as shown
    here:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`[Authorize]`属性装饰`HomeController`的`Index`操作，这样我们就可以在用户未登录时对其进行挑战，如下所示：
- en: '[PRE20]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, if we run the app and we have followed all the steps correctly so far,
    we will see the Facebook login page, as shown here:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行应用程序并且我们已经正确地遵循了所有步骤，我们将看到Facebook登录页面，如下所示：
- en: '![](img/941efabe-d5a8-4496-95d9-01bd8da0e2ab.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/941efabe-d5a8-4496-95d9-01bd8da0e2ab.png)'
- en: 'It will also ask for permission to use the user profile, as shown here:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会要求使用用户资料的权限，如下所示：
- en: '![](img/548325e0-2d3b-4a35-8756-75389b3231ac.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/548325e0-2d3b-4a35-8756-75389b3231ac.png)'
- en: Click on Continue as `<your name>` and we will be navigated to the `Index` page.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 点击继续作为`<your name>`，我们将被导航到`Index`页面。
- en: 'It''s not a scaleable model to put `[Authorize]` on every controller as it
    is susceptible to mistakes. New developers adding a new controller may forget
    to do so and it may not be caught unless someone browses the URL for that controller,
    so it is recommended that we configure authentication in the `ConfigureServices`
    method of `Startup.cs`, as shown here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 将`[Authorize]`放在每个控制器上不是一个可扩展的模型，因为它容易出错。新加入的开发者添加新控制器时可能会忘记这样做，除非有人浏览该控制器的URL，否则可能不会被捕获，因此建议我们在`Startup.cs`的`ConfigureServices`方法中配置认证，如下所示：
- en: '[PRE21]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After applying this policy, wherever we need non-authenticated access, we can
    insert the `[AllowAnonymous]` attribute. This is safer from a security perspective.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 应用此策略后，无论何时我们需要非认证访问，我们都可以插入`[AllowAnonymous]`属性。这在安全方面更为可靠。
- en: 'Now, we have a working login, with the option to register a user as well the
    provision to reset the password, if the user forgot it, without doing any custom
    coding. We can safely rely on Facebook to take care of this stuff. We will wrap
    up this module by seeing how we can do an explicit sign in and sign out, so that
    if we wish to sign out or sign in explicitly by clicking on a link or button,
    we can handle it. To do so, we will add a new controller called `AuthenticationController`
    with two actions, `SignIn` and `SignOut`, as shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个可以工作的登录界面，其中包括注册用户以及重置密码的选项，如果用户忘记了密码，而无需进行任何自定义编码。我们可以安全地依赖Facebook来处理这些事情。我们将通过查看如何进行显式登录和注销来结束本模块，这样如果我们希望通过点击链接或按钮显式地注销或登录，我们就可以处理它。为此，我们将添加一个新的控制器`AuthenticationController`，包含两个操作`SignIn`和`SignOut`，如下所示：
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The code is simple but an explanation is important, as we have used a lot of
    things here:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单，但解释很重要，因为我们在这里使用了很多东西：
- en: We have used attribute routing at the controller level, by using the `[Route("authentication")]`
    attribute. This may seem unnecessary as its name is the same as that of the controller,
    but the intent is to demonstrate how the `Route` attribute is used at a controller
    level. Had we used `[Route("auth")]`, all requests to `/auth/` would redirect
    to this controller.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在控制器级别使用了基于属性的路由，通过使用`[Route("authentication")]`属性。这看起来可能是不必要的，因为它的名称与控制器相同，但目的是展示如何在控制器级别使用`Route`属性。如果我们使用了`[Route("auth")]`，那么所有对`/auth/`的请求都会重定向到这个控制器。
- en: Next, we see that the `AuthenticationController` derives from the `Controller`
    class. This is mandatory when we create any controller; it should derive from
    the `Controller` class. We can have it derive from some other class, say `BaseController`,
    but then `BaseController` should derive from the `Controller` class.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们看到`AuthenticationController`继承自`Controller`类。当我们创建任何控制器时，这是强制性的；它应该继承自`Controller`类。我们也可以让它继承自其他类，比如`BaseController`，但此时`BaseController`也应该继承自`Controller`类。
- en: Next, we see we have a field of type `ILogger<AuthenticationController>` called
    `logger`, which would be used to do the logging with the `AuthenticationController`
    as the category.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们看到我们有一个名为`logger`的字段，其类型为`ILogger<AuthenticationController>`，它将用于以`AuthenticationController`作为分类进行日志记录。
- en: Then, we have the constructor for the `AuthenticationController`. This takes
    in a dependency of `ILogger<AuthenticationController>`, which is injected by default
    by the framework. This demonstrates DI.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有`AuthenticationController`的构造函数。它接受一个`ILogger<AuthenticationController>`依赖项，该依赖项默认由框架注入。这展示了依赖注入（DI）的概念。
- en: There is an action created with the name `SignIn`. Note that it also uses attribute
    routing, as it's decorated with `[Route("signin")]`. The return type of this action
    is `IActionResult`. As is evident, the first line of action is for logging the
    information. The important thing in this action is that its returns a `ChallengeResult`,
    taking in the `AuthenticationProperties` as the parameter. It's important to set
    the `RedirectUri` as it is responsible for redirecting the page to the appropriate
    page after authentication. `ChallengeResult` would use the configured challenge
    scheme, Facebook, in this case.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个名为`SignIn`的操作。请注意，它也使用了基于属性的路由，因为它被装饰了`[Route("signin")]`。这个操作的返回类型是`IActionResult`。如所明显，操作的第一个行是用于记录信息的。在这个操作中，重要的是它返回一个`ChallengeResult`，该结果接受`AuthenticationProperties`作为参数。设置`RedirectUri`很重要，因为它负责在认证后重定向页面到适当的页面。`ChallengeResult`将使用配置的挑战方案，在这个例子中是Facebook。
- en: The last action is `SignOut`. Again, it uses attributebased routing. It would
    be served when a `POST` request comes as it is decorated with the `[HttpPost]`
    attribute. We also note the `async` keyword to demonstrate that we can have `async`
    controller actions. It uses the `SignOutAsync` method of `HttpContext` and signs
    out using the cookie authentication scheme. Post sign out, it redirects the user
    to the `Index` action of the `Home` controller. If the `Index` action of the `Home`
    controller has the `[Authorize]` attribute applied, it may take the user to the
    login screen and if cookies are not cleared from the browser, you may have the
    user logged back in.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个操作是`SignOut`。同样，它使用基于属性的路由。当收到带有`[HttpPost]`属性的`POST`请求时，它会被提供服务。我们还注意到`async`关键字，以展示我们可以有异步控制器操作。它使用`HttpContext`的`SignOutAsync`方法，并通过cookie认证方案进行登出。登出后，它将用户重定向到`Home`控制器的`Index`操作。如果`Home`控制器的`Index`操作应用了`[Authorize]`属性，它可能会将用户带到登录界面，并且如果浏览器中没有清除cookie，用户可能会被重新登录。
- en: 'In the View, we will do the following. If the user is not signed in, show him
    the `Sign In` button, or show him the `Sign Out` button. This can be done easily
    in the `_Layout.cshtml` by the writing the following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图（View）中，我们将执行以下操作。如果用户未登录，则显示“`登录`”按钮，或者显示“`登出`”按钮。这可以通过在`_Layout.cshtml`中编写以下代码轻松完成：
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By doing this in `_Layout.cshtml`, we ensure this functionality is common across
    all the pages. The `@prefix` on Razor tells the RazorEngine that it is C# code.
    We first check if the user is authenticated; if yes, `User.Identity.IsAuthenticated`
    would be `true`. Inside this condition, we display the `Sign Out` button inside
    a `form` tag. The `form` tag is important, as we are doing a submit action on
    the `Sign Out` button, so on clicking it, the form would be posted to the server.
    This call should never ever be `HttpGet`. The `form` tag uses the `post` method
    and uses tag helpers to specify the controller and action as `Authentication`
    and `SignOut`, respectively.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `_Layout.cshtml` 中这样做，我们确保了这种功能在所有页面上都是通用的。Razor 中的 `@prefix` 告诉 RazorEngine
    这是一个 C# 代码。我们首先检查用户是否已认证；如果是，`User.Identity.IsAuthenticated` 将为 `true`。在这个条件内部，我们在
    `form` 标签内显示 `Sign Out` 按钮。`form` 标签很重要，因为我们正在对 `Sign Out` 按钮执行提交操作，所以点击它时，表单将被提交到服务器。这个调用永远不应该使用
    `HttpGet`。`form` 标签使用 `post` 方法，并使用标签助手分别指定控制器和操作为 `Authentication` 和 `SignOut`。
- en: 'HTTP method definitions ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html))
    recommend the usage of `HttpPost` methods over `HttpGet` methods for security
    reasons ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3](https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3)),
    when the data is being submitted to the server, as per the following excerpt:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 方法定义（[https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)）建议出于安全原因，在将数据提交到服务器时，使用
    `HttpPost` 方法而不是 `HttpGet` 方法（[https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3](https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3)），如下摘录所示：
- en: If your of services use the HTTP protocol, then you **SHOULD NOT** use `GET`-based
    forms for the submission of sensitive data. Otherwise, this will cause the data
    to be encoded in the Request-URI. The request URI will be logged somewhere by
    existing servers, proxies, and user agents, and it might be accessible to third
    parties. Servers can use `POST`-based form submission instead.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的服务使用 HTTP 协议，那么你**不应该**使用基于 `GET` 的表单来提交敏感数据。否则，这将导致数据被编码在 Request-URI 中。请求
    URI 将由现有的服务器、代理和用户代理记录在某个地方，并且可能被第三方访问。服务器可以使用基于 `POST` 的表单提交代替。
- en: This completes our authentication module, and we are ready to develop the SignalR
    Chat hub module.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的认证模块，我们现在可以开始开发 SignalR 聊天中心模块。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we brushed up on the fundamentals of MVC and looked at the
    features of ASP.NET Core MVC. Post learning the fundamentals, we developed the
    authentication module for our Let's Chat app using Facebook. We checked that we
    can log in, sign out, register a new user, as well as reset the password, using
    the work already done by Facebook, with minimal lines of code in our ASP.NET Core
    2.0 app. In the next chapter, we will develop the SignalR Chat hub module and
    complete the Let's Chat web app. We will also learn about unit testing and deployment
    for the ASP.NET Core 2.0 app.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们复习了 MVC 的基础知识，并探讨了 ASP.NET Core MVC 的特性。在学习基础知识之后，我们使用 Facebook 开发了 Let's
    Chat 应用程序的认证模块。我们检查了是否可以使用 Facebook 完成的功能进行登录、注销、注册新用户以及重置密码，在我们的 ASP.NET Core
    2.0 应用程序中仅用最少的代码行。在下一章中，我们将开发 SignalR 聊天中心模块并完成 Let's Chat 网络应用程序。我们还将学习 ASP.NET
    Core 2.0 应用程序的单元测试和部署。
