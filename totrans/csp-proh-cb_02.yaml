- en: Chapter 2. Classes and Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 类和泛型
- en: 'Classes form the building blocks of software development and are essential
    in building good code. In this chapter, we will be looking at classes and generics
    and why we need to use them. The recipes we will be covering are going to be as
    follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类是软件开发的基础，对于编写良好的代码至关重要。在本章中，我们将探讨类和泛型以及为什么我们需要使用它们。我们将涵盖的食谱如下：
- en: Creating and implementing an abstract class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和实现一个抽象类
- en: Creating and implementing an interface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和实现一个接口
- en: Creating and using a generic class or method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用泛型类或方法
- en: Creating and using a generic interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用泛型接口
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: As you probably know, classes are simply containers for related methods and
    properties to describe some object in your software. An object is an instance
    of a specific class and, sometimes, mimics real-world things. When thinking of
    a car, you might create a vehicle class that contains certain attributes (properties)
    that all vehicles contain, such as automatic or manual transmission, wheel count
    (not all vehicles have only four wheels), or fuel type.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，类只是相关方法和属性的容器，用于描述软件中的某个对象。一个对象是特定类的实例，有时也模仿现实世界的事物。当你想到一辆车时，你可能会创建一个包含所有车辆都有的属性（属性）的车辆类，例如自动或手动变速箱、车轮数量（并非所有车辆都只有四个轮子），或燃料类型。
- en: When we create an instance of the vehicle class, we can create a car object,
    an SUV object, and so on. Here lies the power of classes, which is to describe
    the world around us and translate it into a programming language that a compiler
    can understand.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建车辆类的实例时，我们可以创建汽车对象、SUV对象等等。这就是类的力量所在，它描述了我们周围的世界，并将其转化为编译器可以理解的编程语言。
- en: Creating and implementing an abstract class
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和实现一个抽象类
- en: Many developers have heard about abstract classes, but their implementation
    is a mystery. How can you as a developer identify an abstract class and decide
    when to use one? The definition is quite a simple one actually. Once you understand
    this fundamental definition of an abstract class, when and why to use one becomes
    obvious.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者都听说过抽象类，但它们的实现却是个谜。作为开发者，你如何识别一个抽象类并决定何时使用它？实际上，定义相当简单。一旦你理解了抽象类的这个基本定义，何时以及为什么使用它就变得明显了。
- en: Imagine for a moment that you are developing an application that manages the
    animals in a cat sanctuary. The cat sanctuary rehabilitates lions, tigers, jaguars,
    leopards, cheetahs, pumas, and even domestic cats. The common noun that describes
    all these animals is the word *cat*. You can, therefore, safely assume that the
    abstraction of all these animals is a cat, and thus, this word identifies our
    abstract class. You would then create an abstract class called `Cat`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在开发一个管理猫舍中动物的应用程序。这个猫舍康复了狮子、老虎、美洲豹、豹、猎豹、美洲狮，甚至家猫。描述所有这些动物的共同名词是“猫”这个词。因此，你可以安全地假设所有这些动物的抽象是猫，因此这个词标识了我们的抽象类。然后，你会创建一个名为`Cat`的抽象类。
- en: However, you need to keep in mind that you will never ever create an instance
    of the abstract class `Cat`. All the classes that inherit from the abstract class
    also share some functionality. This means that you will create a `Lion` class
    and a `Tiger` class that inherit from the abstract class `Cat`. In other words,
    the inherited classes are a kind of cat. Both classes share functionality in the
    form of `Sleep()`, `Eat()`, `Hunt()`, and various other methods. In this way,
    we can ensure that inherited classes all contain this common functionality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你需要记住，你永远不会创建抽象类`Cat`的实例。从抽象类继承的所有类也共享一些功能。这意味着你会创建一个继承自抽象类`Cat`的`Lion`类和一个`Tiger`类。换句话说，继承的类是一种猫。这两个类以`Sleep()`、`Eat()`、`Hunt()`和许多其他方法的形式共享功能。这样，我们可以确保继承的类都包含这种共同的功能。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's go ahead and create our abstract class for cat. We will then use it to
    inherit from and create other objects to define different types of cats.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建我们的猫抽象类。然后我们将使用它来继承并创建其他对象，以定义不同类型的猫。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: In the Visual Studio **Solution Explorer**, right-click on the solution, click
    on **Add**, and then click on **New Project**. Select **Class Library** option
    to add a new class library project to your solution and call it `Chapter2`:![How
    to do it…](img/B05391_02_01.jpg)
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio **解决方案资源管理器**中，右键单击解决方案，单击**添加**，然后单击**新建项目**。选择**类库**选项将新的类库项目添加到您的解决方案中，并将其命名为`Chapter2`：![如何操作…](img/B05391_02_01.jpg)
- en: A class library project called `Chapter2` is added to your solution. Go ahead
    and right-click on the default class called `Class1.cs` that was added to your
    `Chapter2` project and rename it to `Recipes.cs`:![How to do it…](img/B05391_02_02.jpg)
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已将名为`Chapter2`的类库项目添加到您的解决方案中。请右键单击添加到您的`Chapter2`项目中的默认类`Class1.cs`，并将其重命名为`Recipes.cs`：![如何操作…](img/B05391_02_02.jpg)
- en: 'Once you have done this, your code should resemble the following code listing.
    You can see that the default class has been renamed to `Recipes` and that it exists
    in the `Chapter2` namespace:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，您的代码应类似于以下代码列表。您可以看到默认类已被重命名为`Recipes`，并且它存在于`Chapter2`命名空间中：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will now change the default class `Recipes` to an abstract class called
    `Cat`. To do this, add the `abstract` keyword to the class and change the name
    from `Recipes` to `Cat`. We are now ready to describe the `Cat` abstract class:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将默认类`Recipes`更改为名为`Cat`的抽象类。为此，将`abstract`关键字添加到类中，并将名称从`Recipes`更改为`Cat`。我们现在准备好描述`Cat`抽象类：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `abstract` keyword indicates to us that the object it is applied to has
    no implementation. When used in a class declaration, it basically tells the compiler
    that the class is to be used as a base class. This means that no instance of the
    class can be created. The only way in which implementation of the abstract class
    happens is when it is implemented by derived classes that inherit from the base
    class.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`abstract`关键字告诉我们，它所应用的对象没有实现。当在类声明中使用时，它基本上告诉编译器该类将用作基类。这意味着不能创建该类的实例。抽象类实现的唯一方式是当派生类从基类继承时实现它。'
- en: 'Add three methods to the abstract class called `Eat()`, `Hunt()`, and `Sleep()`.
    You will notice that these methods don''t contain a body (curly braces). This
    is because they have been defined as abstract. As with abstract classes, the abstract
    methods contained within the abstract class contain no implementation. These three
    methods basically describe functionality that is common to all cats. All cats
    must eat, hunt, and sleep. Therefore, to ensure that all classes that inherit
    from the `Cat` abstract class contain this functionality, it is added to the abstract
    class. These methods are then implemented in the derived classes, which we will
    see in the upcoming steps:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向名为`Eat()`、`Hunt()`和`Sleep()`的抽象类中添加三个方法。您会注意到这些方法不包含主体（花括号）。这是因为它们已被定义为抽象的。与抽象类一样，抽象类中包含的抽象方法不包含实现。这三个方法基本上描述了所有猫共有的功能。所有猫都必须进食、狩猎和睡眠。因此，为了确保从`Cat`抽象类继承的所有类都包含此功能，它被添加到抽象类中。然后，这些方法在派生类中实现，我们将在接下来的步骤中看到：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We want to define two types of cat. The first type of cat we want to define
    is a lion. For this, we create a `Lion` class:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想定义两种猫的类型。我们想要定义的第一种猫是狮子。为此，我们创建一个`Lion`类：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point in time, the `Lion` class is simply an ordinary class and does
    not contain any common functionality defined in the `Cat` abstract class. To inherit
    from the `Cat` abstract class, we need to add `: Cat` after the `Lion` class name.
    The colon indicates that the `Lion` class inherits from the `Cat` abstract class.
    The `Lion` class is therefore a derived class of the `Cat` abstract class:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在此阶段，`Lion`类只是一个普通类，不包含在`Cat`抽象类中定义的任何公共功能。为了从`Cat`抽象类继承，我们需要在`Lion`类名称后添加`:
    Cat`。冒号表示`Lion`类继承自`Cat`抽象类。因此，`Lion`类是`Cat`抽象类的派生类：'
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As soon as you specify that the `Lion` class inherits from the `Cat` class,
    Visual Studio will show you an error. This is expected, because we have told the
    compiler that the `Lion` class needs to inherit all the features of the `Cat`
    abstract class, but we have not actually added these features to the `Lion` class.
    The derived class is said to override the methods in the abstract class, and needs
    to specifically be written with the `override` keyword.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦你指定`Lion`类从`Cat`类继承，Visual Studio就会显示一个错误。这是预期的，因为我们已经告诉编译器`Lion`类需要继承`Cat`抽象类的所有功能，但我们实际上并没有将这些功能添加到`Lion`类中。派生类被称为覆盖抽象类中的方法，并且需要特别使用`override`关键字来编写。
- en: If you hover over the red squiggly line underlining the `Lion` class, Visual
    Studio will offer an explanation for the error via the lightbulb feature. As you
    can see, Visual Studio is telling you that while you have defined the class to
    be inheriting from the abstract class, you have not implemented any of the abstract
    members of the `Cat` class:![How to do it…](img/B05391_02_03.jpg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将鼠标悬停在`Lion`类下方的红色波浪线处，Visual Studio将通过灯泡功能提供错误解释。正如你所见，Visual Studio告诉你，虽然你已经定义了类以从抽象类继承，但你没有实现`Cat`类的任何抽象成员：![如何操作…](img/B05391_02_03.jpg)
- en: Note
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can, therefore, see that using abstract classes is a fantastic way to enforce
    specific functionality within your system. If you define abstract members in an
    abstract class, the derived classes that inherit from that abstract class must
    implement those members; otherwise, your code will not compile. This can be used
    to enforce standards and practices adopted by your company, or to simply allow
    other developers to implement certain best practices as they use your base class
    for their derived classes. With the advent of the Visual Studio 2015 feature code
    analyzers, this can ensure a consistent development effort by the team.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，你可以看到使用抽象类是强制系统内特定功能的一种绝佳方式。如果你在抽象类中定义了抽象成员，从该抽象类继承的派生类必须实现这些成员；否则，你的代码将无法编译。这可以用来强制执行公司采用的标准和惯例，或者简单地允许其他开发者在使用你的基类作为派生类时实施某些最佳实践。随着Visual
    Studio 2015功能代码分析器的出现，这可以确保团队的开发工作保持一致。
- en: To implement these members that Visual Studio is warning us about, place your
    mouse cursor on the `Lion` class name and hit *Ctrl* + *.* (period). You can also
    click on the **Show potential fixes** link in the lightbulb popup. Visual Studio
    will give you a small heads up, displaying the changes it will make to your code.
    You can preview these changes by clicking on the **Preview changes** link, as
    well as fix all occurrences in the document, project, or solution by clicking
    on the appropriate link:![How to do it…](img/B05391_02_04.jpg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现Visual Studio警告我们的这些成员，将鼠标光标放在`Lion`类名称上并按*Ctrl* + *.*（点号）。你还可以在灯泡弹出窗口中点击**显示潜在修复**链接。Visual
    Studio会给你一个小提示，显示它将对你的代码所做的更改。你可以通过点击**预览更改**链接来预览这些更改，也可以通过点击适当的链接来修复文档、项目或解决方案中的所有发生情况：![如何操作…](img/B05391_02_04.jpg)
- en: After Visual Studio has added the changes displayed in the suggestions window,
    your `Lion` class will be correct and will look like the code listed in the following
    step.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Visual Studio添加了建议窗口中显示的更改后，你的`Lion`类将正确无误，并看起来像以下步骤中列出的代码。
- en: 'You will notice that Visual Studio automatically adds a `NotImplementedException`
    exception with the following line of code in each overridden method: `throw new
    NotImplementedException();`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到Visual Studio会自动在每个覆盖方法中添加一个`NotImplementedException`异常，其代码行如下：`throw new
    NotImplementedException();`
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is the default behavior of Visual Studio when overriding methods in the
    base class. Basically, if you had to instantiate the `Lion` class without writing
    any implementation in the overridden methods, a runtime exception would be generated.
    The idea of inheriting from our abstract class was to extend it and implement
    common functionality. This is where we need to implement that functionality, and
    this is the reason there is no implementation in the abstract class. The abstract
    class just tells us that the following methods need to be implemented. The derived
    class does the actual implementation.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是Visual Studio在基类中覆盖方法时的默认行为。基本上，如果你在未编写任何实现的情况下实例化`Lion`类，将会生成一个运行时异常。从我们的抽象类继承的想法是扩展它并实现共同的功能。这就是我们需要实现这些功能的地方，这也是为什么抽象类中没有实现的原因。抽象类只是告诉我们以下方法需要实现。派生类负责实际的实现。
- en: 'Go ahead and add some implementation to the overridden methods of the `Lion`
    class. First, add the `using static` statement for the `Console.WriteLine` method
    to the top of your class file:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加`Lion`类重写方法的实现。首先，将`using static`语句添加到类文件顶部，用于`Console.WriteLine`方法：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, add the implemented code for the methods, as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下方式添加实现的方法代码：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we will create another class called `Tiger` that also derives from the
    abstract class `Cat`. Follow step 7 to step 12 to create the `Tiger` class and
    inherit the `Cat` abstract class:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建另一个名为`Tiger`的类，它也继承自抽象类`Cat`。按照第7步到第12步创建`Tiger`类并继承`Cat`抽象类：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the same implementation for the `Tiger` class, as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式为`Tiger`类添加相同的实现：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For our `Lion` class, add an enumerator for `ColorSpectrum` and a property
    called `LionColor`. It is here that the implementations of the `Lion` and `Tiger`
    classes will differ. While they both must implement the common functionality specified
    in the abstract class, namely `Eat()`, `Hunt()`, and `Sleep()`, only the lion
    can have a color of either brown or white in its available range of colors:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的`Lion`类，添加一个`ColorSpectrum`枚举和一个名为`LionColor`的属性。在这里，`Lion`和`Tiger`类的实现将有所不同。虽然它们都必须实现抽象类中指定的共同功能，即`Eat()`、`Hunt()`和`Sleep()`，但只有狮子可以在其颜色范围内具有棕色或白色：
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, add the `Lion()` constructor in our `Lion` class. This will allow us
    to specify a color for the lions in the cat sanctuary. The constructor also takes
    as parameter a variable of the `ColorSpectrum` enumerator type:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的`Lion`类中添加`Lion()`构造函数。这将使我们能够为猫舍中的狮子指定颜色。构造函数还接受一个`ColorSpectrum`枚举类型的变量作为参数：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Slightly similar to this, but quite different in color, the `Tiger` class can
    only have a `ColorSpectrum` enumeration that defines tigers as being orange, white,
    gold, blue (yes, you actually get a blue tiger), or black. Add the `ColorSpectrum`
    enumerator to the `Tiger` class, as well as a property called `TigerColor`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与此类似，但在颜色上有所不同，`Tiger`类只能有一个定义老虎为橙色、白色、金色、蓝色（是的，你实际上可以得到一只蓝色的老虎）或黑色的`ColorSpectrum`枚举。将`ColorSpectrum`枚举添加到`Tiger`类中，以及一个名为`TigerColor`的属性：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we will create a `Tiger()` constructor for our `Tiger` class to set
    the colors of tigers in the cat sanctuary to the valid colors that tigers are
    found in. By doing this, we are separating certain functionality specific only
    to tigers and lions in their respective classes, while all the common functionality
    is contained in the abstract class `Cat`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将为我们的`Tiger`类创建一个`Tiger()`构造函数，以将猫舍中老虎的颜色设置为老虎实际存在的有效颜色。通过这样做，我们在各自的类中分离了仅针对老虎和狮子的一些特定功能，而所有共同功能都包含在抽象类`Cat`中：
- en: '[PRE13]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To see the class in action, we first need to add a reference to our `Chapter2.cs`
    class file. Right-click on **References** in the console application project:![How
    to do it…](img/B05391_02_05.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要看到类在实际中的应用，我们首先需要将`Chapter2.cs`类文件添加为引用。在控制台应用程序项目中右键单击**引用**：![如何操作…](img/B05391_02_05.jpg)
- en: The **Reference Manager** window will open for the `CodeSamples` project. Select
    `Chapter2` and click on the **OK** button. Then, add the `using Chapter2;` statement:![How
    to do it…](img/B05391_02_06.jpg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**引用管理器**窗口将打开`CodeSamples`项目。选择`Chapter2`并单击**确定**按钮。然后，添加`using Chapter2;`语句：![如何操作…](img/B05391_02_06.jpg)'
- en: 'We now need to instantiate the `Lion` and `Tiger` classes. You will see that
    we set the respective cat''s color from the constructor:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要实例化`Lion`和`Tiger`类。你会看到我们从构造函数中设置了相应猫的颜色：
- en: '[PRE14]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you run your console application, you see that the methods are called in
    sequence:![How to do it…](img/B05391_02_07.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行你的控制台应用程序时，你会看到方法按顺序被调用：![如何操作…](img/B05391_02_07.jpg)
- en: How it works…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: While the example illustrated earlier is a rather simplistic one, the theory
    is sound. The abstract class takes collective functionality across all cats and
    groups so that it can be shared inside each derived class. No implementation exists
    in the abstract class; it only defines what needs to happen. Think of abstract
    classes as a type of blueprint for classes that inherit from the abstract class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面示例中的例子相当简单，但理论是正确的。抽象类将所有猫的集体功能分组，以便可以在每个派生类中共享。抽象类中不存在实现；它只定义需要发生的事情。将抽象类视为从抽象类继承的类的蓝图类型。
- en: 'While the content of the implementation is up to you, the abstract class requires
    that you add the abstract methods it defines. From here on, you can create a solid
    foundation for similar classes in your applications that are supposed to share
    functionality. This is the goal of inheritance. Let''s recap the features of an
    abstract class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实现的内容由您决定，但抽象类要求您添加它定义的抽象方法。从现在开始，您可以为您的应用程序中应该共享功能的相关类创建一个坚实的基础。这是继承的目标。让我们回顾一下抽象类的特点：
- en: You can't instantiate an abstract class with the `new` keyword.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能使用 `new` 关键字实例化抽象类。
- en: You can only add abstract methods and accessors to an abstract class.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您只能向抽象类添加抽象方法和访问器。
- en: You can never modify an abstract class as `sealed`. The `sealed` modifiers prevents
    inheritance, while abstract requires inheritance.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您永远不能将抽象类作为 `sealed` 修改。`sealed` 修饰符阻止继承，而抽象则要求继承。
- en: Any class derived from your abstract class must include the implementations
    of the abstract methods that were inherited from the abstract class.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何从您的抽象类派生的类都必须包括从抽象类继承的抽象方法的实现。
- en: Because abstract methods inside the abstract class have no implementation, they
    don't contain a body either.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为抽象类内部的抽象方法没有实现，所以它们也不包含主体。
- en: Creating and implementing an interface
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和实现接口
- en: For many developers, interfaces are confusing and their purpose not clearly
    understood. Interfaces are actually quite easy to get to grips with once you understand
    the concept that defines an interface.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多开发者来说，接口是令人困惑的，它们的用途也不清楚。一旦您理解了定义接口的概念，接口实际上很容易掌握。
- en: Interfaces act like verbs. So, for example, if we had to create two classes
    called `Lion` and `Tiger` that derive from the `Cat` abstract class, the interface
    would describe some sort of action. Lions and tigers can roar (but not purr).
    We can then create an interface called `IRoarable`. If we had to derive a class
    called `Cheetah` from our abstract class `Cat`, we would not be able to use the
    `IRoarable` interface, because cheetahs purr. We would need to create an `IPurrable`
    interface.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接口就像动词。例如，如果我们必须创建两个名为 `Lion` 和 `Tiger` 的类，它们从 `Cat` 抽象类派生，那么接口将描述某种动作。狮子和老虎可以吼叫（但不能咕噜）。然后我们可以创建一个名为
    `IRoarable` 的接口。如果我们必须从我们的抽象类 `Cat` 派生一个名为 `Cheetah` 的类，我们就无法使用 `IRoarable` 接口，因为猎豹会咕噜。我们需要创建一个
    `IPurrable` 接口。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Creating an interface is very similar to creating an abstract class. The difference
    is that the interface is describing what the class can do, in the case of the
    `Cheetah` class, by implementing `IPurrable`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建接口与创建抽象类非常相似。区别在于接口描述了类可以做什么，在 `Cheetah` 类的情况下，通过实现 `IPurrable`。
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'If you haven''t already done so in the previous recipe, create an abstract
    class called `Cat`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有在之前的菜谱中这样做，创建一个名为 `Cat` 的抽象类：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, add a class called `Cheetah` that inherits from the `Cat` abstract class:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为 `Cheetah` 的类，该类从 `Cat` 抽象类继承：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As soon as you inherit from the `Cat` abstract class, Visual Studio will show
    you a warning via the lightbulb feature. As you inherited from the abstract class
    `Cat`, you have to implement the abstract members within the abstract class in
    your derived class `Cheetah`:![How to do it…](img/B05391_02_08.jpg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您从 `Cat` 抽象类继承，Visual Studio 将通过灯泡功能显示警告。由于您从抽象类 `Cat` 继承，您必须在派生类 `Cheetah`
    中实现抽象成员：![如何操作…](img/B05391_02_08.jpg)
- en: This is easily fixable by typing *Ctrl* +*.* (period) and fixing all occurrences
    in the document. You can also do this for the project or solution. For our purpose,
    we only select the **Document** link at the bottom of the lightbulb suggestions.
    Visual Studio will automatically add the abstract methods defined in the abstract
    class to implement inside your `Cheetah` class:![How to do it…](img/B05391_02_09.jpg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以通过按*Ctrl* +*.*（句号）来轻松修复，并修复文档中的所有出现。您也可以为项目或解决方案执行此操作。对于我们的目的，我们只选择灯泡建议底部的**文档**链接。Visual
    Studio 将自动将抽象类中定义的抽象方法添加到您的 `Cheetah` 类中实现：![如何操作…](img/B05391_02_09.jpg)
- en: 'You will notice that Visual Studio adds just the methods you need to override
    but will throw `NotImplementedException` if you try to use the class as is. The
    reason for using an abstract class is to implement the functionality defined in
    the abstract class `Cat` in the derived class `Cheetah`. Not doing so contravenes
    the rules for using abstract classes:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到 Visual Studio 只添加了你需要重写的那些方法，但如果你尝试直接使用该类，它将抛出 `NotImplementedException`。使用抽象类的原因是在派生类
    `Cheetah` 中实现抽象类 `Cat` 中定义的功能。如果不这样做，就违反了使用抽象类的规则：
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To add some implementation, modify your `Cheetah` class as follows. The implementation
    in the overridden methods is simple, but this validates the rule of writing some
    sort of implementation in the overridden methods:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了添加一些实现，按照以下方式修改你的 `Cheetah` 类。在重写方法中的实现很简单，但这验证了在重写方法中编写某种实现规则的规则：
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will notice that the following `WriteLine` method is used without the `Console`
    class. This is because we are using a new feature in C# 6.0 that allows developers
    to bring static classes into scope by adding the `using static System.Console;`
    statement to the top of your class file.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到以下 `WriteLine` 方法是在没有 `Console` 类的情况下使用的。这是因为我们正在使用 C# 6.0 中的一个新特性，该特性允许开发者通过在类文件顶部添加
    `using static System.Console;` 语句来将静态类引入作用域。
- en: 'Create an interface called `IPurrable` that will be implemented on the `Cheetah`
    class. A common naming convention for interfaces dictates that the interface name
    should be prefixed with a capital I:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `IPurrable` 的接口，该接口将在 `Cheetah` 类中实现。接口的常见命名约定规定，接口名称应该以大写 I 开头：
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will add a method to the interface that any class implementing the
    interface must implement. You will notice that the interface''s `SoftPurr` method
    contains no implementation at all. It however specifies that we will need to pass
    this method an integer value for the decibel that the `Cheetah` class will purr
    at:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向接口添加一个方法，任何实现该接口的类都必须实现。你会注意到接口的 `SoftPurr` 方法根本没有任何实现。然而，它指定我们需要传递一个整数值给这个方法，这个值将代表
    `Cheetah` 类将发出多少分贝的呼噜声：
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next step is to implement the `IPurrable` interface on the `Cheetah` class.
    To do this, we need to add the `IPurrable` interface name after the `Cat` abstract
    class name. If the `Cheetah` class did not inherit from the abstract class, then
    the interface name would simply follow after the colon:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在 `Cheetah` 类上实现 `IPurrable` 接口。为此，我们需要在 `Cat` 抽象类名称之后添加 `IPurrable` 接口名称。如果
    `Cheetah` 类没有从抽象类继承，那么接口名称将简单地跟在冒号后面：
- en: '[PRE21]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After specifying that the `Cheetah` class implements the `IPurrable` interface,
    Visual Studio once again displays a warning via the lightbulb feature. It is warning
    us that the `Cheetah` class does not implement the `SoftPurr` method defined in
    the interface `IPurrable`:![How to do it…](img/B05391_02_10.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定 `Cheetah` 类实现了 `IPurrable` 接口后，Visual Studio 再次通过灯泡功能显示警告。它警告我们，`Cheetah`
    类没有实现接口 `IPurrable` 中定义的 `SoftPurr` 方法：![如何操作…](img/B05391_02_10.jpg)
- en: As we did earlier, we can let Visual Studio suggest possible fixes for the problems
    encountered by typing *Ctrl* + *.* (period). Visual Studio suggests that the interface
    can be implemented implicitly or explicitly:![How to do it…](img/B05391_02_11.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们可以让 Visual Studio 通过输入 *Ctrl* + *.*（句号）来建议可能的修复方案。Visual Studio
    会建议接口可以隐式或显式地实现：![如何操作…](img/B05391_02_11.jpg)
- en: 'Knowing when to use an implicit or explicit implementation is also quite easy.
    We first need to know when using one over the other would be preferred. Let''s
    start off by implementing the `SoftPurr` method implicitly by selecting the first
    option in the lightbulb suggestion. You will see that by selecting to implement
    the `SoftPurr` method defined in the `IPurrable` interface implicitly, adds it
    as if it were part of the `Cheetah` class:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 知道何时使用隐式或显式实现也很简单。我们首先需要知道在什么情况下使用其中一种而不是另一种会更合适。让我们从通过选择灯泡建议中的第一个选项来隐式实现 `SoftPurr`
    方法开始。你会看到，通过选择隐式实现 `IPurrable` 接口中定义的 `SoftPurr` 方法，它就像 `Cheetah` 类的一部分一样被添加：
- en: '[PRE22]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we look at the `SoftPurr` method, it looks like a normal method inside the
    `Cheetah` class. This would be fine unless our `Cheetah` class already contains
    a property called `SoftPurr`. Go ahead and add a property called `SoftPurr` to
    your `Cheetah` class:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看 `SoftPurr` 方法，它看起来就像 `Cheetah` 类中的一个普通方法。这本来是没问题的，除非我们的 `Cheetah` 类已经包含一个名为
    `SoftPurr` 的属性。现在就给你的 `Cheetah` 类添加一个名为 `SoftPurr` 的属性：
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Visual Studio immediately displays a warning by telling us that the `Cheetah`
    class already contains a definition for `SoftPurr`:![How to do it…](img/B05391_02_12.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio会立即通过告诉我们`Cheetah`类已经包含`SoftPurr`的定义来显示一个警告：![如何操作…](img/B05391_02_12.jpg)
- en: It is here that the use of an explicit implementation becomes evident. This
    specifies that the `SoftPurr` method is a member of the implementation defined
    in the `IPurrable` interface:![How to do it…](img/B05391_02_13.jpg)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正是在这里，显式实现的使用变得明显。这指定了`SoftPurr`方法是`IPurrable`接口中定义的实现的一个成员：![如何操作…](img/B05391_02_13.jpg)
- en: 'Therefore, selecting the second option to implement the interface explicitly
    will add the `SoftPurr` method to your `Cheetah` class as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，选择第二个选项显式实现接口将把`SoftPurr`方法添加到你的`Cheetah`类中，如下所示：
- en: '[PRE24]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The compiler now knows that this is an interface that is being implemented and
    is therefore a valid line of code.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编译器现在知道这是一个正在实现中的接口，因此这是一条有效的代码行。
- en: 'For the purpose of this book, let''s just use the implicit implementation.
    Let''s write some implementation for the `SoftPurr` method and use the new `nameof`
    keyword in C# 6.0, as well as the interpolated string for the output. Also, remove
    the `SoftPurr` property added earlier:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了这本书的目的，我们只需使用隐式实现。让我们为`SoftPurr`方法编写一些实现，并使用C# 6.0中的新`nameof`关键字以及插值字符串进行输出。同时，删除之前添加的`SoftPurr`属性：
- en: '[PRE25]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Heading over to our console application, we can call our `Cheetah` class as
    follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到我们的控制台应用程序，我们可以如下调用我们的`Cheetah`类：
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running the application will produce the following output:![How to do it…](img/B05391_02_14.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序将产生以下输出：![如何操作…](img/B05391_02_14.jpg)
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: So, you might be wondering what the difference between an abstract class and
    an interface is. It basically comes down to where you want your implementation.
    If you need to share functionality between derived classes, then an abstract class
    is the best fit for your needs. In other words, we had specific things that were
    common to all cats (lions, tigers, and cheetahs) such as hunting, eating, and
    sleeping. This is then best used within an abstract class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可能想知道抽象类和接口之间的区别是什么。这基本上取决于你希望在哪里实现你的代码。如果你需要在派生类之间共享功能，那么抽象类最适合你的需求。换句话说，我们有一些对所有猫（狮子、老虎和猎豹）都共同的事情，比如狩猎、进食和睡眠。这最好在抽象类中使用。
- en: If your implementation is specific to a class or several classes (but not all
    classes), then your best course of action would be to use an interface. In this
    case, the `IPurrable` interface can be applied to several classes (for example,
    cheetahs and domestic cats) but can't be applied to all cats (such as lions and
    tigers), because not all cats can purr.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的实现特定于一个或几个类（但不是所有类），那么你最好的做法是使用接口。在这种情况下，`IPurrable`接口可以应用于几个类（例如，猎豹和家猫），但不能应用于所有猫（如狮子和老虎），因为不是所有猫都会发出咕噜声。
- en: Knowing this difference and where you need to place your implementation will
    aid you in deciding whether you need to use an abstract class or an interface.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些区别以及你需要在哪里放置你的实现将帮助你决定是否需要使用抽象类或接口。
- en: Creating and using a generic class or method
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用泛型类或方法
- en: Generics is a very interesting way of writing code. Instead of specifying the
    data type of the elements in the code at design time, you can actually delay the
    specification of those elements until they are used in code. This basically means
    that your class or method can work with any data type.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是一种非常有趣的编写代码的方式。你可以在设计时延迟指定代码中元素的类型，直到它们在代码中使用。这基本上意味着你的类或方法可以与任何数据类型一起工作。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start off by writing a generic class that can take any data type as
    a parameter in its constructor and do something with it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个可以接受任何数据类型作为其构造函数参数并对其进行操作的泛型类开始。
- en: How to do it…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Declaring a generic class is actually very easy. All that we need to do is
    create the class with the generic type parameter `<T>`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个泛型类实际上非常简单。我们只需要创建一个带有泛型类型参数`<T>`的类：
- en: '[PRE27]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The generic type parameter is basically a placeholder for a specific type that
    will need to be defined when the class of variable is instantiated. This means
    that the generic class `PerformAction<T>` can never just be used without specifying
    the type argument inside angle brackets when instantiating the class.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 泛型类型参数基本上是一个占位符，用于在实例化变量类时需要定义的具体类型。这意味着泛型类 `PerformAction<T>` 不能在没有在实例化类时指定尖括号内的类型参数的情况下使用。
- en: 'Next, create a `private` variable of the generic type parameter `T`. This will
    hold the value we pass to the generic class:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个泛型类型参数 `T` 的 `private` 变量。这个变量将保存我们传递给泛型类的值：
- en: '[PRE28]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We now need to add a constructor to the generic class. The constructor will
    take as parameter a value of type `T`. The private variable `_value` will be set
    to the parameter passed to the constructor:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要向泛型类添加一个构造函数。构造函数将接受一个类型为 `T` 的值作为参数。私有变量 `_value` 将被设置为传递给构造函数的参数：
- en: '[PRE29]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, to complete our generic class, create a void return method called
    `IdentifyDataType()`. All that this is going to do is tell us what data type we
    passed to the generic class. We can find the type of the variable using `GetType()`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了完成我们的泛型类，创建一个返回类型为 `void` 的方法，命名为 `IdentifyDataType()`。这个方法将要做的就是告诉我们我们传递给泛型类的数据类型。我们可以使用
    `GetType()` 来找到变量的类型：
- en: '[PRE30]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To see the true beauty of our generic class in action, instantiate the generic
    class in the console application and specify different data type arguments inside
    the angle brackets of each new instantiation:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要看到我们的泛型类在实际操作中的真正美，请在控制台应用程序中实例化泛型类，并在每个新的实例化中指定不同的数据类型参数：
- en: '[PRE31]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Running your console application will output the given data types that you instantiated
    the generic class with each time:![How to do it…](img/B05391_02_15.jpg)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的控制台应用程序将输出你每次实例化泛型类时给定的数据类型：![如何操作…](img/B05391_02_15.jpg)
- en: We have used the exact same class but let it perform with three very different
    data types. This kind of flexibility is a very powerful feature in your code.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用了完全相同的类，但让它以三种非常不同的数据类型执行。这种灵活性是代码中一个非常强大的功能。
- en: 'Another feature of C# is that you can constrain the generic types implemented:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的另一个特性是你可以约束实现的泛型类型：
- en: 'We can do this by telling the compiler that only types that implement the `IDisposable`
    interface can be used with the generic class. Change your generic class by adding
    `where T : IDisposable` to it. Your generic class should now look like this:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们可以通过告诉编译器只有实现了 `IDisposable` 接口的数据类型才能与泛型类一起使用来实现这一点。通过在泛型类中添加 `where T :
    IDisposable` 来更改你的泛型类。你的泛型类现在应该看起来像这样：'
- en: '[PRE32]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Go back to the console application and have a look at the previous instantiations
    of the generic class:![How to do it…](img/B05391_02_16.jpg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回控制台应用程序并查看泛型类的先前实例化：![如何操作…](img/B05391_02_16.jpg)
- en: Visual Studio will tell you that the types underlined by the red squiggly lines
    do not implement `IDisposable` and therefore can't be supplied to the `PerformAction`
    generic class.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Visual Studio 将会告诉你，下划线红色的波浪线下的类型没有实现 `IDisposable`，因此不能提供给 `PerformAction`
    泛型类。
- en: 'Comment out those lines of code and add the following instantiation to your
    console application:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉这些代码行，并将以下实例化添加到你的控制台应用程序中：
- en: '[PRE33]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that for this to work, you might need to add `using System.Data;` to your
    code file. This is needed so that you can declare a `DataSet`.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，为了使这可行，你可能需要在你的代码文件中添加 `using System.Data;`。这是必要的，以便你可以声明一个 `DataSet`。
- en: As you might know, a `DataSet` type implements `IDisposable`, and therefore,
    it is a valid type to pass to our generic class. Go ahead and run the console
    application:![How to do it…](img/B05391_02_17.jpg)
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所知，`DataSet` 类型实现了 `IDisposable`，因此它是一个有效的类型，可以传递给我们的泛型类。继续运行控制台应用程序：![如何操作…](img/B05391_02_17.jpg)
- en: The `DataSet` type is valid, and the generic class performs as expected, identifying
    the type of the parameter passed to the constructor.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DataSet` 类型是有效的，泛型类按预期执行，识别了传递给构造函数的参数类型。'
- en: 'But what about generic methods? Well, just like generic classes, generic methods
    also do not specify their type at design time. It is only known when the method
    is called. Let''s have a look at the following implementation of generic methods:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但泛型方法呢？嗯，就像泛型类一样，泛型方法在设计时也不指定它们的类型。只有在方法被调用时才知道。让我们看看以下泛型方法的实现：
- en: 'Let''s go ahead and create a new helper class called `MyHelperClass`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续创建一个新的辅助类，命名为 `MyHelperClass`：
- en: '[PRE34]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Inside this helper class, we will create a generic method called `InspectType`.
    What is interesting about this generic method is that it can return multiple types
    because the return type is also marked with the generic type parameter. Your generic
    method does not have to return anything. It can also be declared as `void`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个辅助类内部，我们将创建一个名为`InspectType`的泛型方法。这个泛型方法有趣的地方在于它可以返回多种类型，因为返回类型也被标记为泛型类型参数。您的泛型方法不必返回任何内容。它也可以声明为`void`：
- en: '[PRE35]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To illustrate that this generic method can return multiple types, we will output
    the type passed to the generic method to the console window and then return that
    type and display it in the console application. You will notice that you need
    to cast the return type as `(T)` when returning it:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明这个通用方法可以返回多种类型，我们将输出传递给通用方法的类型到控制台窗口，然后返回该类型并在控制台应用程序中显示它。您会注意到，在返回时需要将返回类型转换为`(T)`：
- en: '[PRE36]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the console application, go ahead and create an enumerator called `MyEnum`.
    The generic method can also accept enumerators:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，创建一个名为`MyEnum`的枚举器。泛型方法也可以接受枚举器：
- en: '[PRE37]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After creating the enumerator, add the following code to the console application.
    We are instantiating and calling the `oHelper` class and passing different values
    to it:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建枚举器后，将以下代码添加到控制台应用程序中。我们正在实例化和调用`oHelper`类，并传递不同的值给它：
- en: '[PRE38]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you run the console application, you will see that the generic method correctly
    identifies the type of the parameter passed to it and then returns that type to
    the calling code in the console application:![How to do it…](img/B05391_02_18.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行控制台应用程序，您将看到泛型方法正确地识别了传递给它的参数类型，然后将其返回到控制台应用程序的调用代码中：![如何操作…](img/B05391_02_18.jpg)
- en: Generic methods can be used in a multitude of situations. This is however only
    an introduction to generic classes and methods. It is recommended that you do
    further research to learn how to implement generics in your code appropriately.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型方法可以在多种情况下使用。然而，这只是一个泛型类和方法的介绍。建议您进行进一步研究，以了解如何适当地在代码中实现泛型。
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: At the heart of generics lies the ability to reuse a single class or method.
    It allows developers to essentially not repeat similar code throughout their code
    base. This conforms well to the **Don't Repeat Yourself** (**DRY**) principle.
    This design principle states that a specific bit of logic should be represented
    in code only once.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的核心在于能够重用单个类或方法。它允许开发者基本上在整个代码库中不重复类似的代码。这很好地符合**不要重复自己**（**DRY**）原则。这个设计原则指出，特定的逻辑位只应在代码中表示一次。
- en: Using generic classes also allows developers to create a class that is type
    safe when compiling. Type safe basically means that the developer can be assured
    of the type of the object and can use the class in a specific way without experiencing
    any unexpected behavior. Therefore, the compiler takes over the burden of type
    safety.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型类还可以让开发者创建在编译时类型安全的类。类型安全基本上意味着开发者可以确信对象的类型，并且可以以特定方式使用该类而不会遇到任何意外行为。因此，编译器承担了类型安全的负担。
- en: Generics also allow developers to write less code because code can be reused,
    and less code also performs better.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型还允许开发者编写更少的代码，因为代码可以重用，更少的代码也执行得更好。
- en: Creating and using a generic interface
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用泛型接口
- en: Generic interfaces work in much the same way as the previous examples in generics.
    Let's assume that we want to find the properties of certain classes in our code,
    but we can't be sure how many classes we will need to inspect. A generic interface
    could come in very handy here.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型接口的工作方式与泛型中的先前示例非常相似。假设我们想在代码中找到某些类的属性，但我们不能确定我们需要检查多少个类。在这种情况下，一个泛型接口可能非常有用。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to inspect several classes for their properties. To do this, we will
    create a generic interface that will return a list of all the properties found
    for a class as a list of strings.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查几个类的属性。为此，我们将创建一个通用接口，该接口将返回一个字符串列表，其中包含为该类找到的所有属性。
- en: How to do it…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s take a look at the following implementation of the generic interface
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下泛型接口的实现方式：
- en: 'Go ahead and create a generic interface called `IListClassProperties<T>`. The
    interface will define a method that needs to be used called `GetPropertyList()`
    that simply uses a LINQ query to return a `List<string>` object:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续创建一个名为 `IListClassProperties<T>` 的泛型接口。该接口将定义一个需要使用的方法，即 `GetPropertyList()`，它简单地使用
    LINQ 查询来返回一个 `List<string>` 对象：
- en: '[PRE39]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, create a generic class called `InspectClass<T>`. Let the generic class
    implement the `IListClassProperties<T>` interface created in the previous step:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `InspectClass<T>` 的泛型类。让这个泛型类实现之前步骤中创建的 `IListClassProperties<T>`
    接口：
- en: '[PRE40]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As usual, Visual Studio will highlight that the interface member `GetPropertyList()`
    has not been implemented in the `InspectClass<T>` generic class:![How to do it…](img/B05391_02_19.jpg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，Visual Studio 将突出显示接口成员 `GetPropertyList()` 在 `InspectClass<T>` 泛型类中尚未实现：![如何操作…](img/B05391_02_19.jpg)
- en: To show any potential fixes, type *Ctrl* + *.* (period) and implement the interface
    implicitly:![How to do it…](img/B05391_02_20.jpg)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示任何潜在的修复，键入 *Ctrl* + *.*（句点）并隐式实现接口：![如何操作…](img/B05391_02_20.jpg)
- en: 'This will create the `GetPropertyList()` method in your `InspectClass<T>` class
    without any implementation. You will add the implementation in a moment. If you
    try to run your code without adding any implementation to the `GetpropertyList()`
    method, the compiler will throw `NotImplementedException`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在你的 `InspectClass<T>` 类中创建一个没有任何实现的 `GetPropertyList()` 方法。你将在稍后添加实现。如果你尝试在没有向
    `GetpropertyList()` 方法添加任何实现的情况下运行你的代码，编译器将抛出 `NotImplementedException`：
- en: '[PRE41]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, add a constructor to your `InspectClass<T>` class that takes a generic
    type parameter and sets it equal to the private variable `_classToInspect` that
    you also need to create. This is setting up the code that we will use to instantiate
    the `InspectClass<T>` object. We will pass to the object we need a list of properties
    from the constructor, and the constructor will set the private variable `_classToInspect`
    so that we can use it in our `GetPropertyList()` method implementation:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为你的 `InspectClass<T>` 类添加一个构造函数，它接受一个泛型类型参数，并将其设置为私有变量 `_classToInspect`，你也需要创建这个变量。这是设置我们将要用来实例化
    `InspectClass<T>` 对象的代码。我们将向对象传递一个从构造函数中获取的属性列表，构造函数将设置私有变量 `_classToInspect`，这样我们就可以在
    `GetPropertyList()` 方法实现中使用它：
- en: '[PRE42]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To finish off our class, we need to add some implementation to the `GetPropertyList()`
    method. It is here that the LINQ query will be used to return a `List<string>`
    object of all the properties contained in the class supplied to the constructor:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的类，我们需要向 `GetPropertyList()` 方法添加一些实现。在这里，我们将使用 LINQ 查询来返回一个包含在构造函数提供的类中所有属性的
    `List<string>` 对象：
- en: '[PRE43]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Moving to our console application, go ahead and create a simple class called
    `Invoice`. This is one of several classes that can be used in the system, and
    the `Invoice` class is one of the smaller classes. It usually just holds invoice
    data specific to a record in the invoices records of the data store you connect
    to. We need to find a list of the properties in this class:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到我们的控制台应用程序，创建一个简单的类 `Invoice`。这是可以在系统中使用的几个类之一，`Invoice` 类是其中较小的一个。它通常只包含连接到数据存储的发票记录中的特定记录的发票数据。我们需要找到这个类中的属性列表：
- en: '[PRE44]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can now make use of our `InspectClass<T>` generic class that implements
    the `IListClassProperties<T>` generic interface. To do this, we will create a
    new instance of the `Invoice` class. We will then instantiate the `InspectClass<T>`
    class, passing the type in the angle brackets and the `oInvoice` object to the
    constructor. We are now ready to call the `GetPropertyList()` method. The result
    is returned to a `List<string>` object called `lstProps`. We can then run `foreach`
    on the list, writing the value of each `property` variable to the console window:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以利用我们的 `InspectClass<T>` 泛型类，该类实现了 `IListClassProperties<T>` 泛型接口。为此，我们将创建一个
    `Invoice` 类的新实例。然后，我们将实例化 `InspectClass<T>` 类，将类型传递到尖括号中，并将 `oInvoice` 对象传递给构造函数。我们现在可以调用
    `GetPropertyList()` 方法。结果返回到一个名为 `lstProps` 的 `List<string>` 对象。然后我们可以对列表运行 `foreach`
    循环，将每个 `property` 变量的值写入控制台窗口：
- en: '[PRE45]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Go ahead and run the code to see the output generated by inspecting the properties
    of the `Invoice` class:![How to do it…](img/B05391_02_21.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续运行代码，查看通过检查 `Invoice` 类的属性生成的输出：![如何操作…](img/B05391_02_21.jpg)
- en: As you can see, the properties are listed as they exist in the `Invoice` class.
    The `IListClassProperties<T>` generic interface and the `InspectClass<T>` class
    don't care what type of class they need to inspect. They will take any class,
    run the code on it, and produce a result.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，属性列表是按照在`Invoice`类中存在的顺序列出的。`IListClassProperties<T>`泛型接口和`InspectClass<T>`类不关心它们需要检查的类的类型。它们将接受任何类，对其运行代码，并产生结果。
- en: 'But the preceding implementation still poses a slight problem. Let''s have
    a look at one of the variation of this problem:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但前面的实现仍然存在一个小问题。让我们看看这个问题的变体之一：
- en: 'Consider the following code in the console application:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下控制台应用程序中的代码：
- en: '[PRE46]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can see that we have easily passed an integer value and type to the `InspectClass<T>`
    class, and the code does not show any warnings at all. In fact, if you ran this
    code, nothing would be returned and nothing outputs to the console window. What
    we need to do is implement the constraints on our generic class and interface.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以看到，我们很容易地将整数值和类型传递给`InspectClass<T>`类，代码没有任何警告。实际上，如果你运行这段代码，将不会返回任何内容，也不会在控制台窗口中输出任何内容。我们需要做的是在我们的泛型类和接口上实现约束。
- en: 'At the end of the interface implementation after the class, add the `where
    T : class` clause. The code now needs to look like this:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在类实现接口之后，在接口实现末尾添加`where T : class`子句。现在代码需要看起来像这样：'
- en: '[PRE47]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we returned to our console application code, you will see that Visual Studio
    has underlined the `int` type passed to the `InspectClass<T>` class:![How to do
    it…](img/B05391_02_22.jpg)
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们回到我们的控制台应用程序代码，你会看到Visual Studio已经下划线了传递给`InspectClass<T>`类的`int`类型：![如何做到这一点…](img/B05391_02_22.jpg)
- en: The reason for this is because we have defined a constraint against our generic
    class and interface. We have told the compiler that we only accept reference types.
    Therefore, this applies to any class, interface array, type, or delegate. Our
    `Invoice` class will therefore be a valid type, and the constraint will not apply
    to it.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原因在于我们已经在我们的泛型类和接口上定义了一个约束。我们告诉编译器我们只接受引用类型。因此，这适用于任何类、接口、数组、类型或委托。因此，我们的`Invoice`类将是一个有效的类型，约束不会应用于它。
- en: 'We can also be more specific in our type parameter constraints. The reason
    for this is that we perhaps do not want to constrain the parameters to reference
    types. If we, for example, wanted to button down the generic class and interface
    to only accept classes created inside our current system, we can implement a constraint
    that the argument for `T` needs to be derived from a specific object. Here, we
    can use abstract classes again:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在类型参数约束上更加具体。这样做的原因是，我们可能不希望将参数约束为引用类型。例如，如果我们想将泛型类和接口限制为只能接受在我们当前系统中创建的类，我们可以实现一个约束，即`T`的参数需要从一个特定的对象派生。在这里，我们可以再次使用抽象类：
- en: 'Create an abstract class called `AcmeObject` and specify that all classes that
    inherit from `AcmeObject` implement a property called `ID`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AcmeObject`的抽象类，并指定所有从`AcmeObject`继承的类都必须实现一个名为`ID`的属性：
- en: '[PRE48]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can now ensure that objects we create in our code for which we need to read
    the properties from are derived from `AcmeObject`. To apply the constraint, modify
    the generic class and place the `where T : AcmeObject` constraint after the interface
    implementation. Your code should now look like this:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，我们可以确保我们代码中创建的对象，需要从其读取属性的对象，都继承自`AcmeObject`。为了应用这个约束，修改泛型类并在接口实现后放置`where
    T : AcmeObject`约束。你的代码现在应该看起来像这样：'
- en: '[PRE49]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the console application, modify the `Invoice` class to inherit from the
    `AcmeObject` abstract class. Implement the `ID` property as defined in the abstract
    class:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，将`Invoice`类修改为继承自`AcmeObject`抽象类。实现抽象类中定义的`ID`属性：
- en: '[PRE50]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create two more classes called `SalesOrder` and `CreditNote`. This time, however,
    only make the `SalesOrder` class inherit from `AcmeObject`. Leave the `CreditNote`
    object as is. This is so that we can clearly see how the constraint can be applied:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为`SalesOrder`和`CreditNote`的类。然而，这次，只让`SalesOrder`类继承自`AcmeObject`。将`CreditNote`对象保持原样。这样我们可以清楚地看到约束是如何应用的：
- en: '[PRE51]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create the code needed to get the property list for the `Invoice` and `SalesOrder`
    classes. The code is straightforward, and we can see that Visual Studio does not
    complain about either of these two classes:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建获取`Invoice`和`SalesOrder`类属性列表所需的代码。代码很简单，我们可以看到Visual Studio对这两个类都没有任何抱怨：
- en: '[PRE52]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If, however, we had to try do the same for our `CreditNote` class, we will see
    that Visual Studio will warn us that we can't pass the `CreditNote` class to the
    `InspectClass<T>` class because the constraint we implemented only accepts objects
    that derive from our `AcmeObject` abstract class. By doing this, we have effectively
    taken control over exactly what we allow to be passed to our generic class and
    interface by means of constraints:![How to do it…](img/B05391_02_23.jpg)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果我们试图对我们的`CreditNote`类做同样的事情，我们会看到Visual Studio会警告我们无法将`CreditNote`类传递给`InspectClass<T>`类，因为我们实现的约束只接受派生自我们的`AcmeObject`抽象类的对象。通过这样做，我们实际上通过约束手段控制了允许传递给我们的泛型类和接口的确切内容：![如何做到这一点…](img/B05391_02_23.jpg)
- en: How it works…
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Speaking of generic interfaces, we have seen that we can implement behavior
    on a generic class by implementing a generic interface. The power of using the
    generic class and generic interface is well illustrated earlier.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 谈及泛型接口，我们已看到我们可以通过实现泛型接口来在泛型类上实现行为。使用泛型类和泛型接口的强大之处在前面已有很好的说明。
- en: Having said that, we do believe that knowing when to use constraints is also
    important so that you can close down your generic classes to only accept the specific
    types that you want. This ensures that you don't get any surprises when someone
    accidently passes an integer to your generic class.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们确实认为知道何时使用约束也很重要，这样你就可以将你的泛型类仅接受你想要的特定类型。这确保了当有人意外地将整数传递给你的泛型类时，你不会遇到任何惊喜。
- en: 'Finally, the constraints that you can use are as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用的约束如下：
- en: '`where T: struct`: The type argument must be any value types'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T: struct`: 类型参数必须是任何值类型'
- en: '`where T: class`: The type argument must be any reference types'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T: class`: 类型参数必须是任何引用类型'
- en: '`where T: new()`: The type argument needs to have a parameterless constructor'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T: new()`: 类型参数需要一个无参构造函数'
- en: '`where T: <base class name>`: The type argument must derive from the given
    base class'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T: <base class name>`: 类型参数必须派生自给定的基类'
- en: '`where T: <T must derive from object>`: `T` The type argument must derive from
    the object after the colon'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T: <T must derive from object>`: `T` 类型参数必须在冒号之后派生自对象'
- en: '`where T: <interface>`: The type argument must implement the interface specified'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where T: <interface>`: 类型参数必须实现指定的接口'
