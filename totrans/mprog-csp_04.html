<html><head></head><body>
		<div id="_idContainer019">
			<h1 id="_idParaDest-48" class="chapter-number"><a id="_idTextAnchor059"/>4</h1>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor060"/>Reasoning about Types Using Reflection</h1>
			<p>Now that we have covered some of the basics of how metaprogramming can benefit you, its core concepts, and a real-world example, it’s time to look inside the .NET runtime and see how we can leverage <span class="No-Break">its power.</span></p>
			<p>In this chapter, we will have a look at the implicit metadata provided by the compiler and the runtime. We’ll see how we can collect all types in a running system and use it <span class="No-Break">for discovery.</span></p>
			<p>We will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Assembly discovery in the <span class="No-Break">running process</span></li>
				<li>Leveraging library metadata to get <span class="No-Break">project-referenced assemblies</span></li>
				<li><span class="No-Break">Discovering types</span></li>
				<li>Open/closed <span class="No-Break">principle applied</span></li>
			</ul>
			<p>By the end of this chapter, you will understand how you can use the powerful APIs of the .NET runtime to reason about the types already in the system. You’ll learn how this can then be applied to make a more elastic and dynamic code base that can grow and ensure its maintainability <span class="No-Break">is preserved.</span></p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor061"/>Technical requirements</h1>
			<p>The source code specific to this chapter can be found on GitHub (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4</a>) and builds on top of the <strong class="source-in ine">Fundamentals</strong> code found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals"><span class="No-Break">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor062"/>Assembly discovery in the running process</h1>
			<p>In .NET, everything we compile ends up inside what is <a id="_idIndexMarker119"/>called an <strong class="bo d">assembly</strong>. This is the binary that holds the compiled code in the form of <strong class="bo d">Intermediate Language</strong> (<strong class="bo d">IL</strong>). Alongside<a id="_idIndexMarker120"/> this, there is metadata that goes with it to identify types, methods, properties, fields, and any other symbols <span class="No-Break">and metadata.</span></p>
			<p>All of these artifacts are discoverable through APIs, and it all starts with the <strong class="source-in ine">System.Reflection</strong> namespace. Within this namespace, there are APIs that allow you to reflect on what’s running. In<a id="_idIndexMarker121"/> other languages, this is often referred to <span class="No-Break">as </span><span class="No-Break"><strong class="bo d">introspection</strong></span><span class="No-Break">.</span></p>
			<p>Looking at any instance of any type you’ll see that there is always a <strong class="source-in ine">GetType()</strong> method you can call. This is part of the reflection capabilities and is implemented in the base type of <strong class="source-in ine">Object</strong>, which all types implicitly <span class="No-Break">inherit from.</span></p>
			<p>The <strong class="source-in ine">GetType()</strong> method returns a <strong class="source-in ine">Type</strong> type that describes the capabilities of the particular type – its fields, properties, methods, and more. It also holds information about what possible interfaces it implements or a base type it is inheriting from. These are very powerful constructs that we will leverage later in <span class="No-Break">this chapter.</span></p>
			<p>Instead of starting with individual types, let’s take a step back and see how, from no type, we can discover what we have in our <span class="No-Break">running proces<a id="_idTextAnchor063"/>s.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor064"/>Assembly</h2>
			<p>One of the types in<a id="_idIndexMarker122"/> the <strong class="source-in ine">System.Reflection</strong> namespace is <strong class="source-in ine">Assembly</strong>. This is the type representing an assembly, typically a <strong class="source-in ine">.dll</strong> file containing the IL code. On the <strong class="source-in ine">Assembly</strong> type, there are a few static methods. We want to focus on one particular method: <strong class="source-in ine">.GetEntryAssembly()</strong>. This method lets us, at any time, get the<a id="_idIndexMarker123"/> assembly that was the starting point, the entry point that the .NET runtime called to start <span class="No-Break">our application:</span></p>
			<ol>
				<li>Let’s create a folder called <strong class="source-in ine">Chapter4</strong>. For this chapter, we will create a few projects, so let’s start by creating another folder <span class="No-Break">called </span><span class="No-Break"><strong class="source-in ine">AssemblyDiscovery</strong></span><span class="No-Break">.</span></li>
				<li>Change into this folder in your command-line interface and create a new <span class="No-Break">console project:</span><pre class="console">
dotnet new console</pre></li>
				<li>This will set up the necessary artifacts for the project. Open the <strong class="source-in ine">Program.cs</strong> file and replace its content with <span class="No-Break">the following:</span><pre class="console">
using System.Reflection;
var assembly = Assembly.GetEntryAssembly();
  Console.WriteLine(assembly.FullName)</pre></li>
			</ol>
			<p>The code is accessing the <strong class="source-in ine">GetEntryAssembly()</strong> static method on <strong class="source-in ine">Assembly</strong> to get the assembly that serves as the entry point of <span class="No-Break">the application.</span></p>
			<p>By running this program now, you should get an output that is similar to <span class="No-Break">the following:</span></p>
			<pre class="console">
AssemblyDiscovery, Version=1.0.0.0, Culture=neutral,
  PublicKeyToken=null</pre>
			<p>This just prints out the name of the assembly, its version, information about the culture the assembly is for, and, if the assembly was signed, its <span class="No-Break">public key.</span></p>
			<p>From the entry assembly, we can now start looking at what assemblies have been referenced. Replace the code in <strong class="source-in ine">Program.cs</strong> with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using System.Reflection;
var assembly = Assembly.GetEntryAssembly();
Console.WriteLine(assembly!.FullName);
var assemblies = assembly!.GetReferencedAssemblies();
var assemblyNames = string.Join(", ", assemblies.Select(_
  =&gt; _.Name));
Console.WriteLine(assemblyNames);</pre>
			<p>The code gets the referenced assemblies from the entry assembly and prints them out. You should be see something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
AssemblyDiscovery, Version=1.0.0.0, Culture=neutral,
  PublicKeyToken=null
System.Runtime, System.Console, System.Linq</pre>
			<p>Since we haven’t<a id="_idIndexMarker124"/> explicitly referenced any assemblies, we only see <strong class="source-in ine">System.Runtime</strong>, <strong class="source-in ine">System.Consol</strong>, and <strong class="source-in ine">System.Linq</strong> as the <span class="No-Break">available assemblies.</span></p>
			<p>This is all very basic but demonstrates the starting point of reasoning about your applications and what they’re built from. But we can do so <span class="No-Break">much <a id="_idTextAnchor065"/>more.</span></p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor066"/>Leveraging library metadata to get project referenced assemblies</h1>
			<p>If you are going to <a id="_idIndexMarker125"/>gather metadata across a running process, chances are that you’re only interested in the assemblies that are part of your solution and not all the .NET framework libraries or third-party libraries. There is a performance impact of looking through all assemblies for metadata, so filtering down might be a <span class="No-Break">good idea.</span></p>
			<p>In .NET projects, we can add package references, typically from sources such<a id="_idIndexMarker126"/> as <strong class="bo d">NuGet</strong> or your own package sources, but we can also add local project references. These are references to other <strong class="source-in ine">.csproj</strong> files representing something that we want to package in its own assembly. Inside a <strong class="source-in ine">.csproj</strong> file, you can identify the different references by their XML tags – <strong class="source-in ine">&lt;PackageReference/&gt;</strong> or <strong class="source-in ine">&lt;ProjectReference/&gt;</strong>. Inside Visual Studio or Rider, you will typically see these tags in the explorer view <span class="No-Break">as well.</span></p>
			<p>The <strong class="bo d">C#</strong> compiler<a id="_idIndexMarker127"/> produces additional metadata to distinguish the different types of references all projects have. This can be leveraged <a id="_idTextAnchor067"/><span class="No-Break">in code.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor068"/>Reusable fundamentals</h2>
			<p>Let’s build <a id="_idIndexMarker128"/>a reusable library that we can leverage and expand on throughout the following chapters. Let’s call this <span class="No-Break">project </span><span class="No-Break"><strong class="source-in ine">Fundamentals</strong></span><span class="No-Break">:</span></p>
			<ol>
				<li>Create a new folder at the root of where you started building out the chapters and call it <strong class="source-in ine">Fundamentals</strong>. Change into this folder and create the <span class="No-Break">new project:</span><pre class="console">
dotnet new classlib</pre></li>
			</ol>
			<p>This creates a new project and adds a file called <strong class="source-in ine">Class1.cs</strong>. Remove this file as we don’t need it at all.</p>
			<ol>
				<li value="2">In order for us to be able to get to the proper metadata enabling us to distinguish between package or project references, we need to add a NuGet <span class="No-Break">package reference.</span></li>
			</ol>
			<p>The package we’re looking for is <strong class="source-in ine">Microsoft.Extensions.DependencyModel</strong>. In the terminal, you add the reference by doing the following:</p>
			<pre class="console">
dotnet add package
  Microsoft.Extensions.DependencyModel</pre>
			<ol>
				<li value="3">Now that we have the package, we want to create a system that is capable of discovering project references and any additional package references we explicitly tell it to load. From these, we want to get all the types so that we can start making some serious discoveries about <span class="No-Break">our system.</span></li>
			</ol>
			<p>Start by creating a file called <strong class="source-in ine">Types.cs</strong>. Then add the following code to it:</p>
			<pre class="console">
namespace Fundamentals;
public class Types
{
}</pre>
			<p>Within this new class, we want to be able to expose all the discovered types. Before we can do that, we need to discover them.</p>
			<ol>
				<li value="4">At the top of the <strong class="source-in ine">Types.cs</strong> file before the namespace declaration, add the following <span class="No-Break"><strong class="source-in ine">using</strong></span><span class="No-Break"> statements:</span><pre class="console">
using System.Reflection;
using Microsoft.Extensions.DependencyModel;</pre></li>
				<li>Add a <a id="_idIndexMarker129"/>private method called <strong class="source-in ine">DiscoverAllTypes()</strong> and start by making it look <span class="No-Break">as follows:</span><pre class="console">
IEnumerable&lt;Type&gt; DiscoverAllTypes()
{
    var entryAssembly = Assembly.GetEntryAssembly();
    var dependencyModel =
      DependencyContext.Load(entryAssembly);
    var projectReferencedAssemblies =
      dependencyModel.RuntimeLibraries
                        .Where(_ =&gt; _.Type.Equals
                          ("project"))
                        .Select(_ =&gt; Assembly.Load
                          (_.Name))
                        .ToArray();
}</pre></li>
			</ol>
			<p>This code will get the entry assembly and then leverage <strong class="source-in ine">DependencyContext</strong> from the package you referenced. This model contains more metadata around the assemblies (or libraries, as they are called in the <strong class="source-in ine">DependencyModel</strong> extension). The last thing we do is to load the assemblies we find. For the most part, the assemblies are already loaded. But this will guarantee they are loaded and return an instance of the assembly. It won’t load it again if it is already loaded.</p>
			<p>The result of this is that we have all the project-referenced assemblies in an array. That might not be all you want. If for instance you’re maintaining a set of common packages that are shared within your organization and you want to discover from these, a common pattern is to have your organization name as part of the assembly name, typically at the beginning. That means it’s easy to add something that includes all assemblies that are prefixed with a certain string.</p>
			<ol>
				<li value="6">Change the <a id="_idIndexMarker130"/>signature for the <strong class="source-in ine">DiscoverAllTypes()</strong> method to be able to include a collection of assembly prefixes for collecting types <span class="No-Break">for discovery:</span><pre class="console">
IEnumerable&lt;Type&gt; DiscoverAllTypes(IEnumerable&lt;string&gt;
  assemblyPrefixesToInclude)
{
    // ... leave the content of this method as before
}</pre></li>
				<li>In the <strong class="source-in ine">DiscoverAllTypes()</strong>method, add the following at <span class="No-Break">the end:</span><pre class="console">
var assemblies = dependencyModel.RuntimeLibraries
                    .Where(_ =&gt;
                  _.RuntimeAssemblyGroups.Count &gt; 0 &amp;&amp;
                    assemblyPrefixesToInclude.Any(asm
                    =&gt; _.Name.StartsWith(asm)))
                    .Select(_ =&gt;
                    {
                        try
                        {
                            return Assembly.Load
                              (_.Name);
                        }
                        catch
                        {
                            return null!;
                        }
                    })
                    .Where(_ =&gt; _ is not null)
                    .Distinct()
                    .ToList();</pre></li>
			</ol>
			<p>The code looks at the same <strong class="source-in ine">RuntimeLibraries</strong>, but this time specifically for assemblies that start with the prefixes. There is also error-handling functionality here: some assemblies can’t be loaded with the regular <strong class="source-in ine">Assembly.Load()</strong> method and<a id="_idIndexMarker131"/> we just ignore them, as they are not of interest.</p>
			<p>Since we call <strong class="source-in ine">.ToList()</strong> at the end of the LINQ query, we can easily combine the two collections of assemblies and all the types from all the loaded assemblies and return them from the <strong class="source-in ine">DiscoverAllTypes()</strong> method. Add the following at the end of the <strong class="source-in ine">DiscoverAllTypes()</strong> method:</p>
			<pre class="console">
assemblies.AddRange(projectReferencedAssemblies);
return assemblies.SelectMany(_ =&gt; _.GetTypes())
  .ToArray();</pre>
			<ol>
				<li value="8">Now that we have collected all assemblies and their types and returned them, it’s time to expose them to the outside world. We do this by adding a public property returning <strong class="source-in ine">IEnumerable</strong> of <strong class="source-in ine">Type</strong>. We don’t want this to be potentially mutated from <span class="No-Break">the outside:</span><pre class="console">
public IEnumerable&lt;Type&gt; All { get; }</pre></li>
				<li>The last <a id="_idIndexMarker132"/>piece of the puzzle for the <strong class="source-in ine">Types</strong> class is to add a constructor. We want the constructor to take any assembly prefixes for the <span class="No-Break"><strong class="source-in ine">DiscoverAllTypes()</strong></span><span class="No-Break"> method:</span><pre class="console">
public Types(params string[]
    assemblyPrefixesToInclude)
{
    All = DiscoverAllTypes(assemblyPrefixesToInclude);
}</pre></li>
			</ol>
			<p>We have now encapsulated a type registry that we can leverage for other use cases. Now that we have some basic building blocks. Let’s go ahead and create a <span class="No-Break">multi-project<a id="_idTextAnchor069"/> application.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor070"/>Business app</h2>
			<p>Now that we <a id="_idIndexMarker133"/>have some basic building blocks. Lets go ahead and create a multi <span class="No-Break">project application.</span></p>
			<p>Inside the <strong class="source-in ine">Chapter4</strong> folder, create a folder called <strong class="source-in ine">BusinessApp</strong>. In this folder, we’re going to create multiple projects that will make up the application. Within the <strong class="source-in ine">BusinessApp</strong> folder, create one folder called <strong class="source-in ine">Domain</strong> and another called <strong class="source-in ine">Main</strong>. The <strong class="source-in ine">Domain</strong> folder will represent the domain logic of our application and should be a class library project. Go ahead and create a new .NET project in the <span class="No-Break"><strong class="source-in ine">Domain</strong></span><span class="No-Break"> folder:</span></p>
			<pre class="source-code">
dotnet new classlib</pre>
			<p>Delete <a id="_idIndexMarker134"/>the <strong class="source-in ine">Class1.cs</strong> file that is generated. Then, in the <strong class="source-in ine">Main</strong> folder, we want to create a <span class="No-Break">console app:</span></p>
			<pre class="source-code">
dotnet new console</pre>
			<p>Within the <strong class="source-in ine">Main</strong> project you should now add references to the <strong class="source-in ine">Fundamentals</strong> project and also the <span class="No-Break"><strong class="source-in ine">Domain</strong></span><span class="No-Break"> project:</span></p>
			<pre class="source-code">
dotnet add reference ../../../Fundamentals/Fundamentals.csproj
dotnet add reference ../Domain/Domain.csproj</pre>
			<p>In the <strong class="source-in ine">Program.cs</strong> file, inside the <strong class="source-in ine">Main</strong> project, replace the content with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using Fundamentals;
var types = new Types();
var typeNames = string.Join("\n", types.All.Select(_ =&gt;
  _.Name));
Console.WriteLine(typeNames);</pre>
			<p>This code now leverages the <strong class="source-in ine">Types</strong> class we put into <strong class="source-in ine">Fundamentals</strong>, which will look at all our project reference assemblies and give us all the types. Running this should give you an output similar <span class="No-Break">to this:</span></p>
			<pre class="console">
Program
&lt;&gt;c
EmbeddedAttribute
NullableAttribute
NullableContextAttribute
EmbeddedAttribute
NullableAttribute
NullableContextAttribute
Types</pre>
			<p>You’ll notice<a id="_idIndexMarker135"/> that some of these types aren’t types you have created at all. These are types the C# compiler has put into <span class="No-Break">the projects.</span></p>
			<p>Go and add a folder called <strong class="source-in ine">Employees</strong> in the <strong class="source-in ine">Domain</strong> project and within it, create a file called <strong class="source-in ine">RegisterEmployee.cs</strong> and add the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
namespace Domain.Employees;
public class RegisterEmployee
{
    public string FirstName { get; set; } = string.Empty;
    public string LastName { get; set; } = string.Empty;
    public string SocialSecurityNumber { get; set; } =
      string.Empty;
}</pre>
			<p>By running the <strong class="source-in ine">Main</strong> project again, you should now see the <span class="No-Break">added type:</span></p>
			<pre class="console">
Program
&lt;&gt;c
EmbeddedAttribute
NullableAttribute
NullableContextAttribute
RegisterEmployee   &lt;-- New
EmbeddedAttribute
NullableAttribute
NullableContextAttribute
Types</pre>
			<p>With this, we <a id="_idIndexMarker136"/>have the beginning of a strong foundation for working with types. We just need to improve its capabilities to make it <a id="_idTextAnchor071"/>even <span class="No-Break">more useful.</span></p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor072"/>Discovering types</h1>
			<p>With the <strong class="source-in ine">Types</strong> class, we now have a <a id="_idIndexMarker137"/>raw approach to get all the types in a running system. This can be very helpful on its own as you can now use this to perform <strong class="bo d">Language Integrated Query</strong> (<strong class="bo d">LINQ</strong>) queries<a id="_idIndexMarker138"/> on top of finding types that match specific criteria you’d be <span class="No-Break">interested in.</span></p>
			<p>A very common scenario in code in general is that we have base classes or interfaces that represent characteristics of known artifact types in our system and we create specialized versions that override virtual or abstract methods, or just implement a specific interface to represent what it is. This is the power of object-oriented <span class="No-Break">programming languages.</span></p>
			<p>With this, we are adding additional implicit metadata into our systems that we can leverage. For instance, in <a href="B19418_03.xhtml#_idTextAnchor041"><span class="No-Break"><em class="ita ic">Chapter 3</em></span></a>, <em class="ita ic">Demystifying through Existing Real-World Examples</em>, we looked at how ASP.NET does this by discovering all classes that have <strong class="source-in ine">Controller</strong> as their <span class="No-Break">base type.</span></p>
			<p>From my own experience, this is the typical pattern that has been used the most on the projects I’ve been doing these things on. In fact, it is so common that it is a good idea to optimize the lookup of types on this to avoid the complexity when looking up types based on inheritance. An optimized lookup will improve <span class="No-Break">performance significantly.</span></p>
			<p>It would be a bit too verbose to do a full walkthrough of the full lookup cache mechanism as there are quite a few moving parts to it. You can find the full code <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/blob/main/Fundamentals/ContractToImplementorsMap.cs"><span class="No-Break">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/blob/main/Fundamentals/ContractToImplementorsMap.cs</span></a><span class="No-Break">.</span></p>
			<p>The interface <a id="_idIndexMarker139"/>represented by <strong class="source-in ine">ContractToImplementorsMap</strong> is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
public interface IContractToImplementorsMap
{
    IDictionary&lt;Type, IEnumerable&lt;Type&gt;&gt;
      ContractsAndImplementors { get; }
    IEnumerable&lt;Type&gt; All { get; }
    void Feed(IEnumerable&lt;Type&gt; types);
    IEnumerable&lt;Type&gt; GetImplementorsFor&lt;T&gt;();
    IEnumerable&lt;Type&gt; GetImplementorsFor(Type contract);
}</pre>
			<p>The purpose of the API of <strong class="source-in ine">IContractToImplementorsMap</strong> is to give a fast way of getting implementations of a specific type, be it a base class or an interface. The implementation of <strong class="source-in ine">IContractToImplementorsMap</strong> takes all types it is fed and maps these correctly in <span class="No-Break">this cache.</span></p>
			<p>You’ll notice that there is a method called <strong class="source-in ine">Feed()</strong>. We will have to call this in our <strong class="source-in ine">Types</strong> class. In addition, we want to have some methods that make discovering different types a lot more helpful; for instance, the following methods would <span class="No-Break">be helpful:</span></p>
			<pre class="source-code">
public Type FindSingle&lt;T&gt;();
public IEnumerable&lt;Type&gt; FindMultiple&lt;T&gt;();
public Type FindSingle(Type type);
public IEnumerable&lt;Type&gt; FindMultiple(Type type);
public Type FindTypeByFullName(string fullName);</pre>
			<p>These methods allow us to find methods that implement a specific interface or inherit from a base type. They allow us to find a single instance or multiple implementors, based on type either by generic parameter or by passing in the <strong class="source-in ine">Type</strong> object. Also for convenience, there<a id="_idIndexMarker140"/> is a method for finding a type by <span class="No-Break">its name.</span></p>
			<p>You can find the full implementation in the <strong class="source-in ine">Fundamentals</strong> folder at the link specified at the begin<a id="_idTextAnchor073"/>ning of <span class="No-Break">the chapter.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor074"/>Back to business</h2>
			<p>Moving<a id="_idIndexMarker141"/> back to our business sample, let’s add a second class in the <strong class="source-in ine">Employee</strong> folder within the <strong class="source-in ine">Domain</strong> project called <strong class="source-in ine">SetSalaryLevelForEmployee.cs</strong>. Make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace Domain.Employees;
public class SetSalaryLevelForEmployee
{
    public string SocialSecurityNumber { get; set; } =
      string.Empty;
    public decimal SalaryLevel { get; set; }
}</pre>
			<p>The <strong class="source-in ine">RegisterEmployee</strong> and <strong class="source-in ine">SetSalaryLevelForEmployee</strong> classes both represent the data we need to perform the specific actions in our domain business logic. These types of actions are often called commands. If we wanted to discover all of our commands, we could create an empty interface that we can use for all our commands to implement to make it easy for us to discover them. These types of empty interfaces used in this way are often referred to as <span class="No-Break">marker interfaces.</span></p>
			<p>In the <strong class="source-in ine">Fundamentals</strong> project, add a file called <strong class="source-in ine">ICommand.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace Fundamentals;
public interface ICommand
{
}</pre>
			<p>We now need to have a project reference to the <strong class="source-in ine">Fundamentals</strong> project from the <strong class="source-in ine">Domain</strong> project. Run the following from the <span class="No-Break"><strong class="source-in ine">Domain</strong></span><span class="No-Break"> project:</span></p>
			<pre class="source-code">
dotnet add reference ../../../Fundamentals/
  Fundamentals.csproj</pre>
			<p>With the new <strong class="source-in ine">ICommand</strong> interface, we can mark the <strong class="source-in ine">RegisterEmployee</strong> and <strong class="source-in ine">SetSalaryLevelForEmployee</strong> commands with it. Open the files for both <strong class="source-in ine">RegisterEmployee</strong> and <strong class="source-in ine">SetSalaryLevelForEmployee</strong> and add the following <strong class="source-in ine">using</strong> statements at the top of each of <span class="No-Break">the files:</span></p>
			<pre class="source-code">
using Fundamentals;</pre>
			<p>For both <a id="_idIndexMarker142"/>of the class definitions, add <strong class="source-in ine">: ICommand</strong> at the end to make them implement the <span class="No-Break"><strong class="source-in ine">ICommand</strong></span><span class="No-Break"> interface.</span></p>
			<p>Open the <strong class="source-in ine">Program.cs</strong> file in the <strong class="source-in ine">Main</strong> project and change it with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
using Fundamentals;
var types = new Types();
var commands = types.FindMultiple&lt;ICommand&gt;();
var typeNames = string.Join("\n", commands.Select(_ =&gt; _.Name));
Console.WriteLine(typeNames);</pre>
			<p>Running the <strong class="source-in ine">Main</strong> project should now yield the <span class="No-Break">following result:</span></p>
			<pre class="console">
SetSalaryLevelForEmployee
RegisterEmployee</pre>
			<p>Effectively we <a id="_idIndexMarker143"/>have now reproduced the necessary infrastructure to mimic what ASP.NET is doing for its discovery of items. With this, we have opened our software to be<a id="_idTextAnchor075"/> more open <span class="No-Break">to expansion.</span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor076"/>Domain concepts</h2>
			<p>The most <a id="_idIndexMarker144"/>boring types in most programming languages are the primitives that come with the language; typically, your integers, booleans, strings, and such. They offer absolutely no interesting or meaningful metadata. They are nothing but <span class="No-Break">very primitive.</span></p>
			<p>It’s easy to fall into the trap of using these and end up with primitive obsession. Not only are you losing valuable metadata, but it also creates code that can at times be unclear and also potentially be error prone as two properties of the same primitive type <span class="No-Break">are interchangeable.</span></p>
			<p>For applications, there is a great opportunity to move away from primitives and bring back meaning to your domain by encapsulating the primitives into meaningful types in <span class="No-Break">your domain.</span></p>
			<p>The beauty of this is that you’ll not only make your code more readable but also understandable and less ambiguous. Doing so moves you away from being primitive-obsessed to a place where you will get compiler errors if you do something wrong, putting developers on the right foot from the start. On top of all this, you’ll also be bringing in tons of metadata that can <span class="No-Break">be leveraged.</span></p>
			<p>Key characteristics of primitives are that they are value types. This means you can have two instances of the same value and equality checks would indicate that they are the same. In <strong class="bo d">C# 9.0</strong>, we got a new construct called <strong class="source-in ine">record</strong>. This enables us to create types that are complex types but bare the same characteristics as value types. Comparing two complex <strong class="source-in ine">record</strong> types with the same values on them will be <span class="No-Break">considered equal.</span></p>
			<p>Let’s introduce a base type that can be used for concepts. In the <strong class="source-in ine">Fundamentals</strong> project, add a file called <strong class="source-in ine">ConceptAs.cs</strong> and make it look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace Fundamentals;
public record ConceptAs&lt;T&gt;
{
    public ConceptAs(T value)
    {
        ArgumentNullException.ThrowIfNull(value,
          nameof(value));
        Value = value;
    }
    public T Value { get; init; }
    public static implicit operator T(ConceptAs&lt;T&gt; value)
      =&gt; value.Value;
}</pre>
			<p>This<a id="_idIndexMarker145"/> implementation gives you a way to encapsulate domain concepts. It’s built using generics letting you specify the inner type of the value the concept is representing. It is strict on not allowing null values within the encapsulation. If you want to allow null values in your code, it should not be within the concept but rather on the instance of the concept. Further, the implementation provides a convenience operator for automatic conversion to <span class="No-Break">the primitive.</span></p>
			<p>Typically, when you’re working with databases or you are transferring data across the wire in different formats, you want to strip away the concept wrapper and just get the primitive. Having the common base type is then a fantastic piece of type information that these serializers can <span class="No-Break">work with.</span></p>
			<p>In the <strong class="source-in ine">Fundamentals</strong> link that was at the beginning of the chapter, you’ll find an example of how to create a <strong class="source-in ine">JsonConverter</strong> for <strong class="source-in ine">System.Text.Json</strong> that will automatically convert any implementations of a concept to the underlying value during serialization and back to the concept type when deserializing. With the <strong class="source-in ine">ConceptAsJsonConverterFactory</strong> implementation in the same location in the <strong class="source-in ine">Fundamentals</strong> link, you’ll see that it recognizes whether a type can be converted if it is a concept based on the <strong class="source-in ine">ConceptAs</strong> base type and creates the correct converter to serialize and deserialize <span class="No-Break">the concepts.</span></p>
			<p>With the <strong class="source-in ine">ConceptAs</strong> construct, we can now go and create domain-specific implementations. As you’ll find in the code for this chapter (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4/BusinessApp">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter4/BusinessApp</a>), you can create specific concepts. For instance, for the <strong class="source-in ine">RegisterEmployee</strong> command we created earlier, instead of just using primitives, you can create specific types like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public record FirstName(string Value) :
  ConceptAs&lt;string&gt;(Value);
public record LastName(string Value) :
  ConceptAs&lt;string&gt;(Value);
public record SocialSecurityName(string Value) :
  ConceptAs&lt;string&gt;(Value);</pre>
			<p>Then, you<a id="_idIndexMarker146"/> can alter <strong class="source-in ine">RegisterEmployee</strong> from before to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
namespace Domain.Employees;
public class RegisterEmployee
{
    public FirstName FirstName { get; set; } =
      new(string.Empty)
    public LastName LastName { get; set; } = new(string.Empty);
    public SocialSecurityNumber SocialSecurityNumber { get;
      set; } = new(string.Empty);
}</pre>
			<p>This will <a id="_idIndexMarker147"/>remove any potential mistakes in the code. There is no way you could accidentally put <strong class="source-in ine">FirstName</strong> into <strong class="source-in ine">LastName</strong> or vice versa, as the compiler will tell you t<a id="_idTextAnchor077"/>hey’re not of the <span class="No-Break">same type.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor078"/>Cross-cutting concerns</h2>
			<p>With something like a concept in <a id="_idIndexMarker148"/>place, we are really starting to enrich our application code with meaningful metadata. This creates new opportunities. As mentioned earlier for serialization, by having the base type that everything uses, we can easily handle serialization in one place for concept types. This is what we mean when we talk about cross-cutting concerns: creating constructs or behavior once that can be applied across multiple <span class="No-Break">things, automatically.</span></p>
			<p>The possibilities are endless with these things. We could automatically create validation rules<a id="_idIndexMarker149"/> that are applied for the type whenever it is being used. Or we could go ahead and apply authorization policies based on types when they are used. For the command pattern and a powerful pipeline-based framework such as ASP.NET, this means we can go ahead and create action filters or middleware that can be injected into the pipeline that deals with these things automatically – just because we now have the metadata <span class="No-Break">we need.</span></p>
			<p>Take security, the one thing you really want to get right. Don’t get us wrong, we aim to get everything we do right – but security is the one thing you don’t want to mess around with. With the richness of the type system and all the metadata that goes with it, you gain access to some great opportunities to make it simpler for developers to do the <span class="No-Break">right thing.</span></p>
			<p>One thing that could be done, for instance, is creating authorization policies based on namespaces. If you have a command coming in and it belongs to a namespace that requires a certain role or claim for the user, you could do that check in one place, and by convention, just let developers drop commands or other artifacts into the correct place and they’d <span class="No-Break">be secure.</span></p>
			<p>Compliance is another area you really want to get right. It can be extremely costly if your software is not compliant. Probably the most talked-about compliance law over the last few years has been the EU regulation called <strong class="bo d">GDPR</strong>. If you’re not compliant with this, you could end up <span class="No-Break">being</span><span class="No-Break"><a id="_idIndexMarker150"/></span><span class="No-Break"> fined.</span></p>
			<p>The whole idea of the GDPR is to protect the privacy of the end users of computer systems. A lot of systems<a id="_idIndexMarker151"/> collect what is known as <strong class="bo d">Personally Identifiable Information</strong>, or <strong class="bo d">PII</strong> for short. Things such as your name, address, birth date, social security number, and a lot more are classified as PII. There is also a requirement for transparency for the end users to know what data you have on them and also to know the reason for collecting the data. If your company gets audited, you have to also show what type of data you’re collecting in <span class="No-Break">a report.</span></p>
			<p>Building on what you just learned about concepts, we can take it even further and create a specialized version of the base <strong class="source-in ine">ConceptAs&lt;&gt;</strong> type. Let’s call <span class="No-Break">it </span><span class="No-Break"><strong class="source-in ine">PIIConceptAs&lt;&gt;</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
namespace Fundamentals;
public record PIIConceptAs&lt;T&gt;(T Value) : ConceptAs&lt;T&gt;
  (Value)
{
}</pre>
			<p>As you can<a id="_idIndexMarker152"/> see, it inherits from <strong class="source-in ine">ConceptAs&lt;&gt;</strong>, giving us the opportunity to create serializers and other tooling around this base type once, but it adds metadata saying this is a specialized concept <span class="No-Break">for PII.</span></p>
			<p>At runtime in your application, you can quite easily present to the user all this information, as well as to any auditor or law <span class="No-Break">enforcement agency.</span></p>
			<p>Take the <strong class="source-in ine">SocialSecurityNumber</strong> type we made into a concept earlier. Change that to be <span class="No-Break"><strong class="source-in ine">PIIConceptAs&lt;&gt;</strong></span><span class="No-Break"> instead:</span></p>
			<pre class="source-code">
public record SocialSecurityName(string Value) :
PIIConceptAs&lt;string&gt;(Value);</pre>
			<p>As you can see from the code, it doesn’t take much to enrich it with metadata that can be leveraged. And with the powerful type discovery you built at the beginning of the chapter, you now have the power to quite easily create a simple console report of <span class="No-Break">all this:</span></p>
			<pre class="source-code">
Console.WriteLine("GDPR Report");
var typesWithConcepts = types.All
                            .SelectMany(_ =&gt;
                                _.GetProperties()
                                  .Where(p =&gt;
                                    p.PropertyType
                                       .IsPIIConcept()))
                            .GroupBy(_ =&gt; _.DeclaringType);
foreach (var typeWithConcepts in typesWithConcepts)
{
    Console.WriteLine($"Type: {typeWithConcepts
      .Key!.FullName}");
    foreach (var property in typeWithConcepts)
    {
        Console.WriteLine($"  Property : {property.Name}");
    }
}</pre>
			<p>The first thing the code does is do a LINQ query collecting all properties in the system from all types that are of the <strong class="source-in ine">PIIConceptAs&lt;&gt;</strong> type. As you can see, it uses an extension method, which is part of the fundamentals (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</a>). Since it selects all the properties with <strong class="source-in ine">.SelectMany()</strong>, we group it together based on the declaring type. Then it just loops through all the types and then all the properties and printing out <span class="No-Break">the information.</span></p>
			<p>It should yield the<a id="_idIndexMarker153"/> <span class="No-Break">following result:</span></p>
			<pre class="console">
GDPR Report
Type: Domain.Employees.RegisterEmployee
  Property : FirstName
  Property : LastName
  Property : SocialSecurityNumber</pre>
			<p>With a fairly low amount of code, we’ve gone from having no additional metadata to a much richer model that opens up the opportunity of applying logic in our code across the board. In fact, with it, we’re future-proofing our code to a certain extent. We could come back to it at a later stage and decide we want to change security. Without changing the actual code at all, we could just apply a new rule based on the metadata we already have. This is powerful and makes for flexible, extensible<a id="_idTextAnchor079"/>, and highly <span class="No-Break">maintainable systems.</span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor080"/>Open/closed principle applied</h1>
			<p>The <strong class="bo d">open/closed principle</strong> is a<a id="_idIndexMarker154"/> principle credited to Bertrand Meyer after its appearance in his 1988 book called <em class="ita ic">Object-Oriented Software Construction</em>. This is a principle regarding types we can apply in <span class="No-Break">our software:</span></p>
			<ul>
				<li>A type is open if it can <span class="No-Break">be extended</span></li>
				<li>A type is closed when it is available to <span class="No-Break">other types</span></li>
			</ul>
			<p>Classes in C# are open for extension by default. We can inherit from them and add new meanings to them. But the base class we’re inheriting from should be closed, meaning that there shouldn’t be any need for changes in the base type for the new type <span class="No-Break">to work.</span></p>
			<p>This helps us design our code for extensibility and keep responsibilities in the <span class="No-Break">right place.</span></p>
			<p>Taking a step back, we can apply some of this same thinking on the system level. What if our systems can just be extended with new capabilities without having to add configuration at the heart of a type for it to know about <span class="No-Break">the additions?</span></p>
			<p>This type of thinking is what we did earlier with <strong class="source-in ine">ICommand</strong> and the implementations. The two commands we added were not known by any parts of the system, but by virtue of implementing the <strong class="source-in ine">ICommand</strong> interface, we could see both types thro<a id="_idTextAnchor081"/>ugh an introspective of <span class="No-Break">our system.</span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor082"/>Summary</h1>
			<p>In this chapter, we have learned about the power of looking inward into our running process and collecting all the referenced assemblies and all the types of these assemblies. We’ve looked at how we can leverage even more metadata to gain access to the types of reference the assemblies are, be they package references or <span class="No-Break">project references.</span></p>
			<p>From this, we are empowered to start reasoning about types in a more meaningful way and really take advantage of the type system. Interfaces can serve as a very powerful method to mark types. The interfaces can, of course, enforce implementations of members that need to be there, but they can also just act as empty marker interfaces, serving as a way to bring explicit metadata into <span class="No-Break">the assemblies.</span></p>
			<p>In the next chapter, we will dive into how we can make full use of custom attributes to provide explicit metadata for <span class="No-Break">your applications.</span></p>
		</div>
	</body></html>