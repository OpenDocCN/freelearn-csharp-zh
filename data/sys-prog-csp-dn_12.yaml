- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: The One with the Security Safeguards
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有安全防护措施的人
- en: '*Security essentials for* *systems programming*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统编程的安全要素*'
- en: Security is more critical these days than ever. Software never stands alone;
    it always works with hardware and other software packages. Attackers do whatever
    they can to find the weakest link in the chain. As developers, we must ensure
    our software is not the weakest link.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性在当今比以往任何时候都更加关键。软件永远不会独立存在；它总是与硬件和其他软件包一起工作。攻击者会尽其所能找到链条中最薄弱的环节。作为开发者，我们必须确保我们的软件不是最薄弱的环节。
- en: Security is not a “thing” but a mindset and a process. It is a never-ending
    quest to find the best solution, keeping in mind maintainability and useability.
    As system programmers, we have to trade off security against performance and memory
    usage.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 安全不是一个“东西”，而是一种心态和过程。它是一个永无止境的寻找最佳解决方案的过程，同时考虑到可维护性和可用性。作为系统程序员，我们必须在安全性与性能和内存使用之间进行权衡。
- en: This makes building secure software a challenge. But let’s be honest – isn’t
    that sort of challenge the reason we chose this profession?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得构建安全的软件成为一个挑战。但让我们说实话——难道这种挑战不是我们选择这个职业的原因吗？
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why do we need to care about security as system programmers?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么作为系统程序员我们需要关心安全性？
- en: How to work with strings securely
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安全地处理字符串
- en: How to handle keys in your systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在你的系统中处理密钥
- en: What are the requirements around credentials and privileges?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于凭证和权限的要求是什么？
- en: How do you transfer data safely across a network?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何安全地在网络上传输数据？
- en: Security is an important but complicated topic. I will not cover everything
    there is to say about security. Still, as a system programmer, I will touch upon
    the most important things you should know. But let’s not talk too loudly – we
    must keep our secrets to ourselves! So, make sure nobody is listening in, and
    then follow me.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是一个重要但复杂的话题。我不会涵盖关于安全性的所有内容。然而，作为一个系统程序员，我会涉及到你应该知道的最重要的事情。但让我们不要太过大声——我们必须保守我们的秘密！所以，确保没有人正在监听，然后跟我来。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will find all the code in this chapter at this URL: [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter12](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter12).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个URL中找到本章中所有的代码：[https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter12](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter12)。
- en: 'If you want to follow along when I discuss Azure Key Vault, you need a subscription
    to Azure. You can create one here: [https://azure.microsoft.com/en-us/free](https://azure.microsoft.com/en-us/free).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在我讨论Azure Key Vault时跟上来，你需要一个Azure订阅。你可以在这里创建一个：[https://azure.microsoft.com/en-us/free](https://azure.microsoft.com/en-us/free)。
- en: Security for system programmers
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统程序员的网络安全
- en: When I started programming, security was not an issue. Imagine this – my computer
    had one connection, the one to the power outlet on the wall. And, of course, the
    computer was attached to a television to display whatever it needed to show. Yes,
    a TV. I did not have a monitor; I could not afford one back then. I started the
    machine up, and it would load the OS and the basic programming environment from
    ROM. And that was it. This setup was extremely secure – there were no attachments
    to anything that could interfere with my machine and data. I kept the computer
    in my bedroom, so physical security was also taken care of (no one goes into a
    teenager’s bedroom voluntarily; the mess was unbelievable).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始编程时，安全性并不是一个问题。想象一下——我的电脑只有一个连接，那就是墙上的电源插座。当然，电脑还连接到电视上，以显示它需要显示的内容。是的，一台电视。我没有显示器；当时我买不起。我启动了这台机器，它会从ROM中加载操作系统和基本的编程环境。这就是全部。这种设置极其安全——没有任何东西可以干扰我的机器和数据。我把电脑放在我的卧室里，因此物理安全也得到了保障（没有人会自愿进入一个青少年的卧室；那混乱是难以置信的）。
- en: Fast-forward to today. My desktop computer is always on and always connected
    to the internet. Some systems I have written run on a virtual machine with a cloud
    provider; others are serverless and waiting for connections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到今天。我的台式电脑总是开启并始终连接到互联网。我编写的一些系统在云提供商的虚拟机上运行；其他的是无服务器系统，等待连接。
- en: My firewalls and application gateways inform me that other systems constantly
    try to connect to all those environments and machines. I have the feeling that
    all of those machines are under constant threat.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我的防火墙和应用网关告诉我，其他系统不断尝试连接到所有这些环境和机器。我有一种感觉，所有这些机器都处于持续的威胁之下。
- en: Security is something everybody in the software industry needs to be aware of
    all the time. Only adding security measures at the end of the development cycle
    is the best way to ensure attackers have access to your system. You are bound
    to forget something. Security must be considered at every step, from the initial
    design to maintaining a running system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是软件行业中的每个人都必须时刻关注的事情。只在开发周期结束时添加安全措施是确保攻击者无法访问你的系统的最佳方式。你肯定会忘记一些事情。安全必须在每个步骤中考虑，从最初的设计到维护运行中的系统。
- en: As I said in the second paragraph of this chapter, security is a mindset. You
    need to ask yourself continuously, “Can someone take advantage of the things I
    am doing?”
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章第二段所说，安全是一种心态。你需要不断地问自己，“有人可以利用我正在做的事情吗？”
- en: What could happen if we have a vulnerability?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果我们有一个漏洞会发生什么？
- en: 'I can almost hear you say, “Hey, I write low-level code, not some fancy customer-facing
    website. Why should I be bothered with all this?” That is a reasonable response,
    but there are ways you, as a system programmer, should be very aware of the risks.
    If you aren’t, the results could be catastrophic. Let me outline some of the things
    that could happen:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我几乎能听到你这么说，“嘿，我编写的是底层代码，不是一些花哨的客户网站。我为什么要关心所有这些？”这是一个合理的回应，但作为系统程序员，你应该非常清楚这些风险。如果你不这样做，结果可能是灾难性的。让我概述一下可能会发生的一些事情：
- en: '**Privilege escalation**: A lot of the code we write runs with elevated privileges.
    Hackers who exploit a vulnerability can escalate their privilege from regular
    users to administrators, giving them extensive control over a system.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限提升**：我们编写的许多代码都带有提升的权限。利用漏洞的黑客可以从普通用户提升到管理员权限，从而获得对系统的广泛控制。'
- en: '**Data theft**: Hackers who gain access to your system can use that to steal
    sensitive information, such as the following:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据盗窃**：获得系统访问权限的黑客可以使用这些信息窃取敏感信息，如下所示：'
- en: User data, such as personal information and credit card information
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户数据，例如个人信息和信用卡信息
- en: Confidential business data, including trade secrets, intellectual property,
    and internal communications
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业机密数据，包括商业机密、知识产权和内部通讯
- en: System logs and configurations that might contain information about other systems,
    so they can be targeted as well
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统日志和配置，可能包含有关其他系统的信息，因此它们也可以被针对
- en: '**Code injection**: Hackers might exploit vulnerabilities such as buffer overflows
    or inadequate input validation to inject malicious code into a process. This action
    might enable them to do the following:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码注入**：黑客可能会利用诸如缓冲区溢出或输入验证不足等漏洞，将恶意代码注入进程。这一行为可能使他们能够执行以下操作：'
- en: '**Execute arbitrary commands**: They can run any code, potentially installing
    malware, ransomware, or other malicious software'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行任意命令**：它们可以运行任何代码，可能安装恶意软件、勒索软件或其他恶意软件'
- en: '**Alter system behavior**: Change how a system behaves, causing instability
    or hiding their activities'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改变系统行为**：改变系统的行为，导致系统不稳定或隐藏他们的活动'
- en: '**Denial of service or distributed denial of service**: Attackers can disrupt
    the normal operation of a system by doing the following:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拒绝服务或分布式拒绝服务**：攻击者可以通过以下方式干扰系统的正常运行：'
- en: '**Overloading a process**: Sending excessive requests or data, causing a system
    to crash or become unresponsive.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过载进程**：发送过多的请求或数据，导致系统崩溃或无响应。'
- en: '**Resource exhaustion**. Consuming system resources such as CPU, memory, or
    disk space, leading to performance degradation or system crashes'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源耗尽**。消耗系统资源，如CPU、内存或磁盘空间，导致性能下降或系统崩溃'
- en: '**Backdoors and persistent access**: Once they have control over a background
    process, hackers can do the following:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后门和持续访问**：一旦他们控制了后台进程，黑客可以执行以下操作：'
- en: '**Install backdoors**: Create hidden entry points to re-access a system even
    if the initial vulnerability is patched'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装后门**：创建隐藏的入口点，即使在初始漏洞被修补后也能重新访问系统'
- en: '**Establish persistence**: Modify a process to restart or maintain their presence
    on the system, even after a reboot or restart'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建立持续性**：修改进程以在重启或重启后重新启动或保持其在系统上的存在'
- en: '**Spying and surveillance**: Hackers can use compromised systems to monitor
    and collect data over an extended period:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间谍活动和监控**：黑客可以使用受损害的系统在较长时间内监控和收集数据。'
- en: '**Keystroke logging**: Capture what users type, potentially stealing passwords
    and other sensitive information'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键盘记录**：捕获用户输入的内容，可能窃取密码和其他敏感信息。'
- en: '**Screen capture**: Periodically take screenshots to monitor users’ activity'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕截图**：定期截图以监控用户的活动。'
- en: '**Network traffic monitoring**: Capture data being sent to and received from
    other systems'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络流量监控**：捕获发送到和接收自其他系统的数据。'
- en: '**Spreading malware**: A compromised system can be used as a launchpad for
    further attacks:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传播恶意软件**：受损害的系统可以用作进一步攻击的跳板。'
- en: '**Lateral movement**: Use a compromised system to move to other systems within
    a network'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**横向移动**：使用受损害的系统在网络内的其他系统之间移动。'
- en: '**Propagation**: Spread malware to other devices or processes, creating a larger
    attack surface'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传播**：将恶意软件传播到其他设备或进程，创建更大的攻击面。'
- en: '**Manipulating data**: Hackers can alter data processed by a background process:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操纵数据**：黑客可以更改后台进程处理的数据。'
- en: '**Data corruption**: Introduce errors or malicious modifications to data'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据损坏**：向数据引入错误或恶意修改。'
- en: '**Tampering with logs**: Modifying or deleting log entries to cover their tracks
    makes detecting a breach harder.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**篡改日志**：修改或删除日志条目以掩盖他们的行踪，使得检测到入侵变得更加困难。'
- en: 'As you can see, there are a lot of things that can go wrong if we leave our
    systems vulnerable. To hammer the point home, imagine a background process that
    monitors a serial port and handles data from an external device. That process
    runs 24/7, and since it deals with the lower-level Win32, we run it as an administrator.
    But we made a mistake somewhere, and a hacker accessed our process. The following
    is a potential scenario that might happen:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，如果我们让我们的系统存在漏洞，会有很多事情可能出错。为了强调这一点，想象一个后台进程，它监控串行端口并处理外部设备的数据。该进程全天候运行，因为它处理的是低级的Win32，所以我们以管理员身份运行它。但我们在某个地方犯了错误，黑客访问了我们的进程。以下是一个可能发生的潜在场景：
- en: '**Exploiting the vulnerability**: The hacker finds and exploits a buffer overflow
    vulnerability in the process.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**利用漏洞**：黑客发现并利用了进程中的缓冲区溢出漏洞。'
- en: '**Privilege escalation**: They escalate their privilege to gain administrative
    rights.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**权限提升**：他们提升权限以获得管理权限。'
- en: '**Data theft**: They extract the entire database of user credentials and personal
    information.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据盗窃**：他们提取整个用户凭证和个人信息数据库。'
- en: '**Installing a backdoor**: They install a backdoor to maintain access and monitor
    user activities.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装后门**：他们安装后门以保持访问并监控用户活动。'
- en: '**Data manipulation**: They alter account balances and change bank information
    for accounts payable.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据操纵**：他们更改账户余额和应付账款账户的银行信息。'
- en: '**Disruption**: Finally, they launch a DDOS attack, bringing your whole company
    down.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**破坏**：最后，他们发起DDoS攻击，使整个公司陷入瘫痪。'
- en: If you think this is exaggerated, I suggest you go online and find articles
    about security hacks. If you look hard enough, you will find many examples. Most
    companies are reluctant to share their experiences, but the data is there.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这被夸大了，我建议你上网查找有关安全黑客的文章。如果你足够仔细，你会找到很多例子。大多数公司都不愿意分享他们的经验，但数据是存在的。
- en: How to protect yourself
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何保护自己
- en: 'If I have scared you a little bit, good. It can be scary. But do not worry
    too much – following some good security practices can avert many of these risks.
    In fact, the rest of this chapter is all about what you, as a developer, should
    do to protect your systems. However, besides the coding aspect of security, there
    are several other things you should be doing:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我让你有点害怕，那很好。这可能会很可怕。但不要过于担心——遵循一些良好的安全实践可以避免许多这些风险。实际上，本章的其余部分都是关于作为开发人员，你应该做什么来保护你的系统。然而，除了安全方面的编码，还有几件事情你应该做：
- en: '**Holding regular security audits**: Continuously review and audit your code
    and systems for vulnerabilities. I really would suggest hiring an external party
    for this. They have a lot more experience, and they are not likely to have the
    same blind spots as the people who developed the systems.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定期进行安全审计**：持续审查和审计你的代码和系统以发现漏洞。我真心建议为此聘请外部机构。他们有更多的经验，并且不太可能像开发系统的人那样有相同的盲点。'
- en: '**Input validation**: Ensure all inputs are properly validated and sanitized.
    Just do not trust anything coming in from an external source.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入验证**：确保所有输入都经过适当的验证和清理。绝对不要相信来自外部源的内容。'
- en: '**Least privilege principle**: Run processes with the minimum necessary privileges
    to limit potential damages.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小权限原则**：以最低必要的权限运行进程，以限制潜在的损害。'
- en: '**User modern security practices**: Employ encryption, secure coding practices,
    and up-to-date third-party libraries.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采用现代安全实践**：使用加密、安全的编码实践和最新的第三方库。'
- en: '**Monitoring and logging activities**: Keep detailed logs and monitor for suspicious
    activities to quickly detect and respond to breaches.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和记录活动**：保持详细的日志并监控可疑活动，以便快速检测和应对违规行为。'
- en: So, now you know why security is important. Now, let’s investigate how to do
    that in our code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在你知道为什么安全很重要。现在，让我们调查如何在我们的代码中实现这一点。
- en: Working with strings
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与字符串一起工作
- en: Your application likely has **strings**. Most of them are irrelevant to the
    outside world; if you write “Hello World” to a console, an attacker probably couldn’t
    care less about that. But other strings are a lot more interesting to these people.
    Consider connection strings to a database, for instance. They can be an excellent
    resource for a hacker. Then, there are other data, such as user information, passwords,
    and credit card information.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序很可能有**字符串**。其中大部分与外界无关；如果你向控制台写入“Hello World”，攻击者可能根本不在乎这一点。但其他字符串对这些人的吸引力要大得多。例如，考虑数据库的连接字符串。它们可能对黑客来说是一个极好的资源。然后，还有其他数据，例如用户信息、密码和信用卡信息。
- en: 'We can distinguish between two types of strings:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分两种类型的字符串：
- en: Strings that are part of your code and thus are compiled in the binaries
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为你代码一部分的字符串，因此被编译到二进制文件中
- en: Strings that are handled in your code and originate from an outside process
    or go to an outside process
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的代码中处理并由外部进程产生或发送到外部进程的字符串
- en: Let’s see whether we can protect this sensitive data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是否可以保护这些敏感数据。
- en: Protecting settings
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护设置
- en: First, we deal with the strings in your application that are part of your code
    base. Think of things such as passwords and connection strings. In an ideal world,
    you store this information in an external file. The reason for this is that by
    not having them in your source code, you can change them without recompiling your
    code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们处理你应用程序中作为代码库一部分的字符串。想想密码和连接字符串等事情。在理想的世界里，你将此信息存储在外部文件中。这样做的原因是，由于它们不在源代码中，你可以更改它们而无需重新编译代码。
- en: Imagine that a breach has been detected somewhere in your organization. The
    security department tells everybody to update their passwords. In your case, that
    would mean opening Visual Studio, loading the solution, changing the password
    to the database server, recompiling, and finally, redeploying the system. Or,
    on second thought, you could just change the password in the config file. I know
    what I would prefer to do!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的组织内部某个地方检测到了安全漏洞。安全部门告诉每个人更新他们的密码。在你的情况下，这意味着打开Visual Studio，加载解决方案，更改数据库服务器的密码，重新编译，最后重新部署系统。或者，再想想，你可以在配置文件中更改密码。我知道我会选择做什么！
- en: Still, having a password in a config file is a pretty bad idea. If you have
    the password as part of your code, an attacker must decompile your assembly to
    find it. If we store the password in a text file, all the attacker has to do is
    open that file and read the password. To counter that, we encrypt the password.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在配置文件中保留密码是一个相当糟糕的主意。如果你将密码作为代码的一部分，攻击者必须反编译你的汇编代码来找到它。如果我们把密码存储在文本文件中，攻击者只需打开该文件并读取密码即可。为了应对这种情况，我们加密密码。
- en: We have discussed encryption several times before, so I am sure you can figure
    out how to do this. But all the techniques we have looked at so far require a
    password to be part of the source code, and we just determined that that is a
    bad idea. Storing a password in a config file to enable decrypting the rest of
    the file sounds even worse. There must be a better way. There is.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经多次讨论过加密，所以我确信你能想出如何做这件事。但到目前为止，我们所查看的所有技术都需要密码作为源代码的一部分，而我们刚刚确定这是一个坏主意。将密码存储在配置文件中以启用解密其余文件听起来更糟糕。一定有更好的方法。确实有。
- en: Let’s investigate this.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查这个问题。
- en: 'I have a sample application that has some sensitive information. I have this
    information in a file called `appsettings.json`. You know – a typical .NET-based
    configuration file. It looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个包含一些敏感信息的示例应用程序。我将这些信息放在一个名为`appsettings.json`的文件中。你知道的——一个典型的基于.NET的配置文件。它看起来像这样：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have two sections – insensitive data and data we do not want others to read.
    We need to protect the latter. Now, the way we handle this is a bit inconvenient.
    We must write a separate program to encrypt the data before writing the code that
    uses this file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个部分——不敏感数据和我们不希望其他人读取的数据。我们需要保护后者。现在，我们处理这个问题有点不方便。我们必须在编写使用此文件的代码之前编写一个单独的程序来加密数据。
- en: 'Start a new **console application** and add the following NuGet packages:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的**控制台应用程序**并添加以下NuGet包：
- en: '`Microsoft.Extensions.Configuration`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration`'
- en: '`Microsoft.Extensions.Configuration.FileExtensions`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration.FileExtensions`'
- en: '`Microsoft.Extensions.Configuration.Json`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration.Json`'
- en: '`Microsoft.Extensions.DependencyInjection`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.DependencyInjection`'
- en: '`Microsoft.AspNetCore.DataProtection`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.DataProtection`'
- en: These packages are needed to read and use configuration files, and `Microsoft.AspNetCore.DataProtection`
    is there to protect our data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包用于读取和使用配置文件，而`Microsoft.AspNetCore.DataProtection`用于保护我们的数据。
- en: 'To begin, we have to set up the dependency injection infrastructure. The data
    protection tools use this; they require packages to be injected when required.
    So, the first lines of our code look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须设置依赖注入基础设施。数据保护工具使用它；它们在需要时需要注入包。所以，我们代码的前几行看起来是这样的：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We first create a `ServiceCollection` instance. Then, we call `AddDataProtection()`
    to that collection so that all required packages are loaded and ready to use.
    After getting `serviceProvider`, we get an instance of an `IDataProtector` interface
    by calling `GetDataProtector()`. This method expects a parameter – a string describing
    the purpose. This string can be anything you want; it acts as a label so that
    you can group items. Think of it as labeling your encrypted data so that you can
    later track what belongs to what.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`ServiceCollection`实例。然后，我们调用`AddDataProtection()`到该集合，以便所有必需的包都被加载并准备好使用。在获取`serviceProvider`之后，我们通过调用`GetDataProtector()`获取一个`IDataProtector`接口的实例。此方法期望一个参数——一个描述目的的字符串。这个字符串可以是任何你想要的；它作为一个标签，以便你可以分组项目。想想看，就像给你的加密数据贴上标签，这样你就可以稍后跟踪哪些属于哪些。
- en: 'Then, we read the config file into the configuration infrastructure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将配置文件读取到配置基础设施中：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Do not forget to mark your `appsettings.json` file as `Copy when newer` in Solution
    Explorer; otherwise, your code will not load it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在解决方案资源管理器中将你的`appsettings.json`文件标记为“当较新时复制”；否则，你的代码将无法加载它。
- en: 'OK, now for the funny part – we reread the configuration file, but this time
    as text. We do this because we will replace the sensitive strings with encrypted
    versions. This is the code to read it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在来说说有趣的部分——我们再次读取配置文件，但这次是以文本的形式。我们这样做是因为我们将用加密版本替换敏感字符串。这是读取它的代码：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `json` string now holds our complete settings file. It’s time to start encrypting!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`字符串现在包含了我们的完整设置文件。是时候开始加密了！'
- en: 'First, we read the section we want to protect, iterate through all the items
    in that section, encrypt the values, and then change the strings in the `json`
    variable. Finally, we write the new string to the configuration file. This is
    what that looks like:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们读取要保护的章节，遍历该章节中的所有项目，加密值，然后更改`json`变量中的字符串。最后，我们将新的字符串写入配置文件。这看起来是这样的：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The call to `dataProtector.Protect()` does all the hard work for us. It takes
    a string and encrypts it. We replace the old value with the new one and write
    it in the file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对`dataProtector.Protect()`的调用为我们做了所有艰苦的工作。它接受一个字符串并将其加密。我们用新值替换旧值，并将其写入文件。
- en: If you open the `appsettings.json` file (the one in the folder with the debug
    build, not the original one!), you will see that the secret strings are not human-readable
    anymore. So, anyone opening that file will not have access to our secrets!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开`appsettings.json`文件（调试构建所在的文件夹中的那个，不是原始的那个！），你会看到秘密字符串不再是人类可读的。所以，任何打开该文件的人都无法访问我们的秘密！
- en: Reading encrypted data
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取加密数据
- en: 'In an application where you intend to use secret strings, you can simply read
    the data from the configuration file and decrypt them. That goes like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个打算使用秘密字符串的应用程序中，你可以简单地从配置文件中读取数据并解密它们。这看起来是这样的：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, I reload the configuration to ensure the object has the encrypted strings.
    Then, I get the section and read the first setting and its value. Finally, I use
    `dataProtector` to decrypt the string. The result is a lovely, unencrypted, readable
    string.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我重新加载配置以确保对象具有加密的字符串。然后，我获取部分并读取第一个设置及其值。最后，我使用`dataProtector`来解密字符串。结果是可爱的、未加密的可读字符串。
- en: 'Of course, you should not do encryption and decryption in production systems
    using the same program. You need to split them up. When you do, remember to use
    the same string for the purpose. If you do not do that, you will get an exception
    telling you that the decryption did not work. Try this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不应该在生产系统中使用与加密和解密相同的程序。你需要将它们分开。当你这样做的时候，记得使用相同的字符串作为目的。如果你不这样做，你会得到一个异常，告诉你解密没有工作。试试这个：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I call `GetDataProtector()` with a new purpose string, and I use that to unprotect
    the string. That will not work. If I use `"MySecureString"` instead of `"AnotherSection"`,
    it works again, even though I have a new `DataProtector`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用新的目的字符串调用`GetDataProtector()`，并使用它来解密字符串。这不会起作用。如果我使用`"MySecureString"`而不是`"AnotherSection"`，它就会再次起作用，即使我有一个新的`DataProtector`。
- en: Where are the keys?
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密钥在哪里？
- en: You may wonder why I never specified a password to encrypt and decrypt. The
    answer is that the framework generates one for me. It is more or less hidden in
    the `"%LocalAppData%\ASP.NET\DataProtection-Keys"` folder. This special folder
    is where the runtime stores and reads the keys. Open that folder, pick one of
    the XML files, and open it to see what it contains.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道我为什么从未指定一个密码来加密和解密。答案是框架为我生成了一个。它或多或少地隐藏在`"%LocalAppData%\ASP.NET\DataProtection-Keys"`文件夹中。这个特殊文件夹是运行时存储和读取密钥的地方。打开这个文件夹，选择一个XML文件，然后打开它，看看它包含什么。
- en: 'You can specify another folder where the system stores the keys. Change the
    start of the program, where we call `AddDataProtection()` to add the data protection
    classes to `serviceCollection`, to look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定另一个系统存储密钥的文件夹。更改程序的起始部分，我们将`AddDataProtection()`调用添加到`serviceCollection`中，使其看起来像这样：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This line of code tells the system to use the folder specified in `myKeyFolder`
    to store the keys.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码告诉系统使用`myKeyFolder`中指定的文件夹来存储密钥。
- en: In a production system, you can distribute the key file and store it in a known
    location. Of course, any attacker with access to your `appsettings.json` file
    probably has no problem finding the key file. There must be better ways to deal
    with this. And there are, but I will deal with that in the next part. First, I
    want to talk about the strings that are in memory. Those can be hardcoded strings
    in your code or decrypted strings from your settings file. Are those a potential
    security risk? Let’s find out!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统中，你可以分发密钥文件并将其存储在已知位置。当然，任何可以访问你的`appsettings.json`文件的攻击者可能没有问题找到密钥文件。必须找到更好的处理方法。确实有，但我将在下一部分处理。首先，我想谈谈内存中的字符串。这些可能是代码中的硬编码字符串或从设置文件中解密的字符串。这些都是潜在的安全风险吗？让我们找出答案！
- en: Handling strings in memory
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理内存中的字符串
- en: You might think encrypted strings in a configuration file are safe. After all,
    nobody can read them. Only your program can access them, provided it can access
    the key file. The program can read and decrypt the settings in memory, making
    everything safe and secure. Unfortunately, that is not the case. Finding that
    kind of information in a running program is not hard.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为配置文件中的加密字符串是安全的。毕竟，没有人能读取它们。只有你的程序可以访问它们，前提是它能够访问密钥文件。程序可以读取并解密内存中的设置，使一切安全可靠。不幸的是，情况并非如此。在运行程序中找到这类信息并不困难。
- en: Disclosing strings in your application
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在你的应用程序中泄露字符串
- en: 'Let’s assume we have the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下代码：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I agree. This isn’t the most exciting piece of code you have ever seen, but
    it does what it needs to do. It loads a string in memory and then waits for the
    user to press a key to abort the program.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我同意。这不是你见过的最令人兴奋的代码片段，但它确实完成了它需要做的事情。它将字符串加载到内存中，然后等待用户按下一个键来终止程序。
- en: 'Suppose I compile this in release mode and start the handy **WinDbg** tool
    (you can install that by going to the Microsoft Store and searching for it). In
    that case, I can do all sorts of inspections on a running program. With some digging
    around, I finally found this result:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我在发布模式下编译此代码并启动方便的**WinDbg**工具（你可以通过访问Microsoft Store并搜索它来安装）。在这种情况下，我可以对运行中的程序进行各种检查。经过一番挖掘，我终于找到了这个结果：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: WinDbg gives me all sorts of information about the `System.String` object found
    at a specific memory location. Part of that information is the contents of that
    string – `"This is my` `Open String"`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: WinDbg给我提供了关于在特定内存位置找到的`System.String`对象的所有 sorts of 信息。其中一部分信息是那个字符串的内容——“这是我的`Open
    String`”。
- en: My sample program is straightforward, so finding the information wasn’t hard.
    But the fact that I can actually do this by just attaching it to a running program
    shows you what a hacker can do. If your program takes encrypted data from an `appsettings.json`
    file and keeps that string in memory, you might as well not encrypt your data
    at all.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我的示例程序很简单，所以找到信息并不难。但事实上，我可以通过将其附加到正在运行的程序上来做到这一点，这展示了黑客能做什么。如果你的程序从`appsettings.json`文件中获取加密数据并将该字符串保留在内存中，那么你甚至可以不加密你的数据。
- en: There must be a better way. And guess what – there is!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一定有更好的方法。猜猜看——确实有！
- en: Using SecureStrings
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SecureStrings
- en: We’ve discovered that strings in memory are not secure. The people behind the
    BCL thought of this as well and gave us an alternative – `SecureString`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现内存中的字符串并不安全。BCL背后的那些人也想到了这个问题，并给了我们一个替代方案——`SecureString`。
- en: That sounds like a beautiful idea, but `SecureString` is less convenient than
    a “real” string. Not by far. However, it does have one advantage – the data in
    it is encrypted.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法听起来很美好，但`SecureString`比“真正的”字符串不太方便。远不止这样。然而，它确实有一个优点——其中的数据是加密的。
- en: 'Creating `SecureString` is easy enough:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`SecureString`很容易：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But that doesn’t really help us. We want some data in it. That’s not hard,
    but you must copy the data one character at a time:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并没有真正帮助我们。我们想要一些数据在其中。这不难，但你必须逐个字符复制数据：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, `secureString` contains some data. The nice thing is that the data is encrypted
    and not readable anymore. The call to `MakeReadOnly()` is important. By making
    it read-only, you ensure that the string is not changeable anymore, which helps
    in performance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`secureString`包含了一些数据。好事是数据被加密了，并且不再可读。对`MakeReadOnly()`的调用很重要。通过使其只读，你确保字符串不再可更改，这有助于性能。
- en: '`SecureString` is mainly used to store passwords. A lot of classes in the BCL
    that need passwords accept `SecureString` as their parameter. For instance, these
    are some of the classes that can work with `SecureString` instances:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecureString`主要用于存储密码。BCL中许多需要密码的类都接受`SecureString`作为它们的参数。例如，以下是可以与`SecureString`实例一起工作的类的一些例子：'
- en: '`ProcessStartInfo`: When starting a new process, you can provide a password
    as `SecureString` using the `ProcessStartInfo` struct, or by calling an overload
    of `Process.Start()` that accepts `SecureString`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessStartInfo`：在启动新进程时，你可以使用`ProcessStartInfo`结构或通过调用接受`SecureString`的重载版本的`Process.Start()`来提供密码作为`SecureString`。'
- en: '`NetworkCredential`: When you need to identify a resource with a network resource,
    you can use `NetworkCredential` to pass along the required parameters, such as
    the username, password, and domain. The password can be an instance of the `SecureString`
    class.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetworkCredential`：当你需要用网络资源标识一个资源时，你可以使用`NetworkCredential`来传递所需的参数，例如用户名、密码和域。密码可以是`SecureString`类的实例。'
- en: '`CspParameters` and `X509Certificate`: These are important if you are dealing
    with certificates, and they also allow `SecureString` instances.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CspParameters`和`X509Certificate`：如果你在处理证书，这些非常重要，它们还允许`SecureString`实例。'
- en: So, now we have a secure string. Great. But we still have an issue. Can you
    spot it? I will give you a minute while you look at the code that we last discussed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们有一个安全的字符串。太好了。但我们仍然有一个问题。你能发现吗？在你查看我们刚才讨论的代码的同时，我会给你一分钟时间。
- en: The problem, of course, is where we seed the secure string. We create a string
    in memory with the `"This is a big secret"` contents and transfer it to the secure
    string. But the original string is still in memory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，问题是我们在哪里播种安全字符串。我们创建了一个包含`"This is a big secret"`内容的字符串并将其传输到安全字符串中。但原始字符串仍然在内存中。
- en: We would have had the same issue if we had read an encrypted string from a configuration
    file, decrypted it, and copied it to the secure string. The original, decrypted
    string is still in memory and can be read externally.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从配置文件中读取一个加密的字符串，将其解密，并将其复制到安全字符串中，我们会有同样的问题。原始的解密字符串仍然在内存中，并且可以从外部读取。
- en: The only way to circumvent it is to erase that provisional string as soon as
    you finish it. The unencrypted strings should be in memory for as long as possible.
    Technically, it is still vulnerable, but the attacker has to break the running
    application exactly when the strings are in memory. The attack window is still
    there, but it is very, very small.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要绕过它的唯一方法是尽快删除那个临时字符串。未加密的字符串应该在内存中尽可能长时间地保留。技术上，它仍然容易受到攻击，但攻击者必须在字符串在内存中时恰好打破运行的应用程序。攻击窗口仍然存在，但非常非常小。
- en: 'Erasing a string is not the same as assigning a new value – strings are immutable.
    When you try to change the string, you get a new instance, and the old data is
    still readable. The only way to completely eradicate it from memory is to erase
    the chars that form the string. You can erase a string from memory with something
    similar to this code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 删除字符串与分配新值不同——字符串是不可变的。当你尝试更改字符串时，你会得到一个新的实例，而旧数据仍然可读。要从内存中完全删除它，唯一的方法是删除构成字符串的字符。你可以使用类似以下代码的方式从内存中删除字符串：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You have to set the `'0'`. Since `0` denotes the end of the string, it is harder
    to see the original length of the string.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须设置 `'0'`。由于 `0` 表示字符串的结尾，因此很难看到字符串的原始长度。
- en: I am not saying you need to call this method for every string. But suppose you
    are dealing with strings that you absolutely do not want to leak. In that case,
    this might solve the intermediate problem of copying data to a secure string.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说你需要为每个字符串调用此方法。但假设你正在处理你绝对不希望泄露的字符串。在这种情况下，这可能会解决将数据复制到安全字符串的中间问题。
- en: But where do we get the decryption keys from? We can distribute them as shown
    previously, but there are other ways. Let’s discuss those! However, before doing
    that, let’s think about what we have learned. This was a complicated topic; dealing
    with strings in memory is not something many C# developers think about. But therein
    lies the problem – since people do not think about it, they are unaware of any
    risks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们从哪里获取解密密钥呢？我们可以像之前那样分发它们，但还有其他方法。让我们来讨论那些！然而，在这样做之前，让我们思考一下我们学到了什么。这是一个复杂的话题；处理内存中的字符串不是许多
    C# 开发者会考虑的事情。但问题就在这里——由于人们没有考虑它，他们没有意识到任何风险。
- en: Conversely, you now know about the risks and are ready to deal with them if
    you encounter the need for this level of security.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，现在你已经了解了风险，如果需要这种级别的安全性，你将准备好应对。
- en: Using key management
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用密钥管理
- en: Keys are the best-kept secrets of your application. Keys are used to encrypt
    and decrypt a lot of sensitive data. This means the keys themselves are even more
    sensitive; they hold the power to unlock all your secrets. Storing a key in a
    text file next to an executable might not be the best way to treat this valuable
    piece of data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥是应用程序的最佳保密信息。密钥用于加密和解密大量敏感数据。这意味着密钥本身更加敏感；它们拥有解锁所有秘密的权力。将密钥存储在可执行文件旁边的文本文件中可能不是处理这块宝贵数据的最佳方式。
- en: How and where you store the keys depends on where you run your program. If your
    application lives in the cloud, you should use a cloud-based key management system.
    If you run your systems on a machine you can touch, you need another solution.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何以及在哪里存储密钥取决于你的程序运行的位置。如果你的应用程序运行在云端，你应该使用基于云的密钥管理系统。如果你在可以触摸的机器上运行你的系统，你需要另一个解决方案。
- en: Using the Azure Key Vault
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Azure 密钥保管库
- en: The **Azure Key Vault** is a centralized, cloud-based secret and key management
    solution. It is straightforward to set up and easy to use. Its main purpose is
    to guard secrets and keys for Azure-based applications. However, it can also be
    used by applications running on-premise.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure 密钥保管库**是一个集中式、基于云的秘密和密钥管理系统。它设置简单，使用方便。其主要目的是保护基于 Azure 的应用程序的秘密和密钥。然而，它也可以由本地运行的应用程序使用。'
- en: 'I will not teach you how to create a key vault here; plenty of resources can
    help you. For instance, this is a good resource from Microsoft itself: [https://learn.microsoft.com/en-us/azure/key-vault/general/quick-create-portal](https://learn.microsoft.com/en-us/azure/key-vault/general/quick-create-portal).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里教你如何创建密钥保管库；有很多资源可以帮助你。例如，这是来自微软本身的一个很好的资源：[https://learn.microsoft.com/en-us/azure/key-vault/general/quick-create-portal](https://learn.microsoft.com/en-us/azure/key-vault/general/quick-create-portal)。
- en: 'Once you have a key vault deployed and have added a secret, retrieving that
    secret is simple. But before we look at the code to get that secret, we must ensure
    access to the resource. That means we make notes of the following items:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你部署了密钥库并添加了密钥，检索该密钥就很简单了。但在我们查看获取该密钥的代码之前，我们必须确保对资源的访问。这意味着我们需要记录以下项目：
- en: '| **Item name** | **Value** | **Description** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **项目名称** | **值** | **描述** |'
- en: '| Key vault name | `mykeyvault` | The name of the key vault you specified when
    you created it |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 密钥库名称 | `mykeyvault` | 创建时指定的密钥库的名称 |'
- en: '| Secret name | `MySecretValue` | The name of the secret |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 密钥名称 | `MySecretValue` | 密钥的名称 |'
- en: 'Table 12.1: Values to find the Azure Key Vault secret'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.1：查找Azure密钥库密钥的值
- en: Obviously, you should change these values to match your setup.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你应该更改这些值以匹配你的配置。
- en: 'In the C# application, we need to add a couple of NuGet packages:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#应用程序中，我们需要添加几个NuGet包：
- en: '`Azure.Identity` to enable authentication'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Azure.Identity`以启用身份验证'
- en: '`Azure.Security.KeyvaultSecrets`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Azure.Security.KeyvaultSecrets`'
- en: 'Once you have installed those packages, the code to get the secrets out of
    the key vault is very straightforward. For instance, you can use this helper method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了这些包之后，从密钥库中获取密钥的代码就非常直接了。例如，你可以使用这个辅助方法：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code snippet shows how to use the `SecretClient` class from the previously
    installed package to access the secrets in the key vault. To authenticate this
    request, I use the `DefaultAzureCredential` class. Using this class means I authenticate
    against the Azure URL with the current user’s credentials.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段展示了如何使用之前安装的包中的`SecretClient`类来访问密钥库中的密钥。为了验证这个请求，我使用了`DefaultAzureCredential`类。使用这个类意味着我使用当前用户的凭据对Azure
    URL进行身份验证。
- en: 'In a production system, you would not do that. Instead, you should probably
    create a registration for your system and use that to authenticate. Authentication
    in Azure is a topic that deserves its own book, but the following URL should get
    you on your way: [https://learn.microsoft.com/en-us/dotnet/azure/sdk/authentication/?tabs=command-line](https://learn.microsoft.com/en-us/dotnet/azure/sdk/authentication/?tabs=command-line).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统中，你不会这样做。相反，你可能需要为你的系统创建一个注册，并使用它进行身份验证。Azure中的身份验证是一个值得单独一本书来讨论的话题，但以下URL应该能帮助你入门：[https://learn.microsoft.com/en-us/dotnet/azure/sdk/authentication/?tabs=command-line](https://learn.microsoft.com/en-us/dotnet/azure/sdk/authentication/?tabs=command-line)。
- en: Using environment variables
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: Even when using Azure (and not using the default credentials), you need to store
    some sort of access key, secret ID, or user ID and password before you can use
    the resources. The same applies when you store data encrypted in your `appsettings.json`
    file – you need a key to decrypt. As we saw in a previous sample, you can ask
    the .NET runtime to create a key for you and store it in a known place. That is
    one way of solving this issue, but there is also a much simpler way. We can use
    environment variables.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在使用Azure（且不使用默认凭据）时，你也需要在能够使用资源之前存储某种访问密钥、密钥ID或用户ID和密码。当你将数据加密存储在`appsettings.json`文件中时，这也适用——你需要一个密钥来解密。正如我们在之前的示例中看到的，你可以要求.NET运行时为你创建一个密钥并将其存储在已知位置。这是解决这个问题的方法之一，但还有一个更简单的方法。我们可以使用环境变量。
- en: Warning
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Environment variables are convenient, but they are not secure – not by a long
    shot. Everybody can look up their values if they have physical access to the machine.
    Never store sensitive information in environment variables unless you can be confident
    the virtual or physical machine is secure.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量很方便，但它们并不安全——远远不够安全。如果有人能够物理访问这台机器，他们就可以查看到这些变量的值。除非你能够确信虚拟或物理机器是安全的，否则永远不要在环境变量中存储敏感信息。
- en: An environment variable is simply a key-value pair that lives in Windows. It
    is usually used to contain settings from outside of the process. This is why they
    can be useful for holding data we need to identify resources; they can change
    on the fly without changing or restarting our application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量简单来说就是存在于Windows中的一个键值对。它通常用于包含来自进程外部的设置。这就是为什么它们对于保存我们需要用来识别资源的那些数据很有用；它们可以在不改变或重启我们的应用程序的情况下动态更改。
- en: Environment variable scopes
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量作用域
- en: 'Where precisely these variables live and how long they persist depends on the
    kind of environment variable. The variables can have a scope that affects where
    they persist (and how long they do so). These are the options we have:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量确切地存储在哪里以及它们持续多久取决于环境变量的类型。这些变量可以有一个影响它们持久性的作用域（以及它们持续多久）。以下是我们的选项：
- en: '**Process scope**: These variables are only available to the process that defined
    them, or any child processes that the main process spawns. They can be useful
    for temporary values that can be discarded if the process goes out of memory.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程作用域**：这些变量仅对定义它们的进程或主进程所派生的任何子进程可用。对于可以丢弃的临时值，它们可能很有用。'
- en: '**User scope**: They are specific to the currently logged-in user. They are
    available to all processes that run under that user’s credentials. These variables
    persist across logins.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户作用域**：它们是针对当前登录用户的特定变量。它们对所有在该用户凭据下运行的进程都可用。这些变量在登录之间持续存在。'
- en: '**Machine scope (or system scope)**: These variables are available to all users
    and processes on a machine. They require administrative privileges to set and
    modify but not to read.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器作用域（或系统作用域）**：这些变量对所有机器上的用户和进程都可用。它们需要管理员权限来设置和修改，但不用于读取。'
- en: '**Session scope**: These variables are scoped to a user session. This scope
    is more or less the same as the user scope, but the variables are discarded as
    the session ends. That happens, for instance, if the user logs off.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话作用域**：这些变量的作用域是用户会话。这个范围与用户作用域大致相同，但变量在会话结束时会被丢弃。例如，如果用户注销，就会发生这种情况。'
- en: '**Volatile environment variables**: This is a special category mainly used
    by a system. They are intended to be temporary. Users typically do not handle
    or even access these. An example is the settings set during boot time that can
    be removed once the login process ends.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易失性环境变量**：这是一个主要用于系统的特殊类别。它们旨在是临时的。用户通常不会处理或甚至访问这些变量。一个例子是在启动时设置的设置，一旦登录过程结束就可以删除。'
- en: As you can see, there are a lot of different scopes, some of which most users
    have never even heard of before. Make sure you pick the correct one!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有很多不同的作用域，其中一些大多数用户甚至从未听说过。确保你选择正确的一个！
- en: Setting environment variables
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置环境变量
- en: Of course, we can use our C# code to set variables. However, we usually do not
    do that; in our case, we want to set some secret data outside our application
    and then use it in our code. This means we have to set the data from the outside.
    Setting the values is typically done during the installation of our software.
    However, during development, you have to do it manually.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用我们的 C# 代码来设置变量。然而，我们通常不会这样做；在我们的情况下，我们想在应用程序外部设置一些秘密数据，然后在代码中使用它。这意味着我们必须从外部设置数据。通常，设置值是在我们的软件安装期间完成的。然而，在开发过程中，你必须手动完成。
- en: Setting these variables is very easily done from a PowerShell session, and the
    exact syntax depends on the scope you want to achieve.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PowerShell 会话中设置这些变量非常容易，并且确切的语法取决于你想要实现的作用域。
- en: Process scope
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进程作用域
- en: 'I only add this here for completeness. After all, if we set a variable so that
    we can read it in our application, using the **process scope** does not make sense.
    The variable is set in the scope of the PowerShell session and thus is not readable
    in our application. But anyway, here is how you do it. In PowerShell, enter this
    command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我只在这里添加这个是为了完整性。毕竟，如果我们设置一个变量以便在我们的应用程序中读取它，使用**进程作用域**就没有意义了。变量是在 PowerShell
    会话的作用域中设置的，因此在我们的应用程序中不可读。但无论如何，下面是如何做到这一点的。在 PowerShell 中，输入以下命令：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This command creates a new variable named `"MY_SECRET_ID"` in memory and assigns
    it the `12345678` value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在内存中创建了一个名为 `"MY_SECRET_ID"` 的新变量，并将其赋值为 `12345678`。
- en: 'If you read the data, you’ll be surprised to see that it is almost as simple
    as setting it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读取数据，你会惊讶地发现它设置起来几乎和读取一样简单：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command should return the `12345678` string.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应返回 `12345678` 字符串。
- en: 'After setting and reading the data, you might want to erase it. Again, this
    is very easy to do:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置和读取数据后，你可能想将其擦除。同样，这非常容易做到：
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that that last command happens automatically if you close the PowerShell
    session.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最后一个命令在关闭 PowerShell 会话时会自动发生。
- en: User scope
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户作用域
- en: '**User scope** is the first useable scope for our purposes. Setting this variable
    goes like this in PowerShell:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户作用域**是我们目的的第一个可用的作用域。在 PowerShell 中设置此变量的方式如下：'
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This command creates a new variable and sets the data. The variable is stored
    in the Windows Registry under the `HKEY_CURRENT_USER\Environment` key. Windows
    keeps this value across reboots. Since the data is stored in `HKEY_CURRENT_USER`,
    you can only read the data in processes belonging to that user. That means you
    can read it during debugging in **Visual Studio** (**VS**), but only if you run
    VS under the same credentials.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建一个新变量并设置数据。该变量存储在Windows注册表中的`HKEY_CURRENT_USER\Environment`键下。Windows会在重启之间保持此值。由于数据存储在`HKEY_CURRENT_USER`中，你只能读取属于该用户的进程中的数据。这意味着你可以在**Visual
    Studio**（**VS**）的调试期间读取它，但前提是你必须以相同的凭据运行VS。
- en: Machine scope
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 机器范围
- en: 'The broadest scope is the **machine scope**. Setting data is just as simple
    as using the user scope, with one tiny addition:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛的范围是**机器范围**。设置数据与使用用户范围一样简单，只需添加一个小的改动：
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The use of `/m` at the end makes this variable a machine-scoped one. This means
    it is stored in a different location as well; you can now find this variable in
    the Windows Registry under the `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session
    Manager\Environment` key. This variable is persisted across reboots and is accessible
    to all users and processes on that machine.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在末尾使用 `/m` 使得这个变量成为机器范围的。这意味着它还存储在不同的位置；你现在可以在Windows注册表中的`HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session
    Manager\Environment`键下找到这个变量。这个变量会在重启之间持续存在，并且对该机器上的所有用户和进程都是可访问的。
- en: Reading the variables in your code
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取你代码中的变量
- en: There is little use in storing data somewhere if it is impossible to read. So,
    let’s investigate how we can use that data in our C# application.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法读取，存储数据在某个地方几乎没有什么用处。所以，让我们调查一下我们如何在C#应用程序中使用这些数据。
- en: 'To read the data, you only need one line of code, which is this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取数据，你只需要一行代码，就是这一行：
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: However, remember that `MY_SECRET_ID` was set using the user scope. So, if you
    run your PowerShell command as an administrator, you must also run VS as an administrator.
    Otherwise, the code returns an empty string.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，`MY_SECRET_ID` 是使用用户范围设置的。所以，如果你以管理员身份运行你的PowerShell命令，你也必须以管理员身份运行VS。否则，代码将返回一个空字符串。
- en: 'Do you want to see how to read the machine-scoped variable? I thought you might.
    This is how:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你想看看如何读取机器范围的变量吗？我想你可能会的。这就是方法：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Yes, that is the same code, with the only change being the variable name we
    are looking for. Not all code in this book is hard to understand!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这就是相同的代码，唯一的变化是我们正在寻找的变量名。这本书中的所有代码并不都是难以理解的！
- en: There are many more ways to handle keys, but you have now seen two of the most
    used ones. You now know how to use Azure Key Vault and have learned a lot about
    environmental variables. Let’s move on!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 处理键有许多方法，但你现在已经看到了最常用的两种。你现在知道如何使用Azure Key Vault，并且对环境变量有了很多了解。让我们继续前进！
- en: Using the right privilege level
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正确的权限级别
- en: Most systems do not need to run as admin. Requiring your application to have
    admin rights is a potential security risk. It would be best to ensure your application
    runs on the lowest security level possible to avoid potential leaks.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统不需要以管理员身份运行。要求你的应用程序具有管理员权限是一个潜在的安全风险。最好确保你的应用程序在可能的最低安全级别上运行，以避免潜在的安全漏洞。
- en: However, sometimes you have no choice. There are certain cases where admin-level
    privilege is needed. The bad news is that this happens often in the world where
    we, system programmers, live. Our systems need an admin level more than a regular
    program does.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你不得不这样做。在某些情况下，需要管理员级别的权限。坏消息是，在我们这些系统程序员生活的世界里，这种情况经常发生。我们的系统比普通程序需要更多的管理员级别。
- en: Admin-level scenarios
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理员级别场景
- en: 'Let’s investigate some areas where elevated privileges are needed if we want
    our system to do what it needs to do:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查一些需要提升权限的区域，如果我们想让我们的系统完成它需要做的事情：
- en: '`C:\Windows\System32` directory is a good example of a protected directory.
    You need elevated rights if you want to read something from that folder.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:\Windows\System32` 目录是一个很好的保护目录示例。如果你想从该文件夹中读取内容，你需要提升权限。'
- en: '`HKEY_LOCAL_MACHINE` key. That area cannot be reached without the proper security
    level.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HKEY_LOCAL_MACHINE` 键。没有适当的权限级别是无法访问该区域的。'
- en: '**Service management**:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务管理**：'
- en: Starting, stopping, or configuring Windows services is another nice example
    of requiring admin-level privileges. Also, installing and uninstalling these services
    need that level of trust. Since we work a lot with background processes, we can
    imagine scenarios where we need to control those processes from other processes.
    That means elevating the level again.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启动、停止或配置Windows服务是另一个需要管理员级别权限的好例子。同样，安装和卸载这些服务也需要这种信任水平。由于我们与后台进程打交道很多，我们可以想象出需要从其他进程控制这些进程的场景。这意味着需要再次提升权限级别。
- en: '**Network configuration**:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络配置**：'
- en: Modifying network settings is also a reason you might need elevated privileges.
    These tasks include changing an IP address, configuring network adapters, and
    adjusting firewall rules.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修改网络设置也可能是你需要提升权限的原因之一。这些任务包括更改IP地址、配置网络适配器和调整防火墙规则。
- en: '**System monitoring** **and diagnostics**:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统监控** **和诊断**：'
- en: Some of the performance counters or diagnostics tools require elevated privileges.
    Also, reading system logs in an event or other logs requires admin access.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些性能计数器或诊断工具需要提升权限。此外，在事件或其他日志中读取系统日志也需要管理员访问权限。
- en: This is not an exhaustive list; there are other areas as well. If you run into
    one of those, you will find out soon enough – your system won’t work and crash
    with a nice exception.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个详尽的列表；还有其他区域。如果你遇到这些区域之一，你很快就会知道——你的系统将无法工作并崩溃，出现一个漂亮的异常。
- en: Impersonating as an admin
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟管理员身份
- en: If your system does something from the preceding list, you might be tempted
    to install your system with admin credentials. That way, you are sure it always
    works. But as we have discussed before, that is not necessarily a good idea. It
    would be much better to go to the administrator level only when needed. When done,
    revert to the regular, less privileged user account.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统执行了前面列表中的任何操作，你可能会想用管理员凭据安装你的系统。这样，你可以确保它总是正常工作。但正如我们之前讨论的，这并不一定是好主意。更好的做法是在需要时才提升到管理员级别。完成后，回到常规的、权限较低的账户。
- en: How can we do that? First, we must create an account with admin-level rights
    on the machine where our software will run. I would not use the generic administrator
    account found on machines; you are better off using a dedicated account.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何做到这一点？首先，我们必须在我们的软件将运行的机器上创建一个具有管理员级别权限的账户。我不会使用机器上找到的通用管理员账户；你最好使用一个专用账户。
- en: On my machine, I created an account named `MySecureAdmin`. I gave it the extremely
    safe password `P@ssw0rd!`. No, that’s not a password I would use in real life,
    but for this demonstration, it will suffice. This account is a local admin. And
    finally, my machine has the name `DennisMachine`. This is all the information
    you would need if you wanted to log in as an administrator.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，我创建了一个名为`MySecureAdmin`的账户。我给了它一个非常安全的密码`P@ssw0rd!`。不，这不是我会在现实生活中使用的密码，但在这个演示中，它足够了。这个账户是本地管理员。最后，我的机器名为`DennisMachine`。如果你想以管理员身份登录，你需要这些信息。
- en: The technique to temporarily act as another user in your application is called
    impersonating. Let me show you how that is done.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中临时充当另一个用户的技巧被称为模拟。让我向你展示如何做到这一点。
- en: 'I have created a console application and added a new class called `ImpersonationHelper`.
    The class imports two methods from the Win32 API – `LogonUser` and `CloseHandle`.
    This is their signature:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个控制台应用程序，并添加了一个名为`ImpersonationHelper`的新类。该类从Win32 API中导入了两个方法——`LogonUser`和`CloseHandle`。这是它们的签名：
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `LogonUser` API resides in the “`advapi32.dll"` DLL, while the `CloseHandle`
    API can be found in `"kernel32.dll"`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogonUser` API位于“`advapi32.dll`”DLL中，而`CloseHandle` API可以在“`kernel32.dll`”中找到。'
- en: 'Next, I declare two constants that we will need later on:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我声明两个我们稍后会用到的常量：
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That is all we need to start impersonating. This is the code that does that:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们开始模拟所需的所有内容。这是执行该操作的代码：
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let me explain what is going on here.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我来解释这里发生了什么。
- en: The method gets all the required information to log into Windows – the username,
    password, and domain. We also give it the code we want to run under these credentials
    in the form of an `Action`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法获取登录Windows所需的所有信息——用户名、密码和域。我们还以`Action`的形式给它提供了在这些凭据下运行的代码。
- en: We call `LogonUser()` and give it the username, domain, and password. Then,
    we specify the login type; we give it `LOGON32_LOGON_BATCH`. This type is used
    for batch servers. Batch servers execute code on behalf of a user without their
    intervention. In contrast, a standard login would use `LOGON32_LOGON_INTERACTIVE`.
    The `BATCH` option results in higher performance, which is very convenient for
    us. After this, we give it the login provider and instruct it to use the default
    provider by passing `LOGON32_PROVIDER_DEFAULT`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`LogonUser()`并给它用户名、域和密码。然后，我们指定登录类型；我们给它`LOGON32_LOGON_BATCH`。这种类型用于批处理服务器。批处理服务器代表用户执行代码而不需要他们的干预。相比之下，标准登录会使用`LOGON32_LOGON_INTERACTIVE`。`BATCH`选项导致性能更高，这对我们来说非常方便。之后，我们给它登录提供者，并指示它使用默认提供者，通过传递`LOGON32_PROVIDER_DEFAULT`。
- en: If all goes well, we will get a pointer in `SafeAccessTokenHandle`. If it does
    not work, we get an error.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将在`SafeAccessTokenHandle`中得到一个指针。如果它不起作用，我们会得到一个错误。
- en: With that handle, we can call `WindowsIdentity.RunImpersonated()`, which in
    turn calls our action.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个句柄，我们可以调用`WindowsIdentity.RunImpersonated()`，它反过来调用我们的操作。
- en: Do not forget to call `Dispose()` on the handle!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在句柄上调用`Dispose()`！
- en: 'Using this code is straightforward:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码很简单：
- en: '[PRE24]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code uses our new class to temporarily log in as another user. But before
    that, it shows the current username. I do the same in the `Action`, but the results
    will differ. We are now logged in as the new user, which should also be shown
    on the screen.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用我们新的类临时以另一个用户的身份登录。但在那之前，它显示了当前的用户名。我在`Action`中也做了同样的事情，但结果会有所不同。我们现在以新用户登录，这应该也会显示在屏幕上。
- en: There is no need to log out – the call to `LogonUser()` doesn’t alter the logged-in
    state of that user; it is just required to get the handle. The moment we dispose
    of the handle, the impersonation also terminates. This means we are now back operating
    under the standard credentials. Run this sample and see what happens.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要注销——对`LogonUser()`的调用不会改变该用户的登录状态；它只是获取句柄所必需的。当我们销毁句柄时，模拟也会终止。这意味着我们现在正在使用标准凭据进行操作。运行这个示例并看看会发生什么。
- en: Impersonation is another nice tool in your toolbelt, but use it sparingly. Only
    increase the trust level in your applications if you absolutely need it. Oh, and
    I am sure I do not need to remind you that storing usernames and passwords in
    plain code in your application is terrible, especially if they belong to admin-level
    users. Right?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是您工具箱中的另一个好工具，但请谨慎使用。只有在绝对需要的情况下才提高您应用程序的信任级别。哦，我相信我肯定不需要提醒你，在您的应用程序中以明文形式存储用户名和密码是可怕的，尤其是如果它们属于管理员级别的用户。对吧？
- en: Many developers, by default, assume their code needs admin-level privileges.
    After reading this section, you now know better. We discussed the situations where
    admin-level is required, but please remember that less is more, especially regarding
    privilege levels! And if you need admin-level privileges in your code, you know
    how to take care of that temporarily before returning to a normal level.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者默认认为他们的代码需要管理员级别的权限。在阅读本节之后，你现在应该更清楚。我们讨论了需要管理员级别权限的情况，但请记住，少即是多，尤其是在权限级别方面！如果您需要在代码中拥有管理员级别的权限，您知道如何在返回到正常级别之前临时处理它。
- en: How to transmit network data securely
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何安全地传输网络数据
- en: As we have seen, keeping data sensitive on your machine is hard. But things
    get even more complicated once we leave the safe haven of the machine we control
    and venture into the wasteland of networks.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，在您的机器上保持数据敏感是困难的。但一旦我们离开我们控制的机器的安全避风港，进入网络的荒野，事情就变得更加复杂。
- en: I probably do not have to remind you that you should never use a public website
    that uses an HTTP connection instead of an HTTPS connection. The “S,” after all,
    stands for “Secure.” That is what we want – we want our data to be encrypted,
    and we want to be confident that the server we talk to is secure and belongs to
    the party we think it belongs to.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能不需要提醒你，永远不要使用使用HTTP连接而不是HTTPS连接的公共网站。毕竟，“S”代表“Secure”（安全）。这正是我们想要的——我们希望我们的数据被加密，并且我们希望确信我们与之交谈的服务器是安全的，并且属于我们认为它属于的那一方。
- en: The same applies to our code – if we talk to an outside system, we want to ensure
    that our data is not being tampered with or intercepted. That also applies to
    other systems when they connect to us – we want to give those users the same sense
    of security. How do we achieve that? The answer is simple – we do the same as
    those HTTPS servers. The next question is, how do we implement that? And that
    is slightly more complicated. But don’t worry – I will walk you through it step
    by step.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于我们的代码——如果我们与外部系统通信，我们希望确保我们的数据没有被篡改或拦截。这也适用于其他系统当我们连接到它们时——我们希望给那些用户提供相同的安全感。我们如何实现这一点？答案是简单的——我们与那些
    HTTPS 服务器做同样的事情。下一个问题是，我们如何实现这一点？这稍微复杂一些。但别担心——我会一步一步地带你走过这个过程。
- en: How HTTPS works
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTPS是如何工作的
- en: Let me ask you a question. How do you know you can trust the website you visit?
    Just because it says HTTPS in the address bar? But what does that mean? How can
    that be a guarantee? To answer that, we need to look at what HTTPS actually means.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我问你一个问题。你怎么知道你可以信任你访问的网站？仅仅因为地址栏里写着 HTTPS 吗？但这究竟意味着什么？这能作为保证吗？为了回答这个问题，我们需要看看
    HTTPS 实际上是什么意思。
- en: '**HTTPS** stands for **Hyper Text Transport Protocol Secure**. This is a variation
    of regular HTTP traffic – it has added security. Let’s examine the flow:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTPS** 代表 **超文本传输协议安全**。这是常规 HTTP 流量的一个变体——它增加了安全性。让我们看看流程：'
- en: 'In your browser, you enter a URL: [https://www.microsoft.com](https://www.microsoft.com).'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中，你输入一个 URL：[https://www.microsoft.com](https://www.microsoft.com)。
- en: The browser resolves the domain name to an IP address.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器将域名解析为 IP 地址。
- en: The client initiates a TCP connection with the server using a three-way handshake
    (SYN, SYN-ACK, and ACK).
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端使用三次握手（SYN、SYN-ACK 和 ACK）与服务器建立 TCP 连接。
- en: 'The client sends a `"ClientHello"` message to the server. This message includes
    the following:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器发送一个 `"ClientHello"` 消息。此消息包括以下内容：
- en: Supported TLS versions
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的 TLS 版本
- en: Supported cipher suites
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的加密套件
- en: Supported compression methods
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的压缩方法
- en: A randomly generated value (client random)
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个随机生成的值（客户端随机）
- en: Session IDs and extensions (optional)
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话 ID 和扩展（可选）
- en: 'The server then responds with a `"ServerHello"` message, which includes the
    following:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器随后响应一个 `"ServerHello"` 消息，其中包含以下内容：
- en: The chosen TLS version
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择的 TLS 版本
- en: The chosen cipher suite
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择的加密套件
- en: The chosen compression method
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择的压缩方法
- en: A randomly generated value (server random)
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个随机生成的值（服务器随机）
- en: The session ID (if supported and desired)
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话 ID（如果支持且需要）
- en: The server sends its digital certificate, including its public key and a digital
    signature, from a trusted certificate authority.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器从受信任的证书机构发送其数字证书，包括其公钥和数字签名。
- en: Then, the server may (if required) send a `"``ServerKeyExchange"` message.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果需要，服务器可能会发送一个 `"ServerKeyExchange"` 消息。
- en: After that, the server requests a client certificate for mutual authentication.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，服务器请求客户端证书以进行相互认证。
- en: Finally, the server sends a `"ServerHelloDone"` message, indicating that this
    is the end of the handshake.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，服务器发送一个 `"ServerHelloDone"` 消息，表示握手结束。
- en: The client then optionally sends its own certificate (if requested).
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，客户端可以选择发送自己的证书（如果请求）。
- en: The client sends a `"ClientKeyExchange"` message. The contents depend on the
    algorithm chosen. For instance, if RSA is chosen, the client encrypts a pre-master
    secret with the server’s public key and sends that to the server.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送一个 `"ClientKeyExchange"` 消息。内容取决于选择的算法。例如，如果选择 RSA，客户端将使用服务器的公钥加密预主密钥并发送给服务器。
- en: The client sends a `"CertificateVerify"` message to prove it owns the client
    certificate. This involves signing a hash of the handshake messages using the
    client’s private key.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送一个 `"CertificateVerify"` 消息来证明它拥有客户端证书。这涉及到使用客户端的私钥对握手消息的哈希进行签名。
- en: Both parties then generate the session keys (symmetric keys) for encryption
    and authentication, using the pre-master secret and the random values exchanged
    earlier.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双方随后使用预主密钥和之前交换的随机值生成会话密钥（对称密钥）以进行加密和认证。
- en: The client then sends a `"ChangeCipherSpec"` message to inform the server that,
    from now on, all messages will be encrypted using the negotiated keys and algorithms.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，客户端向服务器发送一个 `"ChangeCipherSpec"` 消息，通知服务器从现在开始，所有消息都将使用协商的密钥和算法进行加密。
- en: The server also sends a `"``ChangeCipherSpec"` message.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器还发送一个 `"ChangeCipherSpec"` 消息。
- en: The client sends a `"Finished"` message, which is a hash of all the handshake
    messages encrypted with the session key.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送一个 `"Finished"` 消息，这是一个使用会话密钥加密的所有握手消息的哈希值。
- en: The server responds with its `"Finished"` key, with the same sort of information.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器以相同的格式响应其 `"Finished"` 密钥。
- en: From now on, the client and the server can use the keys and algorithms to encrypt
    and decrypt the data flow.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，客户端和服务器可以使用密钥和算法来加密和解密数据流。
- en: If you think this sounds complicated, you are right. The good news is that we
    do not have to worry about this. All of the classes in the BCL dealing with HTTP
    handle this for us. All you have to do is connect to a secure server, specify
    that you want to use SSL, and you are good to go.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这听起来很复杂，你是对的。好消息是，我们不必担心这个问题。BCL 中处理 HTTP 的所有类都为我们处理了这些问题。你所要做的就是连接到安全的服务器，指定你想使用
    SSL，然后就可以开始了。
- en: Certificates and certificate authorities
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证书和证书颁发机构
- en: The preceding steps outline how the client and server exchange keys securely.
    However, a key question remains – how do they know they can trust each other?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤概述了客户端和服务器如何安全地交换密钥。然而，一个关键问题仍然存在——他们如何知道可以相互信任？
- en: 'The answer to that question lies in the use of certificates. A certificate
    is a digital document containing information about the certificate’s owner. It
    includes the following information:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案在于证书的使用。证书是一个包含有关证书所有者信息的数字文档。它包括以下信息：
- en: '**Subject**: The entity that the certificate represents (for instance, the
    website’s domain name)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：证书代表的实体（例如，网站的域名）'
- en: '**Issuer**: Who issued the certificate'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颁发者**：谁颁发的证书'
- en: '**Public key**: The public key of the entity'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公钥**：实体的公钥'
- en: '**Validity period**: The date range in which the certificate is valid'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效期**：证书有效的日期范围'
- en: '**Serial number**: A unique identifier for the certificate'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列号**：证书的唯一标识符'
- en: '**Signature**: The digital signature of the issuer, verifying that the certificate
    is genuine and has not been tampered with'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名**：颁发者的数字签名，验证证书的真实性，并确保未被篡改'
- en: If you get a certificate from a website, you can use that to verify that the
    site you are connecting to is indeed the one it claims to be. If the information
    on the certificate doesn’t match what is expected, you had better not use that
    site.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从一个网站获取证书，你可以使用它来验证你连接到的网站确实是它所声称的那个。如果证书上的信息与预期不符，你最好不要使用该网站。
- en: But how can you be sure that the certificate is valid? This question leads us
    to the last part of the SSL infrastructure – certificate authorities.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 但你如何确保证书是有效的？这个问题引导我们来到 SSL 基础设施的最后一部分——证书颁发机构。
- en: A certificate has to be obtained from a third party. These companies sell certificates,
    but only after they have verified that the one requested a certificate is who
    they say they are. We call these companies **certificate authorities** (**CAs**).
    These authorities are regularly audited to make sure they can be trusted. This
    starts a whole chain – a CA has its own certificate. However, that certificate
    is a root certificate; it is implicitly trusted. No organization guarantees the
    CA’s certificate is valid. But if we trust that root certificate, we can assume
    that all certificates signed with that root certificate are also safe. Then, we
    can use the secondary certificate to sign another certificate. We can build a
    whole tree of trusted certificates, all of which can be traced back to the CA
    that issued the original certificate.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 证书必须从第三方获取。这些公司出售证书，但只有在他们验证请求证书的人确实是他们所声称的人之后才会这样做。我们称这些公司为**证书颁发机构**（**CAs**）。这些机构会定期接受审计，以确保它们可以信赖。这启动了一个整个链条——CA
    有自己的证书。然而，那个证书是根证书；它是隐含受信任的。没有组织保证 CA 的证书是有效的。但如果我们信任那个根证书，我们可以假设所有使用该根证书签发的证书也都是安全的。然后，我们可以使用二级证书来签发另一个证书。我们可以构建一个整个受信任的证书树，所有这些证书都可以追溯到颁发原始证书的
    CA。
- en: Windows keeps track of all the trusted root certificates and stores them on
    the local machine. That way, the software can compare the hashes with the data
    it receives from the HTTPS server and make sure the certificate is secure.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 跟踪所有受信任的根证书，并将它们存储在本地计算机上。这样，软件可以将哈希值与从 HTTPS 服务器接收到的数据进行比较，确保证书的安全性。
- en: 'To see these root certificates, run the `mmc.exe` command on your machine.
    Then, press *CTRL* + *M* to add the **Certificates** snap-in. Open the tree on
    the left to see all the trusted root certificate authorities. This is what it
    looks like on my machine:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些根证书，请在您的机器上运行`mmc.exe`命令。然后，按*CTRL* + *M*添加**证书**插件。展开左侧的树形结构以查看所有受信任的根证书权威机构。这是我机器上的样子：
- en: "![Figure 1\uFEFF2.1: Root certificates in Windows](img/B20924_13_1.jpg)"
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1：Windows中的根证书](img/B20924_13_1.jpg)'
- en: 'Figure 12.1: Root certificates in Windows'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：Windows中的根证书
- en: Your list will undoubtedly differ from mine, but these are all trusted root
    certificates. Windows regularly updates this list to make sure it is still valid.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您的列表无疑会与我的不同，但这些都是受信任的根证书。Windows会定期更新这个列表，以确保其仍然有效。
- en: You must get a certificate from one of these CA organizations to set up a HTTPS
    server. They all have a slightly different process, so I suggest you investigate
    some of them to see if they are suitable for you. It doesn’t matter which CA you
    use; all certificates suit your purposes. Some are faster than others, and others
    are cheaper than others. Just pick what you feel is the best option for you.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须从这些CA机构之一获得证书才能设置HTTPS服务器。它们的过程略有不同，所以我建议您调查其中一些，看看它们是否适合您。您使用哪个CA都无关紧要；所有证书都适合您的目的。有些比其他更快，有些比其他更便宜。只需选择您认为最适合您的选项即可。
- en: Be aware of free certificates!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意免费证书！
- en: I will be very clear about this – there are no free certificates to be had at
    the time of writing. A few CAs issued free certificates, but that doesn’t happen
    anymore. The demands for verification have significantly increased; the CA needs
    to be more thorough than ever to combat cybercrime. And that costs money. If you
    see a CA that offers a free certificate, do not fall for it. Remember that if
    something sounds too good to be true, it probably is. Some CA organizations provide
    a free certificate, but they have other demands. You have to build your software
    on their pipelines, or you have to host with them. Ultimately, you still pay for
    it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我会非常明确地说明这一点——在撰写本文时，没有免费的证书可以获得。一些CA机构发行了免费证书，但这已经不再发生了。验证的需求显著增加；CA需要比以往任何时候都要更加彻底，以对抗网络犯罪。这需要花钱。如果您看到提供免费证书的CA，请不要上当。记住，如果某件事听起来好得令人难以置信，那么它可能就是真的。一些CA组织提供免费证书，但它们有其他要求。您必须在他们的管道上构建您的软件，或者您必须与他们一起托管。最终，您仍然需要为此付费。
- en: So, now we know what a certificate is and how to get one. But let’s be honest
    – if you want to play around with certificates or are still in development, you
    might not be ready to purchase a certificate. If that is your situation, then
    I have good news. There is a free alternative – you can make your own certificate!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们知道了证书是什么以及如何获取一个。但让我们说实话——如果您想玩证书或者还在开发中，您可能还没有准备好购买证书。如果这是您的情况，那么我有好消息。有一个免费的选择——您可以自己创建证书！
- en: Creating a development certificate
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建开发证书
- en: Yes, you can create your own certificate. But this is just for experimental
    or development purposes. You cannot use it in a production system; the verification
    will fail, since your certificate is not vouched for by a CA.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，您可以创建自己的证书。但这只是为了实验或开发目的。您不能在生产系统中使用它；验证将失败，因为您的证书没有得到CA的背书。
- en: The tools to create a certificate are part of the SDK installed with VS. Let’s
    make a certificate!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 创建证书的工具是随VS安装的SDK的一部分。让我们来创建一个证书吧！
- en: 'In a developer command prompt or PowerShell terminal, enter the following command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发命令提示符或PowerShell终端中，输入以下命令：
- en: '[PRE25]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`MakeCert`, part of the SDK, is the tool to create a certificate. There are
    many options, but we do not need most of them. I have given you the minimum we
    need for our purpose. Let’s investigate what we did by looking at the parameters:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeCert`是SDK的一部分，是创建证书的工具。有很多选项，但我们不需要大多数它们。我已经为您提供了我们所需的最小选项。让我们通过查看参数来调查我们做了什么：'
- en: '| **Parameter** | **Description** |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-r` | This means the certificate is self-signed and not signed by a CA.
    |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `-r` | 这意味着证书是自签名的，没有由CA签名。 |'
- en: '| `-``pe` | This marks the private key as exportable. The private and public
    keys are all part of the certificate, so you need this option if you want a copy
    of the private key. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `-pe` | 这将私钥标记为可导出。私钥和公钥都是证书的一部分，因此如果您想要私钥的副本，则需要此选项。 |'
- en: '| `-``ss PrivateCertStore` | The specifies the certificate store where the
    generated certificate will be placed. In our case, we use `PrivateCertStore`,
    one of those entries in the Management console we looked at earlier. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `-ss PrivateCertStore` | 这指定了将放置生成的证书的证书存储。在我们的情况下，我们使用`PrivateCertStore`，这是我们在早期查看的管理控制台中的条目之一。|'
- en: '| `-``n "CN=localhost"` | This is the `localhost` (**CN** means **common name**)
    so that the clients know which domain this certificate belongs to. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `-n "CN=localhost"` | 这是`localhost`（**CN**表示**通用名称**），这样客户端就知道这个证书属于哪个域名。|'
- en: '| `-``sv testcer.pvk` | We marked the private key as exportable; this option
    does the export. The private key is stored in the `testcer.pvk` file. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `-sv testcer.pvk` | 我们将私钥标记为可导出；此选项执行导出。私钥存储在`testcer.pvk`文件中。|'
- en: '| `testcer.cer` | The filename of the certificate |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `testcer.cer` | 证书的文件名 |'
- en: 'Table 12.2: Parameters for MakeCert'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.2：MakeCert的参数
- en: If you run the `MakeCert` command, you will be asked to enter passwords. Make
    sure you remember them and store them somewhere secure!
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`MakeCert`命令，你将被要求输入密码。请确保你记住它们并将它们存储在安全的地方！
- en: This command results in two files – `testcer.cer` (the certificate) and `testcer.pvk`
    (the private key). Make sure you treat these files as confidential; they contain
    your private keys.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会生成两个文件——`testcer.cer`（证书）和`testcer.pvk`（私钥）。请确保将这些文件视为机密文件；它们包含你的私钥。
- en: 'The certificate can now be used, but not for everything we want to use it for.
    Later, we will use the certificate to encrypt data streams, but that will require
    a different format. These tools need a `pfx` format. Luckily, converting a `.cer`
    file to a `.pfx` file is easy enough. Just enter this command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 证书现在可以使用了，但并非适用于我们想要使用的所有情况。稍后，我们将使用证书来加密数据流，但这需要不同的格式。这些工具需要`pfx`格式。幸运的是，将`.cer`文件转换为`.pfx`文件足够简单。只需输入以下命令：
- en: '[PRE26]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `pvk2pfx` tool takes the exported private key and the certificate and converts
    them into a `.pfx` file. The parameters speak for themselves.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`pvk2pfx`工具将导出的私钥和证书转换为`.pfx`文件。参数不言自明。'
- en: 'The certificate we created is now stored in the certificate store under the
    `PrivateCertStore` section. But we also need to store the newly generated `.pfx`
    file in the certificate store for later use. To do this, enter the following command:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的证书现在存储在证书存储的`PrivateCertStore`部分。但我们也需要将新生成的`.pfx`文件存储在证书存储中，以供以后使用。为此，请输入以下命令：
- en: '[PRE27]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case, the `certutil` command invoked another handy tool to take the
    new `testcer.pfx` file and store it in the right place.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`certutil`命令调用了另一个有用的工具，将新的`testcer.pfx`文件存储在正确的位置。
- en: And that is all there is to it. We now have our own certificate, so let’s secure
    some network traffic!
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单。我们现在有了自己的证书，所以让我们保护一些网络流量！
- en: Securing TCP streams
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护TCP流
- en: If you have a web server, such as IIS, you can import the `.pfx` file there.
    That way, you can use HTTPS on your local network. Again, this is not SSL; other
    clients will not accept that self-signed certificate. It is for development only.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个Web服务器，例如IIS，你可以在那里导入`.pfx`文件。这样，你可以在本地网络上使用HTTPS。再次强调，这不是SSL；其他客户端不会接受这个自签名证书。这仅用于开发。
- en: However, I am not currently interested in setting up a HTTPS server. I am more
    concerned about the other network communication types we discussed previously.
    For instance, how can we secure simple, straightforward TCP communications? If
    we want to use sockets, how do we secure that? The answer is to use SSL, as we
    have seen with HTTPS. Let’s build some secure code!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我现在对设置HTTPS服务器不感兴趣。我更关心我们之前讨论的其他网络通信类型。例如，我们如何保护简单的直接TCP通信？如果我们想使用套接字，我们该如何保护？答案是使用SSL，就像我们在HTTPS中看到的那样。让我们构建一些安全代码！
- en: I have created two console applications. One is a server waiting for incoming
    TCP connections; the other is the client connecting to that server.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了两个控制台应用程序。一个是等待传入TCP连接的服务器；另一个是连接到该服务器的客户端。
- en: 'Let’s have a look at the server code first. I have created a new class called
    `SecureServer`. This class gets a constructor that takes the required information
    to set up the server. It looks like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看服务器代码。我创建了一个名为`SecureServer`的新类。这个类有一个构造函数，用于设置服务器所需的信息。它看起来是这样的：
- en: '[PRE28]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We pass the file path to the certificate we just created and the password in
    the port that the TCP socket listens to (I told you to write that down, didn’t
    I?). We store the port number in a local variable and use the other two variables
    to create an instance of the `X509Certificate2` class.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递刚刚创建的证书的文件路径和监听 TCP 套接字的端口的密码（我告诉你要记下来，对吧？）。我们将端口号存储在一个局部变量中，并使用其他两个变量来创建
    `X509Certificate2` 类的实例。
- en: 'Next is the method that starts the server. We investigated that before (in
    [*Chapter 8*](B20924_09.xhtml#_idTextAnchor181), *The One with the Network Navigation*),
    so there shouldn’t be any surprises here. Here it is:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是启动服务器的那个方法。我们之前已经调查过这个方法了（在 [*第 8 章*](B20924_09.xhtml#_idTextAnchor181)，*网络导航那章*），所以这里不应该有任何惊喜。下面是它：
- en: '[PRE29]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We create an instance of `TcpListener`, tell it to use any IP address on the
    machine, and give it the correct port. Then, we call `Start()` to accept incoming
    connections. In a never-ending loop, we wait for a client to connect. If that
    happens, we accept the connection with a call to `AcceptSocketAsync()` and pass
    the handling of the connection to a method called `HandleClientConnection()`.
    Let’s look at that one next.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `TcpListener` 的实例，告诉它使用机器上的任何 IP 地址，并给它正确的端口。然后，我们调用 `Start()` 来接受传入的连接。在一个永无止境的循环中，我们等待客户端连接。如果发生这种情况，我们通过调用
    `AcceptSocketAsync()` 接受连接，并将连接的处理传递给名为 `HandleClientConnection()` 的方法。让我们看看下一个方法。
- en: 'The first half of the method looks like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的前半部分看起来是这样的：
- en: '[PRE30]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Instead of using a normal stream, we use a specialized one called `SslStream`.
    This takes `NetworkStream` and a parameter, indicating whether the stream should
    be kept open when we finish it (we don’t want that, so we give it a `False`).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用普通的流，而是使用一个称为 `SslStream` 的专用流。这个流接受 `NetworkStream` 和一个参数，表示我们完成时是否应该保持流打开（我们不想这样，所以我们给它一个
    `False`）。
- en: Then, we call `AuthenticateAsServerAsync()` on that `SslStream`, giving it the
    certificate, tell it that we do not require a client certificate, also tell it
    that we want to use TLS version 1.2, and finally, inform the method that we want
    to check the certificate revocation (hence the `True`). This one line of code
    makes sure the server does all the steps needed for it to set up a secure connection.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在那个 `SslStream` 上调用 `AuthenticateAsServerAsync()`，给它证书，告诉它我们不需要客户端证书，也告诉它我们想使用
    TLS 版本 1.2，最后，通知该方法我们想检查证书吊销（因此是 `True`）。这一行代码确保服务器完成所有必要的步骤来设置安全连接。
- en: 'The rest of the method is straightforward – we read data coming in and display
    it. This is the rest of that method:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的其余部分很简单——我们读取传入的数据并显示。这是该方法的其余部分：
- en: '[PRE31]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And that is all! Well, almost – we need to use this method as well. But that
    is even simpler. In the `Main()` method, use this code:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！嗯，几乎是这样——我们还需要使用这个方法。但那甚至更简单。在 `Main()` 方法中，使用以下代码：
- en: '[PRE32]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With all this, we have a working and secure socket server!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些，我们就有了一个工作且安全的套接字服务器！
- en: 'Next up, the client! For the client, I did a similar thing. I added a new class
    called `SecureClient` with the following constructor:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是客户端！对于客户端，我做了类似的事情。我添加了一个名为 `SecureClient` 的新类，其构造函数如下：
- en: '[PRE33]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This constructor takes two parameters – the name of the server and the port
    it wants to connect to.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数接受两个参数——服务器的名称和它想要连接的端口。
- en: 'Next, we define a method called `ConnectAsync()` that allows the client to
    connect:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个名为 `ConnectAsync()` 的方法，允许客户端连接：
- en: '[PRE34]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This method starts with familiar code – we create an instance of `TcpClient`
    and give it the server and port. After that, we open `NetworkStream` from that
    `TcpClient`. But then things get more interesting – we create a new instance of
    the `SslStream` class, giving it `NetworkStream`, the same `False` that indicates
    that we do not want to keep the stream open when we are done with it, and a callback
    method called `ValidateServerCertificate`. After that, we call `AuthenticateAsClientAsync()`
    to make sure the client and the server exchange messages, as described previously.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法从熟悉的代码开始——我们创建了一个 `TcpClient` 的实例，并给它服务器和端口。然后，我们从那个 `TcpClient` 打开 `NetworkStream`。但接下来事情变得更有趣——我们创建了一个新的
    `SslStream` 类的实例，给它 `NetworkStream`，同样的 `False` 表示我们完成时不想保持流打开，以及一个名为 `ValidateServerCertificate`
    的回调方法。之后，我们调用 `AuthenticateAsClientAsync()` 来确保客户端和服务器交换消息，如之前所述。
- en: The rest of this method is nothing special – we just write the bytes to the
    stream.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的其余部分没有什么特别之处——我们只是将字节写入流。
- en: 'Let’s look at the `ValidateServerCertificate()` callback method next:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `ValidateServerCertificate()` 回调方法：
- en: '[PRE35]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method is called when we create `SslStream` and is part of validating the
    server’s certificate. The method itself is straightforward – we just check to
    see whether there are any errors in the `SslPolicyErrors` enum. If there are,
    we return `false`. This is picked up by the `SslStream` class, which will raise
    an exception.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `SslStream` 时会调用此方法，它是验证服务器证书的一部分。该方法本身很简单——我们只是检查 `SslPolicyErrors` 枚举中是否有任何错误。如果有，我们返回
    `false`。这会被 `SslStream` 类捕获，它将引发异常。
- en: A developers’ trick – simplify your development
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者的技巧——简化你的开发
- en: If you are developing a solution like this but do not have a valid certificate,
    there is a quick hack you can use. Change the validation method to always return
    `True`. That way, your client will accept all sorts of certificates, regardless
    of their validity. Just do not use this technique in production code!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发这样的解决方案但没有有效的证书，你可以使用一个快速黑客技巧。将验证方法更改为始终返回 `True`。这样，你的客户端将接受所有类型的证书，无论其有效性如何。但请记住，不要在生产代码中使用这种技术！
- en: 'Using this class is easy. This is the code:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类很简单。这是代码：
- en: '[PRE36]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Just a word of warning – this is only for development purposes. The code itself
    is fine for any scenario, but the certificate we created is not. We signed it
    ourselves, so no real client should accept it. Next, we specified that the server’s
    name is `"localhost`”. This apparently only works on your machine, not across
    a network. You could change that when you create the certificate, of course.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 只提醒一下——这只是为了开发目的。代码本身适用于任何场景，但我们创建的证书不行。我们亲自签名，所以没有任何真正的客户端应该接受它。接下来，我们指定服务器的名称是
    `"localhost"`。显然，这只能在你的机器上工作，不能在网络中工作。当然，你可以在创建证书时更改它。
- en: And there you have it – a working TCP client using a secure channel. You have
    made it much harder, if not impossible, for a hacker to eavesdrop and listen in
    on your communications!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，你得到了一个使用安全通道工作的 TCP 客户端。你让黑客窃听和监听你的通信变得非常困难，甚至不可能！
- en: Next steps
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: I have to be honest with you. We only touched briefly on the subject of security.
    There are hundreds, if not thousands, of books on this topic. But the information
    I gave you should help you get in the right mindset. Remember that a system is
    only as secure as the weakest link. And security is something that you should
    consider from the beginning, not added as an afterthought.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须对你坦诚。我们只是简要地触及了安全这个主题。关于这个主题有成百上千，甚至可能成千上万的书籍。但我提供给你的信息应该能帮助你进入正确的思维模式。记住，一个系统只有在其最薄弱的环节上才是安全的。而且，安全是你从一开始就应该考虑的事情，而不是事后才添加的。
- en: One final warning – do not try to reinvent the wheel and come up with your own
    algorithms. Your solutions are never as good as what teams of hundreds of crypto
    and security experts can come up with. Trust them to do their job so that you
    can focus on yours.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个警告——不要试图重新发明轮子，提出你自己的算法。你的解决方案永远不如成百上千的加密和安全专家团队所能提出的那么好。相信他们能做好他们的工作，这样你就可以专注于你的工作了。
- en: 'That being said, we did cover a lot of ground. We discussed the following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们确实覆盖了很多内容。我们讨论了以下内容：
- en: The need for security in modern applications
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代应用程序中安全的必要性
- en: How data is represented in memory and how to protect against that
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据如何在内存中表示以及如何保护它
- en: How to handle keys in Azure Key Vault but also in simple things such as environment
    variables
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Azure Key Vault 中处理密钥，以及在简单事物如环境变量中处理密钥
- en: How to deal with the proper privilege level
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理适当的权限级别
- en: How to secure your network communications
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保你的网络通信安全
- en: However, there is one thing that we mentioned briefly but did not cover in detail
    – how to pass credentials securely from our development machine to a production
    environment. How do we ensure the environment variables are set when deploying
    our solutions? This and other questions are part of the deployment strategies
    we can use, which happens to be the topic of the next chapter!
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们只是简要提及但未详细说明的一件事——如何安全地从我们的开发机器将凭据传递到生产环境。我们如何确保在部署我们的解决方案时环境变量被设置？这些问题是我们可以使用的一些部署策略的一部分，恰好也是下一章的主题！
