- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: The Intricacies of Rolling Out TDD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推广TDD的复杂性
- en: I have frequently seen developers putting their efforts into trying to convince
    the business to follow TDD or adopt unit tests. In fact, this is a situation in
    which I have often found myself, and for this reason, I want to share my experience
    with you in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常看到开发者投入精力试图说服业务遵循TDD或采用单元测试。实际上，这是我经常遇到的情况，因此我想在本章中与你分享我的经验。
- en: After reading this book, you might feel strongly about implementing TDD in your
    direct team or large organization to reap the quality benefits. So far, so good.
    The second stage is doing this in a structured manner and being prepared for the
    business’ counter-arguments and rejections.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这本书之后，你可能会强烈地想要在你的直接团队或大型组织中实施TDD以获得质量效益。到目前为止，一切顺利。第二阶段是以一种结构化的方式进行，并准备好应对业务的反对和拒绝。
- en: 'We will highlight the challenges and guide you through the process of convincing
    your business and team to take the TDD approach. In this chapter, we will discuss
    the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将突出挑战，并指导你通过说服你的业务和团队采用TDD方法的过程。在本章中，我们将讨论以下主题：
- en: Technical challenges
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术挑战
- en: Team challenges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队挑战
- en: Business challenges
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务挑战
- en: TDD arguments and misconceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD论点和误解
- en: After reading this chapter, you will be ready to present your team and/or business
    with a plan to move forward with TDD.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，你将准备好向你的团队和/或业务展示一个计划，以继续实施TDD。
- en: Technical challenges
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术挑战
- en: 'There is a set of technical and business challenges an organization must overcome
    before adopting TDD. Here, we will cover the technical challenges, and in the
    next section, we will consider the team challenges and then the wider organization
    challenges (business challenges). We will start with a diagram to explain the
    workflow of rolling out TDD in your organization:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在采用TDD之前，组织必须克服一系列技术和业务挑战。在这里，我们将涵盖技术挑战，在下一节中，我们将考虑团队挑战，然后是更广泛的组织挑战（业务挑战）。我们将从一个图表开始，以解释在你的组织中推广TDD的工作流程：
- en: '![Figure 13.1 – Technical challenges when planning to move to TDD  ](img/Figure_13.1_B18370.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 计划迁移到TDD时的技术挑战](img/Figure_13.1_B18370.jpg)'
- en: Figure 13.1 – Technical challenges when planning to move to TDD
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 计划迁移到TDD时的技术挑战
- en: We will go through the diagram in the next sub-sections, so let’s start.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中逐步分析这个图表，所以让我们开始吧。
- en: Greenfield or brownfield?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绿色地带或棕色地带？
- en: If you are working on a brownfield project, the technical challenges were well
    presented in the previous chapter, so I will not go further into these challenges.
    To introduce TDD, you need to consider the effort, suitability, and alternatives.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在从事一个棕色地带项目，前一章已经很好地介绍了技术挑战，所以我就不再深入这些挑战了。为了引入TDD，你需要考虑努力程度、适用性和替代方案。
- en: If you are starting a new project (a greenfield project), then you are in luck.
    You can go ahead with your plan.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在启动一个新项目（一个绿色地带项目），那么你很幸运。你可以继续你的计划。
- en: Tools and infrastructure
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具和基础设施
- en: Today, with the availability of the cloud, having an infrastructure to run your
    **continuous integration** (**CI**) pipeline is easy and cheap. However, some
    organizations have restrictions on using the cloud and you might struggle to get
    a CI server.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着云服务的可用性，拥有运行你的**持续集成**（**CI**）管道的基础设施既容易又便宜。然而，一些组织对使用云有限制，你可能会发现很难获得CI服务器。
- en: If you don’t have a CI server in place, then at the risk of sounding pessimistic,
    doing TDD is doomed to fail. This is because developers will break the unit tests
    and you will have them disabled or failing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有设置CI服务器，那么听起来可能有些悲观，但进行TDD注定会失败。这是因为开发者可能会破坏单元测试，导致测试被禁用或失败。
- en: Some developers also like to invest in tools such as **JetBrains ReSharper**
    for its good-quality test runner and refactoring capabilities, but this is optional.
    Also, you may want to consider JetBrains Rider as it has all the capabilities
    of ReSharper, as discussed in [*Chapter 1*](B18370_01.xhtml#_idTextAnchor014)
    of this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者也喜欢投资于像**JetBrains ReSharper**这样的工具，因为它有一个高质量的测试运行器和重构功能，但这不是必需的。此外，你可能还想考虑JetBrains
    Rider，因为它具有ReSharper的所有功能，正如本书[*第1章*](B18370_01.xhtml#_idTextAnchor014)中讨论的那样。
- en: However, if you are using MS Visual Studio Professional 2022 or later, you already
    have a good tool for a proper TDD process.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你正在使用MS Visual Studio Professional 2022或更高版本，你已经有了一个适合TDD过程的良好工具。
- en: The technical challenges are not all you need to think about. Consider also
    your team and its readiness to embrace TDD and then your business challenges.
    Let’s continue with the team challenges.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 技术挑战并不是你需要考虑的全部。还要考虑你的团队是否准备好接受TDD，以及你的业务挑战。让我们继续讨论团队挑战。
- en: Team challenges
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队挑战
- en: 'If you are a solo developer working on a project, no worries, you can do whatever.
    However, most business projects are implemented by a team, so making the effort
    to use TDD is a team decision. Again, let’s start with a workflow diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个独立开发者，正在处理一个项目，那么不用担心，你可以做任何你想做的事情。然而，大多数商业项目都是由团队实施的，因此努力使用TDD是一个团队的决定。再次强调，让我们从一个工作流程图开始：
- en: '![Figure 13.2 – Team challenges when planning to move to TDD  ](img/Figure_13.2_B18370.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 计划迁移到TDD时的团队挑战](img/Figure_13.2_B18370.jpg)'
- en: Figure 13.2 – Team challenges when planning to move to TDD
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 计划迁移到TDD时的团队挑战
- en: We will go through this diagram in the next sub-sections. Let’s go through the
    points to keep in mind when planning to move your team – whether you are a developer
    wanting to influence the team or in a position where you can enforce technical
    standards.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中详细讨论这个图表。让我们回顾一下在计划让你的团队迁移时需要注意的要点——无论你是希望影响团队的开发者，还是处于可以强制执行技术标准的职位。
- en: Team experience
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 团队经验
- en: Unit testing requires DI, which in turn requires experience in OOP. Your team
    members may be unfamiliar with unit testing or may mistake unit testing with integration
    testing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试需要依赖DI（依赖注入），而这又反过来需要OOP（面向对象编程）的经验。你的团队成员可能对单元测试不熟悉，或者可能会将单元测试与集成测试混淆。
- en: Important notes
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: The xUnit and NUnit libraries are widely used to implement integration tests.
    Because they have the suffix **Unit**, developers sometimes incorrectly assume
    the written tests are unit tests. I’ve seen teams claiming they have unit tests,
    but when I inspected the code, I discovered otherwise.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit和NUnit库被广泛用于实现集成测试。因为它们有后缀**Unit**，开发者有时会错误地假设编写的测试是单元测试。我见过一些团队声称他们有单元测试，但当我检查代码时，我发现并非如此。
- en: If your team requires training in TDD, then they need to be educated on what
    it is, how to do it, and the value of TDD. I have a book in mind to recommend
    for the training, but I will leave it to you to guess which it is.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的团队需要TDD（测试驱动开发）的培训，那么他们需要了解TDD是什么，如何进行，以及TDD的价值。我心中有一本推荐的书，但我会让你来猜测是哪一本。
- en: Important notes
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: I usually ask the team to read certain material on their own before having a
    session or several sessions on the topic. Training a team can be done in many
    ways, and it is more related to your company and team culture. I also document
    the conventions and the agreement on Confluence or whatever tool the organization
    uses for documentation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常会在团队进行关于某个主题的会议或几场会议之前，要求他们自己阅读某些材料。培训一个团队可以通过许多方式完成，这更多与你的公司和团队文化相关。我还会在Confluence或其他组织用于文档的工具上记录约定和协议。
- en: It is important to have a competent developer in the team, who understands unit
    testing, is a good explainer, and can squeeze in some time, which could be you.
    This would be helpful, as your team will have questions when they start TDD.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队中有一个理解单元测试、善于解释并能抽出时间（这可能就是你）的合格开发者是很重要的。这将是有帮助的，因为当你的团队开始进行TDD时，他们会有问题。
- en: But training the team may not be an option for many reasons. Having a few members
    of the team doing unit testing and others not won’t be productive, as everyone
    is going to operate on the same code base, so having everybody trained and ready
    for TDD is a prerequisite.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于许多原因，培训团队可能不是一个选择。让团队中的一些成员进行单元测试，而其他人不，将不会产生效益，因为每个人都将操作相同的代码库，所以让每个人都接受培训并准备好进行TDD是一个先决条件。
- en: Willingness
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 愿意
- en: Some teams are not willing to do unit testing whether they feel it is difficult
    or increases development time or they don’t perceive the value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一些团队不愿意进行单元测试，无论他们觉得这很困难，还是认为这会增加开发时间，或者他们没有意识到其价值。
- en: Important notes
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: I have seen unit testing enforced by an organization, but the team was unwilling
    to write the tests, and they just created a unit test project with meaningless
    tests to tick the box of the question *Have you implemented unit testing?*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到过组织强制执行单元测试，但团队不愿意编写测试，他们只是创建了一个包含无意义测试的单元测试项目，只是为了勾选“你是否实现了单元测试？”这个问题。
- en: Having the team synchronized with the objective and collaborating for one goal
    is valuable in promoting product quality.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让团队与目标保持一致，并为了一个共同的目标进行协作，这对提高产品质量是有价值的。
- en: If your team is not willing to go for TDD for whatever reason but unit testing
    is OK, then go for it! You can gently introduce TDD soon after. It doesn’t need
    to be all or nothing. It is also worth noting that some members can do TDD while
    others can do unit tests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的团队因为任何原因不愿意采用TDD，但单元测试是可以接受的，那么就采用它！你可以在不久之后温和地引入TDD。它不需要全有或全无。也值得注意，一些成员可以进行TDD，而其他人可以进行单元测试。
- en: Unit testing is useless
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试无用
- en: I have heard this argument from many developers. They might have formed their
    opinion on bad implementations of unit testing or have other reasons. Certainly,
    unit testing has some disadvantages, but so do most technologies.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经从许多开发者那里听到过这个论点。他们可能对单元测试的糟糕实现形成了自己的看法，或者有其他原因。当然，单元测试有一些缺点，但大多数技术也是如此。
- en: Your best shot is to understand the reasons behind this misconception and see
    whether you can address them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你最好的办法是了解这种误解背后的原因，看看你是否可以解决它们。
- en: TDD is useless, I would do unit testing
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TDD无用，我会做单元测试
- en: TDD is controversial and sometimes developers have their own experiences that
    told them that TDD is unusable. This is OK as long as they are happy with unit
    testing because not all team members have to do TDD.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是有争议的，有时开发者有自己的经验告诉他们TDD是不可用的。这是可以接受的，只要他们对单元测试感到满意，因为并非所有团队成员都必须进行TDD。
- en: If the developers who don’t believe in unit tests are building their arguments
    on seeing bad practices, then your job might be to promote good practices.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不相信单元测试的开发者是在看到不良实践时构建他们的论点，那么你的工作可能就是推广良好的实践。
- en: The team’s willingness to follow TDD has a crucial impact on the success of
    the project, so it is important to have everybody on the same page.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 团队愿意遵循TDD对项目的成功有重要影响，因此确保每个人都站在同一条线上是很重要的。
- en: Timing
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间
- en: TDD requires some preparations and extra effort to get the essential quality,
    following the *no pain, no gain* mantra. Having the right time is important and
    it should definitely not be near the release time or when the team is stressed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: TDD需要一些准备和额外的努力来获得基本的质量，遵循“没有痛苦，就没有收获”的格言。正确的时间很重要，它绝对不应该在发布时间或团队压力大的时候。
- en: The perfect time is at the start of the project, but there is no harm in introducing
    it later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的时机是在项目开始时引入，但稍后引入也无妨。
- en: Once you’ve passed the first and second challenges, you will have the business
    challenges, which are arguably the hardest.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你通过了第一和第二次挑战，你将面临商业挑战，这可能是最困难的。
- en: Business challenges
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商业挑战
- en: The business here means a higher technical authority outside the team, who can
    enforce rules. Also, it can be the project manager or the product owner.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的商业意味着团队外的更高技术权威，他们可以执行规则。它也可以是项目经理或产品负责人。
- en: 'I believe that a successful rollout of TDD or unit testing comes from top to
    bottom, management-wise. Enforcement can come from:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信，TDD或单元测试的成功推广是从上到下的，从管理层来说。执行可以来自：
- en: Head of development
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发部门负责人
- en: Development manager
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发经理
- en: Team lead
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队领导
- en: Technical lead
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术负责人
- en: IT auditing
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IT审计
- en: If this is a personal initiative or a team initiative, the team might think
    of dropping it under delivery pressure. However, if they are responsible for providing
    unit tests as part of the delivery, including a coverage level, then it cannot
    be missed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个个人倡议或团队倡议，在交付压力下，团队可能会考虑放弃它。然而，如果他们负责提供作为交付一部分的单元测试，包括覆盖率水平，那么它不能被忽视。
- en: Let’s think of TDD from the business perspective, so that we are better equipped
    and articulated in getting our points across.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从商业的角度来思考TDD，这样我们就能更好地准备和表达我们的观点。
- en: Business benefits of TDD
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD的商业效益
- en: We are well aware of what the benefits of TDD are from a technical point of
    view. But businesses would be more open to the benefits from the business point
    of view, so let’s get into it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很清楚从技术角度来看TDD的好处。但企业会更愿意从商业角度看待这些好处，所以让我们深入探讨。
- en: Fewer bugs
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误更少
- en: This is clearly the biggest seller, as nobody likes bugs. Some businesses are
    stung by a high number of defects in their products, and having less is definitely
    a welcome promise.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是最大的卖点，因为没有人喜欢错误。一些企业在他们的产品中遭受了大量的缺陷，而拥有更少的缺陷无疑是受欢迎的承诺。
- en: The only issue is that it is hard to prove a lower number of bugs via statistics
    – the project will have unit tests from day one, so we can’t make a comparison
    between before and after.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是，很难通过统计数据证明更少的错误数量——项目将从第一天开始就有单元测试，所以我们无法比较之前和之后。
- en: Live documentation for the project
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目的实时文档
- en: One thing that worries the business is documentation, which has a tight relationship
    with developers’ turnover. The risk is that if a developer leaves, some of the
    business knowledge is lost. To prevent this situation, it is important to have
    the business rules robustly documented, and, in all honesty, I can’t think of
    any tool that is better for this than unit tests.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 商业界担忧的一件事是文档，它与开发人员的流动率紧密相关。风险是如果开发人员离职，一些商业知识就会丢失。为了防止这种情况，重要的是要稳健地记录商业规则，而且，坦白说，我想不出有任何工具比单元测试更适合这项工作。
- en: Project documentation contains documents that cannot be covered by unit tests,
    such as project architecture. However, the detailed business rules that nobody
    will remember in a few months will be covered by unit tests and monitored with
    every developer source control push.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 项目文档包含无法由单元测试覆盖的文档，例如项目架构。然而，几个月后没有人会记住的详细业务规则将由单元测试覆盖，并且随着每个开发人员的源代码提交进行监控。
- en: Promoting unit testing as a documentation tool is powerful and will give you
    listening ears from the business.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将单元测试作为文档工具来推广是非常强大的，并且会让商业界倾听你的意见。
- en: Fewer testing resources
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试资源较少
- en: In the old days, manual testing took a good chunk of the **software development
    life cycle** (**SDLC**). Today, with unit tests and other automated tests, manual
    testing has shrunk in size and the number of required manual testers has gone
    down. Some organizations have even eliminated manual testing completely in favor
    of having automated tests (including unit tests).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，手动测试占据了软件开发生命周期（SDLC）的大部分。今天，随着单元测试和其他自动化测试的出现，手动测试的规模和所需手动测试人员数量都减少了。一些组织甚至完全取消了手动测试，转而采用自动化测试（包括单元测试）。
- en: So, the promise of unit tests is about covering lots of edge cases and business
    rules with fewer testers and almost no regression test time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，单元测试的承诺是使用较少的测试人员几乎不需要回归测试时间来覆盖大量的边缘情况和业务规则。
- en: Important note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**Regression testing** is going through existing functionality to ensure it
    is still working. This typically happens before a new release.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**回归测试**是通过现有功能来确保其仍然正常工作。这通常发生在新版本发布之前。'
- en: Obviously, fewer testing resources means less cost, while less time means shipping
    a feature faster, which naturally leads us to the next topic.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，测试资源较少意味着成本较低，而时间较少意味着更快地发布功能，这自然引出了下一个话题。
- en: Ability to release in short cycles
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 短周期发布的能力
- en: The development model today in more agile organizations has moved to shipping
    a few features now and then.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，在更敏捷的组织中，开发模型已经转变为时不时地发布一些功能。
- en: Having unit tests regressing the code with every change and a CI/CD system in
    place means your software is ready to be shipped anytime.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每次更改时都有单元测试回退代码，并且有一个CI/CD系统，这意味着你的软件随时可以发布。
- en: No clever business person will believe all these aforementioned benefits will
    come at no cost, so next, we will discuss the disadvantages of unit testing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 没有哪个聪明的商人会相信上述所有好处都是免费的，所以接下来，我们将讨论单元测试的缺点。
- en: Disadvantages from the business perspective
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从商业角度的缺点
- en: In general, extra quality requires more effort, and TDD is no different, but
    luckily the disadvantages are minimal.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，额外的质量需要更多的努力，TDD也不例外，但幸运的是，缺点很小。
- en: Slight delay in the first release
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 首次发布的轻微延迟
- en: 'We have discussed before that teams not using TDD tend to deliver faster in
    the first period; we have spoken about this in [*Chapter 5*](B18370_05.xhtml#_idTextAnchor114),
    *Test-Driven Development Explained*. Here is a quick reminder:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过，不使用TDD的团队在初期往往交付得更快；我们曾在[*第五章*](B18370_05.xhtml#_idTextAnchor114)，*测试驱动开发解释*中提到过这一点。这里有一个快速提醒：
- en: '![](img/Figure_13.3_B18370.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_13.3_B18370.jpg)'
- en: Figure 13.3 – TDD versus no unit testing
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – TDD与无单元测试的比较
- en: The idea here is that the effort of writing unit tests adds to the development
    time in the short term, but the speed becomes faster in the mid and long terms.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，编写单元测试的努力在短期内会增加开发时间，但在中期和长期内速度会更快。
- en: This is a small price to pay for quality, but just be aware of this point.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了质量而付出的微小代价，但请记住这一点。
- en: Delay in the first release is not acceptable
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 首次发布的延迟是不可接受的
- en: 'There are circumstances where the business wants the first version as soon
    as possible and they are not interested in looking beyond this. Here are a few
    scenarios:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，企业希望尽快得到第一个版本，并且他们对此以外的内容不感兴趣。以下是一些场景：
- en: The product manager wants the first version out as soon as possible, as this
    can lead them to get a higher bonus or a promotion.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品经理希望尽快推出第一个版本，因为这可以让他们获得更高的奖金或晋升。
- en: There is a competitive advantage in releasing as soon as possible and not worrying
    about the future. This is the mentality of a start-up trying to survive.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽快发布并且不担心未来的竞争优势。这是初创公司试图生存的心态。
- en: This project is done for a third party, and the business doesn’t get paid extra
    for ensuring added quality. But getting this in the shortest time possible is
    the intention.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个项目是为第三方完成的，商业方面不会因为确保额外的质量而获得额外报酬。但尽可能快地完成这是意图。
- en: It would be clear if the business is not interested, and you can feel this in
    advance if you know the business model that the company uses. This is not a criticism
    against TDD, but it would become a disadvantage when mixed with such scenarios.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果商业人士不感兴趣，这将很清楚，如果你了解公司使用的商业模式，你可以在事先感觉到这一点。这并不是对TDD的批评，但如果与这种场景混合，它将变成一个劣势。
- en: Now that we have gone through all the challenges and the merits of TDD, let’s
    form a plan to introduce TDD.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了TDD的所有挑战和优点，让我们制定一个引入TDD的计划。
- en: TDD arguments and misconceptions
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的论点和误解
- en: Here are a few hints and tips – from my own experience – that will occur again
    and again in a conversation with the business or your colleagues.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示和技巧——来自我自己的经验——这些在商业人士或你的同事的对话中会反复出现。
- en: Unit testing, not TDD
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试，而非TDD
- en: When discussing with the business, to reduce the complexity of the conversation,
    especially if the business is not tech-savvy, use the term unit testing rather
    than TDD. TDD is a technical process that individuals will do themselves and it
    is not directly related to the business, so why complicate the discussion by adding
    it? Sometimes the business has heard the term TDD, and they are excited about
    it, so then TDD is the right term to use!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在与商业人士讨论时，为了减少对话的复杂性，特别是如果商业人士不太懂技术，请使用单元测试而不是TDD。TDD是一个个人会自己执行的技术流程，它与商业没有直接关系，所以为什么要在讨论中增加复杂性呢？有时商业人士已经听说过TDD这个术语，并且对此很兴奋，所以在这种情况下使用TDD是正确的术语！
- en: My advice is to use unit testing in your conversation unless the business has
    some preference for the term TDD.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是，除非企业对TDD这个术语有偏好，否则在对话中使用单元测试。
- en: Unit testing is not implemented by testers
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试不是由测试员实现的
- en: The term *testing* in unit testing is misleading to the non-techies as it implies
    a tester doing manual testing. I have had this conversation with many business
    individuals.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试中的“测试”一词对非技术人员来说具有误导性，因为它暗示了一个进行手动测试的测试员。我与许多商业人士都有过这样的对话。
- en: 'It is important to clarify that unit testing has more functionality other than
    just testing, such as the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 需要明确的是，单元测试除了测试之外还有更多功能，如下所示：
- en: Shaping the code design architecture of the project
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建项目的代码设计架构
- en: Live documenting the code
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中实时记录代码
- en: Instant feedback during development when breaking a business rule
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在违反业务规则时开发过程中的即时反馈
- en: Also, unit tests are written in C# (or whatever other language you are using),
    and they are implemented by the same developer writing the code. A manual tester,
    most probably, won’t have the willingness or the expertise to write these tests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单元测试是用C#（或你正在使用的任何其他语言）编写的，并且是由编写代码的同一开发者实现的。一个手动测试员，很可能不会有编写这些测试的意愿或专业知识。
- en: This argument might be triggered when the business is wondering why you want
    to consume the engineers’ expensive time on unit testing when there are testers
    that could (as they initially thought) do the unit tests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当企业想知道为什么你想让工程师花费宝贵的时间进行单元测试，而此时有测试员可以（正如他们最初所想）进行单元测试时，可能会引发这种论点。
- en: The way for writing and maintaining documentation
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写和维护文档的方式
- en: I am sure experienced business people will relate to the lack of documentation
    or the documentation becoming out of date.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信有经验的商业人士会理解缺乏文档或文档过时的情况。
- en: As you already know, documenting the code with unit tests provides fresh documentation
    versus text-based stale documentation that is written and forgotten or covers
    part of the system (a hit and a miss). The keyword here is up-to-date, fresh,
    or live. Obviously, we are talking about part of the documentation and you might
    have to make this clear. This is the detailed business rules part.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，使用单元测试来记录代码提供了比基于文本的陈旧文档更新的文档，后者是编写后就被遗忘或只覆盖系统的一部分（有中也有不中）。这里的重点是最新、新鲜或实时。显然，我们是在谈论文档的一部分，您可能需要明确这一点。这是详细业务规则的部分。
- en: We have incompetent developers
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们有不胜任的开发者
- en: Businesses sometimes believe they have incompetent developers, and this is why
    they are producing plenty of bugs. I have heard this argument whispered by the
    business on multiple occasions when talking about their team.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 企业有时认为他们有不胜任的开发者，这就是为什么他们会产生大量错误。我多次听到业务在谈论他们的团队时低声说出这个论点。
- en: When I hear this argument, I quickly dig and discover that the business does
    not have a structure in place for the agile process and that the developers are
    rewarded for how fast they finish developing a feature. We all know that person
    who takes the shortest route to get their features done and show off to the business!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我听到这个论点时，我会迅速深入挖掘，发现业务没有建立敏捷流程的结构，并且开发者因快速完成开发功能而受到奖励。我们都知道那个人，他们总是选择最短的路来完成他们的功能并向业务炫耀！
- en: Developers are highly logical individuals who like structure and order. Having
    a development process with TDD will definitely reduce bugs and set things on track.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者是非常逻辑性的人，他们喜欢结构化和秩序。拥有TDD的开发流程肯定会减少错误并将事情引上正轨。
- en: Your challenge here is to show how the TDD process and the tests will have a
    positive effect on the problem.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您的挑战是展示TDD过程和测试将如何对问题产生积极影响。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter utilizes all the knowledge provided in this book and demonstrates
    the challenges of rolling out TDD into your organization. I hope I gave you enough
    arguments to convince the team and the business to subscribe to the TDD point
    of view.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本章利用了本书中提供的所有知识，展示了将TDD（测试驱动开发）推广到组织中的挑战。我希望我已经提供了足够的论据来说服团队和业务接受TDD的观点。
- en: Besides this chapter, your presentation skills and familiarity with the subject
    will be highly useful when planning to roll out TDD.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章内容外，在计划推广TDD时，您的演讲技巧和对主题的熟悉程度将非常有用。
- en: In this book, I have endeavored to provide practical examples of real frameworks
    and tools that I’ve worked with, rather than using abstract and oversimplified
    examples. I wrote the book out of love and passion for the topic and I tried to
    stay pragmatic, and I hope I delivered what I aimed to deliver.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我努力提供了我实际使用过的真实框架和工具的实用示例，而不是使用抽象和过于简化的示例。我出于对这一主题的热爱和激情而写这本书，并试图保持务实，我希望我已经实现了我的目标。
- en: While the title of this book refers to TDD, this book contains pragmatic examples
    of OOP and good programming practices, and by finishing the book, I trust you
    have stepped into the world of advanced software engineering.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书的标题提到了TDD，但本书包含了面向对象和良好编程实践的实用示例，我相信您在完成这本书后已经进入了高级软件工程的领域。
- en: Good luck and I would love to know how the book has contributed to you or your
    team adopting TDD.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你好运，并且我很乐意了解这本书是如何帮助您或您的团队采用TDD的。
- en: 'Appendix 1: Commonly Used Libraries with Unit Tests'
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录1：带有单元测试的常用库
- en: 'We have used two major libraries for unit testing across the book:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整本书中使用了两个主要的单元测试库：
- en: xUnit
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: xUnit
- en: NSubstitute
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSubstitute
- en: 'Your team may be using these libraries already. Or you may have done a bit
    of experimentation with unit testing, and you want to expand your horizon into
    more libraries. While these libraries are popular, other libraries can replace
    them or work side by side with them. This appendix will skim through the following
    libraries:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您的团队可能已经在使用这些库了。或者您可能已经对单元测试进行了一些实验，并希望扩大视野到更多的库。虽然这些库很受欢迎，但其他库可以替代它们或与它们并行工作。本附录将简要介绍以下库：
- en: MSTest
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSTest
- en: NUnit
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NUnit
- en: Moq
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moq
- en: Fluent Assertions
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流畅断言
- en: AutoFixture
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AutoFixture
- en: All these libraries use the MIT license, the most permissive license and you
    can install any of them via NuGet.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些库都使用MIT许可证，这是最宽松的许可证，您可以通过NuGet安装它们中的任何一个。
- en: By the end of this appendix, you will be familiar with the libraries that form
    the ecosystem of unit testing in .NET.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到本附录结束时，您将熟悉构成.NET单元测试生态系统的库。
- en: Technical requirements
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following GitHub repository:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下 GitHub 仓库中找到：
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix1](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix1)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix1](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix1)'
- en: Unit testing frameworks
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试框架
- en: We have seen xUnit, and we have briefly spoken about MSTest and NUnit. This
    section will give you a feeling of what these other frameworks are about.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 xUnit，我们也简要地讨论了 MSTest 和 NUnit。本节将让您了解这些其他框架的内容。
- en: MSTest
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MSTest
- en: '**MSTest** used to be popular, as it was installed as part of **Visual Studio**
    (**VS**) in the older versions of VS. Prior to NuGet’s existence, using a *built-in*
    library could cut configuration and deployment time compared to adding and using
    another framework such as NUnit.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**MSTest** 以前很受欢迎，因为它在 VS 的旧版本中作为 **Visual Studio** （**VS**） 的一部分安装。在 NuGet
    存在之前，使用一个 *内置* 库可以减少配置和部署时间，与添加和使用另一个框架（如 NUnit）相比。'
- en: Before NuGet, installing a new library involved manually copying DLLs, putting
    them in the right location, changing some configurations, and pushing them into
    source control for the team to share the same files. So, having a pre-installed
    library and one that didn’t require configuration, such as MSTest, was a blessing.
    We have moved a long way since then.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NuGet 之前，安装一个新的库涉及到手动复制 DLL 文件，将它们放在正确的位置，更改一些配置，并将它们推送到源代码控制，以便团队共享相同的文件。因此，拥有预先安装的库且不需要配置的库，如
    MSTest，是一种祝福。从那时起，我们已经走了很长的路。
- en: 'To add an MSTest project into your solution, you can do it via the UI:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 MSTest 项目添加到您的解决方案中，您也可以通过 UI 来完成：
- en: '![Figure A1.1 – Adding MSTest via the UI ](img/Figure_A1.1_B18370.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.1 – 通过 UI 添加 MSTest](img/Figure_A1.1_B18370.jpg)'
- en: Figure A1.1 – Adding MSTest via the UI
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.1 – 通过 UI 添加 MSTest
- en: Notice that there are two copies of the C# version. The bottom one is for the
    classical .NET Framework, and the top one is what we use with .NET Core.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有两个 C# 版本的副本。下面一个是用于经典 .NET Framework 的，上面一个是我们在 .NET Core 中使用的。
- en: 'You can add MSTest via the `dotnet` CLI:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 `dotnet` CLI 添加 MSTest：
- en: '[PRE0]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'MSTest and xUnit have similar syntax, so let me show you the code in xUnit
    and its equivalent in MSTest. I’ll start with xUnit:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: MSTest 和 xUnit 有类似的语法，所以让我向您展示 xUnit 的代码及其在 MSTest 中的等效代码。我将从 xUnit 开始：
- en: '[PRE1]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The equivalent in MSTest is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MSTest 中的对应代码如下：
- en: '[PRE2]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can directly spot a few differences between the two code snippets:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接看到这两个代码片段之间的一些差异：
- en: The unit test class in MSTest has to be decorated with `TestClass`.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSTest 中的单元测试类必须用 `TestClass` 装饰。
- en: The constructor in MSTest would work, but the standard way of initializing is
    to decorate a method with `TestInitialize`.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSTest 中的构造函数可以工作，但标准的初始化方式是用 `TestInitialize` 装饰一个方法。
- en: Both libraries use the `Assert` class name, but the method names in the class
    are different; for example, xUnit uses `Equal` and `True`, while MSTest uses `AreEqual`
    and `IsTrue`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个库都使用 `Assert` 类名，但类中的方法名不同；例如，xUnit 使用 `Equal` 和 `True`，而 MSTest 使用 `AreEqual`
    和 `IsTrue`。
- en: 'When doing multiple tests, xUnit and MSTest use different attributes. This
    code is in xUnit:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行多个测试时，xUnit 和 MSTest 使用不同的属性。以下是在 xUnit 中的代码：
- en: '[PRE3]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In MSTest, the equivalent code will look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MSTest 中，相应的代码将看起来像这样：
- en: '[PRE4]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, you can notice two differences:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以注意到两个差异：
- en: '`Theory` becomes `DataTestMethod`.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Theory` 变成了 `DataTestMethod`。'
- en: '`InlineData` becomes `DataRow`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InlineData` 变成了 `DataRow`。'
- en: As you can see, there isn’t much difference between the two libraries. Also,
    executing the test running, running the Test Explorer and other test activities
    other than the code stay the same.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两个库之间没有太大的区别。此外，执行测试运行、运行测试资源管理器和其他测试活动（除了代码之外）都保持不变。
- en: NUnit
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NUnit
- en: '**NUnit** used to be the dominant library in the first decade of the two-thousands;
    it is still in use today, with xUnit becoming more prevalent.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**NUnit** 在两千年代的前十年中曾经是主导库；它至今仍在使用，而 xUnit 正变得越来越普遍。'
- en: 'To add an NUnit project to your solution, you can do it via the UI:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 NUnit 项目添加到您的解决方案中，您可以通过 UI 来完成：
- en: '![Figure A1.2 – Adding NUnit via the UI ](img/Figure_A1.2_B18370.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.2 – 通过 UI 添加 NUnit](img/Figure_A1.2_B18370.jpg)'
- en: Figure A1.2 – Adding NUnit via the UI
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.2 – 通过 UI 添加 NUnit
- en: Just like MSTest, NUnit has two copies of the .NET version. The bottom one is
    for the classical .NET Framework, and the top one is what we use with .NET Core.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就像MSTest一样，NUnit有两个.NET版本。下面一个是用于经典.NET Framework的，上面一个是我们在.NET Core中使用的。
- en: 'You can add NUnit via the `dotnet` CLI:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`dotnet` CLI添加NUnit：
- en: '[PRE5]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'NUnit and xUnit have similar syntax, so let me show you the code in NUnit and
    its equivalent in MSTest. I’ll start with xUnit:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: NUnit和xUnit有相似的语法，所以让我给你展示NUnit的代码及其在MSTest中的等效代码。我将从xUnit开始：
- en: '[PRE6]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The equivalent in MSTest is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在MSTest中的等效代码如下：
- en: '[PRE7]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can directly spot a few differences between the two code snippets:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在这两个代码片段中找出一些不同之处：
- en: The constructor in NUnit would work, but the standard way of initializing is
    to decorate a method with `Setup`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在NUnit中，构造函数可以工作，但标准的初始化方式是用`Setup`装饰一个方法。
- en: Both libraries use the `Assert` class name, but the method names in the class
    are different; for example, xUnit uses `Equal`, while NUnit uses `AreEqual`.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个库都使用`Assert`类名，但类中的方法名不同；例如，xUnit使用`Equal`，而NUnit使用`AreEqual`。
- en: The style of NUnit uses a fluent interface design, and the recommended approach
    to test equality is to use `That` and `Is.EqualTo`.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NUnit的风格使用流畅的接口设计，推荐测试相等的方法是使用`That`和`Is.EqualTo`。
- en: 'When doing multiple tests, xUnit and NUnit use different class names. This
    code is in xUnit:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行多个测试时，xUnit和NUnit使用不同的类名。这段代码在xUnit中：
- en: '[PRE8]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In NUnit, the equivalent code will look like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在NUnit中，等效的代码将如下所示：
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, you can notice that `InlineData` becomes `TestCase`. Besides this, there
    isn’t much difference between the two libraries, and their template is included
    in the default installation of VS 2022.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以注意到`InlineData`变成了`TestCase`。除此之外，这两个库之间没有太大的区别，它们的模板包含在VS 2022的默认安装中。
- en: These three libraries are interchangeable, and the syntax changes are minimal.
    Once you are used to one, it will take minimal time to switch to the other.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个库可以互换使用，并且语法变化很小。一旦你习惯了其中一个，切换到另一个将花费极短的时间。
- en: Mocking libraries
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟库
- en: There is no shortage of mocking libraries in .NET; however, the top two used
    libraries are NSubstitute and Moq. We have covered plenty of examples of NSubstitute
    in this book, so let’s see how Moq works.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中不缺少模拟库；然而，使用最多的两个库是NSubstitute和Moq。在这本书中我们已经涵盖了大量的NSubstitute示例，所以让我们看看Moq是如何工作的。
- en: Moq
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Moq
- en: '**Moq** has the same role and same functionality, more or less, as NSubstitute.
    Given that the book was using NSubstitute, the fastest way to introduce Moq is
    to compare the two libraries. Let’s start with a snippet from NSubstitute:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**Moq** 与NSubstitute在角色和功能上大致相同。鉴于这本书使用的是NSubstitute，最快的方式是通过比较这两个库来引入Moq。让我们从一个NSubstitute的片段开始：'
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This snippet instantiates and creates a mock object from `IOpenWeatherService`
    and spies on the `lat` and `lon` input parameters of `OneCallAsync`. The idea
    is to ensure the two parameters passed to `GetForecastWeatherAnalysis` are passed
    without modification to the `OneCallAsync` method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段实例化并创建了一个从`IOpenWeatherService`生成的模拟对象，并监视了`OneCallAsync`的`lat`和`lon`输入参数。目的是确保传递给`GetForecastWeatherAnalysis`的两个参数未经修改地传递给`OneCallAsync`方法。
- en: 'Let’s look at the same code using Moq:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用Moq的相同代码：
- en: '[PRE11]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This Moq code doesn’t look much different from its NSubstitute rival. Let’s
    analyze the differences:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Moq代码与它的NSubstitute竞争对手看起来并没有太大的区别。让我们分析一下它们之间的差异：
- en: NSubstitute instantiates a mock object using the `Substitute.For` method, whereas
    Moq does it using `Mock.Of`.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSubstitute使用`Substitute.For`方法实例化模拟对象，而Moq则使用`Mock.Of`。
- en: NSubstitute uses extension methods such as `Returns` to configure the mock object,
    whereas Moq doesn’t use extensions.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSubstitute使用扩展方法，如`Returns`来配置模拟对象，而Moq则不使用扩展。
- en: NSubstitute uses `Args.Any` to pass parameters, whereas Moq uses `It.IsAny`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSubstitute使用`Args.Any`来传递参数，而Moq使用`It.IsAny`。
- en: In general, while Moq favors syntax with lambda expressions, NSubstitute takes
    another route and uses extension methods. NSubstitute tries to make the code look
    as natural as possible and get out of the way by having less syntax, while Moq
    relies on the power of lambdas.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，虽然Moq倾向于使用lambda表达式语法，但NSubstitute则走另一条路，使用扩展方法。NSubstitute试图让代码看起来尽可能自然，并通过减少语法来让代码更简洁，而Moq则依赖于lambda表达式的力量。
- en: Important note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Moq has another way of creating a mock. I opted to show the modern version.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Moq有另一种创建模拟的方法。我选择展示现代版本。
- en: In my opinion, using one library or another is a matter of style and syntax
    preference.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，使用一个库还是另一个库是一个关于风格和语法偏好的问题。
- en: Unit testing helper libraries
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试辅助库
- en: 'I have seen developers adding these two libraries to their unit tests to enhance
    the syntax and readability: **Fluent Assertions** and **AutoFixture**.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到一些开发者将这两个库添加到他们的单元测试中，以增强语法和可读性：**Fluent Assertions**和**AutoFixture**。
- en: Fluent Assertions
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fluent Assertions
- en: 'Fluent implementation, also known as a fluent interface, is trying to make
    the code read like an English sentence. Take this example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅实现，也称为流畅接口，试图使代码读起来像英语句子。以这个例子为例：
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Some developers like to have the tests written in this way as it supports a
    more natural way of reading a test. Some like it for their own reasons.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者喜欢以这种方式编写测试，因为它支持更自然的测试阅读方式。有些人有自己的原因喜欢它。
- en: '`FluentAssertions` is a popular library that integrates with all popular test
    frameworks among MSTest, Nunit, and xUnit to enable fluent interfaces. You can
    add it to your unit test project via NuGet under the name `FluentAssertions`.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`FluentAssertions`是一个流行的库，它集成了MSTest、Nunit和xUnit等所有流行的测试框架，以启用流畅接口。您可以通过NuGet在单元测试项目中添加它，名称为`FluentAssertions`。'
- en: 'Let’s see how our code will be without and with the library:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看没有和有这个库时我们的代码会怎样：
- en: '[PRE13]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But the previous snippet doesn’t show the true power of the library, so let’s
    do some other examples:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 但之前的代码片段并没有展示库的真实力量，所以让我们看看其他一些例子：
- en: '[PRE14]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The previous snippet is an example of a fluent syntax, and the code is self-explanatory.
    To test this code, you will require a few lines of the standard `Assert` syntax.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段是一个流畅语法的例子，代码不言自明。要测试此代码，你需要几行标准的`Assert`语法。
- en: 'Here is another example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子：
- en: '[PRE15]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous code is also self-explanatory.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码也是不言自明的。
- en: Important Note
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While these code snippets show the power of `FluentAssertions`, asserting too
    many unrelated elements in a unit test is not recommended. These examples are
    for illustration only and do not focus on best unit testing practices.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些代码片段展示了`FluentAssertions`的强大功能，但在单元测试中断言过多不相关的元素并不推荐。这些示例仅用于说明，并不专注于最佳单元测试实践。
- en: These two code snippets are enough to show why some developers are fond of this
    syntax style. Now that you know about it, the choice of using such syntax is yours.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个代码片段足以说明为什么一些开发者喜欢这种语法风格。现在你了解了它，使用这种语法的选择权在你。
- en: AutoFixture
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AutoFixture
- en: Sometimes, you have to generate data to populate an object. The object may be
    directly related to your unit test. Or maybe you just want to populate it for
    the rest of the unit to execute, but it is not the subject of the test. This is
    when **AutoFixture** comes to the rescue.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你必须生成数据来填充一个对象。这个对象可能与你的单元测试直接相关。或者你可能只是想填充它以便单元测试执行，但它不是测试的主题。这就是**AutoFixture**发挥作用的时候。
- en: 'You can write the tedious code to generate an object, or you can use `AutoFixture`.
    Let’s illustrate this with an example. Consider the following `record` class:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写生成对象的繁琐代码，或者你可以使用`AutoFixture`。让我们用一个例子来说明这一点。考虑以下`record`类：
- en: '[PRE16]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Populating this in the `Arrange` part of your unit test will increase the size
    of your unit test and distract the test from its real intention.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试的`Arrange`部分填充这些内容将会增加单元测试的大小，并使测试偏离其真正意图。
- en: 'AutoFixture can create an instance of this class using the least amount of
    code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: AutoFixture可以使用最少的代码创建此类的一个实例：
- en: '[PRE17]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will create an object of this class and populate it with random values.
    These are some of the values:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个此类对象，并用随机值填充它。以下是一些值：
- en: '[PRE18]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous output is the first level of the `OneCallResponse` class, but all
    the succeeding levels are also populated.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出是`OneCallResponse`类的第一级，但所有后续级别也都已填充。
- en: 'But what if you want fine control of the generated data? Let’s say we want
    to generate the class, but with the `Daily` property having an array length of
    `8` rather than a random size:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想要对生成数据进行精细控制呢？比如说，我们想要生成一个类，但`Daily`属性具有`8`个数组元素而不是随机大小：
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will generate everything randomly, but the `Daily` property will have eight
    array elements with random values.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将随机生成一切，但`Daily`属性将包含八个具有随机值的数组元素。
- en: This library has plenty of methods and customizations; this section only scratches
    the surface.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库有大量的方法和自定义选项；本节仅触及表面。
- en: This appendix is a brief pointer to several libraries used for, or in conjunction
    with, unit testing. The intention here is to tell you these libraries exist and
    intrigue you to dig further if the need arises.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录简要介绍了用于或与单元测试结合使用的几个库。这里的目的是告诉你这些库的存在，并在需要时激发你进一步探索。
- en: Further reading
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in the chapter, you can refer to the
    following links:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，你可以参考以下链接：
- en: '*xUnit*: [https://xunit.net](https://xunit.net)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*xUnit*: [https://xunit.net](https://xunit.net)'
- en: '*MSTest*: [https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest](https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MSTest*: [https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest](https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest)'
- en: '*NUnit*: [https://nunit.org](https://nunit.org)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NUnit*: [https://nunit.org](https://nunit.org)'
- en: '*Moq*: [https://github.com/moq/moq4](https://github.com/moq/moq4%0D)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Moq*: [https://github.com/moq/moq4](https://github.com/moq/moq4%0D)'
- en: '*Fluent Assertions*: [https://fluentassertions.com](https://fluentassertions.com%0D)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Fluent Assertions*: [https://fluentassertions.com](https://fluentassertions.com%0D)'
- en: '*AutoFixture*: [https://github.com/AutoFixture](https://github.com/AutoFixture)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AutoFixture*: [https://github.com/AutoFixture](https://github.com/AutoFixture)'
- en: 'Appendix 2: Advanced Mocking Scenarios'
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录2：高级模拟场景
- en: This book has numerous examples of straightforward mocking scenarios. And the
    good news is, in a clean code environment, implementing most of those mocking
    requirements will be easy.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本书有大量直接的模拟场景示例。好消息是，在一个干净的代码环境中，实现大多数模拟需求将会很容易。
- en: However, there are times when you have to *innovate* a bit to be able to mock
    your desired class. I did not want to end this book without presenting you with
    a scenario, so here you go.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你必须*创新*一点，才能模拟你想要的类。我不想在没有给你一个场景的情况下结束这本书，所以，这里就是。
- en: In this appendix, we will experience how to combine a fake with a mock to deal
    with a .NET class called `HttpMessageHandler`. By the end of this appendix, you
    will be familiar with more NSubstitute functionalities and ready to tackle more
    advanced mocking cases.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个附录中，我们将体验如何将一个模拟与一个伪造结合使用来处理一个名为`HttpMessageHandler`的.NET类。在本附录结束时，你将熟悉更多NSubstitute功能，并准备好处理更高级的模拟案例。
- en: Technical requirements
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following GitHub repository:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库找到：
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix2](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix2)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix2](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/appendix2)'
- en: Writing an OpenWeather client library
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写OpenWeather客户端库
- en: We have used the OpenWeather service in this book frequently, so I will give
    you a quick reminder – OpenWeather provides a set of RESTful APIs to bring you
    the weather and the forecast.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 本书频繁使用了OpenWeather服务，所以我会给你一个快速提醒——OpenWeather提供了一套RESTful API，可以为你提供天气和预报。
- en: To consume the service from a C# application, it is good to have a library that
    will translate RESTful API calls to C# and shield the developer from the little
    details of HTTP. We call this sort of library a **RESTful client library** or
    sometimes a **software development kit** (**SDK**).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要从C#应用程序中消费服务，有一个将RESTful API调用转换为C#并保护开发者免受HTTP细节困扰的库会很好。我们称这种类型的库为**RESTful客户端库**，有时也称为**软件开发工具包**（**SDK**）。
- en: We will build an SDK for this service using TDD (of course!) and, while doing
    so, we will encounter more advanced mocking requirements.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用TDD（当然！）来构建这个服务的SDK，在这个过程中，我们将遇到更多高级的模拟需求。
- en: The One Call API
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一调用API
- en: OpenWeather has an API called **One Call** that will get you today’s weather
    information and the forecast for the next few days. The best way to illustrate
    how this works is by using an example that gets the weather and the forecast for
    Greenwich, London.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWeather有一个名为**One Call**的API，可以获取今天的天气信息和未来几天的预报。最好的说明方法是通过一个示例来获取伦敦格林威治的天气和预报。
- en: 'First, issue a RESTful `GET` request. You can use your browser for this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，发起一个RESTful `GET`请求。你可以使用浏览器来做这件事：
- en: '[PRE20]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice that the first two query string parameters are the latitude and the
    longitude of Greenwich, and the last one is your API key (which is omitted here).
    You will get a response similar to this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前两个查询字符串参数是格林威治的纬度和经度，最后一个是你的API密钥（此处省略）。您将获得类似以下响应：
- en: '[PRE21]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a very long JSON output; it is around 21,129 characters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常长的JSON输出；大约有21,129个字符。
- en: Creating the solution skeleton
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建解决方案骨架
- en: 'We have created a library and tested it frequently, so we will need to do the
    same here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个库并频繁测试它，所以在这里我们也将这样做：
- en: Create a library project, call it `Uqs.OpenWeather`, and delete the sample class.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个库项目，命名为`Uqs.OpenWeather`，并删除示例类。
- en: Create an xUnit project and call it `Uqs.OpenWeather.Test.Unit`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个xUnit项目，并将其命名为`Uqs.OpenWeather.Test.Unit`。
- en: Add a reference from the test project to the library.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从测试项目添加对库的引用。
- en: Add NSubstitute from NuGet to the test project.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将NSubstitute从NuGet添加到测试项目中。
- en: Rename the class and the filename in the unit test to `ClientTests.cs`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单元测试中的类和文件名重命名为`ClientTests.cs`。
- en: 'Your VS solution will look like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您的VS解决方案将看起来像这样：
- en: '![Figure A2.1 – Project skeleton’s Solution Explorer ](img/Figure_A2.1_B18370.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图A2.1 – 项目骨架的解决方案资源管理器](img/Figure_A2.1_B18370.jpg)'
- en: Figure A2.1 – Project skeleton’s Solution Explorer
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图A2.1 – 项目骨架的解决方案资源管理器
- en: We are now ready to write the first unit test with TDD.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好使用TDD编写第一个单元测试。
- en: Starting the implementation with TDD
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以TDD开始实现
- en: At this moment, you can open your `ClientTests.cs` and start your first test,
    which will drive the library’s architecture.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在此刻，您可以打开您的`ClientTests.cs`并开始您的第一个测试，这将驱动库的架构。
- en: 'We want to pass to a C# method, which we will call `OneCallAsync`, the two
    required parameters, `lat` and `lon`. This will then generate a URL with the right
    query string. So, our unit test class and the first unit test code will start
    to take shape, as shown in the following code base:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将两个必需的参数`lat`和`lon`传递给一个C#方法，我们将称之为`OneCallAsync`。这将生成一个带有正确查询字符串的URL。因此，我们的单元测试类和第一个单元测试代码将开始成形，如下所示：
- en: '[PRE22]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Given that the API key needs to be sent with every API call, the API key is
    to be in the constructor and not part of the method parameters.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API密钥需要与每个API调用一起发送，因此API密钥应在构造函数中，而不是方法参数的一部分。
- en: Important Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Having the API key in the constructor will free the class’s consumer of having
    to fetch the API key to pass it to the method call. Instead, it will become the
    responsibility of the dependency injection setup to fetch the key, which makes
    more sense.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将API密钥放在构造函数中，将使类的消费者无需获取API密钥并将其传递给方法调用。相反，这将成为依赖注入设置的职责，以获取密钥，这更有意义。
- en: 'We will definitely need the `HttpClient` class because your client will be
    using REST, and this is what you usually use with RESTful calls in .NET Core.
    However, when using this class, we may face the following challenges:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定需要`HttpClient`类，因为您的客户端将使用REST，这是您在.NET Core中通常用于RESTful调用的。然而，在使用此类时，我们可能会面临以下挑战：
- en: '`HttpClient` is a concrete class, and calling any method on it will lead to
    `HttpClient` issuing a call to the destination – this is the default behavior,
    but it can be tweaked.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`是一个具体类，对其调用任何方法都会导致`HttpClient`向目标发出调用——这是默认行为，但可以进行微调。'
- en: '`HttpClient` doesn’t give us access to the generated URL, which is what we
    want in the current test.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`不提供对生成的URL的访问，这是我们当前测试想要的。'
- en: We need to figure out a way to intercept the call before `HttpClient` calls
    the destination (which is the actual third-party service) and get a hold of the
    generated URL for inspection. Of course, we also want to eliminate the outbound
    call as this is a unit test, and we don’t want to call the third party for real.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找出一种方法，在`HttpClient`调用目标（即实际的第三方服务）之前拦截电话，并获取生成的URL以进行检查。当然，我们还想消除出站调用，因为这是一个单元测试，我们不想真正调用第三方。
- en: '`HttpClient` can be passed an instance of `HttpMessageHandler` in the constructor,
    and then from `HttpMessageHandler` we can get hold of the generated URL by spying
    on `HttpMessageHandler.SendAsync` and eliminate the real call. But `HttpMessageHandler`
    is an abstract class, so we cannot instantiate it; we need to inherit from it.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`可以在构造函数中传递一个`HttpMessageHandler`的实例，然后从`HttpMessageHandler`通过监视`HttpMessageHandler.SendAsync`获取生成的URL，并消除真实调用。但是`HttpMessageHandler`是一个抽象类，所以我们不能实例化它；我们需要从它继承。'
- en: 'So, let’s create a child class from `HttpMessageHandler` and call it `FakeHttpMessageHandler`
    in your unit test project, as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在您的单元测试项目中从 `HttpMessageHandler` 创建一个子类，并将其命名为 `FakeHttpMessageHandler`，如下所示：
- en: '[PRE23]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We have created a fake class that will allow us to get access to `HttpRequestMessage`.
    Now, our `Arrange` will look like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个模拟类，这将使我们能够访问 `HttpRequestMessage`。现在，我们的 `Arrange` 将看起来像这样：
- en: '[PRE24]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We first created a response message, so any method call will return this empty
    object. This object will contain the third-party response when we run the real
    code.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个响应消息，因此任何方法调用都将返回这个空对象。当我们运行实际代码时，这个对象将包含第三方响应。
- en: Important Note
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We have created a fake for `HttpMessageHandler`; we could have mocked it as
    well. Both work, and it is based on preference of what is more readable. Here
    I feel that having a fake `HttpMessageHandler` is easier to read.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `HttpMessageHandler` 创建了一个模拟；我们也可以模拟它。两者都有效，这取决于个人偏好，哪个更易读。在这里，我觉得有一个模拟
    `HttpMessageHandler` 更容易阅读。
- en: Also note that the preceding implementation could be called a stub (rather than
    a fake) but I opted to refer to it as fake as it contains some real implementation.
    Sometimes there is a thin line between stubs and fakes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，前面的实现可以被称为存根（而不是模拟），但我选择将其称为模拟，因为它包含了一些实际实现。有时存根和模拟之间只有一条细线。
- en: Note that we used NSubstitute to create a mock of the fake. The reason for that
    is we want to have access to `HttpRequestMessage`, which contains our final URL.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用NSubstitute创建了对模拟的模拟。这样做的原因是我们想访问 `HttpRequestMessage`，它包含我们的最终URL。
- en: We have used `Substitute.ForPartsOf` rather than `Substitute.For` for the first
    time in this book, because `For` is not meant for concrete classes; the code will
    compile, but you will get a runtime error.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们第一次使用 `Substitute.ForPartsOf` 而不是 `Substitute.For`，因为 `For` 不适用于具体类；代码可以编译，但您将得到运行时错误。
- en: Important Note
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We have always used `Substitute.For<ISomeInterface>` and this is what you would
    do in 95% of the cases. We have not created an instance of a concrete class. For
    concrete classes, without interfaces, you would use `ForPartsOf<SomeClass>`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用 `Substitute.For<ISomeInterface>`，在95%的情况下，您也会这样做。我们没有创建具体类的实例。对于没有接口的具体类，您将使用
    `ForPartsOf<SomeClass>`。
- en: 'Our `Assert` section becomes this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Assert` 部分变成了这样：
- en: '[PRE25]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we are ready to write the production code.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写生产代码了。
- en: Fail then pass
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 失败然后通过
- en: 'The code will fail to even compile as we have not created the production code,
    which will give us the TDD fail that we are looking for. Now, we shall do the
    minimal implementation that will pass the test:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有创建生产代码，代码甚至无法编译，这将给我们想要的TDD失败。现在，我们将进行最小实现，以便通过测试：
- en: '[PRE26]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Run your test again, and it will pass.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行您的测试，它将通过。
- en: We’ve done a lot for this test, but other tests will flow easily as they will
    use the same fake that we’ve created. Let’s do a recap of what we’ve done.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这个测试做了很多工作，但其他测试将很容易进行，因为它们将使用我们创建的相同模拟。让我们回顾一下我们所做的一切。
- en: Recap
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾
- en: 'Here is a recap of all the important activities that we’ve done to make the
    first test pass:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有重要活动的回顾，我们做了这些活动以使第一个测试通过：
- en: We wanted to write a test that checks whether the URL is formed right.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想编写一个测试来检查URL是否正确形成。
- en: We had to get into the internals of `HttpClient` to get the URL.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不进入 `HttpClient` 的内部以获取URL。
- en: '`HttpClient` doesn’t have the right methods to spy on the generated URL.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient` 没有正确的方法来监视生成的URL。'
- en: We created a fake `FakeHttpMessageHandler` that inherited `HttpMessageHandler`
    and passed it to `HttpClient` so we can reach the `HttpClient` internals.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个继承自 `HttpMessageHandler` 的模拟 `FakeHttpMessageHandler`，并将其传递给 `HttpClient`，这样我们就可以访问
    `HttpClient` 的内部。
- en: We mocked our fake `FakeHttpMessageHandler` and spied on the URL.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们模拟了我们的模拟 `FakeHttpMessageHandler` 并监视了URL。
- en: We utilized a less-used method of NSubstitute for creating a mock, `Substitute.ForPartsOf`,
    which allowed us to mock a concrete class.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们利用了NSubstitute的一个较少使用的方法来创建模拟，即 `Substitute.ForPartsOf`，这使得我们可以模拟一个具体类。
- en: We followed the standard TDD route of fail and pass to implement our production
    code.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们遵循了标准的TDD路线，即先失败后通过来实现我们的生产代码。
- en: I hope this made the activities clearer. You have the full source code to inspect
    if this is not the case.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这使活动更加清晰。如果您对此有疑问，您可以查看完整的源代码。
- en: You will encounter similar advanced mocking scenarios in the future, so how
    do you attack them?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，您将遇到类似的复杂模拟场景，那么您将如何应对它们呢？
- en: Investigating complex mocking scenarios
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调查复杂的模拟场景
- en: Like everything in a developer’s life, you will be able to find someone else
    who has encountered a similar mocking scenario to the one you are facing. Searching
    online for `access url HttpClient NSubstitute` would have given you the clues
    you needed to cut through the problem quickly.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 就像开发者生活中的一切一样，您总会找到其他人遇到过与您所面临的类似模拟场景。在网上搜索 `access url HttpClient NSubstitute`
    就会为您提供快速解决问题的线索。
- en: The good news is that most of the sophisticated mocking problems have already
    been sorted out, and the solutions have been published (thanks to all developers’
    hard work). You just need to understand the concept and incorporate it into your
    solution.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，大多数复杂的模拟问题已经得到解决，解决方案也已发布（感谢所有开发者的辛勤工作）。您只需要理解这个概念并将其融入您的解决方案中。
- en: In this appendix, we went through a more advanced but less frequent mocking
    scenario. It requires more fiddling and extra effort, but with experience in mocking,
    you will become familiar with these scenarios, and you will cut through them in
    no time.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们讨论了一个更高级但不太常见的模拟场景。这需要更多的调整和额外的工作，但有了模拟经验，您将熟悉这些场景，并且能够迅速解决它们。
- en: Further reading
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in the chapter, you can refer to *OpenWeather’s*
    official website: [https://openweathermap.org](https://openweathermap.org)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，您可以参考 *OpenWeather的* 官方网站：[https://openweathermap.org](https://openweathermap.org)
