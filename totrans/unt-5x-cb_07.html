<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Controlling 3D Animations</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring a character's Avatar and idle animation</li><li class="listitem" style="list-style-type: disc">Moving your character with root motion and Blend Trees</li><li class="listitem" style="list-style-type: disc">Mixing animations with Layers and Masks</li><li class="listitem" style="list-style-type: disc">Organizing States into Sub-State Machines</li><li class="listitem" style="list-style-type: disc">Transforming the Character Controller via script</li><li class="listitem" style="list-style-type: disc">Adding rigid props to animated characters</li><li class="listitem" style="list-style-type: disc">Using Animation Events to throw an object</li><li class="listitem" style="list-style-type: disc">Applying Ragdoll physics to a character</li><li class="listitem" style="list-style-type: disc">Rotating the character's torso to aim a weapon</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Introduction</h1></div></div></div><p>The <strong>Mecanim</strong> animation <a class="indexterm" id="id689"/>system has revolutionized how characters are animated and controlled within Unity. In this chapter, we will learn how to take advantage of its flexibility, power, and friendly and highly visual interface.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec193"/>The big picture</h2></div></div></div><p>Controlling a playable<a class="indexterm" id="id690"/> character with the Mecanim System might look like a complex task, but it is actually very straightforward.</p><div><img alt="The big picture" src="img/1362OT_07_00.jpg"/></div><p>Hopefully, by<a class="indexterm" id="id691"/> the end of the chapter, you will have gained at least a basic understanding of the Mecanim system. For a more complete overview of the subject, consider taking a look at Jamie Dean's <em>Unity Character Animation</em> with Mecanim, also published by Packt Publishing.</p><p>An additional note—all the recipes will make use of <a class="indexterm" id="id692"/><strong>Mixamo</strong> motion packs. Mixamo is a complete solution for character production, rigging, and animation. In fact, the character in use was designed with Mixamo's character creation software called <strong>Fuse</strong>, and rigged <a class="indexterm" id="id693"/>with the Mixamo <strong>Auto-rigger</strong>. You can find out more about Mixamo and their <a class="indexterm" id="id694"/>products at Unity's Asset Store (<a class="ulink" href="https://www.assetstore.unity3d.com/en/#!/publisher/150">https://www.assetstore.unity3d.com/en/#!/publisher/150</a>) or their <a class="indexterm" id="id695"/>website at <a class="ulink" href="https://www.mixamo.com/">https://www.mixamo.com/</a>.</p><p>Please note that although Mixamo offers Mecanim-ready characters and animation clips, we will use, for the recipes in this chapter, unprepared animation clips. The reason is to make you more confident when dealing with assets obtained by other methods and sources.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Configuring a character's Avatar and idle animation</h1></div></div></div><p>A feature that makes Mecanim so flexible and powerful is the ability of quickly reassigning animation clips from one character to another. This is made possible through the use of <strong>Avatars</strong>, which are basically a layer between your character's original rig and the Unity's <a class="indexterm" id="id696"/><strong>Animator</strong> system.</p><p>In this recipe, we <a class="indexterm" id="id697"/>will learn how to configure an Avatar skeleton on a rigged character.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec194"/>Getting ready</h2></div></div></div><p>For this recipe, you will need the <code class="literal">MsLaser@T-Pose.fbx</code> and <code class="literal">Swat@rifle_aiming_idle.fbx</code> files, which are contained inside the <code class="literal">1362_07_code/character_and_clips/</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec195"/>How to do it...</h2></div></div></div><p>To configure an<a class="indexterm" id="id698"/> Avatar skeleton, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">MsLaser@T-Pose.fbx</code> and <code class="literal">Swat@rifle_aiming_idle.fbx</code> files to your project.</li><li class="listitem">Select from the <strong>Project</strong> view, the <code class="literal">MsLaser@T-Pose</code> model.</li><li class="listitem">In the <strong>Inspector</strong> view, under <strong>MsLaser@T-Pose Import Settings</strong>, activate the <strong>Rig</strong> section. Change <strong>Animation Type</strong> to <strong>Humanoid</strong>. Then, leave <strong>Avatar Definition</strong> as <strong>Create From this Model</strong>. Finally, click on the <strong>Configure…</strong> button.<div><img alt="How to do it..." src="img/1362OT_07_01.jpg"/></div></li><li class="listitem"><strong>Inspector</strong> view will show the newly created Avatar. Observe how Unity correctly mapped the bones of our character into its structure, assigning, for instance, the <strong>mixamoRig:LeftForeArm</strong> bone as the Avatar's <strong>Lower Arm</strong>. We could, of course, reassign bones if needed. For now, just click on the <strong>Done</strong> button to close the view.<div><img alt="How to do it..." src="img/1362OT_07_02.jpg"/></div></li><li class="listitem">Now that we have our Avatar ready, let's configure our animation for the <strong>Idle</strong> state. From<a class="indexterm" id="id699"/> the <strong>Project</strong> view, select the <strong>Swat@rifle_aiming_idle</strong> file.</li><li class="listitem">Activate the<a class="indexterm" id="id700"/> <strong>Rig</strong> section, change <strong>Animation Type</strong> to <strong>Humanoid</strong> and <strong>Avatar Definition</strong> to <strong>Create From This Model</strong>. Confirm by clicking on <strong>Apply</strong>.<div><img alt="How to do it..." src="img/1362OT_07_03.jpg"/></div></li><li class="listitem">Activate the <strong>Animations</strong> section (to the right of the <strong>Rig</strong>). Select the <strong>rifle_aiming_idle</strong> clip (from the <strong>Clips</strong> list). The <strong>Preview area</strong> (at the bottom of the Inspector) will display the message as <strong>No model is available for preview. Please </strong><a class="indexterm" id="id701"/><strong>drag a model into this Preview area</strong>. Drag <strong>MsLaser@T-Pose</strong> to the <strong>Preview</strong><a class="indexterm" id="id702"/> area to correct this.<div><img alt="How to do it..." src="img/1362OT_07_04.jpg"/></div></li><li class="listitem">With <strong>rifle_aiming_idle</strong> selected from the <strong>Clips</strong> list, check the <strong>Loop Time</strong> and <strong>Loop Pose</strong> options. Also, click on the <strong>Clamp Range</strong> button to adjust the timeline to the actual time of the animation clip. Then, under <strong>Root Transform Rotation</strong>, check <strong>Bake Into Pose</strong>, and select <strong>Baked Upon</strong> | <strong>Original</strong>. Under <strong>Root Transform Position (Y)</strong>, check <strong>Bake Into Pose</strong>, and select<strong> Baked upon (at Start)</strong> | <strong>Original</strong>. Under <strong>Root Transform Position (XZ)</strong>, leave <strong>Bake Into Pose </strong>unchecked, and select<strong> Baked Upon (at Start)</strong> | <strong>Center of Mass</strong>. Finally, click on <strong>Apply</strong> to confirm the changes.<div><img alt="How to do it..." src="img/1362OT_07_05.jpg"/></div></li><li class="listitem">In order to access animation clips and play them, we need to create a controller. Do<a class="indexterm" id="id703"/> this by clicking on the <strong>Create</strong> button from the <strong>Project</strong> view, and then selecting the <strong>Animator Controller</strong> option. Name it as <code class="literal">MainCharacter</code>.</li><li class="listitem">Double-click on the <strong>Animator Controller</strong> to open the <strong>Animator</strong> view.</li><li class="listitem">From the<a class="indexterm" id="id704"/> <strong>Animator</strong> view, right-click on the grid to open a context menu. Then, select the <strong>Create State</strong> |<strong> Empty</strong> option<strong>.</strong> A new box named <strong>New State</strong> will appear. It will be in orange, indicating that it is the default state.<div><img alt="How to do it..." src="img/1362OT_07_06.jpg"/></div></li><li class="listitem">Select <strong>New State</strong> and, in the <strong>Inspector</strong> view, change its name to <code class="literal">Idle</code>. Also, in the <strong>Motion</strong> field, choose <strong>rifle_aiming_idle</strong> by either selecting it from the list or dragging it<a class="indexterm" id="id705"/> from the <strong>Project</strong> view.<div><img alt="How to do it..." src="img/1362OT_07_07.jpg"/></div></li><li class="listitem">Drag the<a class="indexterm" id="id706"/> <code class="literal">MsLaser@T-Pose</code> model from the <strong>Project</strong> view into the <strong>Hierarchy</strong> view and place it on the scene.</li><li class="listitem">Select <strong>MsLaser@T-Pose</strong> from the <strong>Hierarchy</strong> view and observe its <strong>Animator</strong> component in the <strong>Inspector</strong> view. Then, assign the newly created <strong>MainCharacter controller</strong> to its <strong>Controller</strong> field.<div><img alt="How to do it..." src="img/1362OT_07_08.jpg"/></div></li><li class="listitem">Play your scene to see the character correctly animated.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec196"/>How it works...</h2></div></div></div><p>Preparing our character for animation took many steps. First, we created its <strong>Avatar</strong>, based on the character model's original bone structure. Then, we set <a class="indexterm" id="id707"/>up the <strong>animation clip</strong> (which, as the character mesh, is stored in a <code class="literal">.fbx</code> file), using its own Avatar. After this, we adjusted the<a class="indexterm" id="id708"/> animation clip, clamping its size and making it a loop. We also baked its <strong>Root Transform Rotation</strong> to obey the original file's orientation. Finally, an <a class="indexterm" id="id709"/><strong>Animator Controller</strong> was created, and the edited animation clip was made into its default <strong>Animation state</strong>.</p><p>The concept of the <a class="indexterm" id="id710"/>Avatar is what makes Mecanim so flexible. Once you have a <a class="indexterm" id="id711"/><strong>Controller</strong>, you can apply it to other humanoid characters, as long as they have an Avatar body mask. If you want to try it yourself, import <code class="literal">mascot.fbx</code>, which is also available inside the <code class="literal">charater_and_clips</code> folder, apply steps 3 and 4 into this character, place it on the scene, and apply <strong>MainCharacter</strong> as its <strong>Controller</strong> in the <strong>Animator</strong> component. Then, play the scene to see the mascot playing the <strong>rifle_aiming_idle</strong> animation clip.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec197"/>There's more...</h2></div></div></div><p>To read more<a class="indexterm" id="id712"/> information about the Animator Controller, check out Unity's documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/class-AnimatorController.html">http://docs.unity3d.com/Manual/class-AnimatorController.html</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec71"/>Moving your character with root motion and Blend Trees</h1></div></div></div><p>The Mecanim animation <a class="indexterm" id="id713"/>system is capable of applying Root Motion to characters. In other words, it <em>actually</em> moves the character according to the animation clip, as opposed to arbitrarily translating the character model while playing an in-place animation cycle. This <a class="indexterm" id="id714"/>makes most of the Mixamo <a class="indexterm" id="id715"/>animation clips perfect for use with Mecanim.</p><p>Another feature of the animation system is <strong>Blend Trees</strong>, which can blend animation clips smoothly and easily. In this recipe, we will take advantage of these features to make our character walk/run<a class="indexterm" id="id716"/> forward and backwards, and also strafe right and left at different speeds.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec198"/>Getting ready</h2></div></div></div><p>For this recipe, we have prepared a Unity package named <code class="literal">Character_02</code>, containing a character and featuring a basic Animator Controller. The package can be found inside the <code class="literal">1362_07_02</code> folder, along with the <code class="literal">.fbx</code> files for the necessary animation clips.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec199"/>How to do it...</h2></div></div></div><p>To apply the Root Motion to your character using <strong>Blend Trees</strong>, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import <code class="literal">Character_02.unityPackage</code> into a new project. Also, import <code class="literal">Swat@rifle_run, Swat@run_backwards, Swat@strafe, Swat@strafe_2, Swat@strafe_left, Swat@strafe_right, Swat@walking</code>,<code class="literal"> and Swat@walking_backwards .fbx</code> files.</li><li class="listitem">We need to configure our animation clips. From the <strong>Project view</strong>, select <strong>Swat@rifle_run</strong>.</li><li class="listitem">Activate the <strong>Rig</strong> section. Change <strong>Animation Type</strong> to <strong>Humanoid</strong> and <strong>Avatar Definition</strong> to <strong>Create From this Model</strong>. Confirm by clicking on <strong>Apply</strong>.<div><img alt="How to do it..." src="img/1362OT_07_09.jpg"/></div></li><li class="listitem">Now, activate the <strong>Animations</strong> section (to the right of <strong>Rig</strong>). Select the <strong>rifle_run</strong> clip (from the <strong>Clips</strong> list). The <strong>Preview area</strong> (at the bottom of the <strong>Inspector</strong> view) will display the message as <strong>No model is available for preview. Please drag a model into this Preview area</strong>. Drag <strong>MsLaser@T-Pose </strong>onto the <strong>Preview</strong> area to correct this.</li><li class="listitem">With <strong>rifle_run</strong> selected<a class="indexterm" id="id717"/> from the <strong>Clips</strong> list, select the <strong>rifle_run</strong> clip (from the <strong>Clips</strong> list) and check the <strong>Loop Time</strong> and <strong>Loop Pose</strong> options. Also, click on the <strong>Clamp Range</strong><a class="indexterm" id="id718"/> button to adjust the timeline to the actual time of the animation clip.</li><li class="listitem">Then, under<a class="indexterm" id="id719"/> <strong>Root Transform Rotation</strong>, check <strong>Bake Into Pose</strong>, and select<strong> Baked Upon (at Start)</strong> | <strong>Original</strong>. Under <a class="indexterm" id="id720"/><strong>Root Transform Position (Y)</strong>, check <strong>Bake Into Pose</strong>, and select<strong> Baked Upon</strong> | <strong>Original</strong>. Under <strong>Root Transform Position (XZ)</strong>, leave <strong>Bake Into Pose </strong>unchecked, and select<strong> Baked Upon (at Start)</strong> | <strong>Center of Mass</strong>. Finally, click on <strong>Apply</strong> to confirm the changes.<div><img alt="How to do it..." src="img/1362OT_07_10.jpg"/></div></li><li class="listitem">Repeat steps 3 to 6 for each one of the following animation clips: <strong>Swat@run_backwards</strong>, <strong>Swat@strafe</strong>, <strong>Swat@strafe_2</strong>, <strong>Swat@strafe_left</strong>, <strong>Swat@strafe_right</strong>, <strong>Swat@walking</strong>, and <strong>Swat@walking_backwards</strong>.</li><li class="listitem">From the <strong>Project view</strong>, select the <strong>MsLaser</strong> prefab and drag it onto the <strong>Hierarchy</strong> view, placing it on the scene.</li><li class="listitem">From the <strong>Hierarchy</strong> view, select the <strong>MsLaser</strong> GameObject and attach a <strong>Character Controller</strong> component to it (<strong>menu Component</strong> | <strong>Physics</strong> | <strong>Character Controller</strong>). Then, set its <strong>Skin Width</strong> as <code class="literal">0.0001</code>, and its <strong>Center</strong> as <strong>X</strong>: <strong>0</strong>, <strong>Y</strong>: <strong>0.9</strong>, <strong>Z</strong>: <strong>0</strong>; also change its <strong>Radius</strong> to <strong>0.34</strong> and its <strong>Height</strong> to <strong>1.79</strong>.<div><img alt="How to do it..." src="img/1362OT_07_11.jpg"/></div></li><li class="listitem">In the <strong>Project </strong><a class="indexterm" id="id721"/><strong>view</strong>, open the <strong>MainCharacter</strong> controller.</li><li class="listitem">In the top-left <a class="indexterm" id="id722"/>corner of the <strong>Animator</strong> view, activate the <strong>Parameters</strong> section and use the <strong>+</strong> sign to create three new <strong>Parameters (Float) </strong>named <code class="literal">xSpeed</code>, <code class="literal">zSpeed</code>, and <a class="indexterm" id="id723"/><code class="literal">Speed</code>.</li><li class="listitem">We do have an <strong>Idle</strong> <a class="indexterm" id="id724"/>state for our character, but we need the new ones. Right-click on the gridded area and, from the context menu, navigate to <strong>Create State</strong> | <strong>From New Blend Tree</strong>. Change its name, from the <strong>Inspector</strong> view, to <code class="literal">Move</code>.<div><img alt="How to do it..." src="img/1362OT_07_12.jpg"/></div></li><li class="listitem">Double-click on the <strong>Move</strong> state. You will see the empty blend tree that you have created. Select it and, in the <strong>Inspector</strong> view, rename it to <code class="literal">Move</code>. Then, change its <strong>Blend Type</strong> to <strong>2D Freeform Directional</strong>, also setting <strong>xSpeed</strong> and <strong>zSpeed</strong> in the <strong>Parameters</strong> tab. Finally, using the <strong>+</strong> sign from the bottom<a class="indexterm" id="id725"/> of the <strong>Motion</strong> list, add nine new <strong>Motion Fields</strong>.<div><img alt="How to do it..." src="img/1362OT_07_13.jpg"/></div></li><li class="listitem">Now, populate<a class="indexterm" id="id726"/> the <strong>Motion</strong> list with the following motion <a class="indexterm" id="id727"/>clips and respective <strong>Pos X</strong> and <strong>Pos Y</strong> values: <strong>run_backwards</strong>, <code class="literal">0</code>, <code class="literal">-1</code>; <strong>walking_backwards</strong>, <code class="literal">0</code>,<code class="literal">-0.5</code>; <strong>rifle_aiming_idle</strong>, <code class="literal">0</code>, <code class="literal">0</code>; <strong>walking</strong>, <code class="literal">0</code>, <code class="literal">0.5</code>; <strong>rifle_run</strong>, <code class="literal">0</code>, <code class="literal">1</code>; <strong>strafe</strong>, <code class="literal">-1</code>,<code class="literal"> 0</code>; <strong>strafe_left</strong>, -<code class="literal">0.5</code>, <code class="literal">0</code>; <strong>strafe_right</strong>, <code class="literal">0.5</code>, <code class="literal">0</code>; <strong>strafe_2</strong>, <code class="literal">1</code>, <code class="literal">0</code>. You can populate the <strong>Motion</strong> list by selecting it from the list or, if there are more than one clip with the same name, you can <a class="indexterm" id="id728"/>drag it from the <strong>Project view</strong> onto the slot (by expanding the appropriate model icon).<div><img alt="How to do it..." src="img/1362OT_07_14.jpg"/></div></li><li class="listitem">Double-click on<a class="indexterm" id="id729"/> the gridded area to go from the <strong>Move</strong> blend tree back to the <strong>Base Layer</strong>.</li><li class="listitem">Since we <a class="indexterm" id="id730"/>have the <code class="literal">rifle_aiming_idle</code> Motion clip within our <strong>Move</strong> blend tree, we can get rid of the original <strong>Idle</strong> state. Right-click on the <strong>Idle</strong> state box and, from the menu, select <strong>Delete</strong>. The <a class="indexterm" id="id731"/><strong>Move</strong> blend state will become<a class="indexterm" id="id732"/> the new default state, turning orange.<div><img alt="How to do it..." src="img/1362OT_07_15.jpg"/></div></li><li class="listitem">Now, we must create the script that will actually transform the player's input into those variables that are created to control the animation.</li><li class="listitem">From<a class="indexterm" id="id733"/> the <strong>Project view</strong>, create a new <strong>C# Script</strong> and name it as <code class="literal">BasicController</code>.</li><li class="listitem">Open your<a class="indexterm" id="id734"/> script <a class="indexterm" id="id735"/>and replace everything with<a class="indexterm" id="id736"/> the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class BasicController: MonoBehaviour {
  private Animator anim;
  private CharacterController controller;
  public float transitionTime = .25f;
  private float speedLimit = 1.0f;
  public bool moveDiagonally = true;
  public bool mouseRotate = true;
  public bool keyboardRotate = false;

  void Start () {
    controller = GetComponent&lt;CharacterController&gt;();
    anim = GetComponent&lt;Animator&gt;();
  }
  
  void Update () {
    if(controller.isGrounded){
      if (Input.GetKey (KeyCode.RightShift) ||Input.GetKey (KeyCode.LeftShift))
        speedLimit = 0.5f;
      else
        speedLimit = 1.0f;
    
      float h = Input.GetAxis("Horizontal");
      float v = Input.GetAxis("Vertical");
      float xSpeed = h * speedLimit;
      float zSpeed = v * speedLimit;
      float speed = Mathf.Sqrt(h*h+v*v);

      if(v!=0 &amp;&amp; !moveDiagonally)
        xSpeed = 0;

      if(v!=0 &amp;&amp; keyboardRotate)
        this.transform.Rotate(Vector3.up * h, Space.World);

      if(mouseRotate)
        this.transform.Rotate(Vector3.up * (Input.GetAxis("Mouse X")) * Mathf.Sign(v), Space.World);

      anim.SetFloat("zSpeed", zSpeed, transitionTime, Time.deltaTime);
      anim.SetFloat("xSpeed", xSpeed, transitionTime, Time.deltaTime);
      anim.SetFloat("Speed", speed, transitionTime, Time.deltaTime);
    }
  }
}</pre></div></li><li class="listitem">Save your <a class="indexterm" id="id737"/>script and attach it to the <strong>MsLaser</strong> GameObject in the <strong>Hierarchy</strong> view. Then, add <strong>Plane</strong> (menu option <strong>GameObject</strong> | <strong>3D Object</strong> | <strong>Plane</strong>) and place it beneath the character.</li><li class="listitem">Play your<a class="indexterm" id="id738"/> scene and test the game. You will be able to control your character with the arrow keys (or <em>WASD</em> keys). Keeping<a class="indexterm" id="id739"/> the <em>Shift</em> key pressed will slow it down.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec200"/>How it works...</h2></div></div></div><p>Whenever the<a class="indexterm" id="id740"/> <code class="literal">BasicController</code> script detects any directional keys in use, it sets the <code class="literal">Speed</code> variable of the <strong>Animator</strong> state to a value higher than 0, changing the <strong>Animator</strong> state from <strong>Idle</strong> to <strong>Move</strong>. The <strong>Move</strong> state, in its turn, blends the motion clips that it was populated with, according to the input values for <code class="literal">xSpeed</code> (obtained from<a class="indexterm" id="id741"/> <strong>Horizontal Axis </strong>input, typically <em>A</em> and <em>D</em> keys) and <code class="literal">zSpeed</code> (obtained from<a class="indexterm" id="id742"/> <strong>Vertical Axis</strong> input, typically <em>W</em> and <em>S</em> keys). Since Mecanim is capable of applying root motion to the characters, our character will actually move in the resulting direction.</p><p>For instance, if <em>W</em> and <em>D</em> keys are pressed, <code class="literal">xSpeed</code> and <code class="literal">zSpeed</code> values will rise to 1.0. From the <strong>Inspector</strong> view, it is possible to see that such combination will result in a blend between the motion clips called <strong>rifle_run</strong> and <strong>strafe_2</strong>, making the character run diagonally (front + right).</p><div><img alt="How it works..." src="img/1362OT_07_18.jpg"/></div><p>Our <strong>BasicController</strong><a class="indexterm" id="id743"/> includes three checkboxes for more options: <strong>Move Diagonally</strong>—set as <strong>true</strong>, by default, which allows for blends between forward/backward and left/right clips; <strong>Mouse Rotate</strong>—set as <strong>true</strong>, by default, which allows<a class="indexterm" id="id744"/> for rotating the character with the mouse, changing their direction while moving; <strong>Keyboard Rotate</strong>—set as <strong>false</strong>, by default, which<a class="indexterm" id="id745"/> allows for rotating the character through<a class="indexterm" id="id746"/> simultaneous use of left/right and forward/backwards directional keys.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec201"/>There's more...</h2></div></div></div><p>Our blend tree used the <strong>2D Freeform Directional Blend Type</strong>. However, if we had only four animation clips (forward, backwards, left, and right), <strong>2D Simple Directional</strong> would have been a better option. Learn more on the following links:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn more about Blend<a class="indexterm" id="id747"/> Trees and 2D blending from Unity's Documentation at: <a class="ulink" href="http://docs.unity3d.com/Manual/BlendTree-2DBlending.html">http://docs.unity3d.com/Manual/BlendTree-2DBlending.html</a>.</li><li class="listitem" style="list-style-type: disc">Also, if you want to learn more about Mecanim Animation System, there are some links that you<a class="indexterm" id="id748"/> might want to check out, such as Unity's documentation at: <a class="ulink" href="http://docs.unity3d.com/Manual/AnimationOverview.html">http://docs.unity3d.com/Manual/AnimationOverview.html</a>.</li><li class="listitem" style="list-style-type: disc">Mecanim <a class="indexterm" id="id749"/>Example Scenes are available at Unity <a class="indexterm" id="id750"/>Asset Store at: <a class="ulink" href="https://www.assetstore.unity3d.com/en/#!/content/5328">https://www.assetstore.unity3d.com/en/#!/content/5328</a>.</li><li class="listitem" style="list-style-type: disc">Mecanim <a class="indexterm" id="id751"/>Video Tutorial are available at: <a class="ulink" href="http://unity3d.com/pt/learn/tutorials/topics/animation">http://unity3d.com/pt/learn/tutorials/topics/animation</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Mixing animations with Layers and Masks</h1></div></div></div><p>Mixing animations is a great way of adding complexity to your animated characters without requiring a vast number of animated clips. Using <strong>Layers</strong> and <strong>Masks</strong>, we can combine different animations by playing specific clips for the specific body parts of the character. In this<a class="indexterm" id="id752"/> recipe, we will apply this technique to our animated character, triggering animation clips for firing a rifle, and throwing a<a class="indexterm" id="id753"/> grenade with the character's upper body. We will do this while keeping the lower body moving or idle, according to the player's input.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec202"/>Getting ready</h2></div></div></div><p>For this recipe, we have prepared a Unity Package named <code class="literal">Mixing</code>, containing a basic scene that features an animated character. The package can be found inside the <code class="literal">1362_07_03</code> folder, along with the animation clips called <code class="literal">Swat@firing_rifle.fbx</code> and <code class="literal">Swat@toss_grenade.fbx</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec203"/>How to do it...</h2></div></div></div><p>To mix animations using layers and masks, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new project and import the <code class="literal">Mixing</code> Unity Package. Then, from the <strong>Project view</strong>, open the <strong>mecanimPlayground</strong> level.</li><li class="listitem">Import the <code class="literal">Swat@firing_rifle.fbx</code> and <code class="literal">Swat@toss_grenade.fbx</code> files to the project.</li><li class="listitem">We need to configure the animation clips. From the <strong>Project view</strong>, select the <strong>Swat@firing_rifle</strong> animation clip.</li><li class="listitem">Activate the <strong>Rig</strong> section. Change <strong>Animation Type</strong> to <strong>Humanoid</strong>, and <strong>Avatar Definition</strong> to <strong>Create From this Model</strong>. Confirm this by clicking on <strong>Apply</strong>.<div><img alt="How to do it..." src="img/1362OT_07_09.jpg"/></div></li><li class="listitem">Now, activate the <strong>Animations</strong> section. Select the <strong>firing_rifle</strong> clip (from the <strong>Clips</strong> list), click <a class="indexterm" id="id754"/>on the <strong>Clamp Range</strong> button to adjust the timeline, and check the <strong>Loop Time </strong>and <strong>Loop Pose</strong> <a class="indexterm" id="id755"/>options. Under <strong>Root Transform Rotation</strong>, check <strong>Bake Into Pose</strong>, and select <strong>Baked Upon</strong> | <strong>Original</strong>. Under <strong>Root Transform Position (Y)</strong>, check <strong>Bake Into Pose</strong>, and select <strong>Baked Upon (at Start)</strong> | <strong>Original</strong>. Under <strong>Root Transform Position (XZ)</strong>, leave <strong>Bake Into Pose</strong> unchecked. Click on<strong> Apply</strong> to confirm the changes.<div><img alt="How to do it..." src="img/1362OT_07_19.jpg"/></div></li><li class="listitem">Select the <a class="indexterm" id="id756"/><strong>Swat@toss_grenade</strong><a class="indexterm" id="id757"/> animation clip. Activate the <strong>Rig</strong> section. Then, change <strong>Animation Type</strong> to <strong>Humanoid</strong>, and <strong>Avatar Definition</strong> to <strong>Create From this Model</strong>. Confirm it by clicking on <strong>Apply</strong>.</li><li class="listitem">Now, activate the <strong>Animations</strong> section. Select the <strong>toss_grenade</strong> clip (from the <strong>Clips</strong> list), click on the button <strong>Clamp Range</strong> to adjust the timeline, and leave the <strong>Loop Time </strong>and <strong>Loop Pose</strong> options unchecked. Under <strong>Root Transform Rotation</strong>, check <strong>Bake Into Pose</strong>, and select <strong>Baked Upon (at Start)</strong> | <strong>Original</strong>. Under <strong>Root Transform Position (Y)</strong>, check <strong>Bake Into Pose</strong>, and select <strong>Baked Upon (at Start)</strong> | <strong>Original)</strong>. Under <strong>Root Transform Position (XZ)</strong>, leave <strong>Bake Into Pose</strong> unchecked. Click on <strong>Apply</strong> to confirm the changes.</li><li class="listitem">Let's create a<a class="indexterm" id="id758"/> Mask. From the <strong>Project</strong> view, click on the <strong>Create</strong> button and add an <strong>Avatar Mask</strong> to the project. Name it <a class="indexterm" id="id759"/>as <strong>BodyMask</strong>.</li><li class="listitem">Select the <strong>BodyMask</strong> tab and, in the <strong>Inspector</strong> view, expand the <strong>Humanoid</strong> section to unselect the character's legs, base, and <strong>IK</strong> spots, turning their outline red.<div><img alt="How to do it..." src="img/1362OT_07_20.jpg"/></div></li><li class="listitem">From the <strong>Hierarchy</strong> view, select the <strong>MsLaser</strong> character. Then, from the <strong>Animator</strong> component in the <strong>Inspector</strong> view, double-click on the <strong>MainCharacter</strong> controller to open it.</li><li class="listitem">In the <strong>Animator</strong> view, create a new layer by clicking on the <strong>+</strong> sign at the top-left <strong>Layers </strong>tab, above the <strong>Base Layer</strong>.</li><li class="listitem">Name the new <a class="indexterm" id="id760"/>layer as <strong>UpperBody</strong> and click on the gear icon for the settings. Then, change its <strong>Weight</strong> to <code class="literal">1</code>, and <a class="indexterm" id="id761"/>select the <strong>BodyMask</strong> in the <strong>Mask</strong> slot. Also, change Blending to <strong>Additive</strong>.<div><img alt="How to do it..." src="img/1362OT_07_21.jpg"/></div></li><li class="listitem">Now, in the <strong>Animator</strong> view, with the <strong>UpperBody</strong> layer selected, create three new empty states (by right-clicking on the gridded area and navigating to, from the menu, <strong>Create State</strong> | <strong>Empty</strong>). Name the default (orange) state <strong>null</strong>, and the other two as <strong>Fire</strong> and <strong>Grenade</strong>.</li><li class="listitem">Now, access the <strong>Parameters</strong> tab and add two new parameters of the Boolean type: <code class="literal">Fire</code> and <code class="literal">Grenade</code>.<div><img alt="How to do it..." src="img/1362OT_07_22.jpg"/></div></li><li class="listitem">Select the <strong>Fire</strong> state and, in the <strong>Inspector</strong> view, add the <strong>firing_rifle</strong> animation clip to the <strong>Motion</strong> field.<div><img alt="How to do it..." src="img/1362OT_07_23.jpg"/></div></li><li class="listitem">Now, select the <strong>Grenade</strong> state and, in the <strong>Inspector</strong> view, add the <strong>toss_grenade</strong><a class="indexterm" id="id762"/> animation clip to the <strong>Motion</strong> field.</li><li class="listitem">Right-click on the<a class="indexterm" id="id763"/> <strong>null</strong> state box and, from the menu, select <strong>Make Transition</strong>. Then, drag the white arrow onto the <strong>Fire</strong> box.</li><li class="listitem">Select the arrow (it will turn blue). From the <strong>Inspector</strong> view, uncheck the <strong>Has Exit Time</strong> option. Then, access the <strong>Conditions</strong> list, click on the <strong>+</strong> sign to add a new condition, and set it as <strong>Fire</strong> and <strong>true</strong>.<div><img alt="How to do it..." src="img/1362OT_07_24.jpg"/></div></li><li class="listitem">Now, make a transition from <strong>null</strong> to <strong>Grenade</strong>. Select the arrow (it will turn blue). From the <strong>Inspector</strong> view, uncheck the <strong>Has Exit Time</strong> option. Then, access the <a class="indexterm" id="id764"/><strong>Conditions</strong> list, click on the <strong>+</strong> sign to add a new condition, and set it as <strong>Grenade</strong> and <strong>true</strong>.</li><li class="listitem">Now, create<a class="indexterm" id="id765"/> transitions from <strong>Fire</strong> to <strong>null</strong>, and from <strong>Grenade</strong> to <strong>null</strong>. Then, select the arrow that goes from <strong>Fire</strong> to <strong>null</strong> and, in the <strong>Conditions</strong> box, select the <strong>Fire</strong> and <strong>false</strong> options. Leave the <strong>Has Exit Time </strong>option checked.</li><li class="listitem">Finally, select the arrow that goes from <strong>Grenade</strong> to <strong>null</strong>. In the Conditions box, select the options <code class="literal">Grenade</code>, <code class="literal">false</code>. Leave the <strong>Has Exit Time </strong>option checked.<div><img alt="How to do it..." src="img/1362OT_07_25.jpg"/></div></li><li class="listitem">From the <strong>Hierarchy</strong> view, select the <strong>MsLaser</strong> character. Locate, in the <strong>Inspector</strong> view, the <strong>Basic Controller </strong>component and open its script.</li><li class="listitem">Immediately<a class="indexterm" id="id766"/> before the end of the<a class="indexterm" id="id767"/> <code class="literal">Update()</code> function, add the following code:<div><pre class="programlisting">  if(Input.GetKeyDown(KeyCode.F)){
    anim.SetBool("Grenade", true);
  } else {
    anim.SetBool("Grenade", false);
  }
  if(Input.GetButtonDown("Fire1")){
    anim.SetBool("Fire", true);
  }
  if(Input.GetButtonUp("Fire1")){
    anim.SetBool("Fire", false);
  }</pre></div></li><li class="listitem">Save the script and play your scene. You will be able to trigger the <strong>firing_rifle</strong> and <strong>toss_grenade</strong> animations by clicking on the <strong>fire</strong> button and pressing the <em>F</em> key. Observe how the character's legs still respond to the <strong>Move</strong> animation state.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec204"/>How it works...</h2></div></div></div><p>Once the Avatar mask is created, it can be used as a way of filtering the body parts that would actually play<a class="indexterm" id="id768"/> the animation states of a particular layer. In our case, we have constrained our <strong>fire_rifle</strong> and <strong>toss_grenade</strong> animation<a class="indexterm" id="id769"/> clips to the upper body of our character, leaving the lower body free to play the movement-related animation clips, such as walking, running, and strafing.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec205"/>There's more...</h2></div></div></div><p>You might have noticed that the <strong>UpperBody</strong> layer has a parameter named <strong>Blending</strong>, which we have set to <strong>Additive</strong>. This means that animation states in this layer will be added to the ones from the lower layers. If changed to <strong>Override</strong>, the animation from this would override animation states from the lower layers when played. In our case, <strong>Additive</strong> helped in keeping the aim stable when firing while running.</p><p>For more information on<a class="indexterm" id="id770"/> <strong>Animation Layers</strong> and <strong>Avatar Body Masks</strong>, check out<a class="indexterm" id="id771"/> Unity's documentation at <a class="ulink" href="http://docs.unity3d.com/Manual/AnimationLayers.html">http://docs.unity3d.com/Manual/AnimationLayers.html</a> and <a class="ulink" href="http://docs.unity3d.com/Manual/class-AvatarMask.html">http://docs.unity3d.com/Manual/class-AvatarMask.html</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec73"/>Organizing States into Sub-state Machines</h1></div></div></div><p>Whenever the Animator area gets too cluttered, you can always think of organizing your Animation<a class="indexterm" id="id772"/> States into Sub-State Machines. In this recipe, we will use this technique to organize animation states for turning the character. Also, since<a class="indexterm" id="id773"/> the provided animation clips do not include Root Motion, we will use the opportunity to illustrate how to overcome the lack of Root Motion via script, using it to turn the character 45 degrees to the left and right.</p><div><img alt="Organizing States into Sub-state Machines" src="img/1362OT_07_37.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec206"/>Getting ready</h2></div></div></div><p>For this recipe, we have prepared a Unity Package named <code class="literal">Turning</code>, containing a basic scene that features an animated character. The package can be found inside the <code class="literal">1362_07_04</code> folder, along with animation clips called <code class="literal">Swat@turn_right_45_degrees.fbx</code> and <code class="literal">Swat@turn_left.fbx</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec207"/>How to do it...</h2></div></div></div><p>To apply Root<a class="indexterm" id="id774"/> Motion via script, please follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new project and import the <code class="literal">Turning</code> Unity Package. Then, from the <strong>Project</strong> view, open the <strong>mecanimPlayground</strong> level.</li><li class="listitem">Import the <code class="literal">Swat@turn_right_45_degrees.fbx</code> and <code class="literal">Swat@turn_left.fbx</code> files in the project.</li><li class="listitem">We need to configure our animation clips. Select the <strong>Swat@turn_left</strong> file from the <strong>Project</strong> view.</li><li class="listitem">Activate the <a class="indexterm" id="id775"/><strong>Rig</strong> section. Change <strong>Animation Type</strong> to <strong>Humanoid</strong>, and <strong>Avatar Definition</strong> to <strong>Create From this Model</strong>. Confirm by clicking on <strong>Apply</strong>.</li><li class="listitem">Now, activate the <strong>Animations</strong> section. Select the <strong>turn_left</strong> clip (from the <strong>Clips</strong> list), click on the <strong>Clamp Range</strong> button to adjust the timeline, and check the <strong>Loop Time</strong> option. Under <strong>Root Transform Rotation</strong>, check <strong>Bake Into Pose</strong>, and navigate to <strong>Baked Upon (at Start)</strong> | <strong>Original</strong>. Under <strong>Root Transform Position (Y)</strong>, check <strong>Bake Into Pose</strong>, and select <strong>Baked Upon (at Start)</strong> | <strong>Original</strong>. Under <strong>Root Transform Position (XZ)</strong>, leave <strong>Bake Into Pose</strong> unchecked. Click on <strong>Apply</strong> to confirm the changes.<div><img alt="How to do it..." src="img/1362OT_07_26.jpg"/></div></li><li class="listitem">Repeat steps 4 and 5 for <strong>Swat@turning_right_45_degrees</strong>.</li><li class="listitem">From the <strong>Hierarchy</strong> view, select the <strong>MsLaser</strong> character. Then, from the <strong>Animator</strong> <a class="indexterm" id="id776"/>component in the <strong>Inspector</strong> view, open the <strong>MainCharacter</strong> controller.</li><li class="listitem">From the top-left corner <a class="indexterm" id="id777"/>of the <strong>Animator</strong> view, activate the <strong>Parameters</strong> section and use the <strong>+</strong> sign to create the two new <strong>Parameters (Boolean) </strong>named <code class="literal">TurnLeft</code> and <code class="literal">TurnRight</code>.</li><li class="listitem">Right-click on the gridded area. From the context menu, select <strong>Create Sub-State Machine</strong>. From the <strong>Inspector</strong> view, rename it <code class="literal">Turn</code>.<div><img alt="How to do it..." src="img/1362OT_07_27.jpg"/></div></li><li class="listitem">Double-click on the <strong>Turn</strong> sub-state machine. Right-click on the gridded area, select <strong>Create State</strong> | <strong>Empty</strong>, and add a new state. Rename it to <code class="literal">Turn Left</code>. Then, add <a class="indexterm" id="id778"/>another state named <code class="literal">Turn Right</code>.</li><li class="listitem">From the <strong>Inspector</strong> <a class="indexterm" id="id779"/>view, populate <code class="literal">Turn Left</code> with the <strong>turn_left</strong> motion clip. Then, populate <code class="literal">Turn Right </code>with <strong>turning_right_45_degrees</strong>.<div><img alt="How to do it..." src="img/1362OT_07_28.jpg"/></div></li><li class="listitem">Get out of the <strong>Turn</strong> sub-state machine back into the <strong>Base Layer</strong>. By right-clicking on each state and selecting the option <strong>Make Transition</strong>, create transitions between <strong>Move </strong>and <strong>Turn Left</strong>, and <strong>Move </strong>and <strong>Turn Right</strong>.<div><img alt="How to do it..." src="img/1362OT_07_29.jpg"/></div></li><li class="listitem">Enter the <strong>Turn</strong> sub-state machine. Then, create transitions from <strong>Turn Left</strong> and <strong>Turn Right</strong> into the <strong>Move</strong> state.<div><img alt="How to do it..." src="img/1362OT_07_30.jpg"/></div></li><li class="listitem">Select the arrow<a class="indexterm" id="id780"/> that goes form <strong>Turn Right</strong> to <strong>(Up) Base Layer</strong>. It will turn blue. From the <strong>Inspector</strong> view, uncheck the <strong>Has Exit Time</strong> option. Then, access the <strong>Conditions</strong> list, click<a class="indexterm" id="id781"/> the <strong>+</strong> sign to add a new condition, and set it as <strong>TurnRight</strong> and <strong>false</strong>.<div><img alt="How to do it..." src="img/1362OT_07_31.jpg"/></div></li><li class="listitem">Select the arrow that goes from <strong>(Up) Base Layer</strong> to <strong>Turn Right</strong>. From the <strong>Inspector</strong> view, uncheck the <strong>Has Exit Time</strong> option. Then, access the <strong>Conditions</strong> list, click the <strong>+</strong> sign to add a new condition, and set it as <strong>TurnRight</strong> and <strong>true</strong>.</li><li class="listitem">Repeat steps 14 and 15 with the arrows that go between <strong>(Up) Base Layer</strong> and <strong>Turn Left</strong>, using <strong>TurnLeft</strong> as a condition, this time.</li><li class="listitem">From the <strong>Hierarchy</strong> view, select the <strong>MsLaser</strong> character. Then, from the <strong>Inspector</strong> view, open the script from the <strong>BasicController</strong> component.</li><li class="listitem">Immediately<a class="indexterm" id="id782"/> after the <code class="literal">if(controller.isGrounded){</code> line, add:<div><pre class="programlisting">if(Input.GetKey(KeyCode.Q)){
  anim.SetBool("TurnLeft", true);
  transform.Rotate(Vector3.up * (Time.deltaTime * -45.0f), Space.World);
}  else {
  anim.SetBool("TurnLeft", false);
}
if(Input.GetKey(KeyCode.E)){
  anim.SetBool("TurnRight", true);
  transform.Rotate(Vector3.up * (Time.deltaTime * 45.0f), Space.World);
} else {
  anim.SetBool("TurnRight", false);
}</pre></div></li><li class="listitem">Save your script. Then, select the <strong>MsLaser</strong> character and, from the <strong>Inspector</strong> view, access the<a class="indexterm" id="id783"/> <strong>Basic Controller</strong> component. Leave the <strong>Move Diagonally</strong> and <strong>Mouse Rotate</strong> options unchecked. Also, leave the <strong>Keyboard Rotate</strong> option checked. Finally, play the scene. You <a class="indexterm" id="id784"/>will be able to turn left and right by using the <em>Q</em> and <em>E</em> keys, respectively.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec208"/>How it works...</h2></div></div></div><p>As it should be clear from the recipe, the sub-state machines work in a similar way to groups or folders, allowing you to encapsulate a series of state machines into a single entity for easier reference. States from the sub-state machines can be transitioned from external states, in our case, the<a class="indexterm" id="id785"/> <strong>Move</strong> state, or even from different sub-state machines.</p><p>Regarding the character's rotation, we have overcome the lack of root motion by using the <code class="literal">transform.Rotate(Vector3.up * (Time.deltaTime * -45.0f), Space.World);</code> command to make the character actually turn around when the <em>Q</em> and <em>E</em> keys are being held down. This command was used in conjunction with <code class="literal">animator.SetBool("TurnLeft", true);</code>, which triggers the right animation clip.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec74"/>Transforming the Character Controller via script</h1></div></div></div><p>Applying <strong>Root Motion</strong> to your character might be a very practical and accurate way to animate it. However, every now and then, you might need to manually control one or two aspects of the <a class="indexterm" id="id786"/>character movement. Perhaps you only have an in-place animation to work with, or maybe you want the character's movement to be affected by<a class="indexterm" id="id787"/> other variables. In these cases, you will need to override the root motion via script.</p><p>To illustrate this issue, this recipe makes use of an animation clip for jumping, which originally moves the character only in the Y-axis. In order to make her move forward or backwards while jumping, we will learn how to access the character's velocity to inform the jump's direction via the script.</p><div><img alt="Transforming the Character Controller via script" src="img/1362OT_07_38.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec209"/>Getting ready</h2></div></div></div><p>For this recipe, we have prepared a Unity Package named <code class="literal">Jumping</code>, containing a basic scene that features an animated character. The package can be found inside the <code class="literal">1362_07_05</code> folder, along with the animation clip called <code class="literal">Swat@rifle_jump</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec210"/>How to do it...</h2></div></div></div><p>To apply the Root Motion via script, please follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new project and import the <code class="literal">Jumping</code> Unity Package. Then, from the <strong>Project</strong> view, open the <strong>mecanimPlayground</strong> level.</li><li class="listitem">Import the <code class="literal">Swat@rifle_jump.fbx</code> file to the project.</li><li class="listitem">We need to configure our animation clip. From the <strong>Project </strong>view, select the <strong>Swat@rifle_jump</strong> file.</li><li class="listitem">Activate the <strong>Rig</strong> section. Change <strong>Animation Type</strong> to <strong>Humanoid</strong>, and <strong>Avatar Definition</strong> to <strong>Create From this Model</strong>. Confirm this by clicking on <strong>Apply</strong>.</li><li class="listitem">Now, activate the <strong>Animations</strong> section. Select the <strong>rifle_jump </strong>clip (from the <strong>Clips</strong> list), click<a class="indexterm" id="id788"/> on the <strong>Clamp Range</strong> button to adjust the timeline, and check the <strong>Loop Time </strong>and <strong>Loop Pose</strong> options. Under <strong>Root Transform Rotation</strong>, check <strong>Bake Into Pose</strong>, and select <strong>Baked Upon (at Start)</strong> | <strong>Original</strong>. Under <strong>Root Transform Position (Y)</strong>, leave <strong>Bake into Pose </strong>unchecked, and select <strong>Baked Upon (at Start)</strong> | <strong>Original</strong>. Under <strong>Root Transform Position (XZ)</strong>, leave <strong>Bake Into Pose</strong> unchecked. Click on<strong> Apply</strong> to confirm the changes.<div><img alt="How to do it..." src="img/1362OT_07_32.jpg"/></div></li><li class="listitem">From the <strong>Hierarchy</strong> view, select the <strong>MsLaser</strong> character. Then, from the <strong>Animator</strong> component in the <strong>Inspector</strong> view, open the <strong>MainCharacter</strong> controller.</li><li class="listitem">From the top-left corner of the <strong>Animator</strong> view, activate the <strong>Parameters</strong> section, and use the <strong>+</strong> sign to create a new <strong>Parameters (Boolean) </strong>named <code class="literal">Jump</code>.</li><li class="listitem">Right-click on the <a class="indexterm" id="id789"/>gridded area and, from the context menu, select <strong>Create State</strong> | <strong>Empty</strong>. Change its name, from the <strong>Inspector</strong> view, to <code class="literal">Jump</code>.<div><img alt="How to do it..." src="img/1362OT_07_33.jpg"/></div></li><li class="listitem">Select the <strong>Jump</strong> state. Then, from the <strong>Inspector</strong> view, populate it with the <strong>rifle_jump</strong> Motion clip.<div><img alt="How to do it..." src="img/1362OT_07_34.jpg"/></div></li><li class="listitem">Find and right-click on the <strong>Any State</strong>. Then, selecting the <strong>Make Transition</strong> option, create a transition from <strong>Any State</strong> to <strong>Jump</strong>. Select the transition, uncheck <strong>Has Exit Time</strong>, and use the <strong>Jump</strong> variable as a condition (<strong>true</strong>).</li><li class="listitem">Now, create a transition from <strong>Jump</strong> to <strong>Move</strong>.<div><img alt="How to do it..." src="img/1362OT_07_35.jpg"/></div></li><li class="listitem">Configure the<a class="indexterm" id="id790"/> transitions between <strong>Jump</strong> and <strong>Move</strong>, leaving <strong>Has Exit Time</strong> checked, and use the <strong>Jump</strong> variable as a condition (<strong>false</strong>).<div><img alt="How to do it..." src="img/1362OT_07_36.jpg"/></div></li><li class="listitem">From the <strong>Hierarchy</strong> view, select the <strong>MsLaser</strong> character. Then, from the <strong>Inspector</strong> view, open the script from the <strong>BasicController</strong> component.</li><li class="listitem">Right before the <code class="literal">Start()</code> function, add the following code:<div><pre class="programlisting">public float jumpHeight = 3f;
private float verticalSpeed = 0f;
private float xVelocity = 0f;
private float zVelocity = 0f;</pre></div></li><li class="listitem">Inside the <code class="literal">Update()</code> function, find the line containing the following code:<div><pre class="programlisting">if(controller.isGrounded){</pre></div><p>And add the following lines immediatly after it:</p><div><pre class="programlisting">if (Input.GetKey (KeyCode.Space)) {
  anim.SetBool ("Jump", true);
  verticalSpeed = jumpHeight;
}</pre></div></li><li class="listitem">Finally, add a<a class="indexterm" id="id791"/> new function, following immediately before the final <code class="literal">}</code> of the code:<div><pre class="programlisting">  void OnAnimatorMove(){
    Vector3 deltaPosition = anim.deltaPosition;
    if (controller.isGrounded) {
      xVelocity = controller.velocity.x;
      zVelocity = controller.velocity.z;
    } else {
      deltaPosition.x = xVelocity * Time.deltaTime;
      deltaPosition.z = zVelocity * Time.deltaTime;
      anim.SetBool ("Jump", false);
    }
    deltaPosition.y = verticalSpeed * Time.deltaTime;
    controller.Move (deltaPosition);
    verticalSpeed += Physics.gravity.y * Time.deltaTime;
    if ((controller.collisionFlags &amp; CollisionFlags.Below) != 0) {
      verticalSpeed = 0;
    }
  }</pre></div></li><li class="listitem">Save your script and play the scene. You will be able to jump around using the <em>Space</em> key. Observe how the character's velocity affects the direction of the jump.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec211"/>How it works...</h2></div></div></div><p>Observe that once this function is added to the script, the <strong>Apply Root Motion</strong> field, in the <strong>Animator</strong> component, changes from a checked box to <strong>Handled by Script</strong>. The reason is that in order to override the animation clip's original movement, we have placed, inside Unity's <code class="literal">OnAnimatorMove()</code> function, a series of commands to move our character controller while jumping. The line of code: <code class="literal">controller.Move (deltaPosition);</code> basically replaces the jump's direction from the original animation with the <code class="literal">deltaPosition</code> 3D Vector, which is made of the character's velocity at the instant before the jump (<em>x</em> and <em>z</em>-axis) and the calculation between the <code class="literal">jumpHeight</code> variable and gravity<a class="indexterm" id="id792"/> force overtime (<em>y</em>-axis).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec75"/>Adding rigid props to animated characters</h1></div></div></div><p>In case you<a class="indexterm" id="id793"/> haven't included a sufficient number of props to your character when modeling and animating it, you might want to give her the <a class="indexterm" id="id794"/>chance of collecting new ones at runtime. In this recipe, we will learn how to instantiate a GameObject and assign it to a character, respecting the animation hierarchy.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec212"/>Getting ready</h2></div></div></div><p>For this recipe, we have prepared a Unity Package named <code class="literal">Props</code>, containing a basic scene that features an animated character and a prefab named <strong>badge</strong>. The package can be found inside the <code class="literal">1362_07_06</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec213"/>How to do it...</h2></div></div></div><p>To add a rigid prop at runtime to an animated character, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new project and import the <code class="literal">Props</code> Unity Package. Then, from the <strong>Project</strong> view, open the <strong>mecanimPlayground</strong> level.</li><li class="listitem">From the <strong>Project</strong> view, add the <strong>badge</strong> prop to the scene by dragging it onto the <strong>Hierarchy</strong> view. Then, make it a child of the <strong>mixamorig:Spine2</strong> transform (use the <strong>Hierarchy</strong> tree to navigate to <strong>MsLaser</strong> | <strong>mixamorig:Hips</strong> | <strong>mixamorig:Spine</strong> | <strong>mixamorig:Spine1</strong> | <strong>mixamorig:Spine2</strong>). Then, make the <strong>badge</strong> object visible above the character's chest by changing its <strong>Transform Position</strong> to <strong>X</strong>: <code class="literal">-0.08</code>, <strong>Y</strong>: <code class="literal">0,</code> <strong>Z</strong>: <code class="literal">0.15</code>; and <strong>Rotation</strong> to <strong>X</strong>: <code class="literal">0.29</code>, <strong>Y</strong>: <code class="literal">0.14</code>, <strong>Z</strong>:<code class="literal">-13.29</code>.<div><img alt="How to do it..." src="img/1362OT_07_39.jpg"/></div></li><li class="listitem">Make a note of the <strong>Position</strong> and <strong>Rotation</strong> values, and delete the <strong>badge</strong> object from the scene.</li><li class="listitem">Add a new <strong>Cube</strong> to the scene (drop-down <strong>Create</strong> | <strong>3D Object</strong> | <strong>Cube</strong>), rename it as <strong>PropTrigger</strong>, and change its Position to <strong>X</strong>: <code class="literal">0</code>, <strong>Y</strong>: <code class="literal">0.5</code>, <strong>Z</strong>: <code class="literal">2</code>.</li><li class="listitem">From the <strong>Inspector</strong> view's <strong>Box Collider</strong> component, check the <strong>Is Trigger</strong> option.</li><li class="listitem">From the<a class="indexterm" id="id795"/> <strong>Project</strong> view, create a new <strong>C# Script</strong> named <code class="literal">AddProp.cs</code>.</li><li class="listitem">Open the<a class="indexterm" id="id796"/> script and add the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class AddProp : MonoBehaviour {
  public GameObject prop;
  public Transform targetBone;
  public Vector3 positionOffset;
  public Vector3 rotationOffset;
  public bool  destroyTrigger = true;
  
  void  OnTriggerEnter ( Collider collision  ){
    
    if (targetBone.IsChildOf(collision.transform)){
      bool  checkProp = false;
      foreach(Transform child in targetBone){
        if (child.name == prop.name)
          checkProp = true;
      }
      
      if(!checkProp){
        GameObject newprop;
        newprop = Instantiate(prop, targetBone.position, targetBone.rotation) as GameObject;
        newprop.name = prop.name;
        newprop.transform.parent = targetBone;
        newprop.transform.localPosition += positionOffset;
        newprop.transform.localEulerAngles += rotationOffset;
        if(destroyTrigger)
          Destroy(gameObject);
      }
    }
  }
}</pre></div></li><li class="listitem">Save and close the script.</li><li class="listitem">Attach the <strong>AddProp.cs</strong> script to the <strong>PropTrigger</strong> GameObject.</li><li class="listitem">Select the <strong>PropTrigger</strong> textbox and check out its <strong>Add Prop</strong> component. First, populate<a class="indexterm" id="id797"/> the <strong>Prop</strong> field with the <strong>badge</strong> prefab. Then, populate <strong>Target Bone</strong> with the <strong>mixamorig:Spine2</strong> transform. Finally, assign the <strong>Position</strong> and <strong>Rotation</strong> values<a class="indexterm" id="id798"/> that we have previously made a note of to the <strong>Position Offset</strong> and <strong>Rotation Offset</strong> fields, respectively (<strong>Position Offset</strong>: <strong>X</strong>: <code class="literal">-0.08</code>, <strong>Y</strong>: <code class="literal">0,</code> <strong>Z</strong>: <code class="literal">0.15</code>; <strong>Rotation Offset</strong>: <strong>X</strong>: <code class="literal">0.29</code>, <strong>Y</strong>: <code class="literal">0.14</code>, <strong>Z</strong>:<code class="literal">-13.29</code>).<div><img alt="How to do it..." src="img/1362OT_07_40.jpg"/></div></li><li class="listitem">Play the scene. Using the 'WASD' keyboard control scheme, direct the character to the<a class="indexterm" id="id799"/> <strong>PropTrigger </strong>textbox. Colliding with it will add a badge to the character.<div><img alt="How to do it..." src="img/1362OT_07_41.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec214"/>How it works...</h2></div></div></div><p>Once it's been triggered by the character, the script attached to <strong>PropTrigger</strong> instantiates the assigned prefab, making it a child of the bones that they have been "placed into". The <strong>Position Offset</strong> and <strong>Rotation Offset</strong> can be used to fine-tune the exact position of the prop (relative to its<a class="indexterm" id="id800"/> parent transform). As the props become parented by the bones of the animated character, they will follow and respect its hierarchy and animation. Note that the script checks for the preexisting props of the same name<a class="indexterm" id="id801"/> before actually instantiating a new one.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec215"/>There's more...</h2></div></div></div><p>You can make a similar script to remove the props. In this case, the <code class="literal">OnTriggerEnter</code> function will contain only the following code:</p><div><pre class="programlisting">if (targetBone.IsChildOf(collision.transform)){
   foreach(Transform child in targetBone){
      if (child.name == prop.name)
        Destroy (child.gameObject);
    }
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec76"/>Using Animation Events to throw an object</h1></div></div></div><p>Now that <a class="indexterm" id="id802"/>your animated character is ready, you might want to coordinate some of her actions with her animation states. In this recipe, we will exemplify this by making the character throw an object whenever the appropriate animation clip reaches the right time. To do so, we will make<a class="indexterm" id="id803"/> use of <strong>Animation Events</strong>, which basically trigger a function from the animation clip's timeline. This feature, recently introduced to the <strong>Mecanim</strong> system, should<a class="indexterm" id="id804"/> feel familiar to those experienced with the<a class="indexterm" id="id805"/> <strong>Add Event</strong> feature of <a class="indexterm" id="id806"/>the classic <strong>Animation </strong>panel.</p><div><img alt="Using Animation Events to throw an object" src="img/1362OT_07_42.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec216"/>Getting ready</h2></div></div></div><p>For this recipe, we<a class="indexterm" id="id807"/> have prepared a Unity Package named <code class="literal">Throwing</code>, containing a basic scene that features an animated character and a prefab named <strong>EasterEgg</strong>. The package can be found inside the <code class="literal">1362_07_07</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec217"/>How to do it...</h2></div></div></div><p>To make an animated character throw an Easter egg (!), follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new project and import the <code class="literal">Throwing</code> Unity Package. Then, from the <strong>Project</strong> view, open the <strong>mecanimPlayground</strong> level.</li><li class="listitem">Play the level and press <em>F</em> on your keyboard. The character will move as if she is throwing something with her right hand.</li><li class="listitem"> From the <strong>Project</strong> view, create a new <strong>C# Script</strong> named <code class="literal">ThrowObject.cs.</code></li><li class="listitem">Open the script and add the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class ThrowObject : MonoBehaviour {
  public GameObject prop;
  private GameObject proj;
  public Vector3 posOffset;
  public Vector3 force;
  public Transform hand;
  public float compensationYAngle = 0f;
    
  public void Prepare () {

    proj = Instantiate(prop, hand.position, hand.rotation) as GameObject;
    if(proj.GetComponent&lt;Rigidbody&gt;())
      Destroy(proj.GetComponent&lt;Rigidbody&gt;());
    proj.GetComponent&lt;SphereCollider&gt;().enabled = false;
    proj.name = "projectile";
    proj.transform.parent = hand;
    proj.transform.localPosition = posOffset;
    proj.transform.localEulerAngles = Vector3.zero;
  }

  public void Throw () {

    Vector3 dir = transform.rotation.eulerAngles;
    dir.y += compensationYAngle;
    proj.transform.rotation = Quaternion.Euler(dir);
    proj.transform.parent = null;
    proj.GetComponent&lt;SphereCollider&gt;().enabled = true;
    Rigidbody rig = proj.AddComponent&lt;Rigidbody&gt;();
    Collider projCollider = proj.GetComponent&lt;Collider&gt; ();
    Collider col = GetComponent&lt;Collider&gt; ();
    Physics.IgnoreCollision(projCollider, col);
    rig.AddRelativeForce(force);
  }
}</pre></div></li><li class="listitem">Save and close the script.</li><li class="listitem">Attach the <a class="indexterm" id="id808"/><strong>ThrowObject.cs</strong> script to the character's GameObject named <strong>MsLaser</strong>.</li><li class="listitem">Select the <strong>MsLaser</strong> object. From the <strong>Inspector</strong> view, check out its <strong>Throw Object</strong> component. Then, populate the <strong>Prop</strong> field with a prefab named <strong>EasterEgg</strong>. Populate <strong>Hand</strong> with <strong>mixamorig:RightHand</strong>. Also, change <strong>Pos Offset</strong> to <strong>X</strong>: <code class="literal">0</code>; <strong>Y</strong>: <code class="literal">0.07</code>; <strong>Z</strong>: <code class="literal">0.04</code>. Finally, change <strong>Force</strong> to <strong>X</strong>: <code class="literal">0</code>; <strong>Y</strong>: <code class="literal">200</code>; <strong>Z</strong>: <code class="literal">500</code>.<div><img alt="How to do it..." src="img/1362OT_07_43.jpg"/></div></li><li class="listitem">From the <strong>Project</strong> view, select the <strong>Swat@toss_grenade</strong> file. Then, from the <strong>Inspector</strong><a class="indexterm" id="id809"/> view, access the <strong>Animation</strong> section and scroll down to the <strong>Events</strong> section.</li><li class="listitem">Expand the <strong>Events</strong> section. Drag the playhead to approximately <strong>0:17 (017.9%)</strong> of the animation timeline. Then, click on the button with the <em>marker +</em> icon to add an<a class="indexterm" id="id810"/> <strong>Animation Event</strong>. From the <strong>Edit Animation Event</strong> window, set <strong>Function</strong> as <code class="literal">Prepare</code>. Close the window.<div><img alt="How to do it..." src="img/1362OT_07_44.jpg"/></div></li><li class="listitem">Add a new animation event at approximately <strong>1:24 (057.1%)</strong> of the animation timeline. This time, from the <strong>Edit Animation Event</strong> window, set <strong>Function</strong> as <code class="literal">Throw</code>. Close the window.</li><li class="listitem">Click on the <strong>Apply</strong> button to save the changes.</li><li class="listitem">Play your scene. Your character will now be able to throw an Easter egg when you press the <em>F </em>key.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec218"/>How it works...</h2></div></div></div><p>Once the <strong>toss_grenade</strong> animation reaches the <a class="indexterm" id="id811"/>moments that we have set our <strong>Events</strong> to, the <code class="literal">Prepare() </code>and<code class="literal"> throw()</code> functions are called. The former instantiates a prefab, now named <strong>projectile</strong>, into the character's hand (<strong>Projectile Offset</strong> values are used to fine-tune its position), also <a class="indexterm" id="id812"/>making it respect the character's hierarchy. Also, it disables the prefab's collider and destroys its <code class="literal">Rigidbody</code> component, provided it has one. The latter function enables the projectile's collider, and adds a <code class="literal">Rigidbody</code> component to it, making it independent from the character's hand. Finally, it adds a relative force to the projectile's <code class="literal">Rigidbody</code> component, so it will behave as if thrown by the character. The <strong>Compensation YAngle</strong> can be used to adjust the direction of the grenade, if necessary.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec77"/>Applying Ragdoll physics to a character</h1></div></div></div><p>Action games <a class="indexterm" id="id813"/>often make use of <strong>Ragdoll physics </strong>to simulate the character's body reaction to being unconsciously under the effect of a hit or explosion. In this recipe, we will learn how to set up and activate Ragdoll physics to our <a class="indexterm" id="id814"/>character whenever she steps in a landmine object. We will also use the opportunity to reset the character's position and animations a number of seconds after that event has occurred.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec219"/>Getting ready</h2></div></div></div><p>For this recipe, we have prepared a Unity Package named <code class="literal">Ragdoll</code>, containing a basic scene that features an animated character and two prefabs, already placed into the scene, named <strong>Landmine</strong> and <strong>Spawnpoint</strong>. The package can be found inside the <code class="literal">1362_07_08</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec220"/>How to do it...</h2></div></div></div><p>To apply Ragdoll physics to your character, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new project and import the <code class="literal">Ragdoll</code> Unity Package. Then, from the <strong>Project</strong> view, open the <strong>mecanimPlayground</strong> level.</li><li class="listitem">You will see the animated MsLaser character and two discs: <strong>Landmine</strong> and <strong>Spawnpoint</strong>.</li><li class="listitem">First, let's set up our <a class="indexterm" id="id815"/><strong>Ragdoll</strong>. Access the <strong>GameObject</strong> | <strong>3D Object</strong> | <strong>Ragdoll...</strong> menu<a class="indexterm" id="id816"/> and the <strong>Ragdoll wizard</strong> will<a class="indexterm" id="id817"/> pop-up.</li><li class="listitem">Assign the<a class="indexterm" id="id818"/> transforms as follows:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Pelvis</strong>: mixamorig:Hips</li><li class="listitem" style="list-style-type: disc"><strong>Left Hips</strong>: mixamorig:LeftUpLeg</li><li class="listitem" style="list-style-type: disc"><strong>Left Knee</strong>: mixamorig:LeftLeg</li><li class="listitem" style="list-style-type: disc"><strong>Left Foot</strong>: mixamorig:LeftFoot</li><li class="listitem" style="list-style-type: disc"><strong>Right Hips</strong>: mixamorig:RightUpLeg</li><li class="listitem" style="list-style-type: disc"><strong>Right Knee</strong>: mixamorig:RightLeg</li><li class="listitem" style="list-style-type: disc"><strong>Right Foot</strong>: mixamorig:RightFoot</li><li class="listitem" style="list-style-type: disc"><strong>Left Arm</strong>: mixamorig:LeftArm</li><li class="listitem" style="list-style-type: disc"><strong>Left Elbow</strong>: mixamorig:LeftForeArm</li><li class="listitem" style="list-style-type: disc"><strong>Right Arm</strong>: mixamorig:RightArm</li><li class="listitem" style="list-style-type: disc"><strong>Right Elbow</strong>: mixamorig:RightForeArm</li><li class="listitem" style="list-style-type: disc"><strong>Middle Spine</strong>: mixamorig:Spine1</li><li class="listitem" style="list-style-type: disc"><strong>Head</strong>: mixamorig:Head</li><li class="listitem" style="list-style-type: disc"><strong>Total Mass</strong>: 20</li><li class="listitem" style="list-style-type: disc"><strong>Strength</strong>: 50</li></ul></div><div><img alt="How to do it..." src="img/1362OT_07_45.jpg"/></div></li><li class="listitem">From the <strong>Project</strong> <a class="indexterm" id="id819"/>view, create a new <strong>C# Script</strong> named <code class="literal">RagdollCharacter.cs</code>.</li><li class="listitem">Open the <a class="indexterm" id="id820"/>script and add the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class RagdollCharacter : MonoBehaviour {

  void Start () {
      DeactivateRagdoll();
    }

    public void ActivateRagdoll(){
    gameObject.GetComponent&lt;CharacterController&gt; ().enabled = false;
    gameObject.GetComponent&lt;BasicController&gt; ().enabled = false;
    gameObject.GetComponent&lt;Animator&gt; ().enabled = false;
    foreach (Rigidbody bone in GetComponentsInChildren&lt;Rigidbody&gt;()) {
        bone.isKinematic = false;
        bone.detectCollisions = true;
    }
    foreach (Collider col in GetComponentsInChildren&lt;Collider&gt;()) {
        col.enabled = true;
    }
    StartCoroutine (Restore ());

    }
  public void DeactivateRagdoll(){

    gameObject.GetComponent&lt;BasicController&gt;().enabled = true;
    gameObject.GetComponent&lt;Animator&gt;().enabled = true;
    transform.position = GameObject.Find("Spawnpoint").transform.position;
    transform.rotation = GameObject.Find("Spawnpoint").transform.rotation;
    foreach(Rigidbody bone in GetComponentsInChildren&lt;Rigidbody&gt;()){
        bone.isKinematic = true;
          bone.detectCollisions = false;
      }
    foreach (CharacterJoint joint in GetComponentsInChildren&lt;CharacterJoint&gt;()) {
      joint.enableProjection = true;
    }
    foreach(Collider col in GetComponentsInChildren&lt;Collider&gt;()){
      col.enabled = false;
    }
  gameObject.GetComponent&lt;CharacterController&gt;().enabled= true;

    }

  IEnumerator Restore(){
    yield return new WaitForSeconds(5);
    DeactivateRagdoll();
  }
}</pre></div></li><li class="listitem">Save and close the script.</li><li class="listitem">Attach the <strong>RagdollCharacter.cs</strong> script to the <strong>MsLaser</strong> GameObject. Then, select the <strong>MsLaser</strong> character and, from the top of the <strong>Inspector</strong> view, change its tag to <strong>Player</strong>.</li><li class="listitem">From the <strong>Project</strong> view, create<a class="indexterm" id="id821"/> a new <strong>C# Script</strong> named <code class="literal">Landmine.cs</code>.</li><li class="listitem">Open the script <a class="indexterm" id="id822"/>and add the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class Landmine : MonoBehaviour {
  public float range = 2f;
  public float force = 2f;
  public float up = 4f;
  private bool active = true;

  void  OnTriggerEnter ( Collider collision  ){
    if(collision.gameObject.tag == "Player" &amp;&amp; active){
      active = false;
      StartCoroutine(Reactivate());
      collision.gameObject.GetComponent&lt;RagdollCharacter&gt;().ActivateRagdoll();
      Vector3 explosionPos = transform.position;
            Collider[] colliders = Physics.OverlapSphere(explosionPos, range);
          foreach (Collider hit in colliders) {
        if (hit.GetComponent&lt;Rigidbody&gt;())
                  hit.GetComponent&lt;Rigidbody&gt;().AddExplosionForce(force, explosionPos, range, up);
             }
        }
    }
  IEnumerator Reactivate(){
    yield return new WaitForSeconds(2);
    active = true;
  }
}</pre></div></li><li class="listitem">Save and close the script.</li><li class="listitem">Attach the script to the <strong>Landmine</strong> GameObject.</li><li class="listitem">Play the scene. Using the <em>WASD</em> keyboard control scheme, direct the character to the <strong>Landmine</strong> GameObject. Colliding with it will activate the character's Ragdoll physics and apply an explosion force to it. As a result, the character will be thrown away to a considerable distance and will no longer be in the control<a class="indexterm" id="id823"/> of its body movements, akin to a ragdoll.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec221"/>How it works...</h2></div></div></div><p>Unity's <strong>Ragdoll Wizard</strong> assigns, to <a class="indexterm" id="id824"/>selected transforms, the components <code class="literal">Collider</code>, <code class="literal">Rigidbody</code>, and <code class="literal">Character Joint</code>. In conjunction, those components make Ragdoll physics possible. However, those components must be disabled whenever we want our character to be <a class="indexterm" id="id825"/>animated and controlled by the player. In our case, we switch those components on and off using the <code class="literal">RagdollCharacter</code> script and its two functions: <code class="literal">ActivateRagdoll()</code> and <code class="literal">DeactivateRagdoll()</code>, the latter includes instructions to re-spawn our character in the appropriate place.</p><p>For the testing purposes, we have also created the <code class="literal">Landmine</code> script, which calls <code class="literal">RagdollCharacter</code> script's function named <code class="literal">ActivateRagdoll()</code>. It also applies an explosion force to our ragdoll character, throwing it outside the explosion site.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec222"/>There's more...</h2></div></div></div><p>Instead of resetting the character's transform settings, you could have destroyed its GameObject and instantiated a new one<a class="indexterm" id="id826"/> over the respawn point using <strong>Tags</strong>. For more information<a class="indexterm" id="id827"/> on this subject, check Unity's documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html">http://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec78"/>Rotating the character's torso to aim a weapon</h1></div></div></div><p>When playing a<a class="indexterm" id="id828"/> third-person character, you might want her to aim her weapon at some target that is not directly in front of her, without making her change her direction. In these <a class="indexterm" id="id829"/>cases, you will need to apply what is called a <em>procedural animation</em>, which does not rely on premade animation clips, but rather on the processing of other data, such as player input, to animate the character. In this recipe, we will use this technique to rotate the character's spine by moving the mouse, allowing for adjustments in the character's aim. We will also use this opportunity to cast a ray from the character's weapon and display a crosshair over the nearest object on target. Please note that this approach will work with the cameras standing behind the third-person controlled characters.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec223"/>Getting ready</h2></div></div></div><p>For this recipe, we have prepared a Unity Package named <code class="literal">AimPointer</code>, containing a basic scene that features a character armed with a laser pointer. The package, which also includes the <code class="literal">crossAim</code> sprite that is to be used as a crosshair for aiming, can be found inside the <code class="literal">1362_07_09</code> folder.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec224"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a new<a class="indexterm" id="id830"/> project and import the <code class="literal">AimPointer</code> Unity Package. Then, from the <strong>Project</strong> view, open the <strong>mecanimPlayground</strong> level. You will see an animated character named <strong>MsLaser</strong> holding the <strong>pointerPrefab</strong> object.</li><li class="listitem">From the <strong>Project</strong> view, create a new <strong>C# Script</strong> named <code class="literal">MouseAim.cs</code>.</li><li class="listitem">Open the script and<a class="indexterm" id="id831"/> add the following code:<div><pre class="programlisting">using UnityEngine;
using System.Collections;

public class MouseAim : MonoBehaviour {
  
  public Transform spine;
  private float xAxis = 0f;
  private float yAxis = 0f;
  public Vector2 xLimit = new Vector2(-30f,30f);
  public Vector2 yLimit= new Vector2(-30f,30f);
  public Transform weapon;
  public GameObject crosshair;
  private Vector2 aimLoc;

  public void LateUpdate(){

    yAxis += Input.GetAxis ("Mouse X");
    yAxis = Mathf.Clamp (yAxis, yLimit.x, yLimit.y);
    xAxis -= Input.GetAxis ("Mouse Y");
    xAxis = Mathf.Clamp (xAxis, xLimit.x, xLimit.y);
    Vector3 corr = new Vector3(xAxis,yAxis, spine.localEulerAngles.z);
    spine.localEulerAngles = corr;
    RaycastHit hit;
    Vector3 fwd = weapon.TransformDirection(Vector3.forward);
    if (Physics.Raycast (weapon.position, fwd, out hit)) {
      print (hit.transform.gameObject.name);
      aimLoc =  Camera.main.WorldToScreenPoint(hit.point);
      crosshair.SetActive(true);
      crosshair.transform.position = aimLoc;
    } else {
     crosshair.SetActive(false);
    }
    Debug.DrawRay (weapon.position, fwd, Color.red);
  }
}</pre></div></li><li class="listitem">Save and close the script.</li><li class="listitem">From the <strong>Hierarchy</strong> view, create a new <strong>UI</strong> | <strong>Image</strong> GameObject. Then, from the <strong>Inspector</strong> <a class="indexterm" id="id832"/>view, change its name to <code class="literal">crosshair</code>. Also, in <strong>Rect</strong><a class="indexterm" id="id833"/><strong> Transform</strong>, set its <strong>Width</strong> and <strong>Height</strong> to <code class="literal">16</code> and populate <strong>Source Image</strong> field with the <strong>crossAim</strong> sprite.<div><img alt="How to do it..." src="img/1362OT_07_46.jpg"/></div></li><li class="listitem">Attach<a class="indexterm" id="id834"/> the <strong>MouseAim.cs</strong> <a class="indexterm" id="id835"/>script to the <strong>MsLaser</strong> GameObject.</li><li class="listitem">Select the <strong>MsLaser</strong> GameObject and from the <strong>Inspector</strong> view's <strong>Mouse Aim</strong> component, populate the <strong>Spine</strong> field with <strong>mixamorig:Spine</strong>; the <strong>Weapon</strong> field with <strong>pointerPrefab</strong>; and the <strong>Crosshair</strong> field with the <strong>crosshair</strong> UI GameObject.<div><img alt="How to do it..." src="img/1362OT_07_47.jpg"/></div></li><li class="listitem">Play the scene. You<a class="indexterm" id="id836"/> will now be able to rotate the character's torso by moving the mouse. Even<a class="indexterm" id="id837"/> better, the crosshair GUI texture will be displayed at the top of the object that is being aimed at by the pointer.<div><img alt="How to do it..." src="img/1362OT_07_48.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec225"/>How it works...</h2></div></div></div><p>You might have noticed that all the code for rotating the character's spine is inside the <code class="literal">LateUpdate</code> function, as opposed to the more common <code class="literal">Update</code> function. The reason for this is to make sure that all the transform manipulation will be executed after the original animation clip is played, overriding it.</p><p>Regarding the spine rotation, our script adds the horizontal and vertical speed of the mouse to the <code class="literal">xAxis</code> and <code class="literal">yAxis</code> float variables. These variables are then constrained within the specified limits, avoiding distortions to the character's model. Finally, the <code class="literal">spine</code> object transform rotation for <em>x</em> and <em>y</em> axes are set to <code class="literal">xAxis</code> and <code class="literal">yAxis</code> respectively. The <em>z</em>-axis<a class="indexterm" id="id838"/> is preserved from the original animation clip.</p><p>Additionally, our<a class="indexterm" id="id839"/> script uses a <code class="literal">Raycast</code> command to detect if there is any object's collider within the weapon's aim, in which case a crosshair will be drawn on the screen.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec226"/>There's more...</h2></div></div></div><p>Since this recipe's script was tailored for cameras standing behind the third-person controlled characters, we have included a more generic solution to the problem—in fact, a similar approach to the one presented in <em>Unity 4.x Cookbook</em>, <em>Packt Publishing</em>. An alternate script named <code class="literal">MouseAimLokkAt</code>, which can be found inside the <code class="literal">1362_07_09</code> folder, starts by converting our bi-dimensional mouse cursor screen's coordinates to the three-dimensional world space coordinates (stored in a <code class="literal">point</code> variable). Then, it rotates the character's torso towards the <em>point</em> location, using the <code class="literal">LookAt()</code> command to do so. Additionally, it makes sure that the spine does not extrapolate <code class="literal">minY</code> and <code class="literal">maxY</code> angles, otherwise causing distortions to the character model. Also, we have included a <code class="literal">Compensation YAngle</code> variable that makes it possible for us to fine-tune the character's alignment with the mouse cursor. Another addition is the option to freeze the X-axis rotation, in case you just want the character to rotate the torso laterally, but not look up or down. Again, this script uses a <code class="literal">Raycast</code> command to detect objects in front of the weapon's aim, drawing a crosshair on the screen when they are present.</p></div></div></body></html>