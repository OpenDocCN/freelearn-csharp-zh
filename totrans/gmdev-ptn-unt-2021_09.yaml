- en: Implement a Replay System with the Command Pattern
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令模式实现回放系统
- en: In this chapter, we will use a classic design pattern named Command to implement
    a replay system for our racing game. Its mechanism will record the player's controller
    inputs and the corresponding timestamp. This approach will permit us to play back
    the recorded inputs in the proper order and with the correct timing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个经典的设计模式——命令，来实现我们赛车游戏的回放系统。其机制将记录玩家的控制器输入和相应的时间戳。这种方法将允许我们以正确的顺序和正确的时间播放记录的输入。
- en: Replay features are often a must-have in racing games. With the Command pattern,
    we are going to implement this system in a scalable and modular manner. This pattern
    proposes a mechanism that permits encapsulating information needed to perform
    an "action" or trigger a state change. It also decouples the requester of an "action"
    from the object that will perform it. This encapsulation and decoupling permit
    us to queue action requests so we can execute them at a later time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在赛车游戏中，回放功能通常是必需的。使用命令模式，我们将以可扩展和模块化的方式实现这个系统。这个模式提出了一种机制，允许封装执行“动作”或触发状态改变所需的信息。它还解耦了请求“动作”的对象与执行它的对象。这种封装和解耦使我们能够排队动作请求，以便我们可以在稍后执行它们。
- en: All of this might sound very abstract, but once we implement the system's core
    components, it will be made clear.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可能听起来非常抽象，但一旦我们实现了系统的核心组件，一切都将变得清晰。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the Command pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解命令模式
- en: Designing a replay system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计回放系统
- en: Implementing a replay system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现回放系统
- en: Reviewing alternative solutions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查替代解决方案
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The following chapter is hands-on, so you will need to have a basic understanding
    of Unity and C#.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是实践性的，因此你需要对Unity和C#有基本的了解。
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter07](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter07).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter07](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter07)。
- en: Check out the following video to see the code in action: [https://bit.ly/3wAWYpb](https://bit.ly/3wAWYpb)[.](https://bit.ly/3wAWYpb)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行效果：[https://bit.ly/3wAWYpb](https://bit.ly/3wAWYpb)[.](https://bit.ly/3wAWYpb)
- en: Understanding the Command pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解命令模式
- en: Imagine a platform game in which you can jump over obstacles when you press
    the space bar. In this scenario, every time you press that input key, you are
    asking the character on the screen to change states and perform a jump action.
    In code, we could implement a simple `InputHandler`, which would listen for a
    space bar input from the player, and when the player hits it, we would call `CharacterController`
    to trigger the jump action.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个平台游戏，当你按下空格键时，你可以跳过障碍物。在这种情况下，每次你按下这个输入键，你都是在要求屏幕上的角色改变状态并执行跳跃动作。在代码中，我们可以实现一个简单的`InputHandler`，它会监听玩家从空格键的输入，当玩家按下它时，我们会调用`CharacterController`来触发跳跃动作。
- en: 'The following very simplified pseudo-code sums up what we have in mind:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下非常简化的伪代码总结了我们的想法：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can see, this approach can get the job done, but if we wanted to record,
    undo, or replay an input from the player at a later time, it could become complicated.
    However, the Command pattern permits us to decouple the object that invokes the
    operation from the one that knows how to execute it. In other words, our `InputHandler`
    doesn't need to know what exact action needs to be taken when the player presses
    the space bar. It just needs to make sure that the correct *command* is executed
    and let the Command pattern mechanism do its magic behind the scenes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这种方法可以完成任务，但如果我们要在以后的时间记录、撤销或回放玩家的输入，可能会变得复杂。然而，命令模式允许我们将调用操作的对象与知道如何执行它的对象解耦。换句话说，我们的`InputHandler`不需要知道当玩家按下空格键时需要采取什么具体动作。它只需要确保执行正确的*命令*，并让命令模式机制在幕后施展其魔法。
- en: 'The following pseudo-code shows the difference in the way we implement `InputHandler`
    when we are using the Command pattern:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码显示了当我们使用命令模式时，我们实现`InputHandler`的方式的差异：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, we are not just invoking `CharacterController` directly when
    the player presses the space bar. We are actually encapsulating all the information we
    need to perform the jump action into an object that we could put in a queue and
    re-invoke at a later time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当玩家按下空格键时，我们并不是直接调用 `CharacterController`。我们实际上是将执行跳跃动作所需的所有信息封装到一个对象中，我们可以将其放入队列并在稍后重新调用。
- en: 'Let''s review the following diagram, which illustrates an implementation of
    the Command pattern:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾以下图表，它展示了命令模式的实现：
- en: '![](img/1055bba6-6fa4-4b50-92da-48f9440eb790.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1055bba6-6fa4-4b50-92da-48f9440eb790.png)'
- en: Figure 7.1 – UML diagram of the Command pattern
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 命令模式的 UML 图
- en: 'Trying to learn about the Command pattern by looking at a diagram is not the
    right approach, but it does help us isolate the fundamental classes that are participating
    in this pattern:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看图表来学习命令模式不是正确的方法，但它确实帮助我们隔离了参与此模式的根本类：
- en: '`Invoker` is an object that knows how to execute a command and can also do
    the bookkeeping of executed commands.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoker` 是一个知道如何执行命令并且可以记录已执行命令的对象。'
- en: '`Receiver` is a type of object that can receive commands and execute them.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Receiver` 是一种可以接收命令并执行它们的对象类型。'
- en: '`CommandBase` is an abstract class that an individual `ConcreteCommand` class
    must inherit, and it exposes an `Execute()` method that `Invoker` can call to
    execute a specific command.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommandBase` 是一个抽象类，一个具体的 `ConcreteCommand` 类必须继承它，并且它暴露了一个 `Execute()` 方法，`Invoker`
    可以调用它来执行特定的命令。'
- en: Each participant in the pattern has a distinct responsibility and a role to
    play. A solid implementation of the Command pattern should allow us to encapsulate
    action requests as an object that can be queued and executed immediately or at
    a later time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模式中的每个参与者都有独特的责任和角色。一个良好的命令模式实现应该允许我们将动作请求封装为一个对象，该对象可以被排队并在稍后立即或执行。
- en: The Command pattern is a part of the Behavioral pattern family; its close cousins
    are Memento, Observer, and Visitor. These types of patterns are often concerned
    with the assignment of responsibilities and how objects communicate with one another.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式是行为模式家族的一部分；它的近亲是备忘录、观察者和访问者。这些类型的模式通常关注责任的分配以及对象之间如何相互通信。
- en: Benefits and drawbacks of the Command pattern
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令模式的优缺点
- en: 'These are some of the benefits of the Command pattern:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是命令模式的一些优点：
- en: '**Decoupling**: The pattern permits the decoupling of the object that invokes
    the operation from the one that knows how to execute it. This layer of separation
    allows the addition of an intermediary that will be able to bookkeep and sequence
    operations.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦**：该模式允许将调用操作的对象与知道如何执行它的对象解耦。这种分离层允许添加一个中间件，它将能够记录和排队操作。'
- en: '**Sequencing**: The Command pattern facilitates the process of queuing user
    inputs, which permits the implementation of undo/redo features, macros, and command
    queues.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序**：命令模式促进了排队用户输入的过程，这允许实现撤销/重做功能、宏和命令队列。'
- en: 'This is a potential drawback of the Command pattern:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令模式的一个潜在缺点：
- en: '**Complexity**: It takes numerous classes to implement this pattern as each
    command is a class in itself. And it takes a good understanding of the pattern
    to maintain code built with it. In most cases, this is not an issue, but if you
    are using the Command pattern without a specific goal in mind, it can become an
    unnecessary layer of complexity and verbosity in your code base.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：由于每个命令本身就是一个类，因此实现此模式需要许多类。并且需要很好地理解该模式才能维护使用它构建的代码。在大多数情况下，这不是问题，但如果你没有特定的目标而使用命令模式，它可能会成为代码库中不必要的复杂性和冗余层。'
- en: Benefits and drawbacks are usually contextual; the ones presented in this book
    are general, and not absolutes. Therefore, it's essential when choosing a pattern
    to analyze its benefits and drawbacks in the context of your own project, and
    to not consider or reject one based on general statements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 优缺点通常是情境性的；本书中提出的是一般的，而不是绝对的。因此，在选择模式时，分析其在自己的项目中的优缺点是至关重要的，不要基于一般陈述考虑或拒绝某个模式。
- en: When to use the Command pattern
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用命令模式
- en: 'Here''s a shortlist of possible uses for the Command pattern:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个命令模式可能的用途简短列表：
- en: '**Undo**: Implementing an undo/redo system that you find in most text and image
    editors.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**撤销**：实现大多数文本和图像编辑器中找到的撤销/重做系统。'
- en: '**Macro**: A macro recording system with which players can record a sequence
    of attack or defensive combos. Then, assign them on an input key to execute them
    automatically.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宏**：一个宏录制系统，玩家可以使用它来录制一系列攻击或防御组合。然后，将它们分配到输入键上以自动执行。'
- en: '**Automation:** Automate processes or behaviors by recording a set of commands
    that a bot will automatically and sequentially execute.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：通过记录一组命令，使机器人能够自动和顺序地执行这些命令，从而自动化流程或行为。'
- en: In conclusion, it's a good pattern for features related to storing, timing,
    and sequencing user inputs. And if you get very creative with it, you could create
    some compelling game systems and mechanics.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这是一个与存储、定时和用户输入排序相关的功能的好模式。如果你能非常富有创意地使用它，你甚至可以创建一些引人入胜的游戏系统和机制。
- en: Design patterns are fun to use if you don't worry too much about staying true
    to the original academic descriptions. If you don't lose the original intent of
    the pattern while experimenting with it, you should retain its core benefits.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不过分担心保持与原始学术描述的一致性，设计模式很有趣。如果你在实验中不失去模式的原意，你应该保留其核心优势。
- en: Designing a replay system
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计重放系统
- en: Before describing the replay system design that we will be implementing in this
    chapter, we have to declare some specifications about our game that can influence
    the way in which we will implement it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述我们将在本章中实现的重放系统设计之前，我们必须声明一些可能影响我们实现方式的游戏规格。
- en: 'Specifications to keep in mind are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的规格如下：
- en: '**Deterministic**: Everything in our game is deterministic, which means we
    don''t have any entities with random behaviors, and that makes our replay system
    simpler to implement because we don''t have to worry about recording positions
    or states of entities that move in our scene like enemy drones. We know they will
    move and behave the same way during the replay sequence.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确定性**：我们游戏中的所有内容都是确定性的，这意味着我们没有具有随机行为的实体，这使得我们的重放系统更容易实现，因为我们不必担心记录场景中移动的实体（如敌机）的位置或状态。我们知道它们在重放序列中将以相同的方式移动和表现。'
- en: '**Physics**: We are minimizing the use of the physics features of the Unity
    engine as our entities'' movements are not determined by any physical properties
    or interactions. Therefore, we do not have to worry about unexpected behaviors
    when objects collide.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理**：我们尽量减少使用Unity引擎的物理特性，因为我们的实体运动不由任何物理属性或交互决定。因此，我们不必担心物体碰撞时出现意外行为。'
- en: '**Digital**: All our inputs are digital, so we do not bother to capture or
    handle granular analog input data from a joystick or trigger button.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字**：我们所有的输入都是数字的，所以我们不会费心去捕捉或处理来自摇杆或触发按钮的细粒度模拟输入数据。'
- en: '**Precision**: We tolerate a lack of precision in the timing of when we replay
    inputs. Therefore, we do not expect the inputs to replay precisely within the
    same timeframe as they were recorded. *This tolerance level is subject to change
    depending on several factors related to the desired level of precision of the
    replay feature.*'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精度**：我们对重放输入的时间精度缺乏容忍。因此，我们不会期望输入在记录时精确地重现在同一时间范围内。*这种容忍水平将根据与所需重放功能精度相关的几个因素而变化。*'
- en: Considering all these specifications, the replay system we are going to implement
    will only record the player's inputs but not the bike's current position. Because
    there are no in-between locations that the bike might be at, depending on the
    player's input, it will be on one rail or the other. Also, another essential detail
    to note is the fact that the bike does not move forward. It is the track that
    moves toward the player's position to give the illusion of movement and speed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些规格，我们将实现的重放系统将只记录玩家的输入，而不是自行车的当前位置。因为没有中间位置，自行车可能处于，这取决于玩家的输入，它将位于一条轨道或另一条轨道上。另外，还有一个需要注意的重要细节是，自行车不会向前移动。是轨道向玩家的位置移动，以产生移动和速度的错觉。
- en: 'In theory, if we record the player''s controller inputs from the start and
    end of a race, then we could simulate a replay of the player''s gameplay by replaying
    the recorded inputs at the beginning of a new race. We have a diagram that illustrates
    the mechanism behind the replay system:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，如果我们从比赛的开始和结束记录玩家的控制器输入，那么我们可以在新比赛的开始时重放记录的输入，从而模拟玩家的游戏过程。我们有一个图解说明了重放系统背后的机制：
- en: '![](img/3a1df14e-86fb-485c-b8de-c79880fb233f.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a1df14e-86fb-485c-b8de-c79880fb233f.png)'
- en: Figure 7.2 – Diagram of the replay system
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 重放系统的示意图
- en: As we can see in the diagram, `InputRecorder` records and serializes the inputs
    so that `ReplaySystem` can replay them later on. During a replay sequence, `ReplaySystem`
    acts similarly to a bot as it takes control of the bike and automatically maneuvers
    it by replaying the player's inputs. It is a simple form of automation that gives
    the illusion that we are watching a replay video.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，`InputRecorder` 记录并序列化输入，以便 `ReplaySystem` 可以稍后回放它们。在回放序列中，`ReplaySystem`
    的行为类似于机器人，因为它控制自行车并通过回放玩家的输入来自动操纵它。这是一种简单的自动化形式，给人一种我们在观看回放视频的错觉。
- en: In the next section, we will implement a simplified version of the system we
    just reviewed, and we will use the Command pattern as its foundation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现我们刚刚审查的系统的简化版本，并使用命令模式作为其基础。
- en: Implementing a replay system
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现回放系统
- en: This section includes pseudo-code for the sake of simplicity and readability.
    If you wish to review a complete implementation in the context of an actual game
    project, open the `FPP` folder in the GitHub project. The link can be found under
    the *Technical requirements* section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，本节包含伪代码。如果您希望在真实游戏项目的上下文中查看完整的实现，请打开 GitHub 项目中的 `FPP` 文件夹。链接可以在 *技术要求*
    部分找到。
- en: In this section, we are going to build up a simple input replay system prototype
    using the Command pattern as the foundation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用命令模式作为基础构建一个简单的输入回放系统原型。
- en: Implementing the replay system
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现回放系统
- en: 'The implementation will be done in two parts. In the first part, we will code
    the core components of the Command pattern and then we will integrate the elements
    that are necessary to test the replay system:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实现将分为两部分。在第一部分，我们将编写命令模式的核心理念，然后我们将集成测试回放系统所必需的元素：
- en: 'To start, we are implementing a base abstract class named `Command`, which
    has a singular method named `Execute()`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们正在实现一个名为 `Command` 的基抽象类，它有一个名为 `Execute()` 的单一方法：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we are going to write three concrete command classes that will derive from
    the `Command` base class, and then we will implement the `Execute()` method. Each
    of them encapsulates an action to execute.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将编写三个具体的命令类，它们将派生自 `Command` 基类，然后我们将实现 `Execute()` 方法。每个类封装了一个要执行的操作。
- en: 'The first one toggles the turbocharger on `BikeController`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个操作是在 `BikeController` 上打开涡轮增压：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following two commands are the `TurnLeft` and `TurnRight` commands. Each
    represents a different action and is mapped to a specific input key, as we are
    going to see when we implement `InputHandler`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下两个命令是 `TurnLeft` 和 `TurnRight` 命令。每个命令代表不同的动作，并映射到特定的输入键，正如我们将在实现 `InputHandler`
    时看到的那样：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following command represents the right turn action and, as its name implies,
    this turns the bike to the right:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令表示右转动作，正如其名称所暗示的，这将自行车转向右边：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have completed the encapsulation of each command into individual
    classes, it is time to code the critical ingredient that will make our replay
    system work – `Invoker`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将每个命令封装到单独的类中，是时候编写使我们的回放系统工作的关键成分了——`Invoker`。
- en: '`Invoker` is an attentive bookkeeper; it keeps track of the commands that have
    been executed in a ledger. We represent this ledger in code in the form of `SortedList`,
    a native C# sorted collection with a key/value structure. This list will keep
    track of when a specific command was executed.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoker` 是一个细心的簿记员；它跟踪已执行的命令，并在账簿中记录。我们在代码中以 `SortedList` 的形式表示这个账簿，这是一个具有键/值结构的本地
    C# 排序列表。这个列表将跟踪特定命令何时被执行。'
- en: 'Because this class is very long, we will review it in two segments. The following
    is the first part:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为这个类非常长，我们将分两部分来审查。以下是一部分：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this part of the `Invoker` class, we add a command to the `_recordedCommands`
    sorted list every time `Invoker` executes a new one. However, we only do this
    when we start recording because we want to record the player inputs at specific
    moments, such as at the start of the race.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Invoker` 类的这一部分，每次 `Invoker` 执行一个新的命令时，我们都会将其添加到 `_recordedCommands` 排序列表中。然而，我们只在开始录制时这样做，因为我们希望在特定的时刻记录玩家输入，例如在比赛开始时。
- en: 'For the next section of the `Invoker` class, we are going to implement the
    replay behavior:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `Invoker` 类的下一部分，我们将实现回放行为：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you may have already noticed, we are using `FixedUpdate()` to record and
    replay commands. This might seem strange as we usually use `Update()` to listen
    for player inputs. However, `FixedUpdate()` has the advantage of running in fixed
    time steps and is helpful for time-dependent but frame rate-independent tasks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，我们正在使用`FixedUpdate()`来记录和回放命令。这可能会显得有些奇怪，因为我们通常使用`Update()`来监听玩家输入。然而，`FixedUpdate()`具有在固定时间步长中运行的优点，这对于时间依赖但帧率无关的任务非常有帮助。
- en: Therefore, we know that the default engine time step is 0.02 seconds, and our
    timestamps will be in similar increments as we use `Time.fixedDeltaTime` to record
    the time of executed commands.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道默认的引擎时间步长是0.02秒，并且我们的时间戳将以类似的增量增加，因为我们使用`Time.fixedDeltaTime`来记录执行命令的时间。
- en: However, this also means that we lose precision during the recording phase,
    as our timestamp is bound to Unity's time-step settings. This loss of precision
    is tolerable in the context of this example. However, it could become an issue
    if there are significant inconsistencies between the game play and replay sequences.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也意味着我们在记录阶段会失去精度，因为我们的时间戳受限于Unity的时间步长设置。在这个例子中，这种精度损失是可以容忍的。然而，如果游戏玩法和回放序列之间存在重大不一致，这可能会成为一个问题。
- en: In that case, we might need to consider a solution that includes `Update()`,
    `Time.deltaTime`, and a value that will permit us to set the degree of precision
    when comparing the recording and replay time. However, this is beyond the scope
    of this chapter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能需要考虑一个包括`Update()`、`Time.deltaTime`以及允许我们设置比较记录和回放时间精度程度的值的解决方案。然而，这超出了本章的范围。
- en: We should take note that we are giving `Invoker` the responsibility of bookkeeping
    but also replaying. It can be argued that we have broken the single responsibility
    principle by giving `Invoker` too many responsibilities. In this context, this
    is not an issue; it is just a code example for educational purposes. Still, it
    would be wise to encapsulate the responsibilities of recording, saving, and replaying
    commands in a separate class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，我们正在赋予`Invoker`记账和回放的责任。有人可能会认为，通过给`Invoker`赋予过多的责任，我们已经违反了单一职责原则。在这个上下文中，这不是一个问题；这只是一个用于教育目的的代码示例。尽管如此，将记录、保存和回放命令的责任封装在单独的类中仍然是一个明智的选择。
- en: Testing the replay system
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试回放系统
- en: 'Now that we have the core ingredients of the Command pattern and our replay
    system in place, it is time to test whether it works:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了命令模式和回放系统的核心成分，是时候测试它是否正常工作了：
- en: 'The first class we will implement is `InputHandler`. Its primary responsibility
    is to listen for the player''s inputs and invoke the appropriate commands. However,
    because of its length, we will review it in two parts:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要实现的第一类是`InputHandler`。其主要职责是监听玩家的输入并调用适当的命令。然而，由于其长度，我们将分两部分来审查它：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this section of the class, we are initializing our commands and mapping them
    to specific inputs. Notice that we are passing an instance of `BikeController`
    in the command's constructor. `InputHandler` is only aware that `BikeController`
    exists, but does not need to know how it functions. It is the responsibility of
    the individual command classes to call the proper public methods of the bike's
    controller depending on the desired action. In the `Update()` loop, we listen
    for specific key inputs and call on `Invoker` to execute a command associated
    with a particular input.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类的这个部分，我们初始化我们的命令并将它们映射到特定的输入。请注意，我们在命令的构造函数中传递了一个`BikeController`的实例。`InputHandler`只知道`BikeController`的存在，但不需要了解其功能。根据所需操作，调用自行车控制器的适当公共方法是个别命令类的责任。在`Update()`循环中，我们监听特定的按键输入，并调用`Invoker`执行与特定输入关联的命令。
- en: This segment of code is what makes it possible to record the inputs of the player.
    We do not call `BikeController` directly, and we do not execute the commands.
    Instead, we allow `Invoker` to act like an intermediary and do all the work. This
    approach permits it to keep records of the player inputs in the background for
    later use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使得记录玩家输入成为可能。我们并没有直接调用`BikeController`，也没有执行命令。相反，我们允许`Invoker`充当一个中介，并完成所有工作。这种方法允许它在后台记录玩家输入，以备后用。
- en: 'For the final part of the `InputHandler` class, we are adding some GUI debug
    buttons that will help us test the replay system. This segment of code is for
    debugging and testing purposes only:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `InputHandler` 类的最后一部分，我们添加了一些 GUI 调试按钮，这将帮助我们测试回放系统。此段代码仅用于调试和测试目的：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For our final class, we will implement a skeleton version of the `BikeController`
    class for testing purposes. It acts like a receiver in the context of the Command
    pattern:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的最终类，我们将实现 `BikeController` 类的骨架版本以供测试。在命令模式的上下文中，它充当接收者：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The overall purpose and structure of the class are self-explanatory. `ToggleTurbo()`
    and `Turn()` are public methods that get called by the command classes. However,
    `ResetPosition()` is for debugging and testing purposes only and can be ignored.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类的总体目的和结构是显而易见的。`ToggleTurbo()` 和 `Turn()` 是被命令类调用的公共方法。然而，`ResetPosition()`
    仅用于调试和测试目的，可以忽略。
- en: 'To test this code in your instance of Unity, you need to complete the following
    steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的 Unity 实例中测试此代码，您需要完成以下步骤：
- en: Start a new empty Unity scene that includes at least one light and camera.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的空 Unity 场景，其中至少包含一个灯光和一个摄像机。
- en: Add a 3D GameObject to the new scene, such as a cube, and make it visible from
    the scene's main camera.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新场景中添加一个 3D GameObject，例如一个立方体，并确保它可以从场景的主摄像机中看到。
- en: Attach the `InputHandler` and `BikeController` classes to the new GameObject.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `InputHandler` 和 `BikeController` 类附加到新的 GameObject 上。
- en: 'At runtime, if you have copied all the classes we have just reviewed in your
    project, you should see the following on your screen:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行时，如果您已将我们刚刚审查的所有类复制到您的项目中，您应该在屏幕上看到以下内容：
- en: '![](img/6930a7ab-085c-4dc5-8f7a-aced6162fbd0.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6930a7ab-085c-4dc5-8f7a-aced6162fbd0.png)'
- en: Figure 7.3 – Screenshot of the code in action inside Unity
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – Unity 中代码执行截图
- en: When you start recording, you will be able to move the cube on a horizontal
    axis. Each input entered can be replayed in the same sequence and timing they
    were recorded.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始录制时，您将能够沿水平轴移动立方体。每个输入都可以按记录的相同顺序和时序进行回放。
- en: Reviewing the implementation
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现回顾
- en: We completed the process of building a quick input replay system by using the
    Command pattern as our foundation. Of course, the code example in this chapter
    is not production-ready and very limited. Nevertheless, the goal of this chapter
    was to learn how to use the Command pattern with Unity, and not design an entire
    replay system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用命令模式作为基础，完成了构建快速输入回放系统的过程。当然，本章中的代码示例并不是生产就绪的，而且非常有限。尽管如此，本章的目标是学习如何使用命令模式与
    Unity 结合，而不是设计一个完整的回放系统。
- en: In the game prototype project in the `FPP` folder of the GitHub project, we
    did implement a more advanced example of a replay system that includes serialization
    and a rewind feature. We recommend checking it out and, of course, modify it at
    your discretion.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 项目的 `FPP` 文件夹中的游戏原型项目中，我们确实实现了一个包含序列化和倒退功能的更高级的回放系统示例。我们建议您查看它，当然，您可以根据自己的意愿进行修改。
- en: In the next section, we will review some alternatives solutions and approaches
    that we could have used to build our replay system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾一些替代解决方案和方法，我们本可以使用它们来构建我们的回放系统。
- en: Reviewing alternative solutions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代解决方案回顾
- en: 'Even if the Command pattern was perfectly suited for our use case, there are
    some alternative patterns and solutions we could have considered:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 即使命令模式非常适合我们的用例，我们还可以考虑一些替代模式和解决方案：
- en: '**Memento:** The Memento pattern provides the ability to roll back an object
    to a previous state. This was not our first choice for our replay system because
    we are focusing on recording inputs and queuing them for replay at a later time,
    which is very compatible with the design intention of the Command pattern. However,
    if we implemented a system with a rollback to the previous state feature, the
    Memento pattern will probably be our first choice.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备忘录模式（Memento）**：备忘录模式提供了将对象回滚到先前状态的能力。这并不是我们为回放系统选择的第一方案，因为我们更关注记录输入并将它们排队以供稍后回放，这与命令模式的意图非常兼容。然而，如果我们实现了一个具有回滚到先前状态功能的系统，备忘录模式可能将是我们的首选。'
- en: '**Queue/Stack**: Queues and stacks are not patterns, but data structures, but
    we could simply encode all our inputs and store them in a queue directly in our
    `InputHandler` class. It would have been more straightforward and less verbose
    than using the Command pattern. The choice between implementing a system with
    or without conventional design patterns is very contextual. If a system is simple
    enough, then the added verbosity and complexity that a design pattern might bring
    might exceed the potential benefits of using it.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列/栈**：队列和栈不是模式，而是数据结构，但我们可以简单地编码所有输入，并将它们直接存储在我们的`InputHandler`类中的队列中。这将比使用命令模式更直接、更简洁。在实现具有或没有传统设计模式的系统之间的选择非常具体。如果一个系统足够简单，那么设计模式可能带来的额外冗长和复杂性可能会超过使用它的潜在好处。'
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented a simple, but functional, replay system by using
    the Command pattern. Our goal with this chapter was not to show how to build a
    robust replay system, but instead showcase how to use the Command pattern to create
    something in Unity that might be useful for a game project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用命令模式实现了一个简单但功能性的回放系统。我们编写本章的目标不是展示如何构建一个健壮的回放系统，而是展示如何使用命令模式在Unity中创建可能对游戏项目有用的东西。
- en: I hope you will research alternative ways of implementing the Command pattern
    that might be better than shown in this book because, like most things in programming,
    there is no single way of doing things. Nevertheless, at least this chapter offers
    a first approach to using the Command pattern with Unity.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你会研究实现命令模式的替代方法，这些方法可能比本书中展示的更好，因为，就像编程中的大多数事情一样，没有一种唯一的方法来做事情。然而，至少这一章提供了使用Unity中的命令模式的第一种方法。
- en: In the next part of the book, we will start optimizing our code with the Object
    pool. An essential aspect of a good racing game is consistent performance and
    frame rate. Everything must run smoothly at every moment, or it might cause our
    game to feel slow and sluggish.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一部分，我们将开始使用对象池来优化我们的代码。一款优秀的赛车游戏的一个重要方面是保持一致的性能和帧率。每一刻都必须运行顺畅，否则可能会让我们的游戏感觉缓慢和笨拙。
