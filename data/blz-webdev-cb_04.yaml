- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Enhancing Data Display with Grids
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格增强数据展示
- en: In this chapter, we’ll dive into data presentation within Blazor applications
    through the implementation of advanced grid functionalities. Starting with the
    essential task of refactoring traditional tables into more dynamic grid components,
    we’ll explore the significance of attaching interactive actions to various parts
    of a grid, such as buttons or links within cells, enhancing user engagement and
    operational efficiency.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过实现高级网格功能来深入探讨 Blazor 应用程序中的数据展示。从将传统表格重构为更动态的网格组件的基本任务开始，我们将探讨将交互式操作附加到网格的各个部分（如单元格中的按钮或链接）的重要性，从而增强用户参与度和操作效率。
- en: We’ll also cover pagination techniques to manage large datasets effectively
    and explore infinite scrolling as a modern alternative to traditional pagination.
    Additionally, we’ll walk through creating a customizable grid, offering flexibility
    in adapting the grid to specific application needs. Lastly, we will discuss **QuickGrid**
    – a ready-to-use Blazor grid component with a predefined feature set and the quickest
    and simplest data-grid option you can leverage.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将涵盖分页技术，以有效地管理大型数据集，并探讨无限滚动作为传统分页的现代替代方案。此外，我们将逐步创建一个可定制的网格，提供灵活性以适应特定应用程序的需求。最后，我们将讨论**QuickGrid**——一个具有预定义功能集、可立即使用的
    Blazor 网格组件，这是您可以利用的最快、最简单的数据网格选项。
- en: By the end of this chapter, you will be equipped with the knowledge to enhance
    data display in your Blazor applications, improving the aesthetics and functionality
    of data presentation through the effective use of grids.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将具备增强 Blazor 应用程序中数据展示的知识，通过有效使用网格来提升数据展示的美观性和功能性。
- en: 'Here are the recipes we will follow in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将遵循以下食谱：
- en: Refactoring a table to a grid component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将表格重构为网格组件
- en: Attaching actions to parts of a grid
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将操作附加到网格的各个部分
- en: Implementing pagination
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现分页
- en: Implementing sorting
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现排序
- en: Implementing infinite scrolling
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现无限滚动
- en: Utilizing QuickGrid
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 QuickGrid
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will maintain simplicity across all examples to facilitate understanding
    and learning. We will use the same dataset for all recipes, so you can see the
    impact of different technical aspects of working with grid components. No external
    tools will be required but the following basics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在所有示例中保持简洁，以促进理解和学习。我们将使用相同的数据集来展示所有食谱，以便您可以看到不同技术方面与网格组件协同工作的影响。不需要外部工具，但以下是一些基本要求：
- en: A modern IDE (that supports Blazor development)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持 Blazor 开发的现代 IDE
- en: .NET 9 installed on your development machine
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的开发机器上安装 .NET 9
- en: A modern web browser (that supports WebAssembly)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持 WebAssembly 的现代网络浏览器
- en: A Blazor project (where you’ll write code as you go along)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Blazor 项目（您将在其中边做边写代码）
- en: 'All the code examples (and data samples) that you’ll see can be found in a
    dedicated GitHub repository at: [https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter04](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter04)
    . In each recipe that needs any samples, I will also point you to the directory
    where you can find them.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到的所有代码示例（和数据样本）都可以在专门的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter04](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter04)
    。在需要任何样本的每个食谱中，我还会指向您可以找到它们的目录。
- en: Refactoring a table to a grid component
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将表格重构为网格组件
- en: In this recipe, we’ll explore the fundamentals of developing a reusable grid
    component. Grids are a cornerstone in designing intuitive and organized user interfaces,
    enabling structured data display. Transitioning from using basic tables to implementing
    a reusable grid component is a strategic move toward achieving modular, maintainable,
    and scalable frontend architecture. Such a component can be adapted across different
    parts of an application, ensuring consistency and reducing redundancy in code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探讨开发可重用网格组件的基本原理。网格是设计直观和组织良好的用户界面的基石，它能够实现结构化数据展示。从使用基本表格到实现可重用网格组件的转变，是朝着实现模块化、可维护和可扩展的前端架构的战略举措。这样的组件可以适应应用程序的不同部分，确保一致性并减少代码中的冗余。
- en: Let’s start from the basics and refactor an existing, standard HTML table to
    a componentized grid.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始，将现有的标准 HTML 表格重构为一个组件化的网格。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Before we dive into exploring grid and refactoring markup, let’s get the stage
    ready:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探索网格和重构标记之前，让我们先准备好舞台：
- en: Create a **Chapter04** / **Recipe01** directory – this will be your working
    directory
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建**Chapter04** / **Recipe01**目录——这将是你的工作目录
- en: Copy the **Samples** and **HtmlGrid** files from the **Chapter04** / **Data**
    directory of the GitHub repository
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库的**Chapter04** / **Data**目录复制**Samples**和**HtmlGrid**文件
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to rebuild the standard HTML markup into a modular grid
    component:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将标准HTML标记重构为模块化网格组件：
- en: 'Locate the **HtmlGrid** component. Rename **HtmlGrid** to **Grid** and convert
    it to a generic version by adding the **@typeparam** attribute at the top of the
    file:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位**HtmlGrid**组件。将**HtmlGrid**重命名为**Grid**，并通过在文件顶部添加**@typeparam**属性将其转换为通用版本：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add a **@code** section within the **Grid** component. Declare three critical
    parameters: **Header** and the generic **Data** and **Row** , allowing for dynamic
    content rendering:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Grid**组件内添加一个**@code**部分。声明三个关键参数：**Header**和通用的**Data**以及**Row**，允许动态内容渲染：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Modify the table header cell markup to utilize the **Header** parameter, representing
    a flexible template:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改表格标题单元格标记以利用**Header**参数，代表一个灵活的模板：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Revise the loop responsible for rendering the table body. Instead of a fixed
    dataset, iterate over the **Data** collection provided through the parameter.
    Similarly, replace static row cells with the **Row** template parameter:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修订负责渲染表格体的循环。而不是使用固定数据集，遍历通过参数提供的**Data**集合。同样，用**Row**模板参数替换静态行单元格：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a new routable **TicketManager** component and embed the newly modularized
    **Grid** component in the markup area. Leverage the provided **Tickets.All** sample
    data for the **Grid** data source:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的可路由的**TicketManager**组件，并将新模块化的**Grid**组件嵌入到标记区域。利用提供的**Tickets.All**样本数据作为**Grid**的数据源：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Declare the **Header** markup for the embedded grid by extracting the header
    area from the original raw table:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从原始原始表格中提取标题区域来声明嵌入网格的**Header**标记：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Construct the **Row** markup for the embedded grid by extracting the row markup
    from the original raw table:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从原始原始表格中提取行标记来构建嵌入网格的**Row**标记：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we begin implementing a modular grid by renaming **HtmlGrid**
    to **Grid** . Then, we convert the **Grid** component into a generic component
    by adding the **@typeparam T** attribute at the top. If you haven’t seen generic
    components before, we already explored that topic in [*Chapter 1*](B22020_01.xhtml#_idTextAnchor020)
    , in the *Making components generic* recipe. In *step 2* , we declare three required
    parameters. With a generic **Data** collection and a generic **Row** template,
    we enable the dynamic rendering of any objects as table rows. With **Header**
    , we can dynamically provide a table header setup without depending on any fixed
    layout. In *step 3* , we utilize the **Header** parameter to modularize the table’s
    **thead** content, effectively making the table header fully customizable. In
    *step 4* , we configure table body rendering. We iterate over the **Data** collection
    and leverage the type-aware **Row** template to render table rows dynamically
    with the provided template.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们通过将**HtmlGrid**重命名为**Grid**开始实现模块化网格。然后，我们在文件顶部添加**@typeparam T**属性，将**Grid**组件转换为通用组件。如果你之前没有见过通用组件，我们已经在[*第1章*](B22020_01.xhtml#_idTextAnchor020)中的*使组件通用*配方中探讨了该主题。在*步骤2*中，我们声明了三个必需的参数。通过通用的**Data**集合和通用的**Row**模板，我们能够动态渲染任何对象作为表格行。通过**Header**，我们可以动态提供表格标题设置，而不依赖于任何固定布局。在*步骤3*中，我们利用**Header**参数对表格的**thead**内容进行模块化，从而使得表格标题完全可定制。在*步骤4*中，我们配置表格体渲染。我们遍历**Data**集合，并利用类型感知的**Row**模板动态渲染提供的模板的表格行。
- en: In *step 5* , we add a new routable **TicketManager** component. We showcase
    the new modularized **Grid** component, thereby embedding it into the **TicketManager**
    markup area. We utilize the **Tickets.All** dataset sample as the data source
    for the **Grid** instance. In *step 6* , we construct the **Header** markup by
    repurposing the original table header. In *step 7* , we do the same for the **Row**
    markup. However, with **Row** , there’s no need to implement a loop here – the
    **Grid** component already iterates over the provided dataset.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们添加了一个新的可路由**TicketManager**组件。我们展示了新的模块化**Grid**组件，并将其嵌入到**TicketManager**的标记区域中。我们使用**Tickets.All**数据集样本作为**Grid**实例的数据源。在*步骤6*中，我们通过重新利用原始表格标题来构建**Header**标记。在*步骤7*中，我们对**Row**标记做同样的处理。然而，对于**Row**，这里不需要实现循环——**Grid**组件已经遍历了提供的数据集。
- en: Such a modularized approach not only simplifies the implementation but also
    ensures that the grid remains highly customizable and adaptable to various data
    types. We’ve effectively only simplified the loop mechanism to render grid rows,
    but it was important to showcase the thought process behind breaking the HTML
    table into modular pieces. Understanding that allows us to take the grid concept
    further in the following recipes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模块化方法不仅简化了实现，还确保了网格保持高度可定制性和适应各种数据类型。我们实际上只简化了渲染网格行的循环机制，但展示将HTML表格拆分为模块化部分背后的思考过程很重要。理解这一点使我们能够在接下来的菜谱中进一步扩展网格概念。
- en: There’s more…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: While modularizing grids in Blazor applications enhances flexibility and reusability,
    you must consider the potential rendering overhead this introduces, especially
    with interactive grids. Every user interaction could activate the diffing algorithm
    (we touched upon diffing in [*Chapter 3*](B22020_03.xhtml#_idTextAnchor095) )
    and trigger re-rendering, which, depending on the complexity of your logic, might
    significantly affect performance. It’s essential that you find a balance in componentizing
    your grid – implement enough modularity to maintain flexibility without overcomplicating
    your components. Strategic API call placement and the judicious use of static
    **RenderFragment** instances can help manage performance impacts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blazor应用程序中将网格模块化可以提高灵活性和可重用性，但你必须考虑这种做法可能带来的潜在渲染开销，尤其是在交互式网格中。每一次用户交互都可能激活差异算法（我们在[*第3章*](B22020_03.xhtml#_idTextAnchor095)
    中提到了差异算法）并触发重新渲染，这可能会根据你逻辑的复杂性显著影响性能。在组件化你的网格时找到平衡至关重要——实现足够的模块化以保持灵活性，同时不要过度复杂化你的组件。策略性地放置API调用和审慎使用静态**RenderFragment**实例可以帮助管理性能影响。
- en: 'An effective strategy to improve grid performance is leveraging the **@key**
    Blazor attribute. This attribute helps Blazor’s diffing algorithm to identify
    elements more efficiently, reducing unnecessary DOM updates by associating each
    grid row or component with a unique identifier. If we were to assume that we expect
    only row-level changes in our grid, then we could leverage the **Id** property
    of the **Ticket** object and attach **@key** in the following way:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 提高网格性能的有效策略是利用**@key** Blazor属性。此属性帮助Blazor的差异算法更有效地识别元素，通过将每个网格行或组件与一个唯一标识符关联，减少不必要的DOM更新。如果我们假设我们期望网格中只有行级变化，那么我们可以利用**Ticket**对象的**Id**属性，并按以下方式附加**@key**：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When Blazor can correlate DOM elements with backing data objects, it can smartly
    decide when re-rendering is actually necessary and when it can skip updating certain
    parts of the DOM. By using the **@key** attribute, you not only enhance the rendering
    performance of your grids but also ensure a smoother user experience, particularly
    in data-intensive scenarios where the grid’s contents change frequently.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当Blazor能够将DOM元素与支持数据对象相关联时，它可以智能地决定何时重新渲染实际上是必要的，何时可以跳过更新DOM的某些部分。通过使用**@key**属性，你不仅提高了网格的渲染性能，还确保了更流畅的用户体验，尤其是在数据密集型场景中，网格的内容经常发生变化。
- en: Attaching actions to parts of a grid
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将操作附加到网格的部分
- en: Interactive grids play a pivotal role in enhancing the user experience within
    frontend applications, allowing users to interact with and manipulate data in
    intuitive and efficient ways. By attaching actions to parts of a grid, you can
    significantly improve the grid’s functionality, paving the way for advanced features
    such as sorting, filtering, and dynamic data management. We explored how actions
    and events correlate in Blazor in [*Chapter 3*](B22020_03.xhtml#_idTextAnchor095)
    . In this recipe, you’ll learn about the techniques and best practices for integrating
    actionable elements within your grid components. Attaching actions effectively
    to grid parts not only enriches the user interface but also provides a seamless
    experience for users as they interact with your application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式网格在增强前端应用程序的用户体验中起着关键作用，使用户能够以直观和高效的方式与数据交互和操作。通过将动作附加到网格的某些部分，你可以显著提高网格的功能性，为高级功能如排序、过滤和动态数据管理铺平道路。我们在[*第3章*](B22020_03.xhtml#_idTextAnchor095)中探讨了动作和事件在Blazor中的相关性。在本食谱中，你将了解在网格组件中集成可操作元素的技巧和最佳实践。有效地将动作附加到网格部分不仅丰富了用户界面，还为用户提供了与应用程序交互时的无缝体验。
- en: Let’s implement a table that allows you to attach an action to its columns that
    Blazor will execute when the user clicks on them and refactor the grid so it’s
    more flexible.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个表格，允许你为其列附加一个动作，当用户点击时Blazor将执行该动作，并重构网格以使其更灵活。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you dive into making columns and rows interactive, do the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入制作交互式列和行之前，请执行以下操作：
- en: Create a **Chapter04** / **Recipe02** directory – this will be your working
    directory
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter04** / **Recipe02**目录——这将是你的工作目录
- en: Copy **Grid** and **TicketManager** from the *Refactoring a table to a grid
    component* recipe or from the **Chapter04** / **Recipe01** directory in the GitHub
    repository
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*重构表格为网格组件*食谱或从GitHub仓库中的**Chapter04** / **Recipe01**目录复制**Grid**和**TicketManager**：
- en: Copy **Samples** from the **Chapter04** / **Data** directory in the GitHub repository
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中的**Chapter04** / **Data**目录复制**Samples**：
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何完成它...
- en: 'To implement interactive table columns and rows, follow these steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现交互式表格列和行，请按照以下步骤操作：
- en: 'Create a new, generic **ColumnViewModel** class with **Label** , **Template**
    , and **OnSort** properties:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的、通用的**ColumnViewModel**类，具有**Label**、**Template**和**OnSort**属性：
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Navigate to the **Grid** component and, below the **@typeparam** directive,
    add an attribute indicating that the generic type of the **Grid** component should
    cascade to descendant components:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**Grid**组件，并在**@typeparam**指令下方添加一个属性，指示**Grid**组件的泛型类型应级联到子组件：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the **@code** block of the **Grid** component, remove the **Row** parameter
    and rename the **Header** parameter to **ChildContent** . You already have the
    **Data** collection that you will also need:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Grid**组件的**@code**块中，删除**Row**参数，并将**Header**参数重命名为**ChildContent**。你已经有**Data**集合，你还需要它：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Below the parameters, initialize a **Columns** collection, with objects of
    type **ColumnViewModel** , and implement an **AddColumn()** method, allowing you
    to add a new column to the internal collection:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在参数下方，初始化一个**Columns**集合，包含类型为**ColumnViewModel**的对象，并实现一个**AddColumn()**方法，允许你向内部集合添加新的列：
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Lastly, at the end of the **@code** block, override the **OnAfterRender()**
    lifecycle method to ensure Blazor re-renders **Grid** when the rendering of all
    the nested components completes:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在**@code**块的最后，重写**OnAfterRender()**生命周期方法，以确保在所有嵌套组件渲染完成后Blazor重新渲染**Grid**：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Move to the **Grid** markup and replace the existing table header with a loop
    constructing column headers based on the objects in the **Columns** collection:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到**Grid**标记，并用一个循环替换现有的表头，该循环基于**Columns**集合中的对象构建列头：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Still within the **Grid** markup, in the table body area, nest another **foreach**
    loop where you render each column template for all elements in the **Data** collection:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**Grid**标记内，在表格体区域，嵌套另一个**foreach**循环，在其中渲染**Data**集合中所有元素的每个列模板：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To complete the markup, add a **CascadingValue** markup to share the current
    **Grid** instance with all the nested components it might contain:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成标记，添加一个**CascadingValue**标记以与所有可能包含的嵌套组件共享当前的**Grid**实例：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a new, generic **Column** component, with a **@code** block where you
    intercept a cascading reference to the **Grid** instance and allow passing **Label**
    , **ChildContent** , and **OnSort** parameters:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的通用**Column**组件，其中包含一个**@code**块，在该块中拦截对**Grid**实例的级联引用，并允许传递**Label**、**ChildContent**和**OnSort**参数：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Still in the **@code** block of the **Column** component, override the **OnInitialized()**
    lifecycle method to convert **Column** parameters to **ColumnViewModel** and pass
    the **model** instance to the parent **Grid** component:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**Column**组件的**@code**块中，重写**OnInitialized()**生命周期方法以将**Column**参数转换为**ColumnViewModel**并将**model**实例传递给父**Grid**组件：
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Navigate to the **TicketManager** component and initialize an **@code** block
    to implement a **Sort()** placeholder method, where you just log the intention:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**TicketManager**组件并初始化一个**@code**块以实现一个**Sort()**占位符方法，你只需记录意图：
- en: '[PRE18]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the **TicketManager** markup, replace the no longer compatible **Grid**
    content with columns rendered with the help of the **Column** component:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**TicketManager**标记中，用通过**Column**组件渲染的列替换不再兼容的**Grid**内容：
- en: '[PRE19]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lastly, enhance the **TicketManager** component to render in **InteractiveWebAssembly**
    mode:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，增强**TicketManager**组件以在**InteractiveWebAssembly**模式下渲染：
- en: '[PRE20]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'In *step 1* , we create a generic **ColumnViewModel** class. **ColumnViewModel**
    contains three properties: **Label** , representing the title of the column; **Template**
    , representing the markup to be rendered for each data point in the column; and
    **OnSort** , a callback to trigger sorting when a user clicks on the column header.
    Using **ColumnViewModel** , you can simplify the definition of a column in the
    grid without passing all the column properties explicitly.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们创建了一个通用的**ColumnViewModel**类。**ColumnViewModel**包含三个属性：**Label**，表示列的标题；**Template**，表示列中每个数据点要渲染的标记；以及**OnSort**，当用户点击列标题时触发的回调。使用**ColumnViewModel**，你可以简化网格中列的定义，而无需显式传递所有列属性。
- en: In *step 2* , we navigate to the **Grid** component and perform some refactoring
    to make its construction more dynamic. While the **Grid** component is already
    generic, we will work with cascading values next and want Blazor to automatically
    propagate these values type down the component tree. To achieve this descendant
    sharing, we leverage the **CascadingTypeParameter** attribute. **CascadingTypeParameter**
    allows a generic type to be shared across the component tree. Instead of passing
    the generic type **"T"** as a string, we use the **nameof()** method, achieving
    the same result while maintaining compile-time validation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们导航到**Grid**组件并执行一些重构以使其构建更加动态。虽然**Grid**组件已经是通用的，但我们接下来将处理级联值，并希望Blazor自动将这些值类型向下传递到组件树。为了实现这种后代共享，我们利用**CascadingTypeParameter**属性。**CascadingTypeParameter**允许在组件树中共享通用类型。我们不是将通用类型**"T"**作为字符串传递，而是使用**nameof()**方法，以实现相同的结果同时保持编译时验证。
- en: In *step 3* , we change the parameters required by **Grid** . We remove the
    **Row** parameter, as we will move the data point template into **ColumnViewModel**
    . With the **Grid** component now requiring only one **RenderFragment** parameter,
    we rename **Header** to **ChildContent** to simplify the grid’s construction later.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 3*中，我们更改了**Grid**所需的参数。我们移除了**Row**参数，因为我们将数据点模板移动到**ColumnViewModel**。由于**Grid**组件现在只需要一个**RenderFragment**参数，我们将**Header**重命名为**ChildContent**，以便稍后简化网格的构建。
- en: In *step 4* , we add a **Columns** collection that will serve as a container
    for the grid columns we will render. To populate that collection, we expose an
    **AddColumn()** method, which accepts a **ColumnViewModel** object and adds it
    to **Columns** .
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 4*中，我们添加了一个**Columns**集合，它将作为我们将要渲染的网格列的容器。为了填充这个集合，我们公开了一个**AddColumn()**方法，它接受一个**ColumnViewModel**对象并将其添加到**Columns**。
- en: In *step 5* , we override the **OnAfterRender()** lifecycle method of the **Grid**
    component. This instructs Blazor to re-render the **Grid** component immediately
    after the initial render completes. This might seem counter-intuitive now, but
    it will make more sense when we implement the **Column** component later.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 5*中，我们重写了**Grid**组件的**OnAfterRender()**生命周期方法。这指示Blazor在初始渲染完成后立即重新渲染**Grid**组件。现在这可能会显得有些反直觉，但当我们稍后实现**Column**组件时，它将更有意义。
- en: In *step 6* , we adjust the **Grid** markup to comply with the changes in the
    **@code** block. As we’ve removed the **Header** parameter, we rebuild the table
    header area. We reconstruct the **thead** content by explicitly embedding **tr**
    tags and rendering the **Label** properties of columns from the **Columns** collection.
    We also attach the declared sorting action of each column to the **@onclick**
    event of each **th** element. You attach actions to grid elements the same as
    any other HTML element.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 6*中，我们调整**网格**标记以符合**@code**块中的更改。由于我们已移除**标题**参数，我们重建表格标题区域。我们通过显式嵌入**tr**标签并渲染**Columns**集合中列的**标签**属性来重构**thead**内容。我们还将每个列声明的排序操作附加到每个**th**元素的**@onclick**事件。您将操作附加到网格元素的方式与任何其他HTML元素相同。
- en: In *step 7* , we reconstruct the table body. We replace the **Row** reference
    (which we’ve removed) with explicit **tr** tags inside the loop iterating over
    the **Data** collection. Inside each **tr** , we nest another loop, instructing
    Blazor to render each **Data** element using the template from the **Template**
    property of the current column.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 7*中，我们重构表格主体。我们将（我们已移除的）**行**引用替换为在遍历**数据**集合的循环中显式的**tr**标签。在每个**tr**内部，我们嵌套另一个循环，指示Blazor使用当前列的**模板**属性中的模板渲染每个**数据**元素。
- en: In *step 8* , we complete the **Grid** markup by constructing a **CascadingValue**
    area, where we share the current grid instance with nested components. We will
    also need the **Column** component to understand this part, so we will implement
    it next.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 8*中，我们通过构建**级联值**区域来完成**网格**标记，在该区域中，我们与嵌套组件共享当前网格实例。我们还需要**列**组件来理解这部分，因此我们将在下一步实现它。
- en: In *step 9* , we create a generic **Column** component, which will be the primary
    construction element for the grid. The **Column** component intercepts the **Grid**
    instance where it is rendered and requires **Label** and **ChildContent** parameters.
    The **Label** parameter defines the column title, while **ChildContent** represents
    a template for the data point belonging to that column. This markup will be rendered
    for each element of the **Data** collection in the grid. We also declare one optional
    parameter, **OnSort** , allowing the attachment of sorting behavior triggered
    by clicking the column header.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 9*中，我们创建一个通用的**列**组件，它将成为网格的主要构建元素。**列**组件拦截其渲染的**网格**实例，并需要**标签**和**子内容**参数。**标签**参数定义列标题，而**子内容**代表属于该列的数据点的模板。此标记将为网格中**数据**集合的每个元素渲染。我们还声明了一个可选参数**OnSort**，允许通过点击列标题附加排序行为。
- en: In *step 10* , we complete the **Column** implementation by overriding the **OnInitialized()**
    lifecycle method, where we convert the incoming parameters into a **ColumnViewModel**
    object that we then register in the **Grid** component using the previously implemented
    **AddColumn()** method. The **Column** component is markupless by design – it
    doesn’t render any markup explicitly. Instead, it registers the row template and
    column definition directly in the **Grid** instance, which knows how to construct
    the table markup from those details.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 10*中，我们通过重写**OnInitialized()**生命周期方法来完成**列**的实现，在该方法中，我们将传入的参数转换为**ColumnViewModel**对象，然后使用之前实现的**AddColumn()**方法将其注册到**网格**组件中。**列**组件按设计是无标记的——它不会显式渲染任何标记。相反，它直接在**网格**实例中注册行模板和列定义，该实例知道如何根据这些详细信息构建表格标记。
- en: In *step 11* , we navigate to the **TicketManager** component. First, we initialize
    a **@code** block where we implement a **Sort()** method – a behavior placeholder
    that only logs an operation intention (we will implement the sorting in a separate
    step).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 11*中，我们导航到**票务管理器**组件。首先，我们初始化一个**@code**块，在其中实现一个**Sort()**方法——一个仅记录操作意图的行为占位符（我们将在单独的步骤中实现排序）。
- en: In *step 12* , we reconstruct the grid content, leveraging the **Column** component.
    As all grid elements are generic and the **Grid** component cascades the generic
    parameter type downwards, we can access the **Ticket** properties with a **context**
    reference. Knowing this, we build the first column with a **Tariff** title and
    declare that for each data point, we want to render the value of the **Tariff**
    property of the current element. We also declare that the **OnSort** callback
    exposed by **Column** will trigger the **Sort()** method on the **Tariff** property.
    For the second column, we duplicate these steps for the **Price** property.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤12*中，我们利用**Column**组件重构网格内容。由于所有网格元素都是通用的，并且**Grid**组件将泛型参数类型向下传递，我们可以使用**context**引用访问**Ticket**属性。了解这一点后，我们构建了第一个带有**Tariff**标题的列，并声明对于每个数据点，我们想要渲染当前元素的**Tariff**属性的值。我们还声明**Column**暴露的**OnSort**回调将触发**Tariff**属性的**Sort()**方法。对于第二列，我们对**Price**属性重复这些步骤。
- en: In *step 13* , since we expect the grid to be interactive, we declare that the
    **TicketManager** component will render in **InteractiveWebAssembly** mode.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤13*中，由于我们期望网格是交互式的，我们声明**TicketManager**组件将以**InteractiveWebAssembly**模式渲染。
- en: Now, with the entire implementation in place, it will be easier to understand
    the rendering of the enhanced **Grid** component. As you can see, the **Column**
    component we use to construct the grid doesn’t carry any markup, so it will be
    fully transparent in the DOM. However, **Column** still requires cascading access
    to the **Grid** instance, which is why we put all the customizable **Grid** content
    in the **CascadingValue** tags in *step 8* . With that, each **Column** instance
    can register the render template it carries directly within the **Grid** instance,
    so it is rendered together with the **Grid** markup. This is also why we’ve overridden
    the **OnAfterRender()** lifecycle method of the **Grid** component in *step 5*
    . We must re-render the table markup after the initial render of the grid and
    after all the **Column** instances register their payload within the **Grid**
    instance.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着整个实现的完成，理解增强的**Grid**组件的渲染将更容易。如您所见，我们用于构建网格的**Column**组件不携带任何标记，因此在DOM中将完全透明。然而，**Column**仍然需要级联访问**Grid**实例，这就是为什么我们在*步骤8*中将所有可定制的**Grid**内容放入**CascadingValue**标签中。有了这个，每个**Column**实例可以直接在**Grid**实例中注册它携带的渲染模板，因此它与**Grid**标记一起渲染。这也是为什么我们在*步骤5*中覆盖了**Grid**组件的**OnAfterRender()**生命周期方法。我们必须在网格的初始渲染之后以及所有**Column**实例在**Grid**实例中注册其有效负载之后重新渲染表格标记。
- en: There’s more…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In some scenarios, you might need to attach actions to entire grid rows and
    specific grid cells. When a row overlaps a cell, you will face **event bubbling**
    . When an event, such as a mouse click or key press, occurs in the browser, it
    propagates (or bubbles) from the target element through its ancestors, resulting
    in unwanted behavior in parent elements listening for the same event. With Blazor’s
    **@onEvent:stopPropagation** attribute, you can prevent this propagation, ensuring
    that only the intended event handler executes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，您可能需要将操作附加到整个网格行和特定的网格单元格。当一行与单元格重叠时，您将面临**事件冒泡**。当浏览器中发生事件，如鼠标点击或按键时，它从目标元素通过其祖先传播（或冒泡），导致父元素中监听相同事件的不当行为。使用Blazor的**@onEvent:stopPropagation**属性，您可以防止这种传播，确保只有预期的处理程序执行：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this code snippet, we allow users to display ticket details when they click
    on a table row and add a ticket to the cart when they click on the cell with the
    price. We’ve attached the desired event handlers to the **tr** and **td** elements.
    Additionally, we’ve attached the **@onclick:stopPropagation** attribute to **td**
    with a price. Now, we prevent the click event from propagating to the parent row.
    As a result, when the user clicks the cell, Blazor executes only the **AddToCart()**
    handler and omits the **ShowTicketDetails()** handler. With **@onclick:stopPropagation**
    , we ensure that the click event is handled solely by the cell and does not affect
    the surrounding row element.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们允许用户在点击表格行时显示票务详情，在点击带有价格的单元格时将票务添加到购物车。我们已经将所需的事件处理程序附加到**tr**和**td**元素上。此外，我们还将**@onclick:stopPropagation**属性附加到带有价格的**td**上。现在，我们阻止点击事件传播到父行。因此，当用户点击单元格时，Blazor只执行**AddToCart()**处理程序，并省略**ShowTicketDetails()**处理程序。通过**@onclick:stopPropagation**，我们确保点击事件仅由单元格处理，不会影响周围的行元素。
- en: Implementing pagination
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现分页
- en: Pagination refers to dividing content into separate pages, which is particularly
    crucial for tables and grids displaying large datasets. This approach improves
    the readability and navigability of data and significantly enhances performance
    by reducing the volume of data loaded and rendered at any given time. Pagination
    is often required in tables and grids to manage large amounts of data efficiently,
    preventing overwhelming users with too much information at once and ensuring that
    the application remains responsive.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 分页是指将内容分成单独的页面，这对于显示大量数据的表格和网格尤其重要。这种方法提高了数据的可读性和可导航性，并通过减少在任何给定时间内加载和渲染的数据量来显著提高性能。在表格和网格中，分页通常需要有效地管理大量数据，防止用户一次性接收过多信息而感到不知所措，并确保应用程序保持响应。
- en: Let’s add a simple pagination to the grid.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给网格添加简单的分页。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we dive in, ensure that you do the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，请确保你做了以下事情：
- en: Create a **Chapter04** / **Recipe03** directory – this will be your working
    directory
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter04**/**Recipe03**目录——这将是你的工作目录
- en: Copy **Column** , **ColumnViewModel** , **Grid** , and **TicketManager** from
    the *Attaching actions to parts of a grid* recipe or the **Chapter04** / **Recipe02**
    directory in the GitHub repository
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*将操作附加到网格的一部分*配方或GitHub仓库中的**Chapter04**/**Recipe02**目录复制**Column**、**ColumnViewModel**、**Grid**和**TicketManager**：
- en: Copy **Samples** from the **Chapter04** / **Data** directory in the GitHub repository
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中的**Chapter04**/**Data**目录复制**Samples**：
- en: How to do it…
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To add pagination to your **Grid** component, follow these steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要将分页添加到你的**Grid**组件中，请按照以下步骤操作：
- en: 'Create a new **PaginateEventArgs** record with **Page** and **Size** properties:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的带有**Page**和**Size**属性的**PaginateEventArgs**记录：
- en: '[PRE22]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add a new **Paginator** component and initialize a **@code** block with two
    required parameters: a **Paginate** callback with **PaginateEventArgs** and **DataSize**
    :'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的**Paginator**组件，并使用两个必需参数初始化一个**@code**块：一个带有**PaginateEventArgs**和**DataSize**的**Paginate**回调：
- en: '[PRE23]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Below the parameters, initialize variables defining the pagination state: **TotalPages**
    , **CurrentPage** , and **PageSize** with default initial values:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在参数下方，初始化定义分页状态的变量：**TotalPages**、**CurrentPage**和**PageSize**，并使用默认的初始值：
- en: '[PRE24]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next to the state variables, override the **OnInitialized()** lifecycle method
    and calculate the **TotalPages** value:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在状态变量旁边，重写**OnInitialized()**生命周期方法并计算**TotalPages**值：
- en: '[PRE25]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Still within the **@code** block, implement a **LoadAsync()** method, invoking
    the **Paginate** callback with the current pagination state:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**@code**块内，实现一个**LoadAsync()**方法，调用**Paginate**回调并传递当前的分页状态：
- en: '[PRE26]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Below the loading method, define a **NextAsync()** method to enable the forward
    navigation of data pages:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载方法下方，定义一个**NextAsync()**方法以启用数据页面的前进导航：
- en: '[PRE27]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, next to the forward navigation, implement a **PreviousAsync()**
    method to handle backward navigation of data pages:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，在前进导航旁边，实现一个**PreviousAsync()**方法来处理数据页面的向后导航：
- en: '[PRE28]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Complete the **@code** block by overriding the **OnAfterRenderAsync()** lifecycle
    method and load the initial data page, after the first render:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过重写**OnAfterRenderAsync()**生命周期方法并加载初始数据页面来完成**@code**块，在第一次渲染之后：
- en: '[PRE29]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Move to the **Paginator** markup area and construct a container with two **button**
    elements for page navigation and an **input** field to display the **CurrentPage**
    value:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到**Paginator**标记区域，并构建一个包含两个用于页面导航的**button**元素和一个用于显示**CurrentPage**值的**input**字段的容器：
- en: '[PRE30]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Navigate to the **Grid** component and, within the **@code** block, initialize
    a generic **Set** collection to persist currently displayed data:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**Grid**组件，并在**@code**块内初始化一个通用的**Set**集合以持久化当前显示的数据：
- en: '[PRE31]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next to the **Set** initialization, implement a **LoadAsync()** method, accepting
    a **PaginationEventArgs** parameter, that takes a slice of data from the **Data**
    collection based on the incoming pagination state details:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Set**初始化旁边，实现一个接受**PaginationEventArgs**参数的**LoadAsync()**方法，该方法根据传入的分页状态详细信息从**Data**集合中获取数据的一个片段：
- en: '[PRE32]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Jump to the **Grid** component markup and update the loop generating table
    rows to iterate over the **Set** collection:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到**Grid**组件的标记，并更新生成表格行的循环以遍历**Set**集合：
- en: '[PRE33]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Still within the **Grid** markup, under the table, embed the **Paginator**
    component, attaching the **LoadAsync()** method to its **Paginate** callback and
    passing the size of the **Data** collection as the **DataSize** parameter:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 **Grid** 标记的表格下方嵌入 **Paginator** 组件，将其 **LoadAsync()** 方法附加到其 **Paginate**
    回调，并将 **Data** 集合的大小作为 **DataSize** 参数传递：
- en: '[PRE34]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we create a **PaginateEventArgs** record with **Page** and **Size**
    properties representing the currently visible page and the size of each page a
    user is viewing. Having these details allows us to fetch data in expected batches
    effectively. As we expect **PaginateEventArgs** to represent a pagination event,
    it makes sense to make the object immutable, so we declare it as a **record**
    object. To simplify the **PaginateEventArgs** initialization, we also leverage
    the primary constructor rather than the legacy one and explicit property declaration.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们创建了一个带有 **Page** 和 **Size** 属性的 **PaginateEventArgs** 记录，分别表示当前可见的页面和用户查看的每页大小。拥有这些详细信息使我们能够有效地按预期批次获取数据。由于我们期望
    **PaginateEventArgs** 表示一个分页事件，因此使该对象不可变是有意义的，所以我们将其声明为 **record** 对象。为了简化 **PaginateEventArgs**
    的初始化，我们还利用了主构造函数而不是传统的构造函数和显式属性声明。
- en: In *step 2* , we introduce a **Paginator** component to encapsulate the grid
    pagination logic. First, we initialize a **@code** block within **Paginator**
    . We declare a **Paginate** callback that returns **PaginateEventArgs** to communicate
    page navigation changes. We also declare a **DataSize** parameter. Knowing the
    amount of data to paginate allows us to improve the pagination experience by setting
    the maximum page a user can reach.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们引入了一个 **Paginator** 组件来封装网格分页逻辑。首先，我们在 **Paginator** 内初始化一个 **@code**
    块。我们声明一个返回 **PaginateEventArgs** 的 **Paginate** 回调，以通信页面导航更改。我们还声明了一个 **DataSize**
    参数。知道要分页的数据量使我们能够通过设置用户可以达到的最大页数来改进分页体验。
- en: 'In *step 3* , we initialize three state properties: **TotalPages** , indicating
    where the pagination navigator should stop; **CurrentPage** , indicating the current
    page a user is viewing; and **PageSize** , defining how many elements we allow
    to load per page. For **CurrentPage** , we set the initial value to **1** since
    we naturally start from the first page. We also fix **PageSize** to **5** , allowing
    us to focus on the pagination behavior.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 中，我们初始化了三个状态属性：**TotalPages**，表示分页导航器应该停止的位置；**CurrentPage**，表示用户正在查看的当前页面；以及
    **PageSize**，定义我们允许每页加载的元素数量。对于 **CurrentPage**，我们将初始值设置为 **1**，因为我们自然从第一页开始。我们还固定
    **PageSize** 为 **5**，以便我们能够专注于分页行为。
- en: In *step 4* , we override the **OnInitialized()** lifecycle method of **Paginator**
    to calculate the **TotalPages** value based on the incoming **DataSize** parameter
    and the **PageSize** variable. We implement the simplest arithmetic calculation
    that always rounds up to the next whole number, whenever the division of **DataSize**
    and **PageSize** is an odd number, indicating that the last page is not full.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 4* 中，我们重写了 **Paginator** 的 **OnInitialized()** 生命周期方法，根据传入的 **DataSize**
    参数和 **PageSize** 变量计算 **TotalPages** 值。我们实现了最简单的算术计算，该计算始终向上取整到下一个整数，当 **DataSize**
    和 **PageSize** 的除法结果为奇数时，这表明最后一页不是满的。
- en: In *step 5* , we implement a **LoadAsync()** method, which is central to the
    pagination request communication. Every time Blazor invokes **LoadAsync()** ,
    we create a **PaginationEventArgs** instance from the current value of **CurrentPage**
    and **PageSize** variables and asynchronously pass it to the **Paginate** callback
    for the callback consumer to interpret.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 5* 中，我们实现了一个 **LoadAsync()** 方法，这是分页请求通信的核心。每次 Blazor 调用 **LoadAsync()**
    时，我们都会从 **CurrentPage** 和 **PageSize** 变量的当前值创建一个 **PaginationEventArgs** 实例，并将其异步传递给
    **Paginate** 回调，以便回调消费者进行解释。
- en: In *step 6* , we construct the first part of the **Paginator** navigation capabilities
    by implementing a **NextAsync()** method. **NextAsync()** allows the user to fetch
    the next page of data – we check whether the user is already on the last available
    page to prevent further navigation; if not, we increment **CurrentPage** and invoke
    the **LoadAsync()** method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 6* 中，我们通过实现一个 **NextAsync()** 方法构建了 **Paginator** 导航能力的第一部分。**NextAsync()**
    允许用户获取下一页的数据 – 我们检查用户是否已经在最后一个可用的页面上，以防止进一步的导航；如果不是，我们增加 **CurrentPage** 并调用 **LoadAsync()**
    方法。
- en: In *step 7* , we construct the **NextAsync()** counterpart, **PreviousAsync()**
    . The **PreviousAsync()** method allows the user to navigate backward and fetch
    the previous dataset. To prevent the user from navigating too far back, we check
    whether **CurrentPage** is already the first available page. If not, we decrease
    **CurrentPage** and invoke **LoadAsync()** .
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 7* 中，我们构建 **NextAsync()** 的对应方法，**PreviousAsync()**。**PreviousAsync()**
    方法允许用户向后导航并获取前一个数据集。为了防止用户导航得太远，我们检查 **CurrentPage** 是否已经是第一页。如果不是，我们减少 **CurrentPage**
    并调用 **LoadAsync()**。
- en: The last thing we must cover is the initial loading of data. In *step 8* , we
    override the **OnAfterRenderAsync()** lifecycle method of **Paginator** . After
    the first render, we invoke **LoadAsync()** to instruct Blazor to load the defined
    initial page with the specified number of elements.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须覆盖的最后一件事是数据的初始加载。在 *步骤 8* 中，我们重写了 **Paginator** 的 **OnAfterRenderAsync()**
    生命周期方法。在第一次渲染后，我们调用 **LoadAsync()** 指示 Blazor 加载定义的初始页面，并带有指定的元素数量。
- en: In *step 9* , we build the **Paginator** markup. We construct a primitive bar
    with two buttons allowing navigation back and forth using **PreviousAsync()**
    and **NextAsync()** respectively. We also add a disabled input field displaying
    the current page based on the **CurrentPage** variable.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 9* 中，我们构建 **Paginator** 标记。我们构建了一个原始的条形，包含两个按钮，分别允许使用 **PreviousAsync()**
    和 **NextAsync()** 进行前后导航。我们还添加了一个禁用的输入字段，显示基于 **CurrentPage** 变量的当前页。
- en: In *step 10* , we move to the **Grid** component and enhance it to comply with
    **Paginator** and pagination. First, we focus on the **@code** block and declare
    a generic **Set** collection to store the currently fetched dataset.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 10* 中，我们转向 **Grid** 组件并增强它以符合 **Paginator** 和分页。首先，我们关注 **@code** 块并声明一个通用的
    **Set** 集合来存储当前获取的数据集。
- en: In *step 11* , we implement a **LoadAsync()** method that consumes **PaginateEventArgs**
    and reacts to the **Paginator** callback. Inside **LoadAsync()** , we use **LINQ
    methods** to load only the required elements from **Data** . We use the **Skip()**
    method to skip elements the user has already seen. Since the **Paginator** component
    starts the page count from **1** while collection indexing starts from **0** ,
    we reduce the **args.Page** value by **1** and then multiply it by **args.Size**
    to get the number of elements to omit from the start of the **Data** collection.
    Then, we use a **Take()** method to fetch the desired amount of elements.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 11* 中，我们实现了一个 **LoadAsync()** 方法，该方法消费 **PaginateEventArgs** 并响应 **Paginator**
    回调。在 **LoadAsync()** 内部，我们使用 **LINQ 方法** 从 **Data** 中仅加载所需元素。我们使用 **Skip()** 方法跳过用户已经看到的元素。由于
    **Paginator** 组件从 **1** 开始计数页面，而集合索引从 **0** 开始，所以我们减去 **args.Page** 的值 **1**，然后乘以
    **args.Size** 以获取从 **Data** 集合开始要跳过的元素数量。然后，我们使用 **Take()** 方法获取所需数量的元素。
- en: In *step 12* , we jump to the **Grid** markup, locate the loop where we iterate
    over **Data** elements, and update the loop to work with **Set** .
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 12* 中，我们跳转到 **Grid** 标记，找到迭代 **Data** 元素的循环，并将循环更新为使用 **Set**。
- en: Lastly, in *step 13* , we embed the **Paginator** component into the **Grid**
    markup. We attach the **LoadAsync()** method to the **Paginate** callback and
    count the **Data** elements to provide the required **DataSize** parameter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 *步骤 13* 中，我们将 **Paginator** 组件嵌入到 **Grid** 标记中。我们将 **LoadAsync()** 方法附加到
    **Paginate** 回调，并计算 **Data** 元素以提供所需的 **DataSize** 参数。
- en: With very little code, we have arrived at a fully functional and generic pagination
    feature.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用少量代码，我们就实现了完全功能和通用的分页功能。
- en: '![Figure 4.1: Grid loading with a functional pagination bar](img/B22020_04_1.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：带有功能分页条的网格加载](img/B22020_04_1.jpg)'
- en: 'Figure 4.1: Grid loading with a functional pagination bar'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：带有功能分页条的网格加载
- en: There’s more…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the pagination implementation, we have some methods returning **Task** that
    we didn’t declare as **async** but rather returned the **Task.CompletedTask**
    object. This approach is beneficial when we don’t perform asynchronous operations
    inside the method but must adhere to an asynchronous method signature. Returning
    **Task.CompletedTask** is more efficient in such scenarios because we avoid the
    overhead of the async state machine that the compiler generates for **async**
    methods. By not awaiting **Task** and simply returning **Task.CompletedTask**
    , we minimize unnecessary performance costs associated with task scheduling and
    context switching.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在分页实现中，我们有一些返回**Task**的方法，我们没有将其声明为**async**，而是返回了**Task.CompletedTask**对象。当我们在方法内部不执行异步操作但必须遵守异步方法签名时，这种方法是有益的。在这种情况下返回**Task.CompletedTask**更高效，因为我们避免了编译器为**async**方法生成的异步状态机的开销。通过不等待**Task**并简单地返回**Task.CompletedTask**，我们最小化了与任务调度和上下文切换相关的性能成本。
- en: See also
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: In this recipe, we also saw the LINQ methods in action. LINQ methods could fill
    a book on their own, so if you’d like to explore that topic, head over to [https://learn.microsoft.com/en-us/dotnet/csharp/linq/](https://learn.microsoft.com/en-us/dotnet/csharp/linq/)
    .
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们还看到了LINQ方法的应用。LINQ方法本身就可以写成一本书，所以如果你想探索这个话题，请访问[https://learn.microsoft.com/en-us/dotnet/csharp/linq/](https://learn.microsoft.com/en-us/dotnet/csharp/linq/)。
- en: Implementing sorting
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现排序
- en: In this recipe, we dive into organizing data within grids by arranging rows
    based on column values. Sorting allows users to easily navigate and analyze data
    by prioritizing it according to relevant criteria, such as alphabetical order,
    numerical values, dates, or custom parameters. This capability becomes increasingly
    important in applications dealing with extensive datasets, where locating specific
    information or understanding data trends can become cumbersome without effective
    sorting mechanisms. By introducing sorting functionalities, developers can significantly
    improve the user experience, offering intuitive interactions and insights into
    the data presented.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们深入探讨如何在网格中组织数据，通过根据列值排列行来实现。排序允许用户根据相关标准（如字母顺序、数值、日期或自定义参数）优先排序数据，从而轻松地导航和分析数据。在处理大量数据集的应用程序中，这种能力变得越来越重要，如果没有有效的排序机制，查找特定信息或理解数据趋势可能会变得很麻烦。通过引入排序功能，开发者可以显著提升用户体验，提供直观的交互和数据洞察。
- en: Let’s enhance the grid with sorting functionality that users can trigger by
    clicking on the grid column headers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增强网格，添加用户可以通过点击网格列标题触发的排序功能。
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we explore sorting in a grid, do the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索网格中的排序之前，请执行以下操作：
- en: Create a **Chapter04** / **Recipe04** directory – this will be your working
    directory
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter04** / **Recipe04**目录——这将是你的工作目录。
- en: Copy **Column** , **ColumnViewModel** , **Grid** , **PaginateEventArgs** , **Paginator**
    , and **TicketManager** from the *Implementing pagination* recipe or from the
    **Chapter04** / **Recipe04** directory in the GitHub repository
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**Implementing pagination**菜谱或从GitHub仓库的**Chapter04** / **Recipe04**目录复制**Column**、**ColumnViewModel**、**Grid**、**PaginateEventArgs**、**Paginator**和**TicketManager**。
- en: Copy **Samples** from the **Chapter04** / **Data** directory in the GitHub repository
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库的**Chapter04** / **Data**目录复制**Samples**。
- en: How to do it…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to add sorting to a grid:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤向网格添加排序：
- en: 'Navigate to the **ColumnViewModel** class and replace the **OnSort** callback
    with a **Property** delegate, encapsulating the logic to select a property from
    a generic model:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**ColumnViewModel**类，并将**OnSort**回调替换为**Property**委托，封装从泛型模型中选择属性的逻辑：
- en: '[PRE35]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Go to the **@code** block of the **Column** component and replace the **OnSort**
    parameter with a **Property** delegate parameter, allowing you to pass a property
    selector from a generic model:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**Column**组件的**@code**块，并将**OnSort**参数替换为**Property**委托参数，允许你从泛型模型传递属性选择器：
- en: '[PRE36]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Still in the **Column** component, fix the implementation of the overridden
    **OnInitialized()** method by updating the **ColumnViewModel** construction to
    utilize the **Property** parameter:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**Column**组件中，通过更新**ColumnViewModel**构造函数以利用**Property**参数来修复重写的**OnInitialized()**方法：
- en: '[PRE37]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Move to the **Grid** component. At the end of the **@code** block, declare
    variables to persist the current sorting column and order:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到**Grid**组件。在**@code**块的末尾，声明变量以持久化当前排序列和顺序：
- en: '[PRE38]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Below the sorting state variables, add a **PaginatorRef** variable to allow
    referencing the **Paginator** component from within the **Grid** code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在排序状态变量下方，添加一个 **PaginatorRef** 变量，以便在 **Grid** 代码中引用 **Paginator** 组件：
- en: '[PRE39]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Complete the **@code** block of the **Grid** component, by implementing a **SortAsync()**
    method, allowing you to dynamically sort the **Data** collection based on the
    **Property** selector set for each **ColumnViewModel** column object:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现一个 **SortAsync()** 方法来完成 **Grid** 组件的 **@code** 块，允许你根据为每个 **ColumnViewModel**
    列对象设置的 **Property** 选择器动态地对 **Data** 集合进行排序：
- en: '[PRE40]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the **Grid** markup, replace the delegate attached to the table column headers
    with the newly implemented **SortAsync()** :'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Grid** 标记中，将附加到表格列标题的委托替换为新实现的 **SortAsync()**：
- en: '[PRE41]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Still within the **Grid** markup, locate the **Paginator** instance and attach
    its reference to the **PaginatorRef** variable:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 **Grid** 标记内，找到 **Paginator** 实例并将其引用附加到 **PaginatorRef** 变量：
- en: '[PRE42]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Navigate to the **TicketManager** component and fix the **Column** instances
    by passing in the **Property** selector and defining the **Ticket** properties
    to sort on:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **TicketManager** 组件，并通过传递 **Property** 选择器和定义要排序的 **Ticket** 属性来修复 **Column**
    实例：
- en: '[PRE43]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we update the **ColumnViewModel** class and replace the **OnSort**
    callback with a generic **Func<T, object>** . **Func<T, object>** is a delegate
    that represents a method returning an object from a given type, **T** . We use
    **Func<T, object>** as a selector for the property to sort by and name it **Property**
    intuitively.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们更新 **ColumnViewModel** 类，并将 **OnSort** 回调替换为泛型 **Func<T, object>**。**Func<T,
    object>** 是一个表示从给定类型 **T** 返回对象的委托。我们使用 **Func<T, object>** 作为排序属性的选择器，并直观地命名为
    **Property**。
- en: In *step 2* , we jump to the **Column** component to update the **Grid** building
    block with the same logic as we did for **ColumnViewModel** . Inside the **@code**
    block of **Column** , we replace the **OnSort** callback with the **Func<T, object>**
    parameter. In *step 3* , we fix the mapping in the overridden **OnInitialized()**
    method to pass the sorting property selector into the **ColumnViewModel** constructor
    and consequently into the **Grid** instance.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们跳转到 **Column** 组件，使用与 **ColumnViewModel** 相同的逻辑更新 **Grid** 构建块。在
    **Column** 的 **@code** 块内部，我们将 **OnSort** 回调替换为 **Func<T, object>** 参数。在 *步骤 3*
    中，我们在重写的 **OnInitialized()** 方法中修复映射，将排序属性选择器传递给 **ColumnViewModel** 构造函数，从而传递给
    **Grid** 实例。
- en: 'In *step 4* , we navigate to the **Grid** component and implement the backing
    logic for the sorting feature. First, we declare two variables representing the
    current state of the sorting: **_currentSortColumn** , indicating which sorting
    property is currently selected, and an **_isAsc** flag, implying whether the sorting
    order is ascending or descending.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 4* 中，我们导航到 **Grid** 组件并实现排序功能的后端逻辑。首先，我们声明两个变量来表示排序的当前状态：**_currentSortColumn**，表示当前选中的排序属性，以及一个
    **_isAsc** 标志，表示排序顺序是升序还是降序。
- en: In *step 5* , we introduce a **PaginatorRef** variable of type **Paginator**
    . It might look a bit confusing at first glance. Using a component as a variable
    in your C# code in Blazor allows you to interact with the component’s public API.
    Furthermore, with the **@ref** attribute, you can capture a reference to the rendered
    component and leverage its methods and properties. But **@ref** has one major
    limitation – the reference is only populated after the component rendering completes.
    Since Blazor’s rendering process is asynchronous, any attempt to use the reference
    immediately after component initialization may fail because the reference might
    not yet be available. Therefore, you must ensure that you access the **@ref**
    bound reference only after the component render cycle completes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 5* 中，我们引入一个类型为 **Paginator** 的 **PaginatorRef** 变量。一开始可能会有些困惑。在 Blazor
    的 C# 代码中使用组件作为变量允许你与组件的公共 API 进行交互。此外，使用 **@ref** 属性，你可以捕获渲染组件的引用并利用其方法和属性。但是
    **@ref** 有一个主要限制——引用仅在组件渲染完成后才会填充。由于 Blazor 的渲染过程是异步的，在组件初始化后立即尝试使用引用可能会失败，因为引用可能尚未可用。因此，你必须确保仅在组件渲染周期完成后访问绑定到
    **@ref** 的引用。
- en: In *step 6* , we implement a **SortAsync()** method, the center of our sorting
    logic. The **SortAsync()** method requires a **ColumnViewModel** object to define
    the sorting to perform. First, we determine the sorting order by checking whether
    the current sorting column label matches the one selected by the user. If they
    match, it indicates the user is trying to invert the sorting order, so we flip
    the current value of **_isAsc** . Otherwise, we set it to ascending order, as
    expected for the initial behavior. Next, we leverage a generic **Comparison**
    C# object. The **Comparison<T>** delegate represents a comparison method that
    compares two objects of the same type. We build the **comparer** delegate using
    a lambda expression that compares the **left** and **right** objects in the collection
    using the default **Comparer** . The **Comparer<T>** class provides a way to compare
    two objects and returns an integer indicating their relative order. By checking
    **_isAsc** , we can negate the comparison result to arrive easily at a descending
    order. With the **comparer** instance in place, we use the **Sort()** LINQ extension
    method on the **Data** collection to reshuffle the elements according to our logic.
    Finally, we update the current sorting column reference with the latest **column.Label**
    value and invoke the **LoadAsync()** method exposed by the **PaginatorRef** object
    to reload the dataset with the new sorting.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 6**中，我们实现了一个**SortAsync()**方法，这是我们的排序逻辑的核心。**SortAsync()**方法需要一个**ColumnViewModel**对象来定义要执行的排序。首先，我们通过检查当前排序列标签是否与用户选择的标签匹配来确定排序顺序。如果它们匹配，这表明用户试图反转排序顺序，因此我们翻转当前**_isAsc**的值。否则，我们将其设置为升序，这是预期的初始行为。接下来，我们利用一个通用的**Comparison**
    C#对象。**Comparison<T>**委托代表一个比较方法，用于比较相同类型的两个对象。我们使用一个lambda表达式构建**comparer**委托，该表达式使用默认的**Comparer**比较集合中的**left**和**right**对象。**Comparer<T>**类提供了一种比较两个对象并返回表示它们相对顺序的整数的方法。通过检查**_isAsc**，我们可以否定比较结果，从而轻松地得到降序。有了**comparer**实例，我们使用**Sort()**
    LINQ扩展方法在**Data**集合上重新排列元素，根据我们的逻辑。最后，我们使用最新的**column.Label**值更新当前排序列引用，并调用**PaginatorRef**对象公开的**LoadAsync()**方法，用新的排序重新加载数据集。
- en: In *step 7* , we jump to the **Grid** markup, locate the table header area where
    we render each table column header, and attach the **SortAsync()** method to the
    **@onclick** event handler with the current **column** reference. In *step 8*
    , we scroll down to where we constructed the **Paginator** instance and, with
    the help of the **@ref** attribute, attach the **Paginator** instance to the **PaginatorRef**
    variable we have in the code part of the component.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 7**中，我们跳转到**Grid**标记，定位到渲染每个表格列标题的表头区域，并将**SortAsync()**方法附加到带有当前**column**引用的**@onclick**事件处理器。在**步骤
    8**中，我们向下滚动到构建**Paginator**实例的位置，并借助**@ref**属性，将**Paginator**实例附加到组件代码部分中的**PaginatorRef**变量。
- en: After all the sorting enhancements, the **TicketManager** component is no longer
    compatible. In *step 9* , we move to the **TicketManager** markup and update the
    **Column** instances by declaring the **Property** delegate with a lambda expression
    for each column we render.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有排序增强之后，**TicketManager**组件不再兼容。在**步骤 9**中，我们转向**TicketManager**标记，并通过为每个渲染的列声明带有lambda表达式的**Property**委托来更新**Column**实例。
- en: Implementing infinite scrolling
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现无限滚动
- en: In user experience trends, there’s a shift from traditional pagination to a
    more dynamic and seamless infinite scrolling approach. **Virtualize** , integrated
    into the Blazor framework, was designed to enhance the user interface by loading
    content on-demand as users scroll through the page. It smartly manages resources
    by only rendering items in the viewport and fetching additional content as needed,
    significantly improving performance and user experience, especially in applications
    dealing with large datasets. By implementing infinite scrolling with the **Virtualize**
    component, you can offer a smoother, more engaging interaction pattern, eliminating
    the need for manual page navigation and making content exploration effortless.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户体验趋势中，从传统的分页方式转向了更动态和流畅的无缝滚动方式。**虚拟化**（Virtualize），集成到Blazor框架中，旨在通过在用户滚动页面时按需加载内容来增强用户界面。它通过仅渲染视口中的项目并在需要时获取额外内容来智能管理资源，显著提高了性能和用户体验，尤其是在处理大量数据集的应用程序中。通过使用**Virtualize**组件实现无限滚动，您可以提供一个更平滑、更吸引人的交互模式，消除手动页面导航的需求，使内容浏览变得轻松。
- en: Let’s construct a simple grid and implement infinite scrolling, leveraging the
    **Virtualize** component.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个简单的网格并实现无限滚动，利用 **Virtualize** 组件。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To simplify the grid itself and focus on the infinite scrolling implementation,
    we will not leverage any grid markup built in prior recipes but rather start from
    scratch. But before you dive in, do the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化网格本身并专注于无限滚动实现，我们不会利用之前食谱中内置的任何网格标记，而是从头开始。但在你深入之前，请执行以下操作：
- en: Create a **Chapter04** / **Recipe05** directory – this will be your working
    directory
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter04** / **Recipe05** 目录 – 这将是你的工作目录
- en: Copy **Samples** from the **Chapter04** / **Data** directory in the GitHub repository
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GitHub 仓库中的 **Chapter04** / **Data** 目录复制 **Samples**
- en: 'Navigate to the **Program** file of your application and register the **TicketsApi**
    service, from **Samples** , in the application dependency injection container:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到应用程序的 **Program** 文件并注册来自 **Samples** 的 **TicketsApi** 服务，在应用程序依赖注入容器中：
- en: '[PRE44]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How to do it…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to add infinite scrolling to a grid:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤向网格添加无限滚动：
- en: 'Create a generic **Grid** component using the **typeparam** attribute:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **typeparam** 属性创建一个泛型 **Grid** 组件：
- en: '[PRE45]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Inside the **@code** block of the **Grid** component, declare three required
    parameters:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Grid** 组件的 **@code** 块内部，声明三个必需的参数：
- en: '[PRE46]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The three parameters are:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 三个参数是：
- en: '**Provider** – delegate that encapsulates data fetching'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Provider** – 封装数据获取的代理'
- en: '**Header** – **RenderFragment** for the table header template'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Header** – 表格表头模板的 **RenderFragment**'
- en: '**Row** – generic **RenderFragment** for the table row template'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Row** – 表格行模板的泛型 **RenderFragment**'
- en: 'Below the parameters, implement a **LoadAsync()** method to handle dynamic
    data loading; accepting **ItemsProviderRequest** as input and returning a generic
    **ItemsProviderResult** object:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在参数下方，实现一个 **LoadAsync()** 方法来处理动态数据加载；接受 **ItemsProviderRequest** 作为输入并返回一个泛型
    **ItemsProviderResult** 对象：
- en: '[PRE47]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Move to the **Grid** component’s markup area and construct a table: embed the
    **Header** template within the **<thead>** tags and for the **<tbody>** section,
    utilize the **Virtualize** component, linking it to the **LoadAsync()** method
    via its **ItemsProvider** parameter, and pass the **Row** template as its **ChildContent**
    parameter:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到 **Grid** 组件的标记区域并构建一个表格：将 **Header** 模板嵌入到 **<thead>** 标签内，对于 **<tbody>**
    部分，使用 **Virtualize** 组件，通过其 **ItemsProvider** 参数将其链接到 **LoadAsync()** 方法，并将 **Row**
    模板作为其 **ChildContent** 参数传递：
- en: '[PRE48]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a routable **TicketManager** component. Set **TicketManager** to render
    in **InteractiveWebAssembly** mode and inject **TicketsApi** :'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个可路由的 **TicketManager** 组件。将 **TicketManager** 设置为以 **InteractiveWebAssembly**
    模式渲染并注入 **TicketsApi** :'
- en: '[PRE49]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Within the **TicketManager** markup, incorporate the newly created **Grid**
    component. Attach the **Tickets.GetAsync()** method to the **Provider** parameter
    and define the **Header** and **Row** templates for rendering **Ticket** properties
    within the grid:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **TicketManager** 标记内，包含新创建的 **Grid** 组件。将 **Tickets.GetAsync()** 方法附加到 **Provider**
    参数，并定义 **Header** 和 **Row** 模板以在网格中渲染 **Ticket** 属性：
- en: '[PRE50]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we create a generic **Grid** component that serves as the foundation
    for dynamically displaying data in a tabular format with infinite scrolling capabilities.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们创建了一个泛型 **Grid** 组件，它作为动态以无限滚动能力显示表格格式的数据的基础。
- en: In *step 2* , we declare a few required parameters within the **Grid** component.
    **Header** and **Row** , of type **RenderFragment** , enable the customization
    of the table’s header and facilitate the dynamic rendering of table rows. Additionally,
    we specify a **Provider** delegate to encapsulate the logic for fetching data.
    We intentionally designed **Provider** to match the **ItemsProvider** signature
    required by the **Virtualize** component, ensuring compatibility and seamless
    integration.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们在 **Grid** 组件内声明了一些必需的参数。**Header** 和 **Row** ，类型为 **RenderFragment**
    ，允许自定义表格的表头并简化表格行的动态渲染。此外，我们指定了一个 **Provider** 代理来封装获取数据的逻辑。我们特意设计 **Provider**
    以匹配 **Virtualize** 组件所需的 **ItemsProvider** 签名，确保兼容性和无缝集成。
- en: In *step 3* , we implement a **LoadAsync()** method that plays a pivotal role
    in fetching data in response to the user’s scroll actions. It accepts an **ItemsProviderRequest**
    parameter and returns an **ItemsProviderResult<T>** object to enable the **Virtualize**
    component continuous population of the grid as users scroll through the content.
    **ItemsProviderRequest** provides the current state of scrolling, exposing **StartIndex**
    , which defines from which index the next data batch should start. To construct
    the **ItemsProviderResult<T>** response, we need a subset of new objects to render
    and a total number of objects in the collection. The **Virtualize** component
    uses that total to safely stop data fetching and avoid throwing an indexing exception.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 中，我们实现了一个 **LoadAsync()** 方法，它在响应用户滚动操作获取数据时起着关键作用。它接受一个 **ItemsProviderRequest**
    参数，并返回一个 **ItemsProviderResult<T>** 对象，以使 **Virtualize** 组件能够连续填充网格，当用户滚动内容时。**ItemsProviderRequest**
    提供了当前滚动状态，暴露了 **StartIndex**，它定义了下一个数据批次应从哪个索引开始。为了构建 **ItemsProviderResult<T>**
    响应，我们需要渲染的新对象子集和集合中的总对象数。**Virtualize** 组件使用这个总数来安全地停止数据获取，避免抛出索引异常。
- en: In *step 4* , we set up the **Grid** markup. We add a **<table>** structure
    where we place the **Header** template within **<thead>** tags and utilize the
    **Virtualize** component within the **<tbody>** tags. By attaching the **LoadAsync()**
    method as the **ItemsProvider** parameter and including the **Row** template as
    the **Virtualize** component **ChildContent** , the grid dynamically renders additional
    rows of data, creating an infinite scrolling effect.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 4* 中，我们设置了 **Grid** 标记。我们添加了一个 **<table>** 结构，在其中我们将 **Header** 模板放置在
    **<thead>** 标签内，并在 **<tbody>** 标签内使用 **Virtualize** 组件。通过将 **LoadAsync()** 方法作为
    **ItemsProvider** 参数附加，并将 **Row** 模板作为 **Virtualize** 组件的 **ChildContent**，网格动态渲染额外的数据行，创建无限滚动效果。
- en: To demonstrate the usage of the **Grid** component, in *step 5* , we introduce
    a routable **TicketManager** component. We set **TicketManager** to render in
    **InteractiveWebAssembly** mode and inject **TicketsApi** as we will need it as
    the data source. In *step 6* , we integrate the **Grid** component into the **TicketManager**
    markup, with **Tickets.GetAsync** serving as the data provider and **Header**
    and **Row** templates specified to display the properties of the **Ticket** objects.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 **Grid** 组件的使用，在 *步骤 5* 中，我们引入了一个可路由的 **TicketManager** 组件。我们将 **TicketManager**
    设置为以 **InteractiveWebAssembly** 模式渲染，并注入 **TicketsApi**，因为我们将其作为数据源。在 *步骤 6* 中，我们将
    **Grid** 组件集成到 **TicketManager** 标记中，其中 **Tickets.GetAsync** 作为数据提供者，并指定了 **Header**
    和 **Row** 模板以显示 **Ticket** 对象的属性。
- en: There’s more…
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Utilizing the **Virtualize** component in your Blazor applications brings forth
    a multitude of benefits that enhance both performance and user experience:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Blazor 应用程序中使用 **Virtualize** 组件可以带来许多好处，这些好处既提高了性能，也改善了用户体验：
- en: Firstly, **Virtualize** dramatically improves performance and reduces memory
    usage when dealing with large datasets. This efficiency gain comes from its rendering
    approach, where only a visible subset of items is rendered at any given time,
    reducing the overall load on the browser.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，**Virtualize** 在处理大量数据集时显著提高了性能并减少了内存使用。这种效率的提高来自于其渲染方法，即在任何给定时间只渲染可见的项目子集，从而减少了浏览器上的总体负载。
- en: Secondly, the simplicity offered by **Virtualize** cannot be overstated. You
    can implement sophisticated infinite scrolling functionalities with minimal code,
    as the component abstracts the complexities of item virtualization and automatic
    event handling.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，**Virtualize** 提供的简洁性不容小觑。您可以用最少的代码实现复杂的无限滚动功能，因为该组件抽象了项目虚拟化和自动事件处理的复杂性。
- en: Lastly, **Virtualize** provides remarkable flexibility, enabling seamless integration
    with a wide array of data sources. This flexibility is especially beneficial for
    applications requiring real-time data fetching, as you can tailor the **ItemsProvider**
    delegate to suit specific data fetching logic, ensuring that applications remain
    responsive and up to date with the latest information.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，**Virtualize** 提供了卓越的灵活性，使其能够无缝集成到各种数据源中。这种灵活性对于需要实时数据获取的应用程序特别有益，因为您可以根据特定的数据获取逻辑定制
    **ItemsProvider** 委托，确保应用程序保持响应并更新到最新信息。
- en: Utilizing QuickGrid
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 QuickGrid
- en: In this recipe, we’ll explore a powerful component now embedded directly into
    the Blazor framework – **QuickGrid** . QuickGrid simplifies the creation and management
    of dynamic, data-driven grids in Blazor applications, offering out-of-the-box
    functionalities such as sorting, pagination, and filtering. This component stands
    out for its ease of implementation and high performance in presenting and manipulating
    large datasets thanks to the baked-in virtualization. QuickGrid eliminates the
    need for additional NuGet packages, streamlining development processes and reducing
    project complexity.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索现在直接嵌入到 Blazor 框架中的强大组件 – **QuickGrid**。QuickGrid 简化了在 Blazor 应用程序中创建和管理动态、数据驱动的网格，提供开箱即用的功能，如排序、分页和过滤。该组件因其易于实现和通过内置虚拟化在呈现和操作大数据集时的高性能而脱颖而出。QuickGrid
    消除了对额外 NuGet 包的需求，简化了开发过程并减少了项目复杂性。
- en: Let’s walk through the essentials of QuickGrid and showcase how simple it is
    to implement.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们浏览 QuickGrid 的基本知识，并展示其实现是多么简单。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we explore the QuickGrid implementation, do the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索 QuickGrid 的实现之前，请执行以下操作：
- en: Create a **Chapter04** / **Recipe06** directory – this will be your working
    directory
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter04** / **Recipe06** 目录 – 这将是你的工作目录
- en: Copy **Samples** from the **Chapter04** / **Data** directory in the GitHub repository
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GitHub 仓库中的 **Chapter04** / **Data** 目录复制 **Samples**
- en: 'Navigate to the **Program** file of your application and register the **TicketsApi**
    service, from **Samples** , in the application dependency injection container:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到你的应用程序的 **Program** 文件并注册来自 **Samples** 的 **TicketsApi** 服务到应用程序依赖注入容器中：
- en: '[PRE51]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How to do it…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To render a grid utilizing QuickGrid, follow these steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 QuickGrid 渲染网格，请按照以下步骤操作：
- en: 'Navigate to the **.csproj** configuration file of your project and add the
    **Microsoft.AspNetCore.Components.QuickGrid** package to your project:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的项目的 **.csproj** 配置文件，并添加 **Microsoft.AspNetCore.Components.QuickGrid**
    包到你的项目中：
- en: '[PRE52]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a new routable **TicketManager** component, with a reference to the
    **QuickGrid** package, that renders in **InteractiveWebAssembly** mode, and inject
    the **TicketApi** service:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的可路由的 **TicketManager** 组件，引用 **QuickGrid** 包，以 **InteractiveWebAssembly**
    模式渲染，并注入 **TicketApi** 服务：
- en: '[PRE53]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the **@code** block of the **TicketManager** component, introduce a **Pagination**
    variable of type **PaginationState** to configure data pagination of the **QuickGrid**
    instance:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **TicketManager** 组件的 **@code** 块中，引入一个类型为 **PaginationState** 的 **Pagination**
    变量来配置 **QuickGrid** 实例的数据分页：
- en: '[PRE54]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the **TicketManager** markup, construct the **QuickGrid** component with
    nested **PropertyColumn** components to define the data columns and integrate
    a **Paginator** component to manage data pagination:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **TicketManager** 标记中，使用嵌套的 **PropertyColumn** 组件构建 **QuickGrid** 组件以定义数据列，并集成
    **Paginator** 组件来管理数据分页：
- en: '[PRE55]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works…
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we navigate to the configuration file of the project (the one
    with a **.csproj** extension) and add the **Microsoft.AspNetCore.Components.QuickGrid**
    package into the project. QuickGrid is officially a part of the Blazor ecosystem
    but isn’t included in the Blazor project by default.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们导航到项目的配置文件（具有 **.csproj** 扩展名的文件）并将 **Microsoft.AspNetCore.Components.QuickGrid**
    包添加到项目中。QuickGrid 是 Blazor 生态系统的一部分，但默认情况下并不包含在 Blazor 项目中。
- en: In *step 2* , we create a new routable **TicketManager** component, where we
    will put **QuickGrid** to the test. As the grid will be interactive, we declare
    **TicketManager** to render in **InteractiveWebAssembly** mode. We also include
    a **using** directive, referencing the **QuickGrid** namespace. And lastly, we
    inject the **TicketsApi** service to have a data source for the grid.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们创建一个新的可路由的 **TicketManager** 组件，我们将在这里测试 **QuickGrid**。由于网格将是交互式的，我们声明
    **TicketManager** 以 **InteractiveWebAssembly** 模式渲染。我们还包含一个 **using** 指令，引用 **QuickGrid**
    命名空间。最后，我们注入 **TicketsApi** 服务以提供网格的数据源。
- en: In *step 3* , we initialize the **@code** block of the **TicketManager** component
    where we construct an instance of a **Pagination** variable and set its **ItemsPerPage**
    property. **QuickGrid** requires a **PaginationState** object to enable the pagination.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 3* 中，我们在 **TicketManager** 组件的 **@code** 块中初始化，其中我们构建一个 **Pagination**
    变量的实例并设置其 **ItemsPerPage** 属性。**QuickGrid** 需要一个 **PaginationState** 对象来启用分页。
- en: Finally, in *step 4* , we embed **QuickGrid** in the **TicketManager** markup.
    We attach the **Tickets.Get()** method and the **Pagination** object to **QuickGrid**
    ’s **Items** and **Pagination** parameters respectively. Next, we construct grid
    columns using **PropertyColumn** components. We specify properties to render with
    a delegate and enable sorting by setting the **Sortable** parameter accordingly.
    For the **Price** column, we additionally set the **Format** parameter. The **QuickGrid**
    component will automatically apply this formatting to all prices in that column.
    Lastly, we incorporate a **Paginator** component that we link to the same **Pagination**
    variable as the **QuickGrid** Instance. **Paginator** exposes the pagination UI
    to the user and executes navigation requests directly on **QuickGrid** .
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*步骤 4*中，我们将**QuickGrid**嵌入到**TicketManager**标记中。我们将**Tickets.Get()**方法和**Pagination**对象分别附加到**QuickGrid**的**Items**和**Pagination**参数上。接下来，我们使用**PropertyColumn**组件构建网格列。我们通过委托指定要渲染的属性，并通过设置**Sortable**参数来启用排序。对于**价格**列，我们还设置了**Format**参数。**QuickGrid**组件将自动将此格式应用于该列中的所有价格。最后，我们引入了一个**Paginator**组件，并将其链接到与**QuickGrid**实例相同的**Pagination**变量。**Paginator**向用户公开分页UI，并直接在**QuickGrid**上执行导航请求。
- en: 'At the end, we get a fully functional, optimized, and feature-rich grid:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到了一个功能齐全、优化良好且功能丰富的网格：
- en: '![Figure 4.2: Grid with sortable columns and pagination rendered with QuickGrid](img/B22020_04_2.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：使用QuickGrid渲染的具有可排序列和分页的网格](img/B22020_04_2.jpg)'
- en: 'Figure 4.2: Grid with sortable columns and pagination rendered with QuickGrid'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：使用QuickGrid渲染的具有可排序列和分页的网格
