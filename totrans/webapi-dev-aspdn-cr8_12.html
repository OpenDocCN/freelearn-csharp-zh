<html><head></head><body>
<div id="_idContainer094">
<h1 class="chapter-number" id="_idParaDest-251"><a id="_idTextAnchor484"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-252"><a id="_idTextAnchor485"/><span class="koboSpan" id="kobo.2.1">Getting Started with GraphQL</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In </span><a href="B18971_11.xhtml#_idTextAnchor438"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.5.1">, we explored how to create a gRPC service in ASP.NET Core. </span><span class="koboSpan" id="kobo.5.2">gRPC is a high-performance RPC framework that facilitates communication between services. </span><span class="koboSpan" id="kobo.5.3">We discussed the field types used in protobuf messages, and how to define four types of gRPC services: unary, server streaming, client streaming, and bidirectional streaming. </span><span class="koboSpan" id="kobo.5.4">Additionally, we learned how to configure gRPC services in ASP.NET Core and how to call gRPC services from a </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">client application.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Next, we will explore another shape of web APIs: GraphQL. </span><span class="koboSpan" id="kobo.7.2">GraphQL is a query-based API that allows clients to specify the data they need, which solves the problem of over-fetching and under-fetching data. </span><span class="koboSpan" id="kobo.7.3">Besides, GraphQL supports </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">mutations</span></strong><span class="koboSpan" id="kobo.9.1">, which allow clients to </span><a id="_idIndexMarker1194"/><span class="koboSpan" id="kobo.10.1">modify data. </span><span class="koboSpan" id="kobo.10.2">In this chapter, we will learn about some basic concepts of GraphQL and how to create a GraphQL API in ASP.NET Core. </span><span class="koboSpan" id="kobo.10.3">We will cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Recap </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">of GraphQL</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Setting up a GraphQL API </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">using HotChocolate</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Adding mutations</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Using variables </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">in queries</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Defining a </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">GraphQL schema</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Retrieving related objects </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">using resolvers</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Using </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">data loaders</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Dependency injection</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Interfaces and </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">union types</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Filtering, sorting, </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">and paging</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Visualizing the </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">GraphQL schema</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.32.1">After reading this chapter, you will be able to understand the basic concepts of GraphQL and how to create a GraphQL API in ASP.NET Core. </span><span class="koboSpan" id="kobo.32.2">You will also learn how to use Apollo Federation to build a microservices-based </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">GraphQL API.</span></span><a id="_idTextAnchor486"/></p>
<h1 id="_idParaDest-253"><a id="_idTextAnchor487"/><span class="koboSpan" id="kobo.34.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.35.1">The code examples in this chapter can be found at </span><a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter12"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter12</span></a><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">You can use VS 2022 or VS Code to open </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">the solutions.</span></span><a id="_idTextAnchor488"/></p>
<h1 id="_idParaDest-254"><a id="_idTextAnchor489"/><span class="koboSpan" id="kobo.39.1">Recap of GraphQL</span></h1>
<p><span class="koboSpan" id="kobo.40.1">GraphQL </span><a id="_idIndexMarker1195"/><span class="koboSpan" id="kobo.41.1">offers a flexible way to query and mutate data. </span><span class="koboSpan" id="kobo.41.2">The main difference between GraphQL and REST is that GraphQL allows clients to specify the data they need, whereas REST APIs return a fixed set of data. </span><span class="koboSpan" id="kobo.41.3">GraphQL treats data as a graph, and it uses a query language to define the shape of the data. </span><span class="koboSpan" id="kobo.41.4">This addresses the issues of over-fetching and under-fetching data by enabling clients to specify their data requirements. </span><span class="koboSpan" id="kobo.41.5">Additionally, it supports mutations, empowering clients to modify data </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">While REST APIs have multiple endpoints for different resources, GraphQL is typically served over a single endpoint, usually </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">/graphql</span></strong><span class="koboSpan" id="kobo.45.1">, which exposes a schema that describes the data. </span><span class="koboSpan" id="kobo.45.2">All queries and mutations are sent to this endpoint. </span><span class="koboSpan" id="kobo.45.3">The schema is defined using a GraphQL Schema Definition Language, which is the contract between the client and the server. </span><span class="koboSpan" id="kobo.45.4">The schema defines the types of data and the operations that can be performed on the data. </span><span class="koboSpan" id="kobo.45.5">The client can use the schema to validate the query and </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">mutation requests.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">GraphQL can solve the problem of over-fetching and under-fetching data for clients. </span><span class="koboSpan" id="kobo.47.2">However, the backend development is more complex than REST APIs. </span><span class="koboSpan" id="kobo.47.3">GraphQL uses resolvers to fetch data from different levels of the graph. </span><span class="koboSpan" id="kobo.47.4">If the implementation of the resolvers is not efficient, it can lead to performance issues. </span><span class="koboSpan" id="kobo.47.5">GraphQL also has a steep learning curve for developers who are not familiar </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">with it.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">ASP.NET Core does not have built-in support for GraphQL. </span><span class="koboSpan" id="kobo.49.2">However, several third-party libraries can be used to create </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">GraphQL APIs:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.51.1">HotChocolate</span></strong><span class="koboSpan" id="kobo.52.1">: HotChocolate is</span><a id="_idIndexMarker1196"/><span class="koboSpan" id="kobo.53.1"> an open-source GraphQL server for .NET. </span><span class="koboSpan" id="kobo.53.2">It is built on top of ASP.NET Core and supports the newest GraphQL October 2021 specification. </span><span class="koboSpan" id="kobo.53.3">It is supported by ChilliCream, a company that provides GraphQL tooling and consulting services. </span><span class="koboSpan" id="kobo.53.4">ChilliCream also provides other products, such as Banana Cake Pop, which is a GraphQL IDE to create and test GraphQL queries, and Strawberry Shake, which is a GraphQL client library for .NET. </span><span class="koboSpan" id="kobo.53.5">You can find more</span><a id="_idIndexMarker1197"/><span class="koboSpan" id="kobo.54.1"> information about HotChocolate </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">at </span></span><a href="https://chillicream.com/docs/hotchocolate/"><span class="No-Break"><span class="koboSpan" id="kobo.56.1">https://chillicream.com/docs/hotchocolate/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.57.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.58.1">GraphQL.NET</span></strong><span class="koboSpan" id="kobo.59.1">: GraphQL.NET is</span><a id="_idIndexMarker1198"/><span class="koboSpan" id="kobo.60.1"> another open-source GraphQL implementation for .NET. </span><span class="koboSpan" id="kobo.60.2">It provides a set of libraries that can be used to create GraphQL APIs and clients. </span><span class="koboSpan" id="kobo.60.3">You </span><a id="_idIndexMarker1199"/><span class="koboSpan" id="kobo.61.1">can find more information about GraphQL.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">at </span></span><a href="https://graphql-dotnet.github.io/"><span class="No-Break"><span class="koboSpan" id="kobo.63.1">https://graphql-dotnet.github.io/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.64.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.65.1">In this chapter, we will use HotChocolate to create a GraphQL API in </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">ASP.NET </span><a id="_idTextAnchor490"/><span class="koboSpan" id="kobo.67.1">Core.</span></span></p>
<h1 id="_idParaDest-255"><a id="_idTextAnchor491"/><span class="koboSpan" id="kobo.68.1">Setting up a GraphQL API using HotChocolate</span></h1>
<p><span class="koboSpan" id="kobo.69.1">To begin</span><a id="_idIndexMarker1200"/><span class="koboSpan" id="kobo.70.1"> with, you can download the code example named </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">SchoolManagement</span></strong><span class="koboSpan" id="kobo.72.1"> for this chapter from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">chapter12\start</span></strong><span class="koboSpan" id="kobo.74.1"> folder. </span><span class="koboSpan" id="kobo.74.2">This sample project has some basic code for an </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.76.1"> class and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">Teacher</span></strong><span class="koboSpan" id="kobo.78.1"> class, as well as some seed data. </span><span class="koboSpan" id="kobo.78.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">Teacher</span></strong><span class="koboSpan" id="kobo.80.1"> class has</span><a id="_idIndexMarker1201"/><span class="koboSpan" id="kobo.81.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">following properties:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.83.1">
public class Teacher{
    public Guid Id { get; set; }
    public string FirstName { get; set; } = string.Empty;
    public string LastName { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public string? </span><span class="koboSpan" id="kobo.83.2">Phone { get; set; }
    public string? </span><span class="koboSpan" id="kobo.83.3">Bio { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.84.1">You can open the project in VS Code or VS 2022. </span><span class="koboSpan" id="kobo.84.2">We will integrate </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">HotChocolate</span></strong><span class="koboSpan" id="kobo.86.1"> into the project </span><a id="_idIndexMarker1202"/><span class="koboSpan" id="kobo.87.1">to create a GraphQL API following </span><a id="_idIndexMarker1203"/><span class="No-Break"><span class="koboSpan" id="kobo.88.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.89.1">Add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">HotChocolate.AspNetCore</span></strong><span class="koboSpan" id="kobo.91.1"> NuGet package to the project. </span><span class="koboSpan" id="kobo.91.2">This package contains the ASP.NET Core integration for HotChocolate. </span><span class="koboSpan" id="kobo.91.3">It also contains the GraphQL IDE, which is a GraphQL client that can be used to create and test GraphQL queries. </span><span class="koboSpan" id="kobo.91.4">You can use the following command to add the package to </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">the project:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.93.1">dotnet add package HotChocolate.AspNetCore</span></strong></pre></li> <li><span class="koboSpan" id="kobo.94.1">Next, create a query root type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">Query</span></strong><span class="koboSpan" id="kobo.96.1">, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">GraphQL/Queries</span></strong><span class="koboSpan" id="kobo.98.1"> folder, as </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.100.1">
public class Query{    public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachers([Service] AppDbContext context) =&gt;        await context.Teachers.ToListAsync();}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.101.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">Query</span></strong><span class="koboSpan" id="kobo.103.1"> class will be used to define the queries that can be executed by the client. </span><span class="koboSpan" id="kobo.103.2">It has one method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">GetTeachers()</span></strong><span class="koboSpan" id="kobo.105.1">, which returns a list </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">of teachers.</span></span></p></li> <li><span class="koboSpan" id="kobo.107.1">Then, we need to register the query root type in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">Program.cs</span></strong><span class="koboSpan" id="kobo.109.1"> file. </span><span class="koboSpan" id="kobo.109.2">Add the following code after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">AddDbContext()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.111.1"> method:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.112.1">builder.Services</span></strong><strong class="bold"><span class="koboSpan" id="kobo.113.1">    .AddGraphQLServer()</span></strong><strong class="bold"><span class="koboSpan" id="kobo.114.1">    .AddQueryType&lt;Query&gt;();</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.115.1">The preceding code registers the GraphQL server and adds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">Query</span></strong><span class="koboSpan" id="kobo.117.1"> type to </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">the schema.</span></span></p></li> <li><span class="koboSpan" id="kobo.119.1">Next, we </span><a id="_idIndexMarker1204"/><span class="koboSpan" id="kobo.120.1">need to map the GraphQL </span><a id="_idIndexMarker1205"/><span class="koboSpan" id="kobo.121.1">endpoint to expose the GraphQL schema. </span><span class="koboSpan" id="kobo.121.2">Add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.123.1"> file:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.124.1">app.MapGraphQL();</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.125.1">The preceding code maps the GraphQL endpoint to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">graphql</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1"> URL.</span></span></p></li> <li><span class="koboSpan" id="kobo.129.1">Run the project using </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">dotnet run</span></strong><span class="koboSpan" id="kobo.131.1"> and open the GraphQL IDE at </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">https://localhost:7208/graphql/</span></strong><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">You should see the </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">following screen:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.135.1"><img alt="Figure 12.1 – The Banana Cake Pop GraphQL IDE" src="image/B18971_12_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.136.1">Figure 12.1 – The Banana Cake Pop GraphQL IDE</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.137.1">The GraphQL IDE allows you to create and test </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">GraphQL queries.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.139.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.140.1">The default launch URL is </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">swagger</span></strong><span class="koboSpan" id="kobo.142.1"> for ASP.NET Core web API projects. </span><span class="koboSpan" id="kobo.142.2">You can change the launch URL in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">launchSettings.json</span></strong><span class="koboSpan" id="kobo.144.1"> file to </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">graphql</span></strong><span class="koboSpan" id="kobo.146.1"> to open the GraphQL </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">IDE directly.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.148.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">Browse Schema</span></strong><span class="koboSpan" id="kobo.150.1"> button, then click the </span><strong class="bold"><span class="koboSpan" id="kobo.151.1">Schema Definition</span></strong><span class="koboSpan" id="kobo.152.1"> tab to view the </span><a id="_idIndexMarker1206"/><span class="koboSpan" id="kobo.153.1">GraphQL schema. </span><span class="koboSpan" id="kobo.153.2">You </span><a id="_idIndexMarker1207"/><span class="koboSpan" id="kobo.154.1">should see the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">following schema:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.156.1">
type Query {  teachers: [Teacher!]!}type Teacher {  id: UUID!  firstName: String!  lastName: String!  email: String!  phone: String  bio: String}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.157.1">The preceding schema defines a query root type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">Query</span></strong><span class="koboSpan" id="kobo.159.1">, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">Teacher</span></strong><span class="koboSpan" id="kobo.161.1"> type. </span><span class="koboSpan" id="kobo.161.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">Query</span></strong><span class="koboSpan" id="kobo.163.1"> type has one field named </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">teachers</span></strong><span class="koboSpan" id="kobo.165.1">, which returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">[Teacher!]! </span></strong><span class="koboSpan" id="kobo.167.1">object. </span><span class="koboSpan" id="kobo.167.2">GraphQL uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">!</span></strong><span class="koboSpan" id="kobo.169.1"> to indicate that the field is non-nullable. </span><span class="koboSpan" id="kobo.169.2">By default, all fields are nullable. </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">[Teacher!]!</span></strong><span class="koboSpan" id="kobo.171.1"> means that this field is a non-nullable array of non-nullable </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">Teacher</span></strong><span class="koboSpan" id="kobo.173.1"> objects. </span><span class="koboSpan" id="kobo.173.2">When there is no data, the field will return an </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">empty array.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.175.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">Teacher</span></strong><span class="koboSpan" id="kobo.177.1"> type has a few fields: </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">id</span></strong><span class="koboSpan" id="kobo.179.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">firstName</span></strong><span class="koboSpan" id="kobo.181.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">lastName</span></strong><span class="koboSpan" id="kobo.183.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">email</span></strong><span class="koboSpan" id="kobo.185.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">phone</span></strong><span class="koboSpan" id="kobo.187.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">bio</span></strong><span class="koboSpan" id="kobo.189.1">. </span><span class="koboSpan" id="kobo.189.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">id</span></strong><span class="koboSpan" id="kobo.191.1"> field is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">UUID</span></strong><span class="koboSpan" id="kobo.193.1"> type, which is a scalar type that represents </span><a id="_idIndexMarker1208"/><span class="koboSpan" id="kobo.194.1">a 128-bit </span><strong class="bold"><span class="koboSpan" id="kobo.195.1">universally unique identifier</span></strong><span class="koboSpan" id="kobo.196.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.197.1">UUID</span></strong><span class="koboSpan" id="kobo.198.1">). </span><span class="koboSpan" id="kobo.198.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">firstName</span></strong><span class="koboSpan" id="kobo.200.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">lastName</span></strong><span class="koboSpan" id="kobo.202.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">email</span></strong><span class="koboSpan" id="kobo.204.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">phone</span></strong><span class="koboSpan" id="kobo.206.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">bio</span></strong><span class="koboSpan" id="kobo.208.1"> fields are of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">String</span></strong><span class="koboSpan" id="kobo.210.1"> type. </span><span class="koboSpan" id="kobo.210.2">The client can specify which fields to be returned in </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">the query.</span></span></p></li> <li><span class="koboSpan" id="kobo.212.1">Let us try</span><a id="_idIndexMarker1209"/><span class="koboSpan" id="kobo.213.1"> to query the data. </span><span class="koboSpan" id="kobo.213.2">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">Create Document</span></strong><span class="koboSpan" id="kobo.215.1"> button to create a new query. </span><span class="koboSpan" id="kobo.215.2">You can use the following </span><a id="_idIndexMarker1210"/><span class="koboSpan" id="kobo.216.1">query to get </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">all teachers:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.218.1">
query {    teachers {        id        firstName        lastName        email        phone        bio    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.219.1">The preceding query will return all teachers in the database, </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">as follows:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.221.1"><img alt="Figure 12.2 – Querying all teachers" src="image/B18971_12_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.222.1">Figure 12.2 – Querying all teachers</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.223.1">You </span><a id="_idIndexMarker1211"/><span class="koboSpan" id="kobo.224.1">can add or remove fields in the</span><a id="_idIndexMarker1212"/><span class="koboSpan" id="kobo.225.1"> query to specify the data to be returned. </span><span class="koboSpan" id="kobo.225.2">For example, to show a list of teachers on a web page, we do not need to return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">id</span></strong><span class="koboSpan" id="kobo.227.1"> field and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">bio</span></strong><span class="koboSpan" id="kobo.229.1"> field. </span><span class="koboSpan" id="kobo.229.2">We can remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">bio</span></strong><span class="koboSpan" id="kobo.231.1"> field from the query </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.233.1">
query {    teachers {        firstName        lastName        email        phone    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.234.1">The preceding query will return those four fields only, which reduces the </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">payload size.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.236.1">So far, we have created a GraphQL API using HotChocolate. </span><span class="koboSpan" id="kobo.236.2">We have also learned how to query data using GraphQL queries. </span><span class="koboSpan" id="kobo.236.3">Next, we will learn how to modify data </span><a id="_idTextAnchor492"/><span class="No-Break"><span class="koboSpan" id="kobo.237.1">using mutations.</span></span></p>
<h1 id="_idParaDest-256"><a id="_idTextAnchor493"/><span class="koboSpan" id="kobo.238.1">Adding mutations</span></h1>
<p><span class="koboSpan" id="kobo.239.1">In the previous section, we </span><a id="_idIndexMarker1213"/><span class="koboSpan" id="kobo.240.1">learned how to create a GraphQL API using HotChocolate. </span><span class="koboSpan" id="kobo.240.2">We added a query root type to query data. </span><span class="koboSpan" id="kobo.240.3">In this section, we will discuss how to modify data </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">using mutations.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">Mutations are used to modify data in GraphQL. </span><span class="koboSpan" id="kobo.242.2">A mutation consists of </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">three parts:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.244.1">Input</span></strong><span class="koboSpan" id="kobo.245.1">: The input</span><a id="_idIndexMarker1214"/><span class="koboSpan" id="kobo.246.1"> is the data that will be used to modify the data. </span><span class="koboSpan" id="kobo.246.2">It is named with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">Input</span></strong><span class="koboSpan" id="kobo.248.1"> suffix following the convention, such </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">AddTeacherInput</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.252.1">Payload</span></strong><span class="koboSpan" id="kobo.253.1">: The </span><a id="_idIndexMarker1215"/><span class="koboSpan" id="kobo.254.1">payload is the data that will be returned after the mutation is executed. </span><span class="koboSpan" id="kobo.254.2">It is named with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">Payload</span></strong><span class="koboSpan" id="kobo.256.1"> suffix following the convention, such </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">AddTeacherPayload</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.260.1">Mutation</span></strong><span class="koboSpan" id="kobo.261.1">: The mutation is the operation that will be executed. </span><span class="koboSpan" id="kobo.261.2">It is named as </span><em class="italic"><span class="koboSpan" id="kobo.262.1">verb + noun</span></em><span class="koboSpan" id="kobo.263.1"> following the convention, such </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">AddTeacherAsync</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.267.1">Let us add a</span><a id="_idIndexMarker1216"/><span class="koboSpan" id="kobo.268.1"> mutation to create a new teacher. </span><span class="koboSpan" id="kobo.268.2">We will use the </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.270.1">Create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">AddTeacherInput</span></strong><span class="koboSpan" id="kobo.272.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">GraphQL/Mutations</span></strong><span class="koboSpan" id="kobo.274.1"> folder, as </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.276.1">
public record AddTeacherInput(    string FirstName,    string LastName,    string Email,    string? </span><span class="koboSpan" id="kobo.276.2">Phone,    string? </span><span class="koboSpan" id="kobo.276.3">Bio);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.277.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">AddTeacherInput</span></strong><span class="koboSpan" id="kobo.279.1"> class is a record type that defines the input data for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">AddTeacherAsync</span></strong><span class="koboSpan" id="kobo.281.1"> mutation. </span><span class="koboSpan" id="kobo.281.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">Id</span></strong><span class="koboSpan" id="kobo.283.1"> property is not included in the input data because it will be generated by </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">the code.</span></span></p></li> <li><span class="koboSpan" id="kobo.285.1">Add </span><a id="_idIndexMarker1217"/><span class="koboSpan" id="kobo.286.1">an </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">AddTeacherPayload</span></strong><span class="koboSpan" id="kobo.288.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">GraphQL/Mutations</span></strong><span class="koboSpan" id="kobo.290.1"> folder, </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.292.1">
public class AddTeacherPayload{    public Teacher Teacher { get; }    public AddTeacherPayload(Teacher teacher)    {        Teacher = teacher;    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.293.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">AddTeacherPayload</span></strong><span class="koboSpan" id="kobo.295.1"> class defines the data that will be returned after the mutation is executed. </span><span class="koboSpan" id="kobo.295.2">It has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">Teacher</span></strong><span class="koboSpan" id="kobo.297.1"> property of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">Teacher</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.299.1"> type.</span></span></p></li> <li><span class="koboSpan" id="kobo.300.1">Next, we need to add the actual mutation to execute the operation. </span><span class="koboSpan" id="kobo.300.2">Add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">Mutation</span></strong><span class="koboSpan" id="kobo.302.1"> class to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">GraphQL/Mutations</span></strong><span class="koboSpan" id="kobo.304.1"> folder, as </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.306.1">
public class Mutation{    public async Task&lt;AddTeacherPayload&gt; AddTeacherAsync(        AddTeacherInput input,        [Service] AppDbContext context)    {        var teacher = new Teacher        {            Id = Guid.NewGuid(),            FirstName = input.FirstName,            LastName = input.LastName,            Email = input.Email,            Phone = input.Phone,            Bio = input.Bio        };        context.Teachers.Add(teacher);        await context.SaveChangesAsync();        return new AddTeacherPayload(teacher);    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.307.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">Mutation</span></strong><span class="koboSpan" id="kobo.309.1"> class</span><a id="_idIndexMarker1218"/><span class="koboSpan" id="kobo.310.1"> has one method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">AddTeacherAsync</span></strong><span class="koboSpan" id="kobo.312.1">, which takes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">AddTeacherInput</span></strong><span class="koboSpan" id="kobo.314.1"> object as the input data and returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">AddTeacherPayload</span></strong><span class="koboSpan" id="kobo.316.1"> object. </span><span class="koboSpan" id="kobo.316.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">AddTeacherAsync()</span></strong><span class="koboSpan" id="kobo.318.1"> method creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">Teacher</span></strong><span class="koboSpan" id="kobo.320.1"> object and adds it to the database. </span><span class="koboSpan" id="kobo.320.2">Then, it returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">AddTeacherPayload</span></strong><span class="koboSpan" id="kobo.322.1"> object that contains the newly created </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">Teacher</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.324.1"> object.</span></span></p></li> <li><span class="koboSpan" id="kobo.325.1">Next, we need to register the mutation in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">Program.cs</span></strong><span class="koboSpan" id="kobo.327.1"> file. </span><span class="koboSpan" id="kobo.327.2">Add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">AddMutationType</span></strong><span class="koboSpan" id="kobo.329.1"> method after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">AddQueryType()</span></strong><span class="koboSpan" id="kobo.331.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.333.1">
builder.Services    .AddGraphQLServer()    .AddQueryType&lt;Query&gt;()    .AddMutationType&lt;Mutation&gt;();</span></pre></li> <li><span class="koboSpan" id="kobo.334.1">Run the project using </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">dotnet run</span></strong><span class="koboSpan" id="kobo.336.1"> and open the GraphQL IDE. </span><span class="koboSpan" id="kobo.336.2">Check the schema</span><a id="_idIndexMarker1219"/><span class="koboSpan" id="kobo.337.1"> definition and you should see the </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">following mutation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.339.1">
type Mutation {  addTeacher(input: AddTeacherInput!): AddTeacherPayload!}input AddTeacherInput {  firstName: String!  lastName: String!  email: String!  phone: String  bio: String}type AddTeacherPayload {  teacher: Teacher!}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.340.1">The preceding schema defines a mutation named </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">addTeacher</span></strong><span class="koboSpan" id="kobo.342.1">, which reflects the types and methods we defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">Mutation</span></strong><span class="koboSpan" id="kobo.344.1"> class. </span><span class="koboSpan" id="kobo.344.2">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">AddTeacherInput</span></strong><span class="koboSpan" id="kobo.346.1"> type is an input type, so it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">input</span></strong><span class="koboSpan" id="kobo.348.1"> keyword instead </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">type</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.352.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.353.1">Create Document</span></strong><span class="koboSpan" id="kobo.354.1"> button to create a new query. </span><span class="koboSpan" id="kobo.354.2">You can use the following mutation to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">new teacher:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.356.1">
mutation addTeacher {  addTeacher(    input: {      firstName: "John"      lastName: "Smith"      email: "john.smith@sampleschool.com"      phone: "1234567890"      bio: "John Smith is a math teacher."    }  ) {    teacher {      id    }  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.357.1">The </span><a id="_idIndexMarker1220"/><span class="koboSpan" id="kobo.358.1">preceding mutation will create a new teacher and return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">id</span></strong><span class="koboSpan" id="kobo.360.1"> property of the newly created teacher, </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">as follows:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.362.1"><img alt="Figure 12.3 – Creating a new teacher" src="image/B18971_12_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.363.1">Figure 12.3 – Creating a new teacher</span></p>
<p><span class="koboSpan" id="kobo.364.1">Then, you can </span><a id="_idIndexMarker1221"/><span class="koboSpan" id="kobo.365.1">query the data to verify that the new teacher has bee</span><a id="_idTextAnchor494"/><span class="koboSpan" id="kobo.366.1">n added to </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">the database.</span></span></p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor495"/><span class="koboSpan" id="kobo.368.1">Using variables in queries</span></h1>
<p><span class="koboSpan" id="kobo.369.1">In the</span><a id="_idIndexMarker1222"/><span class="koboSpan" id="kobo.370.1"> previous section, we learned how to query data and modify data using GraphQL queries and mutations. </span><span class="koboSpan" id="kobo.370.2">In this section, we will discuss how to use variables </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">in queries.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">GraphQL allows</span><a id="_idIndexMarker1223"/><span class="koboSpan" id="kobo.373.1"> you to use variables in queries. </span><span class="koboSpan" id="kobo.373.2">This is useful when you want to pass parameters to the query. </span><span class="koboSpan" id="kobo.373.3">We can create a query that accepts an </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">id</span></strong><span class="koboSpan" id="kobo.375.1"> parameter and returns the teacher with the specified ID. </span><span class="koboSpan" id="kobo.375.2">Follow these steps to create </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">the query:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.377.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">GetTeacher()</span></strong><span class="koboSpan" id="kobo.379.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">Query</span></strong><span class="koboSpan" id="kobo.381.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.383.1">
public async Task&lt;Teacher?&gt; GetTeacher(Guid id, [Service] AppDbContext context) =&gt;    await context.Teachers.FindAsync(id);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.384.1">The preceding code adds a </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">GetTeacher()</span></strong><span class="koboSpan" id="kobo.386.1"> method to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">Query</span></strong><span class="koboSpan" id="kobo.388.1"> class. </span><span class="koboSpan" id="kobo.388.2">It takes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">id</span></strong><span class="koboSpan" id="kobo.390.1"> parameter and returns the teacher with the </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">specified ID.</span></span></p></li> <li><span class="koboSpan" id="kobo.392.1">Now, you </span><a id="_idIndexMarker1224"/><span class="koboSpan" id="kobo.393.1">can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">$</span></strong><span class="koboSpan" id="kobo.395.1"> sign to define a variable in the query. </span><span class="koboSpan" id="kobo.395.2">For example, you can use the following query to get a teacher </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">by ID:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.397.1">
query getTeacher($id: UUID!) {  teacher(id: $id) {    id    firstName    lastName    email    phone  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.398.1">The</span><a id="_idIndexMarker1225"/><span class="koboSpan" id="kobo.399.1"> preceding query defines a variable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">id</span></strong><span class="koboSpan" id="kobo.401.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">UUID!</span></strong><span class="koboSpan" id="kobo.403.1"> type. </span><span class="koboSpan" id="kobo.403.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">!</span></strong><span class="koboSpan" id="kobo.405.1"> sign indicates that the variable is non-nullable. </span><span class="koboSpan" id="kobo.405.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">teacher</span></strong><span class="koboSpan" id="kobo.407.1"> field takes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">id</span></strong><span class="koboSpan" id="kobo.409.1"> variable as the parameter and returns the teacher with the specified ID. </span><span class="koboSpan" id="kobo.409.2">In the </span><strong class="bold"><span class="koboSpan" id="kobo.410.1">GraphQL Variables</span></strong><span class="koboSpan" id="kobo.411.1"> panel, you can define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">id</span></strong><span class="koboSpan" id="kobo.413.1"> variable to pass the value to the query, </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.415.1">{  "id": "00000000-0000-0000-0000-000000000401"}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.416.1">You can define multiple variables in the query. </span><span class="koboSpan" id="kobo.416.2">Note that variables must be scalars, e</span><a id="_idTextAnchor496"/><span class="koboSpan" id="kobo.417.1">nums, or input </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">object types.</span></span></p>
<h1 id="_idParaDest-258"><a id="_idTextAnchor497"/><span class="koboSpan" id="kobo.419.1">Defining a GraphQL schema</span></h1>
<p><span class="koboSpan" id="kobo.420.1">Usually, a </span><a id="_idIndexMarker1226"/><span class="koboSpan" id="kobo.421.1">system has multiple types of data. </span><span class="koboSpan" id="kobo.421.2">For example, a school management system has teachers, students, departments, and courses. </span><span class="koboSpan" id="kobo.421.3">A department has multiple courses, and a course has multiple students. </span><span class="koboSpan" id="kobo.421.4">A teacher can teach multiple courses, and a course can be taught by multiple teachers as well. </span><span class="koboSpan" id="kobo.421.5">In this section, we will discuss how to define a GraphQL schema</span><a id="_idTextAnchor498"/><span class="koboSpan" id="kobo.422.1"> with multiple types </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">of data.</span></span></p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor499"/><span class="koboSpan" id="kobo.424.1">Scalar types</span></h2>
<p><span class="koboSpan" id="kobo.425.1">Scalar types </span><a id="_idIndexMarker1227"/><span class="koboSpan" id="kobo.426.1">are</span><a id="_idIndexMarker1228"/><span class="koboSpan" id="kobo.427.1"> the primitive types in GraphQL. </span><span class="koboSpan" id="kobo.427.2">The following table lists the scalar types </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">in GraphQL:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-9">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.429.1">Scalar type</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.430.1">Description</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.431.1">.</span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.432.1">NET type</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">Int</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.434.1">Signed </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">32-bit integer</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">int</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">Float</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.438.1">Signed double-precision floating-point value specified in </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">IEEE 754</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">float</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.441.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">double</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">String</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.444.1">UTF‐8 </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">character sequence</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">string</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">Boolean</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">true</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.449.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">false</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">bool</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">ID</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.453.1">A unique identifier, serialized as </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">a string</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">string</span></strong></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.456.1">Table 12.1 – Scalar types in GraphQL</span></p>
<p><span class="koboSpan" id="kobo.457.1">Besides the preceding scalar types, </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">HotChocolate</span></strong><span class="koboSpan" id="kobo.459.1"> also supports the following </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">scalar types:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">Byte</span></strong><span class="koboSpan" id="kobo.462.1">: Unsigned </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">8-bit integer</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">ByteArray</span></strong><span class="koboSpan" id="kobo.465.1">: Byte array that is encoded as a </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">Base64 string</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">Short</span></strong><span class="koboSpan" id="kobo.468.1">: Signed </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">16-bit integer</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">Long</span></strong><span class="koboSpan" id="kobo.471.1">: Signed </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">64-bit integer</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">Decimal</span></strong><span class="koboSpan" id="kobo.474.1">: Signed </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">decimal value</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">Date</span></strong><span class="koboSpan" id="kobo.477.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">ISO-8601 date</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">TimeSpan</span></strong><span class="koboSpan" id="kobo.480.1">: ISO-8601 </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">time duration</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">DateTime</span></strong><span class="koboSpan" id="kobo.483.1">: A custom GraphQL scalar defined by the community at </span><a href="https://www.graphql-scalars.com/"><span class="koboSpan" id="kobo.484.1">https://www.graphql-scalars.com/</span></a><span class="koboSpan" id="kobo.485.1">. </span><span class="koboSpan" id="kobo.485.2">It is based on RFC3339. </span><span class="koboSpan" id="kobo.485.3">Note that this </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">DateTime</span></strong><span class="koboSpan" id="kobo.487.1"> scalar uses an offset to UTC instead of a </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">time zone</span></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">Url</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">: URL</span></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">Uuid</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">: GUID</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">Any</span></strong><span class="koboSpan" id="kobo.494.1">: A special type that is used to represent any literal or </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">output type</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.496.1">There are</span><a id="_idIndexMarker1229"/><span class="koboSpan" id="kobo.497.1"> more </span><a id="_idIndexMarker1230"/><span class="koboSpan" id="kobo.498.1">scalar types that are not listed here. </span><span class="koboSpan" id="kobo.498.2">You can find more information about the scalar types </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">at </span></span><a href="https://chillicream.com/docs/hotchocolate/v13/defining-a-schema/scalars"><span class="No-Break"><span class="koboSpan" id="kobo.500.1">https://chillicream.com/docs/hotchocolate/v13/defining-a-schema/scalars</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.501.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.502.1">GraphQL supports enumerations as well. </span><span class="koboSpan" id="kobo.502.2">Enumeration types in GraphQL are a special kind of scalar type. </span><span class="koboSpan" id="kobo.502.3">They are used to represent a fixed set of values. </span><span class="koboSpan" id="kobo.502.4">.NET supports enumeratiopn types very well so that you can use the .NET </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">enum</span></strong><span class="koboSpan" id="kobo.504.1"> type directly in GraphQL. </span><span class="koboSpan" id="kobo.504.2">You can define an enumeration type </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.506.1">
public enum CourseType{
    Core,
    Elective,
    Lab
}</span></pre>
<p><span class="koboSpan" id="kobo.507.1">The preceding code defines an enumeration type named </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">CourseType</span></strong><span class="koboSpan" id="kobo.509.1"> with three values: </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">Core</span></strong><span class="koboSpan" id="kobo.511.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">Elective</span></strong><span class="koboSpan" id="kobo.513.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">Lab</span></strong><span class="koboSpan" id="kobo.515.1">. </span><span class="koboSpan" id="kobo.515.2">The generated GraphQL schema is </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
enum CourseType {  CORE
  ELECTIVE
  LAB
}</span></pre>
<p><span class="koboSpan" id="kobo.518.1">HotChocolate </span><a id="_idIndexMarker1231"/><span class="koboSpan" id="kobo.519.1">automatically converts the enumeration values to uppercase according to the </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">GraphQL specificatio</span><a id="_idTextAnchor500"/><span class="koboSpan" id="kobo.521.1">n.</span></span></p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor501"/><span class="koboSpan" id="kobo.522.1">Object types</span></h2>
<p><span class="koboSpan" id="kobo.523.1">The</span><a id="_idIndexMarker1232"/><span class="koboSpan" id="kobo.524.1"> object type is the most common type in GraphQL. </span><span class="koboSpan" id="kobo.524.2">It </span><a id="_idIndexMarker1233"/><span class="koboSpan" id="kobo.525.1">can contain simple scalar types such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">Int</span></strong><span class="koboSpan" id="kobo.527.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">String</span></strong><span class="koboSpan" id="kobo.529.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">Boolean</span></strong><span class="koboSpan" id="kobo.531.1">, as well as other object types. </span><span class="koboSpan" id="kobo.531.2">For example, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">Teacher</span></strong><span class="koboSpan" id="kobo.533.1"> type can contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">Department</span></strong><span class="koboSpan" id="kobo.535.1"> type, as </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.537.1">
public class Teacher{
    public Guid Id { get; set; }
    public string FirstName { get; set; } = string.Empty;
    public string LastName { get; set; } = string.Empty;
    public Guid DepartmentId { get; set; }
    public Department Department { get; set; } = default!;
}
public class Department
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? </span><span class="koboSpan" id="kobo.537.2">Description { get; set; }
    // other properties
}</span></pre>
<p><span class="koboSpan" id="kobo.538.1">The preceding code defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">Teacher</span></strong><span class="koboSpan" id="kobo.540.1"> type and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">Department</span></strong><span class="koboSpan" id="kobo.542.1"> type. </span><span class="koboSpan" id="kobo.542.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">Teacher</span></strong><span class="koboSpan" id="kobo.544.1"> type has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">Department</span></strong><span class="koboSpan" id="kobo.546.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">Department</span></strong><span class="koboSpan" id="kobo.548.1"> type. </span><span class="koboSpan" id="kobo.548.2">HotChocolate will generate </span><a id="_idIndexMarker1234"/><span class="koboSpan" id="kobo.549.1">the schema </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.551.1">
type Teacher {  id: UUID!
</span><span class="koboSpan" id="kobo.551.2">  firstName: String!
</span><span class="koboSpan" id="kobo.551.3">  lastName: String!
</span><span class="koboSpan" id="kobo.551.4">  departmentId: UUID!
</span><span class="koboSpan" id="kobo.551.5">  department: Department!
</span><span class="koboSpan" id="kobo.551.6">}
type Department {
  id: UUID!
</span><span class="koboSpan" id="kobo.551.7">  name: String!
</span><span class="koboSpan" id="kobo.551.8">  description: String
}</span></pre>
<p><span class="koboSpan" id="kobo.552.1">As we </span><a id="_idIndexMarker1235"/><span class="koboSpan" id="kobo.553.1">mentioned in the previous section, all the fields in GraphQL are nullable by default. </span><span class="koboSpan" id="kobo.553.2">If we want to make a field non-nullable, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">!</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.555.1">sign.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">The object type can contain a list of other object types. </span><span class="koboSpan" id="kobo.556.2">For example, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">Department</span></strong><span class="koboSpan" id="kobo.558.1"> type can contain a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">Teacher</span></strong><span class="koboSpan" id="kobo.560.1"> objects, as </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.562.1">
public class Department{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? </span><span class="koboSpan" id="kobo.562.2">Description { get; set; }
    public List&lt;Teacher&gt; Teachers { get; set; } = new();
}</span></pre>
<p><span class="koboSpan" id="kobo.563.1">The generated schema is </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.565.1">
type Department {  id: UUID!
</span><span class="koboSpan" id="kobo.565.2">  name: String!
</span><span class="koboSpan" id="kobo.565.3">  description: String
  teachers: [Teacher!]!
</span><span class="koboSpan" id="kobo.565.4">}</span></pre>
<p><span class="koboSpan" id="kobo.566.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">teachers</span></strong><span class="koboSpan" id="kobo.568.1"> field</span><a id="_idIndexMarker1236"/><span class="koboSpan" id="kobo.569.1"> is a non-nullable array of non-nullable </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">Teacher</span></strong><span class="koboSpan" id="kobo.571.1"> objects. </span><span class="koboSpan" id="kobo.571.2">If we want to make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">teachers</span></strong><span class="koboSpan" id="kobo.573.1"> field nullable, we can </span><a id="_idIndexMarker1237"/><span class="koboSpan" id="kobo.574.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">?</span></strong><span class="koboSpan" id="kobo.576.1"> sign </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.578.1">
public class Department{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? </span><span class="koboSpan" id="kobo.578.2">Description { get; set; }
    public List&lt;Teacher&gt;? </span><span class="koboSpan" id="kobo.578.3">Teachers { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.579.1">The generated schema is </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
type Department {  id: UUID!
</span><span class="koboSpan" id="kobo.581.2">  name: String!
</span><span class="koboSpan" id="kobo.581.3">  description: String
  teachers: [Teacher!]
}</span></pre>
<p><span class="koboSpan" id="kobo.582.1">The preceding schema means that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">teachers</span></strong><span class="koboSpan" id="kobo.584.1"> field is a nullable array of non-nullable </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">Teacher</span></strong><span class="koboSpan" id="kobo.586.1"> objects. </span><span class="koboSpan" id="kobo.586.2">When there is no data, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">teachers</span></strong><span class="koboSpan" id="kobo.588.1"> field will </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.592.1">Let's look</span><a id="_idIndexMarker1238"/><span class="koboSpan" id="kobo.593.1"> back at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">Query</span></strong><span class="koboSpan" id="kobo.595.1"> type and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">Mutation</span></strong><span class="koboSpan" id="kobo.597.1"> type we defined in the </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">previous sections:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.599.1">
type Query {  teachers: [Teacher!]!
</span><span class="koboSpan" id="kobo.599.2">  teacher(id: UUID!): Teacher
}
type Mutation {
  addTeacher(input: AddTeacherInput!): AddTeacherPayload!
</span><span class="koboSpan" id="kobo.599.3">}</span></pre>
<p><span class="koboSpan" id="kobo.600.1">These</span><a id="_idIndexMarker1239"/><span class="koboSpan" id="kobo.601.1"> two types look like regular object types, but they have special meanings in GraphQL. </span><span class="koboSpan" id="kobo.601.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">Query</span></strong><span class="koboSpan" id="kobo.603.1"> type and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">Mutation</span></strong><span class="koboSpan" id="kobo.605.1"> type are two special object types in GraphQL, as they define the entry points of the GraphQL API. </span><span class="koboSpan" id="kobo.605.2">Every GraphQL service must have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">Query</span></strong><span class="koboSpan" id="kobo.607.1"> type, but may or may not have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">Mutation</span></strong><span class="koboSpan" id="kobo.609.1"> type. </span><span class="koboSpan" id="kobo.609.2">So the </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">teachers</span></strong><span class="koboSpan" id="kobo.611.1"> query is actually a field of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">Query</span></strong><span class="koboSpan" id="kobo.613.1"> type, just like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">department</span></strong><span class="koboSpan" id="kobo.615.1"> field in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">teacher</span></strong><span class="koboSpan" id="kobo.617.1"> type. </span><span class="koboSpan" id="kobo.617.2">Mutations work in the </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">same way.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">So far, the GraphQL types are similar to C# types. </span><span class="koboSpan" id="kobo.619.2">If you are familiar with object-oriented programming, you should be able to understand the GraphQL types easily. </span><span class="koboSpan" id="kobo.619.3">Similar to C#, GraphQL supports interfaces as well. </span><span class="koboSpan" id="kobo.619.4">But before we delve into interfaces, Let's discuss how to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">Department</span></strong><span class="koboSpan" id="kobo.621.1"> object when querying the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">Teach</span><a id="_idTextAnchor502"/><span class="koboSpan" id="kobo.623.1">er</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.624.1"> object.</span></span></p>
<h1 id="_idParaDest-261"><a id="_idTextAnchor503"/><span class="koboSpan" id="kobo.625.1">Retrieving related objects using resolvers</span></h1>
<p><span class="koboSpan" id="kobo.626.1">In the </span><a id="_idIndexMarker1240"/><span class="koboSpan" id="kobo.627.1">previous section, we defined a </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">Teacher</span></strong><span class="koboSpan" id="kobo.629.1"> type and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">Department</span></strong><span class="koboSpan" id="kobo.631.1"> type. </span><span class="koboSpan" id="kobo.631.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">Teacher</span></strong><span class="koboSpan" id="kobo.633.1"> type has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">Department</span></strong><span class="koboSpan" id="kobo.635.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">Department</span></strong><span class="koboSpan" id="kobo.637.1"> type. </span><span class="koboSpan" id="kobo.637.2">When querying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">Teacher</span></strong><span class="koboSpan" id="kobo.639.1"> object, we may also want to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">Department</span></strong><span class="koboSpan" id="kobo.641.1"> object. </span><span class="koboSpan" id="kobo.641.2">How can we </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">do that?</span></span></p>
<p><span class="koboSpan" id="kobo.643.1">You may think that we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">Include()</span></strong><span class="koboSpan" id="kobo.645.1"> method to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">Department</span></strong><span class="koboSpan" id="kobo.647.1"> object, </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.649.1">
public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachers([Service] AppDbContext context) =&gt;    await context.Teachers.Include(x =&gt; x.Department).ToListAsync();</span></pre>
<p><span class="koboSpan" id="kobo.650.1">Then, you can </span><a id="_idIndexMarker1241"/><span class="koboSpan" id="kobo.651.1">query the </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">Department</span></strong><span class="koboSpan" id="kobo.653.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.655.1">
query{  teachers{
    id
    firstName
    lastName
    department{
      id
      name
      description
    }
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.656.1">It does work and you will see the </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">following result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.658.1">
{  "data": {
    "teachers": [
      {
        "id": "00000000-0000-0000-0000-000000000401",
        "firstName": "John",
        "lastName": "Doe",
        "department": {
          "id": "00000000-0000-0000-0000-000000000001",
          "name": "Mathematics",
          "description": "Mathematics Department"
        }
      },
      {
        "id": "00000000-0000-0000-0000-000000000402",
        "firstName": "Jane",
        "lastName": "Doe",
        "department": {
          "id": "00000000-0000-0000-0000-000000000001",
          "name": "Mathematics",
          "description": "Mathematics Department"
        }
      }
    ]
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.659.1">But this is not </span><a id="_idIndexMarker1242"/><span class="koboSpan" id="kobo.660.1">the best way to do it. </span><span class="koboSpan" id="kobo.660.2">Remember that GraphQL allows clients to specify the data they need. </span><span class="koboSpan" id="kobo.660.3">If the query does not specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">department</span></strong><span class="koboSpan" id="kobo.662.1"> field, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">Department</span></strong><span class="koboSpan" id="kobo.664.1"> object will still be retrieved from the database. </span><span class="koboSpan" id="kobo.664.2">This is not efficient. </span><span class="koboSpan" id="kobo.664.3">We should only retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">Department</span></strong><span class="koboSpan" id="kobo.666.1"> object when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">department</span></strong><span class="koboSpan" id="kobo.668.1"> field is specified in the query. </span><span class="koboSpan" id="kobo.668.2">That leads us to the concept </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">of resolvers.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">A resolver is a function that is used to retrieve data from somewhere for a specific field. </span><span class="koboSpan" id="kobo.670.2">The resolver is</span><a id="_idIndexMarker1243"/><span class="koboSpan" id="kobo.671.1"> executed when the field is requested in the query. </span><span class="koboSpan" id="kobo.671.2">The resolver can fetch data from a database, a web API, or any other data source. </span><span class="koboSpan" id="kobo.671.3">It will drill down the graph to retrieve the data for the field. </span><span class="koboSpan" id="kobo.671.4">For example, when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">department</span></strong><span class="koboSpan" id="kobo.673.1"> field is requested in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">teachers</span></strong><span class="koboSpan" id="kobo.675.1"> query, the resolver will retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">Department</span></strong><span class="koboSpan" id="kobo.677.1"> object from the database. </span><span class="koboSpan" id="kobo.677.2">But when the query does not specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">department</span></strong><span class="koboSpan" id="kobo.679.1"> field, the resolver will not be executed. </span><span class="koboSpan" id="kobo.679.2">This can avoid unnecessary </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">dat</span><a id="_idTextAnchor504"/><span class="koboSpan" id="kobo.681.1">abase queries.</span></span></p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor505"/><span class="koboSpan" id="kobo.682.1">Field resolvers</span></h2>
<p><span class="koboSpan" id="kobo.683.1">HotChocolate supports</span><a id="_idIndexMarker1244"/><span class="koboSpan" id="kobo.684.1"> three ways to </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">define schemas:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.686.1">Annotation-based</span></strong><span class="koboSpan" id="kobo.687.1">: The first way is to use the annotation-based approach, which is what we</span><a id="_idIndexMarker1245"/><span class="koboSpan" id="kobo.688.1"> have been using so far. </span><span class="koboSpan" id="kobo.688.2">HotChocolate automatically converts public properties and methods to a resolver that retrieves data from the data source following conventions. </span><span class="koboSpan" id="kobo.688.3">If a method has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">Get</span></strong><span class="koboSpan" id="kobo.690.1"> prefix or an </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">Async</span></strong><span class="koboSpan" id="kobo.692.1"> suffix, these prefixes or suffixes will be removed from </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">the name.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.694.1">Code-first</span></strong><span class="koboSpan" id="kobo.695.1">: This </span><a id="_idIndexMarker1246"/><span class="koboSpan" id="kobo.696.1">approach allows you to define the schema using explicit types and resolvers. </span><span class="koboSpan" id="kobo.696.2">It uses the Fluent API to define the details of the schema. </span><span class="koboSpan" id="kobo.696.3">This approach is more flexible when you need to customize </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">the schema.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.698.1">Schema-first</span></strong><span class="koboSpan" id="kobo.699.1">: This </span><a id="_idIndexMarker1247"/><span class="koboSpan" id="kobo.700.1">approach allows you to define the schema using the GraphQL schema definition language. </span><span class="koboSpan" id="kobo.700.2">If you are familiar with GraphQL, you can use this approach to define the </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">schema directly.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.702.1">As you, our </span><a id="_idIndexMarker1248"/><span class="koboSpan" id="kobo.703.1">readers, are mostly .NET developers, we will use the code-first approach to define the schema in the rest of this chapter, so we can benefit from the Fluent API to fine-tune </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">the schema.</span></span></p>
<p><span class="koboSpan" id="kobo.705.1">Let us look back at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">teacher</span></strong><span class="koboSpan" id="kobo.707.1"> query we defined in the </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">previous section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.709.1">
public async Task&lt;Teacher?&gt; GetTeacher(Guid id, [Service] AppDbContext context) =&gt;   await context.Teachers.FindAsync(id);</span></pre>
<p><span class="koboSpan" id="kobo.710.1">The preceding is the annotation-based approach. </span><span class="koboSpan" id="kobo.710.2">HotChocolate automatically converts the </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">GetTeacher()</span></strong><span class="koboSpan" id="kobo.712.1"> method to a resolver named </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">teacher</span></strong><span class="koboSpan" id="kobo.714.1">. </span><span class="koboSpan" id="kobo.714.2">Next, we want to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">Department</span></strong><span class="koboSpan" id="kobo.716.1"> object when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">department</span></strong><span class="koboSpan" id="kobo.718.1"> field is requested. </span><span class="koboSpan" id="kobo.718.2">Let us make some changes by following </span><a id="_idIndexMarker1249"/><span class="No-Break"><span class="koboSpan" id="kobo.719.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.720.1">First, we need to define </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">TeacherType</span></strong><span class="koboSpan" id="kobo.722.1"> class as a GraphQL object. </span><span class="koboSpan" id="kobo.722.2">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">TeacherType</span></strong><span class="koboSpan" id="kobo.724.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">Types</span></strong><span class="koboSpan" id="kobo.726.1"> folder. </span><span class="koboSpan" id="kobo.726.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.728.1">
public class TeacherType : ObjectType&lt;Teacher&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;Teacher&gt; descriptor)    {        descriptor.Field(x =&gt; x.Department)            .Name("department")            .Description("This is the department to which the teacher belongs.")            .Resolve(async context =&gt;            {                var department = await context.Service&lt;AppDbContext&gt;().Departments.FindAsync(context.   Parent&lt;Teacher&gt;().DepartmentId);                return department;            });    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.729.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">TeacherType</span></strong><span class="koboSpan" id="kobo.731.1"> class inherits from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">ObjectType&lt;Teacher&gt;</span></strong><span class="koboSpan" id="kobo.733.1"> class, which </span><a id="_idIndexMarker1250"/><span class="koboSpan" id="kobo.734.1">has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">Configure()</span></strong><span class="koboSpan" id="kobo.736.1"> method to configure the GraphQL object and specify how to resolve the fields. </span><span class="koboSpan" id="kobo.736.2">In the preceding code, we use the code-first approach to define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">Department</span></strong><span class="koboSpan" id="kobo.738.1"> field of </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">TeacherType</span></strong><span class="koboSpan" id="kobo.740.1">. </span><span class="koboSpan" id="kobo.740.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">Name</span></strong><span class="koboSpan" id="kobo.742.1"> method is used to specify the name of the field. </span><span class="koboSpan" id="kobo.742.2">If the name of the field is the same as the name of the property following the convention, we can omit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">Name</span></strong><span class="koboSpan" id="kobo.744.1"> method. </span><span class="koboSpan" id="kobo.744.2">By convention, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">Department</span></strong><span class="koboSpan" id="kobo.746.1"> field will be converted to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">department</span></strong><span class="koboSpan" id="kobo.748.1"> field in the schema. </span><span class="koboSpan" id="kobo.748.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">Description</span></strong><span class="koboSpan" id="kobo.750.1"> method to define the description of the field. </span><span class="koboSpan" id="kobo.750.2">The description will be shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">GraphQL IDE.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.752.1">Then, we</span><a id="_idIndexMarker1251"/><span class="koboSpan" id="kobo.753.1"> use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">Resolve()</span></strong><span class="koboSpan" id="kobo.755.1"> method to define the resolver. </span><span class="koboSpan" id="kobo.755.2">The</span><a id="_idIndexMarker1252"/><span class="koboSpan" id="kobo.756.1"> resolver retrieves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">Department</span></strong><span class="koboSpan" id="kobo.758.1"> object from the database using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">DepartmentId</span></strong><span class="koboSpan" id="kobo.760.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">Teacher</span></strong><span class="koboSpan" id="kobo.762.1"> object. </span><span class="koboSpan" id="kobo.762.2">Note that we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">context.Parent&lt;Teacher&gt;()</span></strong><span class="koboSpan" id="kobo.764.1"> method to get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">Teacher</span></strong><span class="koboSpan" id="kobo.766.1"> object because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">Teacher</span></strong><span class="koboSpan" id="kobo.768.1"> object is the parent object of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">Department</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.770.1"> object.</span></span></p></li> <li><span class="koboSpan" id="kobo.771.1">As we know the </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">Query</span></strong><span class="koboSpan" id="kobo.773.1"> type is a special object type, we will create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">QueryType</span></strong><span class="koboSpan" id="kobo.775.1"> class as well. </span><span class="koboSpan" id="kobo.775.2">Create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">Types</span></strong><span class="koboSpan" id="kobo.777.1"> folder in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">GraphQL</span></strong><span class="koboSpan" id="kobo.779.1"> folder and move the </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">Query.cs</span></strong><span class="koboSpan" id="kobo.781.1"> file to this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">Types</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.783.1"> folder.</span></span></li>
<li><span class="koboSpan" id="kobo.784.1">Remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">GetTeacher()</span></strong><span class="koboSpan" id="kobo.786.1"> method and add a property </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.788.1">
public class Query{    // Omitted for brevity    public TeacherType? </span><span class="koboSpan" id="kobo.788.2">Teacher { get; set; } = new();}</span></pre></li> <li><span class="koboSpan" id="kobo.789.1">Create a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">QueryType</span></strong><span class="koboSpan" id="kobo.791.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.793.1">
public class QueryType : ObjectType&lt;Query&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;Query&gt; descriptor)    {        descriptor.Field(x =&gt; x.Teacher)            .Name("teacher")            .Description("This is the teacher in the school.")            .Type&lt;TeacherType&gt;()            .Argument("id", a =&gt; a.Type&lt;NonNullType&lt;UuidType&gt;&gt;())            .Resolve(async context =&gt;            {                var id = context.ArgumentValue&lt;Guid&gt;("id");                var teacher = await context.Service&lt;AppDbContext&gt;().Teachers.FindAsync(id);                return teacher;            });    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.794.1">The </span><a id="_idIndexMarker1253"/><span class="koboSpan" id="kobo.795.1">preceding code defines the root query type. </span><span class="koboSpan" id="kobo.795.2">In this </span><a id="_idIndexMarker1254"/><span class="koboSpan" id="kobo.796.1">query type, we specify the type of the field to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">TeacherType</span></strong><span class="koboSpan" id="kobo.798.1">. </span><span class="koboSpan" id="kobo.798.2">Next, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">Argument()</span></strong><span class="koboSpan" id="kobo.800.1"> method to define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">id</span></strong><span class="koboSpan" id="kobo.802.1"> argument, which is a non-nullable </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">UUID</span></strong><span class="koboSpan" id="kobo.804.1"> type. </span><span class="koboSpan" id="kobo.804.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">Resolve()</span></strong><span class="koboSpan" id="kobo.806.1"> method to define the resolver. </span><span class="koboSpan" id="kobo.806.2">The resolver takes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">id</span></strong><span class="koboSpan" id="kobo.808.1"> argument and retrieves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">Teacher</span></strong><span class="koboSpan" id="kobo.810.1"> object from the database. </span><span class="koboSpan" id="kobo.810.2">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.812.1"> is injected into the resolver from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">context</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.814.1"> object.</span></span></p></li> <li><span class="koboSpan" id="kobo.815.1">Next, we need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">Program.cs</span></strong><span class="koboSpan" id="kobo.817.1"> file to register </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">QueryType</span></strong><span class="koboSpan" id="kobo.819.1">. </span><span class="koboSpan" id="kobo.819.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">Program.cs</span></strong><span class="koboSpan" id="kobo.821.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.823.1">
builder.Services    .AddGraphQLServer()    .AddQueryType&lt;QueryType&gt;()    .AddMutationType&lt;Mutation&gt;();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.824.1">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">QueryType</span></strong><span class="koboSpan" id="kobo.826.1"> to replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">Query</span></strong><span class="koboSpan" id="kobo.828.1"> type we defined previously so that we can use the resolver to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">Department</span></strong><span class="koboSpan" id="kobo.830.1"> object when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">department</span></strong><span class="koboSpan" id="kobo.832.1"> field </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">is requested.</span></span></p></li> <li><span class="koboSpan" id="kobo.834.1">Now, we </span><a id="_idIndexMarker1255"/><span class="koboSpan" id="kobo.835.1">can test the resolvers. </span><span class="koboSpan" id="kobo.835.2">Run the application</span><a id="_idIndexMarker1256"/><span class="koboSpan" id="kobo.836.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">dotnet run</span></strong><span class="koboSpan" id="kobo.838.1"> and send the following request to query </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">a teacher.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.840.1">This is the </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">GraphQL request:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.842.1">
query ($id: UUID!) {  teacher(id: $id) {    firstName    lastName    email    department {      name      description    }  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.843.1">These are the </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">GraphQL variables:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.845.1">{  "id": "00000000-0000-0000-0000-000000000401"}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.846.1">You will see the department information in the response. </span><span class="koboSpan" id="kobo.846.2">Also, if you check the log, you will see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">Department</span></strong><span class="koboSpan" id="kobo.848.1"> object is retrieved from the database. </span><span class="koboSpan" id="kobo.848.2">If you remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">department</span></strong><span class="koboSpan" id="kobo.850.1"> field from the query, you will only see one database query in the log, which means that GraphQL does not fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">Department</span></strong><span class="koboSpan" id="kobo.852.1"> object from </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">the database.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.854.1">In this example, we </span><a id="_idIndexMarker1257"/><span class="koboSpan" id="kobo.855.1">defined a resolver using a delegate method. </span><span class="koboSpan" id="kobo.855.2">We can also</span><a id="_idIndexMarker1258"/><span class="koboSpan" id="kobo.856.1"> define a resolver in a separate class. </span><span class="koboSpan" id="kobo.856.2">For example, we can define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">TeacherResolver</span></strong><span class="koboSpan" id="kobo.858.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.860.1">
public class TeacherResolvers{
    public async Task&lt;Department&gt; GetDepartment([Parent] Teacher teacher, [Service] IDbContextFactory&lt;AppDbContext&gt; dbContextFactory)
    {
        await using var dbContext = await dbContextFactory.CreateDbContextAsync();
        var department = await dbContext.Departments.FindAsync(teacher.DepartmentId);
        return department;
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.861.1">The preceding code defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">GetDepartment()</span></strong><span class="koboSpan" id="kobo.863.1"> method that takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">Teacher</span></strong><span class="koboSpan" id="kobo.865.1"> object as the parent object and returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">Department</span></strong><span class="koboSpan" id="kobo.867.1"> object. </span><span class="koboSpan" id="kobo.867.2">Then, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">ResolveWith</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">()</span></strong><span class="koboSpan" id="kobo.870.1"> method to define the resolver in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">TeacherType</span></strong><span class="koboSpan" id="kobo.872.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.874.1">
descriptor.Field(x =&gt; x.Department)    .Description("This is the department to which the teacher belongs.")
    .ResolveWith&lt;TeacherResolvers&gt;(x =&gt; x.GetDepartment(default, default));</span></pre>
<p><span class="koboSpan" id="kobo.875.1">Now, the logic of the resolver is moved to a separate class. </span><span class="koboSpan" id="kobo.875.2">This approach is more flexible when the resolver is complex. </span><span class="koboSpan" id="kobo.875.3">But for simple resolvers, we can use the delegate </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">method directly.</span></span></p>
<p><span class="koboSpan" id="kobo.877.1">So far, it works well. </span><span class="koboSpan" id="kobo.877.2">Let us try to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">GetTeachers</span></strong><span class="koboSpan" id="kobo.879.1"> method using the same </span><a id="_idTextAnchor506"/><span class="koboSpan" id="kobo.880.1">approach in the </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">next section.</span></span></p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor507"/><span class="koboSpan" id="kobo.882.1">Resolver for a list of objects</span></h2>
<p><span class="koboSpan" id="kobo.883.1">Similarly, we</span><a id="_idIndexMarker1259"/><span class="koboSpan" id="kobo.884.1"> can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">ListType&lt;TeacherType&gt;</span></strong><span class="koboSpan" id="kobo.886.1"> to define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">teachers</span></strong><span class="koboSpan" id="kobo.888.1"> field and then use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">Resolve()</span></strong><span class="koboSpan" id="kobo.890.1"> method to define the resolver. </span><span class="koboSpan" id="kobo.890.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">ListType</span></strong><span class="koboSpan" id="kobo.892.1"> class is a wrapper type for the fluent code-first API. </span><span class="koboSpan" id="kobo.892.2">It is used to define a list of objects. </span><span class="koboSpan" id="kobo.892.3">Remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">GetTeachers()</span></strong><span class="koboSpan" id="kobo.894.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">Query</span></strong><span class="koboSpan" id="kobo.896.1"> class and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">Teachers</span></strong><span class="koboSpan" id="kobo.898.1"> field, as </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.900.1">
public class Query{
    // Omitted for brevity
    public List&lt;TeacherType&gt; Teachers { get; set; } = new();
}</span></pre>
<p><span class="koboSpan" id="kobo.901.1">Then, configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">Teachers</span></strong><span class="koboSpan" id="kobo.903.1"> field in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">QueryType</span></strong><span class="koboSpan" id="kobo.905.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.907.1">
public class QueryType : ObjectType&lt;Query&gt;{
    protected override void Configure(IObjectTypeDescriptor&lt;Query&gt; descriptor)
    {
        descriptor.Field(x =&gt; x.Teachers)
            .Name("teachers") // This configuration can be omitted if the name of the field is the same as the name of the property.
</span><span class="koboSpan" id="kobo.907.2">            .Description("This is the list of teachers in the school.")
            .Type&lt;ListType&lt;TeacherType&gt;&gt;()
            .Resolve(async context =&gt;
            {
                var teachers = await context.Service&lt;AppDbContext&gt;().Teachers.ToListAsync();
                return teachers;
            });
        // Omitted for brevity
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.908.1">The </span><a id="_idIndexMarker1260"/><span class="koboSpan" id="kobo.909.1">preceding code defines the </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">Teachers</span></strong><span class="koboSpan" id="kobo.911.1"> field of </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">QueryType</span></strong><span class="koboSpan" id="kobo.913.1">. </span><span class="koboSpan" id="kobo.913.2">It uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">ListType&lt;TeacherType&gt;</span></strong><span class="koboSpan" id="kobo.915.1"> to define a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">TeacherType</span></strong><span class="koboSpan" id="kobo.917.1">. </span><span class="koboSpan" id="kobo.917.2">Then, it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">Resolve()</span></strong><span class="koboSpan" id="kobo.919.1"> method to define the resolver. </span><span class="koboSpan" id="kobo.919.2">The resolver retrieves all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">Teacher</span></strong><span class="koboSpan" id="kobo.921.1"> objects from the database. </span><span class="koboSpan" id="kobo.921.2">This code is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">teacher</span></strong><span class="koboSpan" id="kobo.923.1"> field we defined previously. </span><span class="koboSpan" id="kobo.923.2">However, it retrieves a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">TeacherType</span></strong><span class="koboSpan" id="kobo.925.1"> objects instead of a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">TeacherType</span></strong><span class="koboSpan" id="kobo.927.1"> object. </span><span class="koboSpan" id="kobo.927.2">As </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">TeacherType</span></strong><span class="koboSpan" id="kobo.929.1"> has a resolver for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">Department</span></strong><span class="koboSpan" id="kobo.931.1"> field, we can retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">Department</span></strong><span class="koboSpan" id="kobo.933.1"> object for each </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">TeacherType</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.935.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.936.1">Now, we can test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">teachers</span></strong><span class="koboSpan" id="kobo.938.1"> field using the </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">following query:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.940.1">
query{  teachers{
    id
    firstName
    lastName
    department{
      id
      name
      description
    }
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.941.1">However, you may encounter an error in the response. </span><span class="koboSpan" id="kobo.941.2">Some teachers can be retrieved correctly, but </span><a id="_idIndexMarker1261"/><span class="koboSpan" id="kobo.942.1">some may not. </span><span class="koboSpan" id="kobo.942.2">The error message is </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.944.1">
{  "errors": [
    {
      "message": "Unexpected Execution Error",
      "locations": [
        {
          "line": 6,
          "column": 5
        }
      ],
      "path": [
        "teachers",
        7,
        "department"
      ],
      "extensions": {
        "message": "A second operation was started on this context instance before a previous operation completed. </span><span class="koboSpan" id="kobo.944.2">This is usually caused by different threads concurrently using the same instance of DbContext. </span><span class="koboSpan" id="kobo.944.3">For more information on how to avoid threading issues with DbContext, see https://go.microsoft.com/fwlink/?linkid=2097913.",
        ...
</span><span class="koboSpan" id="kobo.944.4">      }
    },
  ]
}</span></pre>
<p><span class="koboSpan" id="kobo.945.1">This is because we have multiple resolvers that execute database queries concurrently. </span><span class="koboSpan" id="kobo.945.2">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.947.1"> is registered as a scoped service, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.949.1"> class is not thread-safe. </span><span class="koboSpan" id="kobo.949.2">When multiple resolvers try to query the database in parallel, they will use the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.951.1"> instance, which causes </span><span class="No-Break"><span class="koboSpan" id="kobo.952.1">the error.</span></span></p>
<p><span class="koboSpan" id="kobo.953.1">To fix this issue, we </span><a id="_idIndexMarker1262"/><span class="koboSpan" id="kobo.954.1">need to make sure that the resolvers do not access the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.956.1"> instance concurrently. </span><span class="koboSpan" id="kobo.956.2">There are two ways to do that. </span><span class="koboSpan" id="kobo.956.3">One is to execute the resolvers sequentially, and the other is to use separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.958.1"> instances for each resolver. </span><span class="koboSpan" id="kobo.958.2">HotChocolate provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">RegisterDbContext&lt;TDbContext&gt;()</span></strong><span class="koboSpan" id="kobo.960.1"> method to manage </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">DbContext</span></strong><span class="koboSpan" id="kobo.962.1"> for resolvers. </span><span class="koboSpan" id="kobo.962.2">In order to use this feature, we need to install a NuGet package named </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">HotChocolate.Data.EntityFramework</span></strong><span class="koboSpan" id="kobo.964.1"> using the </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">following command:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.966.1">dotnet add package HotChocolate.Data.EntityFramework</span></strong></pre> <p><span class="koboSpan" id="kobo.967.1">Then, we can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">Program.cs</span></strong><span class="koboSpan" id="kobo.969.1"> file to register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.971.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.973.1">
builder.Services    .AddGraphQLServer()
    .RegisterDbContext&lt;AppDbContext&gt;()
    // Omitted for brevity</span></pre>
<p><span class="koboSpan" id="kobo.974.1">The preceding code allows HotChocolate to manage the lifetime of </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">AppDbContext</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.976.1">for resolvers.</span></span></p>
<p><span class="koboSpan" id="kobo.977.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">RegisterDbContext&lt;TDbContext&gt;()</span></strong><span class="koboSpan" id="kobo.979.1"> method can specify how </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">DbContext</span></strong><span class="koboSpan" id="kobo.981.1"> should be injected. </span><span class="koboSpan" id="kobo.981.2">There are </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">three options:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">DbContextKind.Synchronized</span></strong><span class="koboSpan" id="kobo.984.1">: This is to ensure that </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">DbContext</span></strong><span class="koboSpan" id="kobo.986.1"> is never used concurrently. </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">DbContext</span></strong><span class="koboSpan" id="kobo.988.1"> is still injected as a </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">scoped service.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">DbContextKind.Resolver</span></strong><span class="koboSpan" id="kobo.991.1">: This way will resolve the scoped </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">DbContext</span></strong><span class="koboSpan" id="kobo.993.1"> for each resolver. </span><span class="koboSpan" id="kobo.993.2">This option is the default configuration. </span><span class="koboSpan" id="kobo.993.3">From the perspective of the resolver, </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">DbContext</span></strong><span class="koboSpan" id="kobo.995.1"> is a transient service, so HotChocolate can execute multiple resolvers concurrently without </span><span class="No-Break"><span class="koboSpan" id="kobo.996.1">any issues.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">DbContextKind.Pooled</span></strong><span class="koboSpan" id="kobo.998.1">: This mechanism will create a pool of </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">DbContext</span></strong><span class="koboSpan" id="kobo.1000.1"> instances. </span><span class="koboSpan" id="kobo.1000.2">It leverages the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">DbContextPool</span></strong><span class="koboSpan" id="kobo.1002.1"> feature of EF Core. </span><span class="koboSpan" id="kobo.1002.2">HotChocolate will resolve </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">DbContext</span></strong><span class="koboSpan" id="kobo.1004.1"> from the pool for each resolver. </span><span class="koboSpan" id="kobo.1004.2">When the resolver is completed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">DbContext</span></strong><span class="koboSpan" id="kobo.1006.1"> will be returned to the pool. </span><span class="koboSpan" id="kobo.1006.2">In this way, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">DbContext</span></strong><span class="koboSpan" id="kobo.1008.1"> is also like a transient service for each resolver, so HotChocolate can parallelize the resolvers </span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">as well.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1010.1">To demonstrate </span><a id="_idIndexMarker1263"/><span class="koboSpan" id="kobo.1011.1">how to benefit from the pooled </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">DbContext</span></strong><span class="koboSpan" id="kobo.1013.1">, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">DbContextKind.Pooled</span></strong><span class="koboSpan" id="kobo.1015.1"> option. </span><span class="koboSpan" id="kobo.1015.2">This approach requires a couple of </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">additional steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1017.1">First, we need to register </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">DbContext</span></strong><span class="koboSpan" id="kobo.1019.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">AddPooledDbContextFactory()</span></strong><span class="koboSpan" id="kobo.1021.1"> method instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">AddDbContext()</span></strong><span class="koboSpan" id="kobo.1023.1"> method. </span><span class="koboSpan" id="kobo.1023.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1025.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1027.1">
builder.Services.AddPooledDbContextFactory&lt;AppDbContext&gt;(options =&gt;    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));// Register the GraphQL servicesbuilder.Services    .AddGraphQLServer()    .RegisterDbContext&lt;AppDbContext&gt;(DbContextKind.Pooled)    // Omitted for brevity</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1028.1">The preceding code registers </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.1030.1"> as a pooled service using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">AddPooledDbContextFactory()</span></strong><span class="koboSpan" id="kobo.1032.1"> method. </span><span class="koboSpan" id="kobo.1032.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">RegisterDbContext()</span></strong><span class="koboSpan" id="kobo.1034.1"> method to register </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.1036.1"> as a pooled service for </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">HotChocolate resolvers.</span></span></p></li> <li><span class="koboSpan" id="kobo.1038.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">Configure()</span></strong><span class="koboSpan" id="kobo.1040.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">QueryType</span></strong><span class="koboSpan" id="kobo.1042.1"> file to use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">pooled </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">DbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1046.1">
descriptor.Field(x =&gt; x.Teachers)    // Omitted for brevity    .Type&lt;ListType&lt;TeacherType&gt;&gt;()    .Resolve(async context =&gt;    {        var dbContextFactory = context.Service&lt;IDbContextFactory&lt;AppDbContext&gt;&gt;();        await using var dbContext = await dbContextFactory.CreateDbContextAsync();        var teachers = await dbContext.Teachers.ToListAsync();        return teachers;    });</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1047.1">The </span><a id="_idIndexMarker1264"/><span class="koboSpan" id="kobo.1048.1">preceding code uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">IDbContextFactory&lt;TDbContext&gt;</span></strong><span class="koboSpan" id="kobo.1050.1"> to create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.1052.1"> instance for each resolver. </span><span class="koboSpan" id="kobo.1052.2">Then, it retrieves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">Teacher</span></strong><span class="koboSpan" id="kobo.1054.1"> objects from the database using the new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">AppDbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1056.1"> instance.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.1057.1">One thing to note is that we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">await using</span></strong><span class="koboSpan" id="kobo.1059.1"> statement to dispose of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.1061.1"> instance after the resolver is completed in order to return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.1063.1"> instance to </span><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">the pool.</span></span></p></li> <li><span class="koboSpan" id="kobo.1065.1">Update the other resolvers as well. </span><span class="koboSpan" id="kobo.1065.2">For example, the resolver of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">Teacher</span></strong><span class="koboSpan" id="kobo.1067.1"> type looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1068.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1069.1">
descriptor.Field(x =&gt; x.Department)    .Description("This is the department to which the teacher belongs.")    .Resolve(async context =&gt;    {        var dbContextFactory = context.Service&lt;IDbContextFactory&lt;AppDbContext&gt;&gt;();        await using var dbContext = await dbContextFactory.CreateDbContextAsync();        var department = await dbContext.Departments            .FindAsync(context.Parent&lt;Teacher&gt;().DepartmentId);        return department;    });</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1070.1">Now, we</span><a id="_idIndexMarker1265"/><span class="koboSpan" id="kobo.1071.1"> can test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">teachers</span></strong><span class="koboSpan" id="kobo.1073.1"> field again. </span><span class="koboSpan" id="kobo.1073.2">You will see that all the teachers with the department information can be </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">retrieved correctly.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.1075.1">So, everything looks good. </span><span class="koboSpan" id="kobo.1075.2">But wait. </span><span class="koboSpan" id="kobo.1075.3">If you check the logs, you will find that there are many database queries for each </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">Department</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1077.1"> object:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.1078.1"><img alt="Figure 12.4 – Database queries for each Department object" src="image/B18971_12_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1079.1">Figure 12.4 – Database queries for each Department object</span></p>
<p><span class="koboSpan" id="kobo.1080.1">What is the reason behind this? </span><span class="koboSpan" id="kobo.1080.2">L</span><a id="_idTextAnchor508"/><span class="koboSpan" id="kobo.1081.1">et us </span><a id="_idIndexMarker1266"/><span class="koboSpan" id="kobo.1082.1">find out in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1">next section.</span></span></p>
<h1 id="_idParaDest-264"><a id="_idTextAnchor509"/><span class="koboSpan" id="kobo.1084.1">Using data loaders</span></h1>
<p><span class="koboSpan" id="kobo.1085.1">In the </span><a id="_idIndexMarker1267"/><span class="koboSpan" id="kobo.1086.1">previous section, we learned how to integrate HotChocolate with EF Core. </span><span class="koboSpan" id="kobo.1086.2">We also learned how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">DbContextPool</span></strong><span class="koboSpan" id="kobo.1088.1"> feature to fetch data in multiple resolvers. </span><span class="koboSpan" id="kobo.1088.2">However, we found that there are many database queries for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">Department</span></strong><span class="koboSpan" id="kobo.1090.1"> object in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">Teacher</span></strong><span class="koboSpan" id="kobo.1092.1"> list. </span><span class="koboSpan" id="kobo.1092.2">That is because the resolvers for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">Department</span></strong><span class="koboSpan" id="kobo.1094.1"> object are executed separately, querying the database by each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">DepartmentId</span></strong><span class="koboSpan" id="kobo.1096.1"> property in the list. </span><span class="koboSpan" id="kobo.1096.2">This is similar to the </span><em class="italic"><span class="koboSpan" id="kobo.1097.1">N+1</span></em><span class="koboSpan" id="kobo.1098.1"> problem we discussed in </span><a href="B18971_01.xhtml#_idTextAnchor012"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1099.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.1100.1">. </span><span class="koboSpan" id="kobo.1100.2">The difference is that the </span><em class="italic"><span class="koboSpan" id="kobo.1101.1">N+1</span></em><span class="koboSpan" id="kobo.1102.1"> problem occurs on the client side in REST APIs, while it occurs on the server side in GraphQL. </span><span class="koboSpan" id="kobo.1102.2">To solve this problem, we need to find a way to load the batch </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">data efficiently.</span></span></p>
<p><span class="koboSpan" id="kobo.1104.1">HotChocolate provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">DataLoader</span></strong><span class="koboSpan" id="kobo.1106.1"> mechanism to solve the </span><em class="italic"><span class="koboSpan" id="kobo.1107.1">N+1</span></em><span class="koboSpan" id="kobo.1108.1"> problem. </span><span class="koboSpan" id="kobo.1108.2">The data loader fetches data in batches from the data source. </span><span class="koboSpan" id="kobo.1108.3">Then, the resolver can retrieve the data from the data loader, rather than querying the data source directly. </span><span class="koboSpan" id="kobo.1108.4">The data loader will cache the data for the current request. </span><span class="koboSpan" id="kobo.1108.5">If the same data is requested again, the resolver can retrieve the data from the data loader directly. </span><span class="koboSpan" id="kobo.1108.6">This can avoid unnecessary </span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">database queries.</span></span></p>
<p><span class="koboSpan" id="kobo.1110.1">Before we learn how to use the data loader to solve the </span><em class="italic"><span class="koboSpan" id="kobo.1111.1">N+1</span></em><span class="koboSpan" id="kobo.1112.1"> problem, let's prepare the examples. </span><span class="koboSpan" id="kobo.1112.2">We already have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">Teachers</span></strong><span class="koboSpan" id="kobo.1114.1"> query to query the list of teachers, and each teacher has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">Department</span></strong><span class="koboSpan" id="kobo.1116.1"> object. </span><span class="koboSpan" id="kobo.1116.2">Now, we want to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">Departments</span></strong><span class="koboSpan" id="kobo.1118.1"> query to query the </span><a id="_idIndexMarker1268"/><span class="koboSpan" id="kobo.1119.1">list of departments, and each department has a list of teachers. </span><span class="koboSpan" id="kobo.1119.2">We will use the following steps to add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">Departments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1"> query:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1122.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">Department</span></strong><span class="koboSpan" id="kobo.1124.1"> type is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1126.1">
public class Department{    public Guid Id { get; set; }    public string Name { get; set; } = string.Empty;    public string? </span><span class="koboSpan" id="kobo.1126.2">Description { get; set; }    public List&lt;Teacher&gt; Teachers { get; set; } = new();}</span></pre></li> <li><span class="koboSpan" id="kobo.1127.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">Department</span></strong><span class="koboSpan" id="kobo.1129.1"> class has a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">Teacher</span></strong><span class="koboSpan" id="kobo.1131.1"> objects. </span><span class="koboSpan" id="kobo.1131.2">Following the convention, we can define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">DepartmentType</span></strong><span class="koboSpan" id="kobo.1133.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1135.1">
public class DepartmentType : ObjectType&lt;Department&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;Department&gt; descriptor)    {        descriptor.Field(x =&gt; x.Teachers)            .Description("This is the list of teachers in the department.")            .Type&lt;ListType&lt;TeacherType&gt;&gt;()            .ResolveWith&lt;DepartmentResolvers&gt;(x =&gt; x.GetTeachers(default, default));    }}public class DepartmentResolvers{    public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachers([Parent] Department department,        [Service] IDbContextFactory&lt;AppDbContext&gt; dbContextFactory)    {        await using var dbContext = await dbContextFactory.CreateDbContextAsync();        var teachers = await dbContext.Teachers.Where(x =&gt; x.DepartmentId == department.Id).ToListAsync();        return teachers;    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1136.1">The </span><a id="_idIndexMarker1269"/><span class="koboSpan" id="kobo.1137.1">preceding code is similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">TeacherType</span></strong><span class="koboSpan" id="kobo.1139.1">, which we defined previously. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">DepartmentType</span></strong><span class="koboSpan" id="kobo.1141.1"> has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">Teachers</span></strong><span class="koboSpan" id="kobo.1143.1"> field of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1144.1">ListType&lt;TeacherType&gt;</span></strong><span class="koboSpan" id="kobo.1145.1"> type. </span><span class="koboSpan" id="kobo.1145.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">ResolveWith()</span></strong><span class="koboSpan" id="kobo.1147.1"> method to define the resolver. </span><span class="koboSpan" id="kobo.1147.2">The resolver retrieves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">Teacher</span></strong><span class="koboSpan" id="kobo.1149.1"> objects from the database using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">DepartmentId</span></strong><span class="koboSpan" id="kobo.1151.1"> property of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">Department</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1153.1"> object.</span></span></p></li> <li><span class="koboSpan" id="kobo.1154.1">Add a new field in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">Query</span></strong><span class="koboSpan" id="kobo.1156.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.1157.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1158.1">
public class Query{    // Omitted for brevity    public List&lt;DepartmentType&gt; Departments { get; set; } = new();}</span></pre></li> <li><span class="koboSpan" id="kobo.1159.1">Then, configure </span><a id="_idIndexMarker1270"/><span class="koboSpan" id="kobo.1160.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">Departments</span></strong><span class="koboSpan" id="kobo.1162.1"> field in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">QueryType</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1164.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1165.1">
descriptor.Field(x =&gt; x.Departments)    .Description("This is the list of departments in the school.")    .Type&lt;ListType&lt;DepartmentType&gt;&gt;()    .Resolve(async context =&gt;    {        var dbContextFactory = context.Service&lt;IDbContextFactory&lt;AppDbContext&gt;&gt;();        await using var dbContext = await dbContextFactory.CreateDbContextAsync();        var departments = await dbContext.Departments.ToListAsync();        return departments;    });</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1166.1">Now we have two queries – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">teachers</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1168.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">departments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">:</span></span></p><ul><li><span class="koboSpan" id="kobo.1171.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">teachers</span></strong><span class="koboSpan" id="kobo.1173.1"> query returns a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">Teacher</span></strong><span class="koboSpan" id="kobo.1175.1"> objects, and each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">Teacher</span></strong><span class="koboSpan" id="kobo.1177.1"> object has a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">Department</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1"> object</span></span></li><li><span class="koboSpan" id="kobo.1180.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">departments</span></strong><span class="koboSpan" id="kobo.1182.1"> query returns a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">Department</span></strong><span class="koboSpan" id="kobo.1184.1"> objects, and each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">Department</span></strong><span class="koboSpan" id="kobo.1186.1"> object has a list of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">Teacher</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1188.1"> objects</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.1189.1">You can use the following queries to test the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">departments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1191.1"> query:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1192.1">query{   departments{    id    name    description    teachers{      id      firstName      lastName      bio    }   }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1193.1">If you </span><a id="_idIndexMarker1271"/><span class="koboSpan" id="kobo.1194.1">check the logs, you will find that the following database queries are executed </span><span class="No-Break"><span class="koboSpan" id="kobo.1195.1">multiple times:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1196.1">info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (3ms) [Parameters=[@__department_Id_0='?' </span><span class="koboSpan" id="kobo.1196.2">(DbType = Guid)], CommandType='Text', CommandTimeout='30']      SELECT [t].[Id], [t].[Bio], [t].[DepartmentId], [t].[Email], [t].[FirstName], [t].[LastName], [t].[Phone]      FROM [Teachers] AS [t]      WHERE [t].[DepartmentId] = @__department_Id_0</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1197.1">The preceding query is executed for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">Department</span></strong><span class="koboSpan" id="kobo.1199.1"> object. </span><span class="koboSpan" id="kobo.1199.2">This is also an </span><em class="italic"><span class="koboSpan" id="kobo.1200.1">N+1</span></em><span class="koboSpan" id="kobo.1201.1"> problem, as we discussed previously. </span><span class="koboSpan" id="kobo.1201.2">Next, we will use the</span><a id="_idTextAnchor510"/><span class="koboSpan" id="kobo.1202.1"> data loader to solve these </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1203.1">N+1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1204.1"> problems.</span></span></p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor511"/><span class="koboSpan" id="kobo.1205.1">Batch data loader</span></h2>
<p><span class="koboSpan" id="kobo.1206.1">First, let's </span><a id="_idIndexMarker1272"/><span class="koboSpan" id="kobo.1207.1">optimize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">teachers</span></strong><span class="koboSpan" id="kobo.1209.1"> query. </span><span class="koboSpan" id="kobo.1209.2">To retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">teachers</span></strong><span class="koboSpan" id="kobo.1211.1"> data with the department information, we want to execute two SQL queries only. </span><span class="koboSpan" id="kobo.1211.2">One is to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">teachers</span></strong><span class="koboSpan" id="kobo.1213.1"> data, and the other is to retrieve the department data. </span><span class="koboSpan" id="kobo.1213.2">Then, HotChocolate should be able to map the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">department </span></strong><span class="koboSpan" id="kobo.1215.1">data to the teachers in memory, instead of executing a SQL query for </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">each teacher.</span></span></p>
<p><span class="koboSpan" id="kobo.1217.1">Follow these steps to use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">data loader:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1219.1">Create a folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1220.1">DataLoaders</span></strong><span class="koboSpan" id="kobo.1221.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">GraphQL</span></strong><span class="koboSpan" id="kobo.1223.1"> folder, then create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1224.1">DepartmentByTeacherIdBatchDataLoader</span></strong><span class="koboSpan" id="kobo.1225.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.1226.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1227.1">
public class DepartmentByTeacherIdBatchDataLoader(       IDbContextFactory&lt;AppDbContext&gt; dbContextFactory,       IBatchScheduler batchScheduler,       DataLoaderOptions? </span><span class="koboSpan" id="kobo.1227.2">options = null)       : BatchDataLoader&lt;Guid, Department&gt;(batchScheduler, options){    protected override async Task&lt;IReadOnlyDictionary&lt;Guid, Department&gt;&gt; LoadBatchAsync(IReadOnlyList&lt;Guid&gt;    keys,        CancellationToken cancellationToken)    {        await using var dbContext = await dbContextFactory.CreateDbContextAsync(cancellationToken);        var departments = await dbContext.Departments.Where(x =&gt; keys.Contains(x.Id))            .ToDictionaryAsync(x =&gt; x.Id, cancellationToken);        return departments;    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1228.1">The preceding code defines a data loader to fetch the batch data for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1229.1">Department</span></strong><span class="koboSpan" id="kobo.1230.1"> object. </span><span class="koboSpan" id="kobo.1230.2">The parent resolver, which is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1231.1">teachers</span></strong><span class="koboSpan" id="kobo.1232.1"> query, will get a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">Teacher</span></strong><span class="koboSpan" id="kobo.1234.1"> objects. </span><span class="koboSpan" id="kobo.1234.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">Teacher</span></strong><span class="koboSpan" id="kobo.1236.1"> object has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">DepartmentId</span></strong><span class="koboSpan" id="kobo.1238.1"> property. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1239.1">DepartmentByTeacherIdBatchDataLoader</span></strong><span class="koboSpan" id="kobo.1240.1"> will fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">Department</span></strong><span class="koboSpan" id="kobo.1242.1"> objects for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">DepartmentId</span></strong><span class="koboSpan" id="kobo.1244.1"> values in the list. </span><span class="koboSpan" id="kobo.1244.2">The list of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">Department</span></strong><span class="koboSpan" id="kobo.1246.1"> objects will be converted to a dictionary. </span><span class="koboSpan" id="kobo.1246.2">The key of the dictionary is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">DepartmentId</span></strong><span class="koboSpan" id="kobo.1248.1"> property and the value is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">Department</span></strong><span class="koboSpan" id="kobo.1250.1"> object. </span><span class="koboSpan" id="kobo.1250.2">Then, the parent resolver can map the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">Department</span></strong><span class="koboSpan" id="kobo.1252.1"> object to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">Teacher</span></strong><span class="koboSpan" id="kobo.1254.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">in memory.</span></span></p></li> <li><span class="koboSpan" id="kobo.1256.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">TeacherResolvers</span></strong><span class="koboSpan" id="kobo.1258.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.1259.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1260.1">
public class TeacherResolvers{    public async Task&lt;Department&gt; GetDepartment([Parent] Teacher teacher,        DepartmentByTeacherIdBatchDataLoader departmentByTeacherIdBatchDataLoader, CancellationToken cancellationToken)    {        var department = await departmentByTeacherIdBatchDataLoader.LoadAsync(teacher.DepartmentId,    cancellationToken);        return department;    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1261.1">Instead of querying the database directly, the resolver uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">DepartmentByTeacherIdBatchDataLoader</span></strong><span class="koboSpan" id="kobo.1263.1"> to fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">Department</span></strong><span class="koboSpan" id="kobo.1265.1"> object for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">DepartmentId</span></strong><span class="koboSpan" id="kobo.1267.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">Teacher</span></strong><span class="koboSpan" id="kobo.1269.1"> object. </span><span class="koboSpan" id="kobo.1269.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">DepartmentByTeacherIdBatchDataLoader</span></strong><span class="koboSpan" id="kobo.1271.1"> will be injected by </span><span class="No-Break"><span class="koboSpan" id="kobo.1272.1">HotChocolate automatically.</span></span></p></li> <li><span class="koboSpan" id="kobo.1273.1">Run the </span><a id="_idIndexMarker1273"/><span class="koboSpan" id="kobo.1274.1">application and test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">teachers</span></strong><span class="koboSpan" id="kobo.1276.1"> query </span><a id="_idIndexMarker1274"/><span class="koboSpan" id="kobo.1277.1">again. </span><span class="koboSpan" id="kobo.1277.2">Now, you will see only two SQL queries </span><span class="No-Break"><span class="koboSpan" id="kobo.1278.1">are executed:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1279.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (108ms) [Parameters=[], CommandType='Text', CommandTimeout='30']      SELECT [t].[Id], [t].[Bio], [t].[DepartmentId], [t].[Email], [t].[FirstName], [t].[LastName], [t].   [Phone]      FROM [Teachers] AS [t]info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (73ms) [Parameters=[@__keys_0='?' </span><span class="koboSpan" id="kobo.1279.2">(Size = 4000)], CommandType='Text',    CommandTimeout='30']      SELECT [d].[Id], [d].[Description], [d].[Name]      FROM [Departments] AS [d]      WHERE [d].[Id] IN (          SELECT [k].[value]          FROM OPENJSON(@__keys_0) WITH ([value] uniqueidentifier '$') AS [k]      )</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1280.1">As we see, the first query is to get the list of the teachers, and the second query is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">IN</span></strong><span class="koboSpan" id="kobo.1282.1"> clause </span><a id="_idIndexMarker1275"/><span class="koboSpan" id="kobo.1283.1">to query the departments that match the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1284.1">DepartmentId</span></strong><span class="koboSpan" id="kobo.1285.1"> values in the list. </span><span class="koboSpan" id="kobo.1285.2">This is much more efficient than the </span><span class="No-Break"><span class="koboSpan" id="kobo.1286.1">previous approach.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.1287.1">As it fetches</span><a id="_idIndexMarker1276"/><span class="koboSpan" id="kobo.1288.1"> the batch data for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">Department</span></strong><span class="koboSpan" id="kobo.1290.1"> object, it is</span><a id="_idIndexMarker1277"/><span class="koboSpan" id="kobo.1291.1"> called a batch data loader. </span><span class="koboSpan" id="kobo.1291.2">This data loader is often used for one-to-one relationships, such as one </span><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">Teacher</span></strong><span class="koboSpan" id="kobo.1293.1"> object has one </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">Department</span></strong><span class="koboSpan" id="kobo.1295.1"> object. </span><span class="koboSpan" id="kobo.1295.2">Note that this one-to-one relationship is not the same as the one-to-one relationship in the database. </span><span class="koboSpan" id="kobo.1295.3">In GraphQL, the one-to-one relations</span><a id="_idTextAnchor512"/><span class="koboSpan" id="kobo.1296.1">hip means that one object has one </span><span class="No-Break"><span class="koboSpan" id="kobo.1297.1">child object.</span></span></p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor513"/><span class="koboSpan" id="kobo.1298.1">Group data loader</span></h2>
<p><span class="koboSpan" id="kobo.1299.1">Next, let's </span><a id="_idIndexMarker1278"/><span class="koboSpan" id="kobo.1300.1">optimize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">departments</span></strong><span class="koboSpan" id="kobo.1302.1"> query. </span><span class="koboSpan" id="kobo.1302.2">In this case, one </span><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">Department</span></strong><span class="koboSpan" id="kobo.1304.1"> object has a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">Teacher</span></strong><span class="koboSpan" id="kobo.1306.1"> objects. </span><span class="koboSpan" id="kobo.1306.2">We can use the group data loader</span><a id="_idIndexMarker1279"/><span class="koboSpan" id="kobo.1307.1"> to fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">Teacher</span></strong><span class="koboSpan" id="kobo.1309.1"> objects for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1310.1">Department</span></strong><span class="koboSpan" id="kobo.1311.1"> object. </span><span class="koboSpan" id="kobo.1311.2">The group data loader is similar to the batch data loader. </span><span class="koboSpan" id="kobo.1311.3">The difference is that the group data loader fetches a list of objects for each key. </span><span class="koboSpan" id="kobo.1311.4">The batch data loader fetches a single object for </span><span class="No-Break"><span class="koboSpan" id="kobo.1312.1">each key.</span></span></p>
<p><span class="koboSpan" id="kobo.1313.1">Follow these </span><a id="_idIndexMarker1280"/><span class="koboSpan" id="kobo.1314.1">steps to use the group </span><span class="No-Break"><span class="koboSpan" id="kobo.1315.1">data loader:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1316.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1317.1">TeachersByDepartmentIdDataLoader</span></strong><span class="koboSpan" id="kobo.1318.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1319.1">DataLoaders</span></strong><span class="koboSpan" id="kobo.1320.1"> folder, and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1322.1">
public class TeachersByDepartmentIdDataLoader(       IDbContextFactory&lt;AppDbContext&gt; dbContextFactory,       IBatchScheduler batchScheduler,       DataLoaderOptions? </span><span class="koboSpan" id="kobo.1322.2">options = null)       : GroupedDataLoader&lt;Guid, Teacher&gt;(batchScheduler, options){    protected override async Task&lt;ILookup&lt;Guid, Teacher&gt;&gt; LoadGroupedBatchAsync(IReadOnlyList&lt;Guid&gt; keys,        CancellationToken cancellationToken)    {        await using var dbContext = await dbContextFactory.CreateDbContextAsync(cancellationToken);        var teachers = await dbContext.Teachers.Where(x =&gt; keys.Contains(x.DepartmentId))            .ToListAsync(cancellationToken);        return teachers.ToLookup(x =&gt; x.DepartmentId);    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1323.1">The </span><a id="_idIndexMarker1281"/><span class="koboSpan" id="kobo.1324.1">preceding code defines a group data loader, which returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1325.1">ILookup&lt;Guid, Teacher&gt;</span></strong><span class="koboSpan" id="kobo.1326.1"> object in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">LoadGroupedBatchAsync()</span></strong><span class="koboSpan" id="kobo.1328.1"> method. </span><span class="koboSpan" id="kobo.1328.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1329.1">ILookup&lt;Guid, Teacher&gt;</span></strong><span class="koboSpan" id="kobo.1330.1"> object is similar to a dictionary. </span><span class="koboSpan" id="kobo.1330.2">The key of the dictionary is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">DepartmentId</span></strong><span class="koboSpan" id="kobo.1332.1"> property and the value is a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">Teacher</span></strong><span class="koboSpan" id="kobo.1334.1"> objects. </span><span class="koboSpan" id="kobo.1334.2">The parent resolver can map the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">Teacher</span></strong><span class="koboSpan" id="kobo.1336.1"> objects to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">Department</span></strong><span class="koboSpan" id="kobo.1338.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.1339.1">in memory.</span></span></p></li> <li><span class="koboSpan" id="kobo.1340.1">Update </span><a id="_idIndexMarker1282"/><span class="koboSpan" id="kobo.1341.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">DepartmentResolvers</span></strong><span class="koboSpan" id="kobo.1343.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.1344.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1345.1">
public class DepartmentResolvers{    public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachers([Parent] Department department,        TeachersByDepartmentIdDataLoader teachersByDepartmentIdDataLoader, CancellationToken cancellationToken)    {        var teachers = await teachersByDepartmentIdDataLoader.LoadAsync(department.Id, cancellationToken);        return teachers.ToList();    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1346.1">The </span><a id="_idIndexMarker1283"/><span class="koboSpan" id="kobo.1347.1">preceding code uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1348.1">TeachersByDepartmentIdDataLoader</span></strong><span class="koboSpan" id="kobo.1349.1"> to fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1350.1">Teacher</span></strong><span class="koboSpan" id="kobo.1351.1"> objects for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1352.1">Department</span></strong><span class="koboSpan" id="kobo.1353.1"> object. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">TeachersByDepartmentIdDataLoader</span></strong><span class="koboSpan" id="kobo.1355.1"> will be injected by </span><span class="No-Break"><span class="koboSpan" id="kobo.1356.1">HotChocolate automatically.</span></span></p></li> <li><span class="koboSpan" id="kobo.1357.1">Run the </span><a id="_idIndexMarker1284"/><span class="koboSpan" id="kobo.1358.1">application and test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1359.1">departments</span></strong><span class="koboSpan" id="kobo.1360.1"> query again. </span><span class="koboSpan" id="kobo.1360.2">Now, you will see only two SQL queries </span><span class="No-Break"><span class="koboSpan" id="kobo.1361.1">are executed:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1362.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (38ms) [Parameters=[], CommandType='Text', CommandTimeout='30']      SELECT [d].[Id], [d].[Description], [d].[Name]      FROM [Departments] AS [d]info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (36ms) [Parameters=[@__keys_0='?' </span><span class="koboSpan" id="kobo.1362.2">(Size = 4000)], CommandType='Text',    CommandTimeout='30']      SELECT [t].[Id], [t].[Bio], [t].[DepartmentId], [t].[Email], [t].[FirstName], [t].[LastName], [t].[Phone]      FROM [Teachers] AS [t]      WHERE [t].[DepartmentId] IN (          SELECT [k].[value]          FROM OPENJSON(@__keys_0) WITH ([value] uniqueidentifier '$') AS [k]      )</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1363.1">That is</span><a id="_idIndexMarker1285"/><span class="koboSpan" id="kobo.1364.1"> exactly what we want. </span><span class="koboSpan" id="kobo.1364.2">The first query is </span><a id="_idIndexMarker1286"/><span class="koboSpan" id="kobo.1365.1">to get the list of the departments, and the second query is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1366.1">IN</span></strong><span class="koboSpan" id="kobo.1367.1"> clause to query the teachers that match the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1368.1">DepartmentId</span></strong><span class="koboSpan" id="kobo.1369.1"> values in the list. </span><span class="koboSpan" id="kobo.1369.2">This approach reduces the number of database </span><span class="No-Break"><span class="koboSpan" id="kobo.1370.1">queries significantly.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.1371.1">In this case, each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">Department</span></strong><span class="koboSpan" id="kobo.1373.1"> object has a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">Teacher</span></strong><span class="koboSpan" id="kobo.1375.1"> objects, so this kind of data loader is called a group data loader. </span><span class="koboSpan" id="kobo.1375.2">It is often used for one-to-many relationships, such as one </span><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">Department</span></strong><span class="koboSpan" id="kobo.1377.1"> object has a list of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1378.1">Teacher</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1379.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.1380.1">HotChocolate supports cache data loader as well. </span><span class="koboSpan" id="kobo.1380.2">It also supports using multiple data loaders in a resolver. </span><span class="koboSpan" id="kobo.1380.3">As they are not used often, we will not discuss them in this chapter. </span><span class="koboSpan" id="kobo.1380.4">You can refer to the documentation for more </span><span class="No-Break"><span class="koboSpan" id="kobo.1381.1">details: </span></span><a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter12/start"><span class="No-Break"><span class="koboSpan" id="kobo.1382.1">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter12/start</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1383.1">.</span></span></p>
<h1 id="_idParaDest-267"><a id="_idTextAnchor514"/><span class="koboSpan" id="kobo.1384.1">Dependency injection</span></h1>
<p><span class="koboSpan" id="kobo.1385.1">In the previous code examples, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">IDbContextFactory&lt;AppDbContext&gt;</span></strong><span class="koboSpan" id="kobo.1387.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">AppDbContext</span></strong><span class="koboSpan" id="kobo.1389.1"> directly in the resolvers. </span><span class="koboSpan" id="kobo.1389.2">In order to encapsulate our data access logic, we can add a service layer to implement our business logic. </span><span class="koboSpan" id="kobo.1389.3">HotChocolate supports </span><a id="_idIndexMarker1287"/><span class="koboSpan" id="kobo.1390.1">dependency injection for resolvers. </span><span class="koboSpan" id="kobo.1390.2">In this section, we will learn how to inject other services into </span><span class="No-Break"><span class="koboSpan" id="kobo.1391.1">the resolvers.</span></span></p>
<p><span class="koboSpan" id="kobo.1392.1">To demonstrate how to use dependency injection in HotChocolate, we will add an interface </span><a id="_idIndexMarker1288"/><span class="koboSpan" id="kobo.1393.1">named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">ITeacherService</span></strong><span class="koboSpan" id="kobo.1395.1"> and a class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1396.1">TeacherService</span></strong><span class="koboSpan" id="kobo.1397.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1398.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1399.1">
public interface ITeacherService{
    Task&lt;Department&gt; GetDepartmentAsync(Guid departmentId);
    Task&lt;List&lt;Teacher&gt;&gt; GetTeachersAsync();
    Task&lt;Teacher&gt; GetTeacherAsync(Guid teacherId);
    // Omitted for brevity
}
public class TeacherService(IDbContextFactory&lt;AppDbContext&gt; contextFactory) : ITeacherService
{
    public async Task&lt;Department&gt; GetDepartmentAsync(Guid departmentId)
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var department = await dbContext.Departments.FindAsync(departmentId);
        return department ?? </span><span class="koboSpan" id="kobo.1399.2">throw new ArgumentException("Department not found", nameof(departmentId));
    }
    public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachersAsync()
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var teachers = await dbContext.Teachers.ToListAsync();
        return teachers;
    }
    public async Task&lt;Teacher&gt; GetTeacherAsync(Guid teacherId)
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var teacher = await dbContext.Teachers.FindAsync(teacherId);
        return teacher ?? </span><span class="koboSpan" id="kobo.1399.3">throw new ArgumentException("Teacher not found", nameof(teacherId));
    }
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.1400.1">The</span><a id="_idIndexMarker1289"/><span class="koboSpan" id="kobo.1401.1"> preceding code encapsulates the data access logic in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">TeacherService</span></strong><span class="koboSpan" id="kobo.1403.1"> class. </span><span class="koboSpan" id="kobo.1403.2">Then, we need to register </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">ITeacherService</span></strong><span class="koboSpan" id="kobo.1405.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1407.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.1408.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1409.1">
builder.Services.AddScoped&lt;ITeacherService, TeacherService&gt;();</span></pre> <p><span class="koboSpan" id="kobo.1410.1">HotChocolate uses the same approach to register the services as ASP.NET Core, but injecting the services is a little different. </span><span class="koboSpan" id="kobo.1410.2">In ASP.NET Core, we can inject the services into the controller constructor, while HotChocolate does not recommend constructor injection. </span><span class="koboSpan" id="kobo.1410.3">Instead, HotChocolate recommends using the method-level injection. </span><span class="koboSpan" id="kobo.1410.4">First, the GraphQL type </span><a id="_idIndexMarker1290"/><span class="koboSpan" id="kobo.1411.1">definitions are singleton objects. </span><span class="koboSpan" id="kobo.1411.2">If we use constructor injection, the services will be injected as singleton objects as well. </span><span class="koboSpan" id="kobo.1411.3">This is not what we want. </span><span class="koboSpan" id="kobo.1411.4">Second, sometimes HotChocolate needs to synchronize the resolvers to avoid concurrency issues. </span><span class="koboSpan" id="kobo.1411.5">If we use constructor injection, HotChocolate cannot control the lifetime of the services. </span><span class="koboSpan" id="kobo.1411.6">Note that this applies to the HotChocolate GraphQL types and resolvers only. </span><span class="koboSpan" id="kobo.1411.7">For other services, we can still use </span><span class="No-Break"><span class="koboSpan" id="kobo.1412.1">constructor </span><a id="_idTextAnchor515"/><span class="koboSpan" id="kobo.1413.1">injection.</span></span></p>
<p><span class="koboSpan" id="kobo.1414.1">Let us see how to </span><a id="_idIndexMarker1291"/><span class="koboSpan" id="kobo.1415.1">use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1416.1">method-level injection.</span></span></p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor516"/><span class="koboSpan" id="kobo.1417.1">Using the Service attribute</span></h2>
<p><span class="koboSpan" id="kobo.1418.1">We can </span><a id="_idIndexMarker1292"/><span class="koboSpan" id="kobo.1419.1">use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1420.1">HotChocolate.ServiceAttribute</span></strong><span class="koboSpan" id="kobo.1421.1"> to inject services into the resolvers. </span><span class="koboSpan" id="kobo.1421.2">For example, we can add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1422.1">GetTeachersWithDI</span></strong><span class="koboSpan" id="kobo.1423.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1424.1">Query</span></strong><span class="koboSpan" id="kobo.1425.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.1426.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1427.1">
public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachersWithDI([Service] ITeacherService teacherService) =&gt;    await teacherService.GetTeachersAsync();</span></pre>
<p><span class="koboSpan" id="kobo.1428.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">Service</span></strong><span class="koboSpan" id="kobo.1430.1"> attribute is from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1431.1">HotChocolate</span></strong><span class="koboSpan" id="kobo.1432.1"> namespace, not the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1433.1">Microsoft.AspNetCore.Mvc</span></strong><span class="koboSpan" id="kobo.1434.1"> namespace. </span><span class="koboSpan" id="kobo.1434.2">With this attribute, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1435.1">ITeacherService</span></strong><span class="koboSpan" id="kobo.1436.1"> will be injected into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1437.1">teacherService</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1438.1">parameter automatically.</span></span></p>
<p><span class="koboSpan" id="kobo.1439.1">If we have many services in the project, using the attribute for each service is tedious. </span><span class="koboSpan" id="kobo.1439.2">HotChocolate provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1440.1">RegisterServices()</span></strong><span class="koboSpan" id="kobo.1441.1"> method to simplify the injection. </span><span class="koboSpan" id="kobo.1441.2">We can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1442.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1443.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.1444.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1445.1">
builder.Services    .AddGraphQLServer()
    .RegisterDbContext&lt;AppDbContext&gt;(DbContextKind.Pooled)
    .RegisterService&lt;ITeacherService&gt;()
    .AddQueryType&lt;QueryType&gt;()
    .AddMutationType&lt;Mutation&gt;();</span></pre>
<p><span class="koboSpan" id="kobo.1446.1">Now, we can remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1447.1">Service</span></strong><span class="koboSpan" id="kobo.1448.1"> attribute from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1449.1">GetTeachersWithDI()</span></strong><span class="koboSpan" id="kobo.1450.1"> method. </span><span class="koboSpan" id="kobo.1450.2">HotChocolate</span><a id="_idIndexMarker1293"/><span class="koboSpan" id="kobo.1451.1"> can still inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.1452.1">ITeacherService</span></strong><span class="koboSpan" id="kobo.1453.1"> automatically, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1454.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1455.1">
public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachersWithDI(ITeacherService teacherService) =&gt;    await teac</span><a id="_idTextAnchor517"/><span class="koboSpan" id="kobo.1456.1">herService.GetTeachersAsync();</span></pre>
<p><span class="koboSpan" id="kobo.1457.1">This will save us a lot </span><span class="No-Break"><span class="koboSpan" id="kobo.1458.1">of time.</span></span></p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor518"/><span class="koboSpan" id="kobo.1459.1">Understanding the lifetime of the injected services</span></h2>
<p><span class="koboSpan" id="kobo.1460.1">We have</span><a id="_idIndexMarker1294"/><span class="koboSpan" id="kobo.1461.1"> learned that, in ASP.NET Core, we can inject the services as singleton, scoped, or transient services. </span><span class="koboSpan" id="kobo.1461.2">HotChocolate offers more options for the lifetime of the injected services. </span><span class="koboSpan" id="kobo.1461.3">When we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1462.1">Service</span></strong><span class="koboSpan" id="kobo.1463.1"> attribute or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1464.1">RegisterService()</span></strong><span class="koboSpan" id="kobo.1465.1"> method to inject the services, we can specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1466.1">ServiceKind</span></strong><span class="koboSpan" id="kobo.1467.1"> property to control the lifetime of the services. </span><span class="koboSpan" id="kobo.1467.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1468.1">ServiceKind</span></strong><span class="koboSpan" id="kobo.1469.1"> has the </span><span class="No-Break"><span class="koboSpan" id="kobo.1470.1">following options:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1471.1">ServiceKind.Default</span></strong><span class="koboSpan" id="kobo.1472.1">: This is the default option. </span><span class="koboSpan" id="kobo.1472.2">The service will be injected as the same lifetime in the registered service in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1473.1">DI container.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1474.1">ServiceKind.Synchronized</span></strong><span class="koboSpan" id="kobo.1475.1">: This option is similar to the synchronized </span><strong class="source-inline"><span class="koboSpan" id="kobo.1476.1">DbContext</span></strong><span class="koboSpan" id="kobo.1477.1">. </span><span class="koboSpan" id="kobo.1477.2">The resolver using the service will be executed sequentially. </span><span class="koboSpan" id="kobo.1477.3">The synchronization only happens in the same </span><span class="No-Break"><span class="koboSpan" id="kobo.1478.1">request scope.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1479.1">ServiceKind.Resolver</span></strong><span class="koboSpan" id="kobo.1480.1">: This option is to resolve the service for each resolver scope. </span><span class="koboSpan" id="kobo.1480.2">The service will be disposed of after the resolver </span><span class="No-Break"><span class="koboSpan" id="kobo.1481.1">is completed.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1482.1">ServiceKind.Pooled</span></strong><span class="koboSpan" id="kobo.1483.1">: This option is similar to the pooled </span><strong class="source-inline"><span class="koboSpan" id="kobo.1484.1">DbContext</span></strong><span class="koboSpan" id="kobo.1485.1">. </span><span class="koboSpan" id="kobo.1485.2">The service needs to be registered as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1486.1">ObjectPool&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1487.1"> instance in the ASP.NET Core DI container. </span><span class="koboSpan" id="kobo.1487.2">The resolver will get the service from the pool and return it to the pool after the resolver </span><span class="No-Break"><span class="koboSpan" id="kobo.1488.1">is completed.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1489.1">To specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1490.1">ServiceKind</span></strong><span class="koboSpan" id="kobo.1491.1"> for the injected services, we can add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1492.1">ServiceKind</span></strong><span class="koboSpan" id="kobo.1493.1"> parameter in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1494.1">Service</span></strong><span class="koboSpan" id="kobo.1495.1"> attribute or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1496.1">RegisterService()</span></strong><span class="koboSpan" id="kobo.1497.1"> method. </span><span class="koboSpan" id="kobo.1497.2">For example, we can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1498.1">GetTeachersWithDI()</span></strong><span class="koboSpan" id="kobo.1499.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.1500.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1501.1">
public async Task&lt;List&lt;Teacher&gt;&gt; GetTeachersWithDI([Service(ServiceKind.Resolver)] ITeacherService teacherService) =&gt;    await teacherService.GetTeachersAsync();</span></pre>
<p><span class="koboSpan" id="kobo.1502.1">The</span><a id="_idIndexMarker1295"/><span class="koboSpan" id="kobo.1503.1"> preceding code specifies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1504.1">ServiceKind</span></strong><span class="koboSpan" id="kobo.1505.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1506.1">ServiceKind.Resolver</span></strong><span class="koboSpan" id="kobo.1507.1">. </span><span class="koboSpan" id="kobo.1507.2">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1508.1">ITeacherService</span></strong><span class="koboSpan" id="kobo.1509.1"> will be resolved for each </span><span class="No-Break"><span class="koboSpan" id="kobo.1510.1">resolver scope.</span></span></p>
<p><span class="koboSpan" id="kobo.1511.1">If we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1512.1">RegisterServices()</span></strong><span class="koboSpan" id="kobo.1513.1"> method to register the services, we can specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1514.1">ServiceKind</span></strong><span class="koboSpan" id="kobo.1515.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1516.1">RegisterServices()</span></strong><span class="koboSpan" id="kobo.1517.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.1518.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1519.1">
builder.Services    .AddGraphQLServer()
    .RegisterDbContext&lt;AppDbContext&gt;(DbContextKind.Pooled)
    .RegisterService&lt;ITeacherService&gt;(ServiceKind.Resolver)
    .AddQueryType&lt;QueryType&gt;()
    .AddMutationType&lt;Mutation&gt;();</span></pre>
<p><span class="koboSpan" id="kobo.1520.1">To inject the services in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1521.1">Resolve()</span></strong><span class="koboSpan" id="kobo.1522.1"> method, we can get the service from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1523.1">context</span></strong><span class="koboSpan" id="kobo.1524.1"> object, </span><span class="No-Break"><span class="koboSpan" id="kobo.1525.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1526.1">
descriptor.Field(x =&gt; x.Teachers)    .Description("This is the list of teachers in the school.")
    .Type&lt;ListType&lt;TeacherType&gt;&gt;()
    .Resolve(async context =&gt;
    {
        var teacherService = context.Service&lt;ITeacherService&gt;();
        var teachers = await teacherService.GetTeachersAsync();
        return teachers;
    });</span></pre>
<p><span class="koboSpan" id="kobo.1527.1">The </span><a id="_idIndexMarker1296"/><span class="koboSpan" id="kobo.1528.1">preceding code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1529.1">context.Service&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.1530.1"> method to get </span><strong class="source-inline"><span class="koboSpan" id="kobo.1531.1">ITeacherService</span></strong><span class="koboSpan" id="kobo.1532.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1533.1">context</span></strong><span class="koboSpan" id="kobo.1534.1"> object, which is similar to i</span><a id="_idTextAnchor519"/><span class="koboSpan" id="kobo.1535.1">njecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.1536.1">IDbContextFactory&lt;AppDbContext&gt;</span></strong><span class="koboSpan" id="kobo.1537.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1538.1">previous examples.</span></span></p>
<h1 id="_idParaDest-270"><a id="_idTextAnchor520"/><span class="koboSpan" id="kobo.1539.1">Interface and union types</span></h1>
<p><span class="koboSpan" id="kobo.1540.1">HotChocolate supports the use of interfaces and union types in GraphQL. </span><span class="koboSpan" id="kobo.1540.2">In this section, we will explore how to incorporate these features into your GraphQL schema. </span><span class="koboSpan" id="kobo.1540.3">Interfaces provide a way to group types that share common fields, while union types allow for the creation of a single type that can return different object types. </span><span class="koboSpan" id="kobo.1540.4">With HotChocolate, you can easily implement t</span><a id="_idTextAnchor521"/><span class="koboSpan" id="kobo.1541.1">hese features to enhance the functionality of your </span><span class="No-Break"><span class="koboSpan" id="kobo.1542.1">GraphQL schema.</span></span></p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor522"/><span class="koboSpan" id="kobo.1543.1">Interfaces</span></h2>
<p><span class="koboSpan" id="kobo.1544.1">To prepare </span><a id="_idIndexMarker1297"/><span class="koboSpan" id="kobo.1545.1">the examples of GraphQL interfaces, we have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1546.1">ISchoolRoom</span></strong><span class="koboSpan" id="kobo.1547.1"> interface </span><a id="_idIndexMarker1298"/><span class="koboSpan" id="kobo.1548.1">and two classes that implement the interface, </span><span class="No-Break"><span class="koboSpan" id="kobo.1549.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1550.1">
public interface ISchoolRoom{
    Guid Id { get; set; }
    string Name { get; set; }
    string? </span><span class="koboSpan" id="kobo.1550.2">Description { get; set; }
    public int Capacity { get; set; }
}
public class LabRoom : ISchoolRoom
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? </span><span class="koboSpan" id="kobo.1550.3">Description { get; set; }
    public int Capacity { get; set; }
    public string Subject { get; set; } = string.Empty;
    public string Equipment { get; set; } = string.Empty;
    public bool HasChemicals { get; set; }
}
public class Classroom : ISchoolRoom
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? </span><span class="koboSpan" id="kobo.1550.4">Description { get; set; }
    public int Capacity { get; set; }
    public bool HasComputers { get; set; }
    public bool HasProjector { get; set; }
    public bool HasWhiteboard { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.1551.1">The two classes both implement </span><a id="_idIndexMarker1299"/><span class="koboSpan" id="kobo.1552.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1553.1">ISchoolRoom</span></strong><span class="koboSpan" id="kobo.1554.1"> interface, but they have some different properties. </span><span class="koboSpan" id="kobo.1554.2">You can find the model classes and the model configurations in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1555.1">sample code.</span></span></p>
<p><span class="koboSpan" id="kobo.1556.1">The service layer is defined in </span><a id="_idIndexMarker1300"/><span class="koboSpan" id="kobo.1557.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1558.1">ISchoolRoomService</span></strong><span class="koboSpan" id="kobo.1559.1"> interface and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">SchoolRoomService</span></strong><span class="koboSpan" id="kobo.1561.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.1562.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1563.1">
public interface ISchoolRoomService{
    Task&lt;List&lt;ISchoolRoom&gt;&gt; GetSchoolRoomsAsync();
    Task&lt;List&lt;LabRoom&gt;&gt; GetLabRoomsAsync();
    Task&lt;List&lt;Classroom&gt;&gt; GetClassroomsAsync();
    Task&lt;LabRoom&gt; GetLabRoomAsync(Guid labRoomId);
    Task&lt;Classroom&gt; GetClassroomAsync(Guid classroomId);
}
public class SchoolRoomService(IDbContextFactory&lt;AppDbContext&gt; contextFactory) : ISchoolRoomService
{
    public async Task&lt;List&lt;ISchoolRoom&gt;&gt; GetSchoolRoomsAsync()
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var labRooms = await dbContext.LabRooms.ToListAsync();
        var classrooms = await dbContext.Classrooms.ToListAsync();
        var schoolRooms = new List&lt;ISchoolRoom&gt;();
        schoolRooms.AddRange(labRooms);
        schoolRooms.AddRange(classrooms);
        return schoolRooms;
    }
    // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.1564.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1565.1">GetSchoolRoomsAsync()</span></strong><span class="koboSpan" id="kobo.1566.1"> method retrieves a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1567.1">LabRoom</span></strong><span class="koboSpan" id="kobo.1568.1"> objects and a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1569.1">Classroom</span></strong><span class="koboSpan" id="kobo.1570.1"> objects from the database. </span><span class="koboSpan" id="kobo.1570.2">Then, it combines the two lists into a single list of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1571.1">ISchoolRoom</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1572.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.1573.1">We also need to </span><a id="_idIndexMarker1301"/><span class="koboSpan" id="kobo.1574.1">register </span><strong class="source-inline"><span class="koboSpan" id="kobo.1575.1">ISchoolRoomService</span></strong><span class="koboSpan" id="kobo.1576.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1577.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1578.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.1579.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1580.1">
builder.Services.AddScoped&lt;ISchoolRoomService, SchoolRoomService&gt;();</span></pre> <p><span class="koboSpan" id="kobo.1581.1">To define an</span><a id="_idIndexMarker1302"/><span class="koboSpan" id="kobo.1582.1"> interface in HotChocolate, we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1583.1">InterfaceType&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1584.1"> class. </span><span class="koboSpan" id="kobo.1584.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1585.1">InterfaceType&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1586.1"> class is used to define an interface type in the schema. </span><span class="koboSpan" id="kobo.1586.2">Follow these steps to define an interface type using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1587.1">code-first API:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1588.1">Create a class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1589.1">SchoolRoomType</span></strong><span class="koboSpan" id="kobo.1590.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1591.1">Types</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1592.1"> folder:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1593.1">
public class SchoolRoomType : InterfaceType&lt;ISchoolRoom&gt;{    protected override void Configure(IInterfaceTypeDescriptor&lt;ISchoolRoom&gt; descriptor)    {        descriptor.Name("SchoolRoom");    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1594.1">The preceding code defines an interface type for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1595.1">ISchoolRoom</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1596.1"> interface.</span></span></p></li> <li><span class="koboSpan" id="kobo.1597.1">Create two new classes for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1598.1">LabRoom</span></strong><span class="koboSpan" id="kobo.1599.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1600.1">Classroom</span></strong><span class="koboSpan" id="kobo.1601.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1602.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1603.1">
public class LabRoomType : ObjectType&lt;LabRoom&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;LabRoom&gt; descriptor)    {        descriptor.Name("LabRoom");        descriptor.Implements&lt;SchoolRoomType&gt;();    }}public class ClassroomType : ObjectType&lt;Classroom&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;Classroom&gt; descriptor)    {        descriptor.Name("Classroom");        descriptor.Implements&lt;SchoolRoomType&gt;();    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1604.1">In the </span><a id="_idIndexMarker1303"/><span class="koboSpan" id="kobo.1605.1">preceding code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1606.1">Implements()</span></strong><span class="koboSpan" id="kobo.1607.1"> method to specify the interface implemented by the </span><span class="No-Break"><span class="koboSpan" id="kobo.1608.1">object type.</span></span></p></li> <li><span class="koboSpan" id="kobo.1609.1">Add a query field in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1610.1">Query</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1611.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1612.1">
public List&lt;SchoolRoomType&gt; SchoolRooms { get; set; } = new();</span></pre></li> <li><span class="koboSpan" id="kobo.1613.1">Configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">SchoolRooms</span></strong><span class="koboSpan" id="kobo.1615.1"> field in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1616.1">QueryType</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1617.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1618.1">
descriptor.Field(x =&gt; x.SchoolRooms)    .Description("This is the list of school rooms in the school.")    .Type&lt;ListType&lt;SchoolRoomType&gt;&gt;()    .Resolve(async context =&gt;    {        var service = context.Service&lt;ISchoolRoomService&gt;();        var schoolRooms = await service.GetSchoolRoomsAsync();        return schoolRooms;    });</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1619.1">In the </span><a id="_idIndexMarker1304"/><span class="koboSpan" id="kobo.1620.1">preceding code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1621.1">Service()</span></strong><span class="koboSpan" id="kobo.1622.1"> method to get </span><strong class="source-inline"><span class="koboSpan" id="kobo.1623.1">ISchoolRoomService</span></strong><span class="koboSpan" id="kobo.1624.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1625.1">context</span></strong><span class="koboSpan" id="kobo.1626.1"> object. </span><span class="koboSpan" id="kobo.1626.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1627.1">GetSchoolRoomsAsync()</span></strong><span class="koboSpan" id="kobo.1628.1"> method to retrieve the list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1629.1">ISchoolRoom</span></strong><span class="koboSpan" id="kobo.1630.1"> objects. </span><span class="koboSpan" id="kobo.1630.2">The result includes both </span><strong class="source-inline"><span class="koboSpan" id="kobo.1631.1">LabRoom</span></strong><span class="koboSpan" id="kobo.1632.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1633.1">Classroom</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1634.1"> objects.</span></span></p></li> <li><span class="koboSpan" id="kobo.1635.1">Next, we need to explicitly register </span><strong class="source-inline"><span class="koboSpan" id="kobo.1636.1">LabRoomType</span></strong><span class="koboSpan" id="kobo.1637.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1638.1">ClassroomType</span></strong><span class="koboSpan" id="kobo.1639.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1640.1">SchemaBuilder</span></strong><span class="koboSpan" id="kobo.1641.1">. </span><span class="koboSpan" id="kobo.1641.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1642.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1643.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.1644.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1645.1">
builder.Services    .AddGraphQLServer()    .RegisterDbContext&lt;AppDbContext&gt;(DbContextKind.Pooled)    .RegisterService&lt;ITeacherService&gt;(ServiceKind.Resolver)    .AddQueryType&lt;QueryType&gt;()    .AddType&lt;LabRoomType&gt;()    .AddType&lt;ClassroomType&gt;()    .AddMutationType&lt;Mutation&gt;();</span></pre></li> <li><span class="koboSpan" id="kobo.1646.1">Run the application and check the generated schema. </span><span class="koboSpan" id="kobo.1646.2">You will find the interface definition</span><a id="_idIndexMarker1305"/><span class="koboSpan" id="kobo.1647.1"> and its implementations, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1648.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1649.1">
type Query {  """  This is the list of school rooms in the school.  """  schoolRooms: [SchoolRoom]}type LabRoom implements SchoolRoom {  id: UUID!  name: String!  description: String  capacity: Int!  subject: String!  equipment: String!  hasChemicals: Boolean!}type Classroom implements SchoolRoom {  id: UUID!  name: String!  description: String  capacity: Int!  hasComputers: Boolean!  hasProjector: Boolean!  hasWhiteboard: Boolean!}</span></pre></li> <li><span class="koboSpan" id="kobo.1650.1">Next, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1651.1">SchoolRoom</span></strong><span class="koboSpan" id="kobo.1652.1"> interface to query both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1653.1">LabRoom</span></strong><span class="koboSpan" id="kobo.1654.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1655.1">Classroom</span></strong><span class="koboSpan" id="kobo.1656.1"> objects. </span><span class="koboSpan" id="kobo.1656.2">For</span><a id="_idIndexMarker1306"/><span class="koboSpan" id="kobo.1657.1"> example, we can use the following query to retrieve the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1658.1">LabRoom</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1659.1"> objects:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1660.1">
query {  schoolRooms {    __typename    id    name    description    capacity    ... </span><span class="koboSpan" id="kobo.1660.2">on LabRoom {      subject      equipment      hasChemicals    }    ... </span><span class="koboSpan" id="kobo.1660.3">on Classroom {      hasComputers      hasProjector      hasWhiteboard    }  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1661.1">The preceding query uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1662.1">... </span><span class="koboSpan" id="kobo.1662.2">on LabRoom</span></strong><span class="koboSpan" id="kobo.1663.1"> syntax to specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1664.1">LabRoom</span></strong><span class="koboSpan" id="kobo.1665.1"> object. </span><span class="koboSpan" id="kobo.1665.2">Then we can retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1666.1">LabRoom</span></strong><span class="koboSpan" id="kobo.1667.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1668.1">Classroom</span></strong><span class="koboSpan" id="kobo.1669.1"> properties. </span><span class="koboSpan" id="kobo.1669.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1670.1">__typename</span></strong><span class="koboSpan" id="kobo.1671.1"> property is used to show the object type. </span><span class="koboSpan" id="kobo.1671.2">The result</span><a id="_idIndexMarker1307"/><span class="koboSpan" id="kobo.1672.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.1673.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1674.1">{  "data": {    "schoolRooms": [      {        "__typename": "LabRoom",        "id": "00000000-0000-0000-0000-000000000501",        "name": "Chemistry Lab",        "description": "Chemistry Lab",        "capacity": 20,        "subject": "Chemistry",        "equipment": "Chemicals, Beakers, Bunsen Burners",        "hasChemicals": true      },      {        "__typename": "Classroom",        "id": "00000000-0000-0000-0000-000000000601",        "name": "Classroom 1",        "description": "Classroom 1",        "capacity": 20,        "hasComputers": true,        "hasProjector": false,        "hasWhiteboard": true      },      ...    ]  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1675.1">In the</span><a id="_idIndexMarker1308"/><span class="koboSpan" id="kobo.1676.1"> response, you can see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1677.1">LabRoom</span></strong><span class="koboSpan" id="kobo.1678.1"> object has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1679.1">subject</span></strong><span class="koboSpan" id="kobo.1680.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1681.1">equipment</span></strong><span class="koboSpan" id="kobo.1682.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1683.1">hasChemicals</span></strong><span class="koboSpan" id="kobo.1684.1"> properties, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1685.1">Classroom</span></strong><span class="koboSpan" id="kobo.1686.1"> object has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1687.1">hasComputers</span></strong><span class="koboSpan" id="kobo.1688.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1689.1">hasProjector</span></strong><span class="koboSpan" id="kobo.1690.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1691.1">hasWhiteboard</span></strong><span class="koboSpan" id="kobo.1692.1"> properties. </span><span class="koboSpan" id="kobo.1692.2">This can be helpful when we want to query complex objects with </span><span class="No-Break"><span class="koboSpan" id="kobo.1693.1">different properties.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.1694.1">Although interfaces provide flexibility for querying objects with different properties, we need to note that interfaces can be used</span><a id="_idTextAnchor523"/><span class="koboSpan" id="kobo.1695.1"> for output types only. </span><span class="koboSpan" id="kobo.1695.2">We cannot use interfaces for input types </span><span class="No-Break"><span class="koboSpan" id="kobo.1696.1">or arguments.</span></span></p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor524"/><span class="koboSpan" id="kobo.1697.1">Union types</span></h2>
<p><span class="koboSpan" id="kobo.1698.1">Union types</span><a id="_idIndexMarker1309"/><span class="koboSpan" id="kobo.1699.1"> are similar to interfaces. </span><span class="koboSpan" id="kobo.1699.2">The difference is that union types do not need to define any common fields. </span><span class="koboSpan" id="kobo.1699.3">Instead, union types can combine multiple object types into a </span><span class="No-Break"><span class="koboSpan" id="kobo.1700.1">single type.</span></span></p>
<p><span class="koboSpan" id="kobo.1701.1">Follow the same approach as the previous section to prepare the models for union types. </span><span class="koboSpan" id="kobo.1701.2">You can find an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1702.1">Equipment</span></strong><span class="koboSpan" id="kobo.1703.1"> class and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1704.1">Furniture</span></strong><span class="koboSpan" id="kobo.1705.1"> class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1706.1">Models</span></strong><span class="koboSpan" id="kobo.1707.1"> folder, </span><span class="No-Break"><span class="koboSpan" id="kobo.1708.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1709.1">
public class Equipment{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? </span><span class="koboSpan" id="kobo.1709.2">Description { get; set; }
    public string Condition { get; set; } = string.Empty;
    public string Brand { get; set; } = string.Empty;
    public int Quantity { get; set; }
}
public class Furniture
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? </span><span class="koboSpan" id="kobo.1709.3">Description { get; set; }
    public string Color { get; set; } = string.Empty;
    public string Material { get; set; } = string.Empty;
    public int Quantity { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.1710.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1711.1">Equipment</span></strong><span class="koboSpan" id="kobo.1712.1"> class </span><a id="_idIndexMarker1310"/><span class="koboSpan" id="kobo.1713.1">and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1714.1">Furniture</span></strong><span class="koboSpan" id="kobo.1715.1"> class have some different properties. </span><span class="koboSpan" id="kobo.1715.2">You can find the model configurations in the sample code. </span><span class="koboSpan" id="kobo.1715.3">We also need to add the services for both classes. </span><span class="koboSpan" id="kobo.1715.4">You can find the following code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1716.1">Services</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1717.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.1718.1">Here is the code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1719.1">IEquipmentService</span></strong><span class="koboSpan" id="kobo.1720.1"> interface and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1721.1">EquipmentService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1722.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1723.1">
public interface IEquipmentService{
    Task&lt;List&lt;Equipment&gt;&gt; GetEquipmentListAsync();
    Task&lt;Equipment&gt; GetEquipmentAsync(Guid equipmentId);
}
public class EquipmentService(IDbContextFactory&lt;AppDbContext&gt; contextFactory) : IEquipmentService
{
    public async Task&lt;List&lt;Equipment&gt;&gt; GetEquipmentListAsync()
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var equipment = await dbContext.Equipment.ToListAsync();
        return equipment;
    }
    public async Task&lt;Equipment&gt; GetEquipmentAsync(Guid equipmentId)
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var equipment = await dbContext.Equipment.FindAsync(equipmentId);
        return equipment ?? </span><span class="koboSpan" id="kobo.1723.2">throw new ArgumentException("Equipment not found", nameof(equipmentId));
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1724.1">Here is the code</span><a id="_idIndexMarker1311"/><span class="koboSpan" id="kobo.1725.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1726.1">IFurnitureService</span></strong><span class="koboSpan" id="kobo.1727.1"> interface and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1728.1">FurnitureService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1729.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1730.1">
public interface IFurnitureService{
    Task&lt;List&lt;Furniture&gt;&gt; GetFurnitureListAsync();
    Task&lt;Furniture&gt; GetFurnitureAsync(Guid furnitureId);
}
public class FurnitureService(IDbContextFactory&lt;AppDbContext&gt; contextFactory) : IFurnitureService
{
    public async Task&lt;List&lt;Furniture&gt;&gt; GetFurnitureListAsync()
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var furniture = await dbContext.Furniture.ToListAsync();
        return furniture;
    }
    public async Task&lt;Furniture&gt; GetFurnitureAsync(Guid furnitureId)
    {
        await using var dbContext = await contextFactory.CreateDbContextAsync();
        var furniture = await dbContext.Furniture.FindAsync(furnitureId);
        return furniture ?? </span><span class="koboSpan" id="kobo.1730.2">throw new ArgumentException("Furniture not found", nameof(furnitureId));
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1731.1">The preceding code </span><a id="_idIndexMarker1312"/><span class="koboSpan" id="kobo.1732.1">should be straightforward. </span><span class="koboSpan" id="kobo.1732.2">Do not forget to register the services in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1733.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1734.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.1735.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1736.1">
builder.Services.AddScoped&lt;IEquipmentService, EquipmentService&gt;();builder.Services.AddScoped&lt;IFurnitureService, FurnitureService&gt;();</span></pre>
<p><span class="koboSpan" id="kobo.1737.1">Next, let's create</span><a id="_idIndexMarker1313"/><span class="koboSpan" id="kobo.1738.1"> the union types following </span><span class="No-Break"><span class="koboSpan" id="kobo.1739.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1740.1">Create two classes named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1741.1">EquipmentType</span></strong><span class="koboSpan" id="kobo.1742.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1743.1">FurnitureType</span></strong><span class="koboSpan" id="kobo.1744.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1745.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1746.1">
public class EquipmentType : ObjectType&lt;Equipment&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;Equipment&gt; descriptor)    {        descriptor.Name("Equipment");    }}public class FurnitureType : ObjectType&lt;Furniture&gt;{    protected override void Configure(IObjectTypeDescriptor&lt;Furniture&gt; descriptor)    {        descriptor.Name("Furniture");    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1747.1">The preceding code defines the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1748.1">EquipmentType</span></strong><span class="koboSpan" id="kobo.1749.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1750.1">FurnitureType</span></strong><span class="koboSpan" id="kobo.1751.1"> object types. </span><span class="koboSpan" id="kobo.1751.2">These two object types are just normal </span><span class="No-Break"><span class="koboSpan" id="kobo.1752.1">object types.</span></span></p></li> <li><span class="koboSpan" id="kobo.1753.1">Create a </span><a id="_idIndexMarker1314"/><span class="koboSpan" id="kobo.1754.1">new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1755.1">SchoolItemType</span></strong><span class="koboSpan" id="kobo.1756.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1757.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1758.1">
public class SchoolItemType : UnionType{    protected override void Configure(IUnionTypeDescriptor descriptor)    {        descriptor.Name("SchoolItem");        descriptor.Type&lt;EquipmentType&gt;();        descriptor.Type&lt;FurnitureType&gt;();    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1759.1">The preceding code defines a union type named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1760.1">SchoolItem</span></strong><span class="koboSpan" id="kobo.1761.1">. </span><span class="koboSpan" id="kobo.1761.2">A union type must inherit from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1762.1">UnionType</span></strong><span class="koboSpan" id="kobo.1763.1"> class. </span><span class="koboSpan" id="kobo.1763.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1764.1">Type</span></strong><span class="koboSpan" id="kobo.1765.1"> method to specify the object types that are included in the union type. </span><span class="koboSpan" id="kobo.1765.2">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1766.1">SchoolItem</span></strong><span class="koboSpan" id="kobo.1767.1"> union type includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1768.1">EquipmentType</span></strong><span class="koboSpan" id="kobo.1769.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1770.1">FurnitureType</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1771.1">object types.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.1772.1">As we already registered these two types in the union type, we do not need to register them again in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1773.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1774.1"> file.</span></span></p></li> <li><span class="koboSpan" id="kobo.1775.1">Add a </span><a id="_idIndexMarker1315"/><span class="koboSpan" id="kobo.1776.1">query field in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1777.1">Query</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1778.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1779.1">
public List&lt;SchoolItemType&gt; SchoolItems { get; set; } = new();</span></pre></li> <li><span class="koboSpan" id="kobo.1780.1">Configure the resolver for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1781.1">SchoolItems</span></strong><span class="koboSpan" id="kobo.1782.1"> field in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1783.1">QueryType</span></strong><span class="koboSpan" id="kobo.1784.1"> class, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1785.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1786.1">
descriptor.Field(x =&gt; x.SchoolItems)    .Description("This is the list of school items in the school.")    .Type&lt;ListType&lt;SchoolItemType&gt;&gt;()    .Resolve(async context =&gt;    {        var equipmentService = context.Service&lt;IEquipmentService&gt;();        var furnitureService = context.Service&lt;IFurnitureService&gt;();        var equipmentTask = equipmentService.GetEquipmentListAsync();        var furnitureTask = furnitureService.GetFurnitureListAsync();        await Task.WhenAll(equipmentTask, furnitureTask);        var schoolItems = new List&lt;object&gt;();        schoolItems.AddRange(equipmentTask.Result);        schoolItems.AddRange(furnitureTask.Result);        return schoolItems;    });</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1787.1">We retrieve a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1788.1">Equipment</span></strong><span class="koboSpan" id="kobo.1789.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1790.1">Furniture</span></strong><span class="koboSpan" id="kobo.1791.1"> objects from the database. </span><span class="koboSpan" id="kobo.1791.2">We then combine these two lists into a single list of objects, as the object type is the base type of all types in C#. </span><span class="koboSpan" id="kobo.1791.3">This allows us to use the object type to effectively combine the </span><span class="No-Break"><span class="koboSpan" id="kobo.1792.1">two lists.</span></span></p></li> <li><span class="koboSpan" id="kobo.1793.1">Run the </span><a id="_idIndexMarker1316"/><span class="koboSpan" id="kobo.1794.1">application and check the generated schema. </span><span class="koboSpan" id="kobo.1794.2">You will find the union type defined </span><span class="No-Break"><span class="koboSpan" id="kobo.1795.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1796.1">
union SchoolItem = Equipment | Furnituretype Equipment {  id: UUID!  name: String!  description: String  condition: String!  brand: String!  quantity: Int!}type Furniture {  id: UUID!  name: String!  description: String  color: String!  material: String!  quantity: Int!}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1797.1">A union type is represented as a union of a list of object types using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1798.1">|</span></strong><span class="koboSpan" id="kobo.1799.1"> symbol. </span><span class="koboSpan" id="kobo.1799.2">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1800.1">SchoolItem</span></strong><span class="koboSpan" id="kobo.1801.1"> union type includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1802.1">Equipment</span></strong><span class="koboSpan" id="kobo.1803.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1804.1">Furniture</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1805.1">object types.</span></span></p></li> <li><span class="koboSpan" id="kobo.1806.1">Then, we</span><a id="_idIndexMarker1317"/><span class="koboSpan" id="kobo.1807.1"> can query the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1808.1">SchoolItem</span></strong><span class="koboSpan" id="kobo.1809.1"> union type, </span><span class="No-Break"><span class="koboSpan" id="kobo.1810.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1811.1">
query {  schoolItems {    __typename    ... </span><span class="koboSpan" id="kobo.1811.2">on Equipment {      id      name      description      condition      brand      quantity    }    ... </span><span class="koboSpan" id="kobo.1811.3">on Furniture {      id      name      description      color      material      quantity    }  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1812.1">The preceding query uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1813.1">... </span><span class="koboSpan" id="kobo.1813.2">on Equipment</span></strong><span class="koboSpan" id="kobo.1814.1"> syntax to specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1815.1">Equipment</span></strong><span class="koboSpan" id="kobo.1816.1"> object. </span><span class="koboSpan" id="kobo.1816.2">Then, we</span><a id="_idIndexMarker1318"/><span class="koboSpan" id="kobo.1817.1"> can retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1818.1">Equipment</span></strong><span class="koboSpan" id="kobo.1819.1"> properties or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1820.1">Furniture</span></strong><span class="koboSpan" id="kobo.1821.1"> properties. </span><span class="koboSpan" id="kobo.1821.2">The result is </span><span class="No-Break"><span class="koboSpan" id="kobo.1822.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1823.1">{  "data": {    "schoolItems": [      {        "__typename": "Equipment",        "id": "00000000-0000-0000-0000-000000000701",        "name": "Bunsen Burner",        "description": "Bunsen Burner",        "condition": "Good",        "brand": "Bunsen",        "quantity": 10      },      {        "__typename": "Furniture",        "id": "00000000-0000-0000-0000-000000000801",        "name": "Desk",        "description": "Desk",        "color": "Brown",        "material": "Wood",        "quantity": 20      },      ...    ]  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1824.1">In the</span><a id="_idIndexMarker1319"/><span class="koboSpan" id="kobo.1825.1"> response, you can see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1826.1">Equipment</span></strong><span class="koboSpan" id="kobo.1827.1"> object has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1828.1">condition</span></strong><span class="koboSpan" id="kobo.1829.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1830.1">brand</span></strong><span class="koboSpan" id="kobo.1831.1"> properties, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1832.1">Furniture</span></strong><span class="koboSpan" id="kobo.1833.1"> object has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1834.1">color</span></strong><span class="koboSpan" id="kobo.1835.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1836.1">material</span></strong><span class="koboSpan" id="kobo.1837.1"> properties. </span><span class="koboSpan" id="kobo.1837.2">However, even though the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1838.1">Equipment</span></strong><span class="koboSpan" id="kobo.1839.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1840.1">Furniture</span></strong><span class="koboSpan" id="kobo.1841.1"> objects have some of the same properties (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1842.1">Id</span></strong><span class="koboSpan" id="kobo.1843.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1844.1">Name</span></strong><span class="koboSpan" id="kobo.1845.1">, and so on.), the query must specify the properties for each object type. </span><span class="koboSpan" id="kobo.1845.2">For example, we cannot use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1846.1">following query:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1847.1">query {  schoolItems {    __typename    id    name   }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1848.1">The preceding query will cause an error, </span><span class="No-Break"><span class="koboSpan" id="kobo.1849.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1850.1">{  "errors": [    {      "message": "A union type cannot declare a field directly. </span><span class="koboSpan" id="kobo.1850.2">Use inline fragments or fragments instead.",      "locations": [        {          "line": 2,          "column": 15        }      ],      "path": [        "schoolItems"      ],      "extensions": {        "type": "SchoolItem",        "specifiedBy": "http://spec.graphql.org/October2021/   #sec-Field-Selections-on-Objects-Interfaces-and-Unions-Types"      }    }  ]}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1851.1">Please note that</span><a id="_idIndexMarker1320"/><span class="koboSpan" id="kobo.1852.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1853.1">SchoolItem</span></strong><span class="koboSpan" id="kobo.1854.1"> union type is not a base type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1855.1">Equipment</span></strong><span class="koboSpan" id="kobo.1856.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1857.1">Furniture</span></strong><span class="koboSpan" id="kobo.1858.1"> object types. </span><span class="koboSpan" id="kobo.1858.2">If you want to query the common</span><a id="_idTextAnchor525"/><span class="koboSpan" id="kobo.1859.1"> properties of the object types, you can use the interface type instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1860.1">union type.</span></span></p>
<h1 id="_idParaDest-273"><a id="_idTextAnchor526"/><span class="koboSpan" id="kobo.1861.1">Filtering, sorting, and pagination</span></h1>
<p><span class="koboSpan" id="kobo.1862.1">In this section, we will learn how to</span><a id="_idIndexMarker1321"/><span class="koboSpan" id="kobo.1863.1"> implement filtering, sorting, and pagination in HotChocolate. </span><span class="koboSpan" id="kobo.1863.2">These features are very important for a real-world application. </span><span class="koboSpan" id="kobo.1863.3">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1864.1">Student</span></strong><span class="koboSpan" id="kobo.1865.1"> object as an example to demonstrate how to implement these features. </span><span class="koboSpan" id="kobo.1865.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1866.1">Student</span></strong><span class="koboSpan" id="kobo.1867.1"> class is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.1868.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1869.1">
public class Student{
    public Guid Id { get; set; }
    public string FirstName { get; set; } = string.Empty;
    public string LastName { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public string? </span><span class="koboSpan" id="kobo.1869.2">Phone { get; set; }
    public string Grade { get; set; } = string.Empty;
    public DateOnly? </span><span class="koboSpan" id="kobo.1869.3">DateOfBirth { get; set; }
    public Guid GroupId { get; set; }
    public Group Group { get; set; } = default!;
    public List&lt;Course&gt; Courses { get; set; } = new();
    public List&lt;StudentCourse&gt; StudentCourses { get; set; } = new();
}</span></pre>
<p><span class="koboSpan" id="kobo.1870.1">To use</span><a id="_idIndexMarker1322"/><span class="koboSpan" id="kobo.1871.1"> filtering, sorting, and pagination, we need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1872.1">HotChocolate.Data</span></strong><span class="koboSpan" id="kobo.1873.1"> NuGet package. </span><span class="koboSpan" id="kobo.1873.2">If you already installed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1874.1">HotChocolate.Data.EntityFramework</span></strong><span class="koboSpan" id="kobo.1875.1"> package following the previous sections, you do not need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1876.1">HotChocolate.Data</span></strong><span class="koboSpan" id="kobo.1877.1"> package again. </span><span class="koboSpan" id="kobo.1877.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1878.1">HotChocolate.Data</span></strong><span class="koboSpan" id="kobo.1879.1"> package is a dependency of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1880.1">HotChocolate.Data.EntityFramework</span></strong><span class="koboSpan" id="kobo.1881.1"> package. </span><span class="koboSpan" id="kobo.1881.2">If not, you can install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1882.1">HotChocolate.Data</span></strong><span class="koboSpan" id="kobo.1883.1"> package u</span><a id="_idTextAnchor527"/><span class="koboSpan" id="kobo.1884.1">sing the </span><span class="No-Break"><span class="koboSpan" id="kobo.1885.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1886.1">
dotnet add package HotChocolate.Data</span></pre> <p><span class="koboSpan" id="kobo.1887.1">Let’s begin </span><span class="No-Break"><span class="koboSpan" id="kobo.1888.1">with filtering!</span></span></p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor528"/><span class="koboSpan" id="kobo.1889.1">Filtering</span></h2>
<p><span class="koboSpan" id="kobo.1890.1">HotChocolate </span><a id="_idIndexMarker1323"/><span class="koboSpan" id="kobo.1891.1">supports filtering on the object type. </span><span class="koboSpan" id="kobo.1891.2">A question is how we translate the GraphQL filter to the SQL-native queries. </span><span class="koboSpan" id="kobo.1891.3">If the resolver exposes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1892.1">IQueryable</span></strong><span class="koboSpan" id="kobo.1893.1"> interface, HotChocolate can translate the GraphQL filter to SQL-native queries automatically. </span><span class="koboSpan" id="kobo.1893.2">But we can also implement the filtering logic in the resolver manually. </span><span class="koboSpan" id="kobo.1893.3">In this section, we will explore how to use filtering </span><span class="No-Break"><span class="koboSpan" id="kobo.1894.1">in HotChocolate.</span></span></p>
<p><span class="koboSpan" id="kobo.1895.1">To enable filtering on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1896.1">Student</span></strong><span class="koboSpan" id="kobo.1897.1"> object type, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1898.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1899.1">First, we need to register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1900.1">Filtering</span></strong><span class="koboSpan" id="kobo.1901.1"> middleware in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1902.1">Program.cs</span></strong><span class="koboSpan" id="kobo.1903.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.1904.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1905.1">
builder.Services    .AddGraphQLServer()    // Omitted for brevity    .AddFiltering()    .AddMutationType&lt;Mutation&gt;();</span></pre></li> <li><span class="koboSpan" id="kobo.1906.1">Add a</span><a id="_idIndexMarker1324"/><span class="koboSpan" id="kobo.1907.1"> query field in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1908.1">Query</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1909.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1910.1">
public List&lt;Student&gt; Students { get; set; } = new();</span></pre></li> <li><span class="koboSpan" id="kobo.1911.1">Apply the filtering in the resolver of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1912.1">Students</span></strong><span class="koboSpan" id="kobo.1913.1"> field in </span><span class="No-Break"><span class="koboSpan" id="kobo.1914.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1915.1">QueryType</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1916.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1917.1">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UseFiltering()    .Resolve(async context =&gt;    {        var dbContextFactory = context.Service&lt;IDbContextFactory&lt;AppDbContext&gt;&gt;();        var dbContext = await dbContextFactory.CreateDbContextAsync();        var students = dbContext.Students.AsQueryable();        return students;    });</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1918.1">The preceding code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1919.1">UseFiltering()</span></strong><span class="koboSpan" id="kobo.1920.1"> method to enable filtering on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1921.1">Students</span></strong><span class="koboSpan" id="kobo.1922.1"> field. </span><span class="koboSpan" id="kobo.1922.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1923.1">AsQueryable()</span></strong><span class="koboSpan" id="kobo.1924.1"> method to expose the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1925.1">IQueryable</span></strong><span class="koboSpan" id="kobo.1926.1"> interface. </span><span class="koboSpan" id="kobo.1926.2">This allows HotChocolate to translate the GraphQL filter to SQL-native </span><span class="No-Break"><span class="koboSpan" id="kobo.1927.1">queries automatically.</span></span></p></li> <li><span class="koboSpan" id="kobo.1928.1">Run the</span><a id="_idIndexMarker1325"/><span class="koboSpan" id="kobo.1929.1"> application and check the generated schema. </span><span class="koboSpan" id="kobo.1929.2">You will find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1930.1">students</span></strong><span class="koboSpan" id="kobo.1931.1"> query has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1932.1">StudentFilterInput</span></strong><span class="koboSpan" id="kobo.1933.1"> filter, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1934.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1935.1">
students(where: StudentFilterInput): [Student!]!</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1936.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1937.1">StudentFilterInput</span></strong><span class="koboSpan" id="kobo.1938.1"> filter is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1939.1">input</span></strong><span class="koboSpan" id="kobo.1940.1"> type, </span><span class="No-Break"><span class="koboSpan" id="kobo.1941.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1942.1">input StudentFilterInput {  and: [StudentFilterInput!]  or: [StudentFilterInput!]  id: UuidOperationFilterInput  firstName: StringOperationFilterInput  lastName: StringOperationFilterInput  email: StringOperationFilterInput  phone: StringOperationFilterInput  grade: StringOperationFilterInput  dateOfBirth: DateOperationFilterInput}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1943.1">HotChocolate automatically inspects the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1944.1">Student</span></strong><span class="koboSpan" id="kobo.1945.1"> object type and generates the filter input type. </span><span class="koboSpan" id="kobo.1945.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1946.1">StudentFilterInput</span></strong><span class="koboSpan" id="kobo.1947.1"> filter includes all the properties of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1948.1">Student</span></strong><span class="koboSpan" id="kobo.1949.1"> object type </span><span class="No-Break"><span class="koboSpan" id="kobo.1950.1">by default.</span></span></p></li> <li><span class="koboSpan" id="kobo.1951.1">Next, we can filter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1952.1">students</span></strong><span class="koboSpan" id="kobo.1953.1"> query, </span><span class="No-Break"><span class="koboSpan" id="kobo.1954.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1955.1">
query {  students(where: { firstName: { eq: "John" } }) {    id    firstName    lastName    email    phone    grade    dateOfBirth  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1956.1">The </span><a id="_idIndexMarker1326"/><span class="koboSpan" id="kobo.1957.1">preceding query uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1958.1">where</span></strong><span class="koboSpan" id="kobo.1959.1"> argument to filter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1960.1">Student</span></strong><span class="koboSpan" id="kobo.1961.1"> objects. </span><span class="koboSpan" id="kobo.1961.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1962.1">where</span></strong><span class="koboSpan" id="kobo.1963.1"> argument is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1964.1">StudentFilterInput</span></strong><span class="koboSpan" id="kobo.1965.1"> type. </span><span class="koboSpan" id="kobo.1965.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1966.1">StudentFilterInput</span></strong><span class="koboSpan" id="kobo.1967.1"> type includes all the properties of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1968.1">Student</span></strong><span class="koboSpan" id="kobo.1969.1"> object type. </span><span class="koboSpan" id="kobo.1969.2">In this case, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1970.1">firstName</span></strong><span class="koboSpan" id="kobo.1971.1"> property to filter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1972.1">Student</span></strong><span class="koboSpan" id="kobo.1973.1"> objects. </span><span class="koboSpan" id="kobo.1973.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1974.1">firstName</span></strong><span class="koboSpan" id="kobo.1975.1"> property is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1976.1">StringOperationFilterInput</span></strong><span class="koboSpan" id="kobo.1977.1"> type. </span><span class="koboSpan" id="kobo.1977.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1978.1">StringOperationFilterInput</span></strong><span class="koboSpan" id="kobo.1979.1"> type includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.1980.1">following operators:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.1981.1">eq</span></strong><span class="koboSpan" id="kobo.1982.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.1983.1">Equal to</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.1984.1">neq</span></strong><span class="koboSpan" id="kobo.1985.1">: Not </span><span class="No-Break"><span class="koboSpan" id="kobo.1986.1">equal to</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.1987.1">in</span></strong><span class="koboSpan" id="kobo.1988.1">: In </span><span class="No-Break"><span class="koboSpan" id="kobo.1989.1">the list</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.1990.1">nin</span></strong><span class="koboSpan" id="kobo.1991.1">: Not in </span><span class="No-Break"><span class="koboSpan" id="kobo.1992.1">the list</span></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1993.1">contains</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1994.1">: Contains</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.1995.1">notContains</span></strong><span class="koboSpan" id="kobo.1996.1">: Does </span><span class="No-Break"><span class="koboSpan" id="kobo.1997.1">not contain</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.1998.1">startsWith</span></strong><span class="koboSpan" id="kobo.1999.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.2000.1">Starts with</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.2001.1">nstartsWith</span></strong><span class="koboSpan" id="kobo.2002.1">: Does not </span><span class="No-Break"><span class="koboSpan" id="kobo.2003.1">start with</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.2004.1">endsWith</span></strong><span class="koboSpan" id="kobo.2005.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.2006.1">Ends with</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.2007.1">nendsWith</span></strong><span class="koboSpan" id="kobo.2008.1">: Does not </span><span class="No-Break"><span class="koboSpan" id="kobo.2009.1">end with</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.2010.1">The result is </span><span class="No-Break"><span class="koboSpan" id="kobo.2011.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2012.1">{  "data": {    "students": [      {        "id": "00000000-0000-0000-0000-000000000901",        "firstName": "John",        "lastName": "Doe",        "email": "",        "phone": null,        "grade": "",        "dateOfBirth": "2000-01-01"      }    ]  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2013.1">You can find </span><a id="_idIndexMarker1327"/><span class="koboSpan" id="kobo.2014.1">the generated SQL query in the logs, </span><span class="No-Break"><span class="koboSpan" id="kobo.2015.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2016.1">info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (36ms) [Parameters=[@__p_0='?' </span><span class="koboSpan" id="kobo.2016.2">(Size = 32)], CommandType='Text',    CommandTimeout='30']      SELECT [s].[Id], [s].[DateOfBirth], [s].[Email], [s].[FirstName], [s].[Grade], [s].[GroupId], [s].   [LastName], [s].[Phone]      FROM [Students] AS [s]      WHERE [s].[FirstName] = @__p_0</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2017.1">The preceding SQL query uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2018.1">WHERE</span></strong><span class="koboSpan" id="kobo.2019.1"> clause to filter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2020.1">Student</span></strong><span class="koboSpan" id="kobo.2021.1"> objects, which means the filtering is done in </span><span class="No-Break"><span class="koboSpan" id="kobo.2022.1">the database.</span></span></p></li> <li><span class="koboSpan" id="kobo.2023.1">The filtering</span><a id="_idIndexMarker1328"/><span class="koboSpan" id="kobo.2024.1"> can be defined in the variable as well. </span><span class="koboSpan" id="kobo.2024.2">For example, we can use the following query to filter the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2025.1">Student</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2026.1"> objects:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2027.1">
query ($where: StudentFilterInput) {  students(where: $where) {    id    firstName    lastName    email    phone    grade    dateOfBirth  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2028.1">The variable can be defined </span><span class="No-Break"><span class="koboSpan" id="kobo.2029.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2030.1">{  "where": {    "firstName": {      "eq": "John"    }  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2031.1">The result is the same as the previous query. </span><span class="koboSpan" id="kobo.2031.2">You can also try other operators to filter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2032.1">Student</span></strong><span class="koboSpan" id="kobo.2033.1"> objects. </span><span class="koboSpan" id="kobo.2033.2">For example, the following variable uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2034.1">in</span></strong><span class="koboSpan" id="kobo.2035.1"> operator to filter the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2036.1">Student</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2037.1"> objects:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2038.1">{  "where": {    "firstName": {      "in": ["John", "Jane"]    }  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2039.1">The</span><a id="_idIndexMarker1329"/><span class="koboSpan" id="kobo.2040.1"> following variable uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2041.1">gt</span></strong><span class="koboSpan" id="kobo.2042.1"> operator to filter the students who were born </span><span class="No-Break"><span class="koboSpan" id="kobo.2043.1">after </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2044.1">2001-01-01</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2045.1">:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2046.1">{  "where": {    "dateOfBirth": {      "gt": "2001-01-01"    }  }}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2047.1">The generated filter input type contains all the properties of the object type. </span><span class="koboSpan" id="kobo.2047.2">Sometimes, we do not need to filter all the properties. </span><span class="koboSpan" id="kobo.2047.3">For example, we may want to allow filtering on a few properties only. </span><span class="koboSpan" id="kobo.2047.4">In this case, we can create a custom filter input type and specify the properties we want to filter. </span><span class="koboSpan" id="kobo.2047.5">Follow these steps to create a custom filter </span><span class="No-Break"><span class="koboSpan" id="kobo.2048.1">input type:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2049.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2050.1">Filters</span></strong><span class="koboSpan" id="kobo.2051.1"> folder in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2052.1">GraphQL</span></strong><span class="koboSpan" id="kobo.2053.1"> folder. </span><span class="koboSpan" id="kobo.2053.2">Then, add a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.2054.1">StudentFilterType</span></strong><span class="koboSpan" id="kobo.2055.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.2056.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2057.1">
public class StudentFilterType : FilterInputType&lt;Student&gt;{    protected override void Configure(IFilterInputTypeDescriptor&lt;Student&gt; descriptor)    {        descriptor.BindFieldsExplicitly();        descriptor.Field(t =&gt; t.Id);        descriptor.Field(t =&gt; t.GroupId);        descriptor.Field(t =&gt; t.FirstName);        descriptor.Field(t =&gt; t.LastName);        descriptor.Field(t =&gt; t.DateOfBirth);    }}</span></pre></li> <li><span class="koboSpan" id="kobo.2058.1">Then, we</span><a id="_idIndexMarker1330"/><span class="koboSpan" id="kobo.2059.1"> need to specify the filter input type in the resolver. </span><span class="koboSpan" id="kobo.2059.2">Update the resolver for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2060.1">students</span></strong><span class="koboSpan" id="kobo.2061.1"> query, </span><span class="No-Break"><span class="koboSpan" id="kobo.2062.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2063.1">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UseFiltering&lt;StudentFilterType&gt;()    // Omitted for brevity</span></pre></li> <li><span class="koboSpan" id="kobo.2064.1">Check the generated schema. </span><span class="koboSpan" id="kobo.2064.2">You will find </span><strong class="source-inline"><span class="koboSpan" id="kobo.2065.1">StudentFilterInput</span></strong><span class="koboSpan" id="kobo.2066.1"> only contains the fields we specified in </span><strong class="source-inline"><span class="koboSpan" id="kobo.2067.1">StudentFilterType</span></strong><span class="koboSpan" id="kobo.2068.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.2069.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2070.1">
input StudentFilterInput {  and: [StudentFilterInput!]  or: [StudentFilterInput!]  id: UuidOperationFilterInput  groupId: UuidOperationFilterInput  firstName: StringOperationFilterInput  lastName: StringOperationFilterInput  dateOfBirth: DateOperationFilterInput}</span></pre></li> <li><span class="koboSpan" id="kobo.2071.1">If the </span><a id="_idIndexMarker1331"/><span class="koboSpan" id="kobo.2072.1">model has many properties but we only want to ignore a few properties, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2073.1">Ignore()</span></strong><span class="koboSpan" id="kobo.2074.1"> method to ignore the properties we do not want to filter. </span><span class="koboSpan" id="kobo.2074.2">For example, we can update </span><strong class="source-inline"><span class="koboSpan" id="kobo.2075.1">StudentFilterType</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2076.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2077.1">
override protected void Configure(IFilterInputTypeDescriptor&lt;Student&gt; descriptor){    descriptor.BindFieldsImplicitly();    descriptor.Ignore(t =&gt; t.Group);    descriptor.Ignore(t =&gt; t.Courses);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2078.1">In the preceding code, all the properties of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2079.1">Student</span></strong><span class="koboSpan" id="kobo.2080.1"> object type will be included in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2081.1">StudentFilterInput</span></strong><span class="koboSpan" id="kobo.2082.1"> filter except the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2083.1">Group</span></strong><span class="koboSpan" id="kobo.2084.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2085.1">Courses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2086.1"> properties.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.2087.1">By default, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2088.1">StringOperationFilterInput</span></strong><span class="koboSpan" id="kobo.2089.1"> includes many operations, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.2090.1">eq</span></strong><span class="koboSpan" id="kobo.2091.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2092.1">neq</span></strong><span class="koboSpan" id="kobo.2093.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2094.1">in</span></strong><span class="koboSpan" id="kobo.2095.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2096.1">nin</span></strong><span class="koboSpan" id="kobo.2097.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2098.1">contains</span></strong><span class="koboSpan" id="kobo.2099.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2100.1">notContains</span></strong><span class="koboSpan" id="kobo.2101.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2102.1">startsWith</span></strong><span class="koboSpan" id="kobo.2103.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2104.1">endsWith</span></strong><span class="koboSpan" id="kobo.2105.1">. </span><span class="koboSpan" id="kobo.2105.2">If we do not want to include all these operations, we can specify the operations by using a custom operation filter. </span><span class="koboSpan" id="kobo.2105.3">For example, we can define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2106.1">StudentStringOperationFilterInputType</span></strong><span class="koboSpan" id="kobo.2107.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.2108.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2109.1">public class StudentStringOperationFilterInputType : StringOperationFilterInputType{    protected override void Configure(IFilterInputTypeDescriptor descriptor)    {        descriptor.Operation(DefaultFilterOperations.Equals).Type&lt;StringType&gt;();        descriptor.Operation(DefaultFilterOperations.Contains).Type&lt;StringType&gt;();    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2110.1">The </span><a id="_idIndexMarker1332"/><span class="koboSpan" id="kobo.2111.1">preceding code defines a custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.2112.1">StudentStringOperationFilterInputType</span></strong><span class="koboSpan" id="kobo.2113.1"> filter. </span><span class="koboSpan" id="kobo.2113.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2114.1">StudentStringOperationFilterInputType</span></strong><span class="koboSpan" id="kobo.2115.1"> filter only includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2116.1">eq</span></strong><span class="koboSpan" id="kobo.2117.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2118.1">contains</span></strong><span class="koboSpan" id="kobo.2119.1"> operations. </span><span class="koboSpan" id="kobo.2119.2">Then, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2120.1">StudentStringOperationFilterInputType</span></strong><span class="koboSpan" id="kobo.2121.1"> filter in </span><strong class="source-inline"><span class="koboSpan" id="kobo.2122.1">StudentFilterType</span></strong><span class="koboSpan" id="kobo.2123.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.2124.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2125.1">override protected void Configure(IFilterInputTypeDescriptor&lt;Student&gt; descriptor){    // Omitted for brevity    descriptor.Field(t =&gt; t.FirstName).Type&lt;StudentStringOperationFilterInputType&gt;();    descriptor.Field(t =&gt; t.LastName).Type&lt;StudentStringOperationFilterInputType&gt;();}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2126.1">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2127.1">StudentFilterInput</span></strong><span class="koboSpan" id="kobo.2128.1"> filter only includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2129.1">eq</span></strong><span class="koboSpan" id="kobo.2130.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2131.1">contains</span></strong><span class="koboSpan" id="kobo.2132.1"> operations for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2133.1">FirstName</span></strong><span class="koboSpan" id="kobo.2134.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2135.1">LastName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2136.1"> properties.</span></span></p></li> <li><span class="koboSpan" id="kobo.2137.1">The filter supports </span><strong class="source-inline"><span class="koboSpan" id="kobo.2138.1">and</span></strong><span class="koboSpan" id="kobo.2139.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2140.1">or</span></strong><span class="koboSpan" id="kobo.2141.1"> operations. </span><span class="koboSpan" id="kobo.2141.2">You can find an </span><strong class="source-inline"><span class="koboSpan" id="kobo.2142.1">and</span></strong><span class="koboSpan" id="kobo.2143.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2144.1">or</span></strong><span class="koboSpan" id="kobo.2145.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2146.1">StudentFilterInput</span></strong><span class="koboSpan" id="kobo.2147.1"> filter. </span><span class="koboSpan" id="kobo.2147.2">These two fields are used to combine multiple filters. </span><span class="koboSpan" id="kobo.2147.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2148.1">and</span></strong><span class="koboSpan" id="kobo.2149.1"> field means the filter must match all the conditions. </span><span class="koboSpan" id="kobo.2149.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2150.1">or</span></strong><span class="koboSpan" id="kobo.2151.1"> field means the filter must match at least one condition. </span><span class="koboSpan" id="kobo.2151.2">For example, we</span><a id="_idIndexMarker1333"/><span class="koboSpan" id="kobo.2152.1"> can use the following query to filter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2153.1">Student</span></strong><span class="koboSpan" id="kobo.2154.1"> objects whose first name is John and who were born after 2001-01-01 using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2155.1">and</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2156.1"> operation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2157.1">
query {  students(where: { and: [{ firstName: { eq: "John" } }, { dateOfBirth: { gt: "2001-01-01" } }] }) {    id    firstName    lastName    email    phone    grade    dateOfBirth  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2158.1">The following query filters the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2159.1">Student</span></strong><span class="koboSpan" id="kobo.2160.1"> objects whose first name is John or last name is Doe using </span><span class="No-Break"><span class="koboSpan" id="kobo.2161.1">query variables:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2162.1">query ($where: StudentFilterInput) {  students(where: $filter) {    id    firstName    lastName    email    phone    grade    dateOfBirth  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2163.1">The variables </span><a id="_idIndexMarker1334"/><span class="koboSpan" id="kobo.2164.1">are defined </span><span class="No-Break"><span class="koboSpan" id="kobo.2165.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2166.1">{  "where": {    "or": [      {        "firstName": {          "eq": "John"        }      },      {        "lastName": {          "eq": "Doe"        }      }    ]  }}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2167.1">In the preceding examples, we expose the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2168.1">IQueryable</span></strong><span class="koboSpan" id="kobo.2169.1"> interface in the resolver, so HotChocolate can translate the GraphQL filter to SQL-native queries automatically. </span><span class="koboSpan" id="kobo.2169.2">However, sometimes, we cannot expose the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2170.1">IQueryable</span></strong><span class="koboSpan" id="kobo.2171.1"> interface in the resolver. </span><span class="koboSpan" id="kobo.2171.2">In this case, we need to implement the filtering logic in the resolver manually. </span><span class="koboSpan" id="kobo.2171.3">The code would be more complex. </span><span class="koboSpan" id="kobo.2171.4">Let</span><a id="_idIndexMarker1335"/><span class="koboSpan" id="kobo.2172.1"> us see how to implement the filtering logic in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2173.1">resolver manually:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2174.1">The methods to retrieve the list of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2175.1">Student</span></strong><span class="koboSpan" id="kobo.2176.1"> type by the group ID are defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2177.1">IStudentService</span></strong><span class="koboSpan" id="kobo.2178.1"> interface, </span><span class="No-Break"><span class="koboSpan" id="kobo.2179.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2180.1">
public interface IStudentService{    // Omitted for brevity    Task&lt;List&lt;Student&gt;&gt; GetStudentsByGroupIdAsync(Guid groupId);    Task&lt;List&lt;Student&gt;&gt; GetStudentsByGroupIdsAsync(List&lt;Guid&gt; groupIds);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2181.1">We have two methods for </span><strong class="source-inline"><span class="koboSpan" id="kobo.2182.1">eq</span></strong><span class="koboSpan" id="kobo.2183.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2184.1">in</span></strong><span class="koboSpan" id="kobo.2185.1"> operations. </span><span class="koboSpan" id="kobo.2185.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2186.1">GetStudentsByGroupIdAsync()</span></strong><span class="koboSpan" id="kobo.2187.1"> method retrieves the list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2188.1">Student</span></strong><span class="koboSpan" id="kobo.2189.1"> objects by the group ID. </span><span class="koboSpan" id="kobo.2189.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2190.1">GetStudentsByGroupIdsAsync()</span></strong><span class="koboSpan" id="kobo.2191.1"> method retrieves the list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2192.1">Student</span></strong><span class="koboSpan" id="kobo.2193.1"> objects by the list of group IDs. </span><span class="koboSpan" id="kobo.2193.2">These two methods return the list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2194.1">Student</span></strong><span class="koboSpan" id="kobo.2195.1"> objects instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2196.1">IQueryable</span></strong><span class="koboSpan" id="kobo.2197.1"> interface. </span><span class="koboSpan" id="kobo.2197.2">So, we need to implement the filtering logic in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2198.1">resolver manually.</span></span></p></li> <li><span class="koboSpan" id="kobo.2199.1">Define a customized filter for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2200.1">Student</span></strong><span class="koboSpan" id="kobo.2201.1"> type </span><span class="No-Break"><span class="koboSpan" id="kobo.2202.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2203.1">
public class CustomStudentFilterType : FilterInputType&lt;Student&gt;{    protected override void Configure(IFilterInputTypeDescriptor&lt;Student&gt; descriptor)    {        descriptor.BindFieldsExplicitly();        descriptor.Name("CustomStudentFilterInput");        descriptor.AllowAnd(false).AllowOr(false);        descriptor.Field(t =&gt; t.GroupId).Type&lt;CustomStudentGuidOperationFilterInputType&gt;();    }}public class CustomStudentGuidOperationFilterInputType : UuidOperationFilterInputType{    protected override void Configure(IFilterInputTypeDescriptor descriptor)    {        descriptor.Name("CustomStudentGuidOperationFilterInput");        descriptor.Operation(DefaultFilterOperations.Equals).Type&lt;IdType&gt;();        descriptor.Operation(DefaultFilterOperations.In).Type&lt;ListType&lt;IdType&gt;&gt;();    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2204.1">In the preceding code, we</span><a id="_idIndexMarker1336"/><span class="koboSpan" id="kobo.2205.1"> define a custom filter input type named </span><strong class="source-inline"><span class="koboSpan" id="kobo.2206.1">CustomStudentFilterInput</span></strong><span class="koboSpan" id="kobo.2207.1">. </span><span class="koboSpan" id="kobo.2207.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2208.1">CustomStudentFilterInput</span></strong><span class="koboSpan" id="kobo.2209.1"> filter only includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2210.1">GroupId</span></strong><span class="koboSpan" id="kobo.2211.1"> property. </span><span class="koboSpan" id="kobo.2211.2">To make the filter more simple, we disable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2212.1">and</span></strong><span class="koboSpan" id="kobo.2213.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2214.1">or</span></strong><span class="koboSpan" id="kobo.2215.1"> operations. </span><span class="koboSpan" id="kobo.2215.2">Then, we define a custom filter input type named </span><strong class="source-inline"><span class="koboSpan" id="kobo.2216.1">CustomStudentGuidOperationFilterInput</span></strong><span class="koboSpan" id="kobo.2217.1">. </span><span class="koboSpan" id="kobo.2217.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2218.1">CustomStudentGuidOperationFilterInput</span></strong><span class="koboSpan" id="kobo.2219.1"> filter only includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2220.1">eq</span></strong><span class="koboSpan" id="kobo.2221.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2222.1">in</span></strong><span class="koboSpan" id="kobo.2223.1"> operations. </span><span class="koboSpan" id="kobo.2223.2">Note that we need to specify the names of the filter input types. </span><span class="koboSpan" id="kobo.2223.3">Otherwise, HotChocolate will report name conflicts because we already have a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2224.1">StudentFilterInput</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2225.1"> filter.</span></span></p></li> <li><span class="koboSpan" id="kobo.2226.1">Add a </span><a id="_idIndexMarker1337"/><span class="koboSpan" id="kobo.2227.1">new query type in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2228.1">Query</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2229.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2230.1">
public List&lt;Student&gt; StudentsWithCustomFilter { get; set; } = new();</span></pre></li> <li><span class="koboSpan" id="kobo.2231.1">Configure the resolver and manually filter the data in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2232.1">QueryType</span></strong><span class="koboSpan" id="kobo.2233.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.2234.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2235.1">
descriptor.Field(x =&gt; x.StudentsWithCustomFilter)    .Description("This is the list of students in the school.")    .UseFiltering&lt;CustomStudentFilterType&gt;()    .Resolve(async context =&gt;    {        var service = context.Service&lt;IStudentService&gt;();        // The following code uses the custom filter.        var filter = context.GetFilterContext()?.ToDictionary();        if (filter != null &amp;&amp; filter.ContainsKey("groupId"))        {            var groupFilter = filter["groupId"]! </span><span class="koboSpan" id="kobo.2235.2">as Dictionary&lt;string, object&gt;;            if (groupFilter != null &amp;&amp; groupFilter.ContainsKey("eq"))            {                if (!Guid.TryParse(groupFilter["eq"].ToString(), out var groupId))                {                    throw new ArgumentException("Invalid group id", nameof(groupId));                }                var students = await service.GetStudentsByGroupIdAsync(groupId);                return students;            }            if (groupFilter != null &amp;&amp; groupFilter.ContainsKey("in"))            {                if (groupFilter["in"] is not IEnumerable&lt;string&gt; groupIds)                {                    throw new ArgumentException("Invalid group ids", nameof(groupIds));                }                groupIds = groupIds.ToList();                if (groupIds.Any())                {                    var students =                        await service.GetStudentsByGroupIdsAsync(groupIds                            .Select(x =&gt; Guid.Parse(x.ToString())).ToList());                    return students;                }                return new List&lt;Student&gt;();            }        }        var allStudents = await service.GetStudentsAsync();        return allStudents;    });</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2236.1">The</span><a id="_idIndexMarker1338"/><span class="koboSpan" id="kobo.2237.1"> preceding code is a bit complex. </span><span class="koboSpan" id="kobo.2237.2">We need to get the filter from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2238.1">context</span></strong><span class="koboSpan" id="kobo.2239.1"> object. </span><span class="koboSpan" id="kobo.2239.2">Then, we check whether the filter contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2240.1">groupId</span></strong><span class="koboSpan" id="kobo.2241.1"> property. </span><span class="koboSpan" id="kobo.2241.2">If the filter contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2242.1">groupId</span></strong><span class="koboSpan" id="kobo.2243.1"> property, we check whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2244.1">eq</span></strong><span class="koboSpan" id="kobo.2245.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.2246.1">in</span></strong><span class="koboSpan" id="kobo.2247.1"> operation is specified. </span><span class="koboSpan" id="kobo.2247.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2248.1">eq</span></strong><span class="koboSpan" id="kobo.2249.1"> operation is specified, we retrieve the list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2250.1">Student</span></strong><span class="koboSpan" id="kobo.2251.1"> objects by the group ID. </span><span class="koboSpan" id="kobo.2251.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2252.1">in</span></strong><span class="koboSpan" id="kobo.2253.1"> operation is specified, we retrieve the list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2254.1">Student</span></strong><span class="koboSpan" id="kobo.2255.1"> objects by the list of group IDs. </span><span class="koboSpan" id="kobo.2255.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2256.1">eq</span></strong><span class="koboSpan" id="kobo.2257.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.2258.1">in</span></strong><span class="koboSpan" id="kobo.2259.1"> operation is not specified, we retrieve all the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2260.1">Student</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2261.1"> objects.</span></span></p></li> <li><span class="koboSpan" id="kobo.2262.1">Run the application and check the generated schema. </span><span class="koboSpan" id="kobo.2262.2">You will find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2263.1">studentsWithCustomFilter</span></strong><span class="koboSpan" id="kobo.2264.1"> query has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2265.1">CustomStudentFilterInput</span></strong><span class="koboSpan" id="kobo.2266.1"> filter, as </span><span class="No-Break"><span class="koboSpan" id="kobo.2267.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2268.1">
input CustomStudentFilterInput {  groupId: CustomStudentGuidOperationFilterInput}input CustomStudentGuidOperationFilterInput {  and: [CustomStudentGuidOperationFilterInput!]  or: [CustomStudentGuidOperationFilterInput!]  eq: ID  in: [ID]}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2269.1">Then, we</span><a id="_idIndexMarker1339"/><span class="koboSpan" id="kobo.2270.1"> can use the following query to filter the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2271.1">Student</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2272.1"> objects:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2273.1">query ($where: CustomStudentFilterInput) {  studentsWithCustomFilter(where: $where) {    id    firstName    lastName    email    phone    grade    dateOfBirth  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2274.1">To filter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2275.1">Student</span></strong><span class="koboSpan" id="kobo.2276.1"> objects by </span><strong class="source-inline"><span class="koboSpan" id="kobo.2277.1">groupId</span></strong><span class="koboSpan" id="kobo.2278.1">, we can define the </span><span class="No-Break"><span class="koboSpan" id="kobo.2279.1">following variable:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2280.1">{  "where": {    "groupId": {      "eq": "00000000-0000-0000-0000-000000000201"    }  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2281.1">To filter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2282.1">Student</span></strong><span class="koboSpan" id="kobo.2283.1"> objects by the list of group IDs, we can define the </span><span class="No-Break"><span class="koboSpan" id="kobo.2284.1">following variable:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2285.1">{  "where": {    "groupId": {      "in": ["00000000-0000-0000-0000-000000000201", "00000000-0000-0000-0000-000000000202"]    }  }}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2286.1">As the filtering</span><a id="_idIndexMarker1340"/><span class="koboSpan" id="kobo.2287.1"> variables may vary in different cases, the logic to filter the data may be different. </span><span class="koboSpan" id="kobo.2287.2">It is recommended to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2288.1">IQueryable</span></strong><span class="koboSpan" id="kobo.2289.1"> int</span><a id="_idTextAnchor529"/><span class="koboSpan" id="kobo.2290.1">erface if possible, so that HotChocolate can translate the GraphQL filter to SQL-native </span><span class="No-Break"><span class="koboSpan" id="kobo.2291.1">queries automatically.</span></span></p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor530"/><span class="koboSpan" id="kobo.2292.1">Sorting</span></h2>
<p><span class="koboSpan" id="kobo.2293.1">In this section, we will learn how to </span><a id="_idIndexMarker1341"/><span class="koboSpan" id="kobo.2294.1">use sorting in HotChocolate. </span><span class="koboSpan" id="kobo.2294.2">The sorting is similar to filtering. </span><span class="koboSpan" id="kobo.2294.3">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2295.1">UseSorting()</span></strong><span class="koboSpan" id="kobo.2296.1"> method to enable sorting on the object type. </span><span class="koboSpan" id="kobo.2296.2">If we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2297.1">IQueryable</span></strong><span class="koboSpan" id="kobo.2298.1"> interface in the resolver, HotChocolate can translate the GraphQL sorting to SQL-native queries automatically. </span><span class="koboSpan" id="kobo.2298.2">Otherwise, we need to implement the sorting logic in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2299.1">resolver manually.</span></span></p>
<p><span class="koboSpan" id="kobo.2300.1">To enable</span><a id="_idIndexMarker1342"/><span class="koboSpan" id="kobo.2301.1"> sorting on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2302.1">Student</span></strong><span class="koboSpan" id="kobo.2303.1"> object type, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2304.1">HotChocolate.Data</span></strong><span class="koboSpan" id="kobo.2305.1"> package is required. </span><span class="koboSpan" id="kobo.2305.2">Follow the step just before the </span><em class="italic"><span class="koboSpan" id="kobo.2306.1">Filtering</span></em><span class="koboSpan" id="kobo.2307.1"> section to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2308.1">HotChocolate.Data</span></strong><span class="koboSpan" id="kobo.2309.1"> package if you have not installed it yet. </span><span class="koboSpan" id="kobo.2309.2">Then, follow these </span><a id="_idIndexMarker1343"/><span class="koboSpan" id="kobo.2310.1">steps to enable sorting on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2311.1">Student</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2312.1">object type:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2313.1">Register the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2314.1">Sorting</span></strong><span class="koboSpan" id="kobo.2315.1"> middleware in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2316.1">Program.cs</span></strong><span class="koboSpan" id="kobo.2317.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.2318.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2319.1">
builder.Services    .AddGraphQLServer()    // Omitted for brevity    .AddSorting()    .AddMutationType&lt;Mutation&gt;();</span></pre></li> <li><span class="koboSpan" id="kobo.2320.1">Update the resolver for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2321.1">students</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2322.1"> query:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2323.1">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UseFiltering&lt;StudentFilterType&gt;()    .UseSorting()    // Omitted for brevity</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2324.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.2325.1">UseSorting()</span></strong><span class="koboSpan" id="kobo.2326.1"> must be placed </span><span class="No-Break"><span class="koboSpan" id="kobo.2327.1">after </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2328.1">UseFiltering</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2329.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.2330.1">Then, run the application and check the generated schema. </span><span class="koboSpan" id="kobo.2330.2">You will find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2331.1">students</span></strong><span class="koboSpan" id="kobo.2332.1"> query has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.2333.1">orderBy</span></strong><span class="koboSpan" id="kobo.2334.1"> argument, as </span><span class="No-Break"><span class="koboSpan" id="kobo.2335.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2336.1">
students(where: StudentFilterInput, order: [StudentSortInput!]): [Student!]!</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2337.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2338.1">order</span></strong><span class="koboSpan" id="kobo.2339.1"> argument is an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2340.1">StudentSortInput</span></strong><span class="koboSpan" id="kobo.2341.1"> types, </span><span class="No-Break"><span class="koboSpan" id="kobo.2342.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2343.1">input StudentSortInput {  id: SortEnumType  firstName: SortEnumType  lastName: SortEnumType  email: SortEnumType  phone: SortEnumType  grade: SortEnumType  dateOfBirth: SortEnumType  groupId: SortEnumType  group: GroupSortInput}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2344.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2345.1">StudentSortInput</span></strong><span class="koboSpan" id="kobo.2346.1"> type includes all the properties of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2347.1">Student</span></strong><span class="koboSpan" id="kobo.2348.1"> object</span><a id="_idIndexMarker1344"/><span class="koboSpan" id="kobo.2349.1"> type. </span><span class="koboSpan" id="kobo.2349.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2350.1">SortEnumType</span></strong><span class="koboSpan" id="kobo.2351.1"> type is an enum type, </span><span class="No-Break"><span class="koboSpan" id="kobo.2352.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2353.1">enum SortEnumType {  ASC  DESC}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2354.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2355.1">SortDirection</span></strong><span class="koboSpan" id="kobo.2356.1"> type includes two values: </span><strong class="source-inline"><span class="koboSpan" id="kobo.2357.1">ASC</span></strong><span class="koboSpan" id="kobo.2358.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2359.1">DESC</span></strong><span class="koboSpan" id="kobo.2360.1">. </span><span class="koboSpan" id="kobo.2360.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2361.1">ASC</span></strong><span class="koboSpan" id="kobo.2362.1"> value means the sorting is ascending. </span><span class="koboSpan" id="kobo.2362.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2363.1">DESC</span></strong><span class="koboSpan" id="kobo.2364.1"> value means the sorting </span><span class="No-Break"><span class="koboSpan" id="kobo.2365.1">is descending.</span></span></p></li> <li><span class="koboSpan" id="kobo.2366.1">Next, we can query the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2367.1">Student</span></strong><span class="koboSpan" id="kobo.2368.1"> type with sorting. </span><span class="koboSpan" id="kobo.2368.2">The following query will sort the results by </span><span class="No-Break"><span class="koboSpan" id="kobo.2369.1">first name:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2370.1">
query ($order: [StudentSortInput!]) {  students(order: $order) {    id    firstName    lastName    email    phone    grade    dateOfBirth  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2371.1">The query variable is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.2372.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2373.1">{  "order": [    {      "firstName": "ASC"    }  ]}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2374.1">The</span><a id="_idIndexMarker1345"/><span class="koboSpan" id="kobo.2375.1"> sorting variable supports multiple properties. </span><span class="koboSpan" id="kobo.2375.2">For example, the following query variable will sort the results by first name and </span><span class="No-Break"><span class="koboSpan" id="kobo.2376.1">last name:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2377.1">{  "order": [     {        "firstName": "ASC"     },     {        "lastName": "ASC"     }  ]}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2378.1">You can check the generated SQL query in the logs </span><span class="No-Break"><span class="koboSpan" id="kobo.2379.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2380.1">info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (3ms) [Parameters=[], CommandType='Text', CommandTimeout='30']      SELECT [s].[Id], [s].[DateOfBirth], [s].[Email], [s].[FirstName], [s].[Grade], [s].[GroupId], [s].   [LastName], [s].[Phone]      FROM [Students] AS [s]      ORDER BY [s].[FirstName], [s].[LastName]</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2381.1">The preceding SQL query uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2382.1">ORDER BY</span></strong><span class="koboSpan" id="kobo.2383.1"> clause to sort the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2384.1">Student</span></strong><span class="koboSpan" id="kobo.2385.1"> objects, which means the sorting is done in </span><span class="No-Break"><span class="koboSpan" id="kobo.2386.1">the database.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.2387.1">Similar to filtering, the </span><a id="_idIndexMarker1346"/><span class="koboSpan" id="kobo.2388.1">default sorting includes all the properties of the object type. </span><span class="koboSpan" id="kobo.2388.2">If we want to sort on specific properties only, we can create a custom sort input type and specify the properties we want to sort. </span><span class="koboSpan" id="kobo.2388.3">Follow these steps to create a custom sort </span><span class="No-Break"><span class="koboSpan" id="kobo.2389.1">input type:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2390.1">Create a folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.2391.1">Sorts</span></strong><span class="koboSpan" id="kobo.2392.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2393.1">GraphQL</span></strong><span class="koboSpan" id="kobo.2394.1"> folder. </span><span class="koboSpan" id="kobo.2394.2">Add a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.2395.1">StudentSortType</span></strong><span class="koboSpan" id="kobo.2396.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.2397.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2398.1">
public class StudentSortType : SortInputType&lt;Student&gt;{    protected override void Configure(ISortInputTypeDescriptor&lt;Student&gt; descriptor)    {        descriptor.BindFieldsExplicitly();        descriptor.Field(x =&gt; x.FirstName);        descriptor.Field(x =&gt; x.LastName);        descriptor.Field(x =&gt; x.DateOfBirth);    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2399.1">The preceding code defines a custom sort input type, which only includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2400.1">FirstName</span></strong><span class="koboSpan" id="kobo.2401.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2402.1">LastName</span></strong><span class="koboSpan" id="kobo.2403.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2404.1">DateOfBirth</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2405.1"> properties.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.2406.1">Similar to </span><a id="_idIndexMarker1347"/><span class="koboSpan" id="kobo.2407.1">the filter input type, you can explicitly specify the properties you want to sort, or you can ignore the properties you do not want </span><span class="No-Break"><span class="koboSpan" id="kobo.2408.1">to sort.</span></span></p></li> <li><span class="koboSpan" id="kobo.2409.1">Update the resolver to apply the custom sort </span><span class="No-Break"><span class="koboSpan" id="kobo.2410.1">input type:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2411.1">
descriptor.Field(x =&gt; x.Students)    .UseFiltering&lt;StudentFilterType&gt;()    .UseSorting&lt;StudentSortType&gt;()    // Omitted for brevity</span></pre></li> <li><span class="koboSpan" id="kobo.2412.1">Run the application and check the schema. </span><span class="koboSpan" id="kobo.2412.2">You will see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.2413.1">StudentSortInput</span></strong><span class="koboSpan" id="kobo.2414.1"> now has three </span><span class="No-Break"><span class="koboSpan" id="kobo.2415.1">properties only:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2416.1">
input StudentSortInput {  firstName: SortEnumType  lastName: SortE</span><a id="_idTextAnchor531"/><span class="koboSpan" id="kobo.2417.1">numType  dateOfBirth: SortEnumType}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2418.1">The query is similar to the previous example, so we will not repeat </span><span class="No-Break"><span class="koboSpan" id="kobo.2419.1">it here.</span></span></p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor532"/><span class="koboSpan" id="kobo.2420.1">Pagination</span></h2>
<p><span class="koboSpan" id="kobo.2421.1">Pagination is a common feature in web API development. </span><span class="koboSpan" id="kobo.2421.2">In this section, we will learn how to use</span><a id="_idIndexMarker1348"/><span class="koboSpan" id="kobo.2422.1"> pagination </span><span class="No-Break"><span class="koboSpan" id="kobo.2423.1">in HotChocolate.</span></span></p>
<p><span class="koboSpan" id="kobo.2424.1">Similar to filtering and sorting, we need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2425.1">HotChocolate.Data</span></strong><span class="koboSpan" id="kobo.2426.1"> package to use pagination. </span><span class="koboSpan" id="kobo.2426.2">HotChocolate supports two types </span><span class="No-Break"><span class="koboSpan" id="kobo.2427.1">of pagination:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.2428.1">Cursor-based pagination</span></strong><span class="koboSpan" id="kobo.2429.1">: This </span><a id="_idIndexMarker1349"/><span class="koboSpan" id="kobo.2430.1">is the default pagination in HotChocolate. </span><span class="koboSpan" id="kobo.2430.2">It uses a cursor to indicate the current position in the list. </span><span class="koboSpan" id="kobo.2430.3">The cursor is usually an ID or a timestamp, which is opaque to </span><span class="No-Break"><span class="koboSpan" id="kobo.2431.1">the client.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.2432.1">Offset-based pagination</span></strong><span class="koboSpan" id="kobo.2433.1">: This pagination uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2434.1">skip</span></strong><span class="koboSpan" id="kobo.2435.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2436.1">take</span></strong><span class="koboSpan" id="kobo.2437.1"> arguments</span><a id="_idIndexMarker1350"/><span class="koboSpan" id="kobo.2438.1"> to paginate </span><span class="No-Break"><span class="koboSpan" id="kobo.2439.1">the list.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.2440.1">Let’s first use </span><a id="_idIndexMarker1351"/><span class="koboSpan" id="kobo.2441.1">cursor-based pagination to paginate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2442.1">Student</span></strong><span class="koboSpan" id="kobo.2443.1"> objects. </span><span class="koboSpan" id="kobo.2443.2">As we introduced before, if we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2444.1">IQueryable</span></strong><span class="koboSpan" id="kobo.2445.1"> interface</span><a id="_idIndexMarker1352"/><span class="koboSpan" id="kobo.2446.1"> in the resolver, HotChocolate can translate the GraphQL pagination to SQL-native queries automatically. </span><span class="koboSpan" id="kobo.2446.2">Follow the next steps to use cursor-based pagination for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2447.1">students</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2448.1"> query:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2449.1">Update the resolver for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2450.1">students</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2451.1"> query:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2452.1">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UsePaging()    .UseFiltering&lt;StudentFilterType&gt;()    .UseSorting&lt;StudentSortType&gt;()    // Omitted for brevity</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2453.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.2454.1">UsePaging()</span></strong><span class="koboSpan" id="kobo.2455.1"> must be placed before </span><strong class="source-inline"><span class="koboSpan" id="kobo.2456.1">UseFiltering()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2457.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2458.1">UseSorting()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2459.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.2460.1">Run the application and check the generated schema. </span><span class="koboSpan" id="kobo.2460.2">You will find that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2461.1">students</span></strong><span class="koboSpan" id="kobo.2462.1"> query now is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2463.1">StudentsConnection</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2464.1"> type:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2465.1">
students(  first: Int  after: String  last: Int  before: String  where: StudentFilterInput  order: [StudentSortInput!]): StudentsConnection</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2466.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2467.1">StudentsConnection</span></strong><span class="koboSpan" id="kobo.2468.1"> type is a connection type </span><span class="No-Break"><span class="koboSpan" id="kobo.2469.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2470.1">type StudentsConnection {  pageInfo: PageInfo!  edges: [StudentsEdge!]  nodes: [Student!]}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2471.1">In GraphQL, the </span><a id="_idIndexMarker1353"/><span class="koboSpan" id="kobo.2472.1">connection type is a </span><a id="_idIndexMarker1354"/><span class="koboSpan" id="kobo.2473.1">standard way to paginate the list. </span><span class="koboSpan" id="kobo.2473.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2474.1">StudentsConnection</span></strong><span class="koboSpan" id="kobo.2475.1"> type includes three fields: </span><strong class="source-inline"><span class="koboSpan" id="kobo.2476.1">pageInfo</span></strong><span class="koboSpan" id="kobo.2477.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2478.1">edges</span></strong><span class="koboSpan" id="kobo.2479.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2480.1">nodes</span></strong><span class="koboSpan" id="kobo.2481.1">. </span><span class="koboSpan" id="kobo.2481.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2482.1">nodes</span></strong><span class="koboSpan" id="kobo.2483.1"> field is a list of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2484.1">Student</span></strong><span class="koboSpan" id="kobo.2485.1"> objects. </span><span class="koboSpan" id="kobo.2485.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2486.1">edges</span></strong><span class="koboSpan" id="kobo.2487.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2488.1">pageInfo</span></strong><span class="koboSpan" id="kobo.2489.1"> fields are defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2490.1">StudentsEdge</span></strong><span class="koboSpan" id="kobo.2491.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2492.1">PageInfo</span></strong><span class="koboSpan" id="kobo.2493.1"> types </span><span class="No-Break"><span class="koboSpan" id="kobo.2494.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2495.1">type StudentsEdge {  cursor: String!  node: Student!}type PageInfo {  hasNextPage: Boolean!  hasPreviousPage: Boolean!  startCursor: String  endCursor: String}</span></pre></li> <li><span class="koboSpan" id="kobo.2496.1">Next, we can</span><a id="_idIndexMarker1355"/><span class="koboSpan" id="kobo.2497.1"> query the paginated </span><strong class="source-inline"><span class="koboSpan" id="kobo.2498.1">Student</span></strong><span class="koboSpan" id="kobo.2499.1"> objects </span><span class="No-Break"><span class="koboSpan" id="kobo.2500.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2501.1">
query {  students {    edges {      cursor      node {        id        firstName        dateOfBirth      }    }    pageInfo {      hasNextPage      hasPreviousPage    }  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2502.1">The</span><a id="_idIndexMarker1356"/><span class="koboSpan" id="kobo.2503.1"> result is </span><span class="No-Break"><span class="koboSpan" id="kobo.2504.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2505.1">{  "data": {    "students": {      "edges": [        {          "cursor": "MA==",          "node": {            "id": "00000000-0000-0000-0000-000000000901",            "firstName": "John",            "dateOfBirth": "2000-01-01"          }        },        ...        {          "cursor": "OQ==",          "node": {            "id": "00000000-0000-0000-0000-000000000910",            "firstName": "Jack",            "dateOfBirth": "2000-01-10"          }        }      ],      "pageInfo": {        "hasNextPage": true,        "hasPreviousPage": false      }    }  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2506.1">The result contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2507.1">cursor</span></strong><span class="koboSpan" id="kobo.2508.1"> field for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.2509.1">Student</span></strong><span class="koboSpan" id="kobo.2510.1"> object. </span><span class="koboSpan" id="kobo.2510.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2511.1">cursor</span></strong><span class="koboSpan" id="kobo.2512.1"> field is an opaque string, which is used to indicate the current position in the list. </span><span class="koboSpan" id="kobo.2512.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2513.1">pageInfo</span></strong><span class="koboSpan" id="kobo.2514.1"> field indicates whether</span><a id="_idIndexMarker1357"/><span class="koboSpan" id="kobo.2515.1"> there are more pages. </span><span class="koboSpan" id="kobo.2515.2">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2516.1">hasNextPage</span></strong><span class="koboSpan" id="kobo.2517.1"> field is </span><strong class="source-inline"><span class="koboSpan" id="kobo.2518.1">true</span></strong><span class="koboSpan" id="kobo.2519.1">, which means there are </span><span class="No-Break"><span class="koboSpan" id="kobo.2520.1">more pages.</span></span></p></li> <li><span class="koboSpan" id="kobo.2521.1">To query</span><a id="_idIndexMarker1358"/><span class="koboSpan" id="kobo.2522.1"> the next page, we need to specify the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2523.1">after</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2524.1"> parameter:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2525.1">
query {  students(after: "OQ==") {    edges {      cursor      node {        id        firstName        dateOfBirth      }    }    pageInfo {      hasNextPage      hasPreviousPage    }  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2526.1">You will see the next page of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2527.1">Student</span></strong><span class="koboSpan" id="kobo.2528.1"> objects. </span><span class="koboSpan" id="kobo.2528.2">The generated SQL query is </span><span class="No-Break"><span class="koboSpan" id="kobo.2529.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2530.1">info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (11ms) [Parameters=[@__p_0='?' </span><span class="koboSpan" id="kobo.2530.2">(DbType = Int32), @__p_1='?' </span><span class="koboSpan" id="kobo.2530.3">(DbType = Int32)],    CommandType='Text', CommandTimeout='30']      SELECT [s].[Id], [s].[DateOfBirth], [s].[Email], [s].[FirstName], [s].[Grade], [s].[GroupId], [s].   [LastName], [s].[Phone]      FROM [Students] AS [s]      ORDER BY (SELECT 1)      OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2531.1">The </span><a id="_idIndexMarker1359"/><span class="koboSpan" id="kobo.2532.1">preceding SQL query uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2533.1">OFFSET</span></strong><span class="koboSpan" id="kobo.2534.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2535.1">FETCH</span></strong><span class="koboSpan" id="kobo.2536.1"> clauses to paginate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2537.1">Student</span></strong><span class="koboSpan" id="kobo.2538.1"> objects, which means the </span><a id="_idIndexMarker1360"/><span class="koboSpan" id="kobo.2539.1">pagination is handled in </span><span class="No-Break"><span class="koboSpan" id="kobo.2540.1">the database.</span></span></p></li> <li><span class="koboSpan" id="kobo.2541.1">To query the previous page, we need to specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2542.1">before</span></strong><span class="koboSpan" id="kobo.2543.1"> parameter, as in </span><span class="No-Break"><span class="koboSpan" id="kobo.2544.1">this example:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2545.1">
query {  students(before: "MA==") {     edges {        cursor        node {          id          firstName          dateOfBirth        }     }     pageInfo {        hasNextPage        hasPreviousPage     }  }}</span></pre></li> <li><span class="koboSpan" id="kobo.2546.1">We can </span><a id="_idIndexMarker1361"/><span class="koboSpan" id="kobo.2547.1">specify the options for pagination in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2548.1">UsePaging()</span></strong><span class="koboSpan" id="kobo.2549.1"> method. </span><span class="koboSpan" id="kobo.2549.2">For example, we can specify the default page size and </span><a id="_idIndexMarker1362"/><span class="koboSpan" id="kobo.2550.1">include the total count in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2551.1">UsePaging()</span></strong><span class="koboSpan" id="kobo.2552.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.2553.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2554.1">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UsePaging(options: new PagingOptions()    {        MaxPageSize = 20,        DefaultPageSize = 5,        IncludeTotalCount = true    })    .UseFiltering&lt;StudentFilterType&gt;()    .UseSorting&lt;StudentSortType&gt;()    // Omitted for brevity</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2555.1">Now, we can include a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2556.1">totalCount</span></strong><span class="koboSpan" id="kobo.2557.1"> field in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2558.1">pageInfo</span></strong><span class="koboSpan" id="kobo.2559.1"> field, </span><span class="No-Break"><span class="koboSpan" id="kobo.2560.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2561.1">query {  students {    edges {      cursor      node {        id        firstName        dateOfBirth      }    }    totalCount    pageInfo {      hasNextPage      hasPreviousPage    }  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2562.1">You can </span><a id="_idIndexMarker1363"/><span class="koboSpan" id="kobo.2563.1">see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2564.1">totalCount</span></strong><span class="koboSpan" id="kobo.2565.1"> field in the response. </span><span class="koboSpan" id="kobo.2565.2">The default page size </span><span class="No-Break"><span class="koboSpan" id="kobo.2566.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2567.1">5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2568.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.2569.1">We can use </span><a id="_idIndexMarker1364"/><span class="koboSpan" id="kobo.2570.1">pagination with filtering and sorting. </span><span class="koboSpan" id="kobo.2570.2">The following query will filter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2571.1">Student</span></strong><span class="koboSpan" id="kobo.2572.1"> objects by first name and sort the results by first name and then by </span><span class="No-Break"><span class="koboSpan" id="kobo.2573.1">last name:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2574.1">
query ($where: StudentFilterInput, $order: [StudentSortInput!]) {  students(where: $where, order: $order) {    edges {      cursor      node {        id        firstName        dateOfBirth      }    }    totalCount    pageInfo {      hasNextPage      hasPreviousPage    }  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2575.1">The</span><a id="_idIndexMarker1365"/><span class="koboSpan" id="kobo.2576.1"> query variable is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.2577.1">as </span></span><span class="No-Break"><a id="_idIndexMarker1366"/></span><span class="No-Break"><span class="koboSpan" id="kobo.2578.1">follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2579.1">{   "where":{      "dateOfBirth":{         "gt":"2001-01-01"      }   },   "order":[      {         "firstName":"ASC"      },      {         "lastName":"ASC"      }   ]}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2580.1">After </span><a id="_idIndexMarker1367"/><span class="koboSpan" id="kobo.2581.1">querying the first page, we can query the next page, </span><span class="No-Break"><span class="koboSpan" id="kobo.2582.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2583.1">query ($where: StudentFilterInput, $order: [StudentSortInput!]) {  students(where: $where, order: $order, after: "NA==") {    edges {      cursor      node {        id        firstName        dateOfBirth      }    }    totalCount    pageInfo {      hasNextPage      hasPreviousPage    }  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2584.1">You can also </span><a id="_idIndexMarker1368"/><span class="koboSpan" id="kobo.2585.1">define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2586.1">after</span></strong><span class="koboSpan" id="kobo.2587.1"> parameter in the query variable, </span><span class="No-Break"><span class="koboSpan" id="kobo.2588.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2589.1">{   "where":{      "dateOfBirth":{         "gt":"2001-01-01"      }   },   "order":[      {         "firstName":"ASC"      },      {         "lastName":"ASC"      }   ],   "after":"NA=="}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2590.1">The query</span><a id="_idIndexMarker1369"/><span class="koboSpan" id="kobo.2591.1"> language of GraphQL is very flexible. </span><span class="koboSpan" id="kobo.2591.2">We </span><a id="_idIndexMarker1370"/><span class="koboSpan" id="kobo.2592.1">cannot list all the possible queries here. </span><span class="koboSpan" id="kobo.2592.2">You can try different queries </span><span class="No-Break"><span class="koboSpan" id="kobo.2593.1">by yourself.</span></span></p>
<p><span class="koboSpan" id="kobo.2594.1">HotChocolate supports </span><a id="_idIndexMarker1371"/><span class="koboSpan" id="kobo.2595.1">offset-based pagination as well. </span><span class="koboSpan" id="kobo.2595.2">To </span><a id="_idIndexMarker1372"/><span class="koboSpan" id="kobo.2596.1">use offset-based pagination, we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2597.1">UseOffsetPaging()</span></strong><span class="koboSpan" id="kobo.2598.1"> method instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2599.1">UsePaging()</span></strong><span class="koboSpan" id="kobo.2600.1"> method. </span><span class="koboSpan" id="kobo.2600.2">Follow these steps to use </span><span class="No-Break"><span class="koboSpan" id="kobo.2601.1">offset-based pagination:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2602.1">Update the resolver for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2603.1">students</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2604.1"> query:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2605.1">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UseOffsetPaging()    .UseFiltering&lt;StudentFilterType&gt;()    .UseSorting&lt;StudentSortType&gt;()    // Omitted for brevity</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2606.1">The preceding code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2607.1">UseOffsetPaging()</span></strong><span class="koboSpan" id="kobo.2608.1"> method to enable offset-based pagination instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.2609.1">cursor-based pagination.</span></span></p></li> <li><span class="koboSpan" id="kobo.2610.1">Run the</span><a id="_idIndexMarker1373"/><span class="koboSpan" id="kobo.2611.1"> application and check the </span><a id="_idIndexMarker1374"/><span class="koboSpan" id="kobo.2612.1">generated schema. </span><span class="koboSpan" id="kobo.2612.2">You will find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2613.1">students</span></strong><span class="koboSpan" id="kobo.2614.1"> query is now the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2615.1">StudentsCollectionSegment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2616.1"> type:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2617.1">
students(  skip: Int  take: Int  where: StudentFilterInput  order: [StudentSortInput!]): StudentsCollectionSegmenttype StudentsCollectionSegment {  pageInfo: CollectionSegmentInfo!  items: [Student!]}type CollectionSegmentInfo {  hasNextPage: Boolean!  hasPreviousPage: Boolean!}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2618.1">You should be familiar with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2619.1">skip</span></strong><span class="koboSpan" id="kobo.2620.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2621.1">take</span></strong><span class="koboSpan" id="kobo.2622.1"> arguments. </span><span class="koboSpan" id="kobo.2622.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2623.1">skip</span></strong><span class="koboSpan" id="kobo.2624.1"> argument is used to skip the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.2625.1">n</span></strong><span class="koboSpan" id="kobo.2626.1"> items. </span><span class="koboSpan" id="kobo.2626.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2627.1">take</span></strong><span class="koboSpan" id="kobo.2628.1"> argument is used to take the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.2629.1">n</span></strong><span class="koboSpan" id="kobo.2630.1"> items. </span><span class="koboSpan" id="kobo.2630.2">We already used these two methods in LINQ to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.2631.1">the pagination.</span></span></p></li> <li><span class="koboSpan" id="kobo.2632.1">Next, we </span><a id="_idIndexMarker1375"/><span class="koboSpan" id="kobo.2633.1">can query the paginated </span><strong class="source-inline"><span class="koboSpan" id="kobo.2634.1">Student</span></strong><span class="koboSpan" id="kobo.2635.1"> objects </span><span class="No-Break"><span class="koboSpan" id="kobo.2636.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2637.1">
 query {   students {     items {       id       firstName       dateOfBirth     }     pageInfo {       hasNextPage       hasPreviousPage     }   } }</span></pre></li> <li><span class="koboSpan" id="kobo.2638.1">To </span><a id="_idIndexMarker1376"/><span class="koboSpan" id="kobo.2639.1">query the next page, we need to specify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2640.1">skip</span></strong><span class="koboSpan" id="kobo.2641.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2642.1">take</span></strong><span class="koboSpan" id="kobo.2643.1"> parameters, </span><span class="No-Break"><span class="koboSpan" id="kobo.2644.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2645.1">
query {  students(skip: 5, take: 5) {    items {      id      firstName      dateOfBirth    }    pageInfo {      hasNextPage      hasPreviousPage    }  }}</span></pre></li> <li><span class="koboSpan" id="kobo.2646.1">You </span><a id="_idIndexMarker1377"/><span class="koboSpan" id="kobo.2647.1">can define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2648.1">skip</span></strong><span class="koboSpan" id="kobo.2649.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2650.1">take</span></strong><span class="koboSpan" id="kobo.2651.1"> parameters in the query variable </span><span class="No-Break"><span class="koboSpan" id="kobo.2652.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2653.1">
{  "skip": 5,  "take": 5}</span></pre></li> <li><span class="koboSpan" id="kobo.2654.1">We can</span><a id="_idIndexMarker1378"/><span class="koboSpan" id="kobo.2655.1"> specify the pagination options in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2656.1">UseOffsetPaging</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2657.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2658.1">
descriptor.Field(x =&gt; x.Students)    .Description("This is the list of students in the school.")    .UseOffsetPaging(options: new PagingOptions()    {        MaxPageSize = 20,        DefaultPageSize = 5,        IncludeTotalCount = true    })    .UseFiltering&lt;StudentFilterType&gt;()    .UseSorting&lt;StudentSortType&gt;()    // Omitted for brevity</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2659.1">You can include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2660.1">totalCount</span></strong><span class="koboSpan" id="kobo.2661.1"> field in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2662.1">response now.</span></span></p></li> <li><span class="koboSpan" id="kobo.2663.1">We can use </span><a id="_idIndexMarker1379"/><span class="koboSpan" id="kobo.2664.1">pagination with filtering and sorting. </span><span class="koboSpan" id="kobo.2664.2">The following query will filter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2665.1">Student</span></strong><span class="koboSpan" id="kobo.2666.1"> objects by first name and sort the results by first name and then by last name, and then fetch the </span><span class="No-Break"><span class="koboSpan" id="kobo.2667.1">second page:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2668.1">
query ($where: StudentFilterInput, $order: [StudentSortInput!], $skip: Int!, $take: Int!) {     students(where: $where, order: $order, skip: $skip, take: $take) {       items {         id         firstName         dateOfBirth       }       totalCount       pageInfo {         hasNextPage         hasPreviousPage       }     }   }</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2669.1">The </span><a id="_idIndexMarker1380"/><span class="koboSpan" id="kobo.2670.1">query variable is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.2671.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2672.1">{   "where":{      "dateOfBirth":{         "gt":"2001-01-01"      }   },   "order":[      {         "firstName":"ASC"      },      {         "lastName":"ASC"      }   ],   "skip":5,   "take":5}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2673.1">The </span><a id="_idIndexMarker1381"/><span class="koboSpan" id="kobo.2674.1">generated SQL query is </span><span class="No-Break"><span class="koboSpan" id="kobo.2675.1">shown</span></span><span class="No-Break"><a id="_idIndexMarker1382"/></span><span class="No-Break"><span class="koboSpan" id="kobo.2676.1"> here:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2677.1">info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (2ms) [Parameters=[@__p_0='?' </span><span class="koboSpan" id="kobo.2677.2">(DbType = Date), @__p_1='?' </span><span class="koboSpan" id="kobo.2677.3">(DbType = Int32),    @__p_2='?' </span><span class="koboSpan" id="kobo.2677.4">(DbType = Int32)], CommandType='Text', CommandTimeout='30']      SELECT [s].[Id], [s].[DateOfBirth], [s].[Email], [s].[FirstName], [s].[Grade], [s].[GroupId], [s].   [LastName], [s].[Phone]      FROM [Students] AS [s]      WHERE [s].[DateOfBirth] &gt; @__p_0      ORDER BY [s].[First</span><a id="_idTextAnchor533"/><span class="koboSpan" id="kobo.2678.1">Name], [s].[LastName]      OFFSET @__p_1 ROWS FETCH NEXT @__p_2 ROWS ONLY</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2679.1">The preceding </span><a id="_idIndexMarker1383"/><span class="koboSpan" id="kobo.2680.1">SQL query </span><a id="_idIndexMarker1384"/><span class="koboSpan" id="kobo.2681.1">shows that the pagination is handled in </span><span class="No-Break"><span class="koboSpan" id="kobo.2682.1">the database.</span></span></p>
<h1 id="_idParaDest-277"><a id="_idTextAnchor534"/><span class="koboSpan" id="kobo.2683.1">Visualizing the GraphQL schema</span></h1>
<p><span class="koboSpan" id="kobo.2684.1">When the</span><a id="_idIndexMarker1385"/><span class="koboSpan" id="kobo.2685.1"> GraphQL API becomes more complex, it is difficult to understand the schema. </span><span class="koboSpan" id="kobo.2685.2">We can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.2686.1">GraphQL Voyager</span></strong><span class="koboSpan" id="kobo.2687.1"> to visualize the GraphQL schema. </span><strong class="source-inline"><span class="koboSpan" id="kobo.2688.1">GraphQL Voyager</span></strong><span class="koboSpan" id="kobo.2689.1"> is an open-source project that can visualize the GraphQL schema in an interactive graph. </span><span class="koboSpan" id="kobo.2689.2">It is a frontend application that can be integrated with the GraphQL API. </span><span class="koboSpan" id="kobo.2689.3">To use it in our ASP.NET Core application, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2690.1">GraphQL.Server.Ui.Voyager</span></strong><span class="koboSpan" id="kobo.2691.1"> package. </span><span class="koboSpan" id="kobo.2691.2">This package is part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.2692.1">GraphQL.NET project.</span></span></p>
<p><span class="koboSpan" id="kobo.2693.1">Follow these steps</span><a id="_idIndexMarker1386"/><span class="koboSpan" id="kobo.2694.1"> to use GraphQL Voyager in </span><span class="No-Break"><span class="koboSpan" id="kobo.2695.1">our application:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2696.1">Install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2697.1">GraphQL.Server.Ui.Voyager</span></strong><span class="koboSpan" id="kobo.2698.1"> package using the </span><span class="No-Break"><span class="koboSpan" id="kobo.2699.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2700.1">dotnet add package GraphQL.Server.Ui.Voyager</span></strong></pre></li> <li><span class="koboSpan" id="kobo.2701.1">Add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2702.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2703.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2704.1">
app.MapGraphQLVoyager();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2705.1">The preceding code adds a middleware that maps the Voyager UI to the default URL </span><strong class="source-inline"><span class="koboSpan" id="kobo.2706.1">ui/voyager</span></strong><span class="koboSpan" id="kobo.2707.1">. </span><span class="koboSpan" id="kobo.2707.2">If you want to specify a different URL, you can pass the URL as a parameter, as in </span><span class="No-Break"><span class="koboSpan" id="kobo.2708.1">this example:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2709.1">app.MapGraphQLVoyager("/voyager");</span></pre></li> <li><span class="koboSpan" id="kobo.2710.1">Run the application and navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2711.1">ui/voyager</span></strong><span class="koboSpan" id="kobo.2712.1"> URL. </span><span class="koboSpan" id="kobo.2712.2">You will see the </span><span class="No-Break"><span class="koboSpan" id="kobo.2713.1">following page:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.2714.1"><img alt="Figure 12.5 – The GraphQL Voyager UI" src="image/B18971_12_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2715.1">Figure 12.5 – Overview of the GraphQL Voyager UI</span></p>
<p><span class="koboSpan" id="kobo.2716.1">Visualizing</span><a id="_idIndexMarker1387"/><span class="koboSpan" id="kobo.2717.1"> the </span><a id="_idIndexMarker1388"/><span class="koboSpan" id="kobo.2718.1">GraphQL schema can be beneficial for your team. </span><span class="koboSpan" id="kobo.2718.2">Doing so allows you to share the schema with your team members, making it easier to collaborate and stay on the </span><span class="No-Break"><span class="koboSpan" id="kobo.2719.1">same page.</span></span></p>
<h1 id="_idParaDest-278"><a id="_idTextAnchor535"/><span class="koboSpan" id="kobo.2720.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.2721.1">In this chapter, we explored how to use HotChocolate and Entity Framework Core to create a GraphQL API. </span><span class="koboSpan" id="kobo.2721.2">We discussed how to define object types, queries, and mutations, as well as how to use dependency injection to inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2722.1">DbContext</span></strong><span class="koboSpan" id="kobo.2723.1"> instance and services into the resolver. </span><span class="koboSpan" id="kobo.2723.2">We also introduced the data loader, which can reduce the number of queries to the database. </span><span class="koboSpan" id="kobo.2723.3">Additionally, we discussed interface and union types, which are useful for defining polymorphic types. </span><span class="koboSpan" id="kobo.2723.4">Finally, we explored how to use filtering, sorting, and pagination </span><span class="No-Break"><span class="koboSpan" id="kobo.2724.1">in HotChocolate.</span></span></p>
<p><span class="koboSpan" id="kobo.2725.1">In the next chapter, we will discuss SignalR, which is a real-time communication library in </span><span class="No-Break"><span class="koboSpan" id="kobo.2726.1">ASP.NET Core.</span></span></p>
<h1 id="_idParaDest-279"><a id="_idTextAnchor536"/><span class="koboSpan" id="kobo.2727.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.2728.1">It is important to note that GraphQL is a comprehensive query language and there are many features that we were unable to cover in this chapter. </span><span class="koboSpan" id="kobo.2728.2">For example, GraphQL supports subscriptions, which enable real-time communication with the GraphQL API. </span><span class="koboSpan" id="kobo.2728.3">To learn more about HotChocolate and GraphQL, please refer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.2729.1">following resources:</span></span></p>
<ul>
<li><a href="https://graphql.org/learn/"><span class="No-Break"><span class="koboSpan" id="kobo.2730.1">https://graphql.org/learn/</span></span></a></li>
<li><a href="https://chillicream.com/docs/hotchocolate/"><span class="No-Break"><span class="koboSpan" id="kobo.2731.1">https://chillicream.com/docs/hotchocolate/</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.2732.1">In a microservice architecture, we can use Apollo Federation to create a GraphQL gateway. </span><span class="koboSpan" id="kobo.2732.2">Apollo Federation can combine multiple GraphQL APIs into a single GraphQL API. </span><span class="koboSpan" id="kobo.2732.3">We will not cover Apollo Federation here as it is out of the scope of this book. </span><span class="koboSpan" id="kobo.2732.4">To learn more about Apollo Federation, please refer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.2733.1">following resources:</span></span></p>
<ul>
<li><a href="https://www.apollographql.com/"><span class="No-Break"><span class="koboSpan" id="kobo.2734.1">https://www.apollographql.com/</span></span></a></li>
<li><a href="https://github.com/apollographql"><span class="No-Break"><span class="koboSpan" id="kobo.2735.1">https://github.com/apollographql</span></span></a></li>
</ul>
</div>
</body></html>