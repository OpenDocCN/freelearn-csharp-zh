- en: Chapter 7. Using PLINQ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 使用PLINQ
- en: 'In this chapter, we will review different parallel programming paradigms, such
    as task and data parallelism, and cover the basics of data parallelism and parallel
    LINQ queries. You will learn the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾不同的并行编程范式，例如任务并行和数据并行，并介绍数据并行和并行LINQ查询的基础知识。你将学习以下技巧：
- en: Using the `Parallel` class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Parallel`类
- en: Parallelizing a LINQ query
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行化LINQ查询
- en: Tweaking the parameters of a PLINQ query
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整PLINQ查询的参数
- en: Handling exceptions in a PLINQ query
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PLINQ查询中处理异常
- en: Managing data partitioning in a PLINQ query
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理PLINQ查询中的数据分区
- en: Creating a custom aggregator for a PLINQ query
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为PLINQ查询创建自定义聚合器
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In .NET Framework, there is a subset of libraries that is called Parallel Framework,
    often referred to as **Parallel Framework Extensions** (**PFX**), which was the
    name of the very first version of these libraries. Parallel Framework was released
    with .NET Framework 4.0 and consists of three major parts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Framework中，有一组被称为Parallel Framework的库子集，通常被称为**并行框架扩展**（**PFX**），这是这些库的第一个版本的名字。Parallel
    Framework与.NET Framework 4.0一起发布，包括三个主要部分：
- en: The Task Parallel Library (TPL)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务并行库（TPL）
- en: Concurrent collections
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发集合
- en: Parallel LINQ or PLINQ
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行LINQ或PLINQ
- en: Until now, you have learned how to run several tasks in parallel and synchronize
    them with one another. In fact, we partitioned our program into a set of tasks
    and had different threads running different tasks. This approach is called **task
    parallelism**, and you have only been learning about task parallelism so far.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何并行运行多个任务，并使它们相互同步。实际上，我们将程序分割成一组任务，不同的线程运行不同的任务。这种方法被称为**任务并行**，而你到目前为止只学习了任务并行。
- en: Imagine that we have a program that performs some heavy calculations over a
    big set of data. The easiest way to parallelize this program is to partition this
    set of data into smaller chunks, run the calculations needed over these chunks
    of data in parallel, and then aggregate the results of these calculations. This
    programming model is called **data parallelism**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一个程序，它在一个大数据集上执行一些复杂的计算。将这个数据集分割成更小的块，并行地在这些数据块上运行所需的计算，然后汇总这些计算的结果，这是并行化这个程序最简单的方法。这种编程模型被称为**数据并行**。
- en: Task parallelism has the lowest abstraction level. We define a program as a
    combination of tasks, explicitly defining how they are combined. A program composed
    in this way could be very complex and detailed. Parallel operations are defined
    in different places in this program, and as it grows, the program becomes harder
    to understand and maintain. This way of making the program parallel is called
    **unstructured parallelism**. It is the price we have to pay if we have complex
    parallelization logic.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 任务并行具有最低的抽象级别。我们将程序定义为任务的组合，明确地定义它们是如何组合的。以这种方式组成的程序可能非常复杂和详细。在这个程序的不同地方定义了并行操作，随着程序的增长，程序变得越来越难以理解和维护。这种使程序并行化的方式被称为**无结构并行**。如果我们有复杂的并行化逻辑，这是我们必须付出的代价。
- en: However, when we have simpler program logic, we can try to offload more parallelization
    details to the PFX libraries and the C# compiler. For example, we could say, "I
    would like to run those three methods in parallel, and I do not care how exactly
    this parallelization happens; let the .NET infrastructure decide the details".
    This raises the abstraction level as we do not have to provide a detailed description
    of how exactly we are parallelizing this. This approach is referred to as **structured
    parallelism** since the parallelization is usually a sort of declaration and each
    case of parallelization is defined in exactly one place in the program.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们有更简单的程序逻辑时，我们可以尝试将更多的并行化细节卸载到PFX库和C#编译器。例如，我们可以说：“我想并行运行这三个方法，我不关心具体如何并行化；让.NET基础设施决定细节”。这样，抽象级别就提高了，因为我们不需要提供关于我们如何并行化的详细描述。这种做法被称为**结构化并行**，因为并行化通常是一种声明，并且每个并行化的案例都在程序中的确切位置定义。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There could be an impression that unstructured parallelism is bad practice and
    structured parallelism should be always used instead. I would like to emphasize
    that this is not true. Structured parallelism is indeed more maintainable, and
    preferred when possible, but it is a much less universal approach. In general,
    there are many situations when we simply are not able to use it, and it is perfectly
    OK to use TPL task parallelism in an unstructured manner.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一种印象，认为无结构的并行化是坏习惯，而应该始终使用结构化并行化。我想强调，这并不正确。结构化并行化确实更易于维护，并且在可能的情况下是首选，但它是一种不太通用的方法。一般来说，有许多情况下我们根本无法使用它，以无结构的方式使用TPL任务并行化是完全OK的。
- en: TPL has a `Parallel` class, which provides APIs for structured parallelism.
    This is still a part of TPL, but we will review it in this chapter because it
    is a perfect example of transition from a lower abstraction level to a higher
    one. When we use the `Parallel` class APIs, we do not need to provide the details
    of how we partition our work. However, we still need to explicitly define how
    we make one single result from partitioned results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: TPL有一个`Parallel`类，它提供了结构化并行的API。这仍然是TPL的一部分，但我们将在本章中回顾它，因为它是从较低抽象级别到较高抽象级别的完美示例。当我们使用`Parallel`类API时，我们不需要提供我们如何分区工作的细节。然而，我们仍然需要明确定义我们如何从分区结果中生成单个结果。
- en: PLINQ has the highest abstraction level. It automatically partitions data in
    to chunks and decides whether we really need to parallelize the query or whether
    it will be more effective to use usual sequential query processing. Then, the
    PLINQ infrastructure takes care of combining the partitioned results. There are
    many options that programmers may tweak to optimize the query and achieve the
    best possible performance and result.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ具有最高的抽象级别。它自动将数据分成块，并决定我们是否真的需要并行化查询，或者是否使用常规的顺序查询处理会更有效。然后，PLINQ基础设施负责合并分区的结果。程序员可以调整许多选项以优化查询并实现最佳性能和结果。
- en: In this chapter, we will cover the `Parallel` class API usage and many different
    PLINQ options, such as making a LINQ query parallel, setting up an execution mode
    and tweaking the parallelism degree of a PLINQ query, dealing with a query item
    order, and handling PLINQ exceptions. You will also learn how to manage data partitioning
    for PLINQ queries.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍`Parallel`类API的使用以及许多不同的PLINQ选项，例如使LINQ查询并行化，设置执行模式，调整PLINQ查询的并行度，处理查询项顺序，以及处理PLINQ异常。你还将学习如何管理PLINQ查询的数据分区。
- en: Using the Parallel class
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Parallel类
- en: This recipe shows you how to use the `Parallel` class APIs. You will learn how
    to invoke methods in parallel, how to perform parallel loops, and tweak parallelization
    mechanics.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何使用`Parallel`类API。你将学习如何并行调用方法，如何执行并行循环，以及调整并行化机制。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter7\Recipe1`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，你需要Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter7\Recipe1`中找到。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To invoke methods in parallel, perform parallel loops, and tweak parallelization
    mechanics using the `Parallel` class, perform the given steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要并行调用方法，执行并行循环，并使用`Parallel`类调整并行化机制，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This program demonstrates different features of the `Parallel` class. The `Invoke`
    method allows us to run several actions in parallel without much trouble as compared
    to defining tasks in TPL. The `Invoke` method blocks the other thread until all
    actions are complete, which is quite a common and convenient scenario.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序演示了`Parallel`类的不同功能。`Invoke`方法允许我们以比在TPL中定义任务更少的麻烦并行运行多个操作。与定义任务相比，`Invoke`方法会阻塞其他线程，直到所有操作都完成，这是一个非常常见且方便的场景。
- en: The next feature is parallel loops, which are defined with the `For` and `ForEach`
    methods. We will look closely at `ForEach` since it is very similar to `For`.
    With the `ForEach` parallel loop, you can process any `IEnumerable` collection
    in parallel by applying an action delegate to each collection item. We are able
    to provide several options, customizing parallelization behavior, and get a result
    that shows whether the loop completed successfully.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个特性是并行循环，它通过`For`和`ForEach`方法定义。我们将仔细研究`ForEach`，因为它与`For`非常相似。使用`ForEach`并行循环，你可以通过将操作委托应用于每个集合项来并行处理任何`IEnumerable`集合。我们能够提供几个选项，自定义并行化行为，并获得一个显示循环是否成功完成的输出结果。
- en: To tweak our parallel loop, we provide an instance of the `ParallelOptions`
    class to the `ForEach` method. This allows us to cancel the loop with `CancellationToken`,
    restrict the maximum parallelism degree (how many maximum operations can be run
    in parallel), and provide a custom `TaskScheduler` class to schedule action tasks
    with it. Actions can accept an additional `ParallelLoopState` parameter, which
    is useful for breaking the loop or for checking what happens with the loop at
    this moment.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调整我们的并行循环，我们将`ParallelOptions`类的实例传递给`ForEach`方法。这允许我们使用`CancellationToken`取消循环，限制最大并行度（可以并行运行的最大操作数），并提供一个自定义的`TaskScheduler`类来安排操作任务。操作可以接受一个额外的`ParallelLoopState`参数，这对于中断循环或检查此时循环的状态非常有用。
- en: There are two ways of stopping the parallel loop with this state. We could use
    either the `Break` or `Stop` methods. The `Stop` method tells the loop to stop
    processing any more work and sets the `IsStopped` property of the parallel loop
    state to `true`. The `Break` method stops the iterations after it, but the initial
    ones will continue to work. In that case, the `LowestBreakIteration` property
    of the loop result will contain the number of lowest loop iteration where the
    `Break` method was called.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以使用此状态停止并行循环。我们可以使用`Break`或`Stop`方法。`Stop`方法告诉循环停止处理任何更多的工作，并将并行循环状态的`IsStopped`属性设置为`true`。`Break`方法在迭代之后停止，但初始的迭代将继续工作。在这种情况下，循环结果的`LowestBreakIteration`属性将包含`Break`方法被调用的最低循环迭代数。
- en: Parallelizing a LINQ query
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行化LINQ查询
- en: This recipe will describe how to use PLINQ to make a query parallel and how
    to go back from a parallel query to sequential processing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将描述如何使用PLINQ使查询并行化，以及如何从并行查询返回到顺序处理。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter7\Recipe2`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，你需要Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter7\Recipe2`中找到。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To use PLINQ in order to make a query parallel and to go back from a parallel
    query to sequential processing, perform the following steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用PLINQ使查询并行化，并从并行查询返回到顺序处理，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中添加以下代码片段：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the program.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program runs, we create a LINQ query that uses the reflection API to
    get all types whose names start with *Web* from the assemblies loaded in the current
    application domain. We emulate delays for processing each item and for printing
    it with the `EmulateProcessing` and `PrintInfo` methods. We also use the `Stopwatch`
    class to measure each query's execution time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，我们创建一个LINQ查询，该查询使用反射API从当前应用程序域中加载的程序集获取所有以*Web*开头的类型。我们使用`EmulateProcessing`和`PrintInfo`方法模拟处理每个项和打印它的延迟。我们还使用`Stopwatch`类来测量每个查询的执行时间。
- en: First, we run a usual sequential LINQ query. There is no parallelization here,
    so everything runs on the current thread. The second version of the query uses
    the `ParallelEnumerable` class explicitly. `ParallelEnumerable` contains the PLINQ
    logic implementation and is organized as a number of extension methods to the
    `IEnumerable` collection's functionality. Normally, we do not use this class explicitly;
    we are using it here to illustrate how PLINQ actually works. The second version
    runs `EmulateProcessing` in parallel; however, by default, the results are merged
    on a single thread, so the query execution time should be a couple of seconds
    less than the first version.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们运行一个普通的顺序LINQ查询。这里没有并行化，所以所有操作都在当前线程上运行。查询的第二版明确使用了`ParallelEnumerable`类。`ParallelEnumerable`包含PLINQ逻辑实现，并作为`IEnumerable`集合功能的扩展方法组织。通常，我们不会明确使用这个类；我们在这里使用它来展示PLINQ实际上是如何工作的。第二版并行运行`EmulateProcessing`；然而，默认情况下，结果会在单个线程上合并，所以查询执行时间应该比第一版少几秒钟。
- en: The third version shows how to use the `AsParallel` method to run the LINQ query
    in parallel in a declarative manner. We do not care about implementation details
    here but just state that we want to run this in parallel. However, the key difference
    in this version is that we use the `ForAll` method to print out the query results.
    It runs the action to all items in the query on the same thread they were processed
    in, skipping the results-merging step. It allows us to run `PrintInfo` in parallel
    as well, and this version runs even faster than the previous one.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第三版展示了如何使用`AsParallel`方法以声明性方式并行运行LINQ查询。在这里，我们并不关心实现细节，只是声明我们希望并行运行这个查询。然而，这个版本的关键区别在于我们使用了`ForAll`方法来输出查询结果。它将在处理每个查询项的同一线程上运行操作，跳过了结果合并步骤。这允许我们并行运行`PrintInfo`，并且这个版本比上一个版本运行得更快。
- en: The last sample shows how to turn a PLINQ query back to sequential with the
    `AsSequential` method. We can see that this query runs exactly like the first
    one.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例展示了如何使用`AsSequential`方法将PLINQ查询转换回顺序查询。我们可以看到这个查询的运行方式与第一个完全相同。
- en: Tweaking the parameters of a PLINQ query
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整PLINQ查询的参数
- en: This recipe shows how we can manage parallel processing options using a PLINQ
    query and what these options could affect during a query's execution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了我们如何使用PLINQ查询来管理并行处理选项，以及这些选项在查询执行期间可能产生的影响。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter7\Recipe3`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，你需要Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter7\Recipe3`找到。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand how to manage parallel processing options using a PLINQ query
    and their effects, perform the following steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用PLINQ查询管理并行处理选项及其影响，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE7]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The program demonstrates different useful PLINQ options that programmers can
    use. We start with creating a PLINQ query, and then we create another query providing
    PLINQ tweaking.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 程序演示了程序员可以使用的不同有用的PLINQ选项。我们首先创建一个PLINQ查询，然后创建另一个提供PLINQ调整的查询。
- en: Let's start with cancelation first. To be able to cancel a PLINQ query, there
    is a `WithCancellation` method that accepts a cancelation token object. Here,
    we signal the cancelation token after 3 seconds, which leads to `OperationCanceledException`
    in the query and cancelation of the rest of the work.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从取消操作开始。为了能够取消PLINQ查询，有一个`WithCancellation`方法，它接受一个取消令牌对象。在这里，我们在3秒后发出取消令牌，这导致查询中的`OperationCanceledException`异常，并取消剩余的工作。
- en: Then, we are able to specify a parallelism degree for the query. It is the exact
    number of parallel partitions that will be used to execute the query. In the first
    recipe, we used the `Parallel.ForEach` loop, which has the maximum parallelism
    degree option. It is different because it specifies a maximum partitions value,
    but there could be fewer partitions if the infrastructure decides that it is better
    to use less parallelism to save resources and achieve optimal performance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为查询指定一个并行度。这是将要用于执行查询的确切并行分区数。在第一个食谱中，我们使用了 `Parallel.ForEach` 循环，它具有最大并行度选项。它不同之处在于它指定了一个最大分区值，但如果基础设施决定使用更少的并行度以节省资源并实现最佳性能，则可能会有更少的分区。
- en: Another interesting option is overriding the query execution mode with the `WithExecutionMode`
    method. The PLINQ infrastructure can process some queries in sequential mode if
    it decides that parallelizing the query will only add more overhead and it actually
    will run slower. Using `WithExecutionMode`, we can force the query to run in parallel.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的选择是使用 `WithExecutionMode` 方法覆盖查询执行模式。如果 PLINQ 基础设施决定并行化查询只会增加开销并且实际上会运行得更慢，它可以将一些查询以顺序模式处理。使用
    `WithExecutionMode`，我们可以强制查询以并行方式运行。
- en: To tune up query result processing, we have the `WithMergeOptions` method. The
    default mode is used to buffer a number of results selected by the PLINQ infrastructure
    before returning them from the query. If the query takes a significant amount
    of time, it is more reasonable to turn off result buffering to get the results
    as soon as possible.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调整查询结果处理，我们有 `WithMergeOptions` 方法。默认模式是在将结果从查询返回之前，由 PLINQ 基础设施缓冲选择的一定数量的结果。如果查询需要花费大量时间，关闭结果缓冲以尽快获取结果更为合理。
- en: The last option is the `AsOrdered` method. It is possible that when we use parallel
    execution, the item order in the collection is not preserved. Later items in the
    collection could be processed before earlier ones. To prevent this, we need to
    call `AsOrdered` on a parallel query to explicitly tell the PLINQ infrastructure
    that we intend to preserve the item order for processing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项是 `AsOrdered` 方法。当我们使用并行执行时，集合中的项目顺序可能不会保留。集合中的后续项目可能会在早期项目之前处理。为了防止这种情况，我们需要在并行查询上调用
    `AsOrdered`，以明确告诉 PLINQ 基础设施我们打算保留项目顺序以进行处理。
- en: Handling exceptions in a PLINQ query
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 PLINQ 查询中处理异常
- en: This recipe will describe how to handle exceptions in a PLINQ query.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将描述如何在 PLINQ 查询中处理异常。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter7\Recipe4`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，你需要 Visual Studio 2015。没有其他先决条件。本食谱的源代码可以在 `BookSamples\Chapter7\Recipe4`
    中找到。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To understand how to handle exceptions in a PLINQ query, perform the following
    steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在 PLINQ 查询中处理异常，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法中添加以下代码片段：
- en: '[PRE10]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the program.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we run a usual LINQ query over a range of numbers from -5 to 4\. When
    we divide by 0, we get `DivideByZeroException`, and we handle it as usual in a
    `try/catch` block.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在从 -5 到 4 的数字范围内运行一个常规 LINQ 查询。当我们除以 0 时，我们得到 `DivideByZeroException`，我们像往常一样在
    `try/catch` 块中处理它。
- en: However, when we use `AsParallel`, we get `AggregateException` instead because
    we are now running in parallel, leveraging the task infrastructure behind the
    scenes. `AggregateException` will contain all the exceptions that occurred while
    running the PLINQ query. To handle the inner `DivideByZeroException` class, we
    use the `Flatten` and `Handle` methods, which were explained in the *Handling
    exceptions in asynchronous operations* recipe in [Chapter 5](ch05.html "Chapter 5. Using
    C# 6.0"), *Using C# 6.0*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们使用 `AsParallel` 时，我们得到 `AggregateException` 而不是其他，因为我们现在正在并行运行，利用幕后任务基础设施。`AggregateException`
    将包含在运行 PLINQ 查询期间发生的所有异常。要处理内部的 `DivideByZeroException` 类，我们使用 `Flatten` 和 `Handle`
    方法，这些方法在 [第 5 章](ch05.html "第 5 章。使用 C# 6.0") 的 *处理异步操作中的异常* 食谱中进行了说明，*使用 C# 6.0*。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is very easy to forget that when we handle aggregate exceptions, having more
    than one inner exception inside is a very common situation. If you forget to handle
    all of them, the exception will bubble up and the application will stop working.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忘记，当我们处理聚合异常时，内部有多个异常是一个非常常见的情况。如果你忘记处理所有这些异常，异常将会冒泡，应用程序将停止工作。
- en: Managing data partitioning in a PLINQ query
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PLINQ查询中管理数据分区
- en: This recipe shows you how to create a very basic custom partitioning strategy
    to parallelize a LINQ query in a specific way.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何创建一个非常基本的自定义分区策略以特定方式并行化LINQ查询。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter7\Recipe5`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，你需要Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter7\Recipe5`找到。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To learn how to create a very basic custom partitioning strategy to parallelize
    a LINQ query, perform the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何创建一个非常基本的自定义分区策略以并行化LINQ查询，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE11]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE13]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the program.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To illustrate that we are able to choose custom partitioning strategies for
    the PLINQ query, we created a very simple partitioner that processes strings of
    odd and even lengths in parallel. To achieve this, we derive our custom `StringPartitioner`
    class from a standard base class `Partitioner<T>` using `string` as a type parameter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们能够为PLINQ查询选择自定义的分区策略，我们创建了一个非常简单的分区器，该分区器并行处理奇数长度和偶数长度的字符串。为了实现这一点，我们使用`string`作为类型参数，从标准基类`Partitioner<T>`派生我们的自定义`StringPartitioner`类。
- en: We declare that we only support static partitioning by overriding the `SupportsDynamicPartitions`
    property and setting it to `false`. This means that we predefine our partitioning
    strategy. This is an easy way to partition the initial collection but could be
    inefficient depending on what data we have inside the collection. For example,
    in our case, if we had many strings with odd lengths and only one string with
    even length, one of the threads would have finished early and would not have helped
    to process odd-length strings. On the other hand, dynamic partitioning means that
    we partition the initial collection on the fly, balancing the work load between
    the worker threads.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过重写`SupportsDynamicPartitions`属性并将其设置为`false`来声明我们只支持静态分区。这意味着我们预定义了我们的分区策略。这是一种简单的分区初始集合的方法，但可能会根据集合内部的数据而效率低下。例如，在我们的情况下，如果我们有很多奇数长度的字符串和只有一个偶数长度的字符串，那么其中一个线程会提前完成，而不会帮助处理奇数长度的字符串。另一方面，动态分区意味着我们在运行时对初始集合进行分区，平衡工作负载在工作线程之间。
- en: 'Then, we implement the `GetPartitions` method, where we define the following
    logic: if there is only one partition, we simply process everything on it. However,
    if we have more than one partition, then we process strings with odd length on
    odd partitions and even-length strings on even-numbered partitions.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现`GetPartitions`方法，其中我们定义以下逻辑：如果只有一个分区，我们简单地处理它上面的所有内容。然而，如果我们有多个分区，那么我们在奇数分区上处理奇数长度的字符串，在偶数分区上处理偶数长度的字符串。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that we need to create as many partitions as is stated in the `partitionCount`
    parameter, or else we will get the `Partitioner returned a wrong number of partitions`
    error.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要创建与`partitionCount`参数中所述一样多的分区，否则我们将得到`Partitioner returned a wrong
    number of partitions`错误。
- en: Finally, we create an instance of our partitioner and perform a PLINQ query
    with it. We can see that different threads process the odd-length and even-length
    strings. Also, we can experiment with uncommenting the `WithDegreeOfParallelism`
    method and changing its parameter value. In the case of `1`, there will be a sequential
    work items processing, and when increasing the value, we can see that more work
    gets done in parallel.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建我们分区器的实例，并使用它执行一个PLINQ查询。我们可以看到不同的线程处理奇数长度和偶数长度的字符串。此外，我们可以通过取消注释`WithDegreeOfParallelism`方法并更改其参数值来实验。当参数值为`1`时，将会有顺序的工作项处理，而当增加值时，我们可以看到更多的工作可以并行完成。
- en: Creating a custom aggregator for a PLINQ query
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为PLINQ查询创建自定义聚合器
- en: This recipe shows you how to create a custom aggregation function for a PLINQ
    query.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何为PLINQ查询创建一个自定义聚合函数。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter7\Recipe6`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，你需要Visual Studio 2015。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter7\Recipe6`中找到。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand the workings of a custom aggregation function for a PLINQ query,
    perform the following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解PLINQ查询的自定义聚合函数的工作原理，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE14]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE15]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE16]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the program.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Here, we implement custom aggregation mechanics that are able to work with the
    PLINQ queries. To implement this, we have to understand that since a query is
    being processed in parallel by several tasks simultaneously, we need to provide
    mechanics to aggregate each task's result in parallel and then combine those aggregated
    values into one single result value.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实现了能够与PLINQ查询一起工作的自定义聚合机制。为了实现这一点，我们必须理解，由于查询正在由多个任务同时并行处理，我们需要提供机制来并行聚合每个任务的结果，然后将这些聚合值组合成一个单一的结果值。
- en: In this recipe, we wrote an aggregating function that counts letters in a PLINQ
    query, which returns the `IEnumerable<string>` collection. It counts all the letters
    in each collection item. To illustrate the parallel aggregation process, we print
    out information about which thread processes each part of the aggregation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们编写了一个聚合函数，用于在PLINQ查询中计算字母，它返回`IEnumerable<string>`集合。它计算每个集合项中的所有字母。为了说明并行聚合过程，我们打印出关于哪个线程处理聚合的每个部分的信息。
- en: We aggregate the PLINQ query results using the `Aggregate` extension method
    defined in the `ParallelEnumerable` class. It accepts four parameters, each of
    which is a function that performs different parts of the aggregation process.
    The first one is a factory that constructs the empty initial value of the aggregator.
    It is also called the seed value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在`ParallelEnumerable`类中定义的`Aggregate`扩展方法来聚合PLINQ查询结果。它接受四个参数，每个参数都是一个执行聚合过程不同部分的功能。第一个是一个工厂，用于构建聚合器的空初始值。它也被称为种子值。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the first value provided to the `Aggregate` method is actually not
    an initial seed value for the aggregator function but a factory method that constructs
    this initial seed value. If you provide just an instance, it will be used in all
    partitions that run in parallel, which will lead to an incorrect result.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，提供给`Aggregate`方法的第一个值实际上不是聚合函数的初始种子值，而是一个构造这个初始种子值的工厂方法。如果你只提供一个实例，它将在所有并行运行的分区中使用，这会导致结果不正确。
- en: The second function aggregates each collection item into the partition aggregation
    object. We implement this function with the `AccumulateLettersInformation` method.
    It iterates the string and counts the letters inside it. Here, the aggregation
    objects are different for each query partition running in parallel, which is why
    we called them `taskTotal`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数将每个集合项聚合到分区聚合对象中。我们使用`AccumulateLettersInformation`方法来实现这个函数。它遍历字符串并计算其中的字母。在这里，聚合对象对于每个并行运行的查询分区都是不同的，这就是为什么我们称之为`taskTotal`。
- en: The third function is a higher level aggregation function that takes an aggregator
    object from a partition and merges it into a global aggregator object. We implement
    it with the `MergeAccumulators` method. The last function is a selector function
    that specifies what exact data we need from the global aggregator object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个功能是一个高级聚合函数，它从一个分区中获取一个聚合对象并将其合并到一个全局聚合对象中。我们使用`MergeAccumulators`方法来实现它。最后一个函数是一个选择函数，它指定了我们从全局聚合对象中需要的确切数据。
- en: Finally, we print out the aggregation result, ordering it by the letters used
    most often in the collection items.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印出聚合结果，按集合项中最常用的字母进行排序。
