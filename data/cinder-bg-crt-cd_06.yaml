- en: Chapter 6. Accelerate – Creating Generative Animation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 加速 - 创建生成式动画
- en: 'In this chapter we are going to learn the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Basics of procedural animation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序化动画的基础
- en: Animating multiple objects at the same time
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时动画多个对象
- en: How to make use of randomness
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用随机性
- en: How to benefit from built-in animation easing functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从内置动画缓动函数中受益
- en: We will create a relatively simple drawing by using basic shapes and then animate
    these shapes in a parametric way. We will also learn how to make use of built-in
    easing functions of Cinder that can make polishing our animations a lot easier.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用基本形状创建一个相对简单的绘图，然后以参数方式对这些形状进行动画处理。我们还将学习如何利用Cinder的内置缓动函数，这可以使我们的动画润色变得更加容易。
- en: Preparing the stage
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备舞台
- en: Before we begin, open TinderBox and create a new project with the name `BasicAnimation`.
    Open `xcode/BasicAnimation.xcodeproj` (`vc10\BasicAnimation.sln` on Windows).
    Open `BasicAnimationApp.cpp` in the editor so that we can start making changes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，打开TinderBox并创建一个名为`BasicAnimation`的新项目。打开`xcode/BasicAnimation.xcodeproj`（在Windows上为`vc10\BasicAnimation.sln`）。在编辑器中打开`BasicAnimationApp.cpp`，以便我们可以开始进行更改。
- en: 'We are going to change the window size this time as 640 x 480 px might be too
    small for most of the compositions we will want to create later. To do that, we
    need to override another Cinder `AppBasic` method—`prepareSettings()`. Add a new
    declaration just after the `draw()` method declaration as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将更改窗口大小，因为640 x 480像素可能对于我们想要创建的大多数构图来说太小了。为了做到这一点，我们需要覆盖另一个Cinder的`AppBasic`方法——`prepareSettings()`。在`draw()`方法声明之后添加一个新的声明，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now add the implementation of the method that we just declared just before
    the implementation of the `setup()` method:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们刚刚声明的`setup()`方法实现之前添加方法的实现：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s change the window size. To do that, add the following line of code inside
    the `prepareSettings` method implementation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改窗口大小。为此，在`prepareSettings`方法实现中添加以下代码行：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will also change the frame rate to something more appropriate for Cinder—60
    frames per second is a good choice:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更改帧率，以更合适于Cinder的值——每秒60帧是一个不错的选择：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, this altogether looks as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，整体看起来如下所示：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now compile and run your application to test if it works.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译并运行你的应用程序以测试它是否工作。
- en: Next we are going to draw a solid circle. As you might remember from the previous
    chapters, we have to use the `drawSolidCircle()` function in order to do that.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将绘制一个实心圆。正如你可能从前面的章节中记得的那样，为了做到这一点，我们必须使用`drawSolidCircle()`函数。
- en: 'Navigate to the `draw()` member function implementation in the `BasicAnimationApp.cpp`
    file and add the following line of code just after the `gl::clear()` function
    call:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BasicAnimationApp.cpp`文件中导航到`draw()`成员函数的实现，并在`gl::clear()`函数调用之后添加以下代码行：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This draws a white circle with a radius of 30 pixels in the center of the window.
    As this chapter is about animation, let's think of some ways to move this circle.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在窗口中心绘制一个半径为30像素的白色圆圈。由于本章是关于动画的，让我们考虑一些移动这个圆圈的方法。
- en: '![Preparing the stage](img/9564_06_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![准备舞台](img/9564_06_01.jpg)'
- en: Adding animation
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动画
- en: As we already know, in each frame before we draw something, we use black color
    to clear everything that is left there from the previous frame. We use `gl::clear()`
    to do that. To create the effect of moving something, we need to change the object's
    position in each frame.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，在每一帧绘制任何东西之前，我们使用黑色清除前帧留下的所有内容。我们使用`gl::clear()`来做到这一点。为了创建移动某物的效果，我们需要在每一帧中改变对象的位置。
- en: 'To do that, we will need to replace the values of the `drawSolidCircle` position
    parameters to variables. Let''s declare a new variable that will hold the position
    of the circle on the screen:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要将`drawSolidCircle`位置参数的值替换为变量。让我们声明一个新的变量，它将保存圆在屏幕上的位置：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This variable will hold the `x` and `y` position of the circle that we are drawing
    inside the `draw()` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量将保存我们在`draw()`方法中绘制的圆的`x`和`y`位置。
- en: 'Now we will set the initial value of the variable in the `setup()` method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在`setup()`方法中设置变量的初始值：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, a part of the preceding code snippet is the same as we used
    in the `drawSolidCircle()` function call. We just made it changeable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前面代码片段的一部分与我们用于`drawSolidCircle()`函数调用的代码相同。我们只是让它变得可变。
- en: 'Finally, we have to replace the values in the `drawSolidCircle()` function
    to the newly created variable:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须将`drawSolidCircle()`函数中的值替换为新创建的变量：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Compile and run our application. Nothing much has changed. Don''t worry about
    that and add the following line of code before the `drawSolidCircle()` function
    call:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 再次编译并运行我们的应用程序。没有什么太大的变化。别担心，在`drawSolidCircle()`函数调用之前添加以下代码行：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Compile and run the application again and there it is, a moving circle. Cool!
    We have our first animation! Now let''s do something with the radius of the circle.
    To apply animation to it, we have to declare a new variable again:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 再次编译并运行应用程序，那里就有了一个移动的圆。酷！我们有了第一个动画！现在让我们对圆的半径做些处理。要对其应用动画，我们必须再次声明一个新变量：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, set its starting value:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设置其起始值：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And add an animation rule and replace the constant value of the circle radius
    parameter of the `drawSolidCircle()` function call in the `draw()` method implementation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`draw()`方法实现中添加一个动画规则，并替换`drawSolidCircle()`函数调用中圆半径参数的常量值：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Compile and run our application. You should see a big white point disappearing
    in front of your eyes. It might seem that you did something wrong, but don't worry,
    everything is correct. The trick is that we decreased the circle radius by one
    pixel for each frame. It is happening at a rate of 60 times per second and that
    means that the radius of the circle will reach `0` in approximately 1.5 seconds.
    Therefore, if the radius is `0`, the circle becomes invisible as there can be
    no circle without a radius.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行我们的应用程序。你应该会看到眼前有一个大白色点消失。可能看起来你做错了什么，但别担心，一切正常。诀窍在于我们每帧减少一个像素的圆半径。这是以每秒60次的速率发生的，这意味着圆的半径将在大约1.5秒内达到`0`。因此，如果半径是`0`，圆就变得不可见，因为没有半径的圆是不存在的。
- en: 'So far so good. Let''s try to move our circle to some fixed location over time.
    Let''s say we want to move it from the top-left corner of the screen to the bottom
    right. To do that we need to set the initial position of the circle to `0`. and
    let''s change the initial `circleRadius` to something smaller as well:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。让我们尝试随着时间的推移将我们的圆移动到某个固定的位置。比如说，我们想从屏幕的左上角移动到底右角。要做到这一点，我们需要将圆的初始位置设置为`0`，并且让我们也将初始`circleRadius`改为更小的值：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s declare another `Vec2f` variable that will hold the target position
    of the circle in the class declaration:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在类声明中声明另一个`Vec2f`变量，该变量将保存圆的目标位置：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need to set the initial target position somewhere, so we have to add a new
    line in the `setup()` method implementation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将初始目标位置设置在某个地方，所以我们必须在`setup()`方法实现中添加一行新代码：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, we need to write some code that creates a smooth transition between
    `currentPosition` and `targetPosition`. Let's do it in the `update()` method implementation
    as it is meant for such calculations. Remember, try to use the `draw()` method
    just for drawing and place all your calculations inside `update()`. It does not
    matter much for a small application such as this one, but as your code grows bigger,
    it is possible that the application won't perform so well or will even crash if
    you don't stick to this simple rule.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要编写一些代码来在`currentPosition`和`targetPosition`之间创建平滑的过渡。让我们在`update()`方法实现中这样做，因为它适合这类计算。记住，尽量只使用`draw()`方法进行绘图，并将所有计算放在`update()`方法中。对于像这样的小型应用程序来说，这并不重要，但随着你的代码越来越大，如果不符合这个简单规则，应用程序可能表现不佳，甚至可能崩溃。
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These three lines of code calculate the difference between the current circle
    position and the target circle position. Then, we make the difference between
    these positions smaller by multiplying it with a floating point number that is
    smaller than `0`. Finally, we calculate the new current position by subtracting
    the new difference from the target position of the circle.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这三行代码计算当前圆位置和目标圆位置之间的差异。然后，我们通过乘以一个小于`0`的浮点数来减小这些位置之间的差异。最后，我们通过从圆的目标位置减去新的差异来计算新的当前位置。
- en: This would require a longer code if we didn't make use of the integrated vector
    algebra features of Cinder. As a `Vec2f` object contains two values (the x and
    the y coordinate), when we multiply it with a single value, both values inside
    the `Vec2f` object are multiplied by this value. Furthermore, if we multiply a
    `Vec2f` object with another `Vec2f` object, the first element of the first vector
    is multiplied with the first element of the second one, and the second element
    of the first one is multiplied with the second element of the second one, and
    so on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有利用Cinder的集成矢量代数功能，这将需要更长的代码。由于`Vec2f`对象包含两个值（x和y坐标），当我们用一个单一值乘以它时，`Vec2f`对象内的两个值都会乘以这个值。此外，如果我们用一个`Vec2f`对象乘以另一个`Vec2f`对象，第一个向量的第一个元素与第二个向量的第一个元素相乘，第一个向量的第二个元素与第二个向量的第二个元素相乘，依此类推。
- en: Now compile and run our application. You should see a circle moving from the
    top-left corner to the bottom-right corner of the screen.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译并运行我们的应用程序。您应该看到一个圆从屏幕的左上角移动到右下角。
- en: '![Adding animation](img/9564_06_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![添加动画](img/9564_06_02.jpg)'
- en: Adding randomness
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加随机性
- en: 'Let''s add a bit of unpredictability to this by using the almighty random functions.
    To use them in Cinder, you have to include a header file that contains the necessary
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用强大的随机函数来增加一些不可预测性。要在Cinder中使用它们，您必须包含一个包含必要代码的头文件：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add this in the beginning of the `BasicAnimationApp.cpp` file. Next, we need
    to calculate random target position in the `setup()` method implementation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BasicAnimationApp.cpp`文件的开始处添加此代码。接下来，我们需要在`setup()`方法实现中计算随机目标位置：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now each time you run the application, a different end position will be calculated
    and the circle will fly to a different place on the screen.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每次运行应用程序时，都会计算一个新的结束位置，圆将飞到屏幕上的不同位置。
- en: 'Let''s change the current position of the circle to something random as well:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将圆的当前位置也改为随机值：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Compile and run the application to see the change.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行应用程序以查看更改。
- en: 'It might seem a bit boring to see just one random animation after you have
    opened an application. People usually expect something more. So how about we calculate
    a new random end position as the circle reaches its current end position? Ok,
    let''s do that! Add the following piece of code in the `update()` method implementation
    just after `currentPosition = targetPosition - difference;`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开应用程序后只看到一次随机动画可能有点无聊。人们通常期望更多。那么，当圆达到当前结束位置时，我们是否可以计算一个新的随机结束位置？好的，让我们这么做！在`update()`方法实现中，在`currentPosition
    = targetPosition - difference;`之后添加以下代码片段：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Comment out or delete the following highlighted lines from the `draw()` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从`draw()`方法中注释掉或删除以下突出显示的行：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile and run our application. This is a bit more interesting, but still it
    needs something more to be complete.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行我们的应用程序。这有点更有趣，但仍然需要更多才能完整。
- en: '![Adding randomness](img/9564_06_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![添加随机性](img/9564_06_03.jpg)'
- en: How about we try to handle more than one circle on the screen? It would be worth
    explaining how to create a particle system as a separate class, but this won't
    fit in the scope of this book, so we will continue to make some changes in the
    same file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否可以尝试在屏幕上处理多个圆？解释如何创建一个作为单独类的粒子系统是值得的，但这超出了本书的范围，所以我们将在同一文件中继续进行一些更改。
- en: More circles
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多圆圈
- en: 'Let''s define the count of the circles that we want the application to handle.
    Add the following line of code just after the `#include` statements:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义应用程序要处理的圆圈数量。在`#include`语句之后添加以下代码行：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s go to the class declaration part and change the declarations of
    our variables to arrays:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到类声明部分，并将我们变量的声明更改为数组：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we used the previously defined constant as the size of our arrays.
    By doing that we can change the circle count easily later.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了之前定义的常量作为我们数组的大小。通过这样做，我们可以轻松地稍后更改圆的数量。
- en: 'Next, we have to change some code in the `setup()` method implementation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们不得不在`setup()`方法实现中更改一些代码：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Basically, we wrapped the same code we had before into a `for` loop that iterates
    over all our parameter arrays and sets initial values for each of them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们将之前拥有的相同代码封装在一个`for`循环中，该循环遍历所有参数数组并为它们中的每一个设置初始值。
- en: 'Don''t compile yet as we still have to make changes to the `update()` and `draw()`
    methods in a similar way. Change our `update()` method as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还不要编译，因为我们仍然需要以类似的方式更改`update()`和`draw()`方法。按照以下方式更改我们的`update()`方法：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And lastly, change our `draw()` method implementation as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照以下方式更改我们的`draw()`方法实现：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Compile and run our application now. This looks a bit more interesting!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译并运行我们的应用程序。这看起来更有趣了！
- en: '![More circles](img/9564_06_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![更多圆圈](img/9564_06_04.jpg)'
- en: It seems that 100 circles are not enough, so how about we set the `CIRCLE_COUNT`
    constant to `1000`?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎100个圆圈还不够，那么我们是否可以将`CIRCLE_COUNT`常量设置为`1000`？
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: No problem!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题！
- en: But what if we don't want to focus on quantity, but on the quality of movement?
    This is where animation easing joins the game.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们不想关注数量，而是关注运动的质量呢？这就是动画缓动加入游戏的地方。
- en: Using built-in eases
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置缓动
- en: Now, say we want to make use of the easing algorithms that we saw in the `EaseGallery`
    sample. To do that, we have to change the code by following certain steps.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想利用我们在`EaseGallery`示例中看到的缓动算法。为此，我们必须按照某些步骤更改代码。
- en: 'To use the easing functions, we have to include the `Easing.h` header file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用缓动函数，我们必须包含`Easing.h`头文件：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First we are going to add two more variables, `startPostition` and `circleTimeBase`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加两个额外的变量，`startPostition`和`circleTimeBase`：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, in the `setup()` method implementation, we have to change the `currentPosition`
    parts to `startPosition` and add an initial value to the `circleTimeBase` array
    members:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`setup()`方法实现中，我们必须将`currentPosition`部分更改为`startPosition`，并给`circleTimeBase`数组成员添加一个初始值：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we have to change the `update()` method so that it can be used along
    with the easing functions. They are based on time and they return a floating point
    value between `0` and `1` that defines the `playhead` position on an abstract
    `0` to `1` timeline:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须更改`update()`方法，使其可以与缓动函数一起使用。它们基于时间，并返回一个介于`0`和`1`之间的浮点值，该值定义了抽象的`0`到`1`时间轴上的`playhead`位置：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The highlighted parts in the preceding code snippet are those that have been
    changed. The most important part of it is the `currentPosition[i]` calculation
    part. We take the distance between the start and end points of the timeline and
    multiply it with the position floating point number that is being returned by
    our easing function, which in this case is `easeOutExpo()`. Again, it returns
    a floating point variable between `0` and `1` that represents the position on
    an abstract `0` to `1` timeline. If we multiply any number with, say, `0.33f`,
    we get one-third of that number, `0.5f`, we get one-half of that number, and so
    on. So, we add this distance to the circle's starting position and we get it's
    current position!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中突出显示的部分是已经更改的部分。其中最重要的部分是`currentPosition[i]`计算部分。我们取时间轴起点和终点之间的距离，并将其与我们的缓动函数返回的位置浮点数相乘，在这个例子中是`easeOutExpo()`。再次，它返回一个介于`0`和`1`之间的浮点变量，表示在抽象的`0`到`1`时间轴上的位置。如果我们用任何数字乘以，比如说`0.33f`，我们得到该数字的三分之一，`0.5f`，我们得到该数字的一半，以此类推。因此，我们将这个距离加到圆的起始位置，我们就得到了它的当前位置！
- en: 'Compile and run our application now. You should see something as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译并运行我们的应用程序。你应该看到以下内容：
- en: '![Using built-in eases](img/9564_06_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![使用内置缓动](img/9564_06_05.jpg)'
- en: 'Almost like a snow storm! We will add a small modification to the code though.
    I will add a `TWEEN_SPEED` definition at the top of the code and multiply the
    `time` parameter passed to the ease function with it, so we can control the speed
    of the circles:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎就像暴风雪一样！不过，我们将在代码中添加一个小修改。我将在代码顶部添加一个`TWEEN_SPEED`定义，并将传递给缓动函数的`time`参数与之相乘，这样我们就可以控制圆的速度：
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Change the following line in the `update()` method implementation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update()`方法实现中更改以下行：
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I did this because the default time base for each tween is 1 second. That means
    that each transition is happening exactly for 1 second and that's a bit too fast
    for our current situation. We want it to be slower, so we multiply the time we
    pass to the easing function with a floating point number that is less than `1.0f`
    and greater than `0.0f`. By doing that we ensure that the time is scaled down
    and instead of 1 second we get 5 seconds for our transition.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我这样做是因为每个缓动的默认时间基是1秒。这意味着每个过渡正好持续1秒，这对于我们当前的情况来说有点快。我们希望它更慢，所以我们将传递给缓动函数的时间与一个小于`1.0f`且大于`0.0f`的浮点数相乘。通过这样做，我们确保时间被缩放，而不是1秒，我们的过渡时间变成了5秒。
- en: 'So try to compile and run this, and see for yourself! Here is the full source
    code of our circle-creation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尝试编译并运行它，看看结果如何！以下是我们的圆创建源代码的完整代码：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Experiment with the properties and try to change the eases. Not all of them
    will work with this example, but at least you will understand how to use them
    to create smooth animations with Cinder.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整属性并尝试更改缓动效果。并非所有这些效果都适用于此示例，但至少你会了解如何使用 Cinder 创建平滑的动画。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created our first generative animation application. We learned
    how to use instance variables for creating smooth movements and random functions
    to generate unpredictable results in predictable scale. We also used static arrays
    to change the count of the circles in the simulation and made use of Cinder easing
    functions that can prove themselves very handy when creating Flash-like applications
    (you might know the TweenLite tweening library, if you have some Flash coding
    background).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了我们的第一个生成动画应用程序。我们学习了如何使用实例变量来创建平滑的运动，以及使用随机函数在可预测的范围内生成不可预测的结果。我们还使用了静态数组来改变模拟中圆的数量，并利用了
    Cinder 缓动函数，这些函数在创建类似 Flash 的应用程序时非常有用（如果你有一些 Flash 编码背景，你可能知道 TweenLite 缓动库）。
- en: Finally, we tested the application with a relatively high amount of objects.
    This part should prove to you the real power of Cinder as you might know that
    creating a similar application with other frameworks based on non-C++ platforms
    does not run as smooth as this one.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用相对大量的对象测试了应用程序。这部分应该向你证明 Cinder 的真正实力，因为你可能知道，使用基于非 C++ 平台的框架创建类似的应用程序并不像这个一样流畅。
- en: In the next chapter, we will talk about real-time post-processing and basic
    methods for applying image, as well as video effects with Cinder.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论使用 Cinder 进行实时后处理以及应用图像和视频效果的基本方法。
