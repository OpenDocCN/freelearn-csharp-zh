- en: Working with Data Bindings
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据绑定一起工作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Working with CLR properties and UI notifications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 CLR 属性和 UI 通知一起工作
- en: Working with dependency properties
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与依赖属性一起工作
- en: Working with attached properties
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与附加属性一起工作
- en: Data binding to an object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据绑定到对象
- en: Data binding to a collection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据绑定到集合
- en: Element-to-element data binding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素到元素的数据绑定
- en: Sorting data in a `DataGrid` control
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `DataGrid` 控件中排序数据
- en: Grouping data in a `DataGrid` control
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `DataGrid` 控件中分组数据
- en: Filtering data in a `DataGrid` control
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `DataGrid` 控件中过滤数据
- en: Using static bindings
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态绑定
- en: Using value converters
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用值转换器
- en: Using multi-value converters
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多值转换器
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Data binding** is a technique to establish a connection between the UI of
    the application and the business logic in order to have proper data synchronization
    between them. Though you can directly access UI controls from code behind to update
    their content, data binding has become the preferred way to update the UI layer
    for its automatic notification system.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据绑定** 是一种在应用程序的 UI 和业务逻辑之间建立连接的技术，以便在它们之间实现适当的数据同步。虽然您可以直接从代码后端访问 UI 控件以更新其内容，但数据绑定由于其自动通知系统已成为更新
    UI 层的首选方式。'
- en: 'To make data binding work in WPF applications, both sides of the binding must
    provide a change notification to the other side. The source property of a data
    binding can be a .NET CLR property or a dependency property, but the target property
    must be a dependency property, as shown here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使数据绑定在 WPF 应用程序中工作，绑定双方都必须向对方提供更改通知。数据绑定的源属性可以是 .NET CLR 属性或依赖属性，但目标属性必须是依赖属性，如下所示：
- en: '![](img/14330605-76a3-417e-b2ec-fca74e9203e9.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/14330605-76a3-417e-b2ec-fca74e9203e9.png)'
- en: Data binding is typically done in XAML using the `{Binding}` markup extension.
    In this chapter, we are going to learn more about the WPF data binding mechanism
    by exploring a few recipes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定通常在 XAML 中使用 `{Binding}` 标记扩展来完成。在本章中，我们将通过探索一些食谱来了解更多关于 WPF 数据绑定机制的信息。
- en: Working with CLR properties and UI notifications
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 CLR 属性和 UI 通知一起工作
- en: The CLR properties are just a wrapper around the private variables to expose
    getters and setters to retrieve and assign the value of a variable. You can use
    these normal CLR properties in data binding, but the automatic UI notifications
    are not possible by default, unless you create the notification mechanism.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 属性只是围绕私有变量的包装，以暴露获取器和设置器来检索和分配变量的值。您可以在数据绑定中使用这些常规 CLR 属性，但默认情况下无法自动进行 UI
    通知，除非您创建通知机制。
- en: In this recipe, we will learn how to perform data binding with CLR properties
    and then learn how to trigger notifications from the code to automatically update
    the UI when the value changes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用 CLR 属性进行数据绑定，然后学习如何从代码中触发通知以在值更改时自动更新 UI。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with data binding with normal CLR properties, open your Visual
    Studio IDE and create a new WPF application project called `CH04.NotificationPropertiesDemo`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用常规 CLR 属性进行数据绑定，请打开您的 Visual Studio IDE 并创建一个名为 `CH04.NotificationPropertiesDemo`
    的新 WPF 应用程序项目。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to create CLR properties that send notifications
    to the UI:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建向 UI 发送通知的 CLR 属性：
- en: 'Open the `MainWindow.xaml` file and give the window a name. For example, name
    the current window `window` by adding the following syntax to the `Window` tag:
    `x:Name="window"`.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 文件并给窗口一个名字。例如，通过在 `Window` 标签中添加以下语法来命名当前窗口 `window`：`x:Name="window"`。
- en: 'Now divide the default `Grid` into a few rows and columns. Copy the following
    XAML markup inside your `Grid` panel:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将默认的 `Grid` 划分为几行和几列。将以下 XAML 标记复制到您的 `Grid` 面板中：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the grid has been divided into rows and columns, let''s add a few text
    and button controls inside it. Place these at proper cells, as shared in the following
    code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦网格被划分为行和列，让我们在它里面添加一些文本和按钮控件。将这些控件放置在适当的单元格中，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now open the code behind the file `MainWindow.xaml.cs` and add two CLR properties
    named `Department` and `PersonName` inside it. The first property (`Department`)
    always returns a constant string, whereas the second property (`PersonName`) can
    accept values from the user. Here''s the complete code:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开 `MainWindow.xaml.cs` 文件背后的代码，并在其中添加两个名为 `Department` 和 `PersonName` 的 CLR
    属性。第一个属性（`Department`）始终返回一个常量字符串，而第二个属性（`PersonName`）可以接受用户的值。以下是完整的代码：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the code-behind class, add the following event implementations:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码后置类中添加以下事件实现：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now build and run the application. As shown in the following screenshot, enter
    your name in the `TextBox` and click the Submit button. A message will be shown
    to the user with the entered name:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建并运行应用程序。如图所示，在 `TextBox` 中输入你的名字并点击提交按钮。系统会向用户显示一个包含输入名字的消息：
- en: '![](img/221e6c32-5d83-4f94-9ef1-2062272bf311.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/221e6c32-5d83-4f94-9ef1-2062272bf311.png)'
- en: 'Now click on the Reset button and watch the behavior. Even though the code
    has been written to set the property with an empty string, the UI was not modified:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击重置按钮并观察行为。尽管代码已经编写为使用空字符串设置属性，但 UI 没有被修改：
- en: '![](img/8bee4bd9-c134-48b7-9348-7e56371f9fab.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bee4bd9-c134-48b7-9348-7e56371f9fab.png)'
- en: 'To send a notification to the UI when there is a change in the associated property,
    you need to implement the `INotifyPropertyChanged` interface, present in the `System.ComponentModel`
    namespace. Open the `MainWindow.xaml.cs` file and add the`INotifyPropertyChanged`
    interface as defined here:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在关联属性发生变化时向 UI 发送通知，你需要实现 `System.ComponentModel` 命名空间中存在的 `INotifyPropertyChanged`
    接口。打开 `MainWindow.xaml.cs` 文件，并添加如下定义的 `INotifyPropertyChanged` 接口：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You need to add the following `using` namespace declaration to resolve the
    build issue:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要添加以下 `using` 命名空间声明来解决构建问题：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following `PropertyChanged` event implementation inside the class:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类内部添加以下 `PropertyChanged` 事件实现：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now notify the framework to update the UI when there is a change in the property
    value. Modify the existing implementation of the `PersonName` property to give
    a call to the `OnPropertyChanged` event, passing the name of the property as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通知框架在属性值发生变化时更新 UI。修改现有的 `PersonName` 属性实现，以调用 `OnPropertyChanged` 事件，并按如下方式传递属性名：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you are using C# 6 and above, you can remove the hardcoded strings by using
    the `nameof` operator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 C# 6 及以上版本，你可以通过使用 `nameof` 运算符来移除硬编码的字符串。
- en: Build and run the application once again. Enter your name in the input box and
    hit the Submit button. You will see the message box mentioning the entered name.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建并运行应用程序。在输入框中输入你的名字并点击提交按钮。你会看到一个消息框，其中提到了输入的名字。
- en: 'Close the message box and hit the Reset button. You will see that the text
    in the `TextBox` initialized to an empty string:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭消息框并点击重置按钮。你会看到 `TextBox` 中的文本被初始化为空字符串：
- en: '![](img/18267dcb-d8c5-4cc0-86a8-4eed1d270284.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18267dcb-d8c5-4cc0-86a8-4eed1d270284.png)'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the preceding example, the `Department` property has a data binding with
    the `TextBlock` control and thus the associated `TextBlock` displays the text
    returned by the property. Similarly, the `PersonName` property has a data binding
    with a `TextBox` control. As the data binding has been made to the `Text` property
    of the `TextBlock` (with `TwoWay` mode), it automatically updates the associated
    property when the user changes it in the UI.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`Department` 属性与 `TextBlock` 控件进行了数据绑定，因此相关的 `TextBlock` 显示了属性返回的文本。同样，`PersonName`
    属性与 `TextBox` 控件进行了数据绑定。由于数据绑定已设置为 `TextBlock` 的 `Text` 属性（使用 `TwoWay` 模式），当用户在
    UI 中更改它时，它会自动更新相关的属性。
- en: So, when you hit the Submit button, the `OnSubmit` event triggers, and it directly
    reads the `PersonName` property instead of fetching the text from the UI by accessing
    the `Text` property of the `TextBox` control.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你点击提交按钮时，`OnSubmit` 事件被触发，并且它直接读取 `PersonName` 属性，而不是通过访问 `TextBox` 控件的
    `Text` 属性从 UI 中获取文本。
- en: When you hit the Reset button, the `OnReset` event triggers and it sets the
    `PersonName` property to an empty string. But the UI does not change. This is
    because the CLR property does not have a notification mechanism to automatically
    update the UI when a value change happens to it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击重置按钮时，`OnReset` 事件被触发，并将 `PersonName` 属性设置为空字符串。但是 UI 没有改变。这是因为 CLR 属性没有在值发生变化时自动更新
    UI 的通知机制。
- en: To overcome this, WPF uses the `INotifyPropertyChanged` interface, which defines
    a `PropertyChanged` event to automatically push the UI notification to update
    the elements in the UI thread. In the example, when you set the `PersonName` property,
    the `OnPropertyChanged` event fires from the property `setter` and notifies the
    UI that the `PersonName` has been modified. The UI then sets the value based on
    the property value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一点，WPF 使用 `INotifyPropertyChanged` 接口，该接口定义了一个 `PropertyChanged` 事件，以自动将
    UI 通知推送到 UI 线程以更新元素。在示例中，当你设置 `PersonName` 属性时，`OnPropertyChanged` 事件从属性 `setter`
    触发，并通知 UI `PersonName` 已被修改。然后 UI 根据属性值设置值。
- en: There's more...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Data binding can be unidirectional (source > target or target > source) or
    bidirectional (source < > target), known as **mode**, and is defined in four categories:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定可以是单向的（源 > 目标或目标 > 源）或双向的（源 < > 目标），称为 **模式**，并定义在四个类别中：
- en: '**OneTime**: This type of data binding mode causes the source property to initialize
    the target property. After the binding gets generated, no notifications will be
    triggered. You should use this type of data binding where the source data does
    not change.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性**: 这种类型的数据绑定模式会导致源属性初始化目标属性。绑定生成后，不会触发任何通知。你应该在源数据不发生变化的地方使用这种类型的数据绑定。'
- en: '**OneWay**: This type of binding causes the source property to automatically
    update the target property. The reverse is not possible here. For example, if
    you want to display a label/text in the UI based on some condition in the code
    behind or business logic, you need to use `OneWay` data binding as you don''t
    need to update back the property from the UI.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单向**: 这种类型的绑定会导致源属性自动更新目标属性。这里不可能反向操作。例如，如果你想在 UI 中根据代码后端或业务逻辑中的某些条件显示标签/文本，你需要使用
    `单向` 数据绑定，因为你不需要从 UI 更新属性。'
- en: '**TwoWay**: This type of binding is a bidirectional data binding, where both
    the source property and the target property can send update notifications. This
    is applicable for editable forms where the user can change the value displayed
    in the UI. For example, the `Text` property of a `TextBox` control supports this
    type of data binding.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向**: 这种类型的绑定是双向数据绑定，其中源属性和目标属性都可以发送更新通知。这适用于用户可以更改 UI 中显示的值的可编辑表单。例如，`TextBox`
    控件的 `Text` 属性支持这种类型的数据绑定。'
- en: '**OneWayToSource**: This is another unidirectional data binding, which causes
    the target property to update the source property (the reverse of `OneWay` binding).
    Here, the UI sends notification to the context and no notification is generated
    if the context changes.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单向到源**: 这是另一种单向数据绑定，它会导致目标属性更新源属性（`单向`绑定的反向）。在这里，UI 向上下文发送通知，如果上下文发生变化则不会生成通知。'
- en: 'Here''s a simple diagram, describing how the various data binding modes work:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的图解，描述了各种数据绑定模式的工作原理：
- en: '![](img/0d2f78d4-084b-4607-a235-b0bdd9776aed.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d2f78d4-084b-4607-a235-b0bdd9776aed.png)'
- en: Working with dependency properties
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与依赖属性一起工作
- en: WPF provides a set of services which can be used to extend the CLR properties
    to provide additional benefits such as automatic UI notifications in the ecosystem.
    To implement the dependency property, the class must be inherited from the `DependencyObject`
    class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 提供了一组服务，可用于扩展 CLR 属性以提供额外的优势，例如在生态系统中提供自动 UI 通知。要实现依赖属性，类必须继承自 `DependencyObject`
    类。
- en: A CLR property reads directly from the private member of the class, whereas
    a dependency property is stored in a dictionary of keys and values provided by
    the base class. As the dependency property stores the property only when it is
    changed, it uses a great deal less memory and is accessed faster.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 属性直接从类的私有成员读取，而依赖属性存储在基类提供的键值字典中。由于依赖属性仅在属性更改时存储属性，因此它使用的内存较少，访问速度更快。
- en: To easily create a dependency property in a `.cs` file, use the `propdp` code
    snippet. In any class file which is inherited from `DependencyObject`, write `propdp`
    followed by *TAB* to generate the structure of it. Navigate using the *TAB* key
    and change the type, name, owner, and metadata details.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `.cs` 文件中轻松创建依赖属性，请使用 `propdp` 代码片段。在继承自 `DependencyObject` 的任何类文件中，输入 `propdp`
    后跟 *TAB* 键以生成其结构。使用 *TAB* 键进行导航，并更改类型、名称、所有者和元数据详细信息。
- en: In this recipe, we will learn how to use a dependency property to automatically
    notify the UI that a change has been made in the property value, which will reduce
    the burden of defining the `PropertyChanged` event from the `INotifyPropertyChanged`
    interface.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用依赖属性来自动通知UI属性值已更改，从而减少从`INotifyPropertyChanged`接口定义`PropertyChanged`事件的负担。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's open the Visual Studio IDE and create a project named `CH04.DependencyPropertyDemo`.
    Make sure that you have selected the WPF application type as a project template.
    We will use the same example that we have created in the previous recipe.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开Visual Studio IDE并创建一个名为`CH04.DependencyPropertyDemo`的项目。确保您已选择WPF应用程序类型作为项目模板。我们将使用我们在上一个食谱中创建的相同示例。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to create a dependency property, bind it to the
    UI, and send notifications from the code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建依赖属性，将其绑定到UI，并从代码中发送通知：
- en: 'From Solution Explorer, open the `MainWindow.xaml` page and use the same UI
    design that we have used in the previous example. Copy the following XAML markup
    and replace the content of the `MainWindow.xaml` file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，打开`MainWindow.xaml`页面，并使用我们在上一个示例中使用的相同UI设计。复制以下XAML标记，并将其替换为`MainWindow.xaml`文件的内容：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now open the code-behind file and add the following CLR property inside the
    class. We don''t need to make it a dependency property, as the value is always
    constant here:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开代码隐藏文件，并在类内部添加以下CLR属性。由于这里的值始终是常量，我们不需要将其作为依赖属性：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, inside the class, write `propdp` and press the *TAB* key twice. It will
    create the structure of the property system. By default, `int` will be highlighted.
    Replace it with `string`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在类内部，输入`propdp`并按*TAB*键两次。这将创建属性系统的结构。默认情况下，`int`将被突出显示。将其替换为`string`。
- en: Press the *TAB* key once again and rename the property name from `MyProperty`
    to `PersonName`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按*TAB*键，将属性名称从`MyProperty`重命名为`PersonName`。
- en: Press the *TAB* key once again to change the focus to the `ownerclass` name
    parameter of the `Register` method. Rename it to the class name of the owner.
    In our case, it is `MainWindow`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按*TAB*键将焦点移至`Register`方法的`ownerclass`名称参数。将其重命名为拥有者的类名。在我们的情况下，它是`MainWindow`。
- en: 'Press the *TAB* key once again to move the focus to the property metadata.
    Here you can set the default value of the property. By default, `0` (zero) is
    selected. Change it to `string.Empty`. Here''s the complete implementation of
    our dependency property, named `PersonName`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按*TAB*键将焦点移至属性元数据。在这里，您可以设置属性的默认值。默认情况下，选择`0`（零）。将其更改为`string.Empty`。这是我们的依赖属性`PersonName`的完整实现：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s add the following event implementations for the Submit and Reset buttons
    inside the `MainWindow` class:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`MainWindow`类内部添加以下事件实现，用于提交和重置按钮：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As the code change has been done, let''s build and run the application. You
    will see the application window pop up on the screen. Enter a name in the provided
    input box and click Submit. The message box will be shown, including the entered
    text:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于代码已更改，让我们构建并运行应用程序。您将在屏幕上看到应用程序窗口弹出。在提供的输入框中输入一个名称，然后点击提交。将显示消息框，包括输入的文本：
- en: '![](img/276819c8-4fb5-411c-84bd-71031c93bbf8.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/276819c8-4fb5-411c-84bd-71031c93bbf8.png)'
- en: 'Click on the Reset button. This will clear the text inside the input box (`TextBox`
    control):'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击重置按钮。这将清除输入框（`TextBox`控件）内的文本：
- en: '![](img/d295ae5e-01fa-481f-a798-a1a2f4db2ee2.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d295ae5e-01fa-481f-a798-a1a2f4db2ee2.png)'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The getters and setters work differently in dependency properties. Rather than
    returning or setting a value from/to its private field (`CLR` property), the dependency
    property calls `GetValue(DependencyProperty)` or `SetValue(DependencyProperty,
    value)` from its base class `DependencyObject`. In our example, the name of the
    dependency property is `PersonNameProperty`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖属性中，获取器和设置器的工作方式不同。而不是从其私有字段（`CLR`属性）返回或设置值，依赖属性从其基类`DependencyObject`调用`GetValue(DependencyProperty)`或`SetValue(DependencyProperty,
    value)`。在我们的示例中，依赖属性的名称是`PersonNameProperty`。
- en: 'The static `Register` method of the `DependencyProperty` class takes a few
    parameters to create the `dependency` property. The first parameter that it takes
    is the actual `name` of the property. The second parameter is the `type` of the
    property, the third is the `owner type` which is basically the class name where
    the `dependency` property is going to create. The next parameter it takes is the
    metadata information, where you can assign the default value of the property.
    Here is the complete code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`DependencyProperty`类的静态`Register`方法接受一些参数来创建`依赖`属性。它接受的第一个参数是属性的`实际名称`。第二个参数是属性的`类型`，第三个是`所有者类型`，基本上是`依赖`属性将要创建的类名。它接受的下一个参数是元数据信息，您可以在其中分配属性的默认值。以下是完整的代码：'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you set a value from the XAML, by providing a data binding with the property,
    it sets the value which you can pick from an accessible place. Similarly, when
    you set the value from code, it automatically notifies the UI that a change has
    been made and performs the same change in the UI. Thus, it reduces the burden
    of implementation of the `INotifyPropertyChanged` interface and its associated
    `PropertyChanged` event.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从XAML设置值时，通过提供与属性的绑定，它设置您可以从可访问位置选择的值。同样，当您从代码设置值时，它会自动通知UI已进行更改，并在UI中执行相同的更改。因此，它减少了实现`INotifyPropertyChanged`接口及其关联的`PropertyChanged`事件的开销。
- en: There's more...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The property metadata of the `Register` method can take one to three arguments
    to it. The first one is the default value that we have seen earlier. The second
    one is the `PropertyChangedCallback`, which is to be called by the property system
    whenever the effective value of the property changes. The third one is the `CoerceValueCallback`,
    which is to be called whenever the property system calls `System.Windows.DependencyObject.CoerceValue`
    method against the property.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register`方法的属性元数据可以接受一到三个参数。第一个是我们在前面看到的默认值。第二个是`PropertyChangedCallback`，当属性的值有效值更改时，属性系统会调用它。第三个是`CoerceValueCallback`，当属性系统对属性调用`System.Windows.DependencyObject.CoerceValue`方法时，会调用它。'
- en: 'Most of the time, the property metadata is created using one to two parameters
    defining the default value and the property changed callback. Let''s learn with
    an example demonstrating how this can be written:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，属性元数据使用一到两个参数创建，定义默认值和属性更改回调。让我们通过一个示例来学习如何编写它：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the `OnPropertyChangedCallback` event will be raised whenever you change
    the value of the property. You can take further action based on the event trigger.
    You can also call other non-static members from the callback event by accessing
    the `DependencyObject` "`d`".
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每当您更改属性的值时，都会触发`OnPropertyChangedCallback`事件。您可以根据事件触发进一步采取行动。您还可以通过访问`DependencyObject`
    "`d`"从回调事件中调用其他非静态成员。
- en: You can also validate a dependency property before submitting it to the property
    system. The fifth parameter of the `Register` method accepts a delegate, called
    `ValidateValueCallback`. You can implement it to validate the effective value
    of the `dependency` property. If the value has been validated properly, it will
    return `true`; if not it will be treated as invalid and will return `false`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在提交给属性系统之前验证依赖属性。`Register`方法的第五个参数接受一个委托，称为`ValidateValueCallback`。您可以实现它来验证`依赖`属性的有效值。如果值已正确验证，它将返回`true`；如果没有，它将被视为无效并返回`false`。
- en: Working with attached properties
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与附加属性一起工作
- en: An attached property is a kind of `dependency` property which is intended to
    be used as a global property type and is settable on any object. It does not have
    conventional property wrapper and can still be used to receive notification of
    a value change. Unlike dependency properties, attached properties are not defined
    in the same class where they are used.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 附加属性是一种`依赖`属性，旨在用作全局属性类型，并且可以在任何对象上设置。它没有传统的属性包装器，但仍可用于接收值更改的通知。与依赖属性不同，附加属性不是定义在它们被使用的同一类中。
- en: The main purpose of using attached properties is to allow different child elements
    to specify unique values of a property, which is actually defined in a parent
    element. For example, you can use `Grid.Row`, `Grid.Column` in any child elements
    of the `Grid` panel. Similarly, the `Canvas.Left`, `Canvas.Top` attached properties
    are used in any child elements of a `Canvas` panel.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用附加属性的主要目的是允许不同的子元素指定父元素中定义的属性的唯一值。例如，您可以在 `Grid` 面板的任何子元素中使用 `Grid.Row`、`Grid.Column`。同样，`Canvas.Left`、`Canvas.Top`
    附加属性用于 `Canvas` 面板的任何子元素。
- en: In this recipe, we will learn how to create an `Attached` property and perform
    the operation from a different class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何创建一个 `Attached` 属性，并从不同的类中执行操作。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, create a new project called `CH04.AttachedPropertyDemo`, based on the
    WPF application project type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `CH04.AttachedPropertyDemo` 的新项目，基于 WPF 应用程序项目类型。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now, perform the following steps to create the `Attached` property named `SelectOnFocus`,
    to a `TextBox` control, which when enabled will select the text on focus change
    by using the *TAB* key:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下步骤以创建名为 `SelectOnFocus` 的 `Attached` 属性，并将其应用于 `TextBox` 控件，当启用时，将使用
    *TAB* 键在焦点改变时选择文本：
- en: Open Solution Explorer, right-click on the project, and add a new class by following
    the Add | Class... context menu path. Give the class the name `TextBoxExtensions`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开解决方案资源管理器，右键单击项目，然后通过以下步骤添加一个新类：在“添加”菜单中选择“类...”。给这个类命名为 `TextBoxExtensions`。
- en: 'Open the `TextBoxExtensions.cs` file and add the following `using` namespace
    inside the class file:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `TextBoxExtensions.cs` 文件，并在类文件中添加以下 `using` 命名空间：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Inside the class body, type `propa` and press *TAB* twice. This will create
    the structure of the attached dependency property and the keyboard focus will
    move to the `property` type, which is `int` by default. Change it to `bool`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类体内部，输入 `propa` 并按 *TAB* 键两次。这将创建附加依赖属性的架构，并将键盘焦点移动到 `property` 类型，默认为 `int`。将其更改为
    `bool`。
- en: Press *TAB* again to select `MyProperty`. Rename it to `SelectOnFocus`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按 *TAB* 键选择 `MyProperty` 并将其重命名为 `SelectOnFocus`。
- en: '*TAB* it once again to select the `ownerclass` and change it to `TextBoxExtensions`.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按 *TAB* 键选择 `ownerclass` 并将其更改为 `TextBoxExtensions`。
- en: 'Press *TAB* to set the property metadata. Set the default value to `false`.
    Set the `PropertyChangedCallback` parameter to `OnSelectOnFocusChanged`. Here''s
    the complete code, including the callback event:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *TAB* 键设置属性元数据。将默认值设置为 `false`。将 `PropertyChangedCallback` 参数设置为 `OnSelectOnFocusChanged`。以下是完整的代码，包括回调事件：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now open the `MainWindow.xaml` file and replace the existing XAML content with
    the following one:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开 `MainWindow.xaml` 文件，将现有的 XAML 内容替换为以下内容：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, build and run the application.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建并运行应用程序。
- en: Focus on the first textbox. It won't have any selection by default. Press *TAB*
    to move the focus to the second textbox. The entire text of the textbox will be
    highlighted. Press *TAB* again to focus on the first textbox. There won't be any
    selection, as the said attached property was added to the second textbox only.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 专注于第一个文本框。默认情况下，它不会有任何选择。按 *TAB* 键将焦点移动到第二个文本框。文本框的全部文本将被突出显示。再次按 *TAB* 键将焦点移回第一个文本框。由于所提到的附加属性仅添加到第二个文本框，因此不会进行选择。
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Dependency properties are registered by calling the `DependencyProperty.Register`
    method, whereas attached properties are registered by calling the `DependencyProperty.RegisterAttached`
    method. It takes four parameters—the actual name of the property, type of the
    property, type of the owner, and property metadata.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `DependencyProperty.Register` 方法注册依赖属性，而通过调用 `DependencyProperty.RegisterAttached`
    方法注册附加属性。它接受四个参数——属性的真正名称、属性类型、所有者类型和属性元数据。
- en: When you set the property to the control, as an attached property (`extensions:TextBoxExtensions.SelectOnFocus="True"`,
    in our example), in the XAML, it registers it to the WPF property system during
    the instance load and fires the `PropertyChangedCallback` defined in the `RegisterAttached`
    method. In the preceding example, the `OnSelectOnFocusChanged` event will be called,
    which will register the `GotFocus` event on the associated `TextBox` control to
    perform the selection of the text.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将属性设置为控件时，作为一个附加属性（在我们的例子中为 `extensions:TextBoxExtensions.SelectOnFocus="True"`），在
    XAML 中，它将在实例加载期间将其注册到 WPF 属性系统，并触发在 `RegisterAttached` 方法中定义的 `PropertyChangedCallback`。在上面的例子中，将调用
    `OnSelectOnFocusChanged` 事件，它将在关联的 `TextBox` 控件上注册 `GotFocus` 事件以执行文本选择。
- en: Instead of a specific control such as `TextBox`, you can use `UIElement` to
    generalize the association. In this way, you can apply it to any control, by registering
    the attached property in the XAML.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与特定的控件如 `TextBox` 不同，您可以使用 `UIElement` 来泛化关联。这样，您可以通过在 XAML 中注册附加属性将其应用于任何控件。
- en: Data binding to an object
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象数据绑定
- en: Up to this point, we have learned how to create CLR properties with the `INotifyPropertyChanged`
    interface; we have also learned about the dependency property with a simple data
    type. There are many instances when you need to bind an object of some class/model
    to an UI and display its associated properties necessary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用 `INotifyPropertyChanged` 接口创建 CLR 属性；我们还了解了一个具有简单数据类型的依赖属性。有许多情况下，您需要将某个类/模型的对象绑定到
    UI 并显示其关联的属性。
- en: In this recipe, we will learn how to do object data binding to show and retrieve
    information to and from the user.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何进行对象数据绑定，以向用户展示和检索信息。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's open the Visual Studio instance and create a new project named `CH04.ObjectBindingDemo`.
    Make sure you select the proper WPF application project type.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 Visual Studio 实例，创建一个名为 `CH04.ObjectBindingDemo` 的新项目。确保您选择了正确的 WPF 应用程序项目类型。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps to create the model and dependency property, and
    bind the data to the UI controls, so that, when a change happens in underlying
    data, it automatically reflects in the UI:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建模型和依赖属性，并将数据绑定到 UI 控件，以便当底层数据发生变化时，它自动反映在 UI 中：
- en: First, we need to create a data model. From Solution Explorer, right-click on
    the project and navigate to the context menu entry Add | Class... and create a
    class file called `Person.cs`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个数据模型。从解决方案资源管理器中，右键单击项目并导航到菜单项添加 | 类... 创建一个名为 `Person.cs` 的类文件。
- en: 'Replace the content of the `Person` class with the following three properties:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Person` 类的内容替换为以下三个属性：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Go to Solution Explorer once again and double-click to open the `MainWindow.xaml.cs`
    file. Create a dependency property named `PersonDetails` and set its data type
    as `Person`. Also, set its default value to `null` as shared here:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次转到解决方案资源管理器，双击打开 `MainWindow.xaml.cs` 文件。创建一个名为 `PersonDetails` 的依赖属性，并将其数据类型设置为
    `Person`。同时，将其默认值设置为 `null`，如下所示：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Just after the `InitializeComponent()` method call, inside the constructor
    of the `MainWindow` class, initialize the `PersonDetails` property and set it
    as the `DataContext` of the selected class as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `InitializeComponent()` 方法调用之后，在 `MainWindow` 类的构造函数内部，初始化 `PersonDetails`
    属性并将其设置为所选类的 `DataContext`，如下所示：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, as the backend code is ready, let's open the `MainWindow.xaml` file to
    design the UI and do the data binding with our model.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，后端代码已经准备好了，让我们打开 `MainWindow.xaml` 文件来设计 UI 并使用我们的模型进行数据绑定。
- en: 'Replace the existing `Grid` panel with the following XAML markup:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 `Grid` 面板替换为以下 XAML 标记：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now compile the project and run the application. You will see the following
    UI:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译项目并运行应用程序。您将看到以下 UI：
- en: '![](img/15628741-7329-45f9-8b2a-66eb5057bab7.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15628741-7329-45f9-8b2a-66eb5057bab7.png)'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The UI of the application has two `TextBlock` controls to represent the data
    and one `TextBox` to get input from the user. In the first `TextBlock` control,
    we have multiple `<Run/>` commands to bind the data value from the `Person` class,
    along with other static texts and a `Hyperlink` to create a link. The data of
    the UI class is bound to the `DataContext`, which is `PersonDetails` in our case.
    The properties binded to the UI come from the `Person` class, which is the data
    type of the `PersonDetails` dependency property.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的 UI 有两个 `TextBlock` 控件来表示数据，以及一个 `TextBox` 来获取用户的输入。在第一个 `TextBlock` 控件中，我们使用了多个
    `<Run/>` 命令来绑定来自 `Person` 类的数据值，以及其他静态文本和一个 `Hyperlink` 来创建链接。UI 类的数据绑定到 `DataContext`，在我们的例子中是
    `PersonDetails`。绑定到 UI 的属性来自 `Person` 类，它是 `PersonDetails` 依赖属性的 数据类型。
- en: 'The `TextBox` control is bound to the `Experience` property, which is again
    bound to the third `Run` command of the first `TextBlock`. Hence, it is showing
    `10` in both places. Now change the value of the `TextBox` control to `15` and
    press the *TAB* key to change the focus. This will trigger the `TextChanged` event
    of the `TextBox` and modify the underlying property named `Experience`. Due to
    its nature, the notification will be automatically sent to the UI and the `TextBlock`
    control will get updated as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBox`控件绑定到`Experience`属性，该属性再次绑定到第一个`TextBlock`的第三个`Run`命令。因此，它在两个地方都显示`10`。现在将`TextBox`控件的值更改为`15`并按*TAB*键更改焦点。这将触发`TextBox`的`TextChanged`事件并修改名为`Experience`的底层属性。由于其性质，通知将自动发送到UI，并且`TextBlock`控件将更新如下：'
- en: '![](img/7ec33b64-7349-44e1-979b-1f937baa2a16.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ec33b64-7349-44e1-979b-1f937baa2a16.png)'
- en: Data binding to a collection
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定到集合
- en: As we learned about object data binding to show a single object on the UI, let's
    begin with binding a collection of data objects in a UI to display all the records
    to the user. We will discuss it in this recipe.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们学习了如何使用对象数据绑定在UI上显示单个对象，让我们从将数据对象集合绑定到UI以显示所有记录给用户开始。我们将在本食谱中讨论它。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open a Visual Studio instance and create a new project called `CH04.CollectionBindingDemo`.
    Make sure you use the WPF application project template.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个Visual Studio实例，创建一个名为`CH04.CollectionBindingDemo`的新项目。确保您使用WPF应用程序项目模板。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to create a collection data model and bind it to
    the UI, using a `DataGrid` control:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建集合数据模型并将其绑定到UI，使用`DataGrid`控件：
- en: Inside the Solution Explorer, right-click on the project. From the context menu,
    navigate to Add | Class... to create a class file named `Employee.cs`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，右键单击项目。从上下文菜单中，导航到添加 | 类... 创建一个名为`Employee.cs`的类文件。
- en: 'Open the `Employee.cs` file and replace the class implementation with the following
    code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Employee.cs`文件，并将类实现替换为以下代码：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Navigate to the `MainWindow.xaml.cs` file and add the following `using` statement
    to define `ObservableCollection` inside the class:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`MainWindow.xaml.cs`文件，并在类中添加以下`using`语句以定义`ObservableCollection`：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Inside the `MainWindow` class implementation, create a dependency property
    named `Employees`, of type `ObservableCollection<Employee>`, as shared here:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow`类的实现中，创建一个名为`Employees`的依赖属性，类型为`ObservableCollection<Employee>`，如下所示：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, just after the `InitializeComponent()` method call inside the constructor,
    write the following code block:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，就在构造函数中`InitializeComponent()`方法调用之后，编写以下代码块：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now open the `MainWindow.xaml` file and a `DataGrid` control inside the default
    `Grid` panel. Create three columns and bind their values to the `FirstName`, `LastName`,
    and `Department` properties of the `Employee` object. Make sure you set the `AutoGenerateColumns`
    property of the `DataGrid` to `False`. Here''s the complete XAML markup:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`MainWindow.xaml`文件，并在默认的`Grid`面板内创建一个`DataGrid`控件。创建三个列并将它们的值绑定到`Employee`对象的`FirstName`、`LastName`和`Department`属性。确保将`DataGrid`的`AutoGenerateColumns`属性设置为`False`。以下是完整的XAML标记：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now build the project and run the application. You will see the following screen,
    along with the data inside a `DataGrid`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建项目并运行应用程序。您将看到以下屏幕，以及`DataGrid`中的数据：
- en: '![](img/5fe8ba1a-dccd-4197-bd40-07dbd1818a5f.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5fe8ba1a-dccd-4197-bd40-07dbd1818a5f.png)'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you bind a collection of objects to a `DataGrid`, it creates data grid
    rows for each object present in the collection. The column defines the properties
    exposed by the object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将对象集合绑定到`DataGrid`时，它会为集合中每个对象创建数据网格行。列定义了对象公开的属性。
- en: When the `AutoGenerateColumns` property of the `DataGrid` is set to `True` (default),
    it automatically creates the columns based on the property list. In this example,
    we have set the `AutoGenerateColumns` property to `False` and defined the individual
    columns explicitly. Using this method, you can define which column to show or
    hide. Once you set the collection to the `ItemsSource` property of the `DataGrid`,
    it populates the rows and columns accordingly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当`DataGrid`的`AutoGenerateColumns`属性设置为`True`（默认值）时，它会根据属性列表自动创建列。在这个例子中，我们将`AutoGenerateColumns`属性设置为`False`并显式定义了各个列。使用这种方法，您可以定义要显示或隐藏的列。一旦将集合设置到`DataGrid`的`ItemsSource`属性，它就会相应地填充行和列。
- en: There's more...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can also define the binding in the XAML. To do this, first open the `MainWindow.xaml.cs`
    and remove the line `dataGrid.ItemsSource = Employees;`. Now, go to the `MainWindow.xaml`
    file and give the window a name (`x:Name="window"`). Now, set the `ItemsSource`
    property of the `DataGrid` control, as mentioned here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 XAML 中定义绑定。为此，首先打开 `MainWindow.xaml.cs` 并删除行 `dataGrid.ItemsSource = Employees;`。现在，转到
    `MainWindow.xaml` 文件并给窗口一个名字（`x:Name="window"`）。现在，设置 `DataGrid` 控件的 `ItemsSource`
    属性，如此处所述：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let's run the application once again, by building the project. You will see
    the same output on the screen.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行应用程序，通过构建项目。你将在屏幕上看到相同的输出。
- en: Element-to-element data binding
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元素到元素的数据绑定
- en: In the last few recipes, we learned how to do object-to-element data binding.
    Though this is commonly used, you will need element-to-element data binding within
    the same XAML page to reduce the extra lines of codes in the code-behind file.
    In this recipe, we will learn how to do this.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几个教程中，我们学习了如何进行对象到元素的数据绑定。尽管这很常见，但你可能需要在同一 XAML 页面内进行元素到元素的数据绑定，以减少代码背后的额外代码行。在本教程中，我们将学习如何做到这一点。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, launch your Visual Studio IDE and create a new WPF application project.
    Give it the name `CH04.ElementToElementBindingDemo`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动你的 Visual Studio IDE 并创建一个新的 WPF 应用程序项目。将其命名为 `CH04.ElementToElementBindingDemo`。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now perform the following steps to design the UI with a `TextBlock` and a `Slider`
    control. Then we will bind the value of the slider control with the `FontSize`
    property of the `TextBlock`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行以下步骤以使用 `TextBlock` 和 `Slider` 控件设计 UI。然后我们将滑块控件的值绑定到 `TextBlock` 的 `FontSize`
    属性：
- en: 'Open the `MainWindow.xaml` page and replace the default `Grid` panel with the
    following XAML markup:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 页面，将默认的 `Grid` 面板替换为以下 XAML 标记：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now build the project and run it. You will see the application UI on the screen,
    with a `TextBlock` and a `Slider` control.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在构建项目并运行它。你将在屏幕上看到应用程序 UI，其中包含一个 `TextBlock` 和 `Slider` 控件。
- en: 'Now increase or decrease the slider value to see the change in the UI, as shown
    in the following screenshot:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在增加或减少滑块值，以查看 UI 中的变化，如图所示：
- en: '![](img/739b0f1e-58be-4931-8db5-03a725eaa071.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/739b0f1e-58be-4931-8db5-03a725eaa071.png)'
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you drag the thumb of the slider, it increases or decreases the value of
    the slider control (`fontSizeSlider`, in our example). The `FontSize` property
    of the `TextBlock` control is directly bound to the value of the slider. So, when
    you drag the slider, based on the value, it increases or decreases the font size.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拖动滑块的滑块时，它会增加或减少滑块控件（在我们的例子中为 `fontSizeSlider`）的值。`TextBlock` 控件的 `FontSize`
    属性直接绑定到滑块的值。因此，当你拖动滑块时，根据值，它会增加或减少字体大小。
- en: Similarly, the `TextBlock` has a few `Run` commands. The `Text` property of
    one of the `Run` commands is also binded with the slider value, and thus, you
    can see the number (current value of slider) on the screen as the font size.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`TextBlock` 有几个 `Run` 命令。其中一个 `Run` 命令的 `Text` 属性也绑定到滑块值，因此，你可以看到屏幕上的数字（滑块的当前值）作为字体大小。
- en: Sorting data in a DataGrid control
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 DataGrid 控件中排序数据
- en: The `DataGrid` control is used to show a number of records in a tabular format.
    Rows and columns are used to display the data. Along with other common functionalities,
    the WPF `DataGrid` control offers a default sorting feature. You can also customize
    this to handle it programmatically. In this recipe, we will learn how to add the
    sorting feature to `DataGrid` and trigger it on demand.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataGrid` 控件用于以表格格式显示多个记录。行和列用于显示数据。除了其他常用功能外，WPF `DataGrid` 控件还提供默认的排序功能。你也可以自定义它以编程方式处理。在本教程中，我们将学习如何将排序功能添加到
    `DataGrid` 并按需触发它。'
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with this recipe, open your Visual Studio editor and create a
    new WPF application project, called `CH04.DataGridSortDemo`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本教程，打开你的 Visual Studio 编辑器并创建一个新的 WPF 应用程序项目，命名为 `CH04.DataGridSortDemo`。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following to create a data model, populate it, and bind it to a
    `DataGrid` in the UI. Later, add a `CheckBox` control to customize the sorting
    functionality:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作以创建数据模型、填充它并将其绑定到 UI 中的 `DataGrid`。稍后，添加一个 `CheckBox` 控件来自定义排序功能：
- en: 'To begin, right-click on the Solution Explorer, create a new class file named
    `Employee.cs`, by following the right-click context menu entry Add | Class...,
    and add a few properties in it:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在解决方案资源管理器上右键单击，通过右键单击上下文菜单项添加 | 类...创建一个名为 `Employee.cs` 的新类文件，并在其中添加一些属性：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Open the `MainWindow.xaml.cs` file and add a dependency property, `Employees`,
    of type `ObservableCollection<Employee>`. Make sure you add the following namespaces,
    `System.Collections.ObjectModel` and `System.ComponentModel`, in order to resolve
    the required classes:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainWindow.xaml.cs`文件，并添加一个类型为`ObservableCollection<Employee>`的依赖属性`Employees`。确保添加以下命名空间，`System.Collections.ObjectModel`和`System.ComponentModel`，以解决所需的类：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Inside the constructor of the `MainWindow` class, initialize the `Employees`
    collection as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow`类的构造函数中，初始化`Employees`集合如下：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now open the `MainWindow.xaml` page and replace the default `Grid` panel with
    a `StackPanel`. Add a `DataGrid` control inside it and give it a name (let's say,
    `dataGrid`). Set its `AutoGenerateColumns` property to `False`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`MainWindow.xaml`页面，将默认的`Grid`面板替换为`StackPanel`。在其内部添加一个`DataGrid`控件，并给它一个名字（比如说，`dataGrid`）。将其`AutoGenerateColumns`属性设置为`False`。
- en: 'Create four data grid columns of type `DataGridTextColumn` and create the data
    binding with the properties exposed from the `Employee` model. Here''s the XAML
    code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建四个类型为`DataGridTextColumn`的数据网格列，并使用从`Employee`模型公开的属性创建数据绑定。以下是XAML代码：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, as the data grid is already in place, assign the `Employees` collection
    as the `ItemsSource` property of the data grid. You can do this inside the `MainWindow.xaml.cs`
    file, just after initialization of the `Employees` collection:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，由于数据网格已经就位，将`Employees`集合分配给数据网格的`ItemsSource`属性。你可以在`MainWindow.xaml.cs`文件中这样做，就在`Employees`集合初始化之后：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you run the application now, you will see a `DataGrid` control with the
    records that we have added into the collection. You will be able to sort the records
    by clicking on the column headers, which is the default functionality of the control:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你将看到一个`DataGrid`控件，其中包含我们添加到集合中的记录。你将能够通过点击列标题来对记录进行排序，这是控件默认的功能：
- en: '![](img/24cea8ab-2139-4446-9c93-ecf876d2a1e7.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24cea8ab-2139-4446-9c93-ecf876d2a1e7.png)'
- en: 'Now we need to add a `CheckBox` control in the UI to toggle the sort on demand.
    Let''s do this for the `Department` column. Add the following `CheckBox` inside
    the `StackPanel`, just after the `DataGrid` control:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在UI中添加一个`CheckBox`控件来按需切换排序。让我们为`Department`列做这个。在`StackPanel`中，在`DataGrid`控件之后添加以下`CheckBox`：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Navigate to the `MainWindow.xaml.cs` file once again, and add the following
    event inside the class:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次导航到`MainWindow.xaml.cs`文件，并在类中添加以下事件：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now run the application again. You will see a new checkbox, under the data
    grid. Toggle the selection (check status) and observe the behavior on the UI:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次运行应用程序。你将看到一个新复选框，位于数据网格下方。切换选择（勾选状态）并观察UI上的行为：
- en: '![](img/b3b2a54f-fb4e-4427-9054-bad6cc0464aa.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b3b2a54f-fb4e-4427-9054-bad6cc0464aa.png)'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once the `OnSortByDepartment` event triggers, it gets the default view of the
    data grid and adds `SortDescription` to the `SortDescriptions` property of the
    default view instance. `SortDescription` takes the property name as the first
    argument. It defines the column for which you want to add the sort functionality.
    The second parameter is the `ListSortDirection`, which can be either `Ascending`
    or `Descending`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`OnSortByDepartment`事件被触发，它就会获取数据网格的默认视图，并将`SortDescription`添加到默认视图实例的`SortDescriptions`属性中。`SortDescription`将属性名称作为第一个参数。它定义了你想要添加排序功能的列。第二个参数是`ListSortDirection`，可以是`Ascending`或`Descending`。
- en: It's not limited to a single `SortDescriptor`. You can add more based on your
    requirement. At any point of time, when you want to reset the view from the applied
    sort description, you can call the `SortDescriptions.Clear()` method on the view
    (in our case, it is `cvs`).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅限于单个`SortDescriptor`。根据你的需求，你可以添加更多。在任何时候，当你想要从应用的排序描述中重置视图时，你可以在视图中调用`SortDescriptions.Clear()`方法（在我们的例子中，它是`cvs`）。
- en: Grouping data in a DataGrid control
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在DataGrid控件中分组数据
- en: The `DataGrid` control also allows you to group the records by field name. In
    this recipe, we are going to learn how to implement this feature using the `PropertyGroupDescription`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataGrid`控件还允许你通过字段名对记录进行分组。在这个菜谱中，我们将学习如何使用`PropertyGroupDescription`实现这个功能。'
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's begin with creating a new project called `CH04.DataGridGroupDemo`. Make
    sure you select the WPF application template while creating the project.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`CH04.DataGridGroupDemo`的新项目开始。确保在创建项目时选择WPF应用程序模板。
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to create groups while displaying records in `DataGrid`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，在`DataGrid`中显示记录时创建分组：
- en: Inside the project, create the `Employee` model class and expose some properties,
    like we shared earlier in the *Sorting data in a DataGrid control* recipe.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中创建 `Employee` 模型类，并公开一些属性，就像我们在 *在 DataGrid 控件中排序数据* 菜单中分享的那样。
- en: Create the same dependency property (`Employees`, of type `ObservableCollection<Employee>`)
    in the `MainWindow.xaml.cs` file and populate the collection with some data records.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow.xaml.cs` 文件中创建相同的依赖属性（`Employees`，类型为 `ObservableCollection<Employee>`）并使用一些数据记录填充集合。
- en: Now open the `MainWindow.xaml` file and add the attribute `x:Name="window"`
    to give the `Window` a name, so that we can perform element-to-element data binding.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `MainWindow.xaml` 文件，并添加属性 `x:Name="window"` 以给 `Window` 命名，这样我们就可以执行元素到元素的数据绑定。
- en: Replace the default `Grid` panel with `StackPanel` and add a `DataGrid` control
    inside it.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认的 `Grid` 面板替换为 `StackPanel`，并在其中添加一个 `DataGrid` 控件。
- en: 'Set the `ItemsSource` property of the `DataGrid` to bind the `Employees` collection,
    exposed from the code behind as a dependency property:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `DataGrid` 的 `ItemsSource` 属性设置为绑定 `Employees` 集合，该集合从代码后端作为依赖属性公开：
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Set the `AutoGenerateColumns` of the data grid to `False`, as we are going to
    add the columns manually.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据网格的 `AutoGenerateColumns` 设置为 `False`，因为我们打算手动添加列。
- en: As shown in the following XAML snippet, add the four columns to the data grid.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下 XAML 片段所示，将四个列添加到数据网格中。
- en: 'Also, add a `CheckBox` control, just after the `DataGrid`, to enable it to
    apply grouping to the records by department name. Here''s the complete XAML code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还在 `DataGrid` 之后添加一个 `CheckBox` 控件，以便能够按部门名称对记录应用分组。以下是完整的 XAML 代码：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we are going to add grouping on the `DataGrid` records, we need to design
    the group style. Add the following snippet inside the `DataGrid`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将在 `DataGrid` 记录上添加分组，我们需要设计分组样式。在 `DataGrid` 内部添加以下片段：
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we will need to add the `OnGroupByDepartment` event implementation. Open
    the `MainWindow.xaml.cs` and add the following code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要添加 `OnGroupByDepartment` 事件实现。打开 `MainWindow.xaml.cs` 并添加以下代码：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run the application now. You will see that the UI contains a `DataGrid` with
    some records.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序。您将看到 UI 中包含一个带有一些记录的 `DataGrid`。
- en: 'Click on the checkbox that says Group by Department and observe the behavior:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击复选框，选择按部门分组，并观察其行为：
- en: '![](img/c3067186-1900-4915-88bb-bdcc02180bd0.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3067186-1900-4915-88bb-bdcc02180bd0.png)'
- en: Uncheck the checkbox to revert the view to its original state.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中复选框，将视图恢复到其原始状态。
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you trigger the `OnGroupByDepartment` event, it retrieves the instance
    of the default view of `DataGrid` and applies the group description to it. The
    grouping applies based on the property name, passed to the `PropertyGroupDescription`,
    as shared here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当您触发 `OnGroupByDepartment` 事件时，它检索 `DataGrid` 默认视图的实例并将分组描述应用到它上。分组基于传递给 `PropertyGroupDescription`
    的属性名称，如下所示：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Based on that, the group style applies to the data grid. The template contains
    an `Expander` control with the name of the column to be grouped as the `Header`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这一点，分组样式应用于数据网格。模板包含一个名为要分组列名的 `Expander` 控件作为 `Header`：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can now expand or collapse the groups and apply sorting or filtering to
    drill down the data. It helps to find the correct record easily.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以展开或折叠组，并应用排序或过滤来深入数据。这有助于轻松找到正确的记录。
- en: There's more...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can also modify the `Expander Header` to display the number of records
    inside a group. The `ItemCount` property can be used to display the record count.
    Modify the `Expander.Header`, as shared here, to customize it:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以修改 `Expander Header` 以显示组内的记录数。`ItemCount` 属性可以用来显示记录数。修改 `Expander.Header`，如下所示，以自定义它：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now build and run the application again. Once the window loads, click on the
    checkbox to group the records by department name. Observe the item count in the
    expander, as shown here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新构建并运行应用程序。一旦窗口加载，点击复选框按部门名称分组记录。观察展开器中的项目数量，如图所示：
- en: '![](img/e2719de3-0fa4-4955-8d25-9b04043577ff.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2719de3-0fa4-4955-8d25-9b04043577ff.png)'
- en: Filtering data in a DataGrid control
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 DataGrid 控件中过滤数据
- en: When we display a set of huge records in a `DataGrid`, it often becomes difficult
    for the user to search for and find a particular record from the grid. In such
    cases, you may want to provide an additional feature to filter the records to
    a specific search term.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `DataGrid` 中显示大量记录时，用户通常很难在网格中搜索和找到特定的记录。在这种情况下，您可能希望提供额外的功能来过滤记录到特定的搜索词。
- en: In this recipe, we will learn how to add a search box to filter records in a
    `DataGrid` control.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在 `DataGrid` 控件中添加一个搜索框以过滤记录。
- en: Getting ready
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's start by creating a WPF application project named `CH04.DataGridFilterDemo`
    in your Visual Studio IDE.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Visual Studio IDE 中创建一个名为 `CH04.DataGridFilterDemo` 的 WPF 应用程序项目。
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Now perform the following steps to add the search functionality attached to
    the grid records:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行以下步骤以添加附加到网格记录的搜索功能：
- en: Once the project has been created, add a new `Employee` model class inside the
    project and expose some properties, like we shared earlier in the *Sorting data
    in a DataGrid control* recipe.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建项目，在项目中添加一个新的 `Employee` 模型类并公开一些属性，就像我们在 *在 DataGrid 控件中排序数据* 食谱中分享的那样。
- en: Create the same dependency property (`Employees`, of type `ObservableCollection<Employee>`)
    in the `MainWindow.xaml.cs` file and populate the collection with some data records.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow.xaml.cs` 文件中创建相同的依赖属性（`Employees`，类型为 `ObservableCollection<Employee>`）并在集合中填充一些数据记录。
- en: Now open the `MainWindow.xaml` file and add the attribute `x:Name="window"`
    to give the `Window` a name, so that we can perform element-to-element data binding.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开 `MainWindow.xaml` 文件并添加属性 `x:Name="window"` 以给 `Window` 命名，这样我们就可以执行元素到元素的数据绑定。
- en: Replace the default `Grid` panel with a `StackPanel`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认的 `Grid` 面板替换为 `StackPanel`。
- en: 'Now insert the following horizontal `StackPanel`, containing one `TextBlock`
    and one `TextBox`, inside the root `StackPanel`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在根 `StackPanel` 内插入以下水平的 `StackPanel`，包含一个 `TextBlock` 和一个 `TextBox`：
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add a `DataGrid` control, having four columns inside it. Set the `AutoGenerateColumns`
    to `False` and add the data binding of the `ItemsSource` property with the `Employees`
    collection (`ItemsSource="{Binding Employees, ElementName=window}"`). Here''s
    the complete code for reference:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `DataGrid` 控件，其中包含四个列。将 `AutoGenerateColumns` 设置为 `False` 并将 `ItemsSource`
    属性的数据绑定到 `Employees` 集合（`ItemsSource="{Binding Employees, ElementName=window}"`）。以下是完整的代码供参考：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now navigate to the `MainWindow.xaml.cs` file, and add the following code blocks
    to implement the `OnFilterChanged` event that gets triggered whenever any text
    changes in the `searchBox`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导航到 `MainWindow.xaml.cs` 文件，并添加以下代码块以实现 `OnFilterChanged` 事件，该事件在 `searchBox`
    中任何文本更改时被触发：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s build the project and run the application. You will see the following
    UI on the screen:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建项目并运行应用程序。你将在屏幕上看到以下 UI：
- en: '![](img/8bb6ba8f-4aba-4b77-a93e-d2f72014d403.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8bb6ba8f-4aba-4b77-a93e-d2f72014d403.png)'
- en: 'Now filter the records by entering some search term in the textbox. Let''s
    enter `Finance` as the keyword and see the behavior:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过在文本框中输入一些搜索词来过滤记录。让我们输入 `Finance` 作为关键词并查看行为：
- en: '![](img/c3e64cdd-119f-4849-95de-7c313a82c997.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c3e64cdd-119f-4849-95de-7c313a82c997.png)'
- en: If you change the search term to perform the following from the records, it
    will filter out only those records.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你更改搜索词以从记录中执行以下操作，它将仅过滤出这些记录。
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you enter a search term, it fires the event `OnFilterChanged` and retrieves
    the default view of the `DataGrid`. It exposes a property named `Filter`, which
    is a predicate. In our example, we assigned the predicate `OnFilterApplied` on
    the `Filter` property, which, when called, compares the term with `Department`,
    `FirstName`, `LastName`, and returns `true` if a match is found. Based on the
    `boolean` value, it shows the said record.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入一个搜索词时，它会触发事件 `OnFilterChanged` 并检索 `DataGrid` 的默认视图。它暴露了一个名为 `Filter` 的属性，这是一个谓词。在我们的例子中，我们在
    `Filter` 属性上分配了谓词 `OnFilterApplied`，当被调用时，它会将术语与 `Department`、`FirstName`、`LastName`
    进行比较，如果找到匹配项则返回 `true`。基于 `boolean` 值，它显示相应的记录。
- en: Using static bindings
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态绑定
- en: Often, we use static properties in our applications. Along with WPF 4.5, Microsoft
    provided us with the option to use static properties in XAML markup, while performing
    data binding. In this recipe, we will learn how to create such bindings. These
    can be useful in the next recipes while using Converters, Styles, and Templates.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在应用程序中使用静态属性。随着 WPF 4.5 的推出，Microsoft 提供了在执行数据绑定时使用 XAML 标记中的静态属性的选择。在本食谱中，我们将学习如何创建此类绑定。这些绑定在后续的食谱中使用
    Converters、Styles 和 Templates 时非常有用。
- en: Getting ready
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's start by creating a new project, called `CH04.StaticBindingDemo`. Open
    your Visual Studio IDE and select the WPF application project as the project template.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `CH04.StaticBindingDemo` 的新项目开始。打开你的 Visual Studio IDE 并选择 WPF 应用程序项目作为项目模板。
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Once the project has been created, perform the following steps to learn static
    binding:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了项目，请执行以下步骤来学习静态绑定：
- en: 'Open the `MainWindow.xaml` page and add a `Label` inside the `Grid` panel.
    Give it a background color (let''s say, `OrangeRed`) and run the application.
    This is what we use most often to write hardcoded values inline:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainWindow.xaml` 页面，并在 `Grid` 面板内添加一个 `Label`。给它一个背景颜色（比如说，`OrangeRed`），然后运行应用程序。这是我们最常用来在行内写入硬编码值的方式：
- en: '[PRE46]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, let''s change it to set a background color from the system defined colors.
    To do this, we need to use `{x:Static}` markup extension to access the static
    properties. Here''s how the code will be changed:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将其更改为从系统定义的颜色设置背景颜色。为此，我们需要使用 `{x:Static}` 标记扩展来访问静态属性。以下是代码将如何更改：
- en: '[PRE47]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can also access locally defined resources, within the XAML page or defined
    in a centralized `ResourceDictionary`. Let''s define a color within the same page,
    under `Window`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以访问在 XAML 页面内定义的本地资源，或者在集中定义的 `ResourceDictionary` 中定义的资源。让我们在同一页面的 `Window`
    下定义一个颜色：
- en: '[PRE48]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add a `Foreground` property to the label, to assign its foreground color. Let''s
    bind it with the static resource (`myBrush`), that we defined earlier. Here''s
    the code for reference:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向标签添加一个 `Foreground` 属性，以分配其前景颜色。让我们将其绑定到我们之前定义的静态资源（`myBrush`）。以下是代码供参考：
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now let''s build and run the application. You will see the colors similar to
    the following screenshot, where the background will have a light gray color (based
    on the color set to your system''s `ControlDarkBrush`) and the foreground will
    have a greenish yellow color:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们构建并运行应用程序。你将看到类似于以下截图的颜色，其中背景将具有浅灰色（基于设置到系统 `ControlDarkBrush` 的颜色），前景将具有黄绿色：
- en: '![](img/b2f60b3b-453e-4b65-9016-e899914a0ee9.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2f60b3b-453e-4b65-9016-e899914a0ee9.png)'
- en: How it works...
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A markup extension is a class that derives from `System.Windows.Markup.MarkupExtension`
    and implements a single method named `ProvideValue`. In this example, we have
    used the `{x:Static}` markup extension, implemented by the `System.Windows.Markup.StaticExtension`
    class, which allowed you to access the static property.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 标记扩展是一个从 `System.Windows.Markup.MarkupExtension` 派生的类，并实现了一个名为 `ProvideValue`
    的单方法。在这个例子中，我们使用了由 `System.Windows.Markup.StaticExtension` 类实现的 `{x:Static}` 标记扩展，它允许你访问静态属性。
- en: Similarly, the `{StaticResource}` is used to access the resource (`Color`, `Brush`,
    `Converter`, and more), defined in a XAML.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`{StaticResource}` 用于访问在 XAML 中定义的资源（颜色、画刷、转换器等）。
- en: Using value converters
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用值转换器
- en: Converters are often useful when you want to perform data binding between two
    properties that have incompatible types. In such cases, you will need a piece
    of code which creates a bridge between source and target. This piece of code is
    defined as a **value converter**.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想在两个类型不兼容的属性之间进行数据绑定时，转换器非常有用。在这种情况下，你需要一段代码来在源和目标之间建立桥梁。这段代码被定义为 **值转换器**。
- en: The `IValueConverter` interface is used to create value converters and contains
    two methods named `Convert` and `ConvertBack:`
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`IValueConverter` 接口用于创建值转换器，并包含两个名为 `Convert` 和 `ConvertBack` 的方法：'
- en: '**Convert(...)**: It gets called when the source updates the target object'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Convert(...)**：当源更新目标对象时被调用'
- en: '**ConvertBack(...)**: It gets called when the target object updates the source
    object'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConvertBack(...)**：当目标对象更新源对象时被调用'
- en: In this recipe, we will learn how to create value converters and use them while
    data binding.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建值转换器并在数据绑定中使用它们。
- en: Getting ready
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's begin by creating a new WPF project. Call it `CH04.ConverterDemo`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的 WPF 项目开始。命名为 `CH04.ConverterDemo`。
- en: How to do it...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To begin with the value converter, perform the following steps:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始值转换器，请执行以下步骤：
- en: From the Solution Explorer, open the `MainWindow.xaml` file.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中打开 `MainWindow.xaml` 文件。
- en: 'Replace the existing `Grid` with the following XAML markup, which contains
    a `CheckBox` and a `Rectangle` inside a `StackPanel`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 `Grid` 替换为以下 XAML 标记，它包含一个 `CheckBox` 和一个 `Rectangle`，它们位于 `StackPanel`
    内：
- en: '[PRE50]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There is a data binding between the `Visibility` property of the `Rectangle`
    and the `IsChecked` property of the `CheckBox` control. If you build and run the
    application, you will see that there exists no visible change in the UI when you
    change the checked state of the checkbox:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Rectangle` 的 `Visibility` 属性与 `CheckBox` 控件的 `IsChecked` 属性之间存在数据绑定。如果你构建并运行应用程序，当你改变复选框的选中状态时，你将看到
    UI 中没有明显的可见变化：'
- en: '![](img/16d39b4b-fbae-4449-985a-f15f497a4a25.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/16d39b4b-fbae-4449-985a-f15f497a4a25.png)'
- en: As the `Visibility` property does not accept `boolean` values, the `Rectangle`
    stays always visible by default. Now we will add the converter to it, which will
    automatically convert the value from `bool` to `Visibility`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`Visibility`属性不接受`boolean`值，因此`Rectangle`默认情况下始终可见。现在我们将添加转换器到它，这将自动将值从`bool`转换为`Visibility`。
- en: Let's create a new class file in the project. Name it `BoolToVisibilityConverter`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在项目中创建一个新的类文件。将其命名为`BoolToVisibilityConverter`。
- en: Open the `BoolToVisibilityConverter.cs` file and add the following namespaces—`System`,
    `System.Globalization`, `System.Windows`, and `System.Windows.Data` as `using`
    statement.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BoolToVisibilityConverter.cs`文件，并添加以下命名空间——`System`、`System.Globalization`、`System.Windows`和`System.Windows.Data`作为`using`语句。
- en: Now, mark the class as `public` and implement the `IValueConverter` interface.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将类标记为`public`并实现`IValueConverter`接口。
- en: 'Add the following two code blocks inside the class:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类内部添加以下两个代码块：
- en: '[PRE51]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, go to the `MainWindow.xaml` file and add the following XMLNS namespace,
    so that we can declare the converter as a window resource:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到`MainWindow.xaml`文件，添加以下XMLNS命名空间，以便我们可以将转换器声明为窗口资源：
- en: 'Inside the `Window` tag, add the following markup to declare the converter
    that we have created:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Window`标签内，添加以下标记以声明我们创建的转换器：
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, in the binding syntax of the `Visibility` property of `Rectangle`, associate
    the converter as `StaticResource`, as shown in the following code snippet:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Rectangle`的`Visibility`属性的绑定语法中，将转换器关联为`StaticResource`，如下面的代码片段所示：
- en: '[PRE53]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Once this is done, build the project and run the application.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，构建项目并运行应用程序。
- en: 'By default, the checkbox will be unchecked and the rectangle will not be visible
    on the screen. Change the state of the checkbox to checked and observe that the
    rectangle will become visible on the screen. Unchecking the box will again hide
    the rectangle:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，复选框将处于未选中状态，矩形将不会在屏幕上可见。将复选框的状态更改为选中，观察矩形将变为可见。再次取消选中复选框将再次隐藏矩形：
- en: '![](img/79724832-3b9e-4b6f-b302-a0aa63222852.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/79724832-3b9e-4b6f-b302-a0aa63222852.png)'
- en: How it works...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A value converter is used to convert one value to another, by implementing the
    `IValueConverter` interface. The values may be of the same type or different types,
    but require some transformation that is not possible declaratively. These are
    often powerful because they are written in code, and hence have more logic to
    control the functionality.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用值转换器（`IValueConverter`接口）将一个值转换为另一个值。这些值可以是相同类型或不同类型，但需要一些无法声明式实现的转换。由于它们是编写在代码中的，因此通常非常强大，因为它们具有更多的逻辑来控制功能。
- en: An instance of the converter is generally created in the XAML page and declared
    as a resource. Then it sets to the controls by using binding expressions with
    the `Converter` property.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器的实例通常在XAML页面上创建，并声明为资源。然后通过使用带有`Converter`属性的绑定表达式将其设置到控件上。
- en: Whenever the source property changes, the converter returns a different result
    through the `Convert` method. The `ConvertBack` method is called in a two-way
    binding mode, where the source and target are reversed. In a one-way binding,
    there's no need to implement `ConvertBack` and generally we set its body to return
    an exception, like this—`throw new NotImplementedException()`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 每当源属性发生变化时，转换器通过`Convert`方法返回不同的结果。在双向绑定模式下，会调用`ConvertBack`方法，其中源和目标被反转。在单向绑定中，不需要实现`ConvertBack`，通常我们将它的主体设置为返回一个异常，如下所示——`throw
    new NotImplementedException();`。
- en: There's more...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can extend the functionality of the converter by using the converter parameter.
    Let's modify the `Convert` method to utilize the parameter named `parameter` and
    reverse the visibility based on its value.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用转换器参数来扩展转换器的功能。让我们修改`Convert`方法，以利用名为`parameter`的参数并根据其值反转可见性。
- en: 'To do so, open the `BoolToVisibilityConverter.cs` and modify the class implementation
    as shared in the following code snippet:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请打开`BoolToVisibilityConverter.cs`并修改类实现，如下面的代码片段所示：
- en: '[PRE54]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, open the `MainWindow.xaml` file and modify the data binding of the `Visibility`
    property of the `Rectangle` to have a `ConverterParameter=inverse`, as shared
    here:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`MainWindow.xaml`文件，并修改`Rectangle`的`Visibility`属性的绑定，使其具有`ConverterParameter=inverse`，如下所示：
- en: '[PRE55]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s build and run the application. You will see that, this time, the rectangle
    will be visible by default when the checkbox is unchecked. Now change the status
    of the checkbox to check, and you will see that the rectangle becomes visible
    on the screen:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并运行应用程序。您将看到，这次，当复选框未选中时，矩形将默认可见。现在将复选框的状态更改为选中，您将看到矩形在屏幕上变得可见：
- en: '![](img/cc010dd1-837e-4796-aac1-22924c24bad4.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cc010dd1-837e-4796-aac1-22924c24bad4.png)'
- en: You can, of course, change the implementation and the value of the `ConverterParameter`,
    based on your business requirement, and use the same converter class to return
    different values on various conditions.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以根据业务需求更改实现和 `ConverterParameter` 的值，并使用相同的转换器类在不同的条件下返回不同的值。
- en: 'You can also use `BooleanToVisibilityConverter`, provided by .NET Framework.
    You can read more about this converter here: [https://msdn.microsoft.com/en-us/library/system.windows.controls.booleantovisibilityconverter(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.windows.controls.booleantovisibilityconverter(v=vs.110).aspx).'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 .NET Framework 提供的 `BooleanToVisibilityConverter`。您可以在此处了解更多关于此转换器的信息：[https://msdn.microsoft.com/en-us/library/system.windows.controls.booleantovisibilityconverter(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.windows.controls.booleantovisibilityconverter(v=vs.110).aspx)。
- en: Using multi-value converters
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多值转换器
- en: When you want to change the target value based on multiple values of the same
    or different types, you will need to use multi-binding. This is done by using
    a multi-value converter (`IMultiValueConverter` interface).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想根据相同或不同类型的多值更改目标值时，您需要使用多绑定。这是通过使用多值转换器（`IMultiValueConverter` 接口）来完成的。
- en: In this recipe, we will build a sample demo to learn how to work with multi-binding
    and multi-value converters.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建一个示例演示，学习如何使用多绑定和多值转换器。
- en: Getting ready
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open your Visual Studio IDE and create a new project called `CH04.MultiValueConverterDemo`,
    based on the WPF application project template.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的 Visual Studio IDE 并创建一个名为 `CH04.MultiValueConverterDemo` 的新项目，基于 WPF 应用程序项目模板。
- en: How to do it...
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Once the project is created, follow these steps to design the UI and do a multi-binding
    between multiple elements:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建项目，请按照以下步骤设计 UI 并在多个元素之间进行多绑定：
- en: From the Solution Explorer, open the `MainWindow.xaml` page.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中打开 `MainWindow.xaml` 页面。
- en: 'Inside the default `Grid` panel, create a few rows and columns, so that we
    can position elements at specific cells. Let''s divide the `Grid` into five rows
    and three columns:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认的 `Grid` 面板内，创建一些行和列，以便我们可以将元素定位在特定的单元格中。让我们将 `Grid` 分为五行和三列：
- en: '[PRE56]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Inside the `Grid` panel, insert the following XAML code snippet to add few
    labels and input boxes inside the window:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Grid` 面板内，插入以下 XAML 代码片段，在窗口内添加一些标签和输入框：
- en: '[PRE57]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Build the project and run the application. You will see four input boxes on
    the screen, along with their associated labels as follows:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并运行应用程序。您将在屏幕上看到四个输入框及其相关的标签，如下所示：
- en: '![](img/1656b782-5683-48f8-bee6-d3705f04be3a.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1656b782-5683-48f8-bee6-d3705f04be3a.png)'
- en: Let's close the application and return to the Solution Explorer. Create a new
    class named `FullNameConverter` inside the project.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们关闭应用程序并返回到解决方案资源管理器。在项目中创建一个名为 `FullNameConverter` 的新类。
- en: Open the `FullNameConverter.cs` file and implement `IMultiValueConverter` on
    it.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `FullNameConverter.cs` 文件并在其上实现 `IMultiValueConverter`。
- en: Define the following `using` namespaces in the class file—`System`, `System.Globalization`,
    and `System.Windows.Data`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类文件中定义以下 `using` 命名空间—`System`、`System.Globalization` 和 `System.Windows.Data`。
- en: 'Now add the following two methods inside the class, which implements the methods
    defined in `IMultiValueConverter` interface:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在类内部添加以下两个方法，这些方法实现了 `IMultiValueConverter` 接口中定义的方法：
- en: '[PRE58]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now navigate to the `MainWindow.xaml` page and add the following XMLNS namespace,
    so that the converter can be accessible from the XAML markup:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导航到 `MainWindow.xaml` 页面，并添加以下 XMLNS 命名空间，以便转换器可以从 XAML 标记中访问：
- en: 'Now add the converter to the window resource. To do this, inside the `Window`
    tag, add the following markup to define the instance by key name:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将转换器添加到窗口资源中。为此，在 `Window` 标签内，添加以下标记以通过键名定义实例：
- en: '[PRE59]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, inside the `Text` property of the `fullName` textbox, define the multi-binding
    to bind the property with the `Text` property of three `TextBox` controls. Here''s
    the code:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `fullName` 文本框的 `Text` 属性中，定义多绑定以将属性绑定到三个 `TextBox` 控件的 `Text` 属性。以下是代码：
- en: '[PRE60]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once the binding is done, build the project and run the application. You will
    see the same UI on the screen. Enter some strings in the `Firstname`, `Middle`,
    and `Lastname` fields. Observe the value in the `Fullname` field:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成绑定，构建项目并运行应用程序。你将在屏幕上看到相同的用户界面。在`FirstName`、`Middle`和`Lastname`字段中输入一些字符串。观察`Fullname`字段中的值：
- en: '![](img/a1186b7b-855f-431f-aac6-2e0849b5d863.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1186b7b-855f-431f-aac6-2e0849b5d863.png)'
- en: Similarly, change the `Fullname` field to hold three strings. Press the *TAB*
    key once you are done, and observe the value of the other three fields—`Firstname`,
    `Middle` and `Lastname`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，将`Fullname`字段更改为包含三个字符串。完成操作后按一下*TAB*键，并观察其他三个字段——`FirstName`、`Middle`和`Lastname`的值。
- en: How it works...
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you use a converter of type `IMultiValueConverter` in a `MultiBinding`,
    it passes the values defined by the `Binding` tag to the `Convert` method as an
    object array. In our preceding example, we passed three string values (`firstName`,
    `middleName`, and `lastName`) to the `Convert` method. The method then concatenated
    the strings to form a single string, which was the output string of the `Fullname`
    field as the binding was made with its `Text` property.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`MultiBinding`中使用类型为`IMultiValueConverter`的转换器时，它将`Binding`标签定义的值作为一个对象数组传递给`Convert`方法。在我们前面的例子中，我们将三个字符串值（`firstName`、`middleName`和`lastName`）传递给`Convert`方法。该方法然后将这些字符串连接起来形成一个单一的字符串，这就是`Fullname`字段的输出字符串，因为绑定是通过其`Text`属性进行的。
- en: Similarly, when we changed the value of the `Fullname` field, the `ConvertBack`
    method triggered by the binding converter and returned the splitted strings. As
    per the binding order, those automatically got assigned to the respective fields—`Firstname`,
    `Middle`, and `Lastname`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们更改`Fullname`字段的值时，绑定转换器触发的`ConvertBack`方法返回了分割的字符串。根据绑定顺序，这些值自动分配到相应的字段——`FirstName`、`Middle`和`Lastname`。
