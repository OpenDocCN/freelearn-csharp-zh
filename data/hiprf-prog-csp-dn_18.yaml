- en: '*Chapter 15*: Parallel Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 15 章*：并行编程'
- en: In this chapter, you will learn how to take advantage of the multiple CPU cores
    that are available in today’s modern computers. You will learn how to process
    your code by distributing the work between processes concurrently, as well as
    how to use the **Task Parallel Library** (**TPL**) and **Parallel LINQ** (**PLINQ**)
    to run code in parallel. Throughout this book, you will learn how to use parallel
    data structures and use the Visual Studio debugger to diagnose tasks and parallel
    stacks. You will also learn about the Concurrency Visualizer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何利用现代计算机中可用的多个 CPU 核心来提高性能。你将学习如何通过在进程之间并发分配工作来处理代码，以及如何使用 **任务并行库**（**TPL**）和
    **并行 LINQ**（**PLINQ**）来并行运行代码。在本书中，你将学习如何使用并行数据结构，并使用 Visual Studio 调试器来诊断任务和并行堆栈。你还将了解并发可视化器。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '**Using the Task Parallel Library (TPL)**: In this section, we will compare
    parallel and non-parallel code and its effect on CPU core utilization using *perfmon*.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用任务并行库（TPL）**：在本节中，我们将比较并行和非并行代码及其对 CPU 核心利用率的影响，使用 *perfmon*。'
- en: '**Using Parallel LINQ (PLINQ)**: In this section, we will look at PLINQ and
    how it can be used to execute LINQ statements with varying degrees of parallelism.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用并行 LINQ (PLINQ)**：在本节中，我们将查看 PLINQ 以及如何使用它以不同的并行度执行 LINQ 语句。'
- en: '**Programming parallel data structures**: In this section, we will review some
    of the thread-safe collections you can use for programming parallel data structures.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编程并行数据结构**：在本节中，我们将回顾一些你可以用于编程并行数据结构的线程安全集合。'
- en: '**Benchmarking with BenchmarkDotNet**: In this section, we will look at benchmarking
    our parallel code and find that, in some instances, it can be faster than non-parallel
    code, and at other times, it can be slower.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 BenchmarkDotNet 进行基准测试**：在本节中，我们将查看我们的并行代码的基准测试，并发现，在某些情况下，它可能比非并行代码更快，而在其他时候，它可能更慢。'
- en: '`Func` and `Action` delegates.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Func` 和 `Action` 委托。'
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下事项：
- en: Use TPL and PLINQ for parallel programming tasks.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TPL 和 PLINQ 进行并行编程任务。
- en: Program parallel data structures.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程并行数据结构。
- en: Diagnose issues with tasks and parallel data structures.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诊断任务和并行数据结构的问题。
- en: Use lambda expressions in TPL and PLINQ queries.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 TPL 和 PLINQ 查询中使用 lambda 表达式。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下内容：
- en: Visual Studio 2022
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022
- en: 'This book’s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH15](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH15)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书源代码：[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH15](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH15)
- en: 'Concurrency Visualizer for Visual Studio 2022: [https://marketplace.visualstudio.com/items?itemName=Diagnostics.DiagnosticsConcurrencyVisualizer2022#overview](https://marketplace.visualstudio.com/items?itemName=Diagnostics.DiagnosticsConcurrencyVisualizer2022#overview)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 的并发可视化器：[https://marketplace.visualstudio.com/items?itemName=Diagnostics.DiagnosticsConcurrencyVisualizer2022#overview](https://marketplace.visualstudio.com/items?itemName=Diagnostics.DiagnosticsConcurrencyVisualizer2022#overview)
- en: Using the Task Parallel Library (TPL)
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用任务并行库（TPL）
- en: In this chapter, we will be working with TPL to enhance the performance of our
    programs by making use of the available processor power on a machine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 TPL 通过利用机器上可用的处理器能力来提高我们程序的性能。
- en: We learned how to write threads and execute them in [*Chapter 14*](B16617_14_Final_SB_Epub.xhtml#_idTextAnchor254),
    *Multi-Threaded Programming*. When multiple threads are running on a single processor,
    providing the illusion that they are running in parallel, they are running concurrently.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第 14 章*](B16617_14_Final_SB_Epub.xhtml#_idTextAnchor254)“多线程编程”中学习了如何编写线程并执行它们。当多个线程在单个处理器上运行时，它们提供了并行运行的错觉，但实际上它们是并发运行的。
- en: When threads run concurrently, the processor uses a scheduling algorithm and/or
    interrupts to determine the switching and prioritization between threads. Parallel
    programming, however, runs different threads on different processors so that threads
    execute in parallel to each other with a reduced need for switching and thread
    interrupts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程并发运行时，处理器使用调度算法和/或中断来确定线程之间的切换和优先级。然而，并行编程在不同的处理器上运行不同的线程，这样线程可以相互并行执行，减少了切换和线程中断的需求。
- en: As its name suggests, TPL is used to run tasks in parallel. Tasks are run in
    parallel by running each task against a separate core of the computer’s processor.
    So, for example, say your computer has four cores and you have four tasks. Each
    task would run on a separate core, and each task would be run parallel to the
    other three. This helps improve the overall performance of the code as you can
    have as many tasks executing in parallel as you have processor cores.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，TPL用于并行运行任务。任务通过在计算机处理器的每个单独的核心上运行每个任务来并行运行。例如，如果你的计算机有四个核心，你有四个任务。每个任务将在单独的核心上运行，并且每个任务将与另外三个任务并行运行。这有助于提高代码的整体性能，因为你可以有与处理器核心一样多的任务并行执行。
- en: Also, if you have a big dataset that needs to process many records and store
    them in a variable, you can partition the task so that the records are split into
    different threads running on different processors. These are then synced backed
    together and stored in a variable.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你有一个需要处理大量记录并存储在变量中的大数据集，你可以将任务分割成不同的线程，这些线程在不同的处理器上运行。然后，这些线程同步合并并存储在变量中。
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Code that cannot be parallelized will slow down parallel tasks, as will code
    that must be partitioned and scheduled by the task scheduler. It is always a good
    idea to profile your code to see if the methods you are employing will speed up
    or slow things down.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无法并行化的代码会减慢并行任务的速度，同样，必须由任务调度器分割和调度的代码也会减慢速度。始终是一个好主意，对你的代码进行性能分析，看看你使用的方法是否会加快或减慢事情的速度。
- en: 'A good way to see the value in parallel programming is to compare a thread
    running on a single processor against the same code split between different processors.
    Let’s write some code for this comparison:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到并行编程的价值，一个好的方法是将单处理器上运行的线程与在不同处理器上分割的相同代码进行比较。让我们为这个比较编写一些代码：
- en: Start a new console application and call it `CH15_ParallelProgramming`. Then,
    check the checkbox that says **do not use top-level statements**.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的控制台应用程序，并将其命名为`CH15_ParallelProgramming`。然后，勾选表示**不使用顶级语句**的复选框。
- en: 'Add the following `using` statement:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`using`语句：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This `using` statement gives us access to TPL.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此`using`语句为我们提供了对TPL的访问。
- en: 'Update the `Main` method in the `Program` class, as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Program`类中的`Main`方法，如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method calls the `RunSingleProcessorExample` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法调用`RunSingleProcessorExample`方法。
- en: 'Add the `RunSingleProcessorExample` method:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`RunSingleProcessorExample`方法：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method creates a new thread and assigns it the `SingleProcessorExample`
    method, which it will invoke. The method is then invoked using the `Start` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建一个新的线程，并给它分配`SingleProcessorExample`方法，它将调用该方法。然后使用`Start`方法调用该方法。
- en: 'Now, add `SingleProcessorMethod`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`SingleProcessorMethod`：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method writes the value of the `for` loop index to the console window 1
    million times and then pauses until it receives a user keypress.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将`for`循环索引的值写入控制台窗口一百万次，然后暂停，直到接收到用户按键。
- en: Type `Performance Monitor` into your task bar’s search area and open it. Then,
    remove the existing counter, and then add a counter to view the processor time
    for all the processors on your computer. If you need to, you can change the thickness
    of the lines.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任务栏的搜索区域中输入`性能监控器`并打开它。然后，删除现有的计数器，然后添加一个计数器来查看计算机上所有处理器的处理器时间。如果需要，你可以更改线的粗细。
- en: 'Clear out the **Performance Monitor** screen and then run the console app.
    You should see something similar to the following:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除**性能监控器**屏幕，然后运行控制台应用程序。你应该看到以下类似的内容：
- en: '![Figure 15.1 – Performance Monitor with our console application running'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.1 – 运行中的控制台应用程序的性能监控器'
- en: '](img/B16617_Figure_15.1.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16617_Figure_15.1.jpg)'
- en: Figure 15.1 – Performance Monitor with our console application running
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.1 – 运行中的控制台应用程序的性能监控器'
- en: As you can see, processor instance 1 is the most utilized processor. What we
    need to do is modify the program to utilize all available processors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，处理器实例1是最被充分利用的处理器。我们需要做的是修改程序以利用所有可用的处理器。
- en: 'Comment out the method call in the `Main` method and add the following code
    after the commented-out method:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法中注释掉方法调用，并在注释掉的方法之后添加以下代码：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code uses a parallel `for` loop to process the `MultipleProcessorExample`
    method 1 million times.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用并行 `for` 循环处理 `MultipleProcessorExample` 方法一百万次。
- en: 'Run the code again. You should see the following in Performance Monitor:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码。你应该在性能监视器中看到以下内容：
- en: '![Figure 15.2 – Performance Monitor showing all our processors being used by
    our modified program'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.2 – 性能监视器显示我们的修改后的程序正在使用所有处理器'
- en: '](img/B16617_Figure_15.2.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_15.2.jpg)'
- en: Figure 15.2 – Performance Monitor showing all our processors being used by our
    modified program
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 – 性能监视器显示我们的修改后的程序正在使用所有处理器
- en: As you can see, with very minimal code, you can go from utilizing a single processor
    to utilizing all the processors using TPL. In previous chapters, you learned how
    to use *BenchmarkDotNET* to benchmark the performance of different variations
    of the same code. When deciding whether to turn your single processor code into
    multiple processor code, it’s a good idea to benchmark. There is an overhead to
    using parallel code, so you need to ensure that parallel code will improve your
    program.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过非常少的代码，你可以从利用单个处理器转变为利用所有处理器，使用 TPL。在之前的章节中，你学习了如何使用 *BenchmarkDotNET*
    来基准测试同一代码的不同变体的性能。在决定是否将你的单处理器代码转换为多处理器代码时，进行基准测试是个好主意。使用并行代码会有开销，因此你需要确保并行代码会提高你的程序性能。
- en: Now, let’s learn how to use PLINQ.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用 PLINQ。
- en: Using Parallel LINQ (PLINQ)
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并行 LINQ (PLINQ)
- en: 'In this section, you will learn how to convert your sequential LINQ queries
    into parallel LINQ using PLINQ. Take a look at the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用 PLINQ 将你的顺序 LINQ 查询转换为并行 LINQ。看看以下代码：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code calls the `GetProductNames` method and stores the results
    in the `productNames` variable. A LINQ statement is then performed on the `productNames`
    list to extract a list of all product names greater than eight characters in length.
    The result of this LINQ statement is then stored in the `names` variable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码调用了 `GetProductNames` 方法，并将结果存储在 `productNames` 变量中。然后对 `productNames` 列表执行
    LINQ 语句，以提取所有长度大于八个字符的产品名称列表。此 LINQ 语句的结果随后存储在 `names` 变量中。
- en: 'The following code is identical to the preceding code, except we have modified
    it so that it operates in parallel across multiple processors:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码与前面的代码相同，但我们已对其进行修改，使其在多个处理器上并行运行：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we can see that the only change to the LINQ statement to get it to execute
    as parallel LINQ is to add the `AsParallel()` method call. The rest of the code
    stays the same.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，要使 LINQ 语句执行为并行 LINQ，唯一的更改是添加 `AsParallel()` 方法调用。其余代码保持不变。
- en: 'If you want the data to be returned from the PLINQ statement, then suffix the
    `AsParallel()` call with the `AsOrdered()` call:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望从 PLINQ 语句中返回数据，那么在 `AsParallel()` 调用后加上 `AsOrdered()` 调用：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code will return a list of product names whose lengths are greater
    than `8` in alphabetical order.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将返回一个按字母顺序排列的产品名称列表，其长度大于 `8`。
- en: 'PLINQ utilizes all the processors on the executing computer. However, you can
    limit the number of processors that are used by PLINQ using the `WithDegreeOfParallelism`
    call, passing in the number of processors you want to limit PLINQ being executed
    on:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ 利用执行计算机上的所有处理器。然而，你可以使用 `WithDegreeOfParallelism` 调用来限制 PLINQ 使用的处理器数量，传递你想要限制
    PLINQ 执行的处理器数量：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code has been limited to running on only two processors.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仅限于在两个处理器上运行。
- en: 'The following are some performance considerations when using PLINQ:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PLINQ 时，以下是一些性能考虑因素：
- en: Don’t use PLINQ on single-core computers. This would result in slower performance
    than using standard LINQ.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在单核计算机上使用 PLINQ。这会导致比使用标准 LINQ 更慢的性能。
- en: '`AsOrdered()` will slow PLINQ down. Only use it if you need to. Benchmark alternative
    ordering techniques to see which is quickest, and then implement the quickest
    method.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsOrdered()` 会减慢 PLINQ 的速度。只有在你需要的时候才使用它。基准测试替代排序技术，看看哪个最快，然后实现最快的方法。'
- en: Employ production-sized datasets when developing and testing your PLINQ code.
    This will reveal performance issues sooner rather than later!
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发和测试你的 PLINQ 代码时，使用生产规模的数据库集。这将更快地揭示性能问题！
- en: Avoid using PLINQ on small collections since this could provide less performance.
    This is because PLINQ has been optimized for large datasets.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在小型集合上使用 PLINQ，因为这可能会提供较低的性能。这是因为 PLINQ 已经针对大型数据集进行了优化。
- en: In the next section, we will consider some data structures that are suitable
    for parallel programming.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将考虑一些适合并行编程的数据结构。
- en: Programming parallel data structures
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行数据结构编程
- en: When we do parallel programming, we should always consider that we are using
    threads. Therefore, we should use data structures that are thread-safe.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行并行编程时，我们应该始终考虑我们正在使用线程。因此，我们应该使用线程安全的 数据结构。
- en: For types that implement the `IProducerConsumerCollection<T>` interface, you
    should use the generic `BlockingCollection<T>` class, which provides bounding
    and blocking functionality. Use the `ConcurrentDictionary<TKey, TValue>` class
    for thread-safe dictionaries. For thread-safe FIFO queues, use the `ConcurrentQueue<T>`
    class. Use the `ConcurrentStack<T>` class for LIFO stacks. For a thread-safe implementation
    of a collection of elements, use the `ConcurrentBag<T>` class. Finally, for types
    to be used in a `BlockingCollection`, implement the `IProducerConsumerCollection<T>`
    class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现 `IProducerConsumerCollection<T>` 接口的数据类型，你应该使用通用的 `BlockingCollection<T>`
    类，它提供了边界和阻塞功能。使用 `ConcurrentDictionary<TKey, TValue>` 类来创建线程安全的字典。对于线程安全的 FIFO
    队列，使用 `ConcurrentQueue<T>` 类。使用 `ConcurrentStack<T>` 类来创建 LIFO 栈。对于线程安全的元素集合实现，使用
    `ConcurrentBag<T>` 类。最后，对于要在 `BlockingCollection` 中使用的类型，实现 `IProducerConsumerCollection<T>`
    类。
- en: 'You can read more about thread-safe collections on the Microsoft Docs website:
    [https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/](https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Microsoft Docs 网站上了解更多有关线程安全集合的信息：[https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/](https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)。
- en: Next, we’ll look at benchmarking loops, LINQ, and PLINQ.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看基准测试循环、LINQ 和 PLINQ。
- en: Benchmarking with BenchmarkDotNet
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BenchmarkDotNet 进行基准测试
- en: 'In this section, we will benchmark some methods to determine which method gives
    us the best performance. Keep in mind that there is some initial expense when
    running code in parallel. So, sometimes, parallel code may not be the best option
    for improving code performance. Let’s get started:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将基准测试一些方法以确定哪种方法能给我们带来最佳性能。请注意，在并行运行代码时会有一些初始开销。因此，有时并行代码可能不是提高代码性能的最佳选择。让我们开始吧：
- en: 'Comment out the code in the `Main` method and add the following line:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法中注释掉代码并添加以下行：
- en: '[PRE24]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Add a class called `Benchmarks`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Benchmarks` 的类。
- en: 'Add the following `NuGet` packages:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `NuGet` 包：
- en: '`BenchmarkDotNet`'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BenchmarkDotNet`'
- en: '`LinqOptimizer.Csharp`'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LinqOptimizer.Csharp`'
- en: Add the `using` statements for each of the `NuGet` packages to the `Benchmarks`
    class.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个 `NuGet` 包的 `using` 语句添加到 `Benchmarks` 类中。
- en: 'Add the following code to set up our benchmarks:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码来设置我们的基准测试：
- en: '[PRE25]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we are declaring an array that’s a short data type. The array is then
    initialized and filled with values. This array will be used by two of the following
    six methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们声明了一个短数据类型的数组。然后初始化并填充该数组。这个数组将被以下六个方法中的两个使用。
- en: 'Add the `StandardForLoopExample` method:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `StandardForLoopExample` 方法：
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code uses a standard `foreach` loop to loop through the values
    in the data array and then writes the value of the array at the given index to
    the console window.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码使用标准的 `foreach` 循环遍历数据数组中的值，然后将数组在给定索引处的值写入控制台窗口。
- en: 'Add the `ParallelForLoopExample` method:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ParallelForLoopExample` 方法：
- en: '[PRE27]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code does the same as the preceding code but executes the code
    using PLINQ.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码与上一段代码执行相同，但使用 PLINQ 执行代码。
- en: 'Add the `UrlDownloader1` method:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `UrlDownloader1` 方法：
- en: '[PRE28]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code creates an array of URLs and downloads their content using
    a `foreach` loop.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码创建了一个 URL 数组，并使用 `foreach` 循环下载它们的内容。
- en: 'Add the `UrlDownloader2` method:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `UrlDownloader2` 方法：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding code creates an array of URLs and downloads them as a set of tasks.
    The code waits for all the tasks to complete before the content is returned.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码创建了一个 URL 数组，并将它们作为一系列任务下载。代码会在返回内容之前等待所有任务完成。
- en: 'Add the `Urldownloader3` method:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `Urldownloader3` 方法：
- en: '[PRE62]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The preceding code uses a `Parallel.ForeEach` loop to download the contents
    of URLs stored in an array.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码使用 `Parallel.ForeEach` 循环下载存储在数组中的 URL 的内容。
- en: 'Make sure that your project is set to Release mode, and then run your program.
    The program will take some time to execute. However, once it has finished executing,
    you should see something similar to the following:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的项目设置为发布模式，然后运行你的程序。程序将需要一些时间来执行。然而，一旦执行完成，你应该看到以下类似的内容：
- en: '![Figure 15.3 – BenchmarkDotNet results'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.3 – BenchmarkDotNet结果'
- en: '](img/B16617_Figure_15.3.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.3 – BenchmarkDotNet结果](img/B16617_Figure_15.3.jpg)'
- en: Figure 15.3 – BenchmarkDotNet results
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 – BenchmarkDotNet结果
- en: Looking at the `ForEachLoop` examples, we can see that the standard `foreach`
    loop executed faster than our `Parallel.ForEach` loop. And so, in this example,
    using parallel code was slightly slower than using non-parallel code. But if the
    dataset was much larger and the data type was more complex, then the results could
    show that parallel code performs faster.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到`ForEachLoop`示例，我们可以看到标准的`foreach`循环比我们的`Parallel.ForEach`循环执行得更快。因此，在这个例子中，使用并行代码比使用非并行代码稍微慢一些。但如果数据集很大且数据类型更复杂，那么结果可能会显示并行代码执行得更快。
- en: When looking at our `UrlDownloader` methods, `UrlDownloader4` uses the `Parallel.ForEach`
    loop, which is much faster than the two methods that use the `foreach` loop and
    `foreach` with lambda methods. However, the method that creates an array of tasks
    and waits for them all to complete is slightly faster than the `Parallel.ForEach`
    loop.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看我们的`UrlDownloader`方法时，`UrlDownloader4`使用`Parallel.ForEach`循环，这比使用`foreach`循环和带有lambda方法的`foreach`循环的方法要快得多。然而，创建任务数组并等待它们全部完成的方法比`Parallel.ForEach`循环稍微快一些。
- en: From these test results, we can see that we have different ways to perform the
    same actions, and each method’s processing speed is different. In some cases,
    we have seen that parallel code is slower than non-parallel code, while in others,
    we have seen that parallel code is faster than non-parallel code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些测试结果中，我们可以看到我们有不同的方式执行相同的行为，每种方法的处理速度都不同。在某些情况下，我们看到了并行代码比非并行代码慢，而在其他情况下，我们看到了并行代码比非并行代码快。
- en: When performance is an issue, you can use BenchmarkDotNet to test the efficiency
    of different approaches to the same task. Then, you can choose the most efficient
    option for the problem that you are trying to solve.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当性能成为问题时，你可以使用BenchmarkDotNet来测试对同一任务的多种不同方法的效率。然后，你可以为你要解决的问题选择最有效的选项。
- en: In the next section, we will learn how to use lambda expressions with TPL and
    LINQ.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用TPL和LINQ的lambda表达式。
- en: Using lambda expressions with TPL and LINQ
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TPL和LINQ的lambda表达式
- en: There are several methods in TPL that take a `System.Func<TResult>` or `System.Action`
    delegate as an input parameter. These can be used to pass custom logic into a
    task, query, or parallel loop. Inline blocks can be used when creating delegates.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: TPL中有几个方法接受`System.Func<TResult>`或`System.Action`委托作为输入参数。这些可以用来将自定义逻辑传递到任务、查询或并行循环中。在创建委托时可以使用内联块。
- en: 'Use `Func` delegates to encapsulate methods that return a value and use `Action`
    delegates to encapsulate methods that do not return values. Let’s review the following
    example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Func`委托封装返回值的函数，使用`Action`委托封装不返回值的函数。让我们回顾以下示例：
- en: '[PRE88]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The preceding code shows how to use the `Parallel.ForEach` method and a thread-local
    state. We expect the code to execute in parallel and sum up all the values stored
    in the `int` array. Each thread of the `Parallel.For` loop maintains a local addition
    variable. This addition variable is set to `0` when each thread is initialized.
    With each iteration, the addition is incremented with the number value. Once the
    thread has completed its task, the local sum for that thread is safely added to
    the global sum. The global sum is then printed out once the loop is complete.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了如何使用`Parallel.ForEach`方法和线程局部状态。我们期望代码以并行方式执行并计算存储在`int`数组中的所有值。`Parallel.For`循环的每个线程维护一个局部累加变量。当每个线程初始化时，该累加变量被设置为`0`。随着每次迭代的进行，累加变量会加上数值。一旦线程完成其任务，该线程的局部总和会安全地添加到全局总和。循环完成后，全局总和将被打印出来。
- en: 'The preceding code also demonstrates how to use lambda expressions to express
    both `Func` and `Action` delegates:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码还展示了如何使用lambda表达式来表示`Func`和`Action`委托：
- en: '[PRE119]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: In the next section, we will look at some parallel debugging tools.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些并行调试工具。
- en: Parallel debugging and profiling tools
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行调试和性能分析工具
- en: In this section, we will look at three parallel application debugging and profiling
    tools. These are the `CH15_ParallelProgrammingDebuggingAndProfilingSample` project
    for this. We will be using this project as we work through the next three sections.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨三个并行应用程序调试和性能分析工具。为此，我们使用了`CH15_ParallelProgrammingDebuggingAndProfilingSample`项目。在接下来的三个部分中，我们将使用此项目。
- en: The Parallel Stacks window
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行堆栈窗口
- en: 'Run the program until it is paused by the debugger. Then, from the **Visual
    Studio** menu, select **Debug** | **Windows** | **Parallel Tasks**. This will
    display the **Parallel Tasks** window. You should see the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，直到调试器将其暂停。然后，从**Visual Studio**菜单中选择**调试** | **窗口** | **并行任务**。这将显示**并行任务**窗口。你应该会看到以下内容：
- en: '![Figure 15.4 – The Parallel Stacks thread view'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.4 – 并行堆栈线程视图'
- en: '](img/B16617_Figure_15.4.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16617_Figure_15.4.jpg)'
- en: Figure 15.4 – The Parallel Stacks thread view
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4 – 并行堆栈线程视图
- en: As you can see, our main thread is initiated via our `Program.Main` method.
    We can see that the debugger is paused in `Program.MethodC`. There are four threads
    – one each for methods A, B, and C, and a fourth in external code. There are also
    five threads running – these are external code threads.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的主线程是通过我们的`Program.Main`方法启动的。我们可以看到调试器暂停在`Program.MethodC`。有四个线程 – 分别对应方法A、B和C，以及外部代码中的一个。还有五个线程正在运行
    – 这些是外部代码线程。
- en: 'If you hover over the methods, you will see the following popup:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当你悬停在方法上时，你会看到以下弹出窗口：
- en: '![Figure 15.5 – The Parallel Stacks thread view with the Thread and Stack Frame
    view displayed'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.5 – 显示线程和堆栈帧视图的并行堆栈线程视图'
- en: '](img/B16617_Figure_15.5.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16617_Figure_15.5.jpg)'
- en: Figure 15.5 – The Parallel Stacks thread view with the Thread and Stack Frame
    view displayed
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5 – 显示线程和堆栈帧视图的并行堆栈线程视图
- en: 'By hovering over each method group, you get to see a table of threads and their
    stack frames. These stack frames provide the method name and line number. The
    active stack frame of the current thread is identified by the yellow arrow. If
    you right-click while hovering over the stack frame, you can select what details
    to show, including parameter values, as shown here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过悬停在每个方法组上，你可以看到一个线程和它们的堆栈帧的表格。这些堆栈帧提供了方法名称和行号。当前线程的活动堆栈帧由黄色箭头标识。如果你在悬停在堆栈帧上时右键单击，你可以选择显示哪些详细信息，包括参数值，如下所示：
- en: '![Figure 15.6 – The Thread and Stack Frame view'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.6 – 线程和堆栈帧视图'
- en: '](img/B16617_Figure_15.6.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16617_Figure_15.6.jpg)'
- en: Figure 15.6 – The Thread and Stack Frame view
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.6 – 线程和堆栈帧视图
- en: Here, we can see the values of each of the parameters of our thread methods.
    Next, we will look at the **Tasks** window.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们线程方法的每个参数的值。接下来，我们将查看**任务**窗口。
- en: The Tasks window
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务窗口
- en: 'To view the **Tasks** window, from the **Parallel Tasks** tab, select **Tasks**
    from the dropdown. You should see the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看**任务**窗口，从**并行任务**选项卡中选择下拉菜单中的**任务**。你应该会看到以下内容：
- en: '![Figure 15.7 – The Tasks view'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.7 – 任务视图'
- en: '](img/B16617_Figure_15.7.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16617_Figure_15.7.jpg)'
- en: Figure 15.7 – The Tasks view
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.7 – 任务视图
- en: 'The preceding screenshot shows the async logical stacks. If you hover over
    each method, you will see the following window pop up, as you did with the threads
    view:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了异步逻辑堆栈。如果你悬停在方法上，你会看到一个弹出窗口，就像你在线程视图中做的那样：
- en: '![Figure 15.8 – The Thread and Stack Frame view'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.8 – 线程和堆栈帧视图'
- en: '](img/B16617_Figure_15.6.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16617_Figure_15.6.jpg)'
- en: Figure 15.8 – The Thread and Stack Frame view
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.8 – 线程和堆栈帧视图'
- en: 'From the **Visual Studio** menu, select **Debug** | **Windows** | **Tasks**.
    You should see the following pane:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Visual Studio**菜单中选择**调试** | **窗口** | **任务**。你应该会看到以下窗格：
- en: '![Figure 15.9 – The Tasks pane'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.9 – 任务窗格'
- en: '](img/B16617_Figure_15.9.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16617_Figure_15.9.jpg)'
- en: Figure 15.9 – The Tasks pane
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.9 – 任务窗格
- en: This view shows you the various tasks and their states, along with other information.
    You can right-click on the columns to customize what columns you want to see.
    Clicking on a line should take you to the source location for you to view the
    code.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图显示了各种任务及其状态，以及其他信息。你可以右键单击列来自定义你想要看到的列。单击行应将你带到源位置以查看代码。
- en: In the next section, we will look at the Concurrency Visualizer.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨并发可视化器。
- en: The Concurrency Visualizer
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发可视化器
- en: The Concurrency Visualizer is a command-line utility that allows you to collect
    traces from the command line. These can be viewed in the Concurrency Visualizer
    for Visual Studio 2022, which can be used on computers that don’t have Visual
    Studio installed. Web projects are not supported by the Concurrency Visualizer;
    it relies on Windows event tracing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 并发可视化器是一个命令行实用工具，允许您从命令行收集跟踪数据。这些数据可以在Visual Studio 2022的并发可视化器中查看，该可视化器可用于未安装Visual
    Studio的计算机。并发可视化器不支持Web项目；它依赖于Windows事件跟踪。
- en: By default, `CVCollectionCmd.exe` is installed in `C:\Program Files\Microsoft
    Visual Studio\2022\Preview\Common7\IDE\Extensions\rf2nfg00.o0t` and/or `C:\Program
    Files\Microsoft Visual Studio\2022\Community\Common7\IDE\Extensions\rf2nfg00.o0t`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`CVCollectionCmd.exe`安装在`C:\Program Files\Microsoft Visual Studio\2022\Preview\Common7\IDE\Extensions\rf2nfg00.o0t`和/或`C:\Program
    Files\Microsoft Visual Studio\2022\Community\Common7\IDE\Extensions\rf2nfg00.o0t`。
- en: 'To begin collecting a trace, you can use a command such as the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始收集跟踪，您可以使用以下命令：
- en: '[PRE122]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This will start our application and log trace data to the location specified
    by the `/outdir` command-line argument. Several files will be generated by the
    tool. They will have `.etl` and `.cvtrace` file extensions.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动我们的应用程序并将跟踪数据记录到由`/outdir`命令行参数指定的位置。工具将生成几个文件，它们将具有`.etl`和`.cvtrace`文件扩展名。
- en: 'From the **Visual Studio** menu, select **Analyze** | **Concurrency Visualizer**
    | **Open Trace** to view the generated trace file. You should see something similar
    to the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Visual Studio**菜单中选择**分析** | **并发可视化器** | **打开跟踪**以查看生成的跟踪文件。您应该看到以下类似的内容：
- en: '![Figure 15.10 – The Contextual Visualizer Utilization tab'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.10 – 上下文可视化器利用率选项卡'
- en: '](img/B16617_Figure_15.10.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_Figure_15.10.jpg](img/B16617_Figure_15.10.jpg)'
- en: Figure 15.10 – The Contextual Visualizer Utilization tab
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10 – 上下文可视化器利用率选项卡
- en: 'This screen shows the number of logical cores that are being utilized by the
    program you have traced. As you can see, my computer has 16 logical cores. Out
    of those 16, only 12 are being utilized. Clicking on the **Threads** tab gives
    you the following view:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕显示了您所追踪的程序正在使用的逻辑核心数量。正如您所看到的，我的计算机有16个逻辑核心。在这16个核心中，只有12个正在被使用。点击**线程**选项卡将显示以下视图：
- en: '![Figure 15.11 – The Contextual Visualizer Threads tab'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.11 – 上下文可视化器线程选项卡'
- en: '](img/B16617_Figure_15.11.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_Figure_15.11.jpg](img/B16617_Figure_15.11.jpg)'
- en: Figure 15.11 – The Contextual Visualizer Threads tab
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11 – 上下文可视化器线程选项卡
- en: 'This screen gives us a good, detailed breakdown of the threads that were used,
    their functionality, and the time they took to execute. Clicking on the **Cores**
    tab will display the following view:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕为我们提供了关于所使用的线程、其功能和执行时间的良好、详细的分解。点击**核心**选项卡将显示以下视图：
- en: '![Figure 15.12 – The Contextual Visualizer Cores tab'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.12 – 上下文可视化器核心选项卡'
- en: '](img/B16617_Figure_15.12.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_Figure_15.12.jpg](img/B16617_Figure_15.12.jpg)'
- en: Figure 15.12 – The Contextual Visualizer Cores tab
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12 – 上下文可视化器核心选项卡
- en: This view shows the logical cores and their usage by the main thread and worker
    thread. You will see the thread ID, its name, the number of cross-core context
    switches, total context switches, and the percent of context switches.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图显示了逻辑核心及其由主线程和工作线程的使用情况。您将看到线程ID、其名称、跨核心上下文切换次数、总上下文切换次数以及上下文切换的百分比。
- en: Note
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Microsoft provides a more detailed look into the Concurrency Visualizer. I have
    just provided you with a brief overview of the tool and how to use it. If you
    would like to learn more about how to use this tool, then you can view Microsoft’s
    documentation at [https://docs.microsoft.com/en-us/visualstudio/profiling/concurrency-visualizer?view=vs-2022](https://docs.microsoft.com/en-us/visualstudio/profiling/concurrency-visualizer?view=vs-2022).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供了对并发可视化器的更详细说明。我刚刚为您提供了该工具的简要概述及其使用方法。如果您想了解更多关于如何使用此工具的信息，可以查看微软的文档，链接为[https://docs.microsoft.com/en-us/visualstudio/profiling/concurrency-visualizer?view=vs-2022](https://docs.microsoft.com/en-us/visualstudio/profiling/concurrency-visualizer?view=vs-2022)。
- en: With that, we’ve reached the end of this chapter. Now, let’s summarize what
    we’ve learned.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们已经到达了本章的结尾。现在，让我们总结一下我们所学到的内容。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to use TPL and PLINQ to execute code in parallel.
    At this point, we understand that the main difference between TPL and PLINQ is
    that TPL does not efficiently utilize all the cores on a computer, whereas PLINQ
    does.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用TPL和PLINQ来并行执行代码。到目前为止，我们了解到TPL和PLINQ之间的主要区别在于TPL不能有效地利用计算机上的所有核心，而PLINQ可以。
- en: We also saw how we can view the computer’s CPU utilization. Using PLINQ enables
    us to utilize all the cores of a CPU efficiently to improve code performance.
    However, when benchmarking parallel code, we saw that it is sometimes faster than
    non-parallel code, while other times, it is faster. Therefore, it pays to benchmark
    your code to see what method works best for you.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何查看计算机的CPU利用率。使用PLINQ使我们能够有效地利用CPU的所有核心来提高代码性能。然而，在基准测试并行代码时，我们发现它有时比非并行代码更快，而有时则更快。因此，对你的代码进行基准测试以查看哪种方法最适合你是有益的。
- en: We also reviewed a piece of code that demonstrates the use of lambda expressions
    for expressing both `Func` and `Action` delegates.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还回顾了一段代码，展示了如何使用lambda表达式来表示`Func`和`Action`委托。
- en: Finally, we looked at debugging parallel applications with a code sample that
    employed the Parallel Tasks window, the Tasks pane, and the Concurrency Visualizer.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过一个使用Parallel Tasks窗口、任务面板和并发可视化器的代码示例来查看并行应用程序的调试。
- en: In the next chapter, we will look at asynchronous programming. But before we
    do, try and answer the questions to see how well you have retained what you have
    read. Then, check out the *Further reading* section to enhance your knowledge.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨异步编程。但在我们这样做之前，试着回答这些问题，看看你记住了多少。然后，查看*进一步阅读*部分以增强你的知识。
- en: Questions
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: What does TPL stand for?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TPL代表什么？
- en: What does PLINQ stand for?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PLINQ代表什么？
- en: What Windows program can you use to view CPU core usage?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么Windows程序来查看CPU核心使用情况？
- en: Is parallel code always faster than non-parallel code?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行代码是否总是比非并行代码更快？
- en: How can you measure the code performance of parallel methods?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何测量并行方法的代码性能？
- en: Further reading
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涵盖的主题，请查看以下资源：
- en: '*Lambda Expressions in PLINQ and TPL*: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl)'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PLINQ和TPL中的Lambda表达式*: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/lambda-expressions-in-plinq-and-tpl)'
- en: '*Task Parallel Library (TPL)*: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl)'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*任务并行库 (TPL)*: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl)'
- en: '*Introduction to PLINQ*: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PLINQ简介*: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq)'
- en: '*Parallel Diagnostic Tools*: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/parallel-diagnostic-tools](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/parallel-diagnostic-tools)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并行诊断工具*: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/parallel-diagnostic-tools](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/parallel-diagnostic-tools)'
- en: '*Debugging Async Code: Parallel Stacks for Tasks*: [https://devblogs.microsoft.com/visualstudio/debugging-async-code-parallel-stacks-for-tasks/](https://devblogs.microsoft.com/visualstudio/debugging-async-code-parallel-stacks-for-tasks/)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试异步代码：任务的并行堆栈*: [https://devblogs.microsoft.com/visualstudio/debugging-async-code-parallel-stacks-for-tasks/](https://devblogs.microsoft.com/visualstudio/debugging-async-code-parallel-stacks-for-tasks/)'
- en: '*Walkthrough: Debugging a Parallel Application in Visual Studio (C#, Visual
    Basic, C++)*: [https://docs.microsoft.com/en-us/visualstudio/debugger/walkthrough-debugging-a-parallel-application?view=vs-2022&tabs=csharp#main](https://docs.microsoft.com/en-us/visualstudio/debugger/walkthrough-debugging-a-parallel-application?view=vs-2022&tabs=csharp#main)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Visual Studio中调试并行应用程序（C#、Visual Basic、C++）的教程*: [https://docs.microsoft.com/en-us/visualstudio/debugger/walkthrough-debugging-a-parallel-application?view=vs-2022&tabs=csharp#main](https://docs.microsoft.com/en-us/visualstudio/debugger/walkthrough-debugging-a-parallel-application?view=vs-2022&tabs=csharp#main)'
