- en: Chapter 2. Messages and Transforms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。消息和转换
- en: 'In [Chapter 1](ch01.html "Chapter 1. Hello BizTalk Services"), *Hello BizTalk
    Services*, we discussed the basics of **BizTalk Services** and the central concept
    of a bridge providing the vehicle for receiving and sending data via endpoint
    adapters (sources and destinations) through its built-in pipeline. In this chapter,
    we''ll discuss messaging aspects, focusing on one particular aspect of messaging:
    transformation, or mapping. One of the most common aspects of integration is the
    need to turn one message format into another; what we referred to as structural
    impedance in [Chapter 1](ch01.html "Chapter 1. Hello BizTalk Services"), *Hello
    BizTalk Services*. It''s the bread and butter of any integrator''s toolbox, and
    BizTalk Services provides a brand new, modern mapping engine with graphical tooling
    to build sophisticated and powerful transforms. In this chapter, we''ll look at
    BizTalk Service''s mapping and transformation capabilities in detail and the flexibility
    it provides. To summarize, this chapter will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。Hello BizTalk Services") *Hello BizTalk Services* 中，我们讨论了**BizTalk
    Services**的基础知识和桥梁提供的数据接收和发送的中央概念，通过其内置的管道通过端点适配器（源和目的地）。在本章中，我们将讨论消息方面，重点关注消息的一个特定方面：转换，或映射。集成最常见的一个方面是将一种消息格式转换为另一种格式；我们在[第1章](ch01.html
    "第1章。Hello BizTalk Services") *Hello BizTalk Services* 中提到的结构阻抗。这是任何集成人员工具箱中的基本工具，BizTalk
    Services提供了一个全新的、现代化的映射引擎，以及图形工具来构建复杂和强大的转换。在本章中，我们将详细探讨BizTalk Service的映射和转换功能及其提供的灵活性。总结来说，本章将涵盖以下内容：
- en: Why transformation and mapping is important
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么转换和映射很重要
- en: Mapping capabilities in BizTalk Services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BizTalk Services中的映射功能
- en: Creating your first map
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个映射
- en: Understanding mapping operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解映射操作
- en: The problem
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'BizTalk Services'' job is to let you connect this to that. What this and that
    actually are may not always be clear, well defined, or standardized into some
    internationally recognized protocol. A mapping capability is therefore crucial—a
    way to convert this into that. On many occasions, mapping requirements may be
    complex; the need to fundamentally change the shape or structure of a message,
    for example, or the need to replace data values from the source message with something
    that makes sense to the receiver. We can break this down into two classes of problems:
    one that needs to address the structure of a message, transformation; and one
    that needs to address its content, transcoding or translating it. The two types
    of mapping, transformation and translation, are both possible with BizTalk Services,
    as we''ll see in this chapter.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: BizTalk Services的职责是让您将此连接到彼。实际上，这个“此”和“彼”可能并不总是清晰、明确，或者标准化为某种国际认可的协议。因此，映射功能至关重要——一种将此转换为彼的方法。在许多情况下，映射需求可能很复杂；例如，需要基本改变消息的形状或结构，或者需要用对接收者有意义的内容替换源消息中的数据值。我们可以将这些问题分为两类：一类需要解决消息的结构，即转换；另一类需要解决其内容，即转码或翻译。两种类型的映射，转换和翻译，在BizTalk
    Services中都是可能的，正如我们将在本章中看到的。
- en: The mapper
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射器
- en: 'So far, we''re being deliberately vague, and with good reason. Often, mapping
    requirements are not well known and change as more is discovered about the nuances
    of the messaging formats involved and their variations. It often surprises people
    familiar with dealing with XML-based messages that describing their validity simply
    in terms of schema by using XML Schema Definition ([http://www.w3.org/XML/Schema](http://www.w3.org/XML/Schema))
    can turn out to be more complicated than it first appears. This is unfortunately
    sometimes to do with the different productions or instances of XML messages that
    can be created or produced by a single schema, often unintentionally. XSD is sometimes
    not precise enough, and integration is therefore often messy, requiring good tools
    to make things fit, while the purity of standards and specifications doesn''t
    go far enough to avoid ambiguity in implementation. This is a theme we''ll come
    back to many times during this book: to be successful, any integration technology
    must be flexible to bend to the problem at hand, to fit into that, to not be changed,
    to adapt, to transform, and to integrate. Mapping is one tool in the box, and
    is a very important one to meet these requirements. As such, it deserves a chapter
    all to itself.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们故意保持模糊，并且有很好的理由。通常，映射需求并不明确，并且随着对涉及的消息格式的细微差别及其变体的了解越来越多，它们会发生变化。熟悉处理基于XML的消息的人可能会惊讶地发现，仅仅使用XML
    Schema Definition ([http://www.w3.org/XML/Schema](http://www.w3.org/XML/Schema))来描述它们的有效性，结果可能比最初看起来要复杂。不幸的是，这有时与单个架构可以创建或生成的不同生产或XML消息实例有关，这往往是无意中发生的。XSD有时不够精确，因此集成通常很混乱，需要良好的工具来使事情适应，而标准和规范的纯洁性并没有足够深入，以避免在实现中的歧义。这是我们将在本书中多次回顾的主题：为了成功，任何集成技术都必须灵活，以适应手头的特定问题，适应它，不要改变，适应，转换，并集成。映射是工具箱中的一个工具，并且对于满足这些要求非常重要。因此，它值得有一个专门的章节。
- en: The map designer
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射设计器
- en: Take a look at the following screenshot. This shows the new graphical mapping
    designer that is accessible from Visual Studio 2012\. For those familiar with
    **BizTalk Server**, don't be fooled. While it may have a similar look and feel
    to the BizTalk Server mapper, this tool has significant differences; the overriding
    design aesthetic was to make common mapping tasks as simple as possible, and as
    such, the mapper has undergone a significant overhaul.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的屏幕截图。这显示了可以从Visual Studio 2012访问的新图形映射设计器。对于那些熟悉**BizTalk Server**的人来说，不要被误导。虽然它可能看起来和感觉与BizTalk
    Server映射器相似，但这个工具有显著的不同；主导的设计美学是尽可能简化常见的映射任务，因此映射器经历了重大的改造。
- en: '![The map designer](img/7401EN_02_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![地图设计师](img/7401EN_02_01.jpg)'
- en: Graphical mapping designer
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图形映射设计器
- en: Schema
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: However, we're getting ahead of ourselves. In order to map one message format
    or structure to another, to translate its contents for example, we first need
    to understand the messages themselves. Fundamental to this is schema.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能有些过于急切了。为了将一种消息格式或结构映射到另一种，例如翻译其内容，我们首先需要理解这些消息本身。这其中的基础是架构。
- en: 'BizTalk Services differentiates between two types of messages: XML and non-XML.
    All XML message formats are expressed using XSD, and all non-XML message formats
    are expressed using XSD. So, XSD is important! The purpose of this book is not
    to provide a primer in XSD; we''ll refer to other references if you need some
    background on the technologies we mention. Instead, we''ll provide just enough
    to show how BizTalk Services uses such technologies so that the less familiar
    can still understand what is going on.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: BizTalk Services区分两种类型的消息：XML和非XML。所有XML消息格式都使用XSD表达，所有非XML消息格式都使用XSD表达。因此，XSD很重要！本书的目的不是提供XSD的入门指南；如果您需要我们提到的技术的背景信息，我们会参考其他参考资料。相反，我们将提供足够的信息，以展示BizTalk
    Services如何使用这些技术，以便那些不太熟悉的人也能理解正在发生的事情。
- en: Now, you're probably wondering how any message formats you can think up can
    be defined in XSD. Let's look at an example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道你所能想到的任何消息格式如何能在XSD中定义。让我们看看一个例子。
- en: An example
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个例子
- en: Let's expand on the example we looked at in [Chapter 1](ch01.html "Chapter 1. Hello
    BizTalk Services"), *Hello BizTalk Services*. If you recall, this example received
    a file via SFTP and routed it to a Service Bus endpoint. Now we'll add a map to
    the solution. The map will transform the incoming message into a different format
    expected by the recipient. However, as noted previously, if we're to turn one
    message format into another, we need to define the schema of the target message
    first in order for us to be able to map to it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展一下我们在[第1章](ch01.html "第1章。Hello BizTalk Services")中看到的示例，*Hello BizTalk
    Services*。如果你还记得，这个示例通过SFTP接收了一个文件并将其路由到Service Bus端点。现在我们将向解决方案中添加一个映射。这个映射将把传入的消息转换成接收者期望的另一种格式。然而，正如之前所提到的，如果我们要把一种消息格式转换为另一种格式，我们需要首先定义目标消息的架构，以便我们能够将其映射到它。
- en: To do this, right-click on the project, navigate to **Add** | **New Item**,
    select **Schema** from the list of items, and provide the name `OrderUS.xsd`.
    Click on **Add** to create the schema and add it to the solution.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请右键单击项目，导航到**添加** | **新建项**，从项目列表中选择**架构**，并给出名称`OrderUS.xsd`。点击**添加**以创建架构并将其添加到解决方案中。
- en: 'The schema designer will now be open. As you did in [Chapter 1](ch01.html "Chapter 1. Hello
    BizTalk Services"), *Hello BizTalk Services*, add nodes to the schema to build
    it up, as shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 架构设计器现在将打开。正如你在[第1章](ch01.html "第1章。Hello BizTalk Services")中看到的，*Hello BizTalk
    Services*，添加节点到架构以构建它，如下截图所示：
- en: '![An example](img/7401EN_02_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![一个示例](img/7401EN_02_02.jpg)'
- en: Changing the Order schema
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 修改订单架构
- en: Now, right-click on the project and navigate to **Add** | **New Item**. Select
    **Map** from the list of items and provide the name `FFtoUS.trfm`. Click on **Add**
    to create the map and add it to the solution.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，右键单击项目并导航到**添加** | **新建项**。从项目列表中选择**映射**，并给出名称`FFtoUS.trfm`。点击**添加**以创建映射并将其添加到解决方案中。
- en: 'The map designer will now open; the first task is to set the schemas. As a
    map''s job is to convert one format to another, a minimum of two schemas are required:
    the input and the output.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 映射设计器现在将打开；第一个任务是设置架构。由于映射的职责是将一种格式转换为另一种格式，因此至少需要两个架构：输入和输出。
- en: Click on the **Open Source Schema** link, expand the tree, select `OrderFF.xsd`,
    and click on **OK**. Now click on the **Open Destination Schema** link, select
    the `OrderUS.xsd` schema, and click on **OK**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**开源架构**链接，展开树形结构，选择`OrderFF.xsd`，然后点击**确定**。现在点击**打开目标架构**链接，选择`OrderUS.xsd`架构，然后点击**确定**。
- en: 'The designer will now look like the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 设计器现在将看起来如下截图所示：
- en: '![An example](img/7401EN_02_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![一个示例](img/7401EN_02_03.jpg)'
- en: Selecting schema with the designer
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设计器选择架构
- en: Now we need to map one format to another. We do this by connecting the nodes
    together, usually working from left to right.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将一种格式映射到另一种格式。我们通过连接节点来实现，通常是从左到右工作。
- en: Join the `OrderId` node on the left-hand side to the `OrderNumber` node on the
    right-hand side by clicking and holding the left mouse button while dragging across
    to the right-hand side and releasing the button when the pointer is over the target
    field.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击并按住鼠标左键，将左侧的`OrderId`节点拖动到右侧的`OrderNumber`节点上，并在指针位于目标字段上时释放按钮，将左侧的`OrderId`节点连接到右侧的`OrderNumber`节点。
- en: Now notice that the customer information is different in the target schema and
    the source; only the element names are different, but the structure is the same.
    The mapper provides a shortcut for mapping fields quickly to avoid having to connect
    them one by one. To do this, click and hold the left mouse button down on the
    parent `Customer` node in the left-hand side source schema and drag across to
    the target's `CustomerDetails` node. The context menu shown in the next screenshot
    will pop up. Here, we are presented with a number of options as shown in the following
    screenshot. Select **Link by Structure** and notice that all the nodes are connected
    together automatically even though their names differ. This is because this option
    connects fields in the order they appear, regardless of the node names, and is
    useful when the structure of both schemas is the same. You can use the same approach
    for mapping where the field names match too (**Link by Name**) or select **Simple
    Link** which will simply connect the top-level nodes together. This technique
    is very useful when mapping a large number of fields.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请注意，目标架构和源中的客户信息不同；只有元素名称不同，但结构相同。映射器提供了一个快速映射字段的快捷方式，以避免逐个连接它们。为此，请按住鼠标左键在左侧源架构中的父
    `Customer` 节点上，并将其拖动到目标 `CustomerDetails` 节点上。下一张截图所示的下拉菜单将弹出。在这里，我们提供了以下截图所示的一些选项。选择
    **按结构链接** 并注意，尽管它们的名称不同，但所有节点都自动连接在一起。这是因为此选项按出现的顺序连接字段，而不管节点名称如何，当两个架构的结构相同时非常有用。您可以使用相同的方法来映射字段名称匹配的情况（**按名称链接**）或选择
    **简单链接**，这将简单地连接顶级节点。当映射大量字段时，这种技术非常有用。
- en: '![An example](img/7401EN_02_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![示例](img/7401EN_02_04.jpg)'
- en: Linking options
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 链接选项
- en: Mapping operations
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射操作
- en: We can proceed like this for as many nodes as we like, connecting them individually
    or in groups. However, we often need to do more than just map one node's value
    to another. For this, we can turn to mapping operations. For those acquainted
    with BizTalk Server, you will be familiar with **functoids**; the concept is similar
    in BizTalk Services. However, despite the similarities, there are many differences
    in how they are realized. One of the primary goals of the product group is to
    simplify common tasks, such as looping, which were often difficult or time consuming
    to achieve previously. This is where we will now focus our attention.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续这样做，连接任意数量的节点，单独或成组连接。然而，我们往往需要做的不仅仅是将一个节点的值映射到另一个节点。为此，我们可以转向映射操作。对于那些熟悉
    BizTalk 服务器的人来说，您将熟悉 **functoids**；在 BizTalk 服务中，概念类似。然而，尽管有相似之处，它们在实现上存在许多差异。产品组的主要目标之一是简化常见任务，例如循环，这些任务以前往往很难或耗时。这就是我们现在将关注的重点。
- en: 'BizTalk Services provides a total of 37 mapping operations that are functionally
    grouped into categories in the toolbox. There isn''t room here to cover every
    mapping operation, so we''ll focus on some of the most useful. For a complete
    reference, check the MSDN documentation at [http://msdn.microsoft.com/en-us/library/windowsazure/hh689870.aspx](http://msdn.microsoft.com/en-us/library/windowsazure/hh689870.aspx).
    The idea is that all mapping operations are configured and connected in the same
    way; so, once you''ve learnt the operations available, it becomes a straightforward
    case of using a combination of them to get the mapping job done. The mapping operation
    categories are listed in the following table:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: BizTalk 服务提供了总共 37 个映射操作，这些操作在工具箱中按功能分组。这里没有足够的空间涵盖每个映射操作，所以我们只关注一些最有用的。要获取完整参考，请查看
    MSDN 文档，网址为 [http://msdn.microsoft.com/en-us/library/windowsazure/hh689870.aspx](http://msdn.microsoft.com/en-us/library/windowsazure/hh689870.aspx)。其理念是所有映射操作都以相同的方式进行配置和连接；因此，一旦你学会了可用的操作，使用它们的组合来完成映射任务就变得简单直接。映射操作类别如下表所示：
- en: '| **Category** | **Purpose** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **用途** |'
- en: '| --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| String operations | Manipulate node values as strings such as concatenation,
    trimming, and substring operations |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 字符串操作 | 将节点值作为字符串进行操作，例如连接、修剪和子字符串操作 |'
- en: '| Loop operations | Operations to loop round repeating nodes in source |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 循环操作 | 在源中循环重复节点的操作 |'
- en: '| Expressions | Arithmetic and logical expressions to perform calculations
    or decisions |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 执行计算或决策的算术和逻辑表达式 |'
- en: '| List operations | Processing for lists of items that can be created from
    node content in a conditional way for further processing |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 列表操作 | 对可以由节点内容以条件方式创建的项目列表进行处理 |'
- en: '| Cumulative operations | Operations to accumulate values such as sums, counts,
    and averages |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 累计操作 | 用于累计值，如总和、计数和平均值 |'
- en: '| Date and time operations | Manipulate date and time values |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 日期和时间操作 | 操作日期和时间值 |'
- en: '| Miscellaneous operations | Various operations for retrieving context properties,
    formatting numbers, and incorporating C# in your maps |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 其他操作 | 用于检索上下文属性、格式化数字以及在映射中包含C#的各种操作 |'
- en: A very common type of transformation is flattening. This is where a number of
    repeating items (usually a list) needs to be consolidated (or flattened) into
    a single value, often with some calculation applied (for example, a summation).
    BizTalk Services provides several mapping operations to achieve this in a straightforward
    way.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常常见的转换类型是展平。这是指需要将多个重复的项目（通常是一个列表）合并（或展平）成一个单一值，通常需要应用一些计算（例如，求和）。BizTalk
    Services提供了一些映射操作，以简单直接的方式实现这一点。
- en: 'Take a look at the following XML and you can see that the `<Product>` element
    repeats, that is, there can be more than one product specified. Let''s say we
    want to calculate the sum of all the product prices (`Price`) multiplied by the
    quantity (`Qty`) ordered to work out the total value of the order:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的XML，你可以看到`<Product>`元素是重复的，也就是说，可以指定多个产品。假设我们想要计算所有产品价格（`Price`）乘以订购数量（`Qty`）的总和，以计算出订单的总价值：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The final result, the total value of the order, then needs to be mapped to a
    single field in the target schema. We can use mapping operations to easily achieve
    this. The key to using mapping operations successfully is to break down the requirements
    and select the most appropriate mapping operations to achieve the goal. As my
    explanation has already hinted at, there are several parts to this problem. The
    first of these is to realize that we need to keep a running total of each of the
    `Qty * Price` field calculations—one for each `Product` element. Let's deal with
    that first.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果，即订单的总价值，需要映射到目标架构中的单个字段。我们可以使用映射操作轻松实现这一点。成功使用映射操作的关键是将需求分解，并选择最合适的映射操作来实现目标。正如我的解释已经暗示的那样，这个问题有几个部分。首先是意识到我们需要对每个`Qty
    * Price`字段计算保持累计总和——每个`Product`元素一个。让我们先处理这个问题。
- en: BizTalk Services provides a set of list-based mapping operations that allow
    the creation of a temporary list to store items and manipulate the items in the
    list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: BizTalk Services提供了一套基于列表的映射操作，允许创建一个临时列表来存储项目并操作列表中的项目。
- en: First drag a **Create List** mapping operation onto the design surface. Perhaps
    the first obvious change to a BizTalk Server developer is that mapping operations
    in BizTalk Services provide nesting. This is the key to simplifying complex tasks
    as this nesting behavior provides a natural way to group and organize the mapping
    task required.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将一个**创建列表**映射操作拖动到设计表面上。对于BizTalk Server开发者来说，第一个明显的改变可能是BizTalk Services中的映射操作提供了嵌套功能。这是简化复杂任务的关键，因为这种嵌套行为提供了一种自然的方式来分组和组织所需的映射任务。
- en: The **Create List** operation will be used to hold the temporary results from
    our calculations. We will push each product's total to the list and then calculate
    the sum of these list item values later. Double-click on **Create List** to configure
    it. In the dialog, type a **Member Name**, say `total`, and select **Number**
    from the dropdown for the **Member Type**, as shown in the following screenshot.
    This is a variable that will be used to store the value of our calculations. Click
    on **OK** to close the dialog.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建列表**操作将用于存储我们计算的临时结果。我们将把每个产品的总价值推送到列表中，然后稍后计算这些列表项值的总和。双击**创建列表**来配置它。在对话框中，输入一个**成员名称**，例如`total`，并从下拉菜单中选择**数字**作为**成员类型**，如图所示。这是一个将用于存储我们计算值的变量。点击**确定**关闭对话框。'
- en: '![Mapping operations](img/7401EN_02_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![映射操作](img/7401EN_02_05.jpg)'
- en: Configuring the Create List operation
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 配置创建列表操作
- en: The next step is to loop round all the `Product` elements. To do this, drag
    a **ForEach** mapping operation and drop it inside the **Create List** operation.
    Notice how we can place additional operations inside this operation too. This
    is where we'll put the calculation of each line item's total.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是遍历所有的`Product`元素。为此，拖动一个**For Each**映射操作并将其放入**创建列表**操作内部。注意我们还可以在这个操作中放置额外的操作。这就是我们将放置每行项目总值的计算的地方。
- en: Now wire up the `Product` node in the left-hand schema to the **ForEach** operation.
    This tells the operation to loop round each `Product` node within `Products`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将左侧架构中的`Product`节点连接到**ForEach**操作。这告诉操作在`Products`中循环每个`Product`节点。
- en: 'Drag an **Arithmetic Expression** operation across to the designer and drop
    it in the **ForEach** operation. Now wire up the `Qty` and `Price` fields to this
    operation. These will be our input parameters; the nodes from the input message
    we want to use the data from. Taking each node in turn, drag a connection onto
    the **Arithmetic Expression** operation on the canvas. Now double-click on the
    new **Arithmetic Expression** to configure it. Here we can specify a calculation
    based on the fields that are connected to the operation, in this case `Qty` and
    `Price`. Enter the expression shown in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个**算术表达式**操作拖动到设计器中，并将其放入**ForEach**操作中。现在将`Qty`和`Price`字段连接到这个操作上。这些将成为我们的输入参数；我们想要使用数据的输入消息中的节点。依次拖动每个节点，将连接拖到画布上的**算术表达式**操作上。现在双击新的**算术表达式**来配置它。在这里，我们可以指定基于连接到操作的字段进行的计算，在这种情况下是`Qty`和`Price`。输入以下截图所示的公式：
- en: '![Mapping operations](img/7401EN_02_06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![映射操作](img/7401EN_02_06.jpg)'
- en: Configuring the Arithmetic Expression operation
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**算术表达式**操作的配置'
- en: 'We now need to store this result; to do this, we''ll add it to the outer list
    operation. Drag an **Add Item to List** operation and drop it to the right of
    the **Arithmetic Expression** operation, within the **ForEach** operation. Then,
    connect the **Arithmetic Expression** operation to the **Add Item to List** operation
    by dragging a line from one to the other. Double-click on the **Add Item to List**
    operation to configure it. The dialog should be pre-populated already, so we can
    just click on **OK** to save the settings. The map should now look as shown in
    the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要存储这个结果；为此，我们将它添加到外部的列表操作中。拖动一个**向列表添加项**操作并将其放置在**算术表达式**操作的右侧，在**ForEach**操作内。然后，通过从一侧拖动一条线到另一侧来将**算术表达式**操作连接到**向列表添加项**操作。双击**向列表添加项**操作来配置它。对话框应该已经预先填充，因此我们只需点击**确定**来保存设置。映射现在应该看起来像以下截图所示：
- en: '![Mapping operations](img/7401EN_02_07.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![映射操作](img/7401EN_02_07.jpg)'
- en: Partially-completed map
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 部分完成的映射
- en: OK, the first part of the task is done; we are calculating the total value for
    each product. We now need to add these totals together to obtain the grand total
    for the order. This is very straightforward. Drag a **Select Entries** mapping
    operation and drop it to the right of the **Create List** operation. Connect the
    **Create List** operation to **Select Entries**. Double-click on **Select Entries**
    to open it, check the **Selected** checkbox next to `total`, and click on **OK**
    as shown in the following screenshot. Here, we are specifying what variables we
    want to extract from the list we've created. As we only have one in this case,
    the choice is easy.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，任务的第一部分已经完成；我们正在计算每个产品的总价值。我们现在需要将这些总和相加以获得订单的总计。这非常简单。拖动一个**选择条目**映射操作并将其放置在**创建列表**操作的右侧。将**创建列表**操作连接到**选择条目**。双击**选择条目**以打开它，勾选`total`旁边的**已选择**复选框，并按以下截图所示点击**确定**。在这里，我们指定要从我们创建的列表中提取哪些变量。在这种情况下，我们只有一个，所以选择很简单。
- en: '![Mapping operations](img/7401EN_02_08.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![映射操作](img/7401EN_02_08.jpg)'
- en: Configuration of the Select Entries operation
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择条目**操作的配置'
- en: 'Finally, drag a **Cumulative Sum** operation and drop it to the right of the
    **Select Entries** operation. Connect the **Select Entries** operation to the
    **Cumulative Sum** operation. Now connect the **Cumulative Sum** operation to
    the `TotalValue` field in the target schema. Double-click on the **Cumulative
    Sum** operation you just added and enter `item.total` in the expression textbox,
    as shown in the following screenshot. Here, we are specifying our total variable
    from the list entries passed from the **Select Entries** operation:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，拖动一个**累计求和**操作并将其放置在**选择条目**操作的右侧。将**选择条目**操作连接到**累计求和**操作。现在将**累计求和**操作连接到目标架构中的`TotalValue`字段。双击您刚刚添加的**累计求和**操作，并在表达式文本框中输入`item.total`，如以下截图所示。在这里，我们指定从**选择条目**操作传递的列表条目中的总变量：
- en: '![Mapping operations](img/7401EN_02_09.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![映射操作](img/7401EN_02_09.jpg)'
- en: Configuration of the Cumulative Sum operation
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 累计求和操作的配置
- en: 'The completed map should look the same as the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的映射应该看起来像以下截图：
- en: '![Mapping operations](img/7401EN_02_10.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Mapping operations](img/7401EN_02_10.jpg)'
- en: Map with looping and calculated node
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 带有循环和计算节点的映射
- en: We're nearly there with our map. Let's tackle the `ShippingAddress` node. Notice
    that there are more fields on the left-hand side than the right. We're therefore
    going to consolidate these by concatenating some of them. There are a few ways
    to do this; we could use the **String Concatenate** mapping operation, for example,
    that can take any number of inputs and produce a concatenated single string as
    output.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了地图的创建。让我们来处理`ShippingAddress`节点。注意，左侧的字段比右侧多。因此，我们将通过连接其中一些字段来合并它们。有几种方法可以做到这一点；例如，我们可以使用**String
    Concatenate**映射操作，它可以接受任意数量的输入并生成一个连接的单字符串输出。
- en: However, let's look at something a little more interesting. When there isn't
    an operation that meets your need, you can turn to the **CSharp Scripting** operation.
    As its name implies, this operation allows you to include C# in its configuration,
    giving you the full power of the .NET framework to be able to implement whatever
    mapping functionality you need.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们看看一些更有趣的东西。当没有满足你需求的操作时，你可以转向**CSharp Scripting**操作。正如其名称所暗示的，这个操作允许你在其配置中包含C#，这给了你.NET框架的全部力量，以便能够实现你需要的任何映射功能。
- en: Drag a **CSharp Scripting** operation to the mapping design surface and drop
    it somewhere below the **Create List** operation. Connect the `Number`, `Street`,
    `City`, `State`, and `Country` nodes to it. As you've probably realized by now,
    this is the way operations can work on specific data items, and the same is true
    for the scripting operation. By connecting these items to it, they become available
    to the scripts we write. Double-click on the **CSharp Scripting** operation to
    open its configuration.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将**CSharp Scripting**操作拖动到映射设计表面上，并将其放置在**Create List**操作下方。将`Number`、`Street`、`City`、`State`和`Country`节点连接到它。你可能已经意识到了，这是操作在特定数据项上工作的方式，对于脚本操作也是如此。通过将这些项连接到它，它们就可供我们编写的脚本使用。双击**CSharp
    Scripting**操作以打开其配置。
- en: 'In the dialog, notice that there is a **Script Text** multiline textbox. Here,
    we can define a function in C# that will take the nodes as input parameters and
    return a value. In this simple case, you can see from the next screenshot that
    I am just concatenating the input parameters with some formatting and returning
    the result back to the map. Enter the following code to do the same:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话框中，注意有一个**Script Text**多行文本框。在这里，我们可以定义一个C#函数，该函数将节点作为输入参数并返回一个值。在这个简单的例子中，你可以从下一张截图看到，我只是将输入参数与一些格式化信息连接起来，并将结果返回到地图中。输入以下代码以实现相同的功能：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the names of the input nodes to the scripting operation must match
    the argument names in the code. If the names differ, the map won't compile. Once
    we've saved this by clicking on **OK**, we can connect the operation to the target
    schema's `Address` node.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，脚本操作的输入节点名称必须与代码中的参数名称匹配。如果名称不同，地图将无法编译。一旦我们通过点击**OK**保存，我们就可以将操作连接到目标架构的`Address`节点。
- en: '![Mapping operations](img/7401EN_02_11.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Mapping operations](img/7401EN_02_11.jpg)'
- en: Using C# with mapping
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C#进行映射
- en: There are only a few fields left to map now. Simply connect `Recipient` to `FullName`
    and `PostCode` to `Zip`. The final operation we'll look at to complete this map
    is the **DateTime Reformat** operation. Drag this onto the design surface above
    the **Create List** operation. Connect the `OrderDate` node from both schemas
    to this operation, then double-click on the **DateTime Reformat** operation to
    configure it. This operation is useful when dealing with date formatting requirements
    that differ between sender and receiver. The nice thing about this operation is
    that it doesn't only support a fixed set of date and time formats, but you can
    enter your own as well. For the **Input Format** field, enter `d/M/yyyy` in the
    **Format** field. Note that this is not one of the provided options in the dropdown,
    so you'll need to enter it in the textbox, as shown in the following screenshot.
    Also, make sure that the letter `M` is capitalized, as is shown. Then, select
    **M/d/yyyy** for the **Output Format** field. This will interpret the input date
    in day/month/year format, for example, `2/9/2013`, and change to month/day/year
    format for the output, for example, `9/2/2013`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下几个字段需要映射。只需将`Recipient`连接到`FullName`，将`PostCode`连接到`Zip`。我们将要查看的最后一个操作以完成此地图是**日期时间重新格式化**操作。将其拖放到**创建列表**操作上方的布局表面。将两个模式中的`OrderDate`节点连接到该操作，然后双击**日期时间重新格式化**操作以进行配置。当处理发送者和接收者之间不同的日期格式要求时，此操作非常有用。这个操作的好处是它不仅支持一组固定的日期和时间格式，而且您还可以输入自己的格式。对于**输入格式**字段，在**格式**字段中输入`d/M/yyyy`。请注意，这并不是下拉菜单中提供的选项之一，因此您需要将其输入到文本框中，如下面的截图所示。此外，请确保字母`M`是大写的，如下所示。然后，对于**输出格式**字段，选择**M/d/yyyy**。这将把输入日期解释为日/月/年格式，例如，`2/9/2013`，并将输出转换为月/日/年格式，例如，`9/2/2013`。
- en: '![Mapping operations](img/7401EN_02_12.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![映射操作](img/7401EN_02_12.jpg)'
- en: Formatting dates
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 日期格式化
- en: 'The map is now complete. It should look similar to the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 地图现在已完成。它应该看起来与以下截图相似：
- en: '![Mapping operations](img/7401EN_02_13.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![映射操作](img/7401EN_02_13.jpg)'
- en: The completed map
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的地图
- en: Testing
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Phew! This may seem quite complex, but it's really quite simple once you break
    it down. The next step is to test the map and see if it looks like it's producing
    the right results. Testing is built right into Visual Studio, so there's no need
    to compile and deploy the solution to Windows Azure in order to see if it works.
    This is important as creating anything other than trivial maps is a very iterative
    process. It's made easier by building up the functionality in the map gradually
    and examining the test results along the way. This way, any mistakes are much
    more obvious and easily corrected.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！这看起来可能相当复杂，但一旦分解开来，实际上非常简单。下一步是测试地图，看看它是否产生了正确的结果。测试直接集成在 Visual Studio 中，因此无需编译和部署解决方案到
    Windows Azure 以查看其是否工作。这很重要，因为创建任何非平凡地图都是一个非常迭代的过程。通过逐步构建地图的功能并检查测试结果，这个过程变得更容易。这样，任何错误都更加明显且易于纠正。
- en: 'To test a map, we need some input. This is most easily generated in Visual
    Studio itself. Right-click on the `OrderFF.xsd` schema in the **Solution Explorer**
    window and select **Generate Instance**. Open the file that''s created and edit
    the values to match the one shown in the following code (don''t forget, you can
    just download the source for this example from the website):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个映射，我们需要一些输入。这最简单的方法是在 Visual Studio 本身中生成。在**解决方案资源管理器**窗口中右键单击`OrderFF.xsd`模式，并选择**生成实例**。打开创建的文件，并编辑值以匹配以下代码中显示的内容（别忘了，您可以从网站上下载此示例的源代码）：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The **Generate Instance** action creates an XML-format message by default—which
    is what you need for the map itself. However, this schema is a flat file schema,
    and if we want to generate a message to pass into the bridge, we need to generate
    a message in this format. In the schema properties, there is a property called
    **Generate Instance Output Type** that can be set to **Native** instead of **XML**.
    When **Native** is selected, the schema will create a test message according to
    its type, flat file or XML. The following screenshot shows the results of setting
    this to **Native** when compared with the `OrderFF.xsd` schema:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成实例**操作默认创建一个 XML 格式的消息——这是地图本身所需要的。然而，这个模式是一个平面文件模式，如果我们想生成一个传递给桥接器的消息，我们需要以这种格式生成消息。在模式属性中，有一个名为**生成实例输出类型**的属性，可以将其设置为**原生**而不是**XML**。当选择**原生**时，模式将根据其类型创建一个测试消息，无论是平面文件还是
    XML。以下截图显示了将此设置为**原生**与`OrderFF.xsd`模式相比的结果：'
- en: '![Testing](img/7401EN_02_14.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![测试](img/7401EN_02_14.jpg)'
- en: 'Generate Instance: Native'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 生成实例：本地
- en: Once we have a test message, we can assign it to the map to try it. Click on
    the `FFtoUS.trfm` map in the **Solution Explorer** window; in the **Properties**
    window, enter the path to the file in the **Test Map Input File** property. Now
    right-click on the map and select **Test Map**. With any luck, you should see
    something similar to the following snippet in the output window. This means that
    the map execution worked!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了测试消息，我们就可以将其分配给映射来尝试。在 **解决方案资源管理器** 窗口中单击 `FFtoUS.trfm` 映射；在 **属性** 窗口中，将文件的路径输入到
    **测试映射输入文件** 属性中。现在右键单击映射并选择 **测试映射**。如果有幸，您应该在输出窗口中看到以下片段类似的内容。这意味着映射执行成功！
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open the file from the **File** menu by navigating to **Open** | **File** and
    browsing to the to the file location in the preceding output (in this case: `C:\Users\Jon\AppData\Local\Temp\tmp3817.xml`).
    If you did everything right, it should look the same as the following XML code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 **文件** 菜单打开文件，导航到 **打开** | **文件** 并浏览到前一个输出中的文件位置（在本例中：`C:\Users\Jon\AppData\Local\Temp\tmp3817.xml`）。如果您一切都做得正确，它应该看起来与以下
    XML 代码相同：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice how different this XML document is from the one you used as input and
    you can hopefully start to appreciate the power of the BizTalk Services mapper.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个 XML 文档与您用作输入的文档有多么不同，您可能开始欣赏 BizTalk Services 映射器的强大功能。
- en: Configuring a bridge
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置桥接器
- en: A map is no good on its own though. We need to be able to use it in an integration
    solution. It should hopefully come as no surprise that the way we do this is by
    configuring a bridge. The next screenshot shows part of the bridge configuration.
    This configuration represents the pipeline of processing that can be configured.
    There are multiple stages to this pipeline, as mentioned in [Chapter 1](ch01.html
    "Chapter 1. Hello BizTalk Services"), *Hello BizTalk Services*. In the middle
    of the pipeline, there is a **Transform** stage; it is here that we can specify
    a map to execute.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个映射本身并没有什么用。我们需要能够在集成解决方案中使用它。希望这不会让人感到惊讶，我们这样做是通过配置桥接器。下一个截图显示了桥接器配置的一部分。此配置表示可以配置的处理管道。正如在
    [第 1 章](ch01.html "第 1 章。Hello BizTalk Services") 中提到的，该管道有多个阶段，*Hello BizTalk
    Services*。在管道的中间有一个 **转换** 阶段；正是在这里，我们可以指定要执行的映射。
- en: '![Configuring a bridge](img/7401EN_02_15.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![配置桥接器](img/7401EN_02_15.jpg)'
- en: Configuring a bridge with a map
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 配置带有映射的桥接器
- en: Double-click on the `MessageFlowItinerary.bcs` file in the **Solution Explorer**
    window to open it. In the designer, open the `OrderProcessing` bridge configuration
    by double-clicking on it. Click on the **Transform** stage and look at the **Properties**
    window. Here, we can choose a map by clicking on the ellipsis (**…**) next to
    the **Maps** property to open up the configured maps. This will show us all the
    maps the solution contains.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **解决方案资源管理器** 窗口中双击 `MessageFlowItinerary.bcs` 文件以打开它。在设计器中，通过双击它来打开 `OrderProcessing`
    桥接器配置。单击 **转换** 阶段并查看 **属性** 窗口。在这里，我们可以通过单击 **映射** 属性旁边的省略号（**…**）来选择映射，打开配置的映射。这将显示解决方案中包含的所有映射。
- en: We can select the map that we created earlier by checking the **Selected** checkbox
    next to it, as shown in the following screenshot. Clicking on **OK** will return
    to the bridge configuration, which should now show the selected map, `FFtoUS`,
    in the **Transform** stage.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过勾选它旁边的 **选中** 复选框来选择我们之前创建的映射，如图所示。单击 **确定** 将返回到桥接器配置，此时应该显示在 **转换**
    阶段中选中的映射，即 `FFtoUS`。
- en: '![Configuring a bridge](img/7401EN_02_16.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![配置桥接器](img/7401EN_02_16.jpg)'
- en: Select map dialog
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 选择映射对话框
- en: Putting it all together
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: The solution is now ready. Build and deploy as before, and once deployed, point
    your browser to `https://<yourdeployment>/default/OrderProcessingBridge` and you
    should see a 401 HTTP error code stating that a manage claim is required for this
    operation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案现在已准备就绪。像以前一样构建和部署，一旦部署，将浏览器指向 `https://<yourdeployment>/default/OrderProcessingBridge`，您应该看到一个
    401 HTTP 错误代码，表示此操作需要管理声明。
- en: 'Now you will use two tools provided as a part of the BizTalk Services SDK.
    These are MessageSender and MessagerReceiver which you can download from the following
    links. These tools allow you to send messages to and receive messages from the
    bridge you created:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将使用 BizTalk Services SDK 提供的两个工具。这些是 MessageSender 和 MessagerReceiver，您可以从以下链接下载它们。这些工具允许您向您创建的桥接器发送消息并从桥接器接收消息：
- en: '[http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-e01a5b64](http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-e01a5b64)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-e01a5b64](http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-e01a5b64)'
- en: '[http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-af9bc99f](http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-af9bc99f)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-af9bc99f](http://code.msdn.microsoft.com/windowsazure/Windows-Azure-BizTalk-EAI-af9bc99f)'
- en: Unzip both solutions and open the MessageReceiver sample in Visual Studio 2012
    and build it. Run it from the command prompt by typing the following and pressing
    the *Enter* key.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 解压这两个解决方案，并在Visual Studio 2012中打开MessageReceiver示例并构建它。通过在命令提示符中键入以下内容并按*Enter*键来运行它。
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding command, `<path>` is the path to the exe from the build output
    of Visual Studio, `ServiceBusNS` is the namespace where the relay is running and
    `USAddressRelay` is the endpoint information configured in the bridge configuration.
    Note that you will also need to replace the `<issuerkey>` value with your own
    subscription details.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`<path>`是从Visual Studio构建输出到exe的路径，`ServiceBusNS`是中继运行时的命名空间，`USAddressRelay`是在桥接配置中配置的端点信息。请注意，您还需要将`<issuerkey>`值替换为您自己的订阅详情。
- en: 'Now open the MessageSender sample (downloaded from the previous link) in Visual
    Studio 2012 and build it. Run it as shown in the following code to send a message
    to the bridge:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在Visual Studio 2012中打开MessageSender示例（从上一个链接下载）并构建它。按照以下代码运行以向桥接发送消息：
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, `BizTalkSvcACS` is the ACS namespace of the BizTalk Service
    deployment. As before, `owner` and `issuerkey` are the ACS credentials of that
    namespace, and `instance.xml` is the `OrderFF.xsd` instance in XML format.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`BizTalkSvcACS`是BizTalk服务部署的ACS命名空间。和之前一样，`owner`和`issuerkey`是该命名空间的ACS凭证，而`instance.xml`是XML格式的`OrderFF.xsd`实例。
- en: Ensure that output is observed in the MessageReceiver sample of the relay. Examine
    the output message and notice how the map has transformed it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在中继的MessageReceiver示例中观察到输出。检查输出消息并注意映射是如何将其转换的。
- en: More on mapping
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于映射
- en: We've covered a lot of ground so far, but there is much more to mapping in BizTalk
    Services besides the other 27 operations we've not used here. There are two other
    groups of operations that deserve some discussion.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经覆盖了很多内容，但在BizTalk服务中关于映射的内容还有很多，除了我们在这里没有使用的其他27个操作之外。还有两组其他操作值得讨论。
- en: The first of these is the **Get Context Property** mapping operation. This provides
    an often-asked-for feature in BizTalk Server—the ability to retrieve properties
    from the message context and include them in a map. The way this works is by configuring
    it, specifying the property name to retrieve it, and then connecting it to a target
    node; no input nodes are required. We haven't covered context properties in detail
    yet, but for now, remember that they are a set of name/value pairs that hold contextual
    information about the current message flow; for example, the transport details
    (for example, a filename) of the message received, or even properties of the message
    itself that have been extracted. If you're wondering how you can test this from
    within Visual Studio as we did earlier, the team has thought of this too. A property,
    **Context Property Test Data**, is provided on the map and allows you to specify
    the test name/value properties to execute the map with. The dialog is shown in
    the following screenshot. The ability to use context properties in BizTalk Services
    maps is a very welcome addition. This dialog can also be shown when the map is
    tested to change the values used.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中的第一个是**获取上下文属性**映射操作。这为BizTalk服务器提供了一个经常被询问的功能——从消息上下文中检索属性并将其包含在映射中。这种方式是通过配置它，指定要检索的属性名称，然后将其连接到目标节点来实现的；不需要输入节点。我们还没有详细讲解上下文属性，但到目前为止，请记住它们是一组包含当前消息流上下文信息的键值对；例如，接收到的消息的传输细节（例如，文件名），甚至是消息本身的属性，这些属性已经被提取。如果您想知道如何像我们之前那样在Visual
    Studio中测试它，团队也想到了这一点。在映射上提供了一个属性，**上下文属性测试数据**，允许您指定要执行的测试名称/值属性。对话框如图所示。在BizTalk服务映射中使用上下文属性的能力是一个非常受欢迎的添加。当测试映射时，也可以显示此对话框来更改使用的值。
- en: '![More on mapping](img/7401EN_02_17.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![更多关于映射](img/7401EN_02_17.jpg)'
- en: Select map dialog
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 选择映射对话框
- en: The second area of improvement is in expression operations. For example, an
    **If-Then-Else** **Expression** operation is provided. This greatly simplifies
    the common requirement of testing a condition; if it evaluates to true, one path
    is taken, otherwise another. In BizTalk Server, this was complex to achieve, requiring
    a lot of functoids. This highlights the effort that the product group has put
    in here to simplify common tasks, as I mentioned at the beginning of this chapter.
    The same goes for other logical operations such as the **Logical** **Expression**.
    Here, an expression can be provided that evaluates to true or false. Again, for
    those familiar with BizTalk Server, this operation replaces a large number of
    functoids with just one that is simple to configure and use.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个改进的领域是在表达式操作上。例如，提供了一个**If-Then-Else** **表达式**操作。这极大地简化了测试条件的常见需求；如果它评估为真，则采取一条路径，否则采取另一条路径。在BizTalk
    Server中，这很复杂，需要很多functoids。这突出了产品团队在这里为简化常见任务所付出的努力，正如我在本章开头提到的。对于其他逻辑操作，如**逻辑**
    **表达式**也是如此。在这里，可以提供一个评估为真或假的表达式。同样，对于那些熟悉BizTalk Server的人来说，这个操作用简单配置和使用的单个操作替换了大量的functoids。
- en: 'One issue that was starting to become obvious, referring to the map in the
    earlier screenshot, is complexity. The mapper provides the concept of pages to
    allow the splitting up of operations and links on different pages. You can add
    a new page by right-clicking on the area next to the tab at the bottom of the
    designer, as shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个开始变得明显的问题是复杂性，这可以通过早期截图中的地图来参考。地图绘制者提供了页面的概念，以便在不同的页面上拆分操作和链接。你可以在设计器底部标签旁边的区域右键单击来添加新页面，如下面的截图所示：
- en: '![More on mapping](img/7401EN_02_18.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![更多关于映射](img/7401EN_02_18.jpg)'
- en: Working with pages
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用页面
- en: Splitting the map up into different pages is a trade-off between readability
    and complexity. Ideally, you would see as much detail as is clearly readable in
    a single page to avoid having to jump between different pages all the time. With
    complex maps that perhaps have thousands of links and operations, this isn't possible;
    adding pages can greatly reduce complexity and improve clarity, especially for
    those left to maintain the solution.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将地图拆分成不同的页面是在可读性和复杂性之间的一种权衡。理想情况下，你会在单页面上看到尽可能多的清晰可读的细节，以避免总是需要在不同的页面之间跳转。对于可能包含数千个链接和操作的复杂地图，这是不可能的；添加页面可以大大降低复杂性并提高清晰度，特别是对于那些需要维护解决方案的人来说。
- en: One final point is that, as you may have already noticed, the new BizTalk Services
    mapper is not based on the Extensible Stylesheet Language and XSLT (as the BizTalk
    Server one was). However, it is still possible to include XSLT (1.0 only) in a
    map, which is useful when you have an existing transformation in XSLT that you
    wish to reuse. The XSLT property is accessed by clicking on the designer grid
    and opening the **XSLT** property in the **Properties** window. On the subject
    of reuse, another useful tool provided with BizTalk Services is the BizTalk Server
    map converter. This will convert a BizTalk Server `.btm` map file to the BizTalk
    Services mapping format, saving time when you have existing maps that you wish
    to reuse and avoiding the need to start from scratch. Because of the differences
    in functionality between the two, it cannot perform a 100 percent conversion,
    but is a great time-saver nevertheless.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是，正如你可能已经注意到的，新的BizTalk Services地图绘制器不是基于可扩展样式表语言和XSLT（如BizTalk Server的那个）。然而，仍然可以在地图中包含XSLT（仅限1.0），这在你有现有的需要重用的XSLT转换时很有用。通过在设计器网格上单击并打开**XSLT**属性在**属性**窗口中访问XSLT属性。关于重用的话题，BizTalk
    Services还提供了一个有用的工具，即BizTalk Server地图转换器。这会将BizTalk Server的`.btm`地图文件转换为BizTalk
    Services映射格式，当你有现有的需要重用的地图时可以节省时间，并避免从头开始的需要。由于两个之间的功能差异，它不能进行100%的转换，但仍然是一个节省时间的巨大工具。
- en: Dealing with failure
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理失败
- en: One very important point a developer must consider is how to deal with failures
    that occur. In integration solutions, failure is particularly important as it
    can be hard to isolate and diagnose. On a map, it is possible to configure what
    action to take should a particular operation fail, usually due to bad data provided
    to it. The **Settings** button at the top of the designer displays the dialog,
    as shown in the following screenshot, when clicked.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者必须考虑的一个非常重要的问题是如何处理发生的失败。在集成解决方案中，失败尤其重要，因为它可能很难隔离和诊断。在映射中，可以配置在特定操作失败时应采取什么行动，通常是由于提供给它的数据有问题。当点击设计器顶部的**设置**按钮时，会显示如下截图所示的对话框。
- en: Here, each operation (or group of operations in some cases) can be set to either
    **Fail Map** on an error occurrence or continue and output a null value. This
    is very useful; we'll look at error handling in much more detail in a later chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个操作（或在某些情况下是一组操作）都可以设置为在错误发生时**失败映射**，或者继续并输出一个空值。这非常有用；我们将在稍后的章节中更详细地探讨错误处理。
- en: '![Dealing with failure](img/7401EN_02_19.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![处理失败](img/7401EN_02_19.jpg)'
- en: Setting runtime properties
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 设置运行时属性
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at the mapping features of BizTalk Services.
    You've seen how to create maps, use many of the powerful operations provided,
    and test them. While we haven't been able to cover every operation, many are self-explanatory
    and easy to understand; after all, the whole point of the mapper is to make the
    job of format and content conversion easier. We urge you to experiment on your
    own and see what you can come up with.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 BizTalk 服务的映射功能。您已经看到了如何创建映射，使用许多提供的强大操作，以及如何测试它们。虽然我们没有能够涵盖每个操作，但许多都是自我解释的，易于理解；毕竟，映射器的整个目的就是使格式和内容转换的工作更加容易。我们敦促您自己进行实验，看看您能想出什么。
- en: In the next chapter, we'll look at the different types of bridges BizTalk Services
    provides, starting with EDI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 BizTalk 服务提供的不同类型的桥接，从 EDI 开始。
