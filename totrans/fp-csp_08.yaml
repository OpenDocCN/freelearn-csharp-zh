- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion and Tail Calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at the concept of recursion, which is particularly
    powerful for tackling problems with inherent hierarchical or repetitive structures,
    such as directory traversal, parsing nested data formats, or implementing algorithms
    on tree-like data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we delve into recursion, we’ll explore its two main components: the base
    case and the recursive case. The base case acts as a stop signal for recursion,
    preventing infinite loops, while the recursive case is where the function makes
    progress toward the base case. In addition to these cases, we will discuss the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Types of recursion: simple and tail recursions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Challenges of recursion: stack overflow risk and performance considerations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C# features for recursion: local functions and pattern matching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advanced recursive patterns: mutual recursion and memoization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comparison with iterative solutions: readability and performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recursion in asynchronous programming: async recursion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, we start with a self-evaluation to measure your current understanding
    of recursion. The following tasks are designed to test your grasp of the concepts
    we’ll be covering. If you find these tasks challenging, this chapter will be a
    very valuable resource for you. On the other hand, if you solve these tasks with
    ease, you may still discover new insights and applications of recursion or just
    move on to the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 – Recursive enemy count
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Steve’s game has a hierarchical structure of enemy waves, where each wave can
    contain both individual enemies and sub-waves. Implement a recursive function,
    `CountAllEnemies`, that navigates through a `Wave` object (which can contain both
    `Enemy` objects and `Wave` objects) and returns the total count of enemies found
    within that wave, including all its sub-waves (flying, armored, quick, etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Test your method with a `Wave` containing a mix of `Enemy` objects and `Wave`
    objects to ensure that it accurately counts all enemies, including those in nested
    sub-waves.
  prefs: []
  type: TYPE_NORMAL
- en: Task 2 – Wave generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the same wave structure from Task 1, Steve wants to generate increasingly
    complex waves as the game progresses. Implement a recursive function, `GenerateWave`,
    that creates a `Wave` object with a nested structure of enemies and sub-waves
    based on the current level number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This function should create more complex wave structures as the level number
    increases. Consider the following guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: For every 5 levels, add a sub-wave.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of enemies in each wave or sub-wave should increase with the level
    number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce more varied enemy types as the levels progress.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every 10th level should include a boss enemy.
  prefs: []
  type: TYPE_NORMAL
- en: Test your method with different level numbers to ensure it generates appropriate
    wave structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Task 3 – Asynchronously updating enemy stats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Updating the stats of enemies (such as health, speed, or damage) might need
    to be done asynchronously, especially if it involves fetching or syncing information
    from a game server. Implement an `UpdateAllEnemyStatsAsync` method that recursively
    goes through a hierarchy of waves (containing both enemies and sub-waves) and
    updates stats for each enemy asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of this exercise, simulate the asynchronous update operation with
    the `UpdateStatsAsync(Enemy enemy)` method, which returns `Task`. Your recursive
    function should await the completion of stat updates for each enemy before moving
    to the next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you tackle these tasks, pay attention to how you break down each problem
    into smaller pieces and how you identify the base case and recursive case for
    each scenario. This initial self-evaluation will not only prepare you for the
    concepts ahead but also provide a practical context for their application. Now,
    let’s dive in and explore recursion in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Steve continued developing his tower defense game, he found himself struggling
    with complex nested structures for enemy waves. He called Julia, hoping she might
    have some insights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *It sounds like you’re dealing with hierarchical data structures. Have
    you considered* *using recursion?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Recursion? Isn’t that when a function calls itself? It always seemed
    a bit confusing* *to me.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *That’s right, but it’s a powerful tool for handling nested structures.
    Let’s explore how it could help with* *your game.*'
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is a programming technique where a function calls itself to solve
    a problem. It’s like breaking down a task into smaller tasks of the same type.
    This approach is very useful for tasks that have a repetitive structure, such
    as navigating through folders and files, working with data structures such as
    trees, or doing calculations that follow a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In recursion, there are two main parts: the base case and the recursive case.
    The base case stops the recursion from going on forever. It’s where the function
    doesn’t call itself again. The recursive case is where the function does call
    itself but with a simpler version of the original problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s apply recursion to a practical example. Imagine we need to count the total
    number of views for a series of videos organized in a nested playlist, where a
    playlist can contain both videos and other playlists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we might write a recursive function to solve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `CountViews` is a recursive function that can handle both videos
    and playlists. If it encounters a video, it returns the number of views (the base
    case). If it encounters a playlist, it goes through each item in the playlist
    and calls itself to count the views, adding up all the views for a total (the
    recursive case).
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is powerful for problems like this because it simplifies the code
    and makes it more readable, especially when dealing with nested or hierarchical
    data. However, it’s important to always have a clear base case to prevent the
    function from calling itself indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive thinking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When managing a complex hierarchy of videos, such as sorting them into categories
    and subcategories, thinking recursively can simplify the process. Recursive thinking
    means breaking down a big problem into smaller versions of the same problem until
    it becomes easy to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take organizing a tree of video categories and subcategories as our example.
    The goal is to go through each category, visit all its subcategories, and organize
    the videos in each. This task sounds complex, but recursion makes it easier by
    handling one category (and its subcategories) at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you might write a recursive function to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `OrganizeVideos` is a recursive function. It looks at a category,
    and for each subcategory, it calls itself, diving deeper into the hierarchy. This
    is the recursive case. After it has visited all subcategories, it then organizes
    the videos in the current category. That’s where you’d put your sorting or organizing
    logic, but for now, we’re keeping it simple with a `print` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of recursive thinking is how it simplifies managing a complex hierarchy.
    You deal with organizing videos at just one level at a time, and recursion takes
    care of diving into the depths of the hierarchy for you. Just like in the previous
    example, having a clear base case (in this case, reaching a category with no subcategories)
    ensures that the recursion doesn’t go on indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at an example demonstrating the power of recursive thinking
    in parsing nested JSON data. Consider a scenario where we need to process a JSON
    string representing a book publishing system’s catalog and convert it into a corresponding
    object hierarchy. This example will showcase how recursion can simplify the task
    of navigating and constructing complex data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume we have the following JSON string representing a book catalog with nested
    genres and sub-genres:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To parse this JSON string and create a corresponding object hierarchy, we define
    the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s implement the recursive functions to parse the JSON string and construct
    the object hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `ParseCatalog` function serves as the entry point, recursively calling `ParseGenre`
    for each genre in the catalog. `ParseGenre`, in turn, recursively calls itself
    for each subgenre and invokes `ParseBook` for each book within the genre or subgenre.
  prefs: []
  type: TYPE_NORMAL
- en: With recursion, we can effectively navigate the nested structure of the JSON
    string, handling the parsing of sub-elements (genres, subgenres, and books) within
    the context of their parent elements (catalog and genres). This approach results
    in cleaner and more maintainable code compared to an iterative solution, which
    would require explicit management of multiple levels of nesting and conditional
    checks for the presence of subgenres and books.
  prefs: []
  type: TYPE_NORMAL
- en: Types of recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recursion can be classified into two main types based on how the recursive
    call is made and its position within the function: simple recursion and tail recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simple recursion occurs when a function calls itself directly. This type is
    the most common and easiest to understand. Let’s use it to count the total number
    of videos in a hierarchy of video categories and subcategories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `CountTotalVideos` counts all videos in the given category, including
    those in its subcategories. It starts by counting videos in the current category.
    Then, it goes through each subcategory, calls itself for each one, and adds their
    video counts to the total.
  prefs: []
  type: TYPE_NORMAL
- en: Tail recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tail recursion is a special case of recursion where the recursive call is the
    last operation in the function. It’s important because many compilers optimize
    it to avoid increasing the call stack, which makes the function more efficient
    and prevents stack overflow errors.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example where we flatten the video category tree into a single
    list of videos. This task can benefit from tail recursion optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a slight modification in our approach to allow tail recursion.
    Instead of returning the result directly, we pass along an accumulator—a container
    that collects the result as we go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this function, you’d start with an empty list and pass it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function is tail-recursive because the last action it takes is the recursive
    call (or adding to the accumulator, which doesn’t change the nature of the recursion).
    However, it’s worth noting that not all programming languages or compilers automatically
    optimize tail recursion. In .NET, for example, tail call optimization is at the
    discretion of the CLR, and it might not always apply it. Still, writing tail-recursive
    functions can be a good practice for efficiency and clarity, especially in languages
    and environments that support optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges of recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using recursion in programming, two main challenges often arise: the risk
    of stack overflow and the considerations for performance. Let’s dive into these
    challenges with our characters.'
  prefs: []
  type: TYPE_NORMAL
- en: As Steve began implementing recursive functions in his game, he ran into some
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Julia, I’m getting stack overflow errors when I have too many nested
    waves. What’s* *going on?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Ah, you’ve discovered one of the challenges of recursion. Let’s talk
    about stack overflow risk and how to* *mitigate it.*'
  prefs: []
  type: TYPE_NORMAL
- en: Stack overflow risk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A stack overflow occurs when there’s too much information to store in the call
    stack—the part of memory that tracks where each function is in its execution.
    This can happen if a recursive function calls itself too many times without reaching
    a base case.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when counting the total number of videos in all categories and
    subcategories, if the hierarchy is very deep or there’s a circular reference (a
    category somehow includes itself), the `CountVideos` function could keep calling
    itself indefinitely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If the category structure is very deep, this could lead to thousands of nested
    calls, each one adding a frame to the call stack, potentially causing a stack
    overflow error.
  prefs: []
  type: TYPE_NORMAL
- en: Default stack size and limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using recursion, it’s crucial to be aware of the limitations imposed by
    the default stack size. The stack is a region of memory used to store method calls,
    local variables, and other information. Each recursive call adds a new frame to
    the stack, consuming a portion of the available stack space. If the recursion
    depth becomes too large, it can exhaust the stack, leading to a stack overflow
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET, the default stack size varies depending on the architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '32-bit: 1 MB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '64-bit: 4 MB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to note that these default sizes are subject to change and may
    vary based on the specific runtime environment and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the impact of stack size on recursion, let’s use the example of
    the preceding `CountVideos` function. If the category hierarchy is very deep,
    the recursive calls to `CountVideos` can quickly consume the available stack space.
    For example, with a stack size of 1 MB and assuming an average stack frame size
    of 32 bytes (for simplicity), the maximum recursion depth would be approximately
    32,000 (1 MB / 32 bytes). Exceeding this depth would result in a stack overflow
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mitigate the risk of stack overflow, you can employ several techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tail call optimization** (**TCO**): If your recursive function is tail-recursive,
    the compiler may optimize it to avoid adding new frames to the stack. However,
    TCO is not guaranteed in .NET and depends on the runtime’s discretion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterative alternatives**: Convert the recursive algorithm to an iterative
    one using loops and data structures such as stacks or queues. Iterative solutions
    generally have a smaller stack footprint compared to recursive ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Threading.Thread.MaxStackSize` property or by configuring the runtime
    environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limit recursion depth**: Implement a maximum depth limit in your recursive
    function to prevent excessive recursion. This can be done by passing a depth counter
    as a parameter and checking against a predefined limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of limiting the recursion depth in the `CountVideos` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this modified version, the `CountVideos` function takes additional parameters:
    `depth` to track the current recursion depth, and `maxDepth` to specify the maximum
    allowed depth. If `depth` exceeds `maxDepth`, a `StackOverflowException` is thrown
    to prevent further recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: Performance considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recursion can sometimes be less efficient than iterative solutions, especially
    in languages and environments that don’t optimize recursive calls. The main reasons
    are the overhead of multiple function calls and, in non-tail-recursive cases,
    the additional memory required to maintain the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: Again, in the best case scenario, a smart compiler could optimize this to avoid
    a stack overflow and make it run as efficiently as a loop. However, not all environments
    support this optimization, and without it, tail recursion offers no performance
    benefit over simple recursion.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate the risk of stack overflow with deep recursion, you can sometimes
    refactor recursive functions to use an iterative approach or ensure your recursion
    has a guaranteed termination condition. For performance, it’s often about weighing
    the readability and elegance of recursion against the efficiency of iteration.
    In some cases, using iterative algorithms can be a more practical choice, especially
    for very large datasets or when working in environments that don’t optimize tail
    recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging C# features for recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# offers several features that can make writing recursive functions easier
    and your code cleaner. Two of these features are local functions and pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Local functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Local functions allow you to define functions inside the body of another function.
    This can be particularly useful for recursion when you want to encapsulate all
    the logic within a single method, keeping the recursive part separate for clarity
    and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example showing how to use a local function for recursively processing
    video categories and counting videos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `CountVideos` is a local function defined within `ProcessAndCount`
    **VideosInCategory**. It’s used to traverse the hierarchy of video categories,
    counting videos in all subcategories. The total count is kept in the `videoCount`
    variable, which is accessible to the local function thanks to C#’s closure capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern matching makes it easier to work with complex data by letting you check
    types and conditions more simply. It’s particularly useful in recursive functions
    where you need to handle different types or scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how pattern matching can streamline our function for processing video
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, pattern matching is used to check whether the `category` has
    subcategories. If it does, the function recursively processes each subcategory.
    This approach makes the code more readable and eliminates the need for multiple
    `if` statements or type checks.
  prefs: []
  type: TYPE_NORMAL
- en: Both local functions and pattern matching are powerful tools, especially when
    dealing with recursion. They not only make your recursive logic more understandable
    but also keep your code organized and concise.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced recursive patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In more complex scenarios, recursion can be taken a step further with techniques
    such as mutual recursion and memoization. These advanced patterns can optimize
    performance and manage tasks that require alternating between different operations.
  prefs: []
  type: TYPE_NORMAL
- en: Mutual recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mutual recursion occurs when two or more functions call each other in a cycle.
    This pattern can be particularly useful when you have a problem that requires
    switching between different types of tasks. Imagine a scenario where one function
    organizes video metadata and another validates it. Each function calls the other
    as part of its process.
  prefs: []
  type: TYPE_NORMAL
- en: In a book creation process, books often undergo a meticulous cycle of editing
    and review before being deemed ready for publication. This process, inherently
    iterative and dependent on passing various checks at each stage, lends itself
    well to a mutual recursion model. Here, we explore a scenario where a book’s manuscript
    is edited for both content and format, each process potentially unveiling the
    need for further alterations in the other.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a system where after a manuscript is initially edited for content (such
    as narrative structure, character development, etc.); it must then be formatted
    to meet publishing standards (including font consistency, margin settings, and
    header/footer content). However, the formatting process might introduce or reveal
    content issues that need re-editing, illustrating a dynamic interdependence between
    these stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a conceptual implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `PublishingWorkflow` class contains two mutually recursive
    functions: `EditContent` and `EditFormat`. `EditContent` handles narrative and
    textual corrections, while `EditFormat` ensures that the manuscript adheres to
    the publisher’s formatting standards. The discovery of issues in one stage can
    lead back to the other, mirroring the real-world intricacies of preparing a manuscript
    for publication.'
  prefs: []
  type: TYPE_NORMAL
- en: This mutual recursion effectively captures the cyclic nature of book editing
    and formatting, ensuring that neither content quality nor presentation standards
    are compromised. It highlights the iterative process of refinement that manuscripts
    undergo, embodying the collaborative effort between content editors and formatting
    specialists to achieve a publication-ready book. Through this model, the publishing
    workflow is optimized for thoroughness and quality, ensuring that readers receive
    well-crafted and professionally presented books.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memoization is a technique to speed up recursive functions by caching the results
    of expensive function calls and reusing those results when the same inputs occur
    again. This can significantly reduce the computation time for functions that are
    called repeatedly with the same arguments, such as calculating viewership statistics
    for categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore how memoization can be applied to optimize a recursive function
    for calculating Fibonacci numbers—a common scenario that illustrates the power
    of memoization in recursive algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, the `FibonacciCalculator` class uses a dictionary to
    cache the results of Fibonacci calculations. When the `Calculate` method is called,
    before doing the calculations, it checks whether the result for the given `n`
    is already cached. If so, it returns the cached result immediately, avoiding further
    recursive calls. If not, it proceeds with the recursive calculation and then caches
    the result before returning it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This memoized approach to calculating Fibonacci numbers is vastly more efficient
    than a simple recursive solution without memoization. Without caching, the time
    complexity of calculating the *n*th Fibonacci number recursively is exponential
    (specifically, `O(2^n)`) due to the repeated computation of the same values. In
    other words, each call to `Calculate(n)` results in two additional calls: `Calculate(n-1)`
    and `Calculate(n-2`), each of which branches out similarly. The only exceptions
    are the base cases where `n = 0` or `n = 1`. With memoization, the complexity
    is reduced to linear (`O(n)`), as each unique Fibonacci number up to `n` is calculated
    exactly once.'
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the impact of memoization on the efficiency of recursive function
    calls, let’s analyze the specific case of calculating Fibonacci numbers for `n
    = 13`, `n = 29`, and `n = 79`, comparing the number of function calls required
    with and without memoization.
  prefs: []
  type: TYPE_NORMAL
- en: For `n = 13`, the total number of function calls would be `F(13)` + `F(12)`
    + `F(11)` + `...` + `F(1)` + `F(0)`, which adheres to the Fibonacci sequence itself,
    leading us to 753 function calls. However, if we use memoization, the number of
    function calls will be only 25.
  prefs: []
  type: TYPE_NORMAL
- en: For `n = 29`, we must call our function 1,664,079 times. On the other hand,
    the memoized approach will require only 57 calls.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, for `n = 79`, the number of function calls grows astronomically, making
    it impractical to calculate the exact number here. It’s in the order of trillions.
    For the memoization solution, 157 calls will be enough.
  prefs: []
  type: TYPE_NORMAL
- en: This analysis demonstrates the power of memoization to enhance performance and
    its critical role in making recursive solutions viable for complex problems. By
    leveraging memoization, developers can use recursion without incurring extra computational
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, mutual recursion and memoization are powerful techniques that can
    make your recursive solutions more efficient and capable. Mutual recursion allows
    for an elegant alternation between related tasks, while memoization optimizes
    performance by avoiding redundant calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison with iterative solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When managing video playlists or similar hierarchical data structures, both
    recursive and iterative approaches have their place. The choice between them often
    depends on readability and performance considerations. Let’s explore how these
    two approaches compare in the context of a video management system.
  prefs: []
  type: TYPE_NORMAL
- en: Readability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recursion naturally fits scenarios where the problem can be divided into smaller,
    similar problems. For instance, traversing a tree of video playlists and sub-playlists
    is intuitively understood with recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This recursive function is clear and mirrors the hierarchical nature of playlists.
    It’s easy to read and understand, especially for those familiar with recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterative solutions, using loops and data structures such as stacks or queues,
    can manage the same tasks but often require more setup. An iterative version of
    the playlist traversal might not be as intuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While effective, the iterative solution is more verbose and its logic is less
    direct compared to the recursive approach. Using a stack to mimic the call stack
    of recursion also adds complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The performance characteristics of recursive and iterative approaches can vary
    depending on the specific problem and implementation. Let’s examine the benchmark
    results for the video playlist that contains 10 levels of sub-playlists with 10
    of them on each level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21069_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These results provide interesting insights:'
  prefs: []
  type: TYPE_NORMAL
- en: The recursive method is approximately 14% faster, with a mean execution time
    of 299.2 ms compared to 348.9 ms for the iterative method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recursive approach shows slightly less variation in performance, with smaller
    error and standard deviation values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contrary to common assumptions, the recursive method allocates less memory (876
    bytes) compared to the iterative method (2840 bytes), which is more than three
    times as much.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These findings challenge the conventional wisdom that iterative solutions are
    always more efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed**: The recursive approach outperforms the iterative one, possibly due
    to the compiler’s optimizations or the specific nature of the traversal task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory usage**: Surprisingly, the recursive method uses significantly less
    memory. This could be due to efficient tail-call optimization or other compiler
    optimizations for recursive calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: The recursive method shows slightly more consistent performance
    across runs, as indicated by the lower standard deviation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s important to note that these results are specific to this particular implementation
    and dataset. Factors that could influence the outcomes include:'
  prefs: []
  type: TYPE_NORMAL
- en: The depth and breadth of the playlist structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specific operations performed during traversal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler’s optimization capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The runtime environment
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, while traditional wisdom often favors iterative approaches for
    performance reasons, our benchmark demonstrates that recursive methods can be
    more efficient for certain hierarchical structures. This underscores the importance
    of empirical testing rather than relying solely on general principles. When choosing
    between recursion and iteration, consider not only code readability and problem
    structure but also conduct performance tests tailored to your specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion in asynchronous programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming has become a cornerstone for developing responsive
    applications, especially when dealing with I/O-bound operations, such as network
    requests. When you combine recursion with asynchronous programming, you can handle
    complex tasks such as fetching and processing data from external APIs or managing
    video content across a network efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Async recursion allows you to perform recursive operations without blocking
    the main thread, ensuring that your application remains responsive. For example,
    when fetching video data from an external API where videos are organized into
    categories that may contain subcategories, you can process each category and its
    subcategories recursively without freezing the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you might write an asynchronous recursive function to process videos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `ProcessVideosAsync` processes each subcategory by making recursive
    calls to itself, ensuring that all levels of the category hierarchy are covered.
    It then asynchronously processes each video in the current category. The use of
    `await` ensures that each operation is complete before moving to the next, maintaining
    the order of operations without blocking.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining asynchronous recursion under the hood
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand how asynchronous recursion works under the hood, let’s dive into
    the asynchronous programming model in .NET and explore the use of state machines
    and the interaction with `ThreadPool`.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, asynchronous methods are implemented using state machines. When an
    asynchronous method is called, the compiler generates a state machine that keeps
    track of the method’s execution state. Each `await` expression in the method marks
    a point where the method can be suspended, allowing other work to be performed
    while the awaited operation completes.
  prefs: []
  type: TYPE_NORMAL
- en: When an asynchronous recursive call is made, the state machine is created for
    each recursive invocation. The state machines are managed by the .NET runtime,
    which coordinates their execution and resumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simplified representation of how the `ProcessVideosAsync` method’s
    state machine might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this state machine representation, the `MoveNext` method encapsulates the
    logic of the asynchronous recursive function. It uses a `switch` statement to
    handle different states of the asynchronous operation. The `await` expressions
    are translated into asynchronous continuations using `TaskAwaiter` and `OnCompleted`
    callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: When an asynchronous recursive call is awaited, the state machine is suspended,
    and the control is returned to the caller. The .NET runtime then schedules the
    continuation of the state machine on a `ThreadPool` thread when the awaited operation
    completes.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that asynchronous recursive calls interact with `ThreadPool`
    differently compared to synchronous recursive calls. Instead of consuming stack
    space, asynchronous recursive calls are managed by the `ThreadPool`, which has
    a limited number of threads. If the number of asynchronous recursive calls exceeds
    the available `ThreadPool` threads, the `ThreadPool` may create additional threads
    or queue the work items until threads become available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid overloading the `ThreadPool` and ensure efficient resource utilization,
    consider the following best practices when using asynchronous recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limit recursion depth**: Similar to synchronous recursion, it’s crucial to
    have a base case that terminates the recursion to prevent excessive recursive
    calls. Implement a maximum depth limit or use other conditions to control the
    recursion depth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SemaphoreSlim` or TPL Dataflow to avoid overwhelming the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CancellationToken`. This allows you to gracefully cancel the recursive operation
    if needed, preventing unnecessary work and resource consumption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`try`-`catch` blocks to handle exceptions and consider using libraries such
    as Polly for retry and circuit-breaker policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By understanding how asynchronous recursion works under the hood and following
    best practices, you can effectively leverage the power of asynchronous programming
    in combination with recursion to build responsive and efficient applications.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous recursion is a powerful technique that allows you to perform recursive
    operations without blocking the main thread, enabling your application to remain
    responsive even when dealing with complex hierarchical data structures or remote
    API calls. By combining the benefits of asynchronous programming with the elegance
    of recursion, you can write more efficient and maintainable code for a wide range
    of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous versus asynchronous recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to implementing recursive algorithms, we have the choice between
    using synchronous or asynchronous approaches. Each approach has its own characteristics,
    benefits, and trade-offs. Let’s compare synchronous and asynchronous recursive
    code using an example of traversing a filesystem hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a synchronous recursive example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `TraverseDirectory` function takes a directory path as
    input and recursively traverses its subdirectories. For each file encountered,
    it calls the `ProcessFile` function to perform some operation on the file. The
    function blocks until all files and subdirectories have been processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s consider an asynchronous version of the same example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the asynchronous version, the `TraverseDirectoryAsync` function uses the
    `async` and `await` keywords to enable asynchronous execution. It uses `Task.Run`
    to execute the filesystem operations (`Directory.GetFiles` and `Directory.GetDirectories`)
    on a separate thread, allowing the calling thread to continue execution without
    blocking.
  prefs: []
  type: TYPE_NORMAL
- en: The `ProcessFileAsync` function is assumed to perform some asynchronous operation
    on each file, such as reading its contents or making an API call. The `await`
    keyword is used to wait for the completion of each asynchronous operation without
    blocking the calling thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now look at a comparison and the benefits of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsiveness**: The main advantage of asynchronous recursion is that it
    allows the calling thread to remain responsive while the recursive operations
    are being performed. In the synchronous example, the thread is blocked until all
    files and subdirectories have been processed, which can lead to a frozen UI or
    unresponsive application. Asynchronous recursion, on the other hand, allows the
    thread to continue executing other tasks while waiting for the asynchronous operations
    to complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Asynchronous recursion can improve performance by allowing
    multiple operations to be executed concurrently. In the asynchronous example,
    the filesystem operations and file processing can happen in parallel, potentially
    reducing the overall execution time. However, the actual performance gains depend
    on the nature of the operations being performed and the available system resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource utilization**: Asynchronous recursion can help optimize resource
    utilization by allowing the system to process other tasks while waiting for I/O-bound
    operations to complete. In the synchronous example, the thread is blocked and
    cannot be used for other purposes until the recursive operation finishes. Asynchronous
    recursion enables better utilization of system resources by allowing the thread
    to be freed up for other tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`async`, `await`, and `Task` adds an extra layer of abstraction and requires
    an understanding of asynchronous programming concepts. Error handling and exception
    propagation also become more involved in asynchronous code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scenarios for asynchronous recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Asynchronous recursion is particularly beneficial in scenarios where the recursive
    operations involve I/O-bound tasks or long-running CPU-bound operations. Some
    examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filesystem operations**: Traversing a large filesystem hierarchy and performing
    I/O operations on files, such as reading or writing data, can benefit from asynchronous
    recursion. It allows the application to remain responsive while the file operations
    are being performed asynchronously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network operations**: Recursive algorithms that involve making network requests
    or API calls can leverage asynchronous recursion to prevent blocking the calling
    thread. Asynchronous recursion enables concurrent execution of network operations,
    improving overall performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database operations**: Recursive queries or operations that involve interacting
    with a database can be implemented using asynchronous recursion. It allows the
    application to continue executing other tasks while waiting for the database operations
    to complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex calculations**: Recursive algorithms that perform complex calculations
    or computations can benefit from asynchronous recursion, especially if the calculations
    can be parallelized. Asynchronous recursion can help distribute the workload across
    multiple threads or tasks, potentially improving the overall execution time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to note that not all recursive algorithms are suitable for asynchronous
    execution. Asynchronous recursion is most effective when the recursive operations
    involve I/O-bound tasks or can be parallelized efficiently. In cases where the
    recursive operations are primarily CPU-bound and cannot be parallelized, synchronous
    recursion may be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the differences between synchronous and asynchronous recursion
    can help you write more performance code.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help Steve apply recursion concepts to his tower defense game, Julia prepared
    three coding challenges. Let’s see if you can help Steve solve them!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Steve’s game has a hierarchical structure of enemy waves, where each wave can
    contain both individual enemies and sub-waves. Implement a recursive function,
    `CountAllEnemies`, that navigates through a `Wave` object (which can contain both
    `Enemy` objects and `Wave` objects) and returns the total count of enemies found
    within that wave, including all its sub-waves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Test your method with a `Wave` containing a mix of `Enemy` objects and `Wave`
    objects to ensure that it accurately counts all enemies, including those in nested
    sub-waves.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the same wave structure from Task 1, Steve wants to generate increasingly
    complex waves as the game progresses. Implement a recursive function, `GenerateWave`,
    that creates a `Wave` object with a nested structure of enemies and sub-waves
    based on the current level number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This function should create more complex wave structures as the level number
    increases. Consider the following guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: For every 5 levels, add a sub-wave.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of enemies in each wave or sub-wave should increase with the level
    number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce more varied enemy types as the levels progress.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every 10th level should include a boss enemy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your method with different level numbers to ensure it generates appropriate
    wave structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Updating the stats of enemies (such as health, speed, or damage) might need
    to be done asynchronously, especially if it involves fetching or syncing information
    from a game server. Implement an `UpdateAllEnemyStatsAsync` method that recursively
    goes through a hierarchy of waves (containing both enemies and sub-waves) and
    updates stats for each enemy asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of this exercise, simulate the asynchronous update operation with
    the `UpdateStatsAsync(Enemy enemy)` method, which returns `Task`. Your recursive
    function should await the completion of stat updates for each enemy before moving
    to the next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By tackling these tasks, you’ll enhance your ability to think recursively, manage
    complex data structures, and leverage asynchronous programming techniques effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let’s delve into the solutions for these exercises. As always, these solutions
    represent one of the ways in which the problem can be solved. They are provided
    just to help you verify your work and to offer insights into different ways of
    approaching recursive problems.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This solution demonstrates a basic application of recursion to navigate through
    nested wave structures. It incrementally counts enemies and dives deeper into
    sub-waves when encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To use and test this function, Steve could implement a helper method to print
    the wave structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This solution demonstrates how recursion can be used to generate complex game
    structures. As the level number increases, the waves become more challenging with
    more enemies, different types of enemies, and nested sub-waves. The recursive
    nature of the function allows for easy scalability and the creation of intricate
    wave patterns as the game progresses.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This `async` recursive solution iterates through each content item of a wave,
    updating stats for enemies directly and diving deeper into sub-waves with recursive
    calls. The use of `await` ensures that updates are processed sequentially within
    each wave and sub-wave, maintaining order and ensuring completeness before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: By completing these exercises, you’ve practiced applying recursion to solve
    different problems. Whether counting items in nested structures, determining the
    depth of hierarchies, or performing batch operations asynchronously, recursion
    is a powerful tool in your software development toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter on recursion, we’ve explored how it allows us to solve
    complex problems cleanly and elegantly. By breaking down tasks into smaller, manageable
    parts, recursion provides a direct approach to tackling problems that are naturally
    hierarchical or repetitive, such as organizing books into genres and sub-genres
    or processing book metadata.
  prefs: []
  type: TYPE_NORMAL
- en: We started by understanding the essence of recursion, distinguishing between
    the base case and the recursive case, and highlighting the importance of always
    having a clear base case to prevent infinite loops. Then, through practical examples,
    we demonstrated how recursion simplifies code and enhances readability, especially
    when dealing with nested or hierarchical data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging C# features such as local functions and pattern matching, we explored
    how the language’s capabilities can enhance our recursive functions, making them
    more readable and maintainable. Advanced recursive patterns such as mutual recursion
    and memoization were also introduced, showing how recursion can be extended to
    handle more complex scenarios efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, this chapter aimed to equip you with a deeper understanding of
    recursion, its principles, and its practical applications in real-world scenarios
    such as those encountered in a book publishing system. As you move forward, you
    will learn about currying and partial application and their application in real-world
    scenarios.
  prefs: []
  type: TYPE_NORMAL
