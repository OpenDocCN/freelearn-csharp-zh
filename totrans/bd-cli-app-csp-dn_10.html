<html><head></head><body>
		<div><h1 id="_idParaDest-152" class="chapter-number"><a id="_idTextAnchor155"/>10</h1>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor156"/>Testing CLI Applications</h1>
			<p>Testing is an important phase of any software development project. The purpose of testing<a id="_idIndexMarker302"/> is to ensure that the application we put into the hands of our users behaves as expected and doesnâ€™t cause any harm to users (by leaking their personal information or by allowing malicious actors to take advantage of a security issue to harm users).</p>
			<p>In this chapter, we will discuss why testing is so important and explore different testing techniques and tools that will help us achieve this goal. More specifically, we will discuss the following:</p>
			<ul>
				<li>Why testing is important</li>
				<li>Different types of tests</li>
				<li>What to test, how to do it, and when to run these tests</li>
				<li>How to mock external dependencies when writing unit tests</li>
			</ul>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor157"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this book, <a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter10">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter10</a>.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor158"/>Why is testing so important?</h1>
			<p>Over the years, testing<a id="_idIndexMarker303"/> has proven to be very valuable when it comes to providing great software and digital experiences to users. Any developer, team, or organization that is serious about their software development project and truly cares about their users and the experience they have when using their applications will invest in software testing.</p>
			<p>Testing<a id="_idIndexMarker304"/> allows us to ensure that the applications we put into the hands of our users are of great quality, reliable, performant, and secure.</p>
			<p>Here are some key benefits<a id="_idIndexMarker305"/> you can expect from testing your application:</p>
			<ul>
				<li><strong class="bold">Ensuring your applicationâ€™s quality, usability, and reliability</strong>: Testing ensures that the application behaves as expected, meets stakeholdersâ€™ needs, adheres to business requirements and technical specifications, and provides value to users. This helps increase user (and customer) satisfaction and prevents a poorly designed or developed application from having a negative impact on the organizationâ€™s reputation. This can, for example, be achieved by validating API responses and verifying the output formatting of the CLI application.</li>
				<li><strong class="bold">Ensuring your applicationâ€™s security and compliance</strong>: Testing plays a crucial role in validating the security of the application. It helps identify potential vulnerabilities and weaknesses that could be exploited by malicious actors. It also ensures that the application complies with industry standards, regulations, and other critical requirements that an organization (or an industry) might be subject to.</li>
				<li><strong class="bold">Acting as your applicationâ€™s documentation</strong>: If you have ever worked on IT projects, you know how hard it is to maintain accurate and up-to-date documentation. A by-product of software testing is that it also acts as live documentation for your application: you can run it at any time to understand the behavior of the application.</li>
				<li><strong class="bold">Simplify the applicationâ€™s evolution</strong>: If you have ever worked on IT projects, you know how scary it is when you have to modify the code of an application that works fine. We even have a saying for that: â€œIf itâ€™s not broken, donâ€™t fix it!â€. However, by having an efficient suite of tests, modifying that code is way less scary because we know that we can rely on that test suite to ensure that we didnâ€™t introduce any bug in the existing code and functionalities (we call these <em class="italic">regressions</em>).</li>
				<li><strong class="bold">Achieving cost savings and efficiency</strong>: It is well-known that the cost of finding and fixing a bug in production might be 100 times more expensive than finding it and fixing it during the development or testing phase. This cost also includes the cost of loss of efficiency as the team has to stop working on new features and concentrate on <a id="_idIndexMarker306"/>fixing that bug.</li>
			</ul>
			<p class="callout-heading">This is not a book about testing!</p>
			<p class="callout">During my career, I have coached and trained development teams, both for the organizations I worked for and for our customers, on testing and raising awareness about its importance. Thatâ€™s why I couldnâ€™t write a book about development without covering this topic.</p>
			<p class="callout">However, although we will provide very valuable information and guidance throughout this chapter, keep in mind that this is not a book about software testing. Hence, concepts such as test-driven development, behavior-driven development, and code coverage, will not be covered.</p>
			<p class="callout">That being said, I provide many references in <a href="B22400_14.xhtml#_idTextAnchor236"><em class="italic">Chapter 14</em></a> if you want to dig into this fascinating topic.</p>
			<p>As you can see, there are various types of tests. Letâ€™s highlight them!</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor159"/>Types of tests</h1>
			<p>There is a wide variety of test types. They can be classified into two categories:</p>
			<ul>
				<li><strong class="bold">Functional tests</strong>: This category of <a id="_idIndexMarker307"/>tests verifies that the application performs its <a id="_idIndexMarker308"/>intended function, according to its specifications. In other words, it ensures that the application does what it is supposed to do (what it has been designed for).</li>
				<li><strong class="bold">Non-functional tests</strong>: This category <a id="_idIndexMarker309"/>of tests verifies that the <a id="_idIndexMarker310"/>application does what is intended to do in a way that meets user expectations and quality standards.</li>
			</ul>
			<p>Each of these categories is composed of various types of tests. This figure illustrates this relationship:</p>
			<div><div><img src="img/B22400_10_01.jpg" alt="Figure 10.1 â€“ Categories and types of software tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 â€“ Categories and types of software tests</p>
			<p>Letâ€™s briefly describe each of these types of test:</p>
			<ul>
				<li><strong class="bold">Unit tests</strong>: Here, we<a id="_idIndexMarker311"/> focus on testing methods in isolation (i.e., without relying on <a id="_idIndexMarker312"/>their dependencies such as databases or external services. To achieve this, we use <em class="italic">mocking</em> techniques (more on that later) to avoid relying on these dependencies. These tests are usually fast and provide immediate feedback. They therefore help ensure that a very specific portion of the code (a method) is doing exactly what it is intended to do. In the event that a bug is discovered, this type of test proves very useful as it narrows the issue down to the line of code that causes it! It is however important not to overuse mocks as it can lead to tests that do not represent reality, making them worthless.</li>
				<li><strong class="bold">Integration tests</strong>: This type of<a id="_idIndexMarker313"/> test verifies the interactions between different <a id="_idIndexMarker314"/>components of the application, ensuring that the integrated parts work together as expected. It also helps ensure that the flow of data and communication between these components is correct and can surface integration issues, usually due to interface defects.</li>
				<li><strong class="bold">System tests</strong>: This type of<a id="_idIndexMarker315"/> test verifies that the complete application meets the <a id="_idIndexMarker316"/>specified requirements. This covers end-to-end functionality and behavior and relies on external dependencies. These tests are performed in an environment that is similar to the production environment (usually the staging or pre-production environment).</li>
				<li><strong class="bold">Acceptance tests</strong>: This type <a id="_idIndexMarker317"/>of test validates that the application meets the usersâ€™ <a id="_idIndexMarker318"/>needs and business requirements. The main difference is that acceptance tests are usually performed by users or stakeholders and serve as a final approval before going to production.</li>
			</ul>
			<p>We just described the types of functional tests. Letâ€™s now describe the types of non-functional tests:</p>
			<ul>
				<li><strong class="bold">Security tests</strong>: This<a id="_idIndexMarker319"/> type of test is intended to reveal vulnerabilities and security<a id="_idIndexMarker320"/> breaches in the application and aims to protect users against data breaches, unauthorized access, and cyber-attacks in general.</li>
				<li><strong class="bold">Performance tests</strong>: This <a id="_idIndexMarker321"/>type of test is intended to identify performance issues and bottlenecks by measuring response times and resource usage and<a id="_idIndexMarker322"/> identifying scalability or capacity limits under various workloads.. This provides valuable insights into what parts of the application require special attention, such as redesigning or refactoring, in order to meet the performance requirements and usersâ€™ expectations.</li>
				<li><strong class="bold">Usability tests</strong>: This type of <a id="_idIndexMarker323"/>test focuses on assessing the user-friendliness and ease of <a id="_idIndexMarker324"/>use of the application. This involves asking real users to test the application by completing tasks, gathering feedback and metrics along the way (such as the user experience in general, how easy it is to navigate the application, how long it takes to complete a task, and the userâ€™s appreciation in general).</li>
				<li><code>interactive</code> command, which means that the terminal it is running in is compliant with the requirements. We should then ensure that it works as expected when these requirements are met and gracefully degrades (e.g., converts to text-based output) when they are not.</li>
			</ul>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor160"/>About usability tests</h2>
			<p>As you may have<a id="_idIndexMarker327"/> guessed, usability tests <a id="_idIndexMarker328"/>are intended to be performed manually. While it may not always be possible to gather real users together to perform these tests, one way to achieve this goal in the context of a CLI application is by implementing a command in the CLI application that allows users to provide feedback.</p>
			<p>Here is, as an example, how the Azure CLI team does it: they provide a <code>survey</code> command that directs the user to an online form where they can provide feedback.</p>
			<div><div><img src="img/B22400_10_02.jpg" alt="Figure 10.2 â€“ Allowing users to provide feedback"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 â€“ Allowing users to provide feedback</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor161"/>The pyramid of (software) testing</h2>
			<p>Many of you may not be familiar with the concepts of functional and non-functional tests, but you may be familiar with the<a id="_idIndexMarker329"/> pyramid of testing. It is worth mentioning that this pyramid includes many of the functional and non-functional types of test that we just discussed.</p>
			<p>As a reminder, the pyramid of testing<a id="_idIndexMarker330"/> looks like this:</p>
			<div><div><img src="img/B22400_10_03.jpg" alt="Figure 10.3 â€“ The pyramid of (software) testing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 â€“ The pyramid of (software) testing</p>
			<p>The <a id="_idIndexMarker331"/>reason this is presented as a pyramid is to illustrate the quantity of tests to be expected at each step. The larger the step, the more tests it is expected to contain. As an example, a project is likely to have more unit tests than system tests and more system tests than UAT tests. This is due to the cost of creating and maintaining such tests.</p>
			<p>It is important to keep in mind that what separates these various types of tests is their scope and their intent, not the frameworks or libraries used to implement them.</p>
			<p>It is also important to keep in mind that you can create your own types of tests if you need to. Let me give you some examples.</p>
			<p class="callout-heading">About custom types of tests</p>
			<p class="callout">In my career, I have worked with <a id="_idIndexMarker332"/>organizations that had their own custom types of tests that suited their needs and policies.</p>
			<p class="callout">For example, some organizations may <a id="_idIndexMarker333"/>have <em class="italic">architectural tests</em>, which are tests <a id="_idIndexMarker334"/>written to ensure that an application (and its components) are developed following their architectural standards, such as what components can reference what components, ensure that every service class exposes an interface, and so on.</p>
			<p class="callout">Another type of test I have seen can be referred to<a id="_idIndexMarker335"/> as <em class="italic">naming conventions tests</em>. These<a id="_idIndexMarker336"/> tests are meant to ensure that every component (such as classes, services or libraries) is named according to the organizationâ€™s naming conventions and standards.</p>
			<p>These two types of tests are intended to simplify the code review process and can be automated as part of validating a pull request.</p>
			<p>We now have a better understanding of the various types of tests. The next logical question (the one that I get every time I discuss software testing with clients) is: <em class="italic">â€œWhat should we test?â€</em> Letâ€™s discuss this now.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor162"/>What should we test?</h1>
			<p>This is a <a id="_idIndexMarker337"/>great question!</p>
			<p>It is easy to say that you should test every possible scenario in your application. However, we need to consider the following:</p>
			<ul>
				<li>How do you define â€œevery scenarioâ€?</li>
				<li>Can you really test â€œevery scenarioâ€? How many tests does that mean?</li>
			</ul>
			<p>In a nutshell, your suite of tests should cover both of the following:</p>
			<ul>
				<li><strong class="bold">The happy path</strong>: This <a id="_idIndexMarker338"/>means testing the situation in which the required input for your application is provided and is in the expected format</li>
				<li><strong class="bold">The unhappy path</strong>: Here, we<a id="_idIndexMarker339"/> test the behavior of the application under unexpected circumstances, such as input in the wrong format, user errors, network issues (when relying on external dependencies), the user canceling a task, and so on</li>
			</ul>
			<p>Once again, this is not a book<a id="_idIndexMarker340"/> about software testing, but I would like to give you some guidance on what to test in different situations:</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Input parameters</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Test both valid and invalid values.</p>
							<p>As an example, if a method takes only one integer parameter, and the range of valid values is between 1 and 100, we should also test it with values outside of this range, such as <code>-1</code>, <code>0</code>, and <code>2000</code> (we usually call these <code>"bonjour"</code> or <code>1.23</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Lists</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>When dealing with <a id="_idIndexMarker342"/>lists, we should ensure that the list only contains the expected elements, no more, no less. It is not sufficient to check the number of elements in the list because if a bug in the code inserts an element more than once or inserts inappropriate elements, the count could meet the expected value, but the list might not contain the appropriate elements.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Exceptions</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>If the application throws <a id="_idIndexMarker343"/>exceptions, this should be tested too to ensure that the right type of exception is thrown and with the expected details.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Methods/services </strong><strong class="bold">returned values</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>It is easy to <a id="_idIndexMarker344"/>verify that a numerical or string value matches the expected value, but if the return value is an object (or a list of objects), we should verify that the values of all meaningful properties match the expected ones.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Methods/services </strong><strong class="bold">behavior</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>While most developers verify the returned values of their methods or services when implementing tests, they fail at verifying that these methods or services behave as expected.</p>
							<p>Verifying the behavior of a method or service means that we need to ensure that:</p>
							<ul>
								<li>The correct subsequent methods are called with the expected parameters. These could be logging or caching methods or calls to external dependencies such as database or external APIs for example.</li>
								<li>The state changes within the object, the class, or the service are accurate and expected.</li>
								<li>Side effects, such as database updates or changes to files, are accurate and expected.</li>
								<li>Idempotency occurs when appropriate, which means that if the same method is called more than once, it maintains the coherence of the system. Think of a method that performs a call to a payment gateway or to a reservation system. We certainly donâ€™t want the customer to be charged twice for the same purchase, nor for multiple reservations<a id="_idIndexMarker345"/> to be made for the same appointment.</li>
							</ul>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 â€“ What to test</p>
			<p>It is just as important to know what to test as it is to know what <em class="italic">not</em> to test.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor163"/>What not to test</h2>
			<p>You should not test external frameworks and libraries because this is the responsibility of their creators and maintainers. It is very likely that they have already been tested before you had a chance to use them. So, donâ€™t do this, please!</p>
			<p>Other code artifacts that do not need to be tested are model classes<a id="_idIndexMarker346"/> and <strong class="bold">Data Transfer Objects</strong> (<strong class="bold">DTOs</strong>) as they are supposed to only contain properties, not methods, since they do not perform any processing of any kind, only move data around.</p>
			<p>Also, you may have heard that it is not recommended to test private methods. There is a heated debate about whether we should test private methods. My personal opinion is that you should not, for two main reasons:</p>
			<ul>
				<li><strong class="bold">A private method is intended to be invoked by at least one public method</strong>: Hence, when testing that public method, you are also testing the private one.</li>
				<li><code>Object</code> to pass parameters to it. It is hence very easy to break these tests at runtime (they will compile, though) since the name of the method is usually passed as a string, and since every data type inherits from the <code>Object</code> class, if we change the data type or structure for a given parameter, it will still inherit from that same base class even though it is not expected by the private method anymore.</li>
			</ul>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor164"/>Testing is a safety net</h2>
			<p>As I tell my customers and students, a test suite<a id="_idIndexMarker347"/> is like a safety net:</p>
			<ul>
				<li>The more test cases you cover, the wider the safety net. If you fall from 30 feet and your safety net is 2 inches by 2 inches, the chances are that it wonâ€™t help.</li>
				<li>On the other hand, if you have a safety net that is 50 feet by 50 feet but its meshes are 3 feet by 3 feet large, it wonâ€™t help either. What I mean here is that if you have an extensive test suite in terms of a number of tests, but these tests do not cover meaningful situations, your test suite is of no use.</li>
			</ul>
			<p>So, we are now aware of the different types of tests, and we know what to test. But when should we run these tests? Letâ€™s discuss this.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor165"/>When should we run tests?</h1>
			<p>The various types of tests we discussed are intended to be run at different points during the development lifecycle.</p>
			<p>An organization (or even a developer or a team) may have policies and preferences but, in general, the following recommendations are adopted by the industry:</p>
			<ul>
				<li><strong class="bold">Unit tests</strong>: These <a id="_idIndexMarker348"/>tests are intended to be run during development. In other words, the developer should run them as they write the code. There are some IDEs (such as Visual Studio Enterprise) that even allow you to configure unit tests to be run in the <a id="_idIndexMarker349"/>background as you type your code! This has to be configured and used carefully as it might quickly become cumbersome. You have to, however, run them before committing your changes, and before creating or updating a pull request. Unit tests are also usually run as part of a CI/CD pipeline. For these reasons, unit tests should always be automated and are actually very easy to automate.</li>
				<li><strong class="bold">Integration tests</strong>: These<a id="_idIndexMarker350"/> tests are to be run after unit tests have passed (that is, run successfully).</li>
				<li><strong class="bold">Smoke tests</strong>: These<a id="_idIndexMarker351"/> tests should be run after a new build has been deployed and before QA testers engage in more extensive testing. For this reason, these tests are usually triggered by the CI/CD pipeline, right after the deployment operation is completed.</li>
				<li><strong class="bold">System tests</strong>: These <a id="_idIndexMarker352"/>tests are run on a staging or pre-production environment, right before releasing the application to production. These tests are to be triggered after integration tests have passed.</li>
				<li><strong class="bold">Regression tests</strong>: These tests<a id="_idIndexMarker353"/> should be run at least before committing your changes. They should also be part of the CI/CD pipeline.</li>
				<li><strong class="bold">Performance tests</strong>: These<a id="_idIndexMarker354"/> should be run when new features (especially the ones dealing with external dependencies) or any significant code changes have been made.</li>
				<li><strong class="bold">UAT tests</strong>: These special tests are performed by users (or their representatives, such as stakeholders) and are<a id="_idIndexMarker355"/> intended to obtain final approval before releasing the application to production. Hence, these tests are usually manual.</li>
			</ul>
			<p>As you may have noticed, we havenâ€™t covered all the possible types of tests. We have only focused on the ones that are part of the pyramid of software testing.</p>
			<p>Okay. Now that we understand the importance of software testing, and we know what to test, letâ€™s implement testing into our CLI application.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor166"/>Adding a test project to Bookmarkr</h1>
			<p>In order to add a test project for<a id="_idIndexMarker356"/> our CLI application, I needed to make a slight <a id="_idIndexMarker357"/>change to the project structure, which was to extract the solution file (<code>.sln</code>) from the project directory and edit it to update the path to the <code>.csproj</code> file. This allows us to create a test project and add it to the solution.</p>
			<p>Next, letâ€™s type the following command to create the test project:</p>
			<pre class="console">
dotnet new mstest -n bookmarkr.UnitTests</pre>			<p>This will create a new directory, named <code>bookmarkr.UnitTests</code>, in which the content of the test project will reside.</p>
			<p>Right now, this directory only contains two files:</p>
			<ul>
				<li><code>Bookmarkr.UnitTests.csproj</code>, which describes the project, its configuration, and its dependencies</li>
				<li><code>UnitTest1.cs</code>, which acts as a sample test class</li>
			</ul>
			<p>It is interesting to<a id="_idIndexMarker358"/> note that the <code>.csproj</code> file already references some testing libraries and frameworks, particularly the <strong class="bold">MS Test</strong> testing framework, which<a id="_idIndexMarker359"/> is the one we will be using throughout this <a id="_idIndexMarker360"/>chapter.</p>
			<p class="callout-heading">About testing frameworks</p>
			<p class="callout">While there are <a id="_idIndexMarker361"/>many testing frameworks, the most common ones<a id="_idIndexMarker362"/> being <strong class="bold">NUnit</strong>, <strong class="bold">xUnit</strong>, and <strong class="bold">MS Test</strong>, we decided <a id="_idIndexMarker363"/>to use the latter for many reasons:</p>
			<p class="callout">- MS Test is Microsoftâ€™s testing framework and is widely known and used</p>
			<p class="callout">- MS Test has evolved over the years and has a rich feature set, such as built-in support for testing parallel code, data-driven testing, and test grouping capabilities</p>
			<p class="callout">That being said, no matter what your preferred testing framework is, the concepts are similar and the one covered in this chapter will apply as well. The main difference will be in the keywords provided by each testing framework.</p>
			<p>It is also interesting to note that the test project is defined as <em class="italic">non-packable</em>. This means that this project will not be packaged and distributed as part of the application, which makes perfect sense.</p>
			<p>But before we go any further, letâ€™s add the test project to the solution using this command (which has to be run at the same location as the <code>.</code><code>sln</code> file):</p>
			<pre class="console">
dotnet sln add bookmarkr.UnitTests/bookmarkr.UnitTests.csproj</pre>			<p>Now, if we open the solution in Visual Studio, it will contain both the code and the test projects.</p>
			<p>The next step is to make our test project reference the actual project. This is required so that we can<a id="_idIndexMarker364"/> test the actual code. So, letâ€™s navigate to the test <a id="_idIndexMarker365"/>projectâ€™s directory and type this command:</p>
			<pre class="console">
dotnet add reference ../bookmarkr/bookmarkr.csproj</pre>			<p>There is one last step we need to take before we start implementing unit tests, which is to define a structure for our test project.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor167"/>Structuring the test project</h2>
			<p>Each developer, team, or organization <a id="_idIndexMarker366"/>will have preferences when it comes to structuring their test projects. In this section, I will introduce you to my way of structuring test projects, which I implemented during my career and found valuable.</p>
			<p>First, if your application is composed of multiple components and each component has its own Visual Studio project, you will want to create a separate unit tests project for each component while having a single integration tests project. This structure may be similar to this:</p>
			<div><div><img src="img/B22400_10_04.jpg" alt="Figure 10.5 â€“ Structure of test projects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 â€“ Structure of test projects</p>
			<p>In this chapter, we will <a id="_idIndexMarker367"/>only focus on unit tests, but the same principles apply to integration tests. This is the reason why we only have a <code>bookmarkr.UnitTests</code> project.</p>
			<p>However, if you create multiple test projects within the solution, remember to always use the same version of the testing framework across all projects to prevent side effects due to compatibility issues.</p>
			<p>Now, letâ€™s structure our unit tests project. Here, again, there are unlimited possibilities depending on personal choices and teamsâ€™/organizationsâ€™ policies. My approach is to have one test class for each code class. The test class will have the same name as the code class completed with the <code>Tests</code> suffix. I also like to replicate, in the test project, the same folder structure as in the code project as I find it easier to navigate in the test project because of the structure parity between the two projects.</p>
			<p>After applying these principles, the structure of our test project looks as follows:</p>
			<div><div><img src="img/B22400_10_05.jpg" alt="Figure 10.6 â€“ Test projectâ€™s structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 â€“ Test projectâ€™s structure</p>
			<p>Now that the structure of our test project is set up, we can start implementing our unit tests. But wait! Are there any code artifacts that should not be tested? Yes, indeed!</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor168"/>Code artifacts that should not be tested</h2>
			<p>The following artifacts do not need to be tested since they do not perform any processing:</p>
			<ul>
				<li><code>Bookmark.cs</code> and <code>BookmarkConflictModel.cs</code> since they are only model classes and hence only serve the purpose of moving data around.</li>
				<li><code>Program.cs</code>: The purpose of this class is to configure the CLI application, configure logging, identify which command is the root command and build the command hierarchy.</li>
				<li><code>Helper.cs</code>: This helper classâ€™s methods are used to format the text outputs using different colors and formatting. Hence, this class is more suitable for UI testing rather than unit testing. For this reason, it is excluded from unit testing. However, it could be tested as part of manual tests or end-to-end tests.</li>
			</ul>
			<p>Keep in mind that even though we decided not to test these code artifacts for valid reasons, MS Test will tell us, as part of the test results, that these artifacts were not tested.</p>
			<p>We can inform MS Test that we have chosen not to test these artifacts using the <code>[ExcludeFromCodeCoverage]</code> attribute. This attribute is very flexible: it can be applied to the property, method, class, or even assembly level. This attribute also allows us to pass a string to justify our decision.</p>
			<p>As an example, this is how we will apply it to the <code>Program</code> class:</p>
			<pre class="source-code">
using System.Diagnostics.CodeAnalysis;
//â€¦
[ExcludeFromCodeCoverage(Justification="CLI application configuration. No processing is performed in this class.")]
class Program
{
Â Â Â Â // â€¦
}</pre>			<p>We are finally ready to start implementing some tests. Letâ€™s dive in!</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor169"/>Writing effective tests</h1>
			<p>We will learn how to implement<a id="_idIndexMarker368"/> tests by writing tests for the <code>link</code> and the <code>import</code> commands.</p>
			<p>The first thing we need to do is to add a test class for each command. We already have the folder structure in place, so letâ€™s add the test classes. As I mentioned earlier, I find it useful to name my test classes after the actual classes with an added suffix of <code>Tests</code>. So, our test classes will be named <code>LinkCommandTests</code> and <code>ImportCommandTests</code>, respectively.</p>
			<p>Now, let me introduce you to the best practices of structuring a test class and its test methods (yes, we will talk about structure once again! ğŸ˜Š):</p>
			<ul>
				<li>Using MS Test, a test class<a id="_idIndexMarker369"/> is decorated with the <code>[TestClass]</code> attribute. If you donâ€™t <a id="_idIndexMarker370"/>provide this attribute, the class will not be considered a test class and the test methods it contains will not be run.</li>
				<li>A test class usually<a id="_idIndexMarker371"/> consists of multiple test methods. The name of a test method should convey its intent. This is important since the test report will only present the names of the methods along with an icon indicating the result of this test method (pass, fail, skipped, and so on). The usual approach is that the name of test a method is composed of its name, its input parametersâ€™ values, and the expected result. Examples of such names are <code>GetEmployeeById_ValidId_ReturnsTheExpectedEmployeeObject</code> and <code>GetEmployeeById_InvalidId_ThrowsEmployeeNotFoundException.</code></li>
				<li>Using MS Test, a test method is decorated with the <code>[TestMethod]</code> attribute. If you donâ€™t provide this attribute, the class will not be considered as a test method and will not be run.</li>
				<li>A test method should test one and only one outcome (whether this is a result or a behavior). This is important since we need to be able to know that, if a test method fails, it is because it didnâ€™t achieve the expected outcome (a result or a behavior). To achieve this, however, a test method may contain more than one assertion as long as these multiple assertions serve the purpose of validating that one outcome.</li>
				<li>To maximize clarity and readability, it is advised that a test methodâ€™s body be chunked into three parts (also known as the 3As):<ul><li><strong class="bold">Arrange</strong>: where all <a id="_idIndexMarker372"/>the objects required to perform the test are instantiated and initialized.</li><li><strong class="bold">Act</strong>: where the code artifact to be tested is invoked and the result is gathered.</li><li><strong class="bold">Assert</strong>: where the obtained result (usually referred to as the â€œactualâ€ result) is compared to the expected result. If both match, the test is considered to be a <a id="_idIndexMarker373"/>success. However, the test is considered to be a failure.</li></ul></li>
			</ul>
			<p>Armed with this new <a id="_idIndexMarker374"/>knowledge, we have everything we need to write our first test. Letâ€™s start by writing tests for the <code>link</code> command.</p>
			<p>Looking at the code of the <code>LinkCommand</code> class, we notice that it does not have any methods. However, we see that its constructor calls the <code>AddCommand</code> method to set the <code>LinkAddCommand</code> as a sub-command of <code>Linkcommand</code> (that is why <code>add</code> appears as a child of the <code>link</code> command).</p>
			<p>In this case, our test method will not be verifying a result but rather a behavior. In this case, we want to verify that <code>LinkAddCommand</code> is actually a sub-command of <code>LinkCommand</code>.</p>
			<p>Here is the code for this test method:</p>
			<pre class="source-code">
[TestMethod]
public void LinkCommand_CallingClassConstuctor_EnsuresThatLinkAddCommandIsTheOnlySubCommandOfLinkCommand()
{
Â Â Â Â // Arrange
Â Â Â IBookmarkService service = null;
Â Â Â var expectedSubCommand = new LinkAddCommand(service, "add", "Add a 
Â Â Â new bookmark link");
Â Â Â Â // Act
Â Â Â Â var actualCommand = new LinkCommand(service, "link", "Manage 
Â Â Â Â bookmarks links");
Â Â Â Â var actualSubCommand = actualCommand.Subcommands[0];
Â Â Â Â // Assert
Â Â Â Assert.AreEqual(1, actualCommand.Subcommands.Count);
Â Â Â CollectionAssert.AreEqual(actualSubCommand.Aliases.ToList(), 
Â Â Â expectedSubCommand.Aliases.ToList());
Â Â Â Assert.AreEqual(actualSubCommand.Description, expectedSubCommand.
Â Â Â Description);
}</pre>			<p>Although this code is self-explanatory and easy to understand, I wanted to point out a couple of key points:</p>
			<ul>
				<li>Notice the naming <a id="_idIndexMarker375"/>convention applied to the name of the test method. It clearly indicates its intent: we are testing the <code>LinkCommand</code> class, and our test consists of calling the class constructor and ensuring that <code>LinkAddCommand</code> is its only sub-command.</li>
				<li>Notice that we applied the 3A principle to structure the body of the test method.</li>
				<li>Notice that we performed three assertions to verify the expected behavior. Also, note the usage of <code>CollectionAssert</code>, which helps with asserting collections and their items. It is way more convenient than using <code>Assert</code> when dealing with lists and collections of elements. This is my little secret for you, as many developers are not aware of it or donâ€™t naturally tend to use it ğŸ˜‰.</li>
			</ul>
			<p>We are now ready to run our tests. Letâ€™s see how we do this.</p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor170"/>Running our tests</h1>
			<p>The .NET CLI provides a command for <a id="_idIndexMarker376"/>this purpose:</p>
			<pre class="console">
dotnet test</pre>			<p>This command will compile the code and the test project, discover the test classes and test methods, execute the tests, and return the results.</p>
			<p>Visual Studio Code also provides <a id="_idIndexMarker377"/>a <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) for listing and executing the tests. This pane can be displayed by clicking on the appropriate icon, as<a id="_idIndexMarker378"/> shown in the following figure:</p>
			<div><div><img src="img/B22400_10_06.jpg" alt="Figure 10.7 â€“ Running tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 â€“ Running tests</p>
			<p>This GUI also provides a visual identification of the states of the test methods. In the preceding screenshot, we can see that our test method has been completed successfully.</p>
			<p>From this GUI, we can also debug tests! This is a fantastic capability that helps us understand why a test is failing by strategically applying breakpoints and re-executing it in debug mode.</p>
			<p>Excellent! We can implement more tests.</p>
			<p>But wait!</p>
			<p>Have you noticed that we passed a <code>null</code> instance of the <code>BookmarkrService</code> as a parameter? This is fine since we are not relying on that parameter in the test we are conducting. But if we did (as we will when testing the <code>import</code> command), we would like to provide an instance for it.</p>
			<p>We obviously donâ€™t want to use an actual instance of that service as it is a dependency of the command and it may also rely on an external dependency, such as a database where the bookmarks are stored.</p>
			<p>We will then need to provide a fake representation of it. This is <a id="_idIndexMarker379"/>where <strong class="bold">mocks</strong> come into play!</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor171"/>Mocking external dependencies</h1>
			<p>Mocking<a id="_idIndexMarker380"/> is useful for simulating the behavior of dependencies without actually relying on them. This is powerful because it allows us to test our application in isolation from its environment. The reason we want to do this is to have tests that ensure that the applicationâ€™s code works correctly, irrespective of the state of its dependencies.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor172"/>The role of mocking</h2>
			<p>Let me clarify this with an <a id="_idIndexMarker381"/>example. Letâ€™s say you have a method that stores a bookmark in the database. You write a test method to verify that, and it fails. You run it again, and it passes. Can you tell, without investigating, whether this was due to a transient database connectivity problem or due to a bug in the code? You canâ€™t! But if you remove the dependency (that is, the database) from the equation and the same behavior occurred, you can tell (with a high level of confidence) that this was due to a bug in the code.</p>
			<p>It is worth mentioning that we usually write tests that take external dependencies out of the equation (namely, unit tests) and tests that take these external dependencies into account (such as integration or system tests). So, when facing such an issue, we can look at unit and integration or system tests to figure out if the problem is due to the dependency (such as a communication problem) or due to the code itself.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor173"/>How to mock an external dependency</h2>
			<p>As mentioned earlier, we <a id="_idIndexMarker382"/>can write our own fake implementation of a dependency that simulates the behavior of the real dependency, but the major drawback of this approach is that we have to maintain (and possibly rewrite) these implementations if the behavior of the real dependency changes.</p>
			<p>It is wiser to rely on a mocking framework that will perform this task for us. What we need to do is to provide an interface for that dependency and the mocking framework will create a fake representation of it at runtime. We can also pass instructions to the mocking framework to configure the behavior of the fake dependency in a certain way, depending on the test we need to perform. For example, we can instruct the mocking framework to simulate a certain error or exception when invoking a dependency with some parameter values to verify <a id="_idIndexMarker383"/>the behavior of our application under these circumstances.</p>
			<p class="callout-heading">About mocking frameworks</p>
			<p class="callout">Just as there are many testing frameworks, there <a id="_idIndexMarker384"/>are also many mocking frameworks for you to choose from. One of the most commonly used ones, and my personal favorite, is <strong class="bold">NSubstitute</strong>. I like it <a id="_idIndexMarker385"/>because it is both powerful and easy to learn and use.</p>
			<p class="callout">You can learn more about<a id="_idIndexMarker386"/> NSubstitute by visiting its website: <a href="https://nsubstitute.github.io/help/getting-started/">https://nsubstitute.github.io/help/getting-started/</a>.</p>
			<p>Letâ€™s mock the <code>BookmarkService</code> service using NSubstitute.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor174"/>Mocking the BookmarkService service</h2>
			<p>The first thing we need to do<a id="_idIndexMarker387"/> is to add NSubstitute to the test project. We can achieve this by navigating to the directory of the test project and typing this command:</p>
			<pre class="console">
dotnet add package NSubstitute</pre>			<p>Now, letâ€™s update the <code>LinkCommandTests</code> test class by mocking the <code>BookmarkService</code> service. The updated code is as follows:</p>
			<pre class="source-code">
using NSubstitute;
â€¦
namespace bookmarkr.Tests;
[TestClass]
public class LinkCommandTests
{
Â Â Â Â [TestMethod]
Â Â Â Â public void LinkCommand_CallingClassConstuctor_
Â Â Â Â EnsuresThatLinkAddCommandIsTheOnlySubCommandOfLinkCommand()
Â Â Â Â {
Â Â Â Â Â Â Â Â // Arrange
Â Â Â Â Â Â Â Â IBookmarkService service = Substitute.For&lt;IBookmarkService&gt;();
Â Â Â Â Â Â Â Â â€¦
Â Â Â Â }
}</pre>			<p>As you can see, we havenâ€™t done much here. We merely added a <code>using</code> statement for <code>NSubstitute</code> and instead of initializing the service to a <code>null</code> value, we asked <code>NSubstitute</code> to provide a simulation of it based on its interface (which is referred to as a <em class="italic">mock</em>). The result is a temporary, in-memory object built based on the structure of the <code>IBookmarkService</code> interface for which we can configure the behavior depending on the test we are performing.</p>
			<p>If we now execute the test<a id="_idIndexMarker388"/> again, it still passes. Since we are not calling the service during our test, we do not need to configure its behavior. But we will need to do that for the upcoming test methods we are going to implement.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor175"/>Using the mock version of the BookmarkService service</h2>
			<p>Letâ€™s start by creating a test class<a id="_idIndexMarker389"/> for the <code>import</code> command. We first create the <code>ImportCommandTests.cs</code> file in the <code>Commands\Import</code> directory. This file will contain all the test methods related to the <code>import</code> command.</p>
			<p>Next, we lay out the base structure of the test class, as follows:</p>
			<pre class="source-code">
using bookmarkr.Commands;
using bookmarkr.Services;
using NSubstitute;
namespace bookmarkr.Tests;
[TestClass]
public class ImportCommandTests
{
}</pre>			<p>This command has no subcommands, so we do not need to test that, or we can write a test that verifies this fact. If you want to do this, you can follow the same procedure as in the <code>LinkCommandTests</code> class.</p>
			<p>Before we start<a id="_idIndexMarker390"/> implementing tests, we need to identify the test cases we want to perform. In invite you to reflect on that, but in the meantime, here is a non-exhaustive list of test cases:</p>
			<ul>
				<li><code>OnImportCommand</code> handler method will call the <code>Import</code> method of <code>BookmarkService</code>.</li>
				<li><strong class="bold">Test case #2</strong>: If the file name is invalid, an error message should be returned (for example, indicating that there is an forbidden character in the filename).</li>
				<li><strong class="bold">Test case #3</strong>: If the file is not found, an error message, indicating that the file does not exist, should be returned.</li>
				<li><strong class="bold">Test case #4</strong>: When importing bookmarks, if no conflict is detected, the imported bookmarks are found in the local collection of bookmarks.</li>
				<li><code>Log</code> method is also called.</li>
			</ul>
			<p>For the purpose of this chapter, we will only implement test cases 1 and 5. The remaining test cases are left for you as a challenge.</p>
			<p>However, before we can implement these test cases, some changes to the applicationâ€™s code have to be made.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor176"/>Changes to the code must be made!</h2>
			<p>Here is <a id="_idIndexMarker391"/>the idea: sometimes, changes to your code will have to be made so that the code can be testable. This is okay because some classes of the .NET framework arenâ€™t testable by nature.</p>
			<p>In our situation, this is the case with the <code>FileInfo</code> class, which is a sealed class and exposes no interface, hence it cannot be overridden nor mocked.</p>
			<p>Fortunately, there is a library that allows us to work around this limitation. We will then need to add the following NuGet package to both the application and the test projects:</p>
			<pre class="console">
dotnet add package System.IO.Abstractions</pre>			<p>For the test project, we will also need to add this NuGet package, which will help with testing:</p>
			<pre class="console">
dotnet add package System.IO.Abstractions.TestingHelpers</pre>			<p>We will also need to make the following changes to the <code>ImportCommand</code> class:</p>
			<ol>
				<li>We will add a private property of type <code>IFileSystem</code>.</li>
				<li>We will initialize this property to an instance of the <code>FileSystem</code> class in the default constructor.</li>
				<li>We will add a second constructor that will only be used for testing. This constructor will take an extra parameter, of type <code>IFileSystem</code>.</li>
				<li>Finally, we will add an overload of the <code>OnImportCommand</code> handler method that takes an <code>IFileInfo</code> parameter and whose only purpose is to call the original version of the <code>OnImportCommand</code> method, passing an instance of <code>FileInfo</code> based on the <code>IFileInfo</code> object it received.</li>
			</ol>
			<p>Invoking the <code>import</code> command once again, we find out that it still works as expected.</p>
			<p>We can now implement those test cases.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor177"/>Going back to implementing the test cases</h2>
			<p>Letâ€™s start with test<a id="_idIndexMarker392"/> case 1. Here is the associated test method:</p>
			<pre class="source-code">
[TestMethod]
public void OnImportCommand_PassingAValidAndExistingFile_CallsImportMethodOnBookmarkService()
{
Â Â Â Â // Arrange
Â Â Â Â var mockBookmarkService = Substitute.For&lt;IBookmarkService&gt;();
Â Â Â Â string bookmarksAsJson = @"[
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â ""Name"": ""Packt Publishing"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Url"": ""https://packtpub.com/"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Category"": ""Tech Books""
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â ""Name"": ""Audi cars"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Url"": ""https://audi.ca"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Category"": ""See later""
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â ""Name"": ""LinkedIn"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Url"": ""https://www.linkedin.com/"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Category"": ""Social Media""
Â Â Â Â Â Â Â Â }
Â Â Â Â ]";
Â Â Â Â var mockFileSystem = new MockFileSystem(new Dictionary&lt;string, 
Â Â Â Â MockFileData&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â {@"bookmarks.json", new MockFileData(bookmarksAsJson)}
Â Â Â Â Â Â Â Â });
Â Â Â Â var command = new ImportCommand(mockBookmarkService, 
Â Â Â Â mockFileSystem, "import", "Imports all bookmarks from a file");
Â Â Â Â // Act
Â Â Â Â command.OnImportCommand(mockFileSystem.FileInfo.New("bookmarks.
Â Â Â Â json"));
Â Â Â Â // Assert
Â Â Â Â mockBookmarkService.Received(3).Import(Arg.Any&lt;Bookmark&gt;());
Â Â Â Â mockBookmarkService.Received(1).Import(Arg.Is&lt;Bookmark&gt;(b =&gt; 
Â Â Â Â b.Name == "Packt Publishing" &amp;&amp; b.Url == "https://packtpub.com/" 
Â Â Â Â &amp;&amp; b.Category == "Tech Books"));
Â Â Â Â mockBookmarkService.Received(1).Import(Arg.Is&lt;Bookmark&gt;(b =&gt; 
Â Â Â Â b.Name 
Â Â Â Â == "Audi cars" &amp;&amp; b.Url == "https://audi.ca" &amp;&amp; b.Category == "See 
Â Â Â Â later"));
Â Â Â Â mockBookmarkService.Received(1).Import(Arg.Is&lt;Bookmark&gt;(b =&gt; 
Â Â Â Â b.Name == "LinkedIn" &amp;&amp; b.Url == "https://www.linkedin.com/" &amp;&amp; 
Â Â Â Â b.Category == "Social Media"));
}</pre>			<p>This code deserves an explanation, so here we go:</p>
			<ol>
				<li>We first create a mock of the <code>BookmarkService</code>, as we did in the previous example.</li>
				<li>Then, we create a string representation of the JSON content for three bookmarks that will be needed for our test.</li>
				<li>Next, and this is the reason why we performed the changes to the code that we described above, we create a mock of the filesystem and simulate the existence of a file named <code>bookmarks.json</code> that contains the JSON representation we created in the previous step.</li>
				<li>After that, we <a id="_idIndexMarker393"/>create an instance of the <code>ImportCommand</code> class using the new constructor we have added, which allows us to pass the mock filesystem as a parameter.</li>
				<li>We are now ready to invoke the <code>OnImportCommand</code> by relying on the mock filesystem and passing the name of the <code>bookmarks.json</code> file we simulated earlier. It is important to note here that if we pass the name of a file that was not part of the simulation, the test will fail.</li>
				<li>We are now ready to verify whether our assertions are correct. Pay careful attention to how we did it: we first ensured that calling the <code>OnImportCommand</code> method triggered three calls to the <code>Import</code> method of <code>BookmarkService</code> (here, these calls are in fact made to the mock version of the service since we do not want the service to be activated but rather, we only want to validate that it was invoked as expected). This is, however, not sufficient to validate that the test is successful as these three calls could include unexpected calls. To make sure that these calls are legitimate, we verify them, one by one, ensuring that each of their meaningful properties matches what is expected.</li>
			</ol>
			<p>And thatâ€™s it for test <a id="_idIndexMarker394"/>case #1. Letâ€™s now move on to test case #5.</p>
			<p>Here is the code for this test case:</p>
			<pre class="source-code">
[TestMethod]
public void ImportCommand_Conflict_TheNameOfTheConflictingBookmarkIsUpdated()
{
Â Â Â Â // Arrange
Â Â Â Â var bookmarkService = new BookmarkService();
Â Â Â Â bookmarkService.ClearAll();
Â Â Â Â bookmarkService.AddLink("Audi Canada", "https://audi.ca", "See 
Â Â Â Â later");
Â Â Â Â string bookmarksAsJson = @"[
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â ""Name"": ""Packt Publishing"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Url"": ""https://packtpub.com/"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Category"": ""Tech Books""
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â ""Name"": ""Audi cars"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Url"": ""https://audi.ca"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Category"": ""See later""
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â ""Name"": ""LinkedIn"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Url"": ""https://www.linkedin.com/"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Category"": ""Social Media""
Â Â Â Â Â Â Â Â }
Â Â Â Â ]";
Â Â Â Â var mockFileSystem = new MockFileSystem(new Dictionary&lt;string,
Â Â Â Â MockFileData&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â {@"bookmarks.json", new MockFileData(bookmarksAsJson)}
Â Â Â Â });
Â Â Â Â var command = new ImportCommand(bookmarkService, mockFileSystem, 
Â Â Â Â "import", "Imports all bookmarks from a file");
Â Â Â Â // Act
Â Â Â Â command.OnImportCommand(mockFileSystem.FileInfo.New("bookmarks.
Â Â Â Â json"));
Â Â Â Â var currentBookmarks = bookmarkService.GetAll();
Â Â Â Â // Assert
Â Â Â Â Assert.AreEqual(3, currentBookmarks.Count);
Â Â Â Â Assert.IsTrue(currentBookmarks.Exists(b =&gt; b.Name == "Packt 
Â Â Â Â Publishing" &amp;&amp; b.Url == "https://packtpub.com/" &amp;&amp; b.Category == 
Â Â Â Â "Tech Books"));
Â Â Â Â Assert.IsTrue(currentBookmarks.Exists(b =&gt; b.Name == "Audi cars" 
Â Â Â Â &amp;&amp; b.Url == "https://audi.ca" &amp;&amp; b.Category == "See later"));
Â Â Â Â Assert.IsTrue(currentBookmarks.Exists(b =&gt; b.Name == "LinkedIn" 
Â Â Â Â &amp;&amp; b.Url == "https://www.linkedin.com/" &amp;&amp; b.Category == "Social 
Â Â Â Â Media"));
Â Â Â Â Assert.IsFalse(currentBookmarks.Exists(b =&gt; b.Name == "Audi 
Â Â Â Â Canada" &amp;&amp; b.Url == "https://audi.ca" &amp;&amp; b.Category == "See 
Â Â Â Â later"));
}</pre>			<p>The code for this test <a id="_idIndexMarker395"/>case is very similar to the code for test case #1, with two noticeable differences:</p>
			<ul>
				<li>We are calling the real implementation of <code>BookmarkService</code>, not a mock. The reason is that we want to ensure that the bookmarks have been imported correctly and that the conflicting one has been renamed accordingly. If that service was relying on a database, we could have mocked that database.</li>
				<li>The last assertion, although not necessary, ensures that the original, conflicting bookmark does not exist anymore since it has been updated.</li>
			</ul>
			<p>Now, if you have been coding along with me, you have certainly noticed that this code does not work. In fact, it does not even compile! Donâ€™t worry, this was intentional ğŸ˜Š. The intention is to teach you how to control visibility to test artifacts.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor178"/>Internals visibility</h2>
			<p>In the <code>ImportCommand</code> class, we added a second constructor (which takes a parameter of type <code>IFileSystem</code>) and an overload for the <code>OnImportCommand</code> handler <a id="_idIndexMarker396"/>method. These two methods have been marked as <code>internal</code>, which simply means that they are visible to all parts  of the code within the current project but arenâ€™t visible outside of that project unless we specify otherwise.</p>
			<p>This is the recommended approach when you add artifacts specifically for testing purposes.</p>
			<p>The <code>internal</code> accessor is very interesting. It allows us to control its visibility. In this case, we only want the test project to see these internal code artifacts.</p>
			<p>To do that, we will need to update the <code>bookmarkr.csproj</code> file (the one where these code artifacts marked as <code>internal</code> are located) to indicate that we only want the test project to be able to access them. We can achieve this by adding this entry:</p>
			<pre class="source-code">
&lt;ItemGroup&gt;
Â Â Â Â &lt;InternalsVisibleTo Include="bookmarkr.UnitTests" /&gt;
&lt;/ItemGroup&gt;</pre>			<p>This means that code artifacts that are marked as <code>internal</code> in the <code>bookmarkr</code> project can only be â€œseenâ€ by the <code>bookmarkr.UniTests</code> project.</p>
			<p>Now, you will notice that the code compiles and executes as expected.</p>
			<p>Looking back at the<a id="_idIndexMarker397"/> test methods of the <code>ImportCommandTests</code> class, you have certainly noticed that in both test methods, we instantiated and initialized <code>MockFileSystem</code> and the string representation of the JSON structure of the bookmarks in the same way. Hence, this code is redundant and, if it changes over time, we need to update this code in both places. This will get even worse as the number of test methods increases.</p>
			<p>Fortunately, MS Test provides a way to centralize this initialization. Letâ€™s see how this works.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor179"/>Centralizing test initialization</h2>
			<p>MS Test <a id="_idIndexMarker398"/>provides a <code>[TestInitialize]</code> attribute that can be used to decorate a method where any common instantiation, initialization, or configuration can be centralized.</p>
			<p>This method is then automatically invoked by the MS Test framework before calling every test method. This has another benefit: every test method gets fresh instances of the objects instantiated in the initialization method, preventing the execution of a test method to have an impact and an influence on the execution of the next test method.</p>
			<p>The code of the test initialization method looks like this:</p>
			<pre class="source-code">
public required IBookmarkService _bookmarkService;
public required MockFileSystem _mockFileSystem;
[TestInitialize]
public void TestInitialize()
{
Â Â Â Â string bookmarksAsJson = @"[
Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â ""Name"": ""Packt Publishing"",
Â Â Â Â Â Â Â Â Â Â Â ""Url"": ""https://packtpub.com/"",
Â Â Â Â Â Â Â Â Â Â Â ""Category"": ""Tech Books""
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â ""Name"": ""Audi cars"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Url"": ""https://audi.ca"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Category"": ""See later""
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â ""Name"": ""LinkedIn"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Url"": ""https://www.linkedin.com/"",
Â Â Â Â Â Â Â Â Â Â Â Â ""Category"": ""Social Media""
Â Â Â Â Â Â Â Â }
Â Â Â Â ]";
Â Â Â Â _mockFileSystem = new MockFileSystem(new Dictionary&lt;string, 
Â Â Â Â MockFileData&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â {@"bookmarks.json", new MockFileData(bookmarksAsJson)}
Â Â Â Â });
}</pre>			<p>Fantastic! Now we know <a id="_idIndexMarker399"/>everything we need to know to implement meaningful and efficient tests for our CLI application.</p>
			<p>But before closing this chapter, there is one last thing I want to discuss with you. I want to tell you how you can use these tests that you are implementing to identify and eliminate a bug.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor180"/>How to hunt a bug</h1>
			<p>Tests play a key role in hunting down a <a id="_idIndexMarker400"/>bug and ensuring it doesnâ€™t come up again. To do that, you should follow a process.</p>
			<p>Whenever a bug is discovered (by you or your team) or reported (by the user), you should write tests that reproduce it. These tests can be of different types. These are to ensure that the bug doesnâ€™t come up again.</p>
			<p>Now, run your tests and you should notice that tests are failing. Tests that cover wider ranges (such as system or integration tests) will tell you in what component of the application the bug is happening. Then, more granular tests (such as unit tests) will tell you in what class and ultimately in what method the bug is hiding.</p>
			<p>By using a smart combination of both wide-range and granular tests, you will be able to hunt down the bug. Keep in mind that breakpoints will be great allies.</p>
			<p>And thatâ€™s it! We are now armed with everything we need to enhance the quality of our application by leveraging software testing.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor181"/>Summary</h1>
			<p>In this chapter, we learned why testing is an important step in the process of developing any application, including CLI applications. I like to call tests your safety nets: they ensure not only that your new features behave as expected but also that you donâ€™t accidentally introduce bugs in existing functionalities (we call these <strong class="bold">regressions</strong>). I highly encourage you to write effective tests and run them often.</p>
			<p>We also explored the categories and roles of tests, and we learned techniques for testing applications and applied them to <strong class="bold">Bookmarkr</strong>, our CLI application.</p>
			<p>Our application now has the required functionalities, and we ensured, through testing, that these functionalities behave as expected. It is now time to deliver the application to its users!</p>
			<p>This is why, in the next chapter, we will explore different techniques that will allow us to package, distribute, and deploy our application.</p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor182"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn through practice.</p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to improve the Bookmarkr application by adding the following features.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor183"/>Task #1 â€“ Write the required unit tests for the remaining functionalities</h2>
			<p>In this chapter, we wrote tests only for the <code>link</code> and <code>import</code> commands. You are hence challenged to write tests for the other commands. You will have to figure out what test cases are to be considered and implement them.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor184"/>Task #2 â€“ Write integration tests for the sync command</h2>
			<p>The <code>sync</code> command deals with a database. For the purpose of unit testing, you can mock the database using NSubstitute. However, when implementing an integration test, you need a real database. You are then challenged to write integration tests for the <code>sync</code> command. You will have to provide a test database and use the appropriate connection string depending on whether the application is running in production or in testing mode.</p>
		</div>
	</body></html>