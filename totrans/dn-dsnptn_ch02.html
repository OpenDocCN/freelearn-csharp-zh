<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>2. Why We Need Design Patterns?</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="8afe24fba552.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;2.&#160;Why We Need Design Patterns?">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch02"></a>Chapter&#160;2.&#160;Why We Need Design Patterns?</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we will try to understand the necessity of choosing a pattern-based approach to software development. We start with some principles of software development, that one might find useful while undertaking large projects. The working example in this chapter starts with a requirements specification and progresses toward a preliminary implementation. We will then try to iteratively improve the solution using patterns and idioms, and come up with a good design that supports a well-defined programming Interface. During this process, we will learn about some software development principles that one can adhere to, including the following:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">SOLID principles for OOP</li>
            <li class="listitem" style="list-style-type: disc">Three key uses of design patterns</li>
            <li class="listitem" style="list-style-type: disc">Arlow/Nuestadt archetype patterns</li>
            <li class="listitem" style="list-style-type: disc">Entity, value, and data transfer objects</li>
            <li class="listitem" style="list-style-type: disc">Command pattern and factory method pattern</li>
            <li class="listitem" style="list-style-type: disc">Design by contract idiom and the template method pattern</li>
            <li class="listitem" style="list-style-type: disc">Facade pattern for API</li>
            <li class="listitem" style="list-style-type: disc">Leveraging the .NET Reflection API for plugin architecture</li>
            <li class="listitem" style="list-style-type: disc">XML processing using LINQ for parsing configuration files</li>
            <li class="listitem" style="list-style-type: disc">Deep cloning of CLR objects using extension methods</li>
            <li class="listitem" style="list-style-type: disc">Designing stateless classes for better scalability</li>
          </ul>
        </div>
        <div class="section" title="Some principles of software development">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title"><a id="ch02lvl1sec13"></a>Some principles of software development</h1>
              </div>
            </div>
          </div>
          <p>Writing quality production code consistently is not easy without some foundational principles under your belt. The purpose of this section is to whet the developer's appetite, and towards the end, some references are given for detailed study. Detailed coverage of these principles warrants a separate book on its own scale. The authors have tried to assimilate the following key principles of software development, which help one write quality code:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>KISS</strong></span>: Keep it simple, stupid</li>
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>DRY</strong></span>: Don't repeat yourself</li>
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>YAGNI</strong></span>:You aren't gonna need it</li>
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Low coupling</strong></span>: Minimize coupling between classes</li>
              <li class="listitem" style="list-style-type: disc"><span class="strong"><strong>SOLID principles</strong></span>: Principles for better OOP</li>
            </ul>
          </div>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note5"></a>Note</h3>
              <p>William of Ockham framed the maxim <span class="strong"><strong>Keep it simple, stupid</strong></span> (<span class="strong"><strong>KISS</strong></span>). It is also called the law of parsimony. In programming terms, it can be translated as "writing code in a straightforward manner, focusing on a particular solution that solves the problem at hand".</p>
            </div>
          </div>
          <p>This maxim is important because, most often, developers fall into the trap of writing code in a generic manner for unwarranted extensibility. Even though it initially looks attractive, things slowly go out of bounds. The accidental complexity introduced in the code base for catering to improbable scenarios, often reduces readability and maintainability. The KISS principle can be applied to every human endeavor. Learn more about the KISS principle by consulting the Web.</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note6"></a>Note</h3>
              <p>
<span class="strong"><strong>Don't repeat yourself</strong></span> (<span class="strong"><strong>DRY</strong></span>), a maxim that is often forgotten by programmers while implementing their domain logic. Most often, in a collaborative development scenario, code gets duplicated inadvertently due to a lack of communication and proper design specifications.</p>
            </div>
          </div>
          <p>This bloats the code base, induces subtle bugs, and makes things really difficult to change. By following the DRY maxim at all stages of development, we can avoid additional effort and make the code consistent. The opposite of DRY is <span class="strong"><strong>write everything twice</strong></span> (<span class="strong"><strong>WET</strong></span>).</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note7"></a>Note</h3>
              <p>
<span class="strong"><strong>You aren't gonna need it</strong></span> (<span class="strong"><strong>YAGNI</strong></span>), a principle that complements the KISS axiom. It serves as a warning for people who try to write code in the most general manner, anticipating changes right from the word go.</p>
            </div>
          </div>
          <p>Too often, in practice, most of the code which are written in a generic manner, might result in code smells.</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note8"></a>Note</h3>
              <p>While writing code, one should try to make sure that there are no hard-coded references to concrete classes. It is advisable to program to an interface as opposed to an implementation.</p>
            </div>
          </div>
          <p>This is a key principle which many patterns use to provide behavior acquisition at runtime. A dependency injection framework could be used to reduce coupling between classes.</p>
          <p>SOLID principles are a set of guidelines for writing better object-oriented software. It is a mnemonic acronym that embodies the following five principles:</p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col/>
                <col/>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td>
<p>
<span class="strong"><strong>Sr. no</strong></span>
</p>
</td>
                  <td>
<p>
<span class="strong"><strong>Principles</strong></span>
</p>
</td>
                  <td>
<p>
<span class="strong"><strong>Description</strong></span>
</p>
</td>
                </tr>
                <tr>
                  <td>
<p>1</p>
</td>
                  <td>
<p>
<span class="strong"><strong>Single Responsibility Principle</strong></span> (<span class="strong"><strong>SRP</strong></span>)</p>
</td>
                  <td>
<p>A class should have only one responsibility. If it is doing more than one unrelated thing, we need to split the class.</p>
</td>
                </tr>
                <tr>
                  <td>
<p>2</p>
</td>
                  <td>
<p>
<span class="strong"><strong>Open Close Principle</strong></span> (<span class="strong"><strong>OCP</strong></span>)</p>
</td>
                  <td>
<p>A class should be open for extension, closed for modification.</p>
</td>
                </tr>
                <tr>
                  <td>
<p>3</p>
</td>
                  <td>
<p>
<span class="strong"><strong>Liskov Substitution Principle</strong></span> (<span class="strong"><strong>LSP</strong></span>)</p>
</td>
                  <td>
<p>Named after Barbara Liskov, a Turing Award laureate, who postulated that a sub-class (derived class) could substitute any super class (base class) references without affecting the functionality. Even though it looks like stating the obvious, most implementations have quirks that violate this principle.</p>
</td>
                </tr>
                <tr>
                  <td>
<p>4</p>
</td>
                  <td>
<p>
<span class="strong"><strong>Interface Segregation Principle</strong></span> (<span class="strong"><strong>ISP</strong></span>)</p>
</td>
                  <td>
<p>It is more desirable to have multiple interfaces for a class (such classes can also be called components) than having one Uber interface that forces implementation of all methods (both relevant and non-relevant to the solution context).</p>
</td>
                </tr>
                <tr>
                  <td>
<p>5</p>
</td>
                  <td>
<p>
<span class="strong"><strong>Dependency Inversion</strong></span> (<span class="strong"><strong>DI</strong></span>)</p>
</td>
                  <td>
<p>This is a principle which is very useful for framework design. In the case of frameworks, the client code will be invoked by server code, as opposed to the usual process of the client invoking the server. The main principle here is that abstraction should not depend upon details; rather, details should depend upon abstraction. This is also called the <span class="strong"><strong>Hollywood</strong></span> principle (Do not call us, we will call you back).</p>
</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>The authors consider the preceding five principles primarily as a verification mechanism. This will be demonstrated by verifying the ensuing case study implementations for violation of these principles.</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note9"></a>Note</h3>
              <p>Karl Seguin has written an e-book titled <span class="emphasis"><em>Foundations of Programming - Building Better Software</em></span>, which covers most of what has been outlined here. Read his book to gain an in-depth understanding of most of these topics. The SOLID principles are well covered in the Wikipedia page on the subject, which can be retrieved from <a class="ulink" href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design">https://en.wikipedia.org/wiki/SOLID_(object-oriented_design</a>. Robert Martin's <span class="emphasis"><em>Agile Principles, Patterns, and Practices in C#</em></span> is a definitive book on learning about SOLID, as Robert Martin himself is the creator of these principles, even though Michael Feathers coined the acronym.</p>
            </div>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Why are patterns required?">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch02lvl1sec14"></a>Why are patterns required?</h1>
            </div>
          </div>
        </div>
        <p>According to the authors, the three key advantages of pattern-oriented software development that stand out are as follows:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">A language/platform-agnostic way to communicate about software artifacts</li>
            <li class="listitem" style="list-style-type: disc">A tool for refactoring initiatives (targets for refactoring)</li>
            <li class="listitem" style="list-style-type: disc">Better API design</li>
          </ul>
        </div>
        <p>With the advent of the pattern movement, the software development community got a canonical language to communicate about software design, architecture, and implementation. Software development is a craft that has got trade-offs attached to each strategy, and there are multiple ways to develop software. The various pattern catalogs brought some conceptual unification for this <span class="strong"><strong>cacophony</strong></span> in software development.</p>
        <p>Most developers around the world today who are worth their salt can understand and speak this language. We believe you will be able to do the same by the end of the chapter. Imagine yourself stating the following about your recent implementation:</p>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="tip10"></a>Tip</h3>
            <p>For our tax computation example, we have used the command pattern to handle the computation logic. The commands (handlers) are configured using an XML file, and a factory method takes care of the instantiation of classes on the fly using Lazy loading. We cache the commands, and avoid instantiation of more objects by imposing singleton constraints on the invocation. We support the prototype pattern where command objects can be cloned. The command objects have a base implementation, where concrete command objects use the template method pattern to override methods that are necessary. The command objects are implemented using the design by contracts idiom. The whole mechanism is encapsulated using a Facade class, which acts as an API layer for the application logic. The application logic uses entity objects (reference) to store the taxable entities, attributes such as tax parameters are stored as value objects. We use <span class="strong"><strong>data transfer object</strong></span> (<span class="strong"><strong>DTO</strong></span>) to transfer the data from the application layer to the computational layer. The Arlow/Nuestadt-based archetype pattern is the unit of structuring the tax computation logic.</p>
          </div>
        </div>
        <p>For some developers, the preceding language/platform-independent description of the software being developed is enough to understand the approach taken. This will boost developer productivity (during all phases of SDLC, including development, maintenance, and support) as the developers will be able to get a good mental model of the code base. Without Pattern catalogs, such succinct descriptions of the design or implementation would have been impossible.</p>
        <p>In an Agile software development scenario, we develop software in an iterative fashion. Once we reach a certain maturity in a module, developers refactor their code. While refactoring a module, patterns do help in organizing the logic. The case study given next will help you to understand the rationale behind <span class="emphasis"><em>patterns as refactoring targets</em></span>.</p>
        <p>APIs based on well-defined patterns are easy to use and impose less cognitive load on programmers. The success of the ASP.NET MVC framework, NHibernate, and APIs for writing HTTP modules and handlers in the ASP.NET pipeline are a few testimonies to the process. You will see how these three key advantages are put into practice in the ensuing chapters and case studies.
</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="A quick foray into the .NET Reflection API">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch02lvl1sec15"></a>A quick foray into the .NET Reflection API</h1>
            </div>
          </div>
        </div>
        <p>When we write non-trivial software that should go to production, it is mandatory to have the ability to load and execute modules on the fly. This is useful when you are planning to provide user defined extensions as a mechanism to add new features to the existing software. The .NET Reflection API is a nifty mechanism supported by the Microsoft Corporation to help developers to write code that can be loaded dynamically, after the base software has been written. The platform technologies, such as ASP.net, WCF,EF, and WPF, use reflection extensively:</p>
        <pre class="programlisting">     public class Test 
     { 
       //---- Only Property this class has  
       public int X { get; set; } 
       //----- This method will be invoked dynamically 
       public void Spit() 
       { 
         Console.WriteLine(" X is " + X); 
       } 
     } 
</pre>
        <p>We will write a simple program that will instantiate the object using the&#160;<code class="literal">new</code> keyword, and after the object instantiation, a property (<code class="literal">X</code>) will be set to the value <code class="literal">0xBEEF</code>. The .NET Reflection API will be used to retrieve the property value and invoke a method (<code class="literal">Spit</code>) using them:</p>
        <pre class="programlisting">    class Program 
    { 
      static void Main(string[] args) 
    { 
      Test a = new Test(); 
      //------ Set the property 
      a.X = 0xBEEF; 
      //------ Retrieve the CLR Type 
      Type t = a.GetType(); 
      if (t == null)  return; 
      //---- Retrieve the Property Handle 
      PropertyInfo np = t.GetProperty("X"); 
      //---- Retrieve the Property  Value 
      Console.WriteLine(np.GetValue(a)); 
      //------ Retrieve the Method Handle 
      MethodInfo mi = t.GetMethod("Spit"); 
      //------ Invoke the method 
      mi.Invoke(a, null); 
 
      Console.Read(); 
    } 
  } 
</pre>
        <p>We will be using .NET Reflection API extensively in our programs. A competent programmer should know the .NET Reflection API and its features to write any advanced piece of code. Do consult the Microsoft documentation to understand the features available and the nuances of the API. If you want to be a library or framework designer, you should know Reflection API in depth.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Personal income tax computation - A case study">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch02lvl1sec16"></a>Personal income tax computation - A case study</h1>
            </div>
          </div>
        </div>
        <p>Rather than explaining the advantages of patterns, the following example will help us to see things in action. Computation of annual income tax is a well-known problem domain across the globe. We have chosen an application domain that is well known for focusing&#160;on software development issues.</p>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note11"></a>Note</h3>
            <p>The application should receive inputs regarding the demographic profile (UID, Name, Age, Sex, Location) of a citizen and the income details (Basic, DA, HRA, CESS, Deductions) to compute their tax liability. The system should have discriminants based on the demographic profile, and have a separate logic for senior citizens, juveniles, disabled people, female senior citizens, and others. By discriminant we mean that demographic parameters such as age, sex, and location should determine the category to which a person belongs and therefore apply category-specific computation for that individual. As a first iteration, we will implement logic for the senior citizen and ordinary citizen categories.</p>
          </div>
        </div>
        <p>After preliminary discussions, our developer created a prototype screen, as shown in the following image:</p>
        <p>
</p>
        <div class="mediaobject">
          <img src="graphics/B05691_02_01.jpg" alt="Personal income tax computation - A case study"/>
        </div>
        <p>
</p>
        <div class="section" title="Archetypes and business archetype patterns">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch02lvl2sec6"></a>Archetypes and business archetype patterns</h2>
              </div>
            </div>
          </div>
          <p>The legendary Swiss psychologist, Carl Gustav Jung, created the concept of archetypes to explain fundamental entities that arise from a common repository of human experiences. The concept of archetypes percolated to the software industry from psychology. The Arlow/Nuestadt patterns describe business archetype patterns such as Party, Customer Call, Product, Money, Unit, Inventory, and so on. An example is the Apache Maven archetype, which helps us to generate projects of different natures, such as J2EE apps, Eclipse plugins, OSGI projects, and so on. The Microsoft patterns and practices describe archetypes for targeting builds such as web applications, rich client applications, mobile applications, and services applications. Various domain-specific archetypes can exist in respective contexts as organizing and structuring mechanisms.</p>
          <p>In our case, we will define some archetypes that are common in the taxation domain. Some of the key archetypes in this domain are as follows:</p>
          <div class="informaltable">
            <table border="1">
              <colgroup>
                <col/>
                <col/>
                <col/>
              </colgroup>
              <tbody>
                <tr>
                  <td>
<p>
<span class="strong"><strong>Sr.no</strong></span>
</p>
</td>
                  <td>
<p>
<span class="strong"><strong>Archetype</strong></span>
</p>
</td>
                  <td>
<p>
<span class="strong"><strong>Description</strong></span>
</p>
</td>
                </tr>
                <tr>
                  <td>
<p>1</p>
</td>
                  <td>
<p>SeniorCitizenFemale</p>
</td>
                  <td>
<p>Tax payers who are female, and above the age of 60 years.</p>
</td>
                </tr>
                <tr>
                  <td>
<p>2</p>
</td>
                  <td>
<p>SeniorCitizen</p>
</td>
                  <td>
<p>Tax payers who are male, and above the age of 60 years.</p>
</td>
                </tr>
                <tr>
                  <td>
<p>3</p>
</td>
                  <td>
<p>OrdinaryCitizen</p>
</td>
                  <td>
<p>Tax payers who are male/female, and above 18 years of age.</p>
</td>
                </tr>
                <tr>
                  <td>
<p>4</p>
</td>
                  <td>
<p>DisabledCitizen</p>
</td>
                  <td>
<p>Tax payers who have any disability.</p>
</td>
                </tr>
                <tr>
                  <td>
<p>5</p>
</td>
                  <td>
<p>MilitaryPersonnel</p>
</td>
                  <td>
<p>Tax payers who are military personnel.</p>
</td>
                </tr>
                <tr>
                  <td>
<p>6</p>
</td>
                  <td>
<p>Juveniles</p>
</td>
                  <td>
<p>Tax payers whose age is less than 18 years.</p>
</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>We will use demographic parameters as discriminants to find the archetype that corresponds to the entity. The whole idea of inducing archetypes is to organize the tax computation logic around them. Once we are able to resolve the archetypes, it is easy to locate and delegate the computations corresponding to the archetypes.</p>
        </div>
        <div class="section" title="Entity, value, and data transfer objects">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch02lvl2sec7"></a>Entity, value, and data transfer objects</h2>
              </div>
            </div>
          </div>
          <p>We are going to create a class that represents a citizen. Since a citizen needs to be uniquely identified, we are going to create an entity object, which is also called a reference object (from the DDD catalog). The <span class="strong"><strong>universal identifier</strong></span> (<span class="strong"><strong>UID</strong></span>) of an entity object is the handle to which an application refers. Entity objects are not identified by their attributes, as there can be two people with the same name. The ID uniquely identifies an entity object. The definition of an entity object is given as follows:</p>
          <pre class="programlisting">    public class TaxableEntity 
    { 
      public int Id { get; set; } 
      public string Name { get; set; } 
      public int Age { get; set; } 
      public char Sex { get; set; } 
      public string Location { get; set; } 
      public TaxParamVO taxparams { get; set; } 
    } 
</pre>
          <p>In the preceding class definition, <code class="literal">Id</code> uniquely identifies the entity object. TaxParams is a value object (from the DDD catalog) associated with the entity object. Value objects do not have a conceptual identity. They describe some attributes of things (entities). The definition of TaxParams is given as follows:</p>
          <pre class="programlisting">    public class TaxParamVO 
    { 
      public double Basic {get;set;} 
      public double DA { get; set; } 
      public double HRA { get; set; } 
      public double Allowance { get; set; } 
      public double Deductions { get; set; } 
      public double Cess { get; set; } 
      public double TaxLiability { get; set; } 
      public bool Computed { get; set; } 
    } 
</pre>
          <p>While writing applications ever since Smalltalk, <span class="strong"><strong>Model-view-controller</strong></span> (<span class="strong"><strong>MVC</strong></span>) is the most dominant paradigm for structuring applications. The application is split into a model layer (which mostly deals with data), a view layer (which acts as a display layer), and a controller (to mediate between the two). In the web development scenario, they are physically partitioned across machines. To transfer data between layers, the J2EE pattern catalog identified the DTO. The DTO object is defined as follows:</p>
          <pre class="programlisting">    public class TaxDTO 
    { 
      public int id { } 
      public TaxParamVO taxparams { } 
    } 
</pre>
          <p>If the layering exists within the same process, we can transfer these objects as-is. If layers are partitioned across processes or systems, we can use XML or JSON serialization to transfer objects between the layers.</p>
        </div>
        <div class="section" title="A computation engine">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch02lvl2sec8"></a>A computation engine</h2>
              </div>
            </div>
          </div>
          <p>We need to separate UI processing, input validation, and computation to create a solution that can be extended to handle additional requirements. The computation engine will execute different logic depending upon the command received. The GoF command pattern is leveraged for executing the logic based on the command received.</p>
          <p>The command pattern consists of four constituents. They are as follows:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">Command object</li>
              <li class="listitem" style="list-style-type: disc">Parameters</li>
              <li class="listitem" style="list-style-type: disc">Command Dispatcher</li>
              <li class="listitem" style="list-style-type: disc">Client</li>
            </ul>
          </div>
          <p>The command object's interface has an <code class="literal">Execute</code> method. The parameters to the command objects are passed through a bag. The client invokes the command object by passing the parameters through a bag to be consumed by the Command Dispatcher. The parameters are passed to the command object through the following data structure:</p>
          <pre class="programlisting">    public class COMPUTATION_CONTEXT 
    { 
      private Dictionary&lt;String, Object&gt; symbols = new 
      Dictionary&lt;String, Object&gt;(); 
      public void Put(string k, Object value) { 
        symbols.Add(k, value); 
      } 
      public Object Get(string k) { return symbols[k]; } 
    } 
</pre>
          <p>The <code class="literal">ComputationCommand</code> interface, which all the command objects implement, has only one <code class="literal">Execute</code> method, which is shown next. The <code class="literal">Execute</code> method takes a bag as a parameter. The <code class="literal">COMPUTATION_CONTEXT</code> data structure acts as the bag here:</p>
          <pre class="programlisting">    Interface ComputationCommand 
    { 
      bool Execute(COMPUTATION_CONTEXT ctx); 
    } 
</pre>
          <p>Since we have already implemented a command interface and bag to transfer the parameters, it is time that we implemented a command object. For the sake of simplicity, we will implement two commands where we hardcode the tax liability:</p>
          <pre class="programlisting">    public class SeniorCitizenCommand : ComputationCommand 
    { 
      public bool Execute(COMPUTATION_CONTEXT ctx) 
      { 
        TaxDTO td = (TaxDTO)ctx.Get("tax_cargo"); 
        //---- Instead of computation, we are assigning 
        //---- constant tax for each archetypes 
        td.taxparams.TaxLiability = 1000; 
        td.taxparams.Computed = true; 
        return true; 
      } 
    } 
 
    public class OrdinaryCitizenCommand : ComputationCommand 
    { 
      public bool Execute(COMPUTATION_CONTEXT ctx) 
      { 
        TaxDTO td = (TaxDTO)ctx.Get("tax_cargo"); 
        //---- Instead of computation, we are assigning 
        //---- constant tax for each archetypes 
        td.taxparams.TaxLiability = 1500; 
        td.taxparams.Computed = true; 
        return true; 
      } 
    } 
</pre>
          <p>The commands will be invoked by a <code class="literal">CommandDispatcher</code>&#160;object, which takes an <code class="literal">archetype</code> string and a <code class="literal">COMPUTATION_CONTEXT</code> object. The <code class="literal">CommandDispatcher</code> acts as an API layer for the application:</p>
          <pre class="programlisting">    class CommandDispatcher 
    { 
      public static bool Dispatch(string archetype,      
      COMPUTATION_CONTEXT ctx) 
      { 
        if (archetype == "SeniorCitizen") 
        { 
          SeniorCitizenCommand cmd = new SeniorCitizenCommand(); 
          return cmd.Execute(ctx); 
        } 
        else if (archetype == "OrdinaryCitizen") 
        { 
          OrdinaryCitizenCommand cmd = new OrdinaryCitizenCommand(); 
          return cmd.Execute(ctx); 
        } 
        else {  
          return false; 
        } 
      } 
    } 
</pre>
        </div>
        <div class="section" title="The application to engine communication">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch02lvl2sec9"></a>The application to engine communication</h2>
              </div>
            </div>
          </div>
          <p>The data from the application UI, be it web or desktop, has to flow to the computation engine. The following <code class="literal">ViewHandler</code> routine shows how data, retrieved from the application UI, is passed to the engine, via the Command Dispatcher, by a client:</p>
          <pre class="programlisting">    public static void ViewHandler(TaxCalcForm tf) 
    { 
      TaxableEntity te = GetEntityFromUI(tf); 
      if (te == null){ 
        ShowError(); 
        return; 
      } 
      string archetype = ComputeArchetype(te); 
      COMPUTATION_CONTEXT ctx = new COMPUTATION_CONTEXT(); 
      TaxDTO td = new TaxDTO { id = te.id, taxparams =    
      te.taxparams}; 
      ctx.Put("tax_cargo",td); 
      bool rs = CommandDispatcher.Dispatch(archetype, ctx); 
      if ( rs ) { 
        TaxDTO temp = (TaxDTO)ctx.Get("tax_cargo"); 
        tf.Liabilitytxt.Text =        
        Convert.ToString(temp.taxparams.TaxLiability); 
        tf.Refresh(); 
      } 
    } 
</pre>
          <p>At this point, imagine that a change in requirements has been received from the stakeholders. Now we need to support tax computation for new categories.</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note12"></a>Note</h3>
              <p>Initially, we had different computations for senior citizens and ordinary citizens. Now we need to add new archetypes. At the same time, to make the software extensible (loosely coupled) and maintainable, it would be ideal if we provided the capability to support the new archetypes in a configurable manner, as opposed to recompiling the application for every new archetype owing to concrete references.</p>
            </div>
          </div>
          <p>The Command Dispatcher object does not scale well to handle additional archetypes. We need to change the assembly whenever a new archetype is included, as the tax computation logic varies for each archetype. We need to create a pluggable architecture to add or remove archetypes at will.</p>
        </div>
        <div class="section" title="The plugin system to make system extensible">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch02lvl2sec10"></a>The plugin system to make system extensible</h2>
              </div>
            </div>
          </div>
          <p>Writing system logic without impacting the application warrants a mechanism--that of loading a class on the fly. Luckily, the .NET Reflection API provides a mechanism for one to load a class during runtime, and invoke methods within it. A developer worth his salt should learn the Reflection API to write systems that change dynamically. In fact, most of the technologies such as ASP.NET, Entity Framework, .NET Remoting, and WCF work because of the availability of Reflection API in the .NET stack.</p>
          <p>Henceforth, we will be using an XML configuration file to specify our tax computation logic. A sample XML file is given next:</p>
          <pre class="programlisting">    &lt;?xml version="1.0"?&gt; 
    &lt;plugins&gt; 
      &lt;plugin archetype ="OrindaryCitizen"     
      command="TaxEngine.OrdinaryCitizenCommand"/&gt;  &lt;plugin   
      archetype="SeniorCitizen"    
      command="TaxEngine.SeniorCitizenCommand"/&gt; 
    &lt;/plugins&gt; 
</pre>
          <p>The contents of the XML file can be read very easily using LINQ to XML. We will be generating a <code class="literal">Dictionary</code> object with the following code snippet:</p>
          <pre class="programlisting">    private Dictionary&lt;string,string&gt; LoadData(string xmlfile) 
    { 
       return XDocument.Load(xmlfile) 
      .Descendants("plugins") 
      .Descendants("plugin") 
      .ToDictionary(p =&gt; p.Attribute("archetype").Value, 
      p =&gt; p.Attribute("command").Value); 
    } 
</pre>
        </div>
        <div class="section" title="Factory method pattern and plugins">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch02lvl2sec11"></a>Factory method pattern and plugins</h2>
              </div>
            </div>
          </div>
          <p>The factory method (from the GoF catalog) is a pattern that solves the creation of objects through a static method exposed solely for this purpose. The object we create will be based on a particular class or derived class. In our case, we need to create objects that have implemented the <code class="literal">ComputationCommand</code> interface.</p>
          <p>The consumer of the <code class="literal">Factory</code> class can also indicate whether it requires a singleton or a prototype. The default behavior of the factory method is singleton, and it is supposed to return the same instance whenever a call to the <code class="literal">Factory</code> (<code class="literal">Get</code>) method is received. If the prototype option is given, a clone of the object will be created and returned:</p>
          <pre class="programlisting">    public class ObjectFactory 
    { 
      //--- A Dictionary to store  
      //--- Plugin details (Archetype/commandclass) 
      private Dictionary&lt;string, string&gt; plugins = new   
      Dictionary&lt;string, string&gt;(); 
      //--- A Dictionary to cache objects 
      //--- archetype/commandclassinstance 
      private Dictionary&lt;string, ComputationCommand&gt; commands = 
      new Dictionary&lt;string, ComputationCommand&gt;(); 
 
      public ObjectFactory(String xmlfile) 
      { 
        plugins = LoadData(xmlfile); 
      } 
 
      private Dictionary&lt;string,string&gt; LoadData(string xmlfile) 
      { 
        return XDocument.Load(xmlfile) 
        .Descendants("plugins") 
        .Descendants("plugin") 
        .ToDictionary(p =&gt; p.Attribute("archetype").Value, 
        p =&gt; p.Attribute("command").Value); 
      } 
      //---- Rest of the code omitted 
    } 
</pre>
          <p>The consumer of the <code class="literal">ObjectFactory</code> class will indicate whether it wants a reference to the object to be available in the plugin cache or a clone of the object. We can clone an object using binary serialization. By writing an extension method leveraging generics, we can write an all-purpose clone routine. The following code snippet will help us to achieve that:</p>
          <pre class="programlisting">    public static T DeepClone&lt;T&gt;(this T a) { 
      using (MemoryStream stream = new MemoryStream()) { 
      BinaryFormatter formatter = new BinaryFormatter(); 
      formatter.Serialize(stream, a); 
      stream.Position = 0; 
      return (T)formatter.Deserialize(stream); 
      } 
    } 
</pre>
          <p>Now the implementation of <code class="literal">Get</code> becomes a straightforward affair; the full listing of the <code class="literal">Get</code> method is given as follows:</p>
          <pre class="programlisting">    public ComputationCommand Get(string archetype,  
    string mode = "singleton") 
    { 
      //---- We can create a new instance, when a  
      //---- prototype is asked, otherwise we will 
      //---- return the same instance stored in the dictionary 
      if (mode != "singleton" &amp;&amp; mode != "prototype") 
      return null; 
 
      ComputationCommand temp = null; 
      //--- if an instance is already found, return 
      // it (singleton) or clone (prototype 
      if (commands.TryGetValue(archetype, out temp)) 
      { 
        return (mode == "singleton") ? temp : 
        temp.DeepClone&lt;ComputationCommand&gt;(); 
      } 
 
      //---- retrieve the commandclass name 
      string classname = plugins[archetype]; 
      if (classname == null) 
      return null; 
      //------ retrieve the classname, if it 
      //------ is available with CLR 
      Type t = Type.GetType(classname); 
 
      if (t == null) 
      return null; 
      //---- Create a new Instance and store it 
      //---- in commandclass instance dictionary 
      commands[archetype]=       
      (ComputationCommand)Activator.CreateInstance(t); 
      return commands[archetype]; 
    } 
</pre>
          <p>Now that we have got a factory method implementation, let us see how one can consume the code. The Command Dispatcher will get a handle to the instance of a command based on the archetype provided to it. Once the handle to the object is received, the <code class="literal">Execute</code> method can be invoked:</p>
          <pre class="programlisting">    public class CommandDispatcher 
    { 
      private static ObjectFactory obj =  
      new  ObjectFactory("Pluggins.xml"); 
 
      public static bool Dispatch(string archetype,  
      COMPUTATION_CONTEXT ctx) 
      { 
        ComputationCommand cmd = obj.Get(archetype); 
        return (cmd == null) ? false : cmd.Execute(ctx);  
      } 
    } 
</pre>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note13"></a>Note</h3>
              <p>The authors of the book feel that command objects should be designed in a stateless manner. In the imperative programming world, this means that there shouldn't be any shared variables between the methods of a class. We should not add class-level variables in order to avoid locks in a multithreaded environment. In effect, parameters become the sole determinant of the results. If you cannot avoid having class-level variables, they should be immutable (read only). If we mutate the state of an object, the prototype created out of that will have an impact because of object references. The Java servlet specification expects the servlets to be stateless, and Spring controllers are also stateless. The Microsoft ASP.NET MVC controllers need not be stateless (not sure why Microsoft chose things that way).</p>
            </div>
          </div>
          <p>Now, let us revisit our <code class="literal">ViewHandler</code> routine. The interface does not change here. The real magic happens beneath the Command Dispatcher object:</p>
          <pre class="programlisting">    public static void ViewHandler(TaxCalcForm tf) 
    { 
      TaxableEntity te = GetEntityFromUI(tf); 
      if (te == null) 
      { 
        ShowError(); 
        return; 
      } 
      string archetype = ComputeArchetype(te); 
      COMPUTATION_CONTEXT ctx = new COMPUTATION_CONTEXT(); 
      TaxDTO td = new TaxDTO { id = te.id, taxparams = te.taxparams}; 
      ctx.Put("tax_cargo",td); 
      bool rs = CommandDispatcher.Dispatch(archetype, ctx); 
      if ( rs ) { 
        TaxDTO temp = (TaxDTO)ctx.Get("tax_cargo"); 
        tf.Liabilitytxt.Text =          
        Convert.ToString(temp.taxparams.TaxLiability); 
        tf.Refresh(); 
      } 
    } 
</pre>
          <p>The view handler routine does the following:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">Retrieves the value from the UI elements to create entity</li>
              <li class="listitem" style="list-style-type: disc">Determines the archetype based on demographic parameters</li>
              <li class="listitem" style="list-style-type: disc">Creates a DTO and places it in a bag</li>
              <li class="listitem" style="list-style-type: disc">Dispatches the method through <code class="literal">CommandDispatcher</code></li>
              <li class="listitem" style="list-style-type: disc">Updates the UI based on the status</li>
            </ul>
          </div>
          <p>Let's create a new command that will compute taxes for senior citizens who are female:</p>
          <pre class="programlisting">    public class SeniorCitizenFemaleCommand : ComputationCommand 
    { 
      public bool Execute(COMPUTATION_CONTEXT ctx) 
      { 
        TaxDTO td = (TaxDTO)ctx.Get("tax_cargo"); 
        //---- Compute the Tax for Senior Females 
        //---- They belong to different Slabs 
        double accum = td.taxparams.Basic + 
        td.taxparams.DA + td.taxparams.Allowance + 
        td.taxparams.HRA; 
        double net = accum - td.taxparams.Deductions - 
        td.taxparams.Surcharge; 
        //---- Flat 10% Tax 
        td.taxparams.TaxLiability = net*0.1; 
        td.taxparams.Computed = true; 
        return true; 
      } 
    } 
</pre>
          <p>We have to make some changes to the configuration file. The resulting XML configuration is given as follows:</p>
          <pre class="programlisting">    &lt;?xml version="1.0"?&gt; 
    &lt;plugins&gt; 
      &lt;plugin archetype ="OrindaryCitizen"       
      command="TaxEngine.OrdinaryCitizenCommand"/&gt;  &lt;plugin    
      archetype="SeniorCitizen"      
      command="TaxEngine.SeniorCitizenCommand"/&gt;  &lt;plugin  
      archetype="SeniorCitizenFemale"      
      command="TaxEngine.SeniorCitizenFemaleCommand"/&gt; 
    &lt;/plugins&gt; 
</pre>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Finalizing the solution">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch02lvl1sec17"></a>Finalizing the solution</h1>
            </div>
          </div>
        </div>
        <p>We started with a solution that solved the problem at hand. After creating a basic pipeline, we created an elaborate pipeline, which made the solution extensible. Now we can add new commands without recompiling the application. This is very important in the case of applications that are governed by amendable laws. To make our code robust, we will add the design by contract strategy to our command objects.</p>
        <div class="section" title="Design by contract and template method pattern">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch02lvl2sec12"></a>Design by contract and template method pattern</h2>
              </div>
            </div>
          </div>
          <p>The design by contract idiom, created by Bertrand Meyer (creator of the Eiffel language), extends the ordinary definition of abstract data types with preconditions, post conditions, and invariants. To execute any contract in real life, we need to satisfy some preconditions, followed by execution, and a post execution (verification) phase as listed here:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">Pre-Execute</li>
              <li class="listitem" style="list-style-type: disc">Execute</li>
              <li class="listitem" style="list-style-type: disc">Post-Execute</li>
            </ul>
          </div>
          <p>At the end of the Post-Execute phase, the invariants are checked to see whether they are violated. The consumer will call <code class="literal">PreExecute</code> to determine whether there is a context for the execution of the contract. The invocation will proceed only if <code class="literal">PreExecute</code> returns true. To incorporate design by contract, we extend the interface with two additional methods. The resultant <code class="literal">interface</code> is given as follows:</p>
          <pre class="programlisting">    public interface ComputationCommand 
    { 
      bool PreExecute(COMPUTATION_CONTEXT ctx); 
      bool Execute(COMPUTATION_CONTEXT ctx); 
      bool PostExecute(COMPUTATION_CONTEXT ctx); 
    } 
</pre>
          <p>We will create a <code class="literal">BaseComputationCommand</code> class, which will stub the methods in the <code class="literal">ComputationCommand</code> interface. This will help the concrete, derived command classes to override only those methods which have the respective changes. After redefining the interface, we will create a default implementation of the command pattern with methods marked as <code class="literal">virtual</code>. This helps us to override the implementation in the derived class. This is an instance of the template method pattern:</p>
          <pre class="programlisting">    public class BaseComputationCommand : ComputationCommand 
    { 
      public virtual bool PreExecute(COMPUTATION_CONTEXT ctx) { return      
      true;  }  public virtual bool Execute(COMPUTATION_CONTEXT ctx) {  
      return true; } public virtual bool  
      PostExecute(COMPUTATION_CONTEXT ctx) { return true; } 
    } 
</pre>
          <p>Our commands here will use the template method pattern to override only those methods that are relevant. Otherwise, there is already a fallback in the <code class="literal">BaseComputationCommand</code>. The template method pattern defines the program skeleton of an algorithm(s) in a method, and they are called template method(s). These template methods are overridden by sub-classes, which implement the concrete logic:</p>
          <pre class="programlisting">    public class SeniorCitizenCommand : BaseComputationCommand { 
      public override bool PreExecute(COMPUTATION_CONTEXT ctx) 
      { 
        TaxDTO td = (TaxDTO)ctx.Get("tax_cargo"); 
        //--- Do Some Sanity Checks 
        //--- if some problems =&gt; return false; 
        return base.PreExecute(ctx); 
      } 
      public override bool Execute(COMPUTATION_CONTEXT ctx) 
      { 
        TaxDTO td = (TaxDTO)ctx.Get("tax_cargo"); 
        //---- Compute the Tax for Senior Citizens 
        //---- They belong to different Slabs 
        td.taxparams.TaxLiability = 1000; 
        td.taxparams.Computed = true; 
        return true; 
      } 
 
      public override bool PostExecute(COMPUTATION_CONTEXT ctx) 
      { 
        //--- Do the Check on Invariants 
        //--- Return false, if there is violation 
        return base.PostExecute(ctx); 
      } 
    } 
</pre>
          <p>We need not override every method, and yet, the whole scheme would still work:</p>
          <pre class="programlisting">    public class SeniorCitizenFemaleCommand : BaseComputationCommand 
    { 
      public override bool Execute(COMPUTATION_CONTEXT ctx) 
      { 
        TaxDTO td = (TaxDTO)ctx.Get("tax_cargo"); 
        //---- Compute the Tax for Senior Females 
        //---- They belong to different Slabs 
        double accum = td.taxparams.Basic + 
        td.taxparams.DA + td.taxparams.Allowance + 
        td.taxparams.HRA; 
        double net = accum - td.taxparams.Deductions - 
        td.taxparams.Surcharge; 
        //---- Flat 10% Tax 
        td.taxparams.TaxLiability = net*0.1; 
        return true; 
      } 
    } 
</pre>
          <p>Now we need to rewrite the command pattern to reflect the implementation of the design by contract idiom in the command classes:</p>
          <pre class="programlisting">    public class CommandDispatcher 
    { 
      private static ObjectFactory obj = new      
      ObjectFactory("Pluggins.xml");  public static bool  
      Dispatch(string archetype,    COMPUTATION_CONTEXT ctx) 
      { 
        ComputationCommand cmd = obj.Get(archetype); 
        if (cmd == null)  
        return false; 
 
        if (cmd.PreExecute(ctx)) 
        { 
          bool rs = cmd.Execute(ctx); 
          cmd.PostExecute(ctx); 
          return rs; 
        } 
        return false; 
      } 
    } 
</pre>
          <p>In some implementations, the clients will check the return value to see whether invariants have been violated. In some cases, a compensating transaction will be executed to restore the state to the previous one.</p>
        </div>
        <div class="section" title="Using the Facade pattern to expose the computation API">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch02lvl2sec13"></a>Using the Facade pattern to expose the computation API</h2>
              </div>
            </div>
          </div>
          <p>Our computation engine contains a lot of classes that coordinate to implement the application logic. Any client who wants to interact with this implementation would prefer a simplified interface to this subsystem. A facade is an object that provides a simple interface to a large body of code in large classes or modules.</p>
          <p>The GoF facade pattern is a mechanism that we can use to expose a coarse-grained API:</p>
          <pre class="programlisting">    public class TaxComputationFacade 
    { 
       /// &lt;summary&gt; 
       ///  A Rule Engine can do Archetype detection 
       ///  One can write a small Expression Evaluator Engine  
       ///  and GOF terms its Interpreter pattern 
       /// &lt;/summary&gt; 
       /// &lt;param name="te"&gt;&lt;/param&gt; 
       /// &lt;returns&gt;&lt;/returns&gt; 
       private static string ComputeArchetype(TaxableEntity te) 
       { 
         if ((te.Sex == 'F') &amp;&amp; (te.age &gt; 59)) 
         { 
           return "SeniorCitizenFemale"; 
         } 
         else if (te.age&lt;18) { 
           return "JuevenileCitizen"; 
         } 
 
         return (te.age &gt; 60) ? "SeniorCitizen" : "OrdinaryCitizen"; 
       } 
 
       public static bool Compute(TaxableEntity te) 
       { 
         string archetype = ComputeArchetype(te); 
         COMPUTATION_CONTEXT ctx = new COMPUTATION_CONTEXT(); 
         TaxDTO td = new TaxDTO { id = te.id, taxparams = te.taxparams         
         }; 
         ctx.Put("tax_cargo", td); 
         return CommandDispatcher.Dispatch(archetype, ctx); 
       } 
    } 
</pre>
          <p>Now the <code class="literal">ViewHandler</code> has become much simpler, as shown in the following code:</p>
          <pre class="programlisting">    public static void ViewHandler(TaxCalcForm tf) 
    { 
      TaxableEntity te = GetEntityFromUI(tf); 
      if (te == null) 
      { 
        ShowError(); 
        return; 
      } 
      bool rs = TaxComputationFacade.Compute(te); 
      if (rs)  
      { 
        tf.Liabilitytxt.Text =       
        Convert.ToString(te.taxparams.TaxLiability); 
        tf.Refresh(); 
      } 
    } 
</pre>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Summary">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch02lvl1sec18"></a>Summary</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, we have covered quite a lot of ground in understanding why pattern-oriented software development is a good way to develop modern software. We started the chapter by citing some key principles. We progressed further to demonstrate the applicability of these key principles by iteratively skinning an application that is extensible and resilient to changes. Through this journey, we covered concepts such as the command pattern, factory method pattern, facade pattern, design by contract, template method pattern, XML configuration files, LINQ to XML, and so on.</p>
        <p>In the next chapter, we will continue our discussion of patterns by implementing a logging library, which can serialize contents into file, database, or remote network.</p>
      </div>
    </div>
</body>
</html>