<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-280"><a id="_idTextAnchor537"/>13</h1>
<h1 id="_idParaDest-281"><a id="_idTextAnchor538"/>Getting Started with SignalR</h1>
<p>In <a href="B18971_01.xhtml#_idTextAnchor012"><em class="italic">Chapter 1</em></a>, we introduced the concept of real-time web APIs. Various technologies can be used to implement real-time web APIs, such as gRPC streaming, long polling, <strong class="bold">Server-Sent Events</strong> (<strong class="bold">SSE</strong>), WebSockets, and so on. Microsoft provides an open-source library called SignalR to simplify the implementation of real-time web APIs. In this chapter, we will introduce the basics of SignalR and how to use SignalR to implement real-time web APIs.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Recap of real-time web APIs</li>
<li>Setting up SignalR</li>
<li>Building SignalR clients</li>
<li>Using authentication and authorization in SignalR</li>
<li>Managing users and groups</li>
<li>Sending messages from other services</li>
<li>Configuring SignalR hubs and clients</li>
</ul>
<p>By the end of this chapter, you will be able to use SignalR to implement real-time web APIs.</p>
<h1 id="_idParaDest-282"><a id="_idTextAnchor539"/>Technical requirements</h1>
<p>To follow the steps in this chapter, you can download the source code from the GitHub repository at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter13">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter13</a>. You can use VS 2022 or VS Code to open the solutions.</p>
<p>You also need to install the following software:</p>
<ul>
<li><strong class="bold">Node.js</strong>: Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine. You can download the latest version of Node.js from <a href="https://nodejs.org/en/">https://nodejs.org/en/</a>. We will use it to install the required packages for the TypeScript client.</li>
</ul>
<h1 id="_idParaDest-283"><a id="_idTextAnchor540"/>Recap of real-time web APIs</h1>
<p>We introduced a<a id="_idIndexMarker1389"/> few technologies that can be used to implement real-time web APIs in <a href="B18971_01.xhtml#_idTextAnchor012"><em class="italic">Chapter 1</em></a>. Each technology has its pros and cons. To simplify the implementation of real-time web APIs, Microsoft provides SignalR, which supports multiple transports, such as WebSockets, SSE, and long polling. SignalR will automatically choose the best transport based on the client’s capabilities. On top of that, SignalR <a id="_idIndexMarker1390"/>provides a simple programming model to implement real-time web APIs. Developers do not need to worry about the underlying transport details; instead, they can focus on the business logic.</p>
<p>SignalR was first introduced for ASP.NET in 2013. As of now, SignalR has been rewritten for ASP.NET Core and is included in the ASP.NET Core framework. So, there are two different versions of SignalR: one for ASP.NET and one for ASP.NET Core. If you are using ASP.NET Core, you do not need to install any additional packages to use SignalR. There are also some differences between the ASP.NET version and the ASP.NET Core version of SignalR. For example, ASP.NET Core SignalR does not support Microsoft Internet Explorer. However, most modern applications are targeting modern browsers, so this should not be a big issue. In this chapter, we will focus on the ASP.NET Core version of SignalR.</p>
<p>Unlike REST APIs, SignalR clients need to install a SignalR client library to communicate with SignalR servers. SignalR provides a couple of client libraries for different platforms:</p>
<ul>
<li><strong class="bold">JavaScript client</strong>: This<a id="_idIndexMarker1391"/> is the most used client library because it can be used in both browsers and Node.js applications</li>
<li><strong class="bold">.NET client</strong>: This <a id="_idIndexMarker1392"/>client can be used for .NET applications, such as<a id="_idIndexMarker1393"/> Xamarin, <strong class="bold">Windows Presentation Foundation</strong> (<strong class="bold">WPF</strong>), and Blazor</li>
<li><strong class="bold">Java client</strong>: This<a id="_idIndexMarker1394"/> client supports Java 8 and later</li>
</ul>
<p>Other clients, such as the C++ client and Swift client, are not officially supported by Microsoft.</p>
<p>SignalR is a <a id="_idIndexMarker1395"/>good choice for building real-time web APIs. For example, you can use SignalR to build a chat application, a real-time dashboard, voting applications, whiteboard applications, and so on. SignalR can push data to specific clients or groups of clients. It automatically manages connections between clients and servers. In the next section, we will introduce the basics of SignalR and build a simple chat applic<a id="_idTextAnchor541"/>ation.</p>
<h1 id="_idParaDest-284"><a id="_idTextAnchor542"/>Setting up SignalR</h1>
<p>In this <a id="_idIndexMarker1396"/>section, we will build a simple chat application using SignalR. The chat application will allow users to send messages to a public chat room. The messages will be broadcast to all connected clients. This application contains four projects:</p>
<ul>
<li><code>ChatApp.Server</code>: This is the ASP.NET Core web API project that provides a SignalR hub</li>
<li><code>ChatApp.TypeScriptClient</code>: This is a client application written in TypeScript</li>
<li><code>ChatApp.BlazorClient</code>: This is a client application written in Blazor, which is a web framework for building client-side <a id="_idIndexMarker1397"/>applications using C#</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">The code of this sample is based on the official SignalR sample provided by Microsoft. You can find the original source code at <a href="https://github.com/aspnet/SignalR-samples/tree/main/ChatSample">https://github.com/aspnet/SignalR-samples/tree/main/ChatSample</a>. We added the Blazor and MAUI clients to the sample.</p>
<p>The <code>ChatApp.Server</code> application is a <a id="_idIndexMarker1398"/>simple ASP.NET Core web API application that is used to provide a SignalR hub. A SignalR hub is a class to manage connections between clients and servers. It is a high-level abstraction for SignalR real-time communication. A SignalR hub can be used to send messages to clients and receive messages from clients. A SignalR hub can also manage users and groups of clients. In ASP.NET Core SignalR, a hub is defined as a middleware component, so we can easily add it to the ASP.NET Core pipeline.</p>
<p>A SignalR hub has a <code>Clients</code> property to manage connections between the server and the client. When <a id="_idIndexMarker1399"/>a user connects to the SignalR hub, a new connection<a id="_idIndexMarker1400"/> is created. One user can have multiple connections. The <code>Clients</code> property has some methods to manage connections:</p>
<ul>
<li><code>All</code> is used to call a method on all connected clients.</li>
<li><code>Caller</code> is used to call a method on the caller.</li>
<li><code>Others</code> is used to call a method on all connected clients except the caller.</li>
<li><code>Client</code> is used to call a method on a specific client.</li>
<li><code>Clients</code> is used to call a method on specific connected clients.</li>
<li><code>Group</code> is used to call a method on a group of clients.</li>
<li><code>Groups</code> is used to call a method on multiple groups of clients.</li>
<li><code>User</code> is used to call a method on a specific user. Note that one user may have multiple connections.</li>
<li><code>Users</code> is used to call a method on specified users, including all connections.</li>
<li><code>AllExcept</code> is used to call a method on all connected clients except specified clients.</li>
<li><code>GroupExcept</code> is used to call a method on a group of clients except specified clients.</li>
<li><code>OthersInGroup</code> is used to call a method on all clients in a group except the caller.</li>
</ul>
<p>We will explore some of these methods in the following sections. You can find the complete code of the sample in the <code>chapter13/v1</code> folder of the GitHub repository.</p>
<p>Next, follow<a id="_idIndexMarker1401"/> these steps to create a new solution and set up a <code>ChatApp.Server</code> project:</p>
<ol>
<li>Create a new solution called <code>ChatApp</code> using the <code>dotnet new </code><code>sln</code> command:<pre class="source-code">
<code>ChatApp.Server</code> using the <code>dotnet new webapi</code> command and add it to the solution:<pre class="source-code">
<code>Program.cs</code> file and add the following code:<pre class="source-code">
<code>Hubs</code> in the project and add a new class called <code>ChatHub</code>:<pre class="source-code">
namespace ChatApp.Server.Hubs;public class ChatHub : Hub{    public Task SendMessage(string user, string message)    {        return Clients.All.SendAsync("ReceiveMessage", username, message);    }}</pre><p class="list-inset">The preceding code creates a new SignalR hub class called <code>ChatHub</code> that inherits from the <code>Hub</code> class. The <code>ChatHub</code> class contains a method called <code>SendMessage()</code>, which is used to send a message to all connected clients. The <code>SendMessage()</code> method takes two parameters, <code>user</code> and <code>message</code>, which are used to identify the username and the message. This method uses the <code>Clients.All.SendAsync()</code> method to broadcast the message to all connected clients when the <code>SendMessage()</code> method is invoked by clients. Note the first parameter of the <code>SendAsync()</code> method (for example, <code>ReceiveMessage()</code>) is the name of the method for clients to receive the message.</p></li> <li>Next, we<a id="_idIndexMarker1402"/> need to map the SignalR hub to a URL. Add the following code to the <code>Program.cs</code> file:<pre class="source-code">
<code>using ChatApp.Server.Hubs;</code> statement to the top of the file.</p></li> <li>Check the <code>launchSettings.json</code> file in the <code>Properties</code> folder. The default <code>launchSettings.json</code> file contains <code>http</code> and <code>https</code> URLs. By default, the <code>dotnet run</code> command will use the first <code>http</code> profile. We can specify for the launch profile to use the <code>https</code> URL. Use the following command to run the application:<pre class="source-code">
<code>https</code> URL to run the application. Take note of the URL (for example, <code>https://localhost:7159</code>). We will use it in the next section.</p></li> </ol>
<p>The SignalR hub is now ready for use. To test it, however, a client must install a SignalR client library in order to communicate with the hub. In the following section, we will construct client <a id="_idTextAnchor543"/>applications.</p>
<h1 id="_idParaDest-285"><a id="_idTextAnchor544"/>Building SignalR clients</h1>
<p>This section<a id="_idIndexMarker1403"/> will demonstrate how to use SignalR in different platforms by building three SignalR clients that consume the same SignalR hub provided by the <code>ChatApp.Server</code> application. The code for SignalR is largely the same across platforms, making it easy to learn and implement in your own applications. As such, you can refer to any of these applications to gain an understanding of how to consume a SignalR service in your client<a id="_idTextAnchor545"/> applications.</p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor546"/>Building a TypeScript client</h2>
<p>The<a id="_idIndexMarker1404"/> first client we will build is a TypeScript client. This application is just a normal HTML page that uses the SignalR JavaScript <a id="_idIndexMarker1405"/>client library to communicate with the SignalR hub. TypeScript is a superset of JavaScript that provides static typing and other features to help developers write better JavaScript code. TypeScript code is compiled into JavaScript code, so it can run in any JavaScript runtime, such as browsers and Node.js. To learn more about TypeScript, you can visit the <a id="_idIndexMarker1406"/>official website at <a href="https://www.typescriptlang.org/">https://www.typescriptlang.org/</a>.</p>
<p>To use TypeScript in the application, we need to install it. You can do so using the following command:</p>
<pre class="console">
npm install -g typescript</pre> <p>After installing TypeScript, you can use the following command to check the version:</p>
<pre class="console">
tsc -v</pre> <p>If you see the version number, it means that TypeScript is installed successfully.</p>
<p>Next, follow these steps to create a TypeScript client:</p>
<ol>
<li>Create a new folder named <code>ChatApp.TypeScriptClient</code> in the solution folder. Then, create a <code>src</code> folder in the <code>ChatApp.TypeScriptClient</code> folder. The <code>src</code> folder is used to store the source code of the TypeScript client.</li>
<li>Create a new file named <code>index.html</code> in the <code>src</code> folder and add the following code:<pre class="source-code">
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Chat App&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="divChat"&gt;        &lt;label for="txtUsername"&gt;User Name&lt;/label&gt;        &lt;input type="text" id="txtUsername" /&gt;        &lt;label for="txtMessage"&gt;Message&lt;/label&gt;        &lt;input type="text" id="txtMessage" /&gt;        &lt;button id="btnSend"&gt;Send&lt;/button&gt;        &lt;ul id="messages"&gt;&lt;/ul&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</pre><p class="list-inset">The <a id="_idIndexMarker1407"/>preceding code creates a simple HTML <a id="_idIndexMarker1408"/>page that contains a textbox and a button. The <code>ul</code> element is used to display messages.</p></li> <li>Create a new file named <code>tsconfig.json</code> in the <code>ChatApp.TypeScriptClient</code> folder and add the following code:<pre class="source-code">
{  "compilerOptions": {    "noEmitOnError": true,    "noImplicitAny": true,    "sourceMap": true,    "target": "es6",    "moduleResolution":"node"  },  "files": ["src/app.ts"],  "compileOnSave": true}</pre><p class="list-inset">The<a id="_idIndexMarker1409"/> preceding code is the configuration<a id="_idIndexMarker1410"/> file for the TypeScript compiler. It specifies the target version of JavaScript, the module system, and other options. It also specifies the TypeScript files to compile, such as <code>app.ts</code>. We will create an <code>app.ts</code> file in <em class="italic">step 6</em>.</p></li> <li>Next, we need to set up <code>npm</code> so that we can install the required packages. Use the following command to initialize <code>npm</code>:<pre class="source-code">
<code>package.json</code> file in the <code>ChatApp.TypeScriptClient</code> folder. The <code>package.json</code> file is used to manage the dependencies of the project. It also contains other information about the project, such as the name, version, description, and so on.</p></li> <li>Next, we need to install the required packages. Use the following command to install the required packages:<pre class="source-code">
<code>@microsoft/signalr</code> package is the official SignalR JavaScript client library. The <code>@types/node</code> package is used to provide type definitions for Node.js.</p></li> <li>Create a new<a id="_idIndexMarker1411"/> file named <code>app.ts</code> in the <code>src</code> folder and <a id="_idIndexMarker1412"/>add the following code:<pre class="source-code">
import * as signalR from "@microsoft/signalr";const txtUsername: HTMLInputElement = document.getElementById(  "txtUsername") as HTMLInputElement;const txtMessage: HTMLInputElement = document.getElementById(  "txtMessage") as HTMLInputElement;const btnSend: HTMLButtonElement = document.getElementById(  "btnSend") as HTMLButtonElement;btnSend.disabled = true;const connection = new signalR.HubConnectionBuilder()  .withUrl("https://localhost:7159/chatHub")  .build();connection.on("ReceiveMessage", (username: string, message: string) =&gt; {  const li = document.createElement("li");  li.textContent = `${username}: ${message}`;  const messageList = document.getElementById("messages");  messageList.appendChild(li);  messageList.scrollTop = messageList.scrollHeight;});connection  .start()  .then(() =&gt; (btnSend.disabled = false))  .catch((err) =&gt; console.error(err.toString()));txtMessage.addEventListener("keyup", (event) =&gt; {  if (event.key === "Enter") {    sendMessage();  }});btnSend.addEventListener("click", sendMessage);function sendMessage() {  connection    .invoke("SendMessage", txtUsername.value, txtMessage.value)    .catch((err) =&gt; console.error(err.toString()))    .then(() =&gt; (txtMessage.value = ""));}</pre><p class="list-inset">The preceding code creates a SignalR connection to the SignalR hub. The <code>connection</code> object is used to send messages to the SignalR hub and receive messages from the SignalR hub. The <code>withURL()</code> method is used to specify the URL of the SignalR hub. In this case, we use <code>https://localhost:7159/chatHub</code> as the URL. If your SignalR hub is hosted on a different URL, you need to change it accordingly.</p><p class="list-inset">When<a id="_idIndexMarker1413"/> the page is loaded, the <code>connection</code> object has a couple of methods used in this sample:</p><ul><li><code>on()</code> method takes two parameters: the first parameter is the name of the method, which is <code>RecieveMessage()</code>, as we defined in the <code>ChatHub</code> class, and the second parameter is a callback function that is called when the message is received.</li><li><code>invoke()</code> method is called when the user clicks the <code>invoke()</code> method takes three parameters: the first parameter is the name of the method we want to invoke on the SignalR hub, which is <code>SendMessage()</code>, as we defined in the <code>ChatHub</code> class, the second parameter is the username, and the third parameter is the message.</li></ul><p class="list-inset">Make sure to use the correct method names. Otherwise, the client will not be able to communicate with the SignalR hub.</p></li> <li>Next, we need to compile the TypeScript code to JavaScript code. We will use Gulp to automate the compilation process. If you prefer to use other tools, such as Webpack, you can use them as well. Use the following command to install Gulp globally:<pre class="source-code">
<code>gulp</code> and <code>gulp-typescript</code> in the project:<pre class="source-code">
<code>gulpfile.js</code> in the <code>ChatApp.TypeScriptClient</code> folder and add the following code:<pre class="source-code">
const gulp = require('gulp');const browserify = require('browserify');const source = require('vinyl-source-stream');const buffer = require('vinyl-buffer');const sourcemaps = require('gulp-sourcemaps');const tsify = require('tsify');// Bundle TypeScript with SignalRgulp.task('bundle', () =&gt; {  return browserify({    basedir: '.',    debug: true,    entries: ['src/app.ts'], // Replace with your TypeScript entry file    cache: {},    packageCache: {},  })    .plugin(tsify)    .bundle()    .pipe(source('bundle.js'))    .pipe(buffer())    .pipe(sourcemaps.init({ loadMaps: true }))    .pipe(sourcemaps.write('./'))    .pipe(gulp.dest('dist'));});// Copy HTMLgulp.task('copy-html', () =&gt; {  return gulp.src('src/**/*.html')    .pipe(gulp.dest('dist'));});// Main build taskgulp.task('default', gulp.series('bundle', 'copy-html'));</pre><p class="list-inset">The <code>gulp</code> configuration file defines some tasks that are used to compile TypeScript code to JavaScript and generate a bundle file. Additionally, it copies HTML files to the <code>dist</code> folder, which is used to store the compiled JavaScript code and HTML files. If desired, the folder name can be changed. The bundle file loads the SignalR JavaScript client library <a id="_idIndexMarker1420"/>and the compiled JavaScript code.</p></li> <li>Add a<a id="_idIndexMarker1421"/> script to the <code>package.json</code> file to run <code>gulp</code> tasks:<pre class="source-code">
"scripts": {  "gulp": "gulp"}</pre><p class="list-inset"> The complete <code>package.json</code> file should look like this:</p><pre class="source-code">{  "name": "chatapp.typescriptclient",  "version": "1.0.0",  "description": "",  "main": "index.js",  "scripts": {    "gulp": "gulp"  },  "keywords": [],  "author": "",  "license": "ISC",  "dependencies": {    "@microsoft/signalr": "^8.0.0",    "@types/node": "^20.9.0"  },  "devDependencies": {    "@microsoft/signalr": "^8.0.0",    "browserify": "^17.0.0",    "gulp": "^4.0.2",    "gulp-sourcemaps": "^3.0.0",    "gulp-typescript": "^6.0.0-alpha.1",    "tsify": "^5.0.4",    "vinyl-buffer": "^1.0.1",    "vinyl-source-stream": "^2.0.0"  }}</pre></li> <li>Next, update <a id="_idIndexMarker1422"/>the <code>index.html</code> file in the <code>src</code> folder to load the bundle file:<pre class="source-code">
&lt;!-- Omitted --&gt;    &lt;script src="img/bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</pre></li> <li>Run the<a id="_idIndexMarker1423"/> following command to compile the TypeScript code and copy the HTML files to the <code>dist</code> folder:<pre class="source-code">
<code>dist</code> folder. It will also copy the HTML files to the <code>dist</code> folder. If the command is executed successfully, you should see three files in the <code>dist</code> folder: <code>bundle.js</code>, <code>bundle.js.map</code>, and <code>index.html</code>. In the next sections, if you make any changes to the TypeScript code, you need to run this command again to compile the TypeScript code.</p><p class="list-inset">The <a id="_idIndexMarker1424"/>development of the TypeScript client is now complete. To test it, we need to run a web server to host the HTML page. VS Code has some extensions that can be used to run a web server. For example, you can use the <code>index.html</code> file in the <code>dist</code> folder and select the <strong class="bold">Show Preview</strong> menu to run the web server. You<a id="_idIndexMarker1425"/> will see VS Code opens a new tab and displays the HTML page, as shown next:</p></li> </ol>
<div><div><img alt="Figure 13.1 – Running the TypeScript client in VS Code" src="img/B18971_13_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Running the TypeScript client in VS Code</p>
<p class="list-inset">You can also try some other tools, such as <code>http-server</code>.</p>
<ol>
<li value="13">Now, start the SignalR server by running the following command:<pre class="source-code">
<code>Program.cs</code> file:<pre class="source-code">
// Enable CORSvar corsPolicy = new CorsPolicyBuilder()    .AllowAnyHeader()    .AllowAnyMethod()    .AllowCredentials()    .WithOrigins("http://127.0.0.1:3000")    .Build();builder.Services.AddCors(options =&gt;{    options.AddPolicy("CorsPolicy", corsPolicy);});</pre><p class="list-inset">The preceding code allows cross-origin requests from <code>http://127.0.0.1:3000</code>, which is the URL of the <strong class="bold">Live Preview</strong> web server. You can change it to the URL of your web server if you are using a different web server. Note that this example is a very basic configuration that does not <a id="_idIndexMarker1431"/>restrict any HTTP headers or HTTP methods. In a real-world application, you may need to restrict HTTP requests to improve the security of the application. For more details about CORS, you can refer to the official documentation at <a href="https://learn.microsoft.com/en-us/aspnet/core/security/cors">https://learn.microsoft.com/en-us/aspnet/core/security/cors</a>.</p></li> <li>Restart<a id="_idIndexMarker1432"/> the SignalR server and refresh the web page. You should see the <strong class="bold">Send</strong> button is enabled. Enter a username and a message and click the <strong class="bold">Send</strong> button. You should see the message displayed in a list, as shown next:</li>
</ol>
<div><div><img alt="Figure 13.2 – Sending a message from the TypeScript client" src="img/B18971_13_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Sending a message from the TypeScript client</p>
<ol>
<li value="16">Open another browser tab and enter the same URL. Enter a different username and a message and click the <strong class="bold">Send</strong> button. You should see the message displayed in both browser tabs, as shown next:</li>
</ol>
<div><div><img alt="Figure 13.3 – Sending a message from another browser tab" src="img/B18971_13_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Sending a message from another browser tab</p>
<p>The TypeScript client is now complete. This is a very simple client that does not use any JavaScript frameworks. The world of frontend development is changing rapidly. If you encounter any issues when testing the sample code, you can use any other JavaScript frameworks you like, such as React, Angular, or Vue.js. The code for SignalR is largely the s<a id="_idTextAnchor547"/>ame for different JavaScript frameworks.</p>
<h2 id="_idParaDest-287"><a id="_idTextAnchor548"/>Building a Blazor client</h2>
<p>The <a id="_idIndexMarker1433"/>second client we will build is a Blazor client. Blazor is a <a id="_idIndexMarker1434"/>web framework for building client-side applications using C#. Blazor was first introduced as a part of ASP.NET Core 3.0 in 2018. Blazor supports different hosting models:</p>
<ul>
<li><strong class="bold">Blazor Server</strong>: In<a id="_idIndexMarker1435"/> this hosting model, the Blazor application is hosted on an ASP.NET Core server. Remote clients connect to the server using SignalR. The server is responsible for handling user interactions and updating the UI over a SignalR connection. The application can use the full power of the .NET ecosystem and all ASP.NET Core features. This hosting model also allows the client to download a small amount of code, meaning the application loads fast, but it requires a persistent connection to the server. If the SignalR connection is lost, the application will not work.</li>
<li><strong class="bold">Blazor WebAssembly</strong>: This<a id="_idIndexMarker1436"/> hosting model runs the Blazor application on a WebAssembly .NET runtime in the browser. The Blazor application is downloaded to the client, which means that this model requires a larger download size than the Blazor Server model. When a Blazor WebAssembly application is hosted within an ASP.NET Core application, it is called <em class="italic">hosted Blazor WebAssembly</em>. The hosted Blazor WebAssembly application can share code with the ASP.NET Core application. When a Blazor WebAssembly application is hosted in a static website without server-side code, it is called <em class="italic">standalone Blazor WebAssembly</em>. A standalone Blazor WebAssembly application acts like a pure client-side application, such as a React application, so it can be <a id="_idIndexMarker1437"/>hosted on any web server<a id="_idIndexMarker1438"/> or a <strong class="bold">content delivery network</strong> (<strong class="bold">CDN</strong>). Blazor WebAssembly applications can work offline, but the performance depends on the client’s hardware.</li>
<li><strong class="bold">Blazor Hybrid</strong>: This <a id="_idIndexMarker1439"/>model allows a Blazor application to<a id="_idIndexMarker1440"/> run in a .NET native app framework, such as WPF, Windows Forms, and MAUI. This model combines the power of the web and native applications, and it can use the full power of the .NET platform. It is suitable for building cross-platform applications because the Blazor code can be shared across different platforms. However, it is still required to package the application for different platforms.</li>
</ul>
<p>In this sample application, we will use standalone Blazor WebAssembly to build the client application because a web-based application is one of the most seen scenarios. But it is also possible to use similar code for other hosting models. ASP.NET Core 8 brings some improvements to Blazor. To learn more about Blazor, you can visit the official website at <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/">https://learn.microsoft.com/en-us/aspnet/core/blazor/</a>.</p>
<p>To create a <a id="_idIndexMarker1441"/>Blazor WebAssembly application, follow these steps:</p>
<ol>
<li>Navigate to the root folder of the <code>ChatApp.sln</code> solution. Create a new Blazor WebAssembly application called <code>ChatApp.BlazorClient</code> and add the project to the solution using the following command:<pre class="source-code">
<code>ChatApp.BlazorClient</code> folder and run the following command to install the SignalR client library:<pre class="source-code">
<code>page</code> directive in the <code>/</code><code>Components/Pages/Home.razor</code> file:<pre class="source-code">
@using Microsoft.AspNetCore.SignalR.Client@implements IAsyncDisposable</pre><p class="list-inset">This <code>using</code> statement imports the SignalR client library to the <code>Home</code> component. The <code>implements IAsyncDisposable</code> statement indicates that the <code>Home</code> component implements the <code>IAsyncDisposable</code> interface. The <code>IAsyncDisposable</code> interface is used to dispose of resources asynchronously. We <a id="_idIndexMarker1442"/>will use it to dispose of the SignalR connection when the component is no longer in use.</p></li> <li>Add the<a id="_idIndexMarker1443"/> following code to the end of the <code>Home.razor</code> file:<pre class="source-code">
@code {    private HubConnection? _hubConnection;    private readonly List&lt;string&gt; _messages = new ();    private string? _username;    private string? _message;    private bool IsConnected =&gt; _hubConnection?.State == HubConnectionState.Connected;    protected override async Task OnInitializedAsync()    {        _hubConnection = new HubConnectionBuilder()        .WithUrl("https://localhost:7159/chatHub")        .Build();        _hubConnection.On&lt;string, string&gt;("ReceiveMessage", (username, message) =&gt;        {            var encodedMessage = $"{username}: {message}";            _messages.Add(encodedMessage);            StateHasChanged();        });        await _hubConnection.StartAsync();    }    private async Task SendMessage()    {        if (_hubConnection != null &amp;&amp; IsConnected)        {            await _hubConnection!.InvokeAsync("SendMessage", _username, _message);            _message = string.Empty;        }    }    public async ValueTask DisposeAsync()    {        if (_hubConnection is not null)        {            await _hubConnection.DisposeAsync();        }    }}</pre><p class="list-inset">Blazor utilizes the <code>@code</code> directive to incorporate C# code into components. In this instance, we<a id="_idIndexMarker1444"/> have defined a few fields and methods for the <code>Home</code> component. If you compare this code to its TypeScript counterpart, you will find that the logic is very similar. The <code>OnInitializedAsync()</code> method<a id="_idIndexMarker1445"/> is used to set up a SignalR connection, while the <code>SendMessage()</code> method is used to invoke the <code>SendMessage()</code> method of the SignalR hub to send a message. The <code>DisposeAsync()</code> method is used to dispose of the SignalR connection when the component is no longer in use. Additionally, the <code>StateHasChanged()</code> method is used to notify the component to re-render the UI.</p></li> <li>Next, we need to bind these fields to the UI. Add the following code before the <code>@</code><code>code</code> directive:<pre class="source-code">
&lt;div id="username-group"&gt;    &lt;label&gt;User Name&lt;/label&gt;    &lt;input type="text" @bind="_username" /&gt;&lt;/div&gt;&lt;div id="message-group"&gt;    &lt;label&gt;Message&lt;/label&gt;    &lt;input type="text" @bind="_message" /&gt;&lt;/div&gt;&lt;input type="button" value="Send" @onclick="SendMessage" disabled="@(!IsConnected)" /&gt;&lt;ul&gt;    @foreach (var message in _messages)    {        &lt;li&gt;@message&lt;/li&gt;    }&lt;/ul&gt;</pre><p class="list-inset">Blazor<a id="_idIndexMarker1446"/> uses the <code>@</code> symbol to indicate a C# expression. The <code>@bind</code> directive is used to bind the value of the input element to the specified field. The <code>@onclick</code> directive is used to bind the click event to the specified method. The <code>@foreach</code> directive is used to iterate over the messages<a id="_idIndexMarker1447"/> and display them in a list. If you are familiar with any modern JavaScript frameworks, such as React, Angular, or Vue.js, you will find some similarities between Blazor and these frameworks.</p></li> <li>Next, we need to configure the CORS policy for the SignalR server so that the Blazor client can connect to the SignalR hub. Check the <code>launchSettings.json</code> file in the <code>Properties</code> folder. Similar to the SignalR server application, we can use the <code>http</code> or <code>https</code> profile to run the Blazor client application. We will use the <code>https</code> file in this case. For example, the URL of the sample code uses <code>https://localhost:7093</code> to run the Blazor client application on the HTTPS profile. We need to update the CORS policy in the SignalR server. Update the <code>Program.cs</code> file of the <code>ChatApp.Server</code> project, as shown next:<pre class="source-code">
var corsPolicy = new CorsPolicyBuilder()    .AllowAnyHeader()    .AllowAnyMethod()    .AllowCredentials()    .WithOrigins("http://127.0.0.1:3000", "https://localhost:7093")    .Build();</pre><p class="list-inset">Now, the SignalR server can accept cross-origin requests from the Blazor client application.</p></li> <li>Run the SignalR server application and the Blazor client application in separate terminals using the <code>dotnet run --launch-profile https</code> command. You can test the Blazor client application by opening the <code>https://localhost:7093</code> URL in the browser. The Blazor client can chat with the TypeScript client, as shown next:</li>
</ol>
<div><div><img alt="Figure 13.4 – Chatting between the Blazor client and the TypeScript client" src="img/B18971_13_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Chatting between the Blazor client and the TypeScript client</p>
<p>SignalR provides<a id="_idIndexMarker1448"/> the convenience of real-time communication. Developers do not need to operate the <a id="_idIndexMarker1449"/>underlying transport details; instead, they can use the SignalR <code>Hub</code> class to send and receive messages easily. In the next <a id="_idTextAnchor549"/>section, we will explore more features of a SignalR hub.</p>
<h1 id="_idParaDest-288"><a id="_idTextAnchor550"/>Using authentication and authorization in SignalR</h1>
<p>In the<a id="_idIndexMarker1450"/> previous<a id="_idIndexMarker1451"/> section, we used the <code>Hub</code> class to implement a simple chat app. The <code>Clients.All.SendAsync</code> method is used to send a message to all connected clients. Sometimes, we <a id="_idIndexMarker1452"/>may want to send a message to a specific client <a id="_idIndexMarker1453"/>or a group of clients. To manage users and groups, we need to know the identity of the user. In this section, we will explore how to use authentication and authorization in SignalR.</p>
<p>By default, SignalR uses a <code>ClaimTypes.NameIdentifier</code> claim to differentiate users. The <code>ClaimTypes.NameIdentifier</code> claim is used to uniquely identify a user. We introduced claim-based authorization in <a href="B18971_08.xhtml#_idTextAnchor307"><em class="italic">Chapter 8</em></a>, so we will follow the steps from that chapter to add authentication and authorization to the SignalR server application. If you are not familiar with ASP.NET Core authentication and authorization, you can refer to <a href="B18971_08.xhtml#_idTextAnchor307"><em class="italic">Chapter 8</em></a> for more details.</p>
<p>You can find the complete code of the<a id="_idTextAnchor551"/> sample in the <code>chapter13/v2</code> folder of the GitHub repository.</p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor552"/>Adding authentication and authorization to the SignalR server</h2>
<p>To add <a id="_idIndexMarker1454"/>authentication and authorization to the SignalR server, follow<a id="_idIndexMarker1455"/> these <a id="_idIndexMarker1456"/>steps:</p>
<ol>
<li>Install the <a id="_idIndexMarker1457"/>required packages using the following command:<pre class="source-code">
<code>Data</code> in the <code>ChatApp.Server</code> project. Then, create a new class called <code>AppbContext</code> in the <code>Data</code> folder. As we introduced <code>DbContext</code> in previous chapters, we will not show the code here. You can find the code in the sample application.</li>
<li>Add a connection string in the <code>appsettings.json</code> file:<pre class="source-code">
"ConnectionStrings": {  "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=ChatAppDb;Trusted_Connection=True;MultipleActiveResultSets=true"}</pre></li> <li>Add configurations for JWT tokens in the <code>appsettings.json</code> file:<pre class="source-code">
"JwtConfig": {  "ValidAudiences": "http://localhost:7159",  "ValidIssuer": "http://localhost:7159",  "Secret": "c1708c6d-7c94-466e-aca3-e09dcd1c2042"}</pre><p class="list-inset">We will <a id="_idIndexMarker1458"/>use the same SignalR server as <a id="_idIndexMarker1459"/>the authentication server. So, we will use the URL of the SignalR server as the audience and issuer. If you use a different authentication server, you need to change the audience and issuer accordingly.</p></li> <li>SignalR needs an <code>IUserIdProvider</code> interface to get the user ID. Create a new folder named <code>Services</code> in the <code>ChatApp.Server</code> project. Then, create a new class called <code>NameUserIdProvider</code> in the <code>Services</code> folder:<pre class="source-code">
using Microsoft.AspNetCore.SignalR;namespace ChatApp.Server.Services;public class NameUserIdProvider : IUserIdProvider{    public string GetUserId(HubConnectionContext connection)    {        return connection.User?.Identity?.Name ?? string.Empty;    }}</pre><p class="list-inset">The preceding code implements the <code>IUserIdProvider</code> interface. The <code>GetUserId</code> method returns the user ID of the current user. In this case, we use the username as the user ID. You can use any other unique value as the user ID. For<a id="_idIndexMarker1460"/> example, if you want to use the email <a id="_idIndexMarker1461"/>address as the user ID, you can create an <code>EmailBasedUserIdProvider</code> class as follows:</p><pre class="source-code">using System.Security.Claims;using Microsoft.AspNetCore.SignalR;namespace ChatApp.Server.Services;public class EmailBasedUserIdProvider : IUserIdProvider{    public string GetUserId(HubConnectionContext connection)    {        return connection.User?.Claims.FirstOrDefault(c =&gt; c.Type == ClaimTypes.Email)?.Value ??    string.Empty;    }}</pre></li> <li>Update the <code>Program.cs</code> file to add authentication and authorization, as follows:<pre class="source-code">
builder.Services.AddDbContext&lt;AppDbContext&gt;();builder.Services.AddIdentityCore&lt;IdentityUser&gt;()    .AddEntityFrameworkStores&lt;AppDbContext&gt;()    .AddDefaultTokenProviders();builder.Services.AddAuthentication(options =&gt;{    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;    options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;}).AddJwtBearer(options =&gt;{    var secret = builder.Configuration["JwtConfig:Secret"];    var issuer = builder.Configuration["JwtConfig:ValidIssuer"];    var audience = builder.Configuration["JwtConfig:ValidAudiences"];    if (secret is null || issuer is null || audience is null)    {        throw new ApplicationException("Jwt is not set in the configuration");    }    options.SaveToken = true;    options.RequireHttpsMetadata = false;    options.TokenValidationParameters = new TokenValidationParameters()    {        ValidateIssuer = true,        ValidateAudience = true,        ValidAudience = audience,        ValidIssuer = issuer,        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret))    };    // Hook the SignalR event to check for the token in the query string    options.Events = new JwtBearerEvents    {        OnMessageReceived = context =&gt;        {            var accessToken = context.Request.Query["access_token"];            var path = context.HttpContext.Request.Path;            if (!string.IsNullOrEmpty(accessToken) &amp;&amp; path.StartsWithSegments("/chatHub"))            {                context.Token = accessToken;            }            return Task.CompletedTask;        }    };});// Use the name-based user ID providerbuilder.Services.AddSingleton&lt;IUserIdProvider, NameUserIdProvider&gt;();</pre><p class="list-inset">The <a id="_idIndexMarker1462"/>preceding code is similar to the code in <a href="B18971_08.xhtml#_idTextAnchor307"><em class="italic">Chapter 8</em></a>. A difference is that we configured the <code>options.Events</code> property of the <code>JwtBearerOptions</code> object. The <code>OnMessageReceived</code> event is used to check the token in the query string. The reason is that WebSocket APIs and SSE do not support the standard <code>Authorization</code> header, so it is required to attach the token to the query string. If the <a id="_idIndexMarker1463"/>token is found in the query string, it will be used to authenticate the user.</p><p class="list-inset">We also added the <code>IUserIdProvider</code> service to the <code>NameUserIdProvider</code> class we created earlier. If you want to use the <code>EmailBasedUserIdProvider</code> class, you need to change the code accordingly. Note that you must not use both at the same time.</p></li> <li>Create a database and run migrations using the following commands:<pre class="source-code">
<code>Authorize</code> attribute to the <code>ChatHub</code> class, as shown next:<pre class="source-code">
[Authorize]public class ChatHub : Hub{    // Omitted for brevity}</pre><p class="list-inset">The <code>Authorize</code> attribute can be applied to the <code>Hub</code> class or methods of the <code>Hub</code> class. It also supports policy-based authorization. For example, you can use the <code>Authorize(Policy = "Admin")</code> attribute to restrict access to the <code>ChatHub</code> class to administrators.</p></li> <li>Run<a id="_idIndexMarker1465"/> the <code>ChatApp.Server</code> application, as well as any other client applications. Unfortunately, the TypeScript <a id="_idIndexMarker1466"/>and Blazor clients will not be able to connect to the SignalR hub due to the need for user authen<a id="_idTextAnchor553"/>tication. To access the SignalR hub, we need to authenticate the clients.</li>
</ol>
<h2 id="_idParaDest-290"><a id="_idTextAnchor554"/>Adding a login endpoint</h2>
<p>To <a id="_idIndexMarker1467"/>authenticate the clients, we need to provide a login endpoint. We<a id="_idIndexMarker1468"/> implemented a login endpoint in <a href="B18971_08.xhtml#_idTextAnchor307"><em class="italic">Chapter 8</em></a>. You can follow the steps in <a href="B18971_08.xhtml#_idTextAnchor307"><em class="italic">Chapter 8</em></a> to implement the login endpoint or copy the code from the sample application. You need to create an <code>AccountController</code> class that contains register and login endpoints. You also need to add some models, such as the <code>LoginModel</code> and <code>AddOrUpdateUserModel</code> classes. With these classes, we can use the <code>account/register</code> and <code>account/login</code> endpoints to register and log in users.</p>
<p>One thing to note here is that when generating a JWT token, we need to add a <code>ClaimTypes.NameIdentifier</code> claim to the token. SignalR uses this claim to identify the user. The following code shows how to add a <code>ClaimTypes.NameIdentifier</code> claim to the token:</p>
<pre class="source-code">
var tokenDescriptor = new SecurityTokenDescriptor{
    Subject = new ClaimsIdentity(new[]
    {
        // SignalR requires the NameIdentifier claim to map the user to the connection
        new Claim(ClaimTypes.NameIdentifier, userName),
        new Claim(ClaimTypes.Name, userName),
        // If you use the email-based user ID provider, you need to add the email claim from the database
    }),
    Expires = DateTime.UtcNow.AddDays(1),
    Issuer = issuer,
    Audience = audience,
    SigningCredentials = new SigningCredentials(signingKey, SecurityAlgorithms.HmacSha256Signature)
};</pre>
<p>Now, we<a id="_idIndexMarker1469"/> need to create some users for testing. Run the <code>ChatApp.Server</code> application and send a <code>POST</code> request to the <code>account/register</code> endpoint<a id="_idIndexMarker1470"/> using Postman or any other HTTP client. The following code shows how to create a user using the <code>account/register</code> endpoint:</p>
<pre class="source-code">
{  "userName": "user1",
  "email": "user1@example.com",
  "password": "Passw0rd!"
}</pre>
<p>Create more users such as <code>user2<a id="_idTextAnchor555"/></code>, <code>user3</code>, and so on. We will use these users to test the <code>Groups</code> feature later.</p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor556"/>Authenticating the TypeScript client</h2>
<p>Now, we <a id="_idIndexMarker1471"/>can<a id="_idIndexMarker1472"/> authenticate the TypeScript client. To do so, we need to update the UI to allow the user to enter the username and password. We also need to update the TypeScript code to send the username and password to the login endpoint. Follow these steps to update the TypeScript client:</p>
<ol>
<li>Update the HTML content in the <code>&lt;body&gt;</code> element as follows:<pre class="source-code">
&lt;body&gt;    &lt;div id="divLogin"&gt;        &lt;label for="txtUsername"&gt;User Name&lt;/label&gt;        &lt;input type="text" id="txtUsername" /&gt;        &lt;label for="txtPassword"&gt;Password&lt;/label&gt;        &lt;input type="password" id="txtPassword" /&gt;        &lt;button id="btnLogin"&gt;Login&lt;/button&gt;    &lt;/div&gt;    &lt;div id="divChat"&gt;        &lt;label&gt;User Name&lt;/label&gt;        &lt;label id="lblUsername" &gt;&lt;/label&gt;        &lt;label for="txtMessage"&gt;Message&lt;/label&gt;        &lt;input type="text" id="txtMessage" /&gt;        &lt;button id="btnSend"&gt;Send&lt;/button&gt;        &lt;ul id="messages"&gt;&lt;/ul&gt;    &lt;/div&gt;    &lt;script type="module" src="img/bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;</pre><p class="list-inset">The <a id="_idIndexMarker1473"/>preceding code adds a login form to the <a id="_idIndexMarker1474"/>HTML page. The login form contains a username textbox, a password textbox, and a login button. The <code>divChat</code> element now has a <code>lblUsername</code> element to display the username. The <code>divChat</code> element is hidden by default. We will show it after the user is <a id="_idIndexMarker1475"/>authenticated.</p></li> <li>Update<a id="_idIndexMarker1476"/> the <code>app.ts</code> file as follows:<pre class="source-code">
import * as signalR from "@microsoft/signalr";divChat.style.display = "none";btnSend.disabled = true;btnLogin.addEventListener("click", login);let connection: signalR.HubConnection = null;async function login() {  const username = txtUsername.value;  const password = txtPassword.value;  if (username &amp;&amp; password) {    try {      // Use the Fetch API to login      const response = await fetch("https://localhost:7159/account/login", {        method: "POST",        headers: { "Content-Type": "application/json" },        body: JSON.stringify({ username, password }),      });      const json = await response.json();      localStorage.setItem("token", json.token);      localStorage.setItem("username", username);      txtUsername.value = "";      txtPassword.value = "";      lblUsername.textContent = username;      divLogin.style.display = "none";      divChat.style.display = "block";      txtMessage.focus();      // Start the SignalR connection      connection = new signalR.HubConnectionBuilder()        .withUrl("https://localhost:7159/chatHub", {          accessTokenFactory: () =&gt; {           var localToken = localStorage.getItem("token");           // You can add logic to check if the token is valid or expired           return localToken;         },        })        .build();      connection.on("ReceiveMessage", (username: string, message: string) =&gt; {        const li = document.createElement("li");        li.textContent = `${username}: ${message}`;        const messageList = document.getElementById("messages");        messageList.appendChild(li);        messageList.scrollTop = messageList.scrollHeight;      });      await connection.start();      btnSend.disabled = false;    } catch (err) {      console.error(err.toString());    }  }}txtMessage.addEventListener("keyup", (event) =&gt; {  if (event.key === "Enter") {    sendMessage();  }});btnSend.addEventListener("click", sendMessage);function sendMessage() {  connection    .invoke("SendMessage", lblUsername.textContent, txtMessage.value)    .catch((err) =&gt; console.error(err.toString()))    .then(() =&gt; (txtMessage.value = ""));}</pre><p class="list-inset">Some codes are omitted. You can find the full code from the books GitHub repository.</p><p class="list-inset">In the<a id="_idIndexMarker1477"/> preceding code, we use the <code>fetch</code> API to send a <code>POST</code> request to the login endpoint. The login endpoint returns<a id="_idIndexMarker1478"/> a JWT token if the user is authenticated. Then, we store the token in the local storage and show the username in the <code>divChat</code> element. We also adjusted the creation of the SignalR connection. The <code>accessTokenFactory</code> property is used to get the token from the local storage. You can add some logic to check whether the token is valid or expired. If the token is expired, you can redirect the user to the login page or use the <code>dist</code> folder:<pre class="source-code">
<strong class="bold">npm run gulp</strong></pre></li> <li>Use the <strong class="bold">Live Preview</strong> extension to run the web server. Run the SignalR server application as well. You will see a login form, as shown next:</li>
</ol>
<div><div><img alt="Figure 13.5 – The login form" src="img/B18971_13_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – The login form</p>
<p class="list-inset">Use the username and password you created earlier to log in. You should see a chat form, as shown next:</p>
<div><div><img alt="Figure 13.6 – Authenticated chat" src="img/B18971_13_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – Authenticated chat</p>
<p>Now, th<a id="_idTextAnchor557"/>e<a id="_idIndexMarker1479"/> TypeScript<a id="_idIndexMarker1480"/> client is authenticated. Next, we will authenticate the Blazor client.</p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor558"/>Authenticating the Blazor client</h2>
<p>The <a id="_idIndexMarker1481"/>code to <a id="_idIndexMarker1482"/>authenticate the Blazor client is very similar to the TypeScript client, so we will not list all the code here. You can find the code in the sample application. The following code shows how to log in and set a token to the SignalR connection:</p>
<pre class="source-code">
@inject HttpClient Httpprivate async Task Login()
{
    if (!string.IsNullOrWhiteSpace(_username) &amp;&amp; !string.IsNullOrWhiteSpace(_password))
    {
        var response = await Http.PostAsJsonAsync("Account/login", new { Username = _username, Password = _password });
        if (response.IsSuccessStatusCode)
        {
            var jsonString = await response.Content.ReadAsStringAsync();
            var data = System.Text.Json.JsonSerializer.Deserialize&lt;Dictionary&lt;string, string&gt;&gt;(jsonString);
            _token = data["token"];
            if (string.IsNullOrWhiteSpace(_token))
            {
                throw new Exception("Invalid token.");
            }
            else
            {
                _showLogin = false;
                _showChat = true;
                StateHasChanged();
                // Set the token to the hub connection.
                _hubConnection = new HubConnectionBuilder()
                .WithUrl("https://localhost:7159/chatHub", options =&gt;
                {
                    options.AccessTokenProvider = () =&gt; Task.FromResult&lt;string?&gt;(_token);
                })
                .Build();
                _hubConnection.On&lt;string, string&gt;("ReceiveMessage", (username, message) =&gt;
                {
                    var encodedMessage = $"{username}: {message}";
                    _messages.Add(encodedMessage);
                    StateHasChanged();
                });
                await _hubConnection.StartAsync();
            }
        }
    }
}</pre>
<p>In the<a id="_idIndexMarker1483"/> preceding code, we inject <code>HttpClient</code> to send a <code>POST</code> request to the login endpoint. Then, we set a token to the SignalR <a id="_idIndexMarker1484"/>connection. The <code>AccessTokenProvider</code> property is used to get the token from the <code>_token</code> field. Similar to the TypeScript client, you can add some logic to check whether the token is valid or expired.</p>
<p>Run the three applications. You can use different usernames to log in to the two clients and send messages. You should see messages are displayed in both clients, as shown next:</p>
<div><div><img alt="Figure 13.7 – Authenticated chat for different users" src="img/B18971_13_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – Authenticated chat for different users</p>
<p><a id="_idTextAnchor559"/>The clients now<a id="_idIndexMarker1485"/> support authentication. Next, we will add <a id="_idIndexMarker1486"/>more features to the chat app.</p>
<h1 id="_idParaDest-293"><a id="_idTextAnchor560"/>Managing users and groups</h1>
<p>In the<a id="_idIndexMarker1487"/> previous section, we implemented basic authentication and authorization for the SignalR server. We also updated clients to authenticate users. In this section, we will explore how to manage users and groups in SignalR. We want to add features to the chat app to enable the following:</p>
<ul>
<li>Allow users to know who is connected to the chat app</li>
<li>Allow users to send a message to a specific user</li>
<li>Allow users to join groups</li>
<li>Allow users to send a message to a specific group</li>
</ul>
<p>You can find the complete code of the samp<a id="_idTextAnchor561"/>le in the <code>chapter13/v3</code> folder of the GitHub repository. Let’s start with the first feature.</p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor562"/>Managing events in SignalR</h2>
<p>SignalR provides<a id="_idIndexMarker1488"/> events to notify clients when a user connects or disconnects. We can override the <code>OnConnectedAsync()</code> and <code>OnDisconnectedAsync()</code> methods to handle these events. The following code shows how to override the <code>OnConnectedAsync()</code> method:</p>
<pre class="source-code">
public override async Task OnConnectedAsync(){
    await Clients.All.SendAsync("UserConnected", Context.User.Identity.Name);
    await base.OnConnectedAsync();
}</pre>
<p>When a <a id="_idIndexMarker1489"/>client connects to the SignalR hub, the <code>OnConnectedAsync()</code> method will be called. In this case, we use the <code>Clients.All.SendAsync()</code> method to send a message to all connected clients. The <code>Context.User.Identity.Name</code> property is used to get the username of the current user.</p>
<p>The following code shows how to override the <code>OnDisconnectAsync()</code> method:</p>
<pre class="source-code">
public override async Task OnDisconnectedAsync(Exception? exception){
    await Clients.All.SendAsync("UserDisconnected", Context.User.Identity.Name);
    await base.OnDisconnectedAsync(exception);
}</pre>
<p>Then, we can update the TypeScript client to handle the <code>UserConnected</code> and <code>UserDisconnected</code> events. The following code shows how to handle the <code>UserConnected</code> event in the TypeScript client:</p>
<pre class="source-code">
connection.on("UserConnected", (username: string) =&gt; {  const li = document.createElement("li");
  li.textContent = `${username} connected`;
  const messageList = document.getElementById("messages");
  messageList.appendChild(li);
  messageList.scrollTop = messageList.scrollHeight;
});
connection.on("UserDisconnected", (username: string) =&gt; {
  const li = document.createElement("li");
  li.textContent = `${username} disconnected`;
  const messageList = document.getElementById("messages");
  messageList.appendChild(li);
  messageList.scrollTop = messageList.scrollHeight;
});</pre>
<p>The code <a id="_idIndexMarker1490"/>in the Blazor client is very similar:</p>
<pre class="source-code">
_hubConnection.On&lt;string&gt;("UserConnected", (username) =&gt;{
    var encodedMessage = $"{username} connected.";
    _messages.Add(encodedMessage);
    StateHasChanged();
});
_hubConnection.On&lt;string&gt;("UserDisconnected", (username) =&gt;
{
    var encodedMessage = $"{username} disconnected.";
    _messages.Add(encodedMessage);
    StateHasChanged();
});</pre>
<p>Now, we can run the SignalR server and the two clients. You should see the user’s connected and disconnected messages in the chat window. If you refresh the page or close the browser tab, you should see a user-disconnected message, as shown next:</p>
<div><div><img alt="Figure 13.8 – User-connected and -disconnec﻿ted messages" src="img/B18971_13_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – User-connected and -disconnec<a id="_idTextAnchor563"/>ted messages</p>
<p>Next, we will <a id="_idIndexMarker1491"/>add a feature to allow users to send a message to a specific user.</p>
<h2 id="_idParaDest-295"><a id="_idTextAnchor564"/>Sending a message to a specific user</h2>
<p>The <a id="_idIndexMarker1492"/>next feature we want to add is to allow users to send a message to a specific user. To do so, we need to know to whom the message is sent. SignalR uses a <code>ClaimTypes.NameIdentifier</code> claim to differentiate users. To simplify the code, we will pass the username as the target user:</p>
<pre class="source-code">
public Task SendMessageToUser(string user, string toUser, string message){
    return Clients.User(toUser).SendAsync("ReceiveMessage", user, message);
}</pre>
<p>The preceding code uses the <code>Clients.User(user)</code> method to find the connection of the specified user.</p>
<p>Next, update the TypeScript client to add a textbox to enter the target username. The following code shows how to update the HTML content for the <code>divChat</code> element:</p>
<pre class="source-code">
&lt;label for="txtToUser"&gt;To&lt;/label&gt;&lt;input type="text" id="txtToUser" /&gt;</pre>
<p>Then, we can <a id="_idIndexMarker1493"/>invoke this method from the TypeScript client as follows:</p>
<pre class="source-code">
function sendMessage() {  // If the txtToUser field is not empty, send the message to the user
  if (txtToUser.value) {
    connection
      .invoke("SendMessageToUser", lblUsername.textContent, txtToUser.value, txtMessage.value)
      .catch((err) =&gt; console.error(err.toString()))
      .then(() =&gt; (txtMessage.value = ""));
  } else {
    connection
      .invoke("SendMessage", lblUsername.textContent, txtMessage.value)
      .catch((err) =&gt; console.error(err.toString()))
      .then(() =&gt; (txtMessage.value = ""));
  }
}</pre>
<p>In the preceding code, when the <code>txtToUser</code> field is not empty, we use the <code>SendMessageToUser()</code> method to send a message to a specified user. Otherwise, we use the <code>SendMessage()</code> method to send a message to all connected users.</p>
<p>The code in the Blazor client is very similar:</p>
<pre class="source-code">
private async Task SendMessage(){
    if (_hubConnection != null &amp;&amp; IsConnected)
    {
        if (!string.IsNullOrWhiteSpace(_toUser))
        {
            await _hubConnection.InvokeAsync("SendMessageToUser", _username, _toUser, _message);
        }
        else
        {
            await _hubConnection.InvokeAsync("SendMessage", _username, _message);
        }
        _message = string.Empty;
    }
}</pre>
<p>Please refer to the sample application for the complete code.</p>
<p>Run<a id="_idIndexMarker1494"/> the three applications. This time, we need to open three browser tabs for testing. Use three different usernames to log in to the three clients. Then, we can send a message to a specific user, as shown next:</p>
<div><div><img alt="Figure 13.9 – Sending a message to a specific user" src="img/B18971_13_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – Sending a message to a specific user</p>
<p>In <em class="italic">Figure 13</em><em class="italic">.9</em>, we sent a message to the <code>user1</code> user from <code>user2</code>. You can see that the message is displayed in the <code>user1</code> browser tab but not in the <code>user3</code> browser tab.</p>
<p>You can try<a id="_idIndexMarker1495"/> to log in to the same username in different browser tabs. You will find that both browser tabs will receive the message. This is because SignalR uses the <code>ClaimTypes.NameIdentifier</code> claim to differentiate users. Each browser tab has a different SignalR<a id="_idTextAnchor565"/> connection, but they use the same username. Therefore, SignalR will treat them as the same user.</p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor566"/>Using strongly typed hubs</h2>
<p>So far, we have <a id="_idIndexMarker1496"/>added a couple of methods to the <code>ChatHub</code> class:</p>
<pre class="source-code">
public Task SendMessage(string user, string message){
    await Clients.All.SendAsync("ReceiveMessage", user, message);
}
public Task SendMessageToUser(string user, string toUser, string message)
{
    return Clients.User(toUser).SendAsync("ReceiveMessage", user, message);
}
public override async Task OnConnectedAsync()
{
    await Clients.All.SendAsync("UserConnected", Context.User.Identity.Name);
    await base.OnConnectedAsync();
}
public override async Task OnDisconnectedAsync(Exception? exception)
{
    await Clients.All.SendAsync("UserDisconnected", Context.User.Identity.Name);
    await base.OnDisconnectedAsync(exception);
}</pre>
<p>Each <a id="_idIndexMarker1497"/>method calls the <code>SendAsync()</code> method with a string parameter. The string parameter is the name of the method to be invoked on the client. The <code>SendAsync()</code> method is a dynamic method, but it is not type-safe. If we misspell the method name, the compiler will not report any error. To improve type safety, we can use strongly typed hubs.</p>
<p>To use strongly typed hubs, we need to define a hub interface that contains client methods. The following code shows how to define a hub interface:</p>
<pre class="source-code">
public interface IChatClient{
    Task ReceiveMessage(string user, string message);
    Task UserConnected(string user);
    Task UserDisconnected(string user);
}</pre>
<p>Then, we can update the <code>ChatHub</code> class to implement the <code>IChatClient</code> interface:</p>
<pre class="source-code">
public class ChatHub : Hub&lt;IChatClient&gt;{
    public Task SendMessage(string user, string message)
    {
        return Clients.All.ReceiveMessage(user, message);
    }
    public Task SendMessageToUser(string user, string toUser, string message)
    {
        return Clients.User(toUser).ReceiveMessage(user, message);
    }
    public override async Task OnConnectedAsync()
    {
        await Clients.All.UserConnected(Context.User.Identity.Name);
        await base.OnConnectedAsync();
    }
    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        await Clients.All.UserDisconnected(Context.User.Identity.Name);
        await base.OnDisconnectedAsync(exception);
    }
}</pre>
<p>In the <a id="_idIndexMarker1498"/>preceding code, the <code>SendAsync()</code> method is no longer used. Instead, we use the <code>RecieveMessage()</code>, <code>UserConnected()</code>, and <code>UserDisconnected()</code> methods defined in the <code>IChatClient</code> interface. The <code>Hub</code> class is generic, so we need to specify the <code>IChatClient</code> interface as the generic type argument. Now, the <code>ChatHub</code> class is strongly typed. Note that if you use a strongly typed hub, the<a id="_idTextAnchor567"/> <code>SendAsync()</code> method is no longer available.</p>
<p>Next, we will add a feature to allow users to join groups.</p>
<h2 id="_idParaDest-297"><a id="_idTextAnchor568"/>Joining groups</h2>
<p>SignalR allows<a id="_idIndexMarker1499"/> users to join groups. The <code>Hub</code> class has a <code>Groups</code> property to manage groups. The type of the <code>Groups</code> property is the <code>IGroupManager</code> interface, which provides methods such as <code>AddToGroupAsync()</code>, <code>RemoveFromGroupAsync()</code>, and so on. The following code shows how to add a user to a group and remove a user from a group:</p>
<pre class="source-code">
public async Task AddToGroup(string user, string group){
    await Groups.AddToGroupAsync(Context.ConnectionId, group);
    await Clients.Group(group).ReceiveMessage(Context.User.Identity.Name,
        $"{user} has joined the group {group}. Connection Id: {Context.ConnectionId}");
}
public async Task RemoveFromGroup(string user, string group)
{
    await Groups.RemoveFromGroupAsync(Context.ConnectionId, group);
    await Clients.Group(group).ReceiveMessage(Context.User.Identity.Name,
                   $"{user} has left the group {group}. Connection Id: {Context.ConnectionId}");
}</pre>
<p>In the preceding code, we use the <code>Groups</code> property to manage groups. The <code>Context.ConnectionId</code> property is used to get the connection ID of the current user. The <code>Clients.Group</code> method is used to send a message to all users in the specified group so that they can know who has joined or left the group.</p>
<p>Next, we <a id="_idIndexMarker1500"/>need to update the UI to allow a user to enter the group name. Add the following code to the HTML content for the <code>divChat</code> element:</p>
<pre class="source-code">
&lt;label id="lblToGroup"&gt;Group&lt;/label&gt;&lt;input type="text" id="txtToGroup" /&gt;
&lt;button id="btnJoinGroup"&gt;Join Group&lt;/button&gt;
&lt;button id="btnLeaveGroup"&gt;Leave Group&lt;/button&gt;</pre>
<p>Update the TypeScript code to handle <code>JoinGroup</code> and <code>LeaveGroup</code> events. The following code shows how to handle the <code>JoinGroup</code> event:</p>
<pre class="source-code">
btnJoinGroup.addEventListener("click", joinGroup);btnLeaveGroup.addEventListener("click", leaveGroup);
function joinGroup() {
  if (txtToGroup.value) {
    connection
      .invoke("AddToGroup", lblUsername.textContent, txtToGroup.value)
      .catch((err) =&gt; console.error(err.toString()))
      .then(() =&gt; {
        btnJoinGroup.disabled = true;
        btnJoinGroup.style.display = "none";
        btnLeaveGroup.disabled = false;
        btnLeaveGroup.style.display = "inline";
        txtToGroup.readOnly = true;
      });
  }
}
function leaveGroup() {
  if (txtToGroup.value) {
    connection
      .invoke("RemoveFromGroup", lblUsername.textContent, txtToGroup.value)
      .catch((err) =&gt; console.error(err.toString()))
      .then(() =&gt; {
        btnJoinGroup.disabled = false;
        btnJoinGroup.style.display = "inline";
        btnLeaveGroup.disabled = true;
        btnLeaveGroup.style.display = "none";
        txtToGroup.readOnly = false;
      });
  }
}</pre>
<p>The<a id="_idIndexMarker1501"/> preceding code shows two event handlers for the <code>JoinGroup</code> and <code>LeaveGroup</code> events, which invoke the <code>AddToGroup()</code> and <code>RemoveFromGroup()</code> methods on the SignalR hub respectively.</p>
<p>The code in the Blazor client is very similar. We will not list the code here. You can find the code in the sample application.</p>
<p>Now, the client should be able to join and leave groups. When a user joins or leaves a group, the other users in the group will receive a message, as shown next:</p>
<div><div><img alt="Figure 13.10 – Joining and leaving groups" src="img/B18971_13_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10 – Joining and leaving groups</p>
<p>In <em class="italic">Figure 13</em><em class="italic">.10</em>, <code>user3</code> joined <code>group1</code> and then left <code>group1</code>. You can see that the other <a id="_idIndexMarker1502"/>users in  <code>grou<a id="_idTextAnchor569"/>p1</code> received messages.</p>
<p>Next, we will add a feature to allow users to send a message to a specific group.</p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor570"/>Sending a message to a group</h2>
<p>The code<a id="_idIndexMarker1503"/> to send a message to a group is very similar to the code to send a message to a specific user. The following code shows how to send a message to a group in the <code>ChatHub</code> class:</p>
<pre class="source-code">
public async Task SendMessageToGroup(string user, string group, string message){
    await Clients.Group(group).ReceiveMessage(user, message);
}</pre>
<p>The preceding code uses <code>Clients.Group(group)</code> to find connections of the users in the specified group. Then, it uses the <code>ReceiveMessage()</code> method defined in the <code>IChatClient</code> interface to send a message to users in the group.</p>
<p>The<a id="_idIndexMarker1504"/> Blazor client can invoke this method as follows:</p>
<pre class="source-code">
private async Task SendMessage(){
    if (_hubConnection != null &amp;&amp; IsConnected)
    {
        if (!string.IsNullOrWhiteSpace(_group) &amp;&amp; _isJoinedGroup)
        {
            await _hubConnection.InvokeAsync("SendMessageToGroup", _username, _group, _message);
        }
        // Omitted for brevity
    }
}</pre>
<p>We will not list the code for the TypeScript client here. You can find the code in the sample application.</p>
<p>Now, the client should be able to send a message to a specific group. The following figure shows how to send a message to a group:</p>
<div><div><img alt="Figure 13.11 – Sending a message to a group" src="img/B18971_13_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.11 – Sending a message to a group</p>
<p>You will see a <a id="_idIndexMarker1505"/>message displayed for <code>user1</code> and <code>user3</code> as<a id="_idTextAnchor571"/> they are in the same group. But <code>user2</code> and <code>user4</code> will not see the message because they are not in <code>group1</code>.</p>
<h1 id="_idParaDest-299"><a id="_idTextAnchor572"/>Sending messages from other services</h1>
<p>So far, we have<a id="_idIndexMarker1506"/> implemented a chat app that allows users to send messages to other users or groups. Sometimes, we need to send messages from other places. For example, when an event occurs, we may need to send a message to notify the users. In this section, we will explore how to send messages from other services. You can find the complete code of the sample in the <code>chapter13/v4</code> folder of the GitHub repository.</p>
<p>We will add a REST API endpoint to allow other systems to send messages to the SignalR hub. Follow these steps to add a REST API endpoint in the <code>ChatApp.Server</code> application:</p>
<ol>
<li>Create the following models in the <code>Models</code> folder:<pre class="source-code">
public class SendToAllMessageModel{    public string FromUser { get; set; } = string.Empty;    public string Message { get; set; } = string.Empty;}public class SendToUserMessageModel{    public string FromUser { get; set; } = string.Empty;    public string ToUser { get; set; } = string.Empty;    public string Message { get; set; } = string.Empty;}public class SendToGroupMessageModel{    public string FromUser { get; set; } = string.Empty;    public string GroupName { get; set; } = string.Empty;    public string Message { get; set; } = string.Empty;}</pre><p class="list-inset">These <a id="_idIndexMarker1507"/>models are used to send messages to the SignalR hub.</p></li> <li>Create a new controller or use the existing <code>AccountController</code> class in the sample application. We will create a <code>ChatController</code> class in the <code>Controllers</code> folder.</li>
<li>Inject the <code>IHubContext&lt;ChatHub</code>, <code>IChatClient&gt;</code> service into the <code>ChatController</code> class:<pre class="source-code">
[Route("api/[controller]")][ApiController]public class ChatController(IHubContext&lt;ChatHub, IChatClient&gt; hubContext) : ControllerBase{}</pre><p class="list-inset">The <code>IHubContext&lt;ChatHub, IChatClient&gt;</code> service is used to send messages <a id="_idIndexMarker1508"/>to clients. In this example, we use a strongly typed hub. You can also inject the <code>IHubContext&lt;ChatHub&gt;</code> service if you use a normal SignalR hub.</p></li> <li>Add the following actions to send messages to all users, a specific user, and a specific group:<pre class="source-code">
 [HttpPost("/all")] public async Task&lt;IActionResult&gt; SendToAllMessage([FromBody] SendToAllMessageModel model) {     if (ModelState.IsValid)     {         await hubContext.Clients.All.ReceiveMessage(model.FromUser, model.Message);         return Ok();     }     return BadRequest(ModelState); } [HttpPost("/user")] public async Task&lt;IActionResult&gt; SendToUserMessage([FromBody] SendToUserMessageModel model) {     if (ModelState.IsValid)     {         await hubContext.Clients.User(model.ToUser).ReceiveMessage(model.FromUser, model.Message);         return Ok();     }     return BadRequest(ModelState); } [HttpPost("/group")] public async Task&lt;IActionResult&gt; SendToGroupMessage([FromBody] SendToGroupMessageModel model) {     if (ModelState.IsValid)     {         await hubContext.Clients.Group(model.GroupName).ReceiveMessage(model.FromUser, model.Message);         return Ok();     }     return BadRequest(ModelState); }</pre><p class="list-inset">The <a id="_idIndexMarker1509"/>preceding code uses the <code>hubContext.Clients</code> property to send messages to clients. Note that this endpoint is not authenticated. You can add authentication and authorization to this endpoint if required.</p><ul><li>Run the three applications. Use different users to log in and join the group. Then, you can test the <code>chat/all</code>, <code>chat/user</code>, and <code>chat/group</code> endpoints using Postman or any other HTTP client.</li></ul></li> </ol>
<p>This is how to <a id="_idTextAnchor573"/>send messages from external services. In the next section, we will explore how to manage SignalR connections.</p>
<h1 id="_idParaDest-300"><a id="_idTextAnchor574"/>Configuring SignalR hubs and clients</h1>
<p>SignalR provides a <code>HubOptions</code> class to configure SignalR hubs. Also, SignalR clients<a id="_idIndexMarker1510"/> have some configuration options. In this section, we will explore how to configure SignalR hubs <a id="_idTextAnchor575"/>and clients. You can find the complete code of the sample in the <code>chapter13/v5</code> folder of the GitHub repository.</p>
<h2 id="_idParaDest-301"><a id="_idTextAnchor576"/>Configuring SignalR hubs</h2>
<p>Here are some of <a id="_idIndexMarker1511"/>the configuration options for SignalR hubs:</p>
<ul>
<li><code>KeepAliveInterval</code>: This property determines the interval at which a keep-alive message is sent to clients. If a client does not receive a message from the server within this period of time, it will send a <code>ping</code> message to the server in order to maintain the connection. When changing this value, it is important to also adjust the <code>serverTimeoutInMilliseconds</code> or <code>ServerTimeout</code> option in the client. For best results, it is recommended to set the <code>serverTimeoutInMilliseconds</code> or <code>ServerTimeout</code> option to a value that is double the value of the <code>KeepAliveInterval</code> property. The default value of <code>KeepAliveInterval</code> is 15 seconds.</li>
<li><code>ClientTimeoutInterval</code>: This property determines the interval at which the server will consider the client disconnected if it has not received a message from the client. It is recommended to set <code>ClientTimeoutInterval</code> to a value that is double the value of the <code>KeepAliveInterval</code> property. The default value of <code>ClientTimeoutInterval</code> is 30 seconds.</li>
<li><code>EnableDetailedErrors</code>: This <a id="_idIndexMarker1512"/>property determines whether detailed error messages are sent to the client. The default value of <code>EnableDetailedErrors</code> is <code>false</code> as error messages may contain sensitive information.</li>
<li><code>MaximumReceiveMessageSize</code>: This property determines the maximum size of a message that the server will accept. The default value of <code>MaximumReceiveMessageSize</code> is 32 KB. Do not set this value to a very large value as it may cause <strong class="bold">denial-of-service</strong> (<strong class="bold">DoS</strong>) attacks<a id="_idIndexMarker1513"/> and consume a lot of memory.</li>
<li><code>MaximumParallelInvocationsPerClient</code>: This property determines the maximum number of hub method invocations that can be executed in parallel per client. The default value of <code>MaximumParallelInvocationsPerClient</code> is 1.</li>
<li><code>StreamBufferCapacity</code>: This property determines the maximum number of items that can be buffered in a client upload stream. The default value of <code>StreamBufferCapacity</code> is 10. We will introduce streaming in the next section.</li>
</ul>
<p>There are two ways to configure SignalR hubs. The first way is to provide a <code>HubOptions</code> object <a id="_idIndexMarker1514"/>to all hubs. The following code shows how to configure the <code>ChatHub</code> class:</p>
<pre class="source-code">
builder.Services.AddSignalR(options =&gt;{
    options.KeepAliveInterval = TimeSpan.FromSeconds(10);
    options.ClientTimeoutInterval = TimeSpan.FromSeconds(20);
    options.EnableDetailedErrors = true;
});</pre>
<p>The second way is to configure the SignalR hubs for each hub. The following code shows how to configure the <code>ChatHub</code> class:</p>
<pre class="source-code">
builder.Services.AddSignalR().AddHubOptions&lt;ChatHub&gt;(options =&gt;{
    options.KeepAliveInterval = TimeSpan.FromSeconds(10);
    options.ClientTimeoutInterval = TimeSpan.FromSeconds(20);
    options.EnableDetailedErrors = true;
});</pre>
<p>The preceding code is useful if you have multiple hubs and you want to configure them differently.</p>
<p>Note that if you change the <code>KeepAliveInterval</code> or <code>ClientTimeoutInterval</code> property of the SignalR hub, you need to update the <code>serverTimeoutInMilliseconds</code> or <code>ServerTimeout</code> option in the clients as well. The following code shows how to configure the TypeScript client:</p>
<pre class="source-code">
connection = new signalR.HubConnectionBuilder()  .withUrl("https://localhost:7159/chatHub", {
    // Omitted for brevity
  })
  .build();
// The following configuration must match the configuration in the server project
connection.keepAliveIntervalInMilliseconds = 10000;
connection.serverTimeoutInMilliseconds = 20000;</pre>
<p>The <code>HubConnection</code> object has the <code>keepAliveIntervalInMilliseconds</code> property and the <code>serverTimeoutInMilliseconds</code> property, which can be used to match the <a id="_idIndexMarker1515"/>configuration in the server project.</p>
<p>Similarly, you can configure the Blazor client as follows:</p>
<pre class="source-code">
_hubConnection = new HubConnectionBuilder()    .WithUrl("https://localhost:7159/chatHub", options =&gt;
    {
        // Omitted for brevity
    })
    .Build();
_hubConnection.KeepAliveInterval = TimeSpan.FromSeconds(10);
_hubConnection.ServerTimeout = TimeSpan.FromSeconds(20);
You can also configure these properties on the HubConnectionBuilder object as shown below:
_hubConnection = new HubConnectionBuilder()
    .WithUrl("https://localhost:7159/chatHub", options =&gt;
    {
        // Omitted for brevity
    })
    .WithKeepAliveInterval(TimeSpan.FromSeconds(10))
    .WithServerTimeout(TimeSpan.FromSeconds(20))
    .Build();</pre>
<p>Make sure that <a id="_idIndexMarker1516"/>the v<a id="_idTextAnchor577"/>alues of the <code>KeepAliveInterval</code> and <code>ClientTimeout/ServerTimeout</code> properties are the same in the server and the client.</p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor578"/>HTTP configuration options</h2>
<p>SignalR<a id="_idIndexMarker1517"/> can automatically negotiate the transport protocol with the client. The default transport protocol is WebSockets. If the client does not support WebSockets, SignalR will use SSE or long polling. You can configure HTTP options for SignalR. The following code shows how to configure HTTP options for the <code>ChatHub</code> class:</p>
<pre class="source-code">
app.MapHub&lt;ChatHub&gt;("/chatHub", options =&gt;{
    options.Transports = HttpTransportType.WebSockets | HttpTransportType.LongPolling;
    options.WebSockets.CloseTimeout = TimeSpan.FromSeconds(10);
    options.LongPolling.PollTimeout = TimeSpan.FromSeconds(120);
});</pre>
<p>The preceding code configures HTTP options for the <code>ChatHub</code> class using a <code>HttpConnectionDispatcherOptions</code> object. In this sample, we configured the <code>Transports</code> property to use WebSockets and long polling, but not SSE. In addition, we configured the <code>CloseTimeout</code> property of the <code>WebSockets</code> property to 10 seconds, and the <code>PollTimeout</code> property of the <code>LongPolling</code> property to 120 seconds. The default value of the <code>CloseTimeout</code> property is 5 seconds, meaning that after the server closes, the connection will be terminated if clients cannot close the connection within 5 seconds. The default value of the <code>PollTimeout</code> property is 90 seconds, meaning that the server will terminate a poll request after waiting for 90 seconds and then create a new poll request.</p>
<p>The allowed transports can be configured in the client as well. We can configure the TypeScript client as follows:</p>
<pre class="source-code">
connection = new signalR.HubConnectionBuilder()  .withUrl("https://localhost:7159/chatHub", {
    transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling,
  })
  .build();</pre>
<p>The following<a id="_idIndexMarker1518"/> code shows how to configure the Blazor client:</p>
<pre class="source-code">
_hubConnection = new HubConnectionBuilder()    .WithUrl("https://localhost:7159/chatHub", options =&gt;
    {
        options.Transports = HttpTransportType.WebSockets | HttpTransportType.LongPolling;
    })
    .Build();</pre>
<p>The <code>HttpTransportTyp<a id="_idTextAnchor579"/>e</code> enum has a <code>FlagsAttribute</code> attribute, so you can use the bitwise <code>OR</code> operator to combine multiple transport protocols.</p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor580"/>Automatically reconnecting</h2>
<p>Sometimes, due<a id="_idIndexMarker1519"/> to network issues, the SignalR connection may be disconnected. For example, if the user’s device is switched from Wi-Fi to cellular, or if the user’s device is in a tunnel, the SignalR connection may be disconnected. In this case, we want the client to automatically reconnect to the server:</p>
<ol>
<li>SignalR allows the client to automatically reconnect to the server if the connection is dropped. The following code shows how to configure the TypeScript client to automatically reconnect to the server:<pre class="source-code">
connection = new signalR.HubConnectionBuilder()  .withUrl("https://localhost:7159/chatHub", {    // Omitted for brevity  })  .withAutomaticReconnect()  .build();</pre></li> <li>Similarly, you <a id="_idIndexMarker1520"/>can configure the Blazor client as follows:<pre class="source-code">
_hubConnection = new HubConnectionBuilder()    .WithUrl("https://localhost:7159/chatHub", options =&gt;    {        // Omittted for brevity    })    .WithAutomaticReconnect()    .Build();</pre></li> <li>By default, when the connection is dropped, the client will try to reconnect to the SignalR server in 0, 2, 10, and 30 seconds. You can configure the retry policy as follows:<pre class="source-code">
connection = new signalR.HubConnectionBuilder()  .withUrl("https://localhost:7159/chatHub", {    // Omittted for brevity  })  .withAutomaticReconnect([0, 5, 20])  .build();</pre><p class="list-inset">The <code>withAutomaticReconnect()</code> method accepts an array of numbers to configure the delay duration in milliseconds. In the preceding code, the client will try to reconnect to the server in 0, 5, and 20 seconds.</p></li> <li>In the<a id="_idIndexMarker1521"/> Blazor client, you can configure the retry policy as follows:<pre class="source-code">
_hubConnection = new HubConnectionBuilder()    .WithUrl("https://localhost:7159/chatHub", options =&gt;    {        // Omitted for brevity    })    .WithAutomaticReconnect(new[] { TimeSpan.FromSeconds(0), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(20) })    .Build();</pre><p class="list-inset">The preceding code configures the same retry policy as the TypeScript client.</p></li> <li>To test the automatic reconnect feature, we can add a label to show the connection status. Add the following code to the HTML content for the <code>divChat</code> element:<pre class="source-code">
&lt;div class="form-group mb-3"&gt;  &lt;label&gt;Status&lt;/label&gt;  &lt;label id="lblStatus"&gt;&lt;/label&gt;&lt;/div&gt;</pre></li> <li>Then, update the TypeScript code to show the connection status:<pre class="source-code">
connection.onclose(() =&gt; {  lblStatus.textContent = "Disconnected.";});connection.onreconnecting((error) =&gt; {  lblStatus.textContent = `${error} Reconnecting...`;});connection.onreconnected((connectionId) =&gt; {  lblStatus.textContent = `Connected. ${connectionId}`;});await connection.start();lblStatus.textContent = `Connected. ${connection.connectionId}`;</pre></li> <li>We can <a id="_idIndexMarker1522"/>also enable debug logging to see the connection status. The following code shows how to do this:<pre class="source-code">
connection = new signalR.HubConnectionBuilder()  .withUrl("https://localhost:7159/chatHub", {    // Omitted for brevity  })  .configureLogging(signalR.LogLevel.Debug)  // Omitted for brevity</pre><p class="list-inset">You can find the complete code in the sample application.</p></li> <li>Run the SignalR server and the TypeScript client. Press <em class="italic">F12</em> to open the developer tools for the TypeScript client. Click the <strong class="bold">Network</strong> tab, and you can change network conditions to simulate network issues. For example, you can change the network to <strong class="bold">Offline</strong> to simulate network disconnection, as shown next:</li>
</ol>
<div><div><img alt="Figure 13.12 – Simulating network disconnection in Chrome developer tools" src="img/B18971_13_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.12 – Simulating network disconnection in Chrome developer tools</p>
<ol>
<li value="9">After <a id="_idIndexMarker1523"/>you change the network to <strong class="bold">Offline</strong>, wait for a few seconds (depending on the timeout configuration), and you should see the client automatically reconnect to the server, as shown next:</li>
</ol>
<div><div><img alt="Figure 13.13 – The client automatically reconnects to the server" src="img/B18971_13_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.13 – The client automatically reconnects to the server</p>
<ol>
<li value="10">Change the network back to Online, and you should see that the client reconnects to the server, as shown next:</li>
</ol>
<div><div><img alt="Figure 13.14 – The client reconnects to the server after the network is back online" src="img/B18971_13_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.14 – The client reconnects to the server after the network is back online</p>
<p class="callout-heading">Important note</p>
<p class="callout">If the client fails to reconnect to the server after trying four times, the <code>onclose</code> event will be triggered. You can add the event handler for the <code>onclose</code> event to handle the connection close event. For example, you can notify the user that the connection is closed and ask the user to refresh the page or manually reconnect to the server.</p>
<p class="list-inset">SignalR in<a id="_idIndexMarker1524"/> ASP.NET Core 8.0 supports stateful reconnect, allowing the server to temporarily store messages when the client is disconnected. Upon reconnection, the client will use the same connection ID, and the server will replay any messages that were sent while the client was disconnected. This ensures that the client’s state is maintained and that no messages are lost.</p>
<ol>
<li value="11">To enable stateful reconnect, we need to configure the <code>AllowStatefulReconnects</code> option for the SignalR hub endpoint as follows:<pre class="source-code">
app.MapHub&lt;ChatHub&gt;("/chatHub", options =&gt;{    // Omitted for brevity    options.AllowStatefulReconnects = true;});</pre></li> <li>By default, the maximum buffer size of the stateful reconnect is 100,000 bytes. You can change the buffer size as follows:<pre class="source-code">
builder.Services.AddSignalR(options =&gt;{    // Omitted for brevity    options.StatefulReconnectBufferSize = 200000;});</pre></li> <li>Then, we <a id="_idIndexMarker1525"/>can configure the TypeScript client to use the stateful reconnect as follows:<pre class="source-code">
connection = new signalR.HubConnectionBuilder()  .withUrl("https://localhost:7159/chatHub", {    // Omitted for brevity  })  .withAutomaticReconnect()  .withStatefulReconnect({ bufferSize: 200000 })  .build();</pre></li> <li>Similarly, you can configure the Blazor client as follows:<pre class="source-code">
_hubConnection = new HubConnectionBuilder()    .WithUrl("https://localhost:7159/chatHub", options =&gt;    {        // Omitted for brevity    })    .WithAutomaticReconnect()    .WithStatefulReconnect()    .Build();</pre></li> <li>To configure<a id="_idIndexMarker1526"/> the buffer size of the Blazor client, you can configure the <code>HubConnectionOptions</code> object as follows:<pre class="source-code">
var builder = new HubConnectionBuilder()    .WithUrl("https://localhost:7159/chatHub", options =&gt;    {        // Omitted for brevity    })    .WithAutomaticReconnect()    .WithStatefulReconnect();builder.Services.Configure&lt;HubConnectionOptions&gt;(options =&gt;{    options.StatefulReconnectBufferSize = 200000;});_hubConnection = builder.Build();</pre></li> </ol>
<p>Besides the automatic reconnect feature, you can also manually reconnect to the SignalR server if the conn<a id="_idTextAnchor581"/>ection is dropped. You can add an event handler for the <code>onclose</code> event or <code>Closed</code> event to handle the connection close event.</p>
<h2 id="_idParaDest-304"><a id="_idTextAnchor582"/>Scaling SignalR</h2>
<p>So far, we have<a id="_idIndexMarker1527"/> implemented a chat app that allows users to send messages to other users or groups. We have also explored how to manage SignalR connections. You can also use a similar approach to build a real-time notification system, a real-time dashboard, and so on. However, the application can only run on a single server. If we want to scale the application, for example, using a load balancer to distribute requests to multiple servers, server <em class="italic">A</em> does not know the connections on server <em class="italic">B</em>.</p>
<p>SignalR requires a <a id="_idIndexMarker1528"/>persistent connection between the client and the server. That means requests from the same client must be routed to the same server. This is called <em class="italic">sticky sessions</em> or <em class="italic">session affinity</em>. This is required if you have multiple SignalR servers. Besides this requirement, there are some other considerations when you scale SignalR:</p>
<ul>
<li>If you host the application in Azure, you can use Azure SignalR Service. Azure SignalR Service is a fully managed service that helps you scale the SignalR application without worrying about the infrastructure. With Azure SignalR Service, you do not need to use sticky sessions as all clients connect to Azure SignalR Service. This service takes on the responsibility of managing connections and freeing up resources on the SignalR servers. For more information, please refer to <a href="https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview">https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview</a>.</li>
<li>If you host the application on your own infrastructure or other cloud providers, you can use Redis backplane to synchronize the connections. The Redis backplane is a Redis server that uses the pub/sub feature to forward messages to other SignalR servers. However, this approach requires sticky sessions for most cases, and the SignalR application instances require additional resources to manage connections. There are some other SignalR backplane providers, such as SQL Server, NCache, and so on.<a id="_idTextAnchor583"/></li>
</ul>
<p>We will not cover details of how to scale SignalR in this book. You can find more information in the official documentation.</p>
<h1 id="_idParaDest-305"><a id="_idTextAnchor584"/>Summary</h1>
<p>SignalR is a powerful library that simplifies the process of building real-time web applications. In this chapter, we explored how to use SignalR to build a chat app. We introduced basic concepts of SignalR, such as hubs, clients, and connections. We created clients using TypeScript and Blazor, which demonstrated how to use both TypeScript and .NET to build SignalR clients. We also discussed how to send messages to a specific user or group and how to secure SignalR connections using JWT authentication. Additionally, we explored how to configure SignalR hubs and clients, such as configuring the keep-alive interval, configuring HTTP options, and configuring the automatic reconnect feature.</p>
<p>Although we have covered a lot of features, there is still more to explore, such as streaming. For more information, please refer to the official documentation: <a href="https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction">https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction</a>. In the next chapter, we will explore how to deploy ASP.NET Core applications.</p>
</div>
</body></html>