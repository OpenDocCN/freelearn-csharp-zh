- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Handling Data for Each Microservice with the Database per Service Pattern
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库-按服务模式处理每个微服务的数据
- en: In the previous chapter, we explored the concepts of event sourcing and event
    stores. Event sourcing patterns help us to reconcile changes made to our data
    stores across our microservices. An operation in one microservice might require
    that data be sent to other microservices. For efficiency reasons, we create an
    event store as an intermediary area to which microservices can subscribe for changes
    and will be able to get the latest version of the data as needed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了事件溯源和事件存储的概念。事件溯源模式帮助我们协调微服务之间数据存储的更改。一个微服务的操作可能需要将数据发送到其他微服务。出于效率的考虑，我们创建一个事件存储作为中介区域，微服务可以订阅更改，并能够在需要时获取数据的最新版本。
- en: This concept revolves around the assumption that each microservice has its own
    database. This is the recommended approach in a microservice architecture, given
    the fundamental requirement that each microservice needs to be autonomous in its
    operations and data requirements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念围绕着每个微服务都有自己的数据库的假设。在微服务架构中，考虑到每个微服务在操作和数据需求上的基本要求，即每个微服务需要在其操作和数据需求上保持自主性，这是一种推荐的方法。
- en: Building on this notion, we will explore best practices and techniques for handling
    data for each microservice.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个概念的基础上，我们将探讨处理每个微服务数据的最佳实践和技术。
- en: 'After reading this chapter, you will know how to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，你将了解以下内容：
- en: How to make use of the Database-per-Service pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用数据库-per-Service模式
- en: How to develop a database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何开发数据库
- en: How to implement the repository pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现存储库模式
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code references used in this chapter can be found in the project repository,
    which is hosted on GitHub at [https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch07](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch07).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码参考可以在项目仓库中找到，该仓库托管在GitHub上，网址为[https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch07](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch07)。
- en: How to make use of the Database-Per-Service pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何利用数据库-按服务模式
- en: A core characteristic of microservices architecture is loose coupling between
    our services. We need to maintain the independence and individuality of each service
    and allow them to autonomously interact with the data they need when they need
    it. We want to ensure that one service’s manipulation of data does not inhibit
    another service’s ability to use its own data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的一个核心特征是我们服务之间的松散耦合。我们需要保持每个服务的独立性和个性，并允许它们在需要时自主地与所需数据交互。我们希望确保一个服务对数据的操作不会妨碍另一个服务使用其自己的数据。
- en: Each microservice will be left to define its own data access layers and parameters
    and, unless deliberately implemented, no two services will have direct access
    to the same data store. Data is not persisted across two services and the overall
    decoupling that comes with this pattern means that one database failure will not
    inhibit the operation of the other services.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务将被留给定义自己的数据访问层和参数，除非故意实现，否则没有两个服务将直接访问相同的数据存储。数据不会在两个服务之间持久化，并且这种模式带来的整体解耦意味着一个数据库的故障不会妨碍其他服务的操作。
- en: We also need to bear in mind that microservices architecture allows us to select
    different development technologies that best meet the needs of the service being
    implemented. Different technologies tend to work better with or support specific
    databases. Therefore, this pattern may be more of a requirement than a suggestion
    given that we will want to use the best database technology to support the needs
    of a service.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要记住，微服务架构允许我们选择最适合实现的服务开发技术。不同的技术往往与特定的数据库配合得更好或支持特定的数据库。因此，鉴于我们希望使用最佳数据库技术来支持服务的需求，这个模式可能更像是需求而不是建议。
- en: As usual, where there is a pro, there is a con. We need to consider the costs
    involved with this kind of heterogenous architecture and how we might need to
    adapt our knowledge base and team to support several databases and, by extension,
    various database technologies. We now have to account for additional maintenance,
    backup, and tuning operations, which might lead to maintenance overheads.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，有得必有失。我们需要考虑这种异构架构的成本，以及我们可能需要如何调整我们的知识库和团队以支持多个数据库，以及由此扩展的各种数据库技术。现在我们必须考虑到额外的维护、备份和调优操作，这可能会导致维护成本增加。
- en: There are several approaches that can be taken in implementing this pattern
    and some of the approaches reduce our infrastructure needs and help us to save
    costs. We discuss those options in the next section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施这种模式时，可以采取几种方法，其中一些方法可以减少我们的基础设施需求并帮助我们节省成本。我们将在下一节讨论这些选项。
- en: A single database technology per service
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个服务一个数据库技术
- en: 'Ultimately, we need to establish clear boundaries between the source of truth
    for each service. This doesn’t mean that you absolutely need to have different
    databases, but you can take advantage of features of relational data stores such
    as the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们需要为每个服务的真理来源建立清晰的界限。这并不意味着你绝对需要不同的数据库，但你可以利用如下关系数据存储的功能：
- en: '**Tables-per-service**: We can define tables that are optimized for the data
    to be stored for each service. We will model these tables in the microservice
    code and ensure that we only include these tables. In this model, it is common
    that some tables are denormalized representations of data that can be found in
    other tables, as the service they are created for requires the data in this format.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按服务表**：我们可以定义针对每个服务存储的数据进行优化的表。我们将在微服务代码中建模这些表，并确保我们只包括这些表。在这个模型中，常见的情况是某些表是其他表中可以找到的数据的非规范化表示，因为为该服务创建的表需要以这种格式存储数据。'
- en: '**Schema-per-service**: Relational databases allow us to specify schema values
    to categorize our tables. A schema is an organizational unit in a database that
    helps us to categorize tables. We can use these to organize tables per service.
    Like the **tables-per-service** pattern, the tables in each schema are optimized
    based on the needs of the matching microservice. We also have a better opportunity
    to tune access rights and restrictions per schema and reduce the security administration
    overhead.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按服务模式**：关系数据库允许我们指定模式值来分类我们的表。模式是数据库中的一个组织单元，帮助我们分类表。我们可以使用这些来按服务组织表。类似于**按服务表**模式，每个模式中的表都是基于匹配的微服务需求进行优化的。我们还有机会根据模式调整访问权限和限制，从而减少安全管理的成本。'
- en: '**Database-per-service**: Each microservice has its own database. This can
    be taken a step further by placing each database on its own server to reduce the
    infrastructural dependencies.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按服务数据库**：每个微服务都有自己的数据库。可以通过将每个数据库放置在其自己的服务器上来进一步减少基础设施依赖。'
- en: '*Figure 7.1* shows multiple services connected to one database.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.1*显示了多个服务连接到一个数据库。'
- en: '![Figure 7.1 – Multiple services share one database, but schemas are created
    for each service to preserve segregation and data autonomy](img/Figure_7.1_B19100.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 多个服务共享一个数据库，但为每个服务创建模式以保持隔离和数据自治](img/Figure_7.1_B19100.jpg)'
- en: Figure 7.1 – Multiple services share one database, but schemas are created for
    each service to preserve segregation and data autonomy
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 多个服务共享一个数据库，但为每个服务创建模式以保持隔离和数据自治
- en: Implementing tables and schemas per service has the lowest resource requirements
    since it would be the same thing as building one application on top of one database.
    The downside is that we retain a single point of failure and do not adequately
    scale the varied service demands.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 按服务实现表和模式具有最低的资源需求，因为这相当于在单个数据库上构建一个应用程序。缺点是我们保留了一个单点故障，并且没有充分地扩展各种服务需求。
- en: In the **Database per Service** approach, we can still use one server but provision
    each microservice with its own database. This approach matches the name of the
    pattern more appropriately, but infrastructurally maintains a common choke point
    that has all the databases on the same server. The most appropriate implementation
    to maintain service autonomy and reduce infrastructural dependencies would be
    to have each database and its reliant microservice in its own fault domain.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在**数据库按服务**的方法中，我们仍然可以使用一个服务器，但为每个微服务提供自己的数据库。这种方法更符合模式的名字，但在基础设施上仍然保持了一个共同的瓶颈，即所有数据库都在同一个服务器上。为了保持服务自治并减少基础设施依赖，最合适的实现是将每个数据库及其依赖的微服务放在自己的故障域中。
- en: Looking at this issue from another dimension, we can see that we have the flexibility
    to choose the best database technology for each service. Some services might favor
    a relational data store, while others might use a document data store more efficiently.
    We will discuss this further in the next section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个维度来看这个问题，我们可以看到我们有灵活性，为每个服务选择最好的数据库技术。一些服务可能更倾向于关系型数据存储，而其他服务可能更有效地使用文档数据存储。我们将在下一节进一步讨论这个问题。
- en: Using different database technologies per service
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个服务使用不同的数据库技术
- en: Databases are the foundation of any application. A good or poor database design
    can determine how efficient your application is, how easily it can be extended,
    and how efficiently you can write your code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是任何应用程序的基础。良好的或差的数据库设计可以决定你的应用程序效率如何，它是否容易扩展，以及你编写代码的效率如何。
- en: The use of the database-per-service pattern allows us to choose the best database
    for the operation that each microservice might complete. It would be ideal for
    a more homogenous technology stack that all developers can identify with and easily
    maintain. Attempting to remain homogenous, however, has led to shortcuts and extensive
    integration projects in the past, where the need to use one technology overshadowed
    the opportunity to use the best technology for the problem being addressed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库按服务模式允许我们为每个微服务可能完成的操作选择最好的数据库。对于一个更同质化的技术栈，所有开发者都能认同并轻松维护，这将是理想的。然而，试图保持同质化在过去导致了捷径和广泛的集成项目，其中使用一种技术的需求掩盖了使用最佳技术解决问题的机会。
- en: '*Figure 7.2* shows multiple services connected to individual databases.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.2* 显示了多个服务连接到各自的数据库。'
- en: '![Figure 7.2 – Multiple services can be built using different technologies
    alongside the most appropriate development framework technology](img/Figure_7.2_B19100.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 可以使用不同的技术构建多个服务，同时使用最合适的发展框架技术](img/Figure_7.2_B19100.jpg)'
- en: Figure 7.2 – Multiple services can be built using different technologies alongside
    the most appropriate development framework technology
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 可以使用不同的技术构建多个服务，同时使用最合适的发展框架技术
- en: Microservices allow us to have multiple teams that can choose the best technology
    stack to implement the solution and, by extension, they can use the best type
    of database technology to complement the technology and the problem. Some development
    frameworks tend to work best with certain database technologies, and this makes
    it easier to select the entire stack that is to be used for a particular microservice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务允许我们拥有多个团队，这些团队可以选择最佳技术栈来实现解决方案，并且通过扩展，他们可以使用最佳类型的数据库技术来补充技术和问题。一些开发框架与某些数据库技术配合得最好，这使得选择用于特定微服务的整个堆栈变得更容易。
- en: Now that we have reviewed our database-per-service options, let us review some
    disadvantages of using this development pattern for our microservices architecture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经审查了数据库按服务选项，让我们来回顾一下使用这种开发模式为我们的微服务架构带来的缺点。
- en: Disadvantages of this pattern
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这种模式的缺点
- en: 'We could spend all day singing the praises of this pattern and pointing out
    why it is the ideal path to take during the microservices development process.
    Despite all these advantages, however, we can point to potential pitfalls that
    we must overcome or learn to mitigate during runtime:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以整天歌颂这种模式，指出为什么它在微服务开发过程中是理想的路径。然而，尽管有所有这些优点，我们仍然可以指出潜在的陷阱，我们必须在运行时克服或学会减轻：
- en: '**Additional costs**: When we talk about having fewer infrastructural dependencies
    between our services, we talk about introducing more robust networking software
    and hardware, more servers, and more software licenses for the supporting software.
    Using a cloud platform might more easily offset some of the infrastructural and
    software costs, but even this approach will have a modest price tag.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外成本**：当我们谈论减少服务之间的基础设施依赖时，我们谈论的是引入更健壮的网络软件和硬件、更多的服务器以及更多支持软件的软件许可证。使用云平台可能更容易抵消一些基础设施和软件成本，但即使是这种方法也会有一个适度的价格标签。'
- en: '**Heterogenous development stack**: This is an advantage from the perspective
    of attempting to meet the business needs of the microservice as appropriately
    as possible. The bigger picture, however, comes when we need to source talent
    to maintain certain technologies that might have been used. Cross-training between
    teams is recommended but not always effective and a company can risk having a
    microservice built by past staff members that none of the current ones can maintain.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异构开发堆栈**：从尽可能适当地满足微服务的业务需求的角度来看，这是一个优势。然而，当我们需要寻找维护可能被使用的技术的人才时，更大的问题出现了。团队之间的交叉培训是推荐的，但并不总是有效的，公司可能会面临由过去员工构建的微服务，而当前员工无法维护的风险。'
- en: '**Data synchronization**: We have already discussed the issue of **Eventual
    Consistency**, which leads us down the path of implementing contingencies to deal
    with data being out of sync across multiple databases. This comes with additional
    code and infrastructure overhead to properly implement it.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据同步**：我们已经讨论了**最终一致性**的问题，这导致我们需要实施应急措施来处理多个数据库之间数据不一致的情况。这需要额外的代码和基础设施开销来正确实现。'
- en: '**Transactional handling**: We are unable to ensure ACID transactions across
    databases, which can lead to inconsistent data between data stores. This will
    lead us to need another coding pattern called the **Saga Pattern**, which we will
    discuss further in the next chapter.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务处理**：我们无法确保数据库之间的ACID事务，这可能导致数据存储之间出现不一致的数据。这将导致我们需要另一个名为** Saga 模式**的编码模式，我们将在下一章中进一步讨论。'
- en: '**Communication failure**: Because one microservice cannot directly access
    another’s database, we may need to introduce synchronous microservice communication
    to complete an operation. This introduces more potential failure points in the
    operation at hand. These can be mitigated using the **Circuit Breaker Pattern**,
    which will be discussed in subsequent chapters.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信失败**：由于一个微服务无法直接访问另一个的数据库，我们可能需要引入同步微服务通信来完成操作。这会在当前操作中引入更多的潜在故障点。这些可以通过**断路器模式**来缓解，我们将在后续章节中讨论。'
- en: It is always important to remember that with every pattern, we have pros and
    cons. We should never do an implementation solely because it is the *recommended
    way to go*. We should always properly assess the problems that need to be addressed
    and choose the most appropriate solutions and patterns to ensure full coverage
    and at the best price.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住，每个模式都有其优缺点。我们绝不应该仅仅因为它是*推荐的做法*就进行实施。我们应该始终正确评估需要解决的问题，并选择最合适的解决方案和模式，以确保全面覆盖并以最佳价格实现。
- en: Now that we have discussed the dos and don’ts for our Database-per-Service pattern,
    let us move on to discuss best practices when designing a database.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了数据库按服务模式的做法和禁忌，让我们继续讨论设计数据库时的最佳实践。
- en: Developing a database
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发数据库
- en: The ability to develop a capable database is paramount to a developer’s career.
    This role was once given to the database developer in a team, whose sole purpose
    was to do all things database. The application developer would simply write code
    to interact with the database based on the application’s needs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个功能强大的数据库对于开发者的职业生涯至关重要。这个角色曾经由团队中的数据库开发者承担，其唯一目的是处理所有数据库相关的事务。应用程序开发者只需根据应用程序的需求编写代码与数据库进行交互。
- en: More recently, the role of a typical application developer evolved into what
    is now called a *full stack developer* role. This means that the modern developer
    needs to have as much application development knowledge as they do database development
    knowledge. It is now very common to see teams of two to three developers who work
    on a microservice team, and who can develop and maintain the user interface, application
    code, and database.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，典型应用程序开发者的角色演变成了现在所说的 *全栈开发者* 角色。这意味着现代开发者需要具备与数据库开发知识相当的应用程序开发知识。现在，看到由两到三名开发者组成的团队在微服务团队中工作，他们可以开发和维护用户界面、应用程序代码和数据库是非常常见的。
- en: Developing a database transcends one’s comfort level with the technology being
    used. In fact, that is the easy part. Many developers neglect to consult the business
    and fully understanding the business requirements before they start implementing
    the technology. This often leads to poor design and rework, and additional maintenance
    in the lifetime of the application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 开发数据库超出了对所使用技术的舒适度。实际上，那只是容易的部分。许多开发者在开始实施技术之前，往往忽视咨询业务和充分理解业务需求。这通常会导致设计不佳、返工以及应用程序生命周期中的额外维护。
- en: Since we are in the realm of microservices, we have the unique opportunity to
    build much smaller, target data stores, for tranches of the entire application.
    This makes it easier for us to ingest and analyze the storage needs of the service
    that we are focusing on and reduces the overall complexity of building a large
    database as a catch-all, thus reducing the margin for error during the design
    phase. As discussed previously, we can make better choices about the most appropriate
    database, which influences the design considerations that we make.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处于微服务领域，我们有独特的机遇来构建更小的、针对整个应用程序的各个片段的数据存储。这使得我们更容易摄入和分析我们关注的服务的存储需求，并减少了构建大型数据库作为万能解决方案的整体复杂性，从而在设计阶段减少了出错的可能性。正如之前讨论的，我们可以做出更好的选择，选择最合适的数据库，这会影响我们做出的设计考虑。
- en: Some services need relational integrity based on the nature of the data they
    process; others need to produce results fast more than they need to be accurate;
    some only need a key-value store. In the next section, we will compare the pros
    and cons of relational and non-relational data stores and when it is best to use
    each one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务需要基于他们处理的数据的性质进行关系完整性；其他服务需要快速产生结果，而不仅仅是准确性；有些只需要键值存储。在下一节中，我们将比较关系型和非关系型数据存储的优缺点，以及何时最好使用每种类型。
- en: Databases are an integral part of how well an application performs and it is
    important to make the correct decision on which technology is used for which microservice.
    In the next section, start by assessing the pros and cons of using relational
    databases.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是应用程序性能的一个重要组成部分，因此对于哪个微服务使用哪种技术做出正确的决策非常重要。在下一节中，首先评估使用关系型数据库的优缺点。
- en: Relational databases
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: Relational databases have been a mainstay for years. They have dominated the
    database technology landscape for some time and for good reason. They are built
    on rigid principles that complement clean and efficient data storage while ensuring
    a degree of accuracy in what is stored.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库多年来一直是主流。它们在数据库技术领域占据主导地位一段时间了，而且有很好的理由。它们建立在严格的原则之上，这些原则补充了干净高效的数据存储，同时确保存储内容的准确性。
- en: 'Some of the most popular relational database management systems include the
    following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最受欢迎的关系型数据库管理系统包括以下内容：
- en: '**SQL Server**: This is Microsoft’s flagship relational database management
    system, which is widely used by individuals and enterprises alike for application
    development.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL Server**: 这是微软的旗舰关系型数据库管理系统，被个人和企业广泛用于应用程序开发。'
- en: '**MySQL / MariaDB**: MySQL is a traditionally open source and free-to-use database
    management system that is mostly used for PHP development. MariaDB was forked
    from the original MySQL code base and is maintained by a community of developers
    to maintain the free-to-use policy.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MySQL / MariaDB**: MySQL 是一个传统的开源且免费使用的数据库管理系统，主要用于 PHP 开发。MariaDB 是从原始 MySQL
    代码库分叉出来的，并由一群开发者维护以保持免费使用政策。'
- en: '**PostgreSQL**: A free and open source database management system that is robust
    enough to handle a wide range of workloads, from individual projects to data warehouses.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL**: 这是一个免费且开源的数据库管理系统，足够强大，可以处理从个人项目到数据仓库的各种工作负载。'
- en: '**Oracle Database**: This is Oracle Corporation’s flagship database management
    system, which is designed to handle a wide range of operations, from real-time
    transaction processing to data warehousing and even mixed workloads.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle数据库**：这是Oracle公司旗舰数据库管理系统，旨在处理各种操作，从实时事务处理到数据仓库，甚至混合工作负载。'
- en: '**IBM DB2**: Developed by IBM on top of one of the most reliable systems for
    high transaction and traffic enterprise settings. This database supports relational
    and object-relational structures.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IBM DB2**：由IBM在为高交易量和流量企业设置中最可靠的系统之上开发。该数据库支持关系型和对象关系型结构。'
- en: '**SQLite**: A free and lightweight database storage option for a quick and
    easy database. Unlike most alternatives that require a server, oftentimes a dedicated
    machine, SQLite databases can live in the same filesystem as the app it is being
    integrated into, making it an excellent choice for mobile-first apps.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQLite**：一个免费且轻量级的数据库存储选项，用于快速便捷的数据库。与大多数需要服务器（有时是专用机器）的替代方案不同，SQLite数据库可以与它被集成的应用程序位于同一文件系统中，使其成为移动优先应用程序的绝佳选择。'
- en: Through a process called *normalization*, data is efficiently shared across
    multiple tables, with references or *indexes* created between each table. Good
    design principles encourage you to have a *primary key* column present in each
    table, which will always have a unique value, to uniquely identify a record. This
    unique value is then referenced by other tables in the form of a *foreign key*,
    which helps to reduce the number of times data repeats across tables.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过称为*规范化*的过程，数据可以在多个表中有效地共享，每个表之间创建引用或*索引*。良好的设计原则鼓励你在每个表中都有一个*主键*列，该列将始终具有唯一值，以唯一标识一条记录。然后，其他表通过*外键*的形式引用这个唯一值，这有助于减少数据在表间重复的次数。
- en: These simple references go a long way to ensure that the data is accurate across
    tables. Once this association is created between the primary and foreign keys,
    we have created what we call a *relationship*, which introduces a *constraint*
    or restriction on what values are possible in the foreign key column. This is
    also referred to as *referential integrity.*
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的引用可以确保数据在表格之间保持准确。一旦在主键和外键之间建立了这种关联，我们就创建了我们所说的*关系*，这为外键列中可能存在的值引入了*约束*或限制。这也被称为*引用完整性*。
- en: 'Relationships can be further defined by their *cardinality*. This refers to
    the nature by which the primary key values will be referenced in the other table.
    The most common cardinalities are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关系可以通过它们的*基数*进一步定义。这指的是主键值将在其他表中如何被引用的性质。最常见的基数如下：
- en: '**One-to-one**: This means that a primary key value is referenced exactly once
    in another table as a foreign key. For instance, if a customer can only have one
    address on record. The table storing the address cannot have multiple records
    that refer to the same customer.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一**：这意味着主键值在另一个表中作为外键恰好被引用一次。例如，如果一个客户只能有一个记录在案的地址。存储地址的表不能有多个记录指向同一个客户。'
- en: '**One-to-many**: This means that the primary key value can be referenced multiple
    times in another table. For instance, if a customer has made multiple orders,
    then we have one customer’s ID referenced multiple times in the orders table.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一对一**：这意味着主键值可以在另一个表中多次引用。例如，如果一个客户下了多个订单，那么在订单表中就会有一个客户的ID被引用多次。'
- en: '**Many-to-many**: This means that a primary key can be referenced multiple
    times as a foreign key in another table, and that table’s primary key can be referenced
    multiple times in the original table. This can get confusing and implementing
    it as it is described will directly violate the referential integrity that we
    are fighting hard to maintain. This is where a *linker table* is introduced as
    an intermediary to associate the different combinations of key values from either
    table.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多对多**：这意味着主键可以在另一个表中多次作为外键被引用，并且那个表的主键也可以在原始表中多次被引用。这可能会令人困惑，并且按照描述实现它将直接违反我们努力维护的引用完整性。这就是引入*链接表*作为中介来关联来自任一表的不同键值组合的地方。'
- en: Using the example of our health care management system, if we revisit how appointments
    are tracked relative to the customer who has made them, we will see that we implemented
    a reference point between the customer’s ID, their primary key, and the appointment.
    This ensures that we do not repeat the customer’s information every time an appointment
    is booked. An appointment also cannot be created for a customer who is not already
    in the system.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的医疗管理系统为例，如果我们回顾一下相对于已预约客户的预约跟踪方式，我们会看到我们在客户的ID、他们的主键和预约之间实现了一个参考点。这确保了每次预约时我们不会重复客户的信息。也不可能为尚未在系统中存在的客户创建预约。
- en: '*Figure 7.3* shows a typical relationship.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.3* 展示了一个典型关系。'
- en: '![Figure 7.3 – An example of a one-to-many relationship where one customer
    is referenced many times in the appointments table](img/Figure_7.3_B19100.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 一个一对多关系的示例，其中一位客户在预约表中被引用多次](img/Figure_7.3_B19100.jpg)'
- en: Figure 7.3 – An example of a one-to-many relationship where one customer is
    referenced many times in the appointments table
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 一个一对多关系的示例，其中一位客户在预约表中被引用多次
- en: Many-to-many relationships do occur often and it is important to recognize them.
    Building on the example of customers and their appointments, we can expand and
    see that we also have a need to associate a customer with a room for an appointment.
    The same room is not always guaranteed, which leads us to realize that many customers
    will book appointments, and appointments might happen in many rooms. If we try
    a direct association, then details of either the customer or the room will need
    to be repeated to reflect the many possible combinations of customers, rooms,
    and appointments.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多关系确实经常发生，并且认识到它们很重要。基于客户及其预约的例子，我们可以扩展并看到我们还需要将客户与预约的房间关联起来。同一个房间并不总是保证，这让我们意识到许多客户会预约，预约可能发生在许多房间中。如果我们尝试直接关联，那么客户或房间的详细信息将需要重复，以反映客户、房间和预约的多种可能组合。
- en: Ideally, we would have a table storing rooms and the associated details, a table
    storing customers, and an appointments table sitting between the two, which seeks
    to associate them on the day as needed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们会有一个存储房间及其相关细节的表，一个存储客户的表，以及一个位于两者之间的预约表，该表旨在在需要时将它们按日关联起来。
- en: '*Figure 7.4* shows a typical many-to-many relationship.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.4* 展示了一个典型的多对多关系。'
- en: '![Figure 7.4 – An example of a many-to-many relationship where we associate
    many records from two different tables using an intermediary linker table](img/Figure_7.4_B19100.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 一个多对多关系的示例，其中我们使用一个中间链接表将两个不同表中的多个记录关联起来](img/Figure_7.4_B19100.jpg)'
- en: Figure 7.4 – An example of a many-to-many relationship where we associate many
    records from two different tables using an intermediary linker table
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 一个多对多关系的示例，其中我们使用一个中间链接表将两个不同表中的多个记录关联起来
- en: We have already discussed ACID principles and why they are important. Relational
    databases are designed to ensure that these principles can be observed as a default
    mode of operation. This makes changing the layout and references of tables relatively
    difficult, especially if the changes involve changing how tables are related to
    each other.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了ACID原则及其重要性。关系型数据库被设计来确保这些原则可以作为默认操作模式被观察到。这使得更改布局和表引用相对困难，尤其是如果更改涉及更改表之间的关系。
- en: Another potential drawback of relational database storage comes in terms of
    performance with large datasets. Relational databases are typically efficient
    in data storage, retrieval, and overall speed. They are built to manage large
    workloads, so the technology itself is hardly at fault, but our design will either
    complement speed or inhibit it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库存储的另一个潜在缺点在于处理大量数据集时的性能。关系型数据库在数据存储、检索和整体速度方面通常效率很高。它们被设计来管理大量工作负载，因此技术本身几乎不会出错，但我们的设计要么会补充速度，要么会阻碍它。
- en: These are trade-offs of proper relational database design and upholding relational
    integrity. Design principles favor normalization, where bits of data are spread
    across multiple tables, and this is good until we need the data and need to traverse
    multiple tables with potentially thousands of records to get it. Considering this
    deficiency, NoSQL or document storage databases have become more and more popular,
    as they seek to store data in one place, making the retrieval process much faster.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是适当的关系型数据库设计和维护关系完整性之间的权衡。设计原则倾向于规范化，其中数据位分散在多个表中，这在我们需要数据并需要跨多个表（可能包含数千条记录）来获取数据时是好的。考虑到这种不足，NoSQL
    或文档存储数据库变得越来越受欢迎，因为它们试图将数据存储在一个地方，使检索过程变得更快。
- en: We discuss the use of non-relational databases in the next section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论非关系型数据库的使用。
- en: Non-relational databases
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非关系型数据库
- en: Non-relational databases took the database world by storm. That might be a naive
    assessment of the impact that they have had, but the fact remains that they introduced
    a dimension to data storage that was not very popular or widely used. They came
    along and proposed a far more flexible and scalable data storage technique that
    favored a more agile development style.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库在数据库世界中掀起了一场风暴。这可能是对它们产生影响的简单评估，但事实仍然是，它们引入了数据存储的一个维度，这个维度以前并不受欢迎或广泛使用。它们出现并提出了一种更加灵活和可扩展的数据存储技术，这种技术更倾向于敏捷的开发风格。
- en: Agile development hinges on the ability to morph a project as we go along. This
    means that the excess amounts of scoping and planning that would be recommended
    when using a relational data store would not be necessary upfront. Instead, we
    could start with an idea of a system and begin using a non-relational data store
    to accommodate that tiny part, and as the system evolves, so could the data store,
    with minimal risk of data loss or attrition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷开发依赖于在项目进行过程中改变项目的能力。这意味着当使用关系型数据存储时，通常会推荐的大量范围和规划在初期是不必要的。相反，我们可以从一个系统的想法开始，并开始使用非关系型数据存储来适应那个小部分，随着系统的演变，数据存储也可以相应演变，从而最大限度地减少数据丢失或衰减的风险。
- en: Non-relational databases are also referred to as **NoSQL databases**, or *not
    only SQL*, and they favor a non-tabular data storage model. The most popular NoSQL
    databases use a document style of storage, where each record is stored in one
    document, containing all the details needed for that record. This directly violates
    the principles of *normalization*, which would have us spread the data to reduce
    possible redundancy. The major advantage of this model, however, is the speed
    with which we can write and retrieve data since all the details are in one place.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库也被称为 **NoSQL 数据库**，或 *not only SQL*，并且它们倾向于非表格式的数据存储模型。最受欢迎的 NoSQL 数据库使用文档存储方式，其中每条记录存储在一个文档中，包含该记录所需的所有详细信息。这直接违反了
    *规范化* 的原则，该原则会建议我们将数据分散以减少可能的冗余。然而，这种模型的主要优势是我们可以在一个地方写入和检索数据，从而大大提高速度。
- en: 'Using the example of our health care appointment management system, if we were
    to store an appointment in the form of a document, it would look something like
    this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的健康护理预约管理系统为例，如果我们以文档的形式存储一个预约，它可能看起来像这样：
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unlike with the relational model, where these details were split across multiple
    tables and simply referenced, we have the opportunity to include all the details
    needed to fully assess what an appointment entails.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与关系模型不同，其中这些细节分散在多个表中并简单地引用，我们有包括所有评估预约所需细节的机会。
- en: 'Types of NoSQL databases include the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL 数据库的类型包括以下几种：
- en: '**Document database**: Stores data in the form of **JavaScript Object Notation**
    (**JSON**) objects. This JSON document outlines fields and values and can support
    a hierarchy of JSON objects and collections all in one document. Popular examples
    include *MongoDB*, *CosmosDB*, and *CouchDB*.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档数据库**：以 **JavaScript 对象表示法**（**JSON**）对象的形式存储数据。这个 JSON 文档概述了字段和值，并可以在一个文档中支持
    JSON 对象和集合的层次结构。流行的例子包括 *MongoDB*、*CosmosDB* 和 *CouchDB*。'
- en: '**Key-value database**: Stores data in simple key-value pairs. Values are usually
    stored as string values, and they do not natively support storing complex data
    objects. They are usually used as quick lookup storage areas, like for application
    caching. A popular example of this is *Redis*.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键值数据库**：以简单的键值对存储数据。值通常存储为字符串值，并且它们不支持存储复杂的数据对象。它们通常用作快速查找存储区域，例如用于应用程序缓存。一个流行的例子是
    *Redis*。'
- en: '**Graph database**: Stores data in nodes and edges. A node stores information
    on the object, such as a person or place, and the edges represent relationships
    between the nodes. These relationships link how data points relate to each other,
    as opposed to how records relate to each other. A popular example of this is *Neo4j*.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图数据库**：在节点和边中存储数据。节点存储有关对象的信息，例如人或地点，边表示节点之间的关系。这些关系链接数据点之间的关系，而不是记录之间的关系。一个流行的例子是
    *Neo4j*。'
- en: The clear advantages of using NoSQL document databases come from the way that
    data is stored. Unlike with the relational model, we do not need to traverse many
    relationships and tables to get a fully human-readable record of data. As seen
    in the preceding example, we can store all the details in one document and simply
    scale from there. This comes in handy when we might need to do fast read operations
    and do not want to compromise system performance with complex queries.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NoSQL文档数据库的明显优势来自于数据存储的方式。与关系模型不同，我们不需要遍历许多关系和表来获取一个完全可读的数据记录。正如前一个示例所示，我们可以将所有细节存储在一个文档中，并简单地从这里进行扩展。当我们可能需要快速读取操作且不想通过复杂的查询来牺牲系统性能时，这非常有用。
- en: A clear disadvantage, however, comes from how storage is handled. Document databases
    do very little, if anything at all, to reduce the risk of data redundancy. We
    will end up repeating details of what would have been related data, which means
    that the maintenance of this data, in the long run, could become a problem. Using
    our customer records as examples, if we needed to add a new data point for each
    customer that has booked an appointment, we would need to traverse the appointment
    records to make one change. This would be a much easier and more efficient operation
    using a relational model.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个明显的缺点来自于存储的处理方式。文档数据库在减少数据冗余风险方面做得很少，甚至几乎什么也不做。我们最终会重复相关数据的细节，这意味着从长远来看，这些数据的维护可能会成为一个问题。以我们的客户记录为例，如果我们需要为每个预约过的客户添加一个新的数据点，我们就需要遍历预约记录来做出一个更改。使用关系模型来做这个操作会容易得多，也有效率得多。
- en: Now that we have discovered some of the advantages and disadvantages of relational
    and non-relational database stores, let us discuss scenarios where either would
    be a good choice.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经发现了一些关系型和非关系型数据库存储的优点和缺点，让我们讨论一下在这些情况下任选其一都是好的选择。
- en: Choosing a database technology
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择数据库技术
- en: 'When choosing the best technology for anything, we are faced with several factors:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择任何最佳技术时，我们面临着几个因素：
- en: '**Maintainability**: How easy is this technology to maintain? Does it have
    excessive infrastructural and software requirements? How often are updates and
    security patches produced for the technology? Ultimately, we want to ensure that
    we do not regret our selection weeks into starting the project.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：这项技术维护起来有多容易？它是否有过多的基础设施和软件要求？这项技术的更新和安全补丁产生得多频繁？最终，我们希望确保我们在项目开始几周后不会后悔我们的选择。'
- en: '**Extensibility**: To what extent can I use this technology to implement my
    software? What happens when the requirements change and the project needs to adapt?
    We want to ensure that our technology is not too rigid and can support the dynamics
    of the business needs.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：我可以用这项技术到什么程度来实现我的软件？当需求发生变化，项目需要适应时会发生什么？我们希望确保我们的技术不要太僵化，并且能够支持业务需求的变化。'
- en: '**Supporting technologies**: Is the technology stack that I am using the best
    fit? We are often forced to take shortcuts and implement methods, sometimes contrary
    to best practices, to facilitate matching technologies that are not the best fit
    for each other. With more libraries being produced to support integrations of
    heterogenous technology stacks, this is becoming less of an issue, but is still
    something that we want to take into consideration from day one.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持技术**：我使用的这个技术栈是否是最合适的？我们常常被迫走捷径，实施一些方法，有时甚至与最佳实践相悖，以方便匹配那些彼此并不最合适的技术。随着更多库的产生来支持异构技术栈的集成，这个问题正在逐渐减少，但仍是我们从第一天开始就需要考虑的事情。'
- en: '**Comfort level**: How comfortable are you and the team with the technology?
    It is always nice to use new technology and expand your scope and experience,
    but it is important to recognize your limitations and knowledge gaps. These can
    just as easily be addressed with training, but we always want to ensure that we
    can handle the technology that we choose and are not prone to surprises in the
    long run.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**舒适度**：您和团队对这项技术的舒适度如何？使用新技术并扩展范围和经验总是令人愉快的，但重要的是要认识到自己的局限性和知识差距。这些问题同样可以通过培训来解决，但我们始终希望确保我们能够处理我们选择的技术，并且不会在长期运行中出现意外。'
- en: '**Maturity**: How mature is the technology? In some development circles, technology
    lives for months at a time. We don’t want to embrace new technology the day it
    is released without doing our due diligence. Seek to choose more mature technologies
    that have been tried and proven and have strong enterprise or community support
    and documentation.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成熟度**：这项技术有多成熟？在某些开发圈子中，技术可能每个月都会更新一次。我们不希望在发布当天就盲目拥抱新技术，而不进行充分的尽职调查。我们应该寻求选择那些经过实践检验、证明有效，并且拥有强大企业或社区支持及文档的成熟技术。'
- en: '**Appropriateness**: Lastly, how appropriate is the technology for the application?
    We want to ensure that we use the best technology possible to do the job at hand.
    This sometimes gets compromised considering the bigger picture, which includes
    budget constraints, the type of project, team experience, and the business’ risk
    appetite, but as much as possible, we want to ensure that the technology we choose
    can adequately address the needs of the project.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适用性**：最后，这项技术对于应用程序的适用性如何？我们希望确保我们使用尽可能好的技术来完成手头的任务。这有时会因更大的背景而受到影响，包括预算限制、项目类型、团队经验以及企业的风险承受能力，但尽可能，我们希望确保我们选择的技术能够充分满足项目的需求。'
- en: Now let us narrow this down to database development. We have gone through the
    pros and cons of the different types of database models and the different technology
    providers for each. While we are not limited to the options outlined, they serve
    as guidelines to help us make out assessments from the most unbiased point of
    view possible.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将重点放在数据库开发上。我们已经讨论了不同类型数据库模型和每种技术的利弊。虽然我们不受所列选项的限制，但它们作为指南，帮助我们尽可能从最无偏见的角度进行评估。
- en: Within the context of microservices, we want to choose the best database for
    the service’s needs. There are no hard and fast rules surrounding which storage
    mechanism should be used outright, but there are recommendations that can help
    to guide you during the system design.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务背景下，我们希望为服务的需求选择最佳的数据库。围绕应该使用哪种存储机制没有硬性规定，但有一些建议可以在系统设计过程中帮助您进行指导。
- en: 'You can consider using relational databases in the following situations:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以考虑在以下情况下使用关系型数据库：
- en: '**Working with complex reports and queries**: Relational databases can run
    efficient queries across large datasets and are a much better storage option for
    generating reports.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理复杂报告和查询**：关系型数据库可以在大型数据集上运行高效的查询，并且是生成报告的更好存储选项。'
- en: '**Working with a high transaction application**: Relational databases are a
    good fit for heavy-duty and complex transaction operations. They do a good job
    of ensuring data integrity and stability.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理高交易应用**：关系型数据库非常适合处理重型和复杂的交易操作。它们在确保数据完整性和稳定性方面做得很好。'
- en: '**You require ACID compliance**: Relational databases are based on ACID principles,
    which can go a long way in protecting your data and ensuring accuracy and completeness.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**您需要ACID兼容性**：关系型数据库基于ACID原则，这在保护您的数据、确保准确性和完整性方面可以发挥很大作用。'
- en: '**Your service will not evolve rapidly**: If your service doesn’t have changing
    requirements, then a database should be easy to design and maintain in the long
    run.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**您的服务不会快速进化**：如果您的服务没有变化的需求，那么数据库应该容易设计并长期维护。'
- en: 'You can consider using a non-relational database in the following situations:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以考虑在以下情况下使用非关系型数据库：
- en: Your service is constantly evolving, and you need a flexible data store that
    can adapt to new requirements without too much disruption.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的服务不断进化，您需要一个灵活的数据存储库，能够在不造成太多干扰的情况下适应新的需求。
- en: You anticipate that data may not be clean or meet a certain standard all the
    time. Given the flexibility that we have with non-relational data stores, we accommodate
    data of varying levels of accuracy and completeness.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您预计数据可能不会始终干净或达到某个标准。鉴于我们在非关系型数据存储方面的灵活性，我们适应了不同准确性和完整程度的数据。
- en: 'You need to support rapid scaling: This point goes hand in hand with the need
    to evolve the data store based on the needs of the business, so we can ensure
    that the database can be changed with minimal code changes and low costs.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要支持快速扩展：这一点与根据业务需求演变数据存储的需求相辅相成，因此我们可以确保数据库可以在最小化代码更改和低成本的情况下进行更改。
- en: Now that we have explored some of the major considerations regarding choosing
    a database technology, let us review our options for interacting with a database
    with code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了选择数据库技术的一些主要考虑因素，让我们回顾一下使用代码与数据库交互的选项。
- en: Choosing an ORM
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择ORM
- en: Choosing an **ORM** is an important part of the design process. This lays a
    foundation for how our application will communicate with our database. The abbreviation
    **ORM** is short for **Object Relational Mapping**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**ORM**是设计过程中的重要部分。这为我们应用程序如何与数据库通信奠定了基础。**ORM**的缩写是**对象关系映射**。
- en: 'Every language has support for some form of ORM. Sometimes this is built into
    the language, and sometimes developers and architects alike contract the use of
    an external package or library to support database-related operations. In the
    context of .NET, we have several options, and each has its pros and cons. The
    most popular options are as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每种语言都支持某种形式的ORM。有时这是内置在语言中的，有时开发者和架构师都会使用外部包或库来支持数据库相关操作。在.NET的上下文中，我们有几种选择，每种都有其优缺点。最受欢迎的选项如下：
- en: '**Entity Framework Core**: The most popular and obvious choice of .NET developers.
    It is a Microsoft-developed and maintained ORM that is packaged with .NET. It
    implements a C# query-like syntax called LINQ, which makes it easy to write C#
    code that will execute a query at runtime on the developer’s behalf and has support
    for most relational and non-relational database technologies.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Entity Framework Core**：这是.NET开发者最流行和最明显的选择。它是由微软开发和维护的ORM，与.NET一起打包。它实现了称为LINQ的C#查询语法，这使得编写在运行时代表开发者执行查询的C#代码变得容易，并且支持大多数关系型和非关系型数据库技术。'
- en: '**Dapper**: Dapper is considered a *MicroORM* as it is a fast, lightweight
    ORM for .NET. It provides a clean and extendable interface for constructing SQL
    queries and executing them in a secure and efficient manner. Its performance has
    always rivaled that of Entity Framework.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dapper**：Dapper被认为是一个*微ORM*，因为它是一个快速、轻量级的.NET ORM。它提供了一个干净且可扩展的接口来构建SQL查询并在安全高效的方式下执行它们。其性能始终与Entity
    Framework相媲美。'
- en: '**NHibernate**: NHibernate is an open source ORM that has been widely used
    as an alternative to Entity Framework. It has wide support for database technologies
    and offers alternative methods of handling object mapping and query construction
    that developers have come to prefer.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NHibernate**：NHibernate是一个开源ORM，广泛用作Entity Framework的替代品。它对数据库技术的支持广泛，并提供开发者偏好的处理对象映射和查询构造的替代方法。'
- en: There are other ORMs, but these are arguably the most popular and widely used
    options.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他ORM，但这些都是最具争议的、最受欢迎和最广泛使用的选项。
- en: Entity Framework Core has undergone constant improvement and is currently open
    source and provides excellent interfaces and abstractions that reduce the need
    for specific code to be written based on the database being accessed. This is
    a significant feature as it allows us to reuse code across different database
    technologies and helps us to be flexible in terms of the database technology being
    used. We can easily change the database technology without affecting the main
    application and its operations. Barring the presence of any obvious bias on why
    we should use Entity Framework in our .NET projects, it does help that we can
    keep our technology stack homogenous.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core经历了不断的改进，目前是开源的，并提供了优秀的接口和抽象，减少了根据访问的数据库编写的特定代码的需求。这是一个重要的特性，因为它允许我们在不同的数据库技术之间重用代码，并帮助我们根据使用的数据库技术保持灵活性。我们可以轻松地更改数据库技术，而不会影响主要应用程序及其操作。除了任何明显的偏见之外，我们可以在.NET项目中使用Entity
    Framework，这确实有助于我们保持技术栈的一致性。
- en: 'To integrate Entity Framework Core, or *EF Core* for short, into our .NET application,
    we would need to add the package that is designed for our preferred database technology.
    For this example, we can use SQLite given its versatility. The commands to add
    the packages would look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Entity Framework Core（简称 *EF Core*）集成到我们的 .NET 应用程序中，我们需要添加为我们首选的数据库技术设计的包。对于这个示例，我们可以使用
    SQLite，因为它具有多功能性。添加包的命令如下所示：
- en: '[PRE1]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first command adds all the core and supporting EF Core libraries needed
    to communicate with a SQLite database and the `Microsoft.EntityFrameworkCore.Design`
    package adds support for design time logic for migrations and other operations.
    We will investigate migrations in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令添加了与 SQLite 数据库通信所需的全部核心和辅助 EF Core 库，而 `Microsoft.EntityFrameworkCore.Design`
    包添加了对迁移和其他操作的设计时逻辑的支持。我们将在下一节中研究迁移。
- en: The next thing we need is a data context class, which serves as a code-level
    abstraction of the database and the tables therein. This context file will outline
    the database objects that we wish to access and refer to them. So, if our SQLite
    database should have a table that stores patient information, then we need a class
    that is modeled from how the patient table should look as well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要的是一个数据上下文类，它作为数据库及其表中代码级别的抽象。这个上下文文件将概述我们希望访问和引用的数据库对象。因此，如果我们的 SQLite
    数据库应该有一个存储患者信息的表，那么我们需要一个类，该类模仿患者表应该如何看起来。
- en: 'Our data context file looks like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据上下文文件看起来像这样：
- en: '[PRE2]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This `ApplicationDatabaseContext` class inherits from `DbContext`, which is
    a class provided by EF Core that gives us access to the database operations and
    functions. We also have a property of type `DbSet`, which requires a reference
    type and a name. The reference type will be the class that models a table, and
    the name of the property will be the code-level reference point for the table.
    A `DbSet` represents the collection of records in the referenced table. Our `OnConfiguring`
    method sets up the connection string to our database. This connection string will
    vary based on the type of database we are connecting to.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationDatabaseContext` 类继承自 `DbContext`，这是一个由 EF Core 提供的类，它为我们提供了访问数据库操作和函数的能力。我们还有一个类型为
    `DbSet` 的属性，它需要一个引用类型和一个名称。引用类型将是表示表的类，属性的名称将是表的代码级别引用点。`DbSet` 代表引用表中记录的集合。我们的
    `OnConfiguring` 方法设置了到数据库的连接字符串。这个连接字符串将根据我们连接到的数据库类型而变化。'
- en: 'Now, our patients table will have a few fields and we need a class called `Patient`,
    which has C# properties that represent the column names and data types as accurately
    as possible, relative to how they are presented in the database:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的患者表将有一些字段，我们需要一个名为 `Patient` 的类，该类具有尽可能准确地表示列名和数据类型的 C# 属性，相对于它们在数据库中的呈现方式：
- en: '[PRE3]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our `Patient` class is a typical class. It simply represents what we want a
    patient record to look like both in the database and in our application. This
    way, we abstract much of the database-specific code and use a standard C# class
    and standard C# code to interact with our tables and data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Patient` 类是一个典型的类。它简单地表示我们希望在数据库和我们的应用程序中患者记录看起来是什么样子。这样，我们抽象了大部分数据库特定的代码，并使用标准的
    C# 类和标准 C# 代码来与我们的表和数据交互。
- en: 'A simple database query to retrieve and print all the records from the patients
    table would look like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的数据库查询，用于检索并打印患者表中的所有记录，将如下所示：
- en: '[PRE4]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can see how cleanly we can use the LINQ syntax in C# and execute a query.
    EF Core will attempt to generate the most efficient SQL syntax, carry out the
    operation, and return the data in the form of objects fashioned by the class that
    models the table. We can then interact with the records as standard C# objects.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们如何干净地使用 C# 中的 LINQ 语法并执行查询。EF Core 将尝试生成最有效的 SQL 语法，执行操作，并以由表示表的类塑造的对象形式返回数据。然后我们可以以标准
    C# 对象的方式与记录进行交互。
- en: EF Core gives us a complete way to interact with our database and carry out
    our operations without needing to break much from our C# syntax. To go beyond
    the example shared above, EF Core has full support for dependency injection, which
    makes connection management and garbage collection almost a non-issue.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 提供了一种完整的方式来与我们的数据库交互并执行我们的操作，而无需从我们的 C# 语法中中断太多。为了超越上面共享的示例，EF Core
    完全支持依赖注入，这使得连接管理和垃圾回收几乎不成问题。
- en: A fundamental step that was not addressed above comes in the form of database
    development techniques that govern how we can create our database in our project.
    We also have the issue of migrations. We will discuss those in the next section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容未涉及的一个基本步骤是以数据库开发技术形式出现，这些技术指导我们如何在项目中创建数据库。我们还面临迁移问题。我们将在下一节中讨论这些问题。
- en: Choosing a database development technique
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择数据库开发技术
- en: There are best practices and general guidelines that govern how databases are
    designed. In this section, we are not going to explore or contest those, but we
    will discuss the possible approaches that exist to materialize a database to support
    our application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些最佳实践和一般指南指导数据库的设计。在本节中，我们不会探讨或质疑这些，但我们将讨论实现数据库以支持我们的应用程序的可能方法。
- en: 'There are two popular types of development techniques:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种流行的开发技术：
- en: '**Schema-first**: Also called **Database-First**, this technique sees us creating
    the database using the usual database management tools. We then *scaffold* the
    database into our application. Using Entity Framework, we will get a database
    context class that represents the database and all the objects within, as well
    as classes per table and view.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Schema-first**：也称为**数据库优先**，这种技术使我们能够使用常规的数据库管理工具创建数据库。然后我们将数据库**scaffold**到我们的应用程序中。使用Entity
    Framework，我们将获得一个表示数据库及其所有对象的数据库上下文类，以及每个表和视图的类。'
- en: '**Code-first**: This technique allows us to model the database more fluently
    alongside our application code. We create the data models using standard C# classes
    (as we saw in the previous section) and manage the changes to the data models
    and eventual database using *migrations*.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Code-first**：这种技术允许我们在应用程序代码旁边更流畅地建模数据库。我们使用标准的C#类（如前节所示）创建数据模型，并使用**migrations**管理数据模型和最终数据库的更改。'
- en: Whether we intend to scaffold a database or use the code-first approach, we
    can use *dotnet CLI* commands that are made available via the `Microsoft.EntityFrameworkCore.Tools`
    package. You can add this package to your project using the `dotnet add package`
    command.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不论我们是打算构建数据库还是采用代码优先的方法，我们都可以使用通过`Microsoft.EntityFrameworkCore.Tools`包提供的`*dotnet
    CLI*`命令。你可以使用`dotnet add package`命令将此包添加到你的项目中。
- en: 'To scaffold a database, the commands look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建数据库，命令看起来是这样的：
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command simply states that we wish to generate a `dbcontext` based on the
    database that is located at the connection string that is provided. Based on the
    technology of the target database (SQL Server, Oracle, and so on), this connection
    string will be different, but in this example, we’re looking at scaffolding an
    SQLite database in our application. We then specify the database provider package
    that is most appropriate for the target database and output the generated files
    to a directory in our project called `Models`. This command is also agnostic to
    the IDE being used.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令只是表明我们希望根据提供的连接字符串生成一个`dbcontext`。根据目标数据库的技术（SQL Server、Oracle等），这个连接字符串将不同，但在这个例子中，我们正在构建一个SQLite数据库到我们的应用程序中。然后我们指定最适合目标数据库的数据库提供程序包，并将生成的文件输出到项目中的`Models`目录。这个命令对使用的IDE也是无差别的。
- en: 'This command can also look like this, and this format is more popularly used
    when working in Visual Studio:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令也可以这样，这种格式在Visual Studio中工作时更受欢迎：
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Either command needs to be executed within the directory of the project being
    worked on. Each time a change is made to the database, we need to rerun this command
    to ensure that the code reflects the latest version of the database. It will overwrite
    the existing files accordingly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 任何命令都需要在正在工作的项目目录中执行。每次对数据库进行更改时，我们都需要重新运行此命令以确保代码反映了数据库的最新版本。它将相应地覆盖现有文件。
- en: One limitation here is that we are not always able to track all the changes
    that are happening in the database and adequately track what changes each time
    we run this command. Therefore, code-first is a very popular option for database
    development and its use of migrations helps us to solve this problem.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个限制是我们并不总是能够跟踪数据库中发生的所有更改，并在每次运行此命令时充分跟踪每次更改的内容。因此，代码优先是数据库开发中一个非常受欢迎的选项，其使用迁移帮助我们解决这个问题。
- en: The concept of migrations is not unique to EF Core, but it is present in several
    other frameworks in other languages as well. It is a simple process that tracks
    all the changes being made to a data model as we write our applications and the
    tables and objects evolve. A migration will evaluate the changes being applied
    to the database and generate commands (which eventually become SQL scripts) to
    effect those changes against the database.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移的概念并不仅限于 EF Core，它也存在于其他语言中的几个其他框架中。它是一个简单的流程，它跟踪我们在编写应用程序时对数据模型所做的所有更改，以及表和对象的发展。迁移将评估对数据库应用的变化，并生成命令（最终成为
    SQL 脚本）以对数据库执行这些更改。
- en: Unlike with the database-first model, where we need to use source control with
    a dedicated database project, migrations are natively available in our code base
    and tell the story of every adjustment that is made to the database along the
    way.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库优先模型不同，在数据库优先模型中，我们需要使用带有专用数据库项目的源控制，迁移在我们的代码库中是原生的，并讲述了在迁移过程中对数据库所做的每一次调整的故事。
- en: 'Following the example of using EF Core to add a database to our application,
    we already created the database context class as well as a patient class. So,
    a direct translation of the code would be that our database context is the database,
    and `Patient.cs` is our table. To materialize the database with the table, we
    need to create a migration that will generate the assets as outlined. We need
    the same `Microsoft.EntityFrameworkCore.Tools` package to run our command-line
    commands and the command to create our first migration will look like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 按照使用 EF Core 向我们的应用程序添加数据库的示例，我们已经创建了数据库上下文类以及一个病人类。因此，代码的直接翻译将是我们的数据库上下文就是数据库，而`Patient.cs`是我们的表。为了将表实体化到数据库中，我们需要创建一个迁移，该迁移将生成所需的资产。我们需要相同的`Microsoft.EntityFrameworkCore.Tools`包来运行我们的命令行命令，创建第一个迁移的命令将如下所示：
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or, it will look like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它看起来像这样：
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we simply generate a migration file and give it the name `InitialCreate`.
    Naming our migrations helps us to visibly track what might have changed in that
    operation and helps our team as well. Each time we make a change to a data model
    and/or the database context class, we need to create a new migration, which will
    produce commands that outline the best possible interpretations of what has changed
    since the last known version of the database.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需生成一个迁移文件，并将其命名为`InitialCreate`。命名我们的迁移有助于我们直观地跟踪该操作中可能发生了什么变化，并有助于我们的团队。每次我们对数据模型和/或数据库上下文类进行更改时，我们都需要创建一个新的迁移，这将生成概述自上次已知数据库版本以来发生变化的最佳可能解释的命令。
- en: 'This command will generate a class with `Up` and `Down` methods that outline
    what changes are to be applied, and what will be undone if the migration is reversed.
    This makes it convenient for us to make sure that the changes we intended are
    what will be carried out and we can remove a migration and make corrections before
    these changes are applied. Migrations can only be removed before they are applied
    to the database and the command for that looks like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将生成一个具有`Up`和`Down`方法的类，概述要应用哪些更改，以及如果迁移被撤销，将取消哪些更改。这使得我们能够确保我们打算做出的更改将被执行，我们可以在这些更改应用之前删除迁移并进行更正。迁移只能在应用到数据库之前被删除，该命令如下所示：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or, it looks like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它看起来像这样：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we are satisfied that a migration correctly outlines the changes that
    we intend to make, we can apply it using the simple `database update` command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们确信迁移正确地概述了我们打算做出的更改时，我们可以使用简单的`数据库更新`命令来应用它：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or, we can use the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用以下命令：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If source control is being used with your project, then migrations will always
    be included in the code base for other team members to see and evaluate if necessary.
    It is important to collaborate with team members when making these adjustments
    as well. It is possible to have migration collisions if changes are not coordinated
    and this can lead to mismatched database versions if a central database is being
    used. Ultimately, if we need a fresh copy of the database as of the latest migrations,
    we can simply change our connection string to target a server and an intended
    database name, run the `Update-Database` command, and have EF Core generate a
    database that reflects the most recent version of our database.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目正在使用源代码控制，那么迁移将始终包含在代码库中，以便其他团队成员查看和评估。在做出这些调整时与团队成员协作也很重要。如果不协调变更，可能会发生迁移冲突，如果使用集中式数据库，这可能导致数据库版本不匹配。最终，如果我们需要数据库的最新迁移副本，我们只需更改连接字符串以指向服务器和预期的数据库名称，运行`Update-Database`命令，EF
    Core就会生成反映我们数据库最新版本的数据库。
- en: Now that we understand how to use EF Core to either reverse engineer a database
    into our application or create a new database using migrations, let us investigate
    writing extensible database querying code on top of the interfaces provided by
    EF Core.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用EF Core将数据库反向工程到我们的应用程序中或使用迁移创建新数据库，让我们来研究如何在EF Core提供的接口之上编写可扩展的数据库查询代码。
- en: Implementing the repository pattern
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现仓库模式
- en: By definition, a repository is a central storage area for data or items. In
    the context of database development, we use the word repository to label a widely
    used and convenient development pattern. This pattern helps us to extend the default
    interfaces and code given to us by our ORM, making it reusable and even more specific
    for certain operations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，仓库是一个数据或项目的中枢存储区域。在数据库开发的背景下，我们使用“仓库”这个词来指代一个广泛使用且方便的开发模式。这个模式帮助我们扩展ORM（对象关系映射）给我们的默认接口和代码，使其可重用，并针对某些操作更加具体。
- en: One side effect of this pattern is that we end up with more code and files,
    but the general benefit is that we can centralize our core operations. As a result,
    we abstract our business logic and database operations away from our controllers
    and eliminate repeating database access logic throughout our application. It helps
    us to maintain the *single responsibility principle* in our code base as we seek
    to author clean code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的一个副作用是我们最终会有更多的代码和文件，但总体好处是我们可以将核心操作集中化。因此，我们将业务逻辑和数据库操作从控制器中抽象出来，并在整个应用程序中消除重复的数据库访问逻辑。这有助于我们在编写干净代码的同时，维护代码库中的*单一职责原则*。
- en: In any application, we need to carry out four main operations against any database
    table. We need to create, read, update, and delete data. In the context of an
    API, we need a controller per database table, and we would have our *CRUD* code
    repeating in every controller, which is good for getting started, but becomes
    dangerous as our application code base grows. This means that if something changes
    in the way that we retrieve records from every table, we have that many places
    that we need to change code in.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，我们需要对任何数据库表执行四个主要操作。我们需要创建、读取、更新和删除数据。在API的背景下，我们需要为每个数据库表创建一个控制器，我们会在每个控制器中重复我们的*CRUD*代码，这对于开始来说很好，但随着应用程序代码库的增长，这变得很危险。这意味着如果我们更改从每个表中检索记录的方式，我们就需要在那么多地方更改代码。
- en: 'An API controller with a `GET` operation for our patients table would look
    like this without using the repository pattern:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用仓库模式，我们的患者表`GET`操作的API控制器将看起来像这样：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We simply inject the database context into the controller and use this instance
    to carry out our queries. This is simple and efficient as the query logic is not
    very complicated. Now imagine that you have several controllers with similar `GET`
    operations. All is well until we get feedback that we need to add paging to our
    `GET` operations for all endpoints. Now, we have that many places that need to
    be refactored with a far more complex query, which may also change again in the
    future.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将数据库上下文注入到控制器中，并使用此实例来执行我们的查询。这是简单且高效的，因为查询逻辑并不复杂。现在想象一下，您有多个具有类似`GET`操作的控制器。一切都很顺利，直到我们收到反馈，需要为所有端点的`GET`操作添加分页。现在，我们有那么多地方需要重构，查询将更加复杂，而且未来可能还会再次更改。
- en: For scenarios like this, we need to centralize the code as much as possible
    and reduce the rework that becomes necessary across the application. This is where
    the repository pattern can come to our rescue. We typically have two files that
    contain generic templating code, then, we derive more specific repositories for
    each table where we can add custom operations as needed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种类型的场景，我们需要尽可能集中化代码，并减少在整个应用程序中变得必要的重工作。这就是仓库模式能帮助我们解决问题的地方。我们通常有两个包含通用模板代码的文件，然后，我们为每个表推导出更具体的仓库，以便我们可以根据需要添加自定义操作。
- en: 'Our generic repository includes an interface and a derived class. They look
    something like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的通用仓库包括一个接口和一个派生类。它们看起来像这样：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we only outline methods for read operations, but this interface can just
    as easily be extended to support all CRUD operations. We use generics as we are
    prepared to accept any type of class that represents a data model. We also outline
    a method for a `GET` operation that returns paged results in keeping with the
    recent requirement. Our derived class looks like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只概述了读取操作的方法，但这个接口同样可以轻松扩展以支持所有CRUD操作。我们使用泛型，因为我们准备接受任何表示数据模型的类类型。我们还概述了一个用于`GET`操作的方法，该方法返回分页结果，符合最近的要求。我们的派生类看起来像这样：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We see here that we are injecting the database context into the repository
    and then we can write our preset queries in one place. This generic repository
    can now be injected into the controllers that need to implement these operations:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到，我们将数据库上下文注入到仓库中，然后我们可以在一个地方编写我们的预设查询。现在，这个通用仓库可以被注入到需要实现这些操作的控制器中：
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we can simply call the appropriate method from the repository. The repository
    gets instantiated in our controller relative to the class that is used in its
    injection and the resulting query will be applied against the related table. This
    makes it much easier to standardize our queries across multiple tables and controllers.
    We need to ensure that we register our `GenericRepository` service in our `Program.cs`
    file like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以简单地从仓库中调用适当的方法。仓库在我们的控制器中相对于其注入中使用的类被实例化，并且生成的查询将应用于相关表。这使得我们在多个表和控制器之间标准化查询变得容易得多。我们需要确保我们在`Program.cs`文件中像这样注册我们的`GenericRepository`服务：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we may need to implement operations that are specific to our patient table
    and are not needed for other tables. This means that the generic approach will
    not be best moving forward, as we would end up cluttering it with custom logic
    for our tables. We can now extend it and create a specific interface for our table
    and write our custom logic:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可能需要实现特定于我们的患者表的操作，这些操作对于其他表不是必需的。这意味着通用的方法将不再是最佳选择，因为我们最终会在其中添加针对我们表的定制逻辑。我们现在可以扩展它，并为我们的表创建一个特定的接口，并编写我们的自定义逻辑：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we can register this new service in the `Program.cs` file like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`Program.cs`文件中像这样注册这个新服务：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And then we can inject it into our controller instead of `GenericRepository`
    and use it like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将其注入到我们的控制器中，而不是使用`GenericRepository`，并像这样使用它：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we can cleanly call the custom code while maintaining access to the base
    functions that we implemented in the generic repository.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以在保持对我们在通用仓库中实现的基函数的访问的同时，干净地调用自定义代码。
- en: There are debates as to whether this pattern saves us time and effort or just
    makes our code base more complicated. There are pros and cons to this pattern
    but ensure that you do a fair assessment of the benefits and pitfalls before you
    choose to include it in your project.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种模式是否节省我们时间和精力，或者只是使我们的代码库变得更加复杂，存在争议。这种模式有其优点和缺点，但在选择将其包含到您的项目中之前，请确保您对它的利弊进行公平的评估。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Databases are a critical part of application development, and we need to ensure
    that we make the right decisions as early as possible. The technology, type of
    storage mechanism, and supporting application logic all play a large role in making
    our application as effective as possible in implementing business requirements.
    In this chapter, we explored the different considerations involved when developing
    supporting databases for microservices, the best type of database to use and when,
    and choosing a pattern of development that helps us to reduce redundant code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是应用开发的关键部分，我们需要确保我们尽早做出正确的决策。技术、存储机制的类型以及支持的应用逻辑都在使我们的应用尽可能有效地实现业务需求方面发挥着重要作用。在本章中，我们探讨了开发支持微服务的数据库时涉及的不同考虑因素，最佳数据库类型及其使用时机，以及选择一种有助于我们减少冗余代码的开发模式。
- en: In the next chapter, we will investigate implementing transactions across multiple
    services and databases using the *saga pattern*, since this is a big issue when
    we choose the database-per-service approach to microservice architecture.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用**saga模式**在多个服务和数据库中实现事务的方案，因为当我们选择按服务选择数据库的方法来构建微服务架构时，这是一个大问题。
