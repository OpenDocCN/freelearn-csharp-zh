- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Completing the Collection Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成收集游戏
- en: In [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041), you were introduced to level
    design, adding different 2D assets, using assets with Tilemap to create a game
    environment, and creating scripts using the C# language and the **Visual Studio**
    (**VS**) IDE to add movement to the player character.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B18347_02.xhtml#_idTextAnchor041) 中，你被介绍了关卡设计、添加不同的 2D 资产、使用 Tilemap
    创建游戏环境，以及使用 C# 语言和 **Visual Studio**（**VS**）IDE 创建脚本以添加玩家角色的移动。
- en: With the player moving around the environment, we’ll want a way to follow them
    visually around the level. This chapter will use Unity’s camera system called
    **Cinemachine** (**CM**) – a powerful camera control feature that makes polished
    camera movement easy to add and set up.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家在环境中移动时，我们希望有一种方法可以视觉上跟随他们在关卡中的移动。本章将使用 Unity 的相机系统，称为 **Cinemachine**（**CM**）——这是一个强大的相机控制功能，使得添加和设置流畅的相机移动变得容易。
- en: We’ll finish the chapter with an introduction to adding a **user interface**
    (**UI**). You’ll learn how to add text to the screen to track gameplay progress
    with a timer and score. We’ll use Unity’s UI system, commonly called **uGUI**,
    to accomplish this task.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章以介绍添加 **用户界面**（**UI**）结束。你将学习如何将文本添加到屏幕上，以计时器和分数跟踪游戏进度。我们将使用 Unity 的 UI
    系统，通常称为 **uGUI**，来完成这个任务。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Using CM to follow the Player and playtesting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CM 跟随玩家和进行测试
- en: Game mechanics and how to create with code (components)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏机制以及如何通过代码（组件）创建
- en: Introduction to uGUI, the timer, counting, and winning
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: uGUI、计时器、计数和获胜的介绍
- en: By the end of this chapter, you’ll be able to code game mechanics with C# scripts
    by adding functionality to GameObjects and be comfortable with adding essential
    UI to your game.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够通过向 GameObject 添加功能来使用 C# 脚本编写游戏机制，并熟悉向你的游戏添加基本 UI。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上下载完整项目：[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)。
- en: Using CM to follow the Player and playtesting
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CM 跟随玩家和进行测试
- en: '**CM** is expansive in its features – no wonder it’s an Emmy award-winning
    suite of codeless camera tools – but we’re only going to focus on one function:
    the ability to have a camera follow our ladybug around the 2D environment.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**CM** 功能丰富——难怪它是获得艾美奖的代码无工具套件——但我们只关注一个功能：让相机跟随我们的瓢虫在 2D 环境中移动的能力。'
- en: First, we’ll need to ensure we have the CM package installed by going to **Windows**
    | **Package Manager**, selecting **Cinemachine**, and clicking the **Install**
    button. CM won’t help us much without a Player to follow around, so let’s get
    the Player we designed in the previous chapter and import it into our level scene.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保我们已安装 CM 包，方法是转到 **Windows** | **包管理器**，选择 **Cinemachine**，然后点击 **安装**
    按钮。没有玩家跟随，CM 对我们帮助不大，所以让我们将上一章中设计的玩家导入到我们的关卡场景中。
- en: Creating a Player Prefab
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建玩家 Prefab
- en: Unity’s **Prefab** system allows you to store configured GameObjects as reusable
    assets (files) in your project – complete with all its components, assigned values,
    and any child GameObjects. You can even have Prefabs as children of another Prefab;
    in this case, we call them **nested Prefabs**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的 **Prefab** 系统允许你将配置好的 GameObject 存储为项目中的可重用资产（文件），包括所有其组件、分配的值以及任何子
    GameObject。你甚至可以将 Prefab 作为另一个 Prefab 的子项；在这种情况下，我们称它们为 **嵌套 Prefab**。
- en: Additionally, new Prefab assets can be derived from an original Prefab as a
    **Prefab Variant** (the same base properties but unique variations – when the
    base Prefab is modified, so are all its derived variants).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以从原始 Prefab 派生出新的 Prefab 资产作为 **Prefab 变体**（相同的基属性但独特的变体——当基 Prefab 被修改时，所有派生的变体也会被修改）。
- en: One of the powers of Prefabs is the ability to spawn new instances of them into
    your scene at runtime (think swarms of enemy **non-player characters** (**NPCs**),
    projectiles, pick-up items, repeating parts of an environment, and so on).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Prefab 的一项功能是能够在运行时将它们的新实例生成到场景中（例如，敌对 **非玩家角色**（**NPC**）的群体、投射物、拾取物品、环境重复的部分等等）。
- en: Additional reading | Unity documentation
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '**Prefabs**: [https://docs.unity3d.com/2022.3/Documentation/Manual/Prefabs.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Prefabs.xhtml)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**预制件**：[https://docs.unity3d.com/2022.3/Documentation/Manual/Prefabs.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Prefabs.xhtml)'
- en: 'Follow these steps to create a Prefab of our player character:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建我们的玩家角色预制件：
- en: Open the scene you previously saved with your player character design.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你之前保存的包含玩家角色设计的场景。
- en: Create a `Prefabs` folder at `Assets/Prefabs` and make it the current folder.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Prefabs`创建一个`Prefabs`文件夹并将其设置为当前文件夹。
- en: Click and drag the `Assets/Prefabs` folder. In *Figure 3**.1*, you can see our
    freshly created ladybug Player Prefab asset.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动`Assets/Prefabs`文件夹。在*图3.1*中，你可以看到我们刚刚创建的瓢虫玩家预制资产。
- en: Now, go back to your game level scene and click and drag the `0`, `0`, `0`)
    in the scene).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到你的游戏关卡场景，点击并拖动场景中的`(0, 0, 0)`（在场景中）。
- en: You may not be able to see the player character in the scene View because we
    have not assigned any Sorting Layer for its sprites. Rather than assigning the
    Sorting Layer to all the sprites individually, we can simply use the `sorting`
    in the `1000`, to ensure that the player will always draw as the top-most sprite
    if we add any additional sprites to this Sorting Layer.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能无法在场景视图中看到玩家角色，因为我们尚未为其精灵分配任何排序层。我们不必单独为所有精灵分配排序层，只需使用`sorting`中的`1000`，确保如果我们在该排序层中添加任何额外的精灵，玩家始终作为最顶层的精灵绘制。
- en: '![Figure 3.1 – The Ladybug Player Prefab](img/B18347_03_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 瓢虫玩家预制件](img/B18347_03_01.jpg)'
- en: Figure 3.1 – The Ladybug Player Prefab
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 瓢虫玩家预制件
- en: Tip | Unity documentation
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 | Unity文档
- en: To apply changes to a Prefab in the **Scene Hierarchy** – while the Prefab is
    not open in **Prefab Mode** (an isolated environment for directly editing the
    Prefab) – use the **Review**, **Revert**, or **Apply Override** drop-down at the
    top of the **Inspector** (simply shown as **Overrides**). Alternatively, the quickest
    way to enter **Prefab Mode** is by double-clicking on a Prefab in the Project
    window.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要将更改应用到**场景层次结构**中的预制件上——当预制件不在**预制件模式**（一个用于直接编辑预制件的独立环境）中打开时——使用**检查器**顶部**审查**、**还原**或**应用覆盖**下拉菜单。或者，进入**预制件模式**的最快方法是双击项目窗口中的预制件。
- en: '*Editing a Prefab in Prefab Mode* | *Editing in* *Isolation*: [https://docs.unity3d.com/2022.3/Documentation/Manual/EditingInPrefabMode.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/EditingInPrefabMode.xhtml)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*在预制件模式中编辑预制件* | *在隔离中编辑*：[https://docs.unity3d.com/2022.3/Documentation/Manual/EditingInPrefabMode.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/EditingInPrefabMode.xhtml)'
- en: Creating a 2D follow camera
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个2D跟随相机
- en: 'With CM, it’s trivial to create a follow camera for a 2D environment. Now that
    we have our player in the scene, we can add a CM camera that will follow the player
    around as it moves with the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CM，在2D环境中创建跟随相机非常简单。现在我们已经将玩家放入场景中，我们可以添加一个CM相机，它会跟随玩家移动，按照以下步骤进行：
- en: Create a new CM **virtual camera** (**vcam**) from the **Hierarchy** window’s
    **Create** menu or the main **File** menu by going to **GameObject** | **Cinemachine**
    | **2D Camera** – for the first vcam added to the scene, this also adds a **Cinemachine
    Brain** component to **Main Camera** (CM controls **Main Camera** through one
    or many vcams).
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口的**创建**菜单或主**文件**菜单创建一个新的CM**虚拟相机**（**vcam**），方法是转到**GameObject**
    | **Cinemachine** | **2D Camera**——对于场景中添加的第一个vcam，这也会将**Cinemachine Brain**组件添加到**主相机**（CM通过一个或多个vcam控制**主相机**）。
- en: 'With the new vcam selected, drag the **Player** object from the **Hierarchy**
    to the **Follow** field in the **CinemachineVirtualCamera** component (to assign
    its reference), as seen in the following screenshot:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新的vcam，将**Player**对象从**层次结构**拖动到**CinemachineVirtualCamera**组件中的**跟随**字段（以分配其引用），如以下截图所示：
- en: '![Figure 3.2 – The CM Follow Player Inspector assignment](img/B18347_03_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – CM跟随玩家检查器分配](img/B18347_03_02.jpg)'
- en: Figure 3.2 – The CM Follow Player Inspector assignment
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – CM跟随玩家检查器分配
- en: Within the **Body** section, expand the arrow to the left of **Body** if necessary;
    you can adjust XY damping, screen position, dead zones, and so on. Play around
    with these settings and fine-tune your camera to follow your preferences.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**身体**部分中，如果需要，展开**身体**左侧的箭头；你可以调整XY阻尼、屏幕位置、死区等。尝试这些设置并微调你的相机以符合你的偏好。
- en: Additional reading | Unity documentation
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '**Cinemachine**: [https://docs.unity3d.com/Packages/com.unity.cinemachine%402.3/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.cinemachine%402.3/manual/index.xhtml)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cinemachine**：[https://docs.unity3d.com/Packages/com.unity.cinemachine%402.3/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.cinemachine%402.3/manual/index.xhtml)'
- en: '**Cinemachine** **feature**: [https://unity.com/unity/features/editor/art-and-design/cinemachine](https://unity.com/unity/features/editor/art-and-design/cinemachine)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cinemachine** **功能**：[https://unity.com/unity/features/editor/art-and-design/cinemachine](https://unity.com/unity/features/editor/art-and-design/cinemachine)'
- en: '*Cinemachine for 2D Tips and* *Tricks*: [https://blog.unity.com/technology/cinemachine-for-2d-tips-and-tricks](https://blog.unity.com/technology/cinemachine-for-2d-tips-and-tricks)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cinemachine 2D技巧与技巧*：[https://blog.unity.com/technology/cinemachine-for-2d-tips-and-tricks](https://blog.unity.com/technology/cinemachine-for-2d-tips-and-tricks)'
- en: We can now explore the entire environment knowing that the camera will follow
    us around. Yay!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以探索整个环境，知道摄像机将跟随我们移动。太棒了！
- en: Playtesting the level
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试关卡
- en: The last step to make our level playable is to add the necessary components
    (that is, **PlayerController** and physics), adjust the component values, and
    assign the component references.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的关卡可玩性的最后一步是添加必要的组件（即**PlayerController**和物理），调整组件值，并分配组件引用。
- en: 'Let’s do this now with the following steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们按照以下步骤来做：
- en: Open the **Player** Prefab in **Prefab Mode** by selecting it in the **Hierarchy**
    or selecting the **Prefab** asset in the **Project** window, and then click **Open**
    at the top of the **Inspector**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**层次结构**中选择或在**项目**窗口中选择**预制**资产，然后在**检查器**顶部点击**打开**，以**预制模式**打开**玩家**预制。
- en: Add a `collider`, and selecting it in the results – this will provide physics
    interactions with other colliders in the environment via Unity’s built-in 2D physics
    engine (Box2D).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`collider`，并在结果中选择它——这将通过Unity内置的2D物理引擎（Box2D）与环境中的其他碰撞体提供物理交互。
- en: Adjust the collider to fit the graphics for your player using both the **Offset**
    and **Size** fields, then use the **Edit Collider** button to move it manually
    into position in the scene View.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**偏移**和**大小**字段调整碰撞体以适应玩家的图形，然后使用**编辑碰撞体**按钮在场景视图中手动将其移动到适当的位置。
- en: Add a `rigidbody`, and selecting it in the results – this will provide the physics
    properties to our player character, such as how it’s affected by gravity, its
    mass, drag, position/rotation constraints, and the type of `100`) and `1`) to
    refine the player movement (adjust to your preferences).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`rigidbody`，并在结果中选择它——这将为我们玩家的角色提供物理属性，例如它如何受到重力的影响、它的质量、阻力、位置/旋转约束以及`100`和`1`的类型来细化玩家移动（调整到你的喜好）。
- en: Most importantly, disable `0` – in a top-down environment, everything is already
    *sitting on the ground*, so we don’t assign any gravity (if we did, the object
    would fall toward the bottom of the screen since gravity is based on the *y* axis;
    this works well for a 2D side-on game view).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最重要的是，禁用`0`——在俯视环境中，一切已经*坐在地面上*，所以我们不分配任何重力（如果我们分配了，由于重力基于*y*轴，对象会向屏幕底部坠落；这对于2D侧面游戏视图来说效果很好）。
- en: Add the **PlayerController** script by using the **Add Component** button in
    the **Inspector** or dragging the script from the **Project** window onto **Player**
    in the **Hierarchy** window or, with the **Player** object already selected, into
    the **Inspector**.*   Assign the `PlayerController` script uses.![Figure 3.3 –
    The Player Prefab components configuration](img/B18347_03_03.jpg)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在**检查器**中使用**添加组件**按钮或在**项目**窗口中拖动脚本到**层次结构**窗口中的**玩家**，或者，在**玩家**对象已经选择的情况下，将其拖入**检查器**，添加**PlayerController**脚本。![图3.3
    – 玩家预制组件配置](img/B18347_03_03.jpg)
- en: Figure 3.3 – The Player Prefab components configuration
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 玩家预制组件配置
- en: That’s it! We can now press the **Play** button on the main toolbar to playtest
    our level design.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在我们可以按下主工具栏上的**播放**按钮来测试我们的关卡设计。
- en: The ladybug will rotate to face the mouse pointer’s position and move in the
    direction it’s facing while the spacebar is being held down. Tiles on the **Tilemap**
    with **TilemapCollider2D** assigned will prevent the player from moving into those
    areas.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 瓢虫会旋转以面对鼠标指针的位置，并在按下空格键时朝着面对的方向移动。在**Tilemap**上分配了**TilemapCollider2D**的地砖将阻止玩家进入这些区域。
- en: 'Now is an excellent time to adjust the values on the `PlayerController`. Here,
    you can see the default values we started with:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是调整`PlayerController`上的值的好时机。在这里，你可以看到我们开始的默认值：
- en: '![Figure 3.4 – The PlayerController Inspector field values](img/B18347_03_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 玩家控制器检查器字段值](img/B18347_03_04.jpg)'
- en: Figure 3.4 – The PlayerController Inspector field values
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 玩家控制器检查器字段值
- en: Making these adjustments affects the game feel and the overall player experience,
    so spend time fine-tuning these values until it just *feels right* to you as the
    game designer. Have fun!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调整会影响游戏感觉和整体玩家体验，所以花时间微调这些值，直到它对你这个游戏设计师来说感觉“恰到好处”。祝您玩得开心！
- en: Tip
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'When you find values that you like and want to quickly go back and forth between
    them during testing (without having to write them on a scratch pad somewhere),
    you can use **Presets** (the *slider icon* on the right side of the **Component**
    title bar): [https://docs.unity3d.com/2022.3/Documentation/Manual/Presets.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Presets.xhtml)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你找到你喜欢的值，并希望在测试期间快速在这些值之间来回切换（而无需在某个地方写下它们），你可以使用 **预设**（**组件**标题栏右侧的 *滑块图标*）：[https://docs.unity3d.com/2022.3/Documentation/Manual/Presets.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Presets.xhtml)
- en: In this section, you learned how to read input directly from an input device
    to move the player character with a custom C# script while using physics, you
    explored the timesaving and powerful features adding a CM vcam provides, and you
    understood that playtesting is about refining values to get the right game feel
    for a good player experience.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何直接从输入设备读取输入来使用自定义 C# 脚本移动玩家角色，同时使用物理，你探索了添加 CM vcam 提供的节省时间和强大的功能，并了解到游戏测试是关于调整数值以获得良好的玩家体验的游戏感觉。
- en: Bonus activity
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励活动
- en: Make the ladybug player character move while also holding down the left mouse
    button.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在按住左鼠标按钮的同时移动瓢虫玩家角色。
- en: In the next section, we’ll implement some interactions for the player by coding
    collecting pickups.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过编写收集拾取的代码来实现一些玩家交互。
- en: Game mechanics and how to create with code (components)
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏机制及其代码创建方法（组件）
- en: This section will explore the concept of game mechanics and what that means
    for the gameplay in the *Outer World* collection game we’re making. We’ll define
    precisely the mechanic we’ll be using in a brief expansion on the **Game Design
    Document** (**GDD**) and finish with writing the code for the mechanic by adding
    a new Prefab with a custom component that uses a 2D physics interaction event.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨游戏机制的概念以及这对我们制作的 *外部世界* 收集游戏中的游戏玩法意味着什么。我们将在对 **游戏设计文档** (**GDD**) 的简要扩展中精确定义我们将使用的机制，并通过添加一个使用
    2D 物理交互事件的自定义组件的新 Prefab 来编写该机制的代码。
- en: What is a game mechanic?
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是游戏机制？
- en: A **game mechanic** can loosely be defined as the rules that dictate the gameplay
    and how the player is supposed to engage with the mechanics sufficiently to provide
    a joyful and entertaining experience. Examples of some popular types of gameplay
    mechanics include collecting, moving, shooting, and building things.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏机制**可以大致定义为规定游戏玩法以及玩家应该如何与机制充分互动以提供愉快和娱乐体验的规则。一些流行的游戏玩法机制类型包括收集、移动、射击和建造东西。'
- en: Some game mechanic rules that dictate gameplay are followed by the game and
    not the player, such as the game only unlocking a new level when the player completes
    the current level.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一些规定游戏玩法的游戏机制规则是由游戏而不是玩家遵循的，例如，只有当玩家完成当前关卡时，游戏才会解锁新关卡。
- en: Buff & Nerf | game balance
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 增益 & 削弱 | 游戏平衡
- en: 'Changing elements of mechanics to a player’s advantage is known as the **Buff**
    and to their disadvantage is the **Nerf**, keeping the game balanced: [https://www.inverse.com/gaming/nerf-buff-meaning-video-games-coined-series](https://www.inverse.com/gaming/nerf-buff-meaning-video-games-coined-series)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将机制元素改变为玩家的优势称为 **增益**，而对其不利则称为 **削弱**，以保持游戏平衡：[https://www.inverse.com/gaming/nerf-buff-meaning-video-games-coined-series](https://www.inverse.com/gaming/nerf-buff-meaning-video-games-coined-series)
- en: Let’s explore adding our game’s primary mechanic now.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来探索如何添加我们游戏的主要机制。
- en: Adding to our GDD
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加到我们的 GDD
- en: 'The game mechanic we’re going to add to our GDD and implement is the collection
    of pickup items in the environment. We can describe it as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加到我们的 GDD 并实现的游戏机制是环境中拾取物品的收集。我们可以这样描述它：
- en: '| **Name** **of Game** | Outer World |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **游戏名称** | 外部世界 |'
- en: '| **What is the core game mechanic for the** **collection game?** | The player
    will find and collect “water diamonds” throughout the environment by touching
    them until all are collected, or the countdown timer expires. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **收集游戏的核心理念是什么** **？** | 玩家将通过触摸它们直到收集完所有“水钻石”或倒计时计时器到期，在环境中找到并收集“水钻石”。|'
- en: Table 3.1 – The GDD game mechanic addition
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – GDD 游戏机制新增
- en: Additional reading | Game mechanics
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读更多 | 游戏机制
- en: 'Will Wright (*The Sims* creator), *5 Tips for Writing Game* *Mechanics*: [https://www.masterclass.com/articles/will-wrights-tips-for-writing-game-mechanics#will-wrights-5-tips-for-writing-game-mechanics](https://www.masterclass.com/articles/will-wrights-tips-for-writing-game-mechanics#will-wrights-5-tips-for-writing-game-mechanics)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 威尔·赖特（*模拟人生*的创造者），*编写游戏机制 5 个技巧*：[https://www.masterclass.com/articles/will-wrights-tips-for-writing-game-mechanics#will-wrights-5-tips-for-writing-game-mechanics](https://www.masterclass.com/articles/will-wrights-tips-for-writing-game-mechanics#will-wrights-5-tips-for-writing-game-mechanics)
- en: Now that we have our core game mechanic defined, let’s put the code together
    to make it work!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了核心游戏机制，让我们把代码组合起来使其工作！
- en: Bonus activity
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励活动
- en: By exploring the idea of adding additional physics-based objects to our level,
    design a game mechanic that involves the player pushing around tile blocks that
    we’ll call *toolboxes*. The toolboxes could inconvenience the player and slow
    them down in pursuit of collecting the *water diamonds* or provide additional
    gameplay by requiring them to be moved into specific locations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索向我们的关卡添加基于物理的额外对象的想法，设计一个涉及玩家推动我们称之为 *工具箱* 的瓷砖块的游戏机制。工具箱可能会给玩家带来不便并减慢他们收集
    *水钻石* 的速度，或者通过要求它们移动到特定位置来提供额外的游戏玩法。
- en: Collecting pickups
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集拾取物
- en: A lot of the basics for working within Unity and creating component-based scripts
    have been covered by this point, so we’re going to be moving a bit faster in putting
    things together – while not spending as much time explaining the small details.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了在 Unity 中工作以及创建基于组件的脚本的大部分基础知识，所以我们在组装事物时会稍微快一点 – 而不是花太多时间解释细节。
- en: The primary objective of our core mechanic is collecting objects. We’ll accomplish
    this by taking advantage of the interaction events the 2D physics engine provides.
    Here we go!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们核心机制的主要目标是收集物体。我们将通过利用 2D 物理引擎提供的交互事件来实现这一点。让我们开始吧！
- en: Creating a collectible item Prefab
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建可收集物品 Prefab
- en: 'First, we need a sprite for our collected object – the *water diamond*. You
    can either create your sprite art within Unity (as we did with the ladybug character)
    or import one (the suggested size is a 64 px square). Create a new Prefab for
    the collection object with the following steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的收集对象 – *水钻石* – 创建一个精灵。您可以在 Unity 中创建您的精灵艺术（就像我们为瓢虫角色所做的那样）或导入一个（建议的大小是
    64 像素的正方形）。按照以下步骤创建一个用于收集对象的新的 Prefab：
- en: Add your *water diamond* sprite to the scene.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的 *水钻石* 精灵添加到场景中。
- en: Parent the **Graphics** object’s sprite to an empty GameObject (container).
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Graphics** 对象的精灵附加到一个空的 GameObject（容器）上。
- en: On the parent GameObject, add a primitive collider that best fits the shape
    of your *water diamond* sprite – I chose **CapsuleCollider2D**, as seen in *Figure
    3**.5*.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在父 GameObject 上添加一个最适合您的 *水钻石* 精灵形状的原始碰撞器 – 我选择了 **CapsuleCollider2D**，如 *图
    3**.5* 所示。
- en: Enable the **IsTrigger** field on the **CapsuleCollider2D** component since
    we don’t want any collision interactions to occur between the diamond and the
    Player; we just want to receive a message for the interaction event.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **CapsuleCollider2D** 组件上启用 **IsTrigger** 字段，因为我们不希望钻石和玩家之间发生任何碰撞交互；我们只想接收交互事件的提示。
- en: Additional reading | Unity documentation
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读更多 | Unity 文档
- en: The simple takeaway here is that when **IsTrigger** is enabled, no physical
    collisions between objects will occur – objects won’t move in response to forces
    applied.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，当 **IsTrigger** 被启用时，物体之间不会发生物理碰撞 – 物体不会对施加的力做出反应。
- en: '**Collider.isTrigger**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Collider-isTrigger.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Collider-isTrigger.xhtml)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**Collider.isTrigger**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Collider-isTrigger.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Collider-isTrigger.xhtml)'
- en: Let’s not forget to ensure the sprite is drawn at the correct depth in our `Sprite
    Renderer`’s `100`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们不要忘记确保精灵在 `Sprite Renderer` 的 `100` 中以正确的深度绘制。
- en: If you created your sprite within Unity using the Sprite Creator tool’s shapes,
    select the **Graphics** parent object and add a **Sorting Group** component to
    assign the Sorting Layer.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用 Sprite Creator 工具的形状在 Unity 中创建了自己的精灵，请选择 **Graphics** 父对象，并添加一个 **Sorting
    Group** 组件以分配排序层。
- en: Drag the root object the sprite was parented to into the `Assets/Prefabs` folder
    in the **Project** window.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将精灵的父对象拖动到 **Project** 窗口中的 `Assets/Prefabs` 文件夹。
- en: Tip | Unity documentation
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 | Unity 文档
- en: Objects in the **Hierarchy** window turn blue and have the right caret (arrow)
    to their right when the GameObject is made into a Prefab. Clicking the caret will
    take you into **Prefab Mode** in the context of the scene (as shown in *Figure
    3**.5*).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GameObject 被制作成 Prefab 时，**Hierarchy** 窗口中的对象会变成蓝色，并且在其右侧有正确的光标（箭头）。点击光标将进入场景中的
    **Prefab 模式**（如图 *3**.5* 所示）。
- en: '*Editing a Prefab in Prefab Mode* | *Editing in* *context*: [https://docs.unity3d.com/2022.3/Documentation/Manual/EditingInPrefabMode.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/EditingInPrefabMode.xhtml)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 Prefab 模式下编辑 Prefab* | *在上下文中编辑*：[https://docs.unity3d.com/2022.3/Documentation/Manual/EditingInPrefabMode.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/EditingInPrefabMode.xhtml)'
- en: 'You can verify your collectible **Water Diamond** Prefab setup with the following
    screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下截图验证你的可收集 **Water Diamond** Prefab 设置：
- en: '![Figure 3.5 – Water Diamond Prefab with collider](img/B18347_03_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 带有碰撞器的 Water Diamond Prefab](img/B18347_03_05.jpg)'
- en: Figure 3.5 – Water Diamond Prefab with collider
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 带有碰撞器的 Water Diamond Prefab
- en: Additional reading | Unity documentation
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 更多阅读 | Unity 文档
- en: '**Collider** **2D**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/CapsuleCollider2D.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/CapsuleCollider2D.xhtml)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**Collider 2D**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/CapsuleCollider2D.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/CapsuleCollider2D.xhtml)'
- en: '**Optimizing Physics** **Performance**: [https://docs.unity3d.com/2022.3/Documentation/Manual/iphone-Optimizing-Physics.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/iphone-Optimizing-Physics.xhtml)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化物理性能**：[https://docs.unity3d.com/2022.3/Documentation/Manual/iphone-Optimizing-Physics.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/iphone-Optimizing-Physics.xhtml)'
- en: 'Note that the performance order of 2D colliders, from the fastest to slowest,
    is: **Circle**, **Capsule**, **Box**, **Composite**, **Polygon**, and then **Edge**.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，2D 碰撞器的性能顺序（从最快到最慢）是：**圆形**、**胶囊**、**盒子**、**复合**、**多边形**，然后是 **边缘**。
- en: Okay, we have our Prefab for the collectible item’s sprite; now, let’s code
    the interaction.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经有了可收集物品精灵的 Prefab；现在，让我们编写交互代码。
- en: Creating the CollectItem component
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 CollectItem 组件
- en: 'Create a new script in the `Scripts` folder and name it `CollectItem`. Replace
    the generated code with the following template:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Scripts` 文件夹中创建一个新的脚本，并将其命名为 `CollectItem`。用以下模板替换生成的代码：
- en: '[PRE0]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s have a look at the code line by line:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看代码：
- en: The `Debug.Log()` line in `Start()` will just output a message to our `Start()`
    method was called on. We can use this to verify that all of the collectible item
    objects we’ll add to the scene are *registering* themselves. We’ll be using this
    to increment the count for total items needing to be collected in the level (the
    10 in *0 of 10*) when we add our UI in the next section.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Start()` 中的 `Debug.Log()` 行只会输出一条消息到我们的 `Start()` 方法被调用。我们可以使用这个方法来验证我们将添加到场景中的所有可收集物品对象都在
    *注册* 自己。当我们添加 UI 时，我们将使用这个方法来增加需要收集的总物品数量（下一节中的 *0 of 10* 中的 10）。'
- en: $ string interpolation | C#
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: $ 字符串插值 | C#
- en: The dollar sign (**$**) in **Debug.Log($"{gameObject.name}'s Start called");**
    is for identifying an interpolated string. The text within **{}** (open/close
    squiggly brackets) in the string literal (represented by two double quotes (**""**))
    is a string result of the inserted code (usually a variable or expression).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Debug.Log($"{gameObject.name}'s Start called");** 中的美元符号（**$**）用于标识一个插值字符串。在字符串字面量（由两个双引号
    **""** 表示）中的 **{}**（开放/关闭波浪括号）内的文本是插入代码的字符串结果（通常是变量或表达式）。
- en: 'Refer to the C# language reference for additional reading: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下 C# 语言参考以获取更多信息：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated)
- en: Because we’ve added a second parameter to the `Debug.Log()` call (`gameObject`),
    when the `gameObject` (camelCase) keyword refers to the current GameObject (PascalCase)
    the component is running on (also provided by the `MonoBehaviour` base class).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在 `Debug.Log()` 调用中添加了第二个参数（`gameObject`），当 `gameObject`（驼峰式命名）关键字指向当前组件正在运行的
    GameObject（帕斯卡式命名）时（也由 `MonoBehaviour` 基类提供）。
- en: Optimization note | Unity documentation
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 优化提示 | Unity 文档
- en: Note that you’ll want to comment out **Debug.Log()** statements for performance
    reasons once you’ve finished testing and they are no longer needed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦测试完成并且不再需要，出于性能考虑，您可能需要注释掉 **Debug.Log()** 语句。
- en: '**Debug**: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-Debug.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-Debug.xhtml)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试**: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-Debug.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-Debug.xhtml)'
- en: '`OnTriggerEnter2D(Collider2D collision)` is where the magic happens. This Unity
    message is called when a collision occurs between two physics objects where one
    of the objects has a collider `IsTrigger` value enabled. We receive a reference
    to the other object’s collider with the collision parameter value (we’ll be using
    `collision` to detect whether the other object is the Player in the next section).'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnTriggerEnter2D(Collider2D collision)` 是魔法发生的地方。当两个物理对象发生碰撞，其中一个对象启用了碰撞器
    `IsTrigger` 值时，会调用此 Unity 消息。我们通过碰撞参数值接收另一个对象的碰撞器引用（我们将在下一节中使用 `collision` 来检测另一个对象是否是玩家）。'
- en: '`OnDestroy()` is another Unity message that is called when the GameObject in
    the scene is destroyed – by using the `Destroy()` method, as you can see in the
    `OnTriggerEnter2D()` method previously, when the Player collides with the collectible
    item, it will process the collection of the item in `OnTriggerEnter2D()` and then
    remove the item from the scene by calling `Destroy(gameObject)` (so items cannot
    be collected again).'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnDestroy()` 是另一个 Unity 消息，当场景中的 GameObject 被销毁时会被调用 - 如您在之前的 `OnTriggerEnter2D()`
    方法中看到的，当玩家与可收集物品发生碰撞时，它将在 `OnTriggerEnter2D()` 中处理物品的收集，然后通过调用 `Destroy(gameObject)`
    从场景中移除物品（因此物品不能再次被收集）。'
- en: Save the `CollectItem` script and add it as a component to your `Collider` components
    must be on the same GameObject as the collider – you can see in the `CollectItem`
    script is just below the `CapsuleCollider2D` component.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CollectItem` 脚本保存并添加到您的 `Collider` 组件中，这些组件必须位于与碰撞器相同的 GameObject 上 - 您可以在
    `CollectItem` 脚本中看到它就在 `CapsuleCollider2D` 组件下方。
- en: 'Have a look at the following screenshot displaying the `Debug.Log()` output
    in the **Console** while playtesting and running the ladybug character into the
    *water* *diamond* sprites:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看以下屏幕截图，显示在 **Console** 中进行游戏测试并运行瓢虫角色进入 **水** **钻石**精灵时的 `Debug.Log()` 输出：
- en: '![Figure 3.6 – Playtesting the collectible items](img/B18347_03_06.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 测试可收集物品](img/B18347_03_06.jpg)'
- en: Figure 3.6 – Playtesting the collectible items
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 测试可收集物品
- en: Important note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Two additional things worth mentioning in the previous screenshot are as follows.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的屏幕截图中，还有两件额外的事情值得提及。
- en: The **Editor** is tinted orange because I’ve assigned a color to show when entering
    **Play Mode** – set colors in **Edit** | **Preferences** | **Colors** then **General**
    | **Playmode tint**. This tint *should* remind you that you are in **Play Mode**,
    and most changes you make to **Component** values will not be saved when stopping
    (changes in file-based assets will be saved, however).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**编辑器** 被染成橙色，因为我已经分配了一个颜色来显示在进入 **Play Mode** 时 - 在 **Edit** | **Preferences**
    | **Colors** 然后 **General** | **Playmode tint** 中设置颜色。这种着色 *应该* 提醒您正在 **Play Mode**
    中，并且您对 **Component** 值所做的大多数更改在停止时将不会保存（然而，基于文件的资产中的更改将被保存）。'
- en: I’ve added some empty GameObjects to the **Scene Hierarchy** to organize objects
    into logical groupings. For any object added for purely organizational purposes
    (that is, no child assets are being used in the game), you can assign it an **EditorOnly**
    tag so that it is not included in the final game build (saving some resources
    in the process).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经添加了一些空的 GameObject 来组织 **场景层次结构** 中的对象到逻辑分组中。对于仅用于组织目的添加的对象（即，游戏中没有使用子资产），您可以分配一个
    **EditorOnly** 标签，这样它就不会包含在最终的游戏构建中（在这个过程中节省一些资源）。
- en: You can go ahead and duplicate the **Water Diamond** Prefab by selecting one
    in the **Hierarchy** and pressing *Ctrl*/*Cmd* + *D* several times and repositioning
    it throughout the level. Playtest to get a feel for how well you can move around
    the level to reach each of the items!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续复制 **水钻** 预制件，通过在 **层次结构** 中选择一个并多次按 *Ctrl*/*Cmd* + *D* 来实现，并在关卡中重新定位它。进行测试以了解您在关卡中移动以到达每个物品的能力！
- en: Tip
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can organize all of the **Water Diamond** collectible items in the scene
    in an empty root GameObject – just make sure the root object is at (**0**, **0**,
    **0**) before dragging in the items.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在场景中的空根 GameObject 中组织所有的 **水钻** 可收集物品 – 只需确保在拖入物品之前，根对象位于（**0**，**0**，**0**）。
- en: You can quickly reset the **Transform** component of a GameObject in the **Inspector**
    by clicking the vertical ellipsis button (to the right of the **Help** and **Presets**
    buttons in the title bar) and choosing **Reset**.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击**检查器**中 GameObject 的 **Transform** 组件旁边的垂直省略号按钮（位于标题栏中的 **帮助** 和 **预设**
    按钮右侧）并选择 **重置** 来快速重置 GameObject 的 **Transform** 组件。
- en: With that, our game is shaping into something fun! But what about adding to
    the challenge? We’ll use hazards to slow the player when they touch one… look
    out!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的游戏正在逐渐形成一个有趣的游戏！但关于增加挑战呢？我们将使用危险来减缓玩家在接触它们时的速度…小心！
- en: Hitting hazards
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发危险
- en: We’ve previously discussed hazards in the game, and level design, so now let’s
    look at implementing them before coming to a win/lose condition in the final section
    of this chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了游戏中的危险和关卡设计，现在让我们来看看在章节的最后部分实现它们之前如何实施它们。
- en: 'First, let’s define our nerf mechanic by adding it to our GDD document:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过将其添加到我们的 GDD 文档中来定义我们的 nerf 机制：
- en: '| **Name** **of game** | Outer World |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **游戏名称** | 外部世界 |'
- en: '| **What is a nerf mechanic for the player in the** **collection game?** |
    The player’s speed will be decreased when they touch a “toxic puddle” in the environment
    – increasing the challenge of collecting all “water diamonds” before the timer
    expires. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| **在收集游戏中，玩家遇到的 nerf 机制是什么？** | 当玩家触摸环境中的“有毒水坑”时，他们的速度会降低 – 增加在计时器到期前收集所有“水钻”的挑战。
    |'
- en: Table 3.2 – The GDD nerf mechanic addition
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2 – GDD 中添加的 nerf 机制
- en: Okay, we need to add *toxic puddles* to the level then! We could do these the
    same way we created the **Water Diamond** Prefabs and populate the level in that
    fashion, but let’s take a different approach here and revisit our tilemaps.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们需要在关卡中添加 *有毒水坑*！我们可以像创建 **水钻** 预制件并以此方式填充关卡一样做这些，但让我们采取不同的方法，并重新审视我们的贴图。
- en: 'Add toxic puddles in challenging locations throughout the level by following
    these steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤在关卡中的挑战性位置添加有毒水坑：
- en: Create a new `Tilemap - Hazards -` `Trigger`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Tilemap - Hazards -` `Trigger`。
- en: Open the **Tile Palette** (**Window** | **2D** | **Tile Palette**) and make
    sure the active tilemap is the tilemap we just created in the previous step.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **贴图调色板**（**窗口** | **2D** | **贴图调色板**）并确保活动贴图是我们之前步骤中创建的贴图。
- en: Select **Environment Objects** from the available **Palettes** dropdown menu
    list.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用的 **调色板** 下拉菜单中选择 **环境对象**。
- en: Select the *black splotch/puddle* sprite from the available tiles and use the
    **Paintbrush** tool (shortcut key *B*) to scatter these tiles in strategic spots
    throughout your level (my suggestion would be to place them near water diamonds!).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用的贴图中选择 *黑色斑点/水坑* 精灵，并使用 **画笔** 工具（快捷键 *B*）将这些贴图散布在您关卡中的战略位置（我的建议是在水钻附近放置它们！）。
- en: Since we want to make the toxic puddles interactable (via the physics engine),
    add a `TilemapCollider2D` component to the **Tilemap** GameObject in the **Hierarchy**.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望有毒水坑可交互（通过物理引擎），请向 **层次结构** 中的 **Tilemap** GameObject 添加一个 `TilemapCollider2D`
    组件。
- en: Compared to the previous collision objects’ `TileMapCollider2D.IsTrigger` value
    so that we can use the `OnTriggerEnter2D()` event to respond to the collision.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前碰撞对象的 `TileMapCollider2D.IsTrigger` 值进行比较，以便我们可以使用 `OnTriggerEnter2D()` 事件来响应碰撞。
- en: 'Here is what the setup looks like with the new hazards tilemap, toxic puddles
    painted in the level (selected in the Tile Palette), and `TileMapCollider2D`’s
    **Is Trigger** box ticked:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用新的危险区域贴图、在关卡中绘制的有毒水坑（在贴图调色板中选择）和 `TileMapCollider2D` 的 **Is Trigger** 复选框勾选的设置看起来像：
- en: '![Figure 3.7 – The Hazards Tilemap trigger collider setup](img/B18347_03_07.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 危险区域贴图触发碰撞器设置](img/B18347_03_07.jpg)'
- en: Figure 3.7 – The Hazards Tilemap trigger collider setup
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 危险区域贴图触发碰撞器设置
- en: In *Figure 3**.7*, you can see that I’ve already added a `TouchHazard` component
    for the Player interaction with the hazard tilemap’s tiles.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3*.7 中，你可以看到我已经为玩家与危险 tilemap 的瓦片交互添加了一个 `TouchHazard` 组件。
- en: 'Let’s have a look at the `TouchHazard` script:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `TouchHazard` 脚本：
- en: '[PRE1]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let’s break it down point by point:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一点一点地分解它：
- en: The first new line you’ll notice here is we’ve added some *header information*.
    `[Header]` is an attribute that we can decorate the public field with to show
    some information to the developer – or designer - viewable in the **Inspector**
    along with a field. You can see this message in the **Inspector** in *Figure 3**.7*.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在这里首先会注意到的新行是我们添加了一些 *标题信息*。`[Header]` 是一个可以用来装饰公共字段的属性，以便在 **检查器**中向开发者或设计师显示一些信息，与字段一起可见。你可以在
    *图 3*.7 中的 **检查器**中看到这条信息。
- en: Additional reading | Unity documentation
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读 | Unity 文档
- en: '**Attribute**: [https://docs.unity3d.com/2022.3/Documentation/Manual/Attributes.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Attributes.xhtml)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**: [https://docs.unity3d.com/2022.3/Documentation/Manual/Attributes.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Attributes.xhtml)'
- en: The first public variable we’re declaring here – `Player` – is for the `PlayerController`
    reference. Instead of using a GameObject reference here – requiring an additional
    step to access a component added to the GameObject – we’re using the object type
    of the component to access its public members directly.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里声明的第一个公共变量 – `Player` – 是用于 `PlayerController` 引用的。我们不是在这里使用 GameObject
    引用 – 需要额外的步骤来访问添加到 GameObject 上的组件 – 我们使用组件的对象类型来直接访问其公共成员。
- en: We can see here again that we’re using the `OnTriggerEnter2D` message called
    when the 2D collider on the tilemap reports a collision.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里再次可以看到，我们正在使用当 tilemap 上的 2D 碰撞器报告碰撞时调用的 `OnTriggerEnter2D` 消息。
- en: Now that we have a collision occurring, we will do a quick test with an `if`
    statement to see *who* collided with the hazard tiles by using the `collision.CompareTag()`
    method.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个碰撞发生，我们将使用一个 `if` 语句进行快速测试，以查看 *谁* 与危险瓦片发生了碰撞，通过使用 `collision.CompareTag()`
    方法。
- en: Additional reading | Unity documentation
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读 | Unity 文档
- en: '**CompareTag**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.CompareTag.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.CompareTag.xhtml)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**CompareTag**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.CompareTag.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.CompareTag.xhtml)'
- en: We’re specifying which tag we want to detect by passing in the player’s tag
    assignment with `Player.tag`. So, let’s make sure the **Player** Prefab has the
    **Player** tag assigned to it now!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过传递玩家的标签分配来指定我们想要检测的标签，使用 `Player.tag`。所以，让我们确保现在 **Player** 预制件已经分配了 **Player**
    标签！
- en: 'With the **Player** object selected in the **Hierarchy**, go to the top of
    the **Inspector** and, using the **Tag** drop-down (*A*), select the **Player**
    tag from the list and then apply the change to the **Player** Prefab by using
    the **Overrides** drop-down and clicking **Apply All** (*B*), as seen in the following
    figure:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构**中选择 **Player** 对象，转到 **检查器**的顶部，使用 **标签**下拉菜单 (*A*) 从列表中选择 **Player**
    标签，然后通过使用 **覆盖**下拉菜单并点击 **应用所有** (*B*) 将更改应用到 **Player** 预制件，如图所示：
- en: '![Figure 3.8 – Set Player tag in Inspector and apply override](img/B18347_03_08.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 在检查器中设置玩家标签并应用覆盖](img/B18347_03_08.jpg)'
- en: Figure 3.8 – Set Player tag in Inspector and apply override
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 在检查器中设置玩家标签并应用覆盖
- en: Additional reading | Unity documentation
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读 | Unity 文档
- en: '**Tags**: [https://docs.unity3d.com/2022.3/Documentation/Manual/Tags.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Tags.xhtml)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**标签**: [https://docs.unity3d.com/2022.3/Documentation/Manual/Tags.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Tags.xhtml)'
- en: '**Tags and** **layers**: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-TagManager.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-TagManager.xhtml)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**标签和层**: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-TagManager.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-TagManager.xhtml)'
- en: If the result of our `if` statement returns `true` (the tags matched), then
    the `Debug.Log()` statement to notify us in the `SlowPlayerSpeed()` on the `Player`
    object reference. Accessing public members of an object is performed with `Player.SlowPlayerSpeed()`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的 `if` 语句的结果返回 `true`（标签匹配），那么 `Debug.Log()` 语句将在 `Player` 对象引用的 `SlowPlayerSpeed()`
    中通知我们。访问对象的公共成员是通过 `Player.SlowPlayerSpeed()` 来执行的。
- en: 'Let’s have a look at the *additions* required for adding the `SlowPlayerSpeed()`
    public method to our `PlayerController` class:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看添加`SlowPlayerSpeed()`公共方法到我们的`PlayerController`类所需的**添加内容**：
- en: '[PRE2]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see a few new variables are required to support slowing the player character’s
    speed for a short duration. The public variables, assignable in the `SlowedSpeed`:
    A `float` variable to specify the new slower move speed of the player, with a
    default value of `2f`.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到需要一些新的变量来支持短时间内减慢玩家角色的速度。在`SlowedSpeed`中可分配的公共变量：一个`float`变量，用于指定玩家新的较慢移动速度，默认值为`2f`。
- en: '`SlowedTime`: A `float` variable to specify the duration (in seconds) to keep
    the speed at the `SlowedSpeed` value, with a default value of `5f` (5 seconds).'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SlowedTime`：一个`float`变量，用于指定保持`SlowedSpeed`值的时间（以秒为单位），默认值为`5f`（5秒）。'
- en: The `Start()` method is used to cache (retain) the original `MoveSpeed` value
    of the player.*   The `SlowPlayerSpeed()` method has been added – called from
    the `TouchHazard` class – to set the current `MoveSpeed` of the player to the
    `SlowedSpeed` value to slow down movement.*   Following the `MoveSpeed` assignment,
    the `Invoke()` method (`MonoBehaviour`) is being used with a delay time value
    (the second parameter) to wait to call the new `RestoreSpeed()` method until the
    time specified by the `SlowedTime` variable has passed.*   We’re also using the
    C# `nameof()` expression with the `RestoreSpeed()` method here, so we aren’t using
    a string literal for the method name.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start()`方法用于缓存（保留）玩家的原始`MoveSpeed`值。*   我们还添加了`SlowPlayerSpeed()`方法——从`TouchHazard`类调用——将玩家的当前`MoveSpeed`设置为`SlowedSpeed`值以减慢移动速度。*   在将`MoveSpeed`赋值之后，使用`Invoke()`方法（`MonoBehaviour`）和延迟时间值（第二个参数）来等待，直到`SlowedTime`变量指定的时刻才调用新的`RestoreSpeed()`方法。*   我们在这里还使用了C#的`nameof()`表达式与`RestoreSpeed()`方法，因此我们不需要使用字符串字面量作为方法名。'
- en: Additional reading | Unity documentation
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '**Invoke**: [https://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.xhtml](https://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.xhtml)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**Invoke**: [https://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.xhtml](https://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.xhtml)'
- en: Finally, we’ve added the `RestoreSpeed()` method, which simply resets the `MoveSpeed`
    variable back to its original value – resetting player movement back to normal.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加了`RestoreSpeed()`方法，该方法简单地将`MoveSpeed`变量重置为其原始值——将玩家移动速度重置为正常。
- en: 'With that, we can now enable the hazards interaction by referring to *Figure
    3**.7*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们现在可以通过参考**图3**.7来启用危险交互。
- en: Add the **TouchHazard** component to the **Tilemap - Hazards -** **Trigger**
    object.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**TouchHazard**组件添加到**Tilemap - Hazards -** **Trigger**对象。
- en: Drag the **Player** object from the **Hierarchy** to the **Player** field in
    the **TouchHazard** component.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Hierarchy**中的**Player**对象拖放到**TouchHazard**组件中的**Player**字段。
- en: Verify the **SlowedSpeed** and **SlowedTime** values in the **PlayerController**
    component on the **Player**.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Player**上的**PlayerController**组件中验证**SlowedSpeed**和**SlowedTime**值。
- en: You’ll now want to playtest your level and adjust the speed and duration of
    the hazard effect until it suits you (I’ve chosen a `2` and a `5`, as my initial
    values); move the hazards and diamonds around the level to make it more challenging
    or fun. Again, just have fun with this part!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能想要测试您的关卡并调整危险效果的速率和持续时间，直到它符合您的需求（我选择了`2`和`5`，作为我的初始值）；将危险和钻石移动到关卡中，使其更具挑战性或更有趣。再次强调，只需享受这个过程即可！
- en: In this section, we understood what a game mechanic is and how to define it
    in the GDD, and we learned how to implement a collection mechanic and hazard that
    affects gameplay at our level. Next, we’ll be applying the finishing touches to
    the collection game by adding a UI, countdown timer, and win condition.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了什么是游戏机制以及如何在GDD中定义它，并学习了如何在我们这个级别实现收集机制和影响游戏玩法的影响。接下来，我们将通过添加UI、倒计时计时器和胜利条件来为收集游戏添加最后的修饰。
- en: Introduction to uGUI, the timer, counting, and winning
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: uGUI简介，计时器，计数和胜利
- en: The player needs to know what’s going on in the game, and the way we inform
    the player of this critical information is with a UI. Unity provides easy-to-use
    tooling for creating a UI, and it’s commonly referred to as **uGUI** (or **Unity
    Graphical User Interface**) – pronounced *You-gooey*. Formally, it’s just **Unity
    UI** (searching *ugui* in the documentation returns *No* *results found*).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家需要了解游戏中的情况，而我们通过UI向玩家传达这种关键信息。Unity提供了易于使用的工具来创建UI，通常被称为**uGUI**（或**Unity
    图形用户界面**）——发音为 *You-gooey*。正式名称为**Unity UI**（在文档中搜索 *ugui* 返回 *无* *结果找到*）。
- en: Unity UI is a GameObject-based UI system, so you’ll already be familiar with
    adding UI components to display and interact with UI controls in different ways.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Unity UI是一个基于GameObject的UI系统，因此您已经熟悉如何添加UI组件以以不同的方式显示和交互UI控件。
- en: Additional reading | Unity documentation
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '**Unity** **UI**: [https://docs.unity3d.com/Packages/com.unity.ugui%401.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.ugui%401.0/manual/index.xhtml)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unity** **UI**: [https://docs.unity3d.com/Packages/com.unity.ugui%401.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.ugui%401.0/manual/index.xhtml)'
- en: '*UI How* *Tos*: [https://docs.unity3d.com/Packages/com.unity.ugui%401.0/manual/UIHowTos.xhtml?q=unity%20ui](https://docs.unity3d.com/Packages/com.unity.ugui%401.0/manual/UIHowTos.xhtml?q=unity%20ui)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*UI 如何* *做*：[https://docs.unity3d.com/Packages/com.unity.ugui%401.0/manual/UIHowTos.xhtml?q=unity%20ui](https://docs.unity3d.com/Packages/com.unity.ugui%401.0/manual/UIHowTos.xhtml?q=unity%20ui)'
- en: 'The three key pieces of information the player needs to see in the collection
    game are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家在收集游戏中需要看到的三项关键信息如下：
- en: The number of items collected versus the total number to collect
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集的项目数量与需要收集的总数量对比
- en: The time remaining to collect all the items
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集所有项目剩余的时间
- en: The winning state (win/lose) when the game ends
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏结束时获胜（赢/输）的状态
- en: The first UI object we’ll discuss adding is the Canvas because it’s what’s responsible
    for drawing our UI.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论添加的UI对象是Canvas，因为它负责绘制我们的UI。
- en: Canvas
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Canvas
- en: The **Canvas** is a defined area where all the UI widgets are contained – think
    of it as a piece of paper where everything to be drawn will be contained on the
    page. As mentioned previously, the Unity UI is GameObject based, so the Canvas
    is a GameObject with a Canvas component. All UI widgets added to the scene must
    be children of a Canvas.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**Canvas** 是一个定义的区域，其中包含所有的UI小部件——可以将其想象为一张纸，所有要绘制的内容都将包含在页面上。如前所述，Unity UI是基于GameObject的，因此Canvas是一个具有Canvas组件的GameObject。场景中添加的所有UI小部件都必须是Canvas的子项。'
- en: 'Adding a UI Canvas to our scene is as simple as going to **UI** | **Canvas**
    in the **Create** menu. The first time a Canvas is added to the scene, it also
    adds an **EventSystem**. We’ll have to select the **EventSystem** and update it
    to use the new Input System. Click **Replace with InputSystemUIInputModule**,
    as seen in *Figure 3**.9*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将UI Canvas添加到场景中就像在**创建**菜单中选择**UI** | **Canvas**一样简单。第一次将Canvas添加到场景时，它还会添加一个**EventSystem**。我们需要选择**EventSystem**并将其更新为使用新的输入系统。点击**替换为InputSystemUIInputModule**，如图3.9所示：
- en: '![Figure 3.9 – Update EventSystem for new Input System](img/B18347_03_09.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 更新EventSystem以使用新的输入系统](img/B18347_03_09.jpg)'
- en: Figure 3.9 – Update EventSystem for new Input System
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 更新EventSystem以使用新的输入系统
- en: 'With the `0.5`, as shown in the following figure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图中所示，使用`0.5`：
- en: '![Figure 3.10 – Canvas Scaler](img/B18347_03_10.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – Canvas缩放器](img/B18347_03_10.jpg)'
- en: Figure 3.10 – Canvas Scaler
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – Canvas缩放器
- en: The Canvas is all set, so let’s add our first UI widget for displaying the current
    count of items collected!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas已经设置好了，现在让我们添加第一个UI小部件来显示收集的项目当前数量！
- en: TextMesh Pro
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TextMesh Pro
- en: '**TextMesh Pro** (**TMP**) is a set of tools for creating highly customizable
    and high-quality 2D and 3D UI text in your projects. We’ll use TMP text widgets
    to display all gameplay information, including the items collected, the countdown
    timer, and the win/lose message.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextMesh Pro**（**TMP**）是一套用于在项目中创建高度可定制和高质量的2D和3D UI文本的工具。我们将使用TMP文本小部件来显示所有游戏信息，包括收集的项目、倒计时计时器和胜负信息。'
- en: Additional reading | Unity documentation
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '**TextMeshPro**: [https://docs.unity3d.com/2022.3/Documentation/Manual/com.unity.textmeshpro.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/com.unity.textmeshpro.xhtml)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextMeshPro**: [https://docs.unity3d.com/2022.3/Documentation/Manual/com.unity.textmeshpro.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/com.unity.textmeshpro.xhtml)'
- en: '**TextMesh Pro** **documentation**: [https://docs.unity3d.com/Packages/com.unity.textmeshpro%404.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.textmeshpro%404.0/manual/index.xhtml)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextMesh Pro** **文档**：[https://docs.unity3d.com/Packages/com.unity.textmeshpro%404.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.textmeshpro%404.0/manual/index.xhtml)'
- en: 'With the Canvas object selected in the **Hierarchy**, use the **Create** menu
    to add a **UI** | **Text – TextMeshPro** text widget to the scene. If this is
    the first time you’re adding a **TextMeshPro** widget to your project, you’ll
    be prompted to install the essential resources. Click **Import** **TMP Essentials**:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择Canvas对象后，使用**创建**菜单将**UI** | **Text – TextMeshPro**文本小部件添加到场景中。如果你是第一次将**TextMeshPro**小部件添加到项目中，系统会提示你安装必需的资源。点击**导入**
    **TMP Essentials**：
- en: '![Figure 3.11 – The TMP Importer dialog](img/B18347_03_11.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – TMP导入对话框](img/B18347_03_11.jpg)'
- en: Figure 3.11 – The TMP Importer dialog
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – TMP导入对话框
- en: 'Use the following steps to make the collected item text shown in the bottom-left
    corner of the screen:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤在屏幕左下角显示收集物品文本：
- en: Rename the newly added TMP text object `Collected` `Count Text`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新添加的TMP文本对象重命名为`Collected` `Count Text`。
- en: 'To anchor the text to the bottom-left corner of the screen, use **Anchor Presets**
    (*A*), hold both the *Shift* (**Also set pivot**) and *Alt* (**Also set position**)
    keys down (*B*), then click the bottom-left anchor (*C*):'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将文本锚定到屏幕的左下角，使用**锚点预设** (*A*)，同时按住**Shift**（**也设置轴点**）和**Alt**（**也设置位置**）键（*B*），然后点击左下角的锚点（*C*）：
- en: '![Figure 3.12 – TextMeshPro rect anchor setting](img/B18347_03_12.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – TextMeshPro矩形锚点设置](img/B18347_03_12.jpg)'
- en: Figure 3.12 – TextMeshPro rect anchor setting
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – TextMeshPro矩形锚点设置
- en: 'Use the following settings to provide default text to display and style the
    text (refer to *Figure 3**.12* as a reference):'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下设置来提供默认文本以显示并设置文本样式（参考*图3**.12*作为参考）：
- en: '`0` `of 0`'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0` `of 0`'
- en: '**Font** **Style**: **Bold**'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字体样式**：**粗体**'
- en: '**Font** **Size**: **48**'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字体大小**：**48**'
- en: '**Extra Settings** | **Margin** | **Left**: **50**'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**额外设置** | **边距** | **左**：**50**'
- en: With that, we’re ready to have the text updated every time an item is collected.
    Let’s see how to tie it all together in the next section.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已准备好在每次收集物品时更新文本。让我们在下一节中看看如何将所有这些结合起来。
- en: Updating the pickup count
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新拾取计数
- en: The problem we’re going to solve now is *how is UI text updated when an item
    is collected?* We can refer to design patterns for a solution! We previously covered
    both the Singleton and Observer patterns, and either one will suit our needs here.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要解决的问题是如何在收集物品时更新UI文本？我们可以参考设计模式来找到解决方案！我们之前已经介绍了单例和观察者模式，任何一个都适合我们的需求。
- en: To provide an example in practice, we will use both, starting with the Singleton.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个实际应用的例子，我们将使用两个，从单例开始。
- en: The pickup count will be displayed as `GameManager`, will be responsible for
    holding the data (variables) for the collectibles, so this will become a Singleton
    instance.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 拾取计数将显示为`GameManager`，将负责保存收集品的（变量）数据，因此这将成为一个单例实例。
- en: The `Start()` method for each collectible item in the scene will be called when
    the game first runs, so we’ll use this to add each collectible item to the total
    items count.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏首次运行时，场景中每个可收集物品的`Start()`方法将被调用，因此我们将使用此方法将每个可收集物品添加到总物品计数中。
- en: 'Let’s first create the `GameManager` script and make it a Singleton instance
    by adding the following lines to the variable declaration section (near the top
    of the class):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建`GameManager`脚本，并通过在变量声明部分（靠近类顶部）添加以下行将其设置为单例实例：
- en: '[PRE3]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `GameManager` class itself is declared a `public static` property – we want
    to directly access the class from another type using the `Instance` variable.
    We’ve let `get` remain public, while declaring `set` as private so external classes
    will only be able to read.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameManager`类本身被声明为`public static`属性 – 我们希望使用`Instance`变量直接从另一个类型访问该类。我们让`get`保持公开，而将`set`声明为私有，这样外部类就只能读取。'
- en: In the `Awake()` method, we’re setting the `Instance` variable to `this`, the
    current class instance. We’re using an expression body here (indicated by `=>`)
    instead of the usual `{}` squiggly brackets (block body) to keep the code concise,
    since it’s only a single expression that’s needed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Awake()`方法中，我们将`Instance`变量设置为`this`，即当前类的实例。在这里我们使用表达式体（由`=>`表示）而不是通常的花括号（块体）来使代码更简洁，因为它只需要一个表达式。
- en: Property (C#)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 属性（C#）
- en: A C# property is a class member that uses explicit accessors for the **get**
    and **set** methods to read or write data values.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: C#属性是一个使用显式访问器`get`和`set`方法来读取或写入数据值的类成员。
- en: 'Now, we can add the variable for storing the total number of collectible items,
    the public method for incrementing the total, and the call to the incrementing
    method from the `CollectItem` class by following these steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加存储可收集物品总数的变量、公共方法来增加总数，以及通过以下步骤从`CollectItem`类调用增加方法：
- en: 'Add a private `_totalCollectibleItems` integer variable to the variable declaration
    section. Its accessor is private because it’s encapsulated only to change its
    value within the declaring class (with OOP encapsulation, it’s considered bad
    practice to modify variable values outside the class):'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在变量声明部分添加一个私有`_totalCollectibleItems`整型变量。它的访问器是私有的，因为它只封装在声明类内部以更改其值（在面向对象封装中，认为在类外部修改变量值是不良做法）：
- en: '[PRE4]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a public `AddCollectibleItem()` method with no return type (`void`), as
    an expression body, to increment the `_totalCollectibleItems` current value. The
    `++` unary arithmetic operator increments the operand by 1\. The `public` accessor
    means that we can call this method outside the declaring class, which we will
    do next from the `CollectItem` class via the Singleton instance:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在变量声明部分添加一个公共的`AddCollectibleItem()`方法，没有返回类型（`void`），作为一个表达式体，以增加`_totalCollectibleItems`当前值。`++`一元算术运算符将操作数增加1。`public`访问器意味着我们可以在声明类外部调用此方法，我们将在下一部分从`CollectItem`类通过单例实例来这样做：
- en: '[PRE5]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, in the `CollectItem` class, add the following to the bottom of the `Start()`
    method for calling the `GameManager` Singleton instance to add the collectible
    item to the total items count:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`CollectItem`类中，在`Start()`方法的底部添加以下内容，以调用`GameManager`单例实例并将可收集物品添加到总物品计数中：
- en: '[PRE6]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With that, we now know how many `Start()` will be called on every object instance
    in the scene. Easy-peasy!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们现在就知道每个场景中对象实例的`Start()`方法将被调用多少次了。简单易懂！
- en: 'The second part of the UI display for the collectible items requires the number
    of items currently collected. We’ll do that now with the second design pattern
    we’re covering in practice: Observer.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 可收集物品的UI显示的第二部分需要显示当前收集的物品数量。我们现在将使用我们在实践中覆盖的第二个设计模式：观察者来实现这一点。
- en: Incrementing collected item count
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增加收集项目数量
- en: We’ve already seen how to access the `GameManager` Singleton instance via a
    static variable. We’re going to do something similar with the `CollectItem` class
    to know when any item has been collected.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过静态变量访问`GameManager`单例实例。我们将对`CollectItem`类做类似处理，以便知道何时有项目被收集。
- en: Typically, every instance of an object in the scene is independent of one another
    – each with its independent members. We want `GameManager` to register and listen
    (that is, observe) for any one of the items being collected, so we’re going to
    accomplish this by invoking a static event – a static declaration will make it
    common across all class instances, so we won’t need a reference to any individual
    item’s instance.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，场景中每个对象的实例都是相互独立的——每个实例都有自己的独立成员。我们希望`GameManager`能够注册并监听（即观察）任何被收集的项目，因此我们将通过调用一个静态事件来实现这一点——静态声明将使其在所有类实例中通用，所以我们不需要引用任何单个项目实例。
- en: 'Let’s go ahead and add our static event to the `CollectItem` class, then register
    the listener from `GameManager` to take action when the event is invoked:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在`CollectItem`类中添加我们的静态事件，然后从`GameManager`注册监听器，以便在事件被调用时采取行动：
- en: 'Add the following public static variable declaration to `CollectItem`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CollectItem`中添加以下公共静态变量声明：
- en: '[PRE7]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `event` keyword is added to the declaration to enforce invocation only from
    within the declaring class – we don’t want external classes to be able to trigger
    the event!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将`event`关键字添加到声明中，以强制仅在声明类内部调用——我们不想让外部类能够触发事件！
- en: We’re using `UnityAction` here as a method delegate, so we can use it to refer
    to calling multiple methods through it or even pass it as a method argument. It’s
    also common practice to preface naming event delegates and methods with the word
    *On* (as in `OnItemCollected`).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`UnityAction`作为方法委托，因此我们可以通过它来引用调用多个方法，甚至将其作为方法参数传递。在命名事件委托和方法时，通常在单词*On*之前加前缀（例如`OnItemCollected`）也是常见做法。
- en: Additional reading | Unity documentation
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '**UnityAction**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Events.UnityAction.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Events.UnityAction.xhtml)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**UnityAction**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Events.UnityAction.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Events.UnityAction.xhtml)'
- en: 'Add the following line to the top of the `OnTriggerEnter2D()` method to invoke
    or *trigger* the event (also known as **event invocation**) when the item is collected:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnTriggerEnter2D()` 方法的顶部添加以下行以调用或 *触发* 事件（也称为 **事件调用**），当物品被收集时：
- en: '[PRE8]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The question mark and dot (`?.`) appended to `OnItemCollected` is a null-conditional
    operator – it will only perform the operation if the operand does not evaluate
    to `null`. In this case, it means if there are no registered listeners, we don’t
    want to throw a `NullReferenceException` error when calling `Invoke` (executing
    the event).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到 `OnItemCollected` 的问号和点 (`?.`) 是一个空条件运算符 – 它只有在操作数不评估为 `null` 时才会执行操作。在这种情况下，这意味着如果没有注册监听器，我们不想在调用
    `Invoke`（执行事件）时抛出 `NullReferenceException` 错误。
- en: NullReferenceException (C#)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: NullReferenceException (C#)
- en: A **NullReferenceException** (**NRE**) is an error that can occur when trying
    to access a member of a **null** object (not assigned).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**NullReferenceException**（**NRE**）是在尝试访问一个 **null** 对象（未分配）的成员时可能发生的错误。'
- en: 'Moving into the `GameManager` class now, we add a private variable to track
    the number of items collected by the player:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在进入 `GameManager` 类，我们添加一个私有变量来跟踪玩家收集的物品数量：
- en: '[PRE9]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The class encapsulates this variable – because its accessor is set to `private`
    – so, let’s add an `ItemCollected()` method that increments the count:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类封装了这个变量 – 因为它的访问器被设置为 `private` – 因此，让我们添加一个 `ItemCollected()` 方法来递增计数：
- en: '[PRE10]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’re simply incrementing the count by 1 every time an item is collected by
    using the ++ arithmetic operator after the variable (postfix).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是通过在变量后使用 `++` 算术运算符来递增计数，每次收集到物品时增加 1。
- en: 'What is the `ItemCollected()` method called now? Well, that’s where registering
    with the `CollectItem.OnItemCollected` event comes in. We’ll use the `OnEnable()`
    and `OnDisable()` Unity message events – these are called when the behavior is
    first enabled and active, then becomes disabled, respectively:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么，现在 `ItemCollected()` 方法是如何被调用的呢？这正是注册 `CollectItem.OnItemCollected` 事件的地方。我们将使用
    `OnEnable()` 和 `OnDisable()` Unity 消息事件 – 这些事件分别在行为首次启用并激活时调用，然后变为禁用：
- en: '[PRE11]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `+=` operator specifies adding an event handler method when subscribing
    to events. We’re registering the `ItemCollected` method to be called when the
    `CollectItem.ItemCollected` event is invoked (that is, registering a listener).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`+=` 运算符用于在订阅事件时指定添加事件处理方法。我们将注册 `ItemCollected` 方法，以便在调用 `CollectItem.ItemCollected`
    事件时被调用（即注册监听器）。'
- en: Important note
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To avoid resource leaks, unsubscribing from events should always be performed!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免资源泄露，应该始终执行取消订阅事件的操作！
- en: The `-=` operator specifies removing an event handler method to stop subscribing
    to events. We’re unregistering the `ItemCollected` method so that it will no longer
    be called when the `CollectItem.ItemCollected` event is invoked. Suppose we don’t
    unregister the event handler, and the object holding the handler method is destroyed.
    In that case, it will throw an `null`) – and we quite certainly won’t be happy
    with that!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`-=` 运算符用于指定移除事件处理方法以停止订阅事件。我们正在注销 `ItemCollected` 方法，以便在调用 `CollectItem.ItemCollected`
    事件时它将不再被调用。假设我们没有注销事件处理程序，并且包含处理方法的对象被销毁，那么它将抛出 `null`) – 我们肯定不会对此感到高兴！'
- en: Tip
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don’t forget, if the handler method isn’t already created, you can have VS generate
    the method for you by clicking on the **ItemCollected** text, then using *Alt/Cmd*
    + *Enter* and selecting **Generate** **method ItemCollected**.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，如果处理方法尚未创建，您可以通过单击 **ItemCollected** 文本，然后使用 *Alt/Cmd* + *Enter* 并选择 **Generate**
    **method ItemCollected** 来让 VS 为您生成方法。
- en: Now that we have our total and collected item values calculated, let’s update
    the UI display.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算出了总物品和收集物品的值，让我们更新 UI 显示。
- en: Updating the UI
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新 UI
- en: The text component displaying the collected item progress has already been added
    to the scene as **Collected Count Text**. Now, we need a way to reference and
    update the text displayed every time a **Water Diamond** is collected by the player.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 显示收集物品进度的文本组件已经作为 **Collected Count Text** 添加到场景中。现在，我们需要一种方法来引用和更新每次玩家收集到 **Water
    Diamond** 时显示的文本。
- en: We’ll create a new `UIManager` class to keep UI functionality separate from
    `GameManager` – following the single responsibility principle.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的 `UIManager` 类，以将 UI 功能与 `GameManager` 分离 – 遵循单一责任原则。
- en: 'Create a new script called `UIManager` and add the following code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本名为 `UIManager` 并添加以下代码：
- en: '[PRE12]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here’s what we’ll do when writing the new `UIManager` script.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写新的 `UIManager` 脚本时，我们将这样做。
- en: The first thing we’ll do is add a `using` statement for `TextMeshPro` (`TMPro`)
    so that we can reference the TMP text component’s properties.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要做的是添加一个 `using` 语句用于 `TextMeshPro` (`TMPro`)，这样我们就可以引用 TMP 文本组件的属性。
- en: We’ll then add a public variable for the **Collected Count Text** TMP object
    to be assigned to in the **Inspector** (for referencing).
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个公共变量用于 **收集计数文本** TMP 对象，在 **检查器** 中进行分配（用于引用）。
- en: When the game starts playing, we reset the `CollectedCountText` text to not
    display anything by using `string.Empty` (a zero-length string equivalent to `""`)
    – this will clear out any temporary display text we entered at design time for
    adjusting position and display values.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当游戏开始播放时，我们使用 `string.Empty`（一个零长度的字符串，相当于 `""`）重置 `CollectedCountText` 文本，以不显示任何内容
    – 这将清除我们在设计时输入的任何临时显示文本，以调整位置和显示值。
- en: Lastly, the `UpdateCollectedItemsText()` method is added that sets the `CollectedCountText`
    text. It has two method parameters, one for the current item count and the other
    for the total collectible items in the scene. We’re again using string interpolation
    to combine the variables’ values with *of* for display.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加了一个名为 `UpdateCollectedItemsText()` 的方法，用于设置 `CollectedCountText` 文本。它有两个方法参数，一个用于当前项目计数，另一个用于场景中的总可收集物品。我们再次使用字符串插值将变量的值与
    *of* 结合起来进行显示。
- en: 'Let’s return to the Unity Editor to complete the `UIManager` by adding it to
    the `CollectedCountText` field, as seen in the **Inspector** in the following
    figure:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 Unity 编辑器，通过将 `UIManager` 添加到 `CollectedCountText` 字段来完成 `UIManager`，如图中
    **检查器** 所示：
- en: '![Figure 3.13 – The Manager Inspector assignments](img/B18347_03_13.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 管理器检查器分配](img/B18347_03_13.jpg)'
- en: Figure 3.13 – The Manager Inspector assignments
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 管理器检查器分配
- en: 'The last thing we have to do to get our text displayed when collecting an object
    is to wire up the `UI.UpdateCollectedItemsText()` call in `GameManager.ItemCollected()`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集对象时，我们最后要做的就是在 `GameManager.ItemCollected()` 中连接 `UI.UpdateCollectedItemsText()`
    调用：
- en: 'In `GameManger`, add a public variable to hold the reference to the `UIManager`
    component:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameManger` 中添加一个公共变量来保存对 `UIManager` 组件的引用：
- en: '[PRE13]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Change the `ItemCollected()` method to now call the `UI.UpdateCollectedItemsText()`
    method passing in an incremented `_collectedItemCount` and the `_totalCollectibleItems`
    values:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ItemCollected()` 方法更改为现在调用 `UI.UpdateCollectedItemsText()` 方法，传递增加后的 `_collectedItemCount`
    和 `_totalCollectibleItems` 值：
- en: '[PRE14]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `++` operator in front of `_collectedItemCount` means that we will pre-increment
    its operand (prefix) and then read the value. We want the already incremented
    value to be passed to the method.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`_collectedItemCount` 前面的 `++` 操作符意味着我们将预增其操作数（前缀），然后读取其值。我们希望传递给方法的已经是增加后的值。'
- en: -- (C#)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: -- (C#)
- en: Note that the **--** unary arithmetic operator is also available in C#, and
    instead of incrementing the operand by 1, it decrements it. The same rules apply
    to a pre- or post-decrementer assignment.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，C# 中也提供了 **--** 一元算术操作符，它不是将操作数增加 1，而是将其减 1。相同的规则适用于前缀或后缀递减赋值。
- en: With that, the only remaining task is to drag `UIManager` to the `GameManager`
    component to assign its reference (refer to *Figure 3**.13*). Save your files
    and playtest!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，唯一剩下的任务是将 `UIManager` 拖到 `GameManager` 组件中，以分配其引用（参考 *图 3**.13*）。保存您的文件并测试游戏！
- en: We now have the game keeping track of the number of collected water diamonds
    and displaying progress to the player. It’s not quite a game yet, so we’ll add
    a simple countdown timer that we’ll later tie in to win/lose conditions in the
    next section.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，游戏正在跟踪收集的水钻数量并向玩家显示进度。这还不完全是一个游戏，所以我们将添加一个简单的倒计时计时器，我们将在下一节将其与胜负条件关联起来。
- en: The Timer script
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计时器脚本
- en: Referring to our GDD in *Table 3.1*, we know that the game will be lost if the
    countdown timer reaches 0 before the player collects all the water diamonds. For
    that, we’ll need a simple timer script that subtracts 1 second from the time every
    second. Let’s see how we can accomplish that and notify listeners of both time-changing
    and expiring events.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 参考我们的GDD中的*表3.1*，我们知道如果玩家在收集所有水钻之前，倒计时计时器达到0，游戏将失败。为此，我们需要一个简单的计时器脚本，每秒从时间中减去1秒。让我们看看我们如何实现这一点，并通知监听器时间变化和过期事件。
- en: 'Create a new script named `Timer` and refer to the following code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Timer`的新脚本，并参考以下代码：
- en: '[PRE15]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s have a look at the code and review what’s new:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码并回顾一下新内容：
- en: 'The `OnTimeUpdate` event has a parameter added: `UnityAction<int>`. This allows
    passing an integer value to the listener when the event is invoked (you can add
    up to four types as parameters with `UnityAction`). We use the passed-in `int`
    value (seconds) for the displayed time remaining in the UI.'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnTimeUpdate`事件增加了一个参数：`UnityAction<int>`。这允许在事件被调用时向监听器传递一个整数值（你可以通过`UnityAction`添加最多四种类型的参数）。我们使用传入的`int`值（秒数）来显示UI中的剩余时间。'
- en: We’ve declared two `int` type variables in a single line, `_timeSeconds` and
    `_timeCurrent`, by separating the variable names with a comma.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在一行中声明了两个`int`类型的变量`_timeSeconds`和`_timeCurrent`，通过逗号分隔变量名称。
- en: '`StartTimer()` is a public method that GameManager will call to start the timer
    countdown and begin the gameplay.'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StartTimer()`是一个公共方法，GameManager将调用它来开始计时器的倒计时并开始游戏。'
- en: '`InvokeRepeating()` is similar to `Invoke()` except, you guessed it, with a
    repeating time specified. We use this to update the timer value every second.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InvokeRepeating()`与`Invoke()`类似，除了，你猜对了，有一个重复的时间指定。我们使用这个方法每秒更新计时器值。'
- en: Additional reading | Unity documentation
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '**InvokeRepeating**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.InvokeRepeating.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.InvokeRepeating.xhtml)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**InvokeRepeating**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.InvokeRepeating.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.InvokeRepeating.xhtml)'
- en: '`InvokeRepeating()` takes a string representation for the method’s name as
    a parameter, just as `Invoke()` does, and any time you’re typing a string literal
    into the code, it should raise a flag – hardcoded strings or *magic strings* are
    pure evil! So, instead of typing a string, we’ll use the `nameof` expression to
    return the method name as a string. Sweet!'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvokeRepeating()`方法接受一个表示方法名称的字符串表示形式作为参数，就像`Invoke()`一样，并且每次你在代码中输入一个字符串字面量时，都应该触发一个标志——硬编码的字符串或*魔法字符串*是纯粹的邪恶！因此，我们不会直接输入一个字符串，而是使用`nameof`表达式来返回方法名称作为字符串。太棒了！'
- en: nameof (C#)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: nameof (C#)
- en: The **nameof** expression obtains a string constant from a variable, type, or
    member and is evaluated at compile time. This can be used instead of a string
    literal. It ensures no spelling errors and allows VS CodeLens to produce references.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof`表达式从变量、类型或成员中获取一个字符串常量，并在编译时进行评估。这可以用作字符串字面量的替代品。它确保没有拼写错误，并允许VS CodeLens生成引用。'
- en: The `StopTimer()` method calls `CancelInvoke()`, which will stop the timer counting
    down (by halting the `InvokeRepeating` process).
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StopTimer()`方法调用`CancelInvoke()`，这将停止计时器的倒计时（通过停止`InvokeRepeating`过程）。'
- en: The `UpdateTimer()` method is responsible for incrementing the timer and invoking
    the `OnTimeUpdate` event, passing the `_timeCurrent` value.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UpdateTimer()`方法负责增加计时器并调用`OnTimeUpdate`事件，传递`_timeCurrent`值。'
- en: 'Finally, we test for a timer expired condition using the `>=` comparison operator:
    is `_timeCurrent` greater than or equal to `_timeSeconds`? We use `>=` instead
    of `==` for working with an edge case where the time incremented may skip a second,
    and we’d miss an equal condition. Also, the timer will be stopped, and the `OnTimeExpired`
    event will be triggered.'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`>=`比较运算符测试计时器是否已过期条件：`_timeCurrent`是否大于或等于`_timeSeconds`？我们使用`>=`而不是`==`，因为在处理时间增加可能跳过一秒的边缘情况时，我们会错过一个相等条件。此外，计时器将被停止，并将触发`OnTimeExpired`事件。
- en: Whew! Not a long script, but several vital parts make it all function to work
    well with our other components. Speaking of, we can now integrate the `Timer`
    code with `GameManager` and `UIManager` to start the running of the timer and
    update the time remaining text in the UI.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！脚本不长，但几个关键部分使得它能够很好地与我们的其他组件协同工作。说到这个，我们现在可以将`Timer`代码与`GameManager`和`UIManager`集成，以开始计时器的运行并更新UI中的剩余时间文本。
- en: Additions to GameManager
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对GameManager的扩展
- en: With the `Timer` script all ready, let’s connect the `Timer` script in the `GameManager`
    class to start running the timer and handling events for time updates and countdown
    expiration.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Timer`脚本准备就绪后，让我们在`GameManager`类中将`Timer`脚本连接起来，以开始运行计时器并处理时间更新和倒计时结束的事件。
- en: The first thing we’ll tackle is starting the timer countdown when the game begins.
    The timer countdown starts by calling the `Timer.StartTimer()` public method through
    a direct reference assigned in the `Start()` method of the `GameManager` class.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要解决的是在游戏开始时启动计时器倒计时。计时器倒计时通过在`GameManager`类的`Start()`方法中分配的直接引用调用`Timer.StartTimer()`公共方法来启动。
- en: 'Follow these steps to see how it’s set up:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤查看设置过程：
- en: 'Add a public variable, `GameTimer`, to reference the `Timer` component added
    to the **GameManager** GameObject in the **Hierarchy**:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个公共变量`GameTimer`，用于引用添加到**层次结构**中的**GameManager**GameObject的`Timer`组件：
- en: '[PRE16]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add a public int variable, `GameplayTime`, to specify the amount of time in
    seconds the game will count down from – this is the total time the player will
    have to collect all the water diamonds. The best way to know what value to set
    is to playtest the game!
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个公共整型变量`GameplayTime`，用于指定游戏倒计时的时间（以秒为单位）- 这将是玩家收集所有水钻所需的总时间。确定要设置什么值的最简单方法是进行游戏测试！
- en: '[PRE17]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The timer is started from the `Start()` method when the game is run. We call
    `Invoke()` on the `StartTimer()` method with a 2-second delay – giving the players
    time to orient themselves a bit before gameplay starts:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当游戏运行时，从`Start()`方法开始计时器。我们在`StartTimer()`方法上调用`Invoke()`，延迟2秒 - 给玩家一些时间在游戏开始前稍微定位自己：
- en: '[PRE18]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the `StartTimer()` method, which performs the actual call to the `Timer`’s
    `StartTimer()` method, passing in the amount of time to count down from:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`StartTimer()`方法，该方法执行对`Timer`的`StartTimer()`方法的实际调用，并传入倒计时的时间：
- en: '[PRE19]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Lastly, back in the `Timer` component to the **GameManager** GameObject in the
    **Hierarchy** and assign the reference to it in the **GameTimer** field (refer
    to *Figure 3**.13*).
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，回到`Timer`组件，在**层次结构**中的**GameManager**GameObject上，并在**GameTimer**字段中分配对其的引用（参见图3.13）。
- en: 'The preceding steps have integrated `Timer` with our `GameManager` and start
    the time counting down when the game begins. But we still have to handle the Timer’s
    events, so let’s first add the listener for the time being updated:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤已经将`Timer`与我们的`GameManager`集成，并在游戏开始时开始计时。但我们仍然需要处理计时器的事件，所以让我们首先添加对时间更新的监听器：
- en: 'In the `OnEnable()` method, add the listener for the `OnTimeUpdate` event with
    the handler method specified:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnEnable()`方法中，添加对`OnTimeUpdate`事件的监听器，并指定处理方法：
- en: '[PRE20]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Remember, when we subscribe to an event, we should also unsubscribe from it
    to prevent memory leaks, so add the following code to `OnDisable()`:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，当我们订阅一个事件时，我们也应该取消订阅它以防止内存泄漏，所以将以下代码添加到`OnDisable()`中：
- en: '[PRE21]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the `TimeUpdated()` method (*Alt/Cmd* + *Enter*), where we’ll execute
    the code for handling when the timer is updated with a new time:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`TimeUpdated()`方法（*Alt/Cmd* + *Enter*），其中我们将执行处理计时器更新为新时间的代码：
- en: '[PRE22]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Same as before, we’re calling a public method on our UI reference for updating
    the countdown timer text while adding the values for the seconds passed in from
    `Timer` and the total gameplay time.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们正在调用UI引用上的公共方法来更新倒计时计时器文本，同时添加从`Timer`和总游戏时间传递进来的秒数值。
- en: Note on code architecture
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码架构的说明
- en: We could have added a listener to the **Timer.OnTimeUpdate** event right within
    **UIManager** to update the countdown timer text, but I decided to only have one
    reference to the **Timer** in the project and handle all timer events in **GameManager**.
    This will keep things cleaner, and it is more straightforward to troubleshoot
    any issues since the timer-related code is all within one class.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在**UIManager**内部直接添加对**Timer.OnTimeUpdate**事件的监听器来更新倒计时计时器文本，但我决定在项目中只保留一个对**Timer**的引用，并在**GameManager**中处理所有计时器事件。这将使事情更简洁，并且由于与计时器相关的代码都在一个类中，因此更容易调试任何问题。
- en: We’ll add the `UpdateTimerText()` method in the next section, where we’ll update
    `UIManager`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中添加`UpdateTimerText()`方法，其中我们将更新`UIManager`。
- en: Additions to UIManager
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加到UIManager
- en: 'Let’s get right to adding the additional variables and methods to support updating
    the timer text and the game over messages we’ll finish in the next section:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接添加额外的变量和方法来支持更新计时器文本和游戏结束消息，我们将在下一节完成这些：
- en: 'Open up the `UIManager` script and make the following revisions:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`UIManager`脚本，并进行以下修改：
- en: '[PRE23]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add the two `TextMeshProUGUI` public fields for the text displayed in the UI
    for the timer and game over text.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个`TextMeshProUGUI`公共字段，用于在UI中显示计时器和游戏结束文本。
- en: In `Start()`, we’ll clear out any placeholder text used during design time,
    so no text will be displayed until it’s updated.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start()`中，我们将清除设计时间期间使用的任何占位文本，这样就不会显示任何文本，直到它被更新。
- en: Add the `UpdateTimerText()` method with the current and total seconds parameters
    to calculate the time remaining in the countdown to display.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加带有当前和总秒数的`UpdateTimerText()`方法参数，以计算倒计时剩余时间并显示。
- en: Note that we’re using `System.TimeSpan` to make things easy. We can then use
    the `ts` variable when displaying the text, formatting it to show minutes and
    seconds, where seconds will always be displayed with two digits (`00` being specified).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`System.TimeSpan`来简化事情。然后我们可以使用`ts`变量来显示文本，格式化以显示分钟和秒，其中秒总是以两位数字显示（`00`被指定）。
- en: Finally, add the `SetGameOverText()` method for, you guessed it, updating the
    `GameOverText` text for displaying the game over message.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加`SetGameOverText()`方法，用于更新`GameOverText`文本以显示游戏结束消息。
- en: 'To finish up the revisions, we’ll go back into the **Editor** and create two
    new **Text - TextMeshPro** UI widgets as children of **Canvas** in the **Scene
    Hierarchy** (refer to *Figure 3**.13*):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成修订，我们将回到**编辑器**中，在**场景层次结构**中的**Canvas**下创建两个新的**Text - TextMeshPro** UI小部件（参见图3.13）：
- en: To display the timer in the UI, name it *Countdown Timer Text* and anchor it
    to the top center of the screen. Size the text to something easily visible to
    the player.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在用户界面中显示计时器，将其命名为*Countdown Timer Text*并将其锚定在屏幕顶部中央。调整文本大小，使其对玩家易于可见。
- en: To display the game over text in the UI, name it *Game Over Text* and anchor
    it to the center of the screen. Give the text a large size, covering most of the
    screen, so there is no mistaking when the game is over and the player has either
    won or lost.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在用户界面中显示游戏结束文本，将其命名为*Game Over Text*并将其锚定在屏幕中央。给文本一个大号，覆盖大部分屏幕，这样在游戏结束时玩家无论是赢还是输都不会弄错。
- en: When you’ve finished the UI design for these text widgets, drag them to the
    `UIManager` component.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成这些文本小部件的UI设计后，将它们拖到`UIManager`组件。
- en: A game just isn’t a game unless you can win or lose playing it! So, let’s finish
    up the collection game in the next section.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不能在游戏中赢或输，那么这根本不是一场游戏！所以，让我们在下一节完成收集游戏的收尾工作。
- en: Winning the game
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赢得游戏
- en: 'Everything we require to determine a win-and-lose condition is already in place.
    Let’s start with the win condition: they win if the player collects all the water
    diamonds before the countdown timer expires.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需的一切来确定胜负条件都已经就绪。让我们从胜利条件开始：如果玩家在倒计时计时器结束之前收集到所有的水钻石，他们就会获胜。
- en: 'This is a simple equality conditional statement: does the accumulated item
    count equal the total collectible items count? If we check this condition when
    an item is collected, and it equates to `true`, we know we’ve won the game.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的相等条件语句：累积的项目数量是否等于可收集的项目总数？如果我们在一个项目被收集时检查这个条件，并且它等于`true`，我们就知道我们赢得了游戏。
- en: In `GameManager`, revise the `ItemCollected()` method to include this check,
    and we’ll call a `Win()` method if `true`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameManager`中，修改`ItemCollected()`方法以包含此检查，如果为`true`，我们将调用`Win()`方法。
- en: 'You’ll first have to refactor the expression body to a block body to include
    additional lines of code in the method (hint: VS can refactor this for you and
    add the squiggly brackets). It will now look as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先必须将表达式体重构为块体，以便在方法中包含额外的代码行（提示：VS可以为你重构并添加波浪括号）。现在它将看起来如下：
- en: '[PRE24]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That was easy! Now, let’s state the losing condition: they lose if the countdown
    timer runs out before the player collects all the water diamonds. This requires
    just a bit more work, but we’re just going to use what we’ve already implemented,
    specifically, the `Timer.OnTimeExpired` event.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！现在，让我们声明失败条件：如果倒计时计时器在玩家收集到所有的水钻石之前耗尽，他们就会失败。这需要做一点更多的工作，但我们只是将使用我们已经实现的内容，具体来说，就是`Timer.OnTimeExpired`事件。
- en: 'In `GameManager`, again, let’s add a listener to `OnEnable()` for the time
    expiring and assign a handler method:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameManager`中，再次为时间耗尽添加`OnEnable()`监听器并分配处理方法：
- en: '[PRE25]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Again, unsubscribe:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，取消订阅：
- en: '[PRE26]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the `TimeExpired()` method as an expression body where we’ll just call
    `Lose()` – the time has expired; if the player had already collected all the items
    – and won – this method would never be reached:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`TimeExpired()`方法作为表达式体，我们将只调用`Lose()`——时间已耗尽；如果玩家已经收集了所有物品并获胜——则此方法永远不会被调用：
- en: '[PRE27]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, as the very last steps for completing the collection game, referring
    to the additions to the following `GameManager` script, we’ll add both the `WinText`
    and `LoseText` public fields that hold the messages to be displayed when the game
    ends (as seen in *Figure 3**.13*):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为完成收集游戏的最后几个步骤，参考以下`GameManager`脚本的添加，我们将添加两个公共字段`WinText`和`LoseText`，它们包含游戏结束时显示的消息（如图*3**.13*所示）：
- en: '[PRE28]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you don’t assign some default text values to the variable declarations here,
    then don’t forget to assign them in the **Inspector**!
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为这里的变量声明分配一些默认的文本值，那么别忘了在**检查器**中分配它们！
- en: 'We’ll also add the `Win()` and `Lose()` methods:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加`Win()`和`Lose()`方法：
- en: '[PRE29]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A quick breakdown of these two new methods is as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新方法的简要说明如下：
- en: The `Win()` method starts off by stopping the timer by calling `GameTimer.StopTimer()`.
    This will cancel invoking the update timer method since our game is over now.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Win()`方法首先通过调用`GameTimer.StopTimer()`停止计时器。这将取消调用更新计时器方法，因为我们的游戏现在已经结束了。'
- en: Both of these methods call `UI.SetGameOverText()` but with the corresponding
    argument to display the correct message, `WinText` and `LoseText` respectively.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个方法都调用`UI.SetGameOverText()`，但带有相应的参数来显示正确的消息，分别是`WinText`和`LoseText`。
- en: They each set the `timeScale` variable of the running game `Time` to `0`, which
    has the effect of pausing the game (with some exceptions; see the following callout
    block on `Time.timeScale` for more information).
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '它们各自将运行中的游戏`Time`的`timeScale`变量设置为`0`，这会暂停游戏（有一些例外；有关`Time.timeScale`的更多信息，请参阅下面的提示块）。 '
- en: Note that setting `timeScale` to zero will technically have the same result
    as calling `GameTimer.StopTimer()` here, since the only option at this point,
    is to restart the game. Still, I like to be explicit with some statements so that
    the intent is clearly visible in the code (so long as it’s not something that
    would otherwise negatively impact things, of course, heh).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将`timeScale`设置为零在技术上会产生与在这里调用`GameTimer.StopTimer()`相同的结果，因为此时唯一的选择是重新开始游戏。不过，我喜欢在代码中明确一些语句，以便意图清晰可见（当然，只要它不会对其他方面产生负面影响，哈哈）。
- en: Additional reading | Unity documentation
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '**Time.timeScale**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-timeScale.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-timeScale.xhtml)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**Time.timeScale**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-timeScale.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-timeScale.xhtml)'
- en: 'Since we broke things up into smaller chunks of code quite a bit in this section,
    you may want to refer to the completed `GameManager` script, which can be found
    in the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch3](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch3)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在本节中将代码拆分成了很多小块，你可能需要参考完整的`GameManager`脚本，它可以在GitHub仓库中找到：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch3](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch3)
- en: With that, our game is complete. Yay! However, one more crucial step is needed
    before we can share our game with the world… and that is making sure others find
    the game challenging and fun to play.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的游戏就完成了。太好了！然而，在我们可以与世界分享我们的游戏之前，还需要一个关键的步骤……那就是确保其他人觉得游戏具有挑战性和乐趣。
- en: Playtesting
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏测试
- en: Now is the time to playtest and change the parameters of your level design,
    change the paths where the player can go, move objects and hazards, move the collectibles,
    and tweak the gameplay time to make the game challenging and fun for players.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是进行游戏测试和更改关卡设计参数的时候了，改变玩家可以走的路径，移动物体和危险，移动可收集物品，并调整游戏时间，使游戏对玩家具有挑战性和乐趣。
- en: Have other people play your game – watch them play, if you can, to get an idea
    of how they play your game and get their feedback. Implement and iterate on changes
    in response to playtesting to improve your game!
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让其他人玩你的游戏——如果可能的话，观察他们玩游戏，以了解他们如何玩游戏并获取他们的反馈。根据游戏测试的结果进行改进，并对游戏进行迭代！
- en: Downloading the completed game code
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完整的游戏代码
- en: 'Remember, the example code for this book can be downloaded from the GitHub
    repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，本书的示例代码可以从以下GitHub仓库下载：[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)
- en: Summary
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was an introduction to the power of the CM camera system for quickly
    adding a Player follow camera, implementing game mechanics for collecting items
    that engage the player, displaying key game progression elements to the player
    with Unity UI, and how to finish and balance our collection game with both win
    and lose conditions.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了CM相机系统的强大功能，用于快速添加玩家跟随相机，实现收集物品的游戏机制以吸引玩家，使用Unity UI向玩家展示关键游戏进度元素，以及如何通过胜负条件完成和平衡我们的收集游戏。
- en: In the next chapter, we’ll introduce the next project in the book by defining
    the GDD for the *Outer World* 2D adventure game, learning how to import original
    artwork to use with additional Unity level building tooling, and exploring more
    aspects of level design and game polish.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过定义《Outer World》2D冒险游戏的GDD（游戏设计文档）来介绍本书的下一个项目，学习如何导入原始艺术作品以配合额外的Unity关卡构建工具使用，并探索关卡设计和游戏打磨的更多方面。
