- en: Chapter 6. Plotting Mathematical Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will create an application which will plot arbitrary mathematical
    expressions on a **Windows Presentation Foundation** (**WPF**)-based graphical
    surface. We will be using the GoF observer pattern for wiring expression input
    control and the rendering surface. In the process, we will develop a library which
    can evaluate arbitrary arithmetic expressions on the fly. The expression evaluator
    will support basic arithmetic operators (`+`, `-`, `*`, `/`, unary `+`/`-` ),
    trigonometric functions, and a pseudo variable (`$t`) which can represent the
    value of X-axis in a 2D Plane. During the course of this chapter, as a reader,
    you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing mathematical expressions using recursive descent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling **abstract syntax tree** (**AST**) as a composite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interpreter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elementary WPF 2D graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements for the expressions library and app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we embark on writing the library, let us scribble down a preliminary
    requirement statement, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to plot the result of arbitrary mathematical expressions is a common
    requirement for business applications. We need to parse an expression to evaluate
    the resulting tree-structured representation. The process of lexical analysis,
    parsing, modeling expression nodes, recursive evaluation, and so on should be
    opaque to the application programmer. The library should support some trigonometric
    functions and a variable (`$t`) to pass the information of the current X-coordinate
    of the graphics surface. The application should evaluate the value of the Y-coordinate
    for each value of the X-coordinate passed to the expression evaluation engine.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will divide the requirement into the two following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A library for evaluating arbitrary mathematical expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application which will consume the aforementioned library to plot data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The expression evaluator library requirements can be enumerated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling expressions as AST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a lexical analyzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a recursive descent parser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depth first walk of the tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting trigonometric functions and pseudo variable (`$`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging everything as a facade pattern-based API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The application requirements can be enumerated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A screen with a WPF 2D graphics surface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A prompt for entering expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of the observer for detecting a new plot request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing the value to the expressions library for change in the X-coordinate
    value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering the resulting value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The graph plotter application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The graph plotter application is a simple WPF application with a canvas and
    a textbox in the frame. The following image gives a snapshot of the screen after
    the screen has rendered the result of an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The graph plotter application](img/B05691_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The WPF canvas gets a notification whenever there is a change in the expression
    textbox. If the expression in the textbox is valid, the graph will be plotted
    as shown in the preceding image. We will deal with the nuances of implementing
    an expression evaluation engine in the following sections. The following code
    snippet shows how the change in text gets handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The observer pattern for UI events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the GoF observer pattern to handle UI events in an automatic fashion.
    The moment an expression gets changed in the textbox, the window should get a
    notification about it, and if the expression is valid, the resulting expression
    will be rendered on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While implementing the observer pattern, we have two classes-the `Subject` class,
    which represents the event source, and the `Observer` class, which is a list of
    observers (observer who are interested in listening to the event. Whenever there
    is a change in the text, the `Subject` class which represents the event source
    sends notification to all the sinks who have subscribed to the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already mentioned that in the case of the observer pattern, we communicate
    between the event source and event sinks. The event source is represented using
    the `Subject` class, and the event sink is represented using an `Observer` class.
    Let us dissect the implementation of the `Observer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare a delegate which will act as an event handler, and to make the class
    handle all the WPF controls, we mark the event subscriber as a WPF control. The
    concrete class can hold any object derived from `Control`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we initialize the delegate with an address of an abstract
    method. This will automatically get wired to the concrete class implementation
    of the method. We are, effectively, using the GoF template method pattern for
    the observer implementation. The concrete class is mandated to implement the `Observer_ExpressionChangedEvent`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will try to write the `Subject` class which acts as an event source.
    The `Subject` class will iterate through the list of observers to dispatch the
    events which the observers are interested in. Any change in the expression textbox
    will be relayed to the window object, which acts as a receiver of the events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BaseObserver` class given in the preceding code snippet is an abstract
    class, and we need to create a concrete class which implements `Observer_ExpressionChangedEvent`.
    The concrete implementation listing is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see how we can connect the `Subject` and `Observer` class. See the `MainWindow.cs`
    module in the source code associated with this book. A snippet of the code is
    given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever there is change in the text, the rendering routine will be notified.
    The rendering routine uses WPF 2D graphics transformations to plot the equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The expression evaluator and interpreter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The authors of this book believe that any programmer worth his salt needs to
    learn the rudiments of compiler construction for implementing mini-languages or
    **domain-specific language** (**DSL**) in his work. A compiler treats expressions
    as data, and expressions are mostly hierarchical in nature. We use a data structure
    called AST for representing the nodes of an expression tree. To convert textual
    expressions into an AST, we need to write a parser to analyze the constituents
    of an expression. The subsystem which feeds data to the parser is a module called
    lexical analyzer, which breaks the input stream into a series of tokens.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of a mini language, and writing an evaluator for it, is dealt
    with by the GoF catalog as interpreter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In software design, the interpreter pattern is a design pattern that specifies
    how to evaluate sentences in a (mini) language. The basic idea is to have a class
    for each symbol (terminal or non-terminal) in a specialized computer language.
    In our case, we use a mini language with double precision floating point numbers,
    a symbolic variable (`$t`), trigonometric functions (sine/cosine), and basic arithmetic
    operators. The syntax tree of a sentence in the language is an instance of the
    composite pattern, and is used to evaluate (interpret) the sentence for a client.
    Some expressions which we handle are *2*3 + SIN($t)*2*, *$t*100*, *COS((3.14159/2)
    - $t)*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract syntax tree (AST)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer science, an AST, or just syntax tree, is a tree representation of
    the abstract (simplified) syntactic structure of the source code. Each node of
    the tree denotes a construct of the programming language under consideration.
    In our expression evaluator, the nodes are numeric values (IEEE 754 floating points),
    binary operators, unary operators, trigonometric functions, and a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is abstract in the sense that it does not represent every detail
    that appears in the real syntax. For instance, grouping parentheses is implicit
    in the tree structure, and AST data structure discards parentheses. Before we
    model the AST, let us see some expressions and its AST representations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![The abstract syntax tree (AST)](img/B05691_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding example uses two node types, that is, `NumericConstant`, `BinaryExp`.
    Even the simplest expression creates a structure which seems a bit complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an expression which has a unary operator as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![The abstract syntax tree (AST)](img/B05691_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since our expression evaluator only supports a single variable, we create a
    context class which will store the variable in question. The class is named `RUNTIME_CONTEXT`,
    and the whole listing is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In any programming language, expression is what you evaluate for its value.
    This can be modeled as an abstract class. The numeric value which we support is
    of the type IEEE 754 double precision floating point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression evaluator supports operators like `PLUS` (+), `MINUS` (-), `DIV`
    (/), and `MUL` (*). They are modeled using an enumerated type named `OPERATOR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start by creating a hierarchy of nodes for modeling an expression.
    We use the composite pattern to compose bigger expressions out of smaller ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NumericConstant` class can store an IEEE 754 double precision floating
    point value in it. This is a leaf node in the AST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BinaryExp` class models a binary expression which takes two expressions
    (`ex1` for the left node and `ex2` for the right node), it applies the operator
    on both, the left-side value and the right-side value, inside the evaluate routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of unary expressions, we take an operator and an `Exp` node as
    a child:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The sine node takes an expression as a child. We evaluate `_ex1`, and invoke
    `Math.Sin` on the resulting value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The cosine node takes an expression as a child. We evaluate `_ex1`, and invoke
    `Math.Cos` on the resulting value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the variables (`$t`) are modeled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The grammar of expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Backus-Naur Form** (**BNF**) notation is used to specify the grammar
    for programming languages. The semantics of BNF can be learned from books, and
    plenty of material is available. The grammar of the expression evaluator we use
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This BNF can be converted to source code very easily.
  prefs: []
  type: TYPE_NORMAL
- en: Lexical analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The lexical analyzer groups characters into tokens including `''+''`, `''-''`,
    `''/''`, `''*''`, `SIN`, `COS`, and so on. In the process, the module feeds the
    parser when a request is made to it. Rather than doing a lexical scan of the entire
    input, the parser requests the next token from the lexical analyzer. In our expression
    evaluator, the following tokens are returned by the lexical analyzer upon request
    for the next token by the parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The lexical analyzer module scans through the input, and whenever it finds
    a token (legal or illegal), it saves the current input pointer and returns the
    next token. Since the listing is lengthy and code is trivial, it is given as part
    of the code repository. The following pseudo-code shows the schema of the lexical
    analyzer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The parser module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using recursive descent parsing, we will arrange the tokens to see whether
    expressions are valid, and generate the AST out of the input stream with the help
    of the lexical analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: 'A recursive descent parser is a top-down parser built from a set of mutually-recursive
    procedures, where each such procedure usually implements one of the production
    rules of the grammar. Thus, the structure of the resulting program closely mirrors
    the grammar that it recognizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor of the `RDParser` class takes the expression string as a parameter,
    and passes it to the `Lexer` class. Whenever the parser requires a token, it asks
    the `Lexer` class to provide one through the `GetToken()` method. The whole parsing
    process starts from the `CallExpr()` method, and inside it, a token is grabbed
    by the parser through the `Lexer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Expr()` function descends down to the `Term()` function (which is listed
    next), and returns the subexpressions from there. As long as there are further
    operators of the same precedence, it recursively calls the `Expr()` method to
    retrieve the factors in the form of tree. A `BinaryExp` node is created to represent
    the subexpressions parsed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The term descends down to the `Factor()` method (shown next) to retrieve a
    node (which can be an expression itself within the parentheses), and as long as
    operators of the same precedence are available, it recursively calls itself to
    generate the terms of the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If the parser returns a number, the factor creates a numeric node and returns
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If the current token is `$t`, a `Var` node is returned by the factor method.
    After instantiating the `Var` object, the parser grabs the next token before returning
    the expression object instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the current token is `SIN` or `COS`, we call `Expr()` recursively to parse
    the parameters. Once `Expr()` returns, we create the appropriate node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find an opening parenthesis, a call to `Expr()` will go to parse the
    nested expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet handles unary operators, and if the current token
    is any other thing which is not supposed to be there, an error will be thrown.
    The syntax diagrams (also known as railroad diagrams) of the grammar realized
    are shown next.
  prefs: []
  type: TYPE_NORMAL
- en: '**Expr** is represented with the following syntax diagram. The BNF grammar
    gives better clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![The parser module](img/B05691_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following syntax diagram represents the **Term.** The BNF grammar is shown
    for better clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![The parser module](img/B05691_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Factor** can be represented using the following railroad diagram. The BNF
    grammar is also shown for the sake of clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![The parser module](img/B05691_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The builder, facade, and expression APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of interpreting an expression is a complicated process, where a
    lot of classes work together towards the goal. As an application developer, to
    focus on the task at hand, we might have to expose an API which abstracts away
    the complexities of lexical analysis, parsing, and AST generation. We normally
    use the GoF facade pattern in these contexts. But, we will use the GoF builder
    pattern here, as this creational pattern is more appropriate in situations where
    we need to create a composite object. Here, we create expressions which are modeled
    as composites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetExpression()` method leverages recursive descent parsing and lexical
    analysis to create an `Exp` object composed of AST nodes. If the parse fails,
    the routine will return null. The `Builder` class will be used to parse an expression
    from its textual representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We parse the tree once to create the AST. Once the AST has been created, we
    can evaluate the resulting AST many times over by changing the value in the `RUNTIME_CONTEXT`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The expression is parsed once, and an AST is created out of it. Once the tree
    has been created, it can be evaluated by changing the `context` object. In the
    preceding loop, `t` is updated and set to the `context` object. Each time you
    evaluate the tree, you evaluate against a different value of `t`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created an application which plots the result of an arbitrary
    mathematical expression on a graphics surface. We used WPF for our rendering purpose.
    We also created an expression evaluator library, which uses the recursive descent
    parsing technique to parse an expression to a data structure called AST. The AST
    can be walked depth-first to evaluate the value. This is a good example of the
    interpreter pattern. We used the observer pattern to automatically relay the changes
    in the expression input to the canvas object. In the next chapter, you will learn
    how the .NET framework library leverages patterns to expose a good API for developers.
  prefs: []
  type: TYPE_NORMAL
