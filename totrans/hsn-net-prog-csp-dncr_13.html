<html><head></head><body>
        

                            
                    <h1 class="header-title">FTP and SMTP</h1>
                
            
            
                
<p>Having explored the heavy-hitter of application-layer protocols with a chapter on HTTP, it will serve us well to look at some of the other less common protocols. That's what we'll be looking at in this chapter. While HTTP is a general-purpose, workhorse protocol, there are a number of reasons why you might consider using <strong>File Transfer Protocol</strong> (<strong>FTP</strong>) or <strong>Simple Mail Transfer Protocol</strong> (<strong>SMTP</strong>) for specific tasks in your own software, or why those protocols might be leveraged by .NET Core under the hood of some of their more common abstractions. So, in this chapter, we'll see what those reasons might be and learn how to implement those protocols when the situation arises.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>How the FTP standard is defined and how C# implements the protocol in .NET Core</li>
<li>Understanding the processes for securing file transport</li>
<li>Understanding the nature of SMTP and the role it fulfills</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>In this chapter, we'll be using sample applications available in the GitHub repository for the book here: <a href="https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%2010">https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter 10</a>.</p>
<p>We'll be working mostly with console applications, so you won't need any sort of REST or web client specifically for this chapter.</p>
<p>Also, in this chapter, we'll be writing a client to engage with an FTP server. To that end, we'll need an FTP server we can administer ourselves. I will be using FileZilla for this and recommend you do the same. It's lightweight, stable, and open source. It can be found here: <a href="https://filezilla-project.org/download.php?type=server">https://filezilla-project.org/download.php?type=server</a>. If your development environment doesn't support FileZilla, don't worry. The goal is simply to have a server available and listening for our application to interact with. The demonstrations should be easy enough to follow along with using any FTP server with support for your OS.</p>
<p>Check out the following video to see the code in action: <a href="http://bit.ly/2HYmsHj">http://bit.ly/2HYmsHj</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">File transfer over the web</h1>
                
            
            
                
<p>The first thing to note about FTP and file transfer is that, as an application-layer protocol on the <strong>Open Systems Interconnection</strong> (<strong>OSI</strong>) stack, the primary concern of its design is in optimizing a specific common business task for execution over a network. However, just because a task is optimally done over a given protocol, it doesn't mean it <em>must </em>be done over that protocol. Indeed, almost anything done at the application-layer could, in theory, be accomplished by any application-layer protocol. So, what is it that makes FTP useful for us as engineers?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The intent of FTP</h1>
                
            
            
                
<p>While FTP is optimized for a file transfer between hosts, I'd wager every dollar I have that there isn't a single reader of this book who hasn't transferred files over a network as an attachment of their email. The same task is accomplished, namely, a file was transferred from one host on a network to another, over that network, but it was accomplished using a different application-layer protocol (SMTP instead of FTP). Indeed, the versatility of the specification for HTTP has allowed it to grow well beyond the task for which it was optimized (transferring hypertext documents) and into a general-purpose workhorse of web communication.</p>
<p>In fact, there are countless applications that transfer files directly over HTTP. There's even a well-known and broadly supported media type for precisely that kind of interaction with <kbd>multipart/form-data</kbd>. So, what advantages are there to be gained by using FTP for file transfer instead of other more general-purpose application-layer protocols?</p>
<p>Built on a client-server model architecture, FTP is designed and implemented to leverage two separate connections for establishing the state of the target filesystem and transferring files. The first of these connections is what's called a control connection, and it is used to hold various details about the state of the remote host, such as the current working directory exposed to the FTP client. Meanwhile, for each transfer of data, a second data connection is established using information maintained by the control connection. When the data connection is engaged and transferring data, the control connection is idled.</p>
<p>In most implementations, establishing a control connection can be a bit of a pain, and often slow-performing. This is because each connection requires multiple round trips, sending various commands to the remote host establishing the target directory, negotiating any authentication, and determining and storing the remote state for use by the data connection. This high performance cost, as well as the statefulness of the control connection, is what made FTP ill-suited for use in transferring simple, brief hypertext web pages, thus necessitating HTTP. However, that stateful connection and the information it provides a client regarding the current state of the directory is essential to some operations FTP is used to support (such as detecting the presence of a file on a remote host or bulk downloads of all files in a directory).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Active and passive connections</h1>
                
            
            
                
<p>Once a control connection is established, the data connection can be made using one of two possible modes. The server can establish an active connection, which is the default state for most FTP servers, or a passive connection. These different types of connection refer specifically to how the data<em> </em>connection is established and handled. In either case, the client initiates a control connection with a message using the underlying transport protocol (usually <strong>Transmission Control Protocol</strong> (<strong>TCP</strong>)).</p>
<p>In an active connection, once the control connection is established and the data transfer can begin, it's the server that establishes a data connection to transmit the file over the wire. The client transmits information during the command connection phase, notifying the server about which port is actively listening for the data connection. Then the server attempts to establish a connection with the client on the designated port, which is used for the server to push out the file data. The server is said to be <em>actively transmitting</em> the data to the client.</p>
<p>In a passive connection, the client uses the control connection to notify the server that the connection should be passive. The server then responds with an IP address and port designation for the client to establish a connection with. At that point, it's the client that establishes the data connection to the server's designated IP address and port. Once this connection is established, the client can transmit the file data. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transfer modes and data representations</h1>
                
            
            
                
<p>Once the actual data connection has been established as either active or passive, and the file transfer is ready, there are a number of ways to transmit the file in such a way as to have it readable on the target machine. Keep in mind that a text file written on a Unix system will have different character encodings or line terminals from a text file written on a Windows machine. If you've ever opened up a text editor or source control interface and been prompted to normalize the line endings of your files, this is why. It's a way of accounting for the subtle discrepancies between different native environments.</p>
<p>Since FTP is a platform-agnostic network transmission protocol, it must account for the possible disparities between binary representations of a file's content on different systems. To that end, FTP provides three different common data representation mechanisms for files being transferred over a connection:</p>
<ul>
<li><strong>ASCII mode:</strong> This should only ever be used for text files. The character and bytes are converted from the source machine's native character representation to an 8-bit ASCII encoding prior to transmission, and then converted, again, to the target machine's native character representation from that 8-bit ASCII encoding. Of course, if either machine's native character encoding already is 8-bit ASCII, no conversion happens between that machine and the data connection.</li>
<li><strong>Image (or binary) mode:</strong> In this mode, the underlying binary data of the file on the source machine is sent over, unchanged, in a sequential byte stream. The target machine then stores that stream at the target file location on its local system, byte by byte, as it receives packets from the source.</li>
<li><strong>Local mode:</strong> This is for two computers with a shared local configuration to transfer data in any proprietary representation without a need to convert it to ASCII. It's not entirely dissimilar to the image mode, except that, where the proprietary format allows, data could be transferred non-sequentially.</li>
</ul>
<p class="mce-root">Once you've determined the best way to represent your data for transmission, though, FTP will also provide three mechanisms for actually executing that transmission. They are as follows:</p>
<ul>
<li><strong>Stream mode:</strong> Datagrams are sent as a continuous stream. This has a number of performance advantages, as there's no need to encapsulate discrete packets in any headers or metadata to enable the parsing. Bytes are simply sent out as they are read until the end of the file is reached on the source system.</li>
</ul>
<ul>
<li><strong>Block mode:</strong> This mechanism will chunk the file data into discrete application-layer packets and transfer them one block at a time to the source system, which is then responsible for reconstructing the original file structure based on the information in the packet metadata.</li>
<li><strong>Compressed mode:</strong> This mode simply enables a simple data compression algorithm to minimize the total volume of data sent between hosts.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Exposing directories for FTP</h1>
                
            
            
                
<p>All of the features I've described in this section serve the specific purpose of negotiating the efficient transfer of files between two remote hosts. While the protocol obviously would not be well suited for a task such as transferring web pages to be rendered by a remote web browser, it does leverage a number of advantages over other application protocols such as HTTP. This includes giving engineers the flexibility to determine precisely how, and in what format, they can transfer large files.</p>
<p>So, now that we understand how and why FTP is used, let's look at how we can use it in our own programs. We'll be writing a simple client using the .NET library classes. The end state will be a client that can upload and download files, as well as request directory information from the remote host.</p>
<p>Our application will be a console application this time, so navigate via your terminal of choice to your working directory and create a new project:</p>
<pre>dotnet new console -n FtpClientSample</pre>
<p>Next, you'll want to make sure your fileserver is up and running locally. When you install the software, you should have see a window prompting you to choose a port that the server will be listening on for administration connections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring your FTP server</h1>
                
            
            
                
<p>If you read that prompt carefully, you will have noticed that it was very explicit that the port you were choosing was for administrative connections to your FTP server, and not active FTP connections. This is because (if you remember back to the <em>Reserved ports</em> section in <a href="a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml">Chapter 8</a>, <em>Sockets and Ports</em>) there is already a default port configured to listen for incoming FTP command connections. Just like how the <kbd>80</kbd> port is the default listening port for HTTP, the <kbd>21</kbd> port is the default port for FTP command connections. That means that, in general, connections sent to a URI with a schema of <kbd>ftp://...</kbd> and no port specification will automatically connect to the <kbd>21</kbd> port.</p>
<p>This is why the port you configure on FileZilla is explicitly designated as being for administration only. You're not connecting to the FTP command connection. You're connecting to the FileZilla server that is managing that FTP command connection. So, with that in mind, start the server and configure it to point to the localhost and the port you specified at the time of installation.</p>
<p>Once the application starts running, you'll see a notification that FTP over <strong>Transport Layer Security</strong> (<strong>TLS</strong>) is not enabled. Even though this message is written in alarming red text, you can ignore it for now. We'll look at it further when we explore TLS in a later chapter. For now, the lack of security keys will just make our lives a bit easier as we try to understand FTP, specifically. The fewer variables we introduce at once, the easier it is to understand new information as we receive it.</p>
<p>Finally, we need to register a user for our application in the FTP Administration UI, and set a working directory for the user. To do so, click on Edit | Users in the menu on the FileZilla administrator console. Then navigate to the Shared folders configuration page to set which specific directory you want to allow for which specific user:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9e88207c-72d6-4a40-88a0-c3a2d6b989ce.png"/></p>
<p class="CDPAlignLeft CDPAlign">For the purposes of this demo, I'm going to create a new user named <kbd>s_burns</kbd>, and we'll give that user permissions to access the source code directory of <a href="https://cdp.packtpub.com/hands_on_network_programming_with_c__and__net_core/wp-admin/post.php?post=33&amp;action=edit#post_32">Chapter 9</a>, <em>HTTP in .NET</em>. Note that the user I created for the FTP server is distinct from my local machine username. When you're writing an FTP client to log in and access a remote directory, you need the credentials for a user that is registered with the FTP server software, not with the host machine. If I were to try to download a file from my local server using my operating system username, I would get an unauthorized exception in response, even with the correct password. The user credentials should always for a user as registered with the server itself, and in general, unless you've written an FTP server to allow open and anonymous connection, you should always be connecting with credentials.</p>
<p>The FTP server itself will have whatever permissions for a given directory are granted to it by the host machine. So, if you run the server in a process where the system identity has limited read-only permissions, that will be the extent of operations it can provide to a client. By default, however, FileZilla is installed with the same privileges granted to the user who initiated the installation. Since I'm a local admin, FileZilla was installed with local admin privileges for my system. However, just because those are the permissions granted to the FileZilla, that doesn't mean that any client connecting to the server with valid credentials will also have local admin privileges. That would be a huge security hole! Instead, when registering a new user for your server, the administrator (you, in this case) grants that new user individual permissions for writing, reading, and deleting files in the shared directory. For the purposes of this chapter, just create yourself a new user with full permissions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing an FTP client</h1>
                
            
            
                
<p class="mce-root">Now we'll want to set up our application for interacting with our running FTP server. Some of you may remember from <a href="b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml">Chapter 5</a>, <em>Generating Network Requests in C#</em>, that I mentioned the <kbd>FtpWebRequest</kbd>/<kbd>FtpWebResponse</kbd> subclasses of the <kbd>WebRequest</kbd> utility class. If you do, you're already well ahead of me now. These are the primary mechanisms through which .NET Core apps interact with FTP servers, and they are what we'll be leveraging to satisfy the requirements for this program.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fetching a directory listing</h1>
                
            
            
                
<p>We'll request an instance of the <kbd>FtpWebRequest</kbd> class and then use its methods to view directory information about our listening FTP server. The instance will be pointing to <kbd>ftp://localhost</kbd>, which, as I mentioned, defaults to port <kbd>21</kbd> without actually specifying it, thanks to the <kbd>ftp://</kbd> schema. Just as HTTP has methods for interacting with the server, FTP has its own methods for determining how it intends to interact with the server. In code, that is set with a series of static constant properties that are used by the <kbd>FtpWebRequest</kbd> class to determine how to initiate the desired behavior:</p>
<pre>static async Task&lt;string&gt; GetDirectoryListing() {<br/>  StringBuilder strBuilder = new StringBuilder();<br/>  FtpWebRequest req = (FtpWebRequest)WebRequest.Create("ftp://localhost");<br/>  req.Method = WebRequestMethods.Ftp.ListDirectoryDetails;<br/>  ...<br/>}</pre>
<p class="mce-root"/>
<p>The difference between HTTP methods or verbs and the <kbd>.Method</kbd> property you can set for <kbd>FtpWebRequest</kbd> is how they operate under the hood. As we saw in <a href="e93c024e-3366-46f3-b565-adc20317e6ec.xhtml">Chapter 9</a>, <em>HTTP in .NET</em>, an HTTP method is specified as a header on the request itself. If the method is permitted for the address specified, then the rest of the request is simply parsed and processed right away, and a response generated. In an FTP connection, however, the <kbd>Method</kbd> property you set on the <kbd>FtpWebRequest</kbd> instance is actually an abstraction for a sequence of commands sent to the server over the FTP command connection. The <kbd>FtpWebRequest</kbd> client will actually send the appropriate commands over its underlying TCP connection, and only proceed if it gets the expected responses from the server throughout the entire exchange.</p>
<p>Now, before we can request the information we asked for with the server, we need to authenticate our application as acting on behave of a registered user of the server. For that, we'll use the helpful utility class, <kbd>NetworkCredential</kbd>. This class encapsulates the basic concept of a username and password, and maps it to the underlying representation necessary for an authenticated network request. So, instead of having to worry about whether your authentication mechanism is a basic authentication or digest authentication, this class just lets you think of it in terms of your login information. Simply instantiate a new instance of it with the login credentials of the FTP user you created in FileZilla's administration application, and apply those credentials to your request:</p>
<pre>req.Credentials = new NetworkCredential("s_burns", "test_password");</pre>
<p>And once we're logged in, we can interact with the request object the same as we did back in <a href="b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml">Chapter 5</a>, <em>Generating Network Requests in C#. </em>We'll request the response for our request, and then read the response data stream with <kbd>StreamReader</kbd>, writing the results to our output to confirm our expected results:</p>
<pre>using (FtpWebResponse resp = (FtpWebResponse)await req.GetResponseAsync()) {<br/><br/>  using (var respStream = resp.GetResponseStream()) {<br/>    using (var reader = new StreamReader(respStream)) {<br/>      strBuilder.Append(reader.ReadToEnd());<br/><br/>      strBuilder.Append($"Request returned status:  {resp.StatusDescription}");<br/>    }<br/>  }<br/>}<br/>return strBuilder.ToString();</pre>
<p>Now simply await a call to this method in your <kbd>Main</kbd> method, and observe the results. Since the user I registered in my FTP server only has permissions for the root of the source code directory of <a href="e93c024e-3366-46f3-b565-adc20317e6ec.xhtml">Chapter 9</a>, <em>HTTP in .NET</em>, I see the following output in my console when I run my application:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-921 image-border" src="img/ed84409e-a37b-4943-bc91-42d54493fc62.png" style="width:37.75em;height:7.92em;"/></p>
<p>If you've never seen the string of characters at the start of each of those lines before, those are codes that define the permissions you have for each file in the directory listing. If there is a letter present, it means the permission or status is true for that folder. The structure is as follows:</p>
<pre>[directoryFlag][owner-set][group-set][other-set]</pre>
<p>The directory flag indicates whether the entry listed is, itself, a directory that can be navigated to and have files pulled from it. If <kbd>d</kbd> is present at the start of the entry, it's a folder containing files, not a file itself. Next is the permission sets for each kind of user that might want to interact with it. These are groupings of three characters indicating which permissions members of the set have for the file listed. In the order they are displayed, those characters are as follows:</p>
<ul>
<li><kbd>r</kbd>: read</li>
<li><kbd>w</kbd>: write</li>
<li><kbd>x</kbd>: execute</li>
</ul>
<p>So, for each set, there are three characters that are either set or null (represented here as a <kbd>-</kbd> character) indicating whether that set has the permission.</p>
<p>Using this, we can see that, for the files in our directory, <kbd>FitnessApp</kbd> and <kbd>FitnessDataStore</kbd> are both directories (they have <kbd>d</kbd> at the start of their permissions record), and both of them have the following permissions for each group:</p>
<ul>
<li>Owner: Read, write, and execute permissions</li>
<li>Group: Read and execute permissions</li>
<li>Other: Read and execute permissions</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Meanwhile, we can see that the <kbd>fitness_data.txt</kbd> file is not a directory, and the permissions for each group for that listing are as follows:</p>
<ul>
<li>Owner: Read and write permissions</li>
<li>Group: Read-only access</li>
<li>Other: Read-only access</li>
</ul>
<p>After the permissions, you see the current owner and group for the file (in this case, FTP) then the file size in bytes (0 for a directory), the last modified date, and the name of the file or sub-directory. So, here we can see that our FTP server is listed as the owner of our files and thus the permissions <kbd>rwx</kbd> are available for it to grant to users.</p>
<p>Now that we're successfully connected to our FTP server and able to access the directory information for the directory we have access to with our credentials, let's look back at how the server responded to that request. If you have your FileZilla server administration console open, you would have seen all of the interactions between our running application and the server show up in the server console:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-922 image-border" src="img/d05d00e4-787b-4a84-a035-1865d1833051.png" style="width:49.50em;height:31.17em;"/></p>
<p>Note that the first line indicates that the TCP connection was initiated on <kbd>21</kbd>, even though we never specified the port in our URI. That first line beginning with a timestamp is the initiation of the command connection. From there, every blue line in the console indicates a signal sent from our application to the server, and each green line represents the response from the server. The upper-case four-letter words and abbreviations sent from our application are all FTP commands from the FTP standard for interactions, and they were all sent by our application code without us even realizing it. This all happened under the hood of our application software just because we set our request method to <kbd>WebRequestMethods.Ftp.ListDirectoryDetails</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transferring a file</h1>
                
            
            
                
<p>So, now that we understand how the command connection to an FTP server is initiated under the hood, and how that allows us to open a data connection, let's use that to actually request a file. We'll use the same request processing structure we saw for building a request and then fetching the response back in <a href="b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml">Chapter 5</a>, <em>Generating Network Requests in C#</em>. This should all feel pretty familiar at this point, but I will take advantage of a few of the <kbd>FtpWebRequest</kbd> class's specific properties to highlight some of the options at your disposal. So, let's write the method to download a file.</p>
<p>The first thing we'll do differently will be specifying the sub-directory path for the file we want to look up. We'll just use the <kbd>Startup.cs</kbd> file from FitnessApp, so it's easy enough to confirm that we transferred it correctly. Then, we want to set the request <kbd>Method</kbd> property to the value of <kbd>WebRequestMethods.Ftp.DownloadFile</kbd>. Finally, we'll explicitly notify our server to operate in passive mode, which means our application will, behind the scenes, establish its own connection to the remote server on <kbd>20</kbd> (the default connection port for data connections to an FTP server) and then request the file once the connection is open. So, the initialization code for our download method will look like this:</p>
<pre>public static async Task&lt;string&gt; RequestFile() {<br/>  StringBuilder strBuilder = new StringBuilder();<br/>  FtpWebRequest req = (FtpWebRequest)WebRequest.Create("ftp://localhost/FitnessApp/Startup.cs");<br/>  req.Method = WebRequestMethods.Ftp.DownloadFile;<br/><br/>  req.Credentials = new NetworkCredential("s_burns", "test_password");<br/>  req.UsePassive = true;<br/>  ...<br/>  using(FtpWebResponse resp = (FtpWebResponse) await req.GetResponseAsync()) {<br/>    ...<br/>  }<br/>}</pre>
<p>Now, to copy the file, we'll be reading directly out of the response stream, and writing it into <kbd>StreamWriter</kbd> for our destination file. This will look complicated because of the nested scope, but all those tabs are only there to handle contexts for each disposable <kbd>Stream</kbd> object and its respective <kbd>Reader</kbd> or <kbd>Writer</kbd> helper class:</p>
<pre>using (var respStream = resp.GetResponseStream()) {<br/>  strBuilder.Append(resp.StatusDescription);<br/>  if(!File.Exists(@"../Copy_Startup.cs")) {<br/>    using (var file = File.Create(@"../Copy_Startup.cs")) {<br/>      //We only use this to create the file in the path if it doesn't exist.<br/>    }<br/>  }<br/>  using (var respReader = new StreamReader(respStream)) {<br/>    using (var fileWriter = File.OpenWrite(@"../Copy_Startup.cs")) {<br/>      using (var strWriter = new StreamWriter(fileWriter)) {<br/>        await strWriter.WriteAsync(respReader.ReadToEnd());<br/>      }<br/>    }<br/>  }<br/>}<br/><br/>return strBuilder.ToString();</pre>
<p>Now let's add a call to this method to our <kbd>Main</kbd> method, which should look like this:</p>
<pre>static async Task Main(string[] args) {<br/>  Console.WriteLine(await GetDirectoryListing());<br/>  Console.WriteLine(await RequestFile());<br/>}</pre>
<p>If you run this project from your terminal, your output should list the directory structure, and when navigating to the root of the project, we should find our <kbd>Copy_Startup.cs</kbd> file, looking exactly as we expect it to!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Uploading a file via FTP</h1>
                
            
            
                
<p>To complete this sample client, let's look at uploading to the server. Remember, it's the FTP, not the file download protocol. File transmission can go both ways. For this method, we'll be converting our file to a byte stream to upload to pass along with our request once the connection is established.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We'll also be pointing our <kbd>WebRequest</kbd> URI to the new yet-to-be-created file. We'll just be copying the <kbd>Program.cs</kbd> file from our current project to the root of the remote directory. So, let's see how the initialization code looks:</p>
<pre>public static async Task&lt;string&gt; PushFile() {<br/>    StringBuilder strBuilder = new StringBuilder();<br/>    FtpWebRequest req = (FtpWebRequest)WebRequest.Create("ftp://localhost/Program.cs");<br/>    req.Method = WebRequestMethods.Ftp.UploadFile;<br/><br/>    req.Credentials = new NetworkCredential("s_burns", "test_password");<br/>    req.UsePassive = true;</pre>
<p>So far, so good. Now we'll need to create a byte array and write our <kbd>Program.cs</kbd> file to it. Then, write that byte array to the request stream. This should be pretty familiar territory for you after <a href="b5d28c0a-6e7c-4547-855d-e6c6d1842bd6.xhtml">Chapter 6</a>, <em>Streams, Threads, and Asynchronous Data Transfer</em>:</p>
<pre>byte[] fileBytes;<br/><br/>using (var reader = new StreamReader(@"Program.cs")) {<br/>    fileBytes = Encoding.ASCII.GetBytes(reader.ReadToEnd());<br/>}<br/><br/>req.ContentLength = fileBytes.Length;<br/><br/>using (var reqStream = await req.GetRequestStreamAsync()) {<br/>    await reqStream.WriteAsync(fileBytes, 0, fileBytes.Length);<br/>}</pre>
<p>Finally, to actually transmit the request to upload our file and the data stream with that file's contents, we just have to request a response from the server.</p>
<pre>  using (FtpWebResponse resp = (FtpWebResponse)req.GetResponse()) {<br/>        strBuilder.Append(resp.StatusDescription);<br/>  }<br/><br/>  return strBuilder.ToString();<br/>}</pre>
<p>And with that, we're uploading a file to our remote FTP server. Simply add a line to our <kbd>Main</kbd> method, and run the application. If you've configured your server the same way I did, you should now see a copy of the program we just wrote sitting in the root directory for the <a href="e93c024e-3366-46f3-b565-adc20317e6ec.xhtml">Chapter 9</a>, <em>HTTP in .NET</em>,  source code, right next to the <kbd>FitnessApp</kbd> and the <kbd>FitnessDataStore</kbd> project folders.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Securing FTP requests</h1>
                
            
            
                
<p>While you may suspect that the act of providing user credentials to our server meant there was some measure of security involved in our file access, we were actually interacting with our server in an entirely unsecure manner. Those credentials were only of value the moment they were received by the server and our command connection was established. After that though, they provided no more security of the data we were transmitting than if we had allowed entirely anonymous access to our directory. So, let's look at why that is, and how to fix it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The risks of FTP</h1>
                
            
            
                
<p>With our example software, there isn't any real concern for security because our data is never transmitted over an actual network connection. Our requests are never making it past our <kbd>hosts</kbd> file, because we are always pointing to <kbd>localhost</kbd>. However, if that wasn't the case, and we needed to authenticate with a remote server, and we did so using the standard FTP connection we set up for this demo, we'd be in trouble. Those credentials we used to log in to the server were sent entirely in plain text. Furthermore, the data connection that was eventually established was also sent over the wire in an entirely unsecured fashion.</p>
<p>If we attempted to communicate with a remote server using only the server credentials we provided, we would have been at risk of falling prey to a variety of different malicious attacks. Imagine a simple man-in-the-middle attacker reading the byte stream for a file containing <strong>Personally Identifiable Information</strong> (<strong>PII</strong>), such as a social security number, medical information, or bank account details. The FTP standard isn't actually designed to account for that kind of risk. What's more, since the file transfer mechanisms are negotiated ahead of time via the command connection, the actual file data is usually sent as an uninterrupted stream of bytes, easily re-assembled and read by a malicious party. Simply accept the underlying packet stream in order, remove the standard transport layer headers, and concatenate the bytes as they are received. For this reason, it's generally pretty risky to use standard FTP connections outside of the context of a well-protected private network.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Securing FTP with SFTP and FTPS</h1>
                
            
            
                
<p>While there are security concerns inherent to FTP, there are, fortunately, a couple of approaches that you can take to mitigate your exposure to those risks. The two we'll be looking at both seek to make it substantially more difficult for a malicious actor to interfere with or read the content of your files in transit. So what are they?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">SFTP </h1>
                
            
            
                
<p>Our old friends the <strong>Internet Engineering Task Force</strong> (<strong>IETF</strong>) designed a new standard for file transfer interactions that leveraged the <strong>Secure Shell</strong> (<strong>SSH</strong>) protocol for authentication and secure tunneling. Dubbed <strong>SSH File Transfer Protocol</strong>, or <strong>Secure File Transfer Protocol</strong> (<strong>SFTP</strong>), it was built as an extension to SSH that provisioned file transfer capabilities where they didn't previously exist.</p>
<p>This application protocol provides security by establishing a secure tunnel between the two host machines. All data is sent that via tunnel once the client host has been authenticated by the server host machine (as opposed to the simple server-user authentication of our example in the previous section). This is not entirely dissimilar to simply transferring files over a VPN. It simply uses a different security protocol. This mechanism is less an implementation of FTP with security, though, and more an extension to SSH to also provide FTP functionality. As such, the out-of-the-box support for it in .NET Core is almost non-existent. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">FTPS </h1>
                
            
            
                
<p>While SFTP exists as a file transfer subsystem added as an extension to SSH, the alternative approach for encrypting traffic sent over an open connection (one that hasn't established a secure tunnel between hosts) is to use what's called FTPS. An abbreviation of FTP over SSL, or FTP Secure, FTPS leverages the encryption mechanisms of the underlying transport layer to provide encryption for data transferred between hosts. This is almost exactly the same mechanism that underlies the HTTPS protocol we looked at in <a href="e93c024e-3366-46f3-b565-adc20317e6ec.xhtml">Chapter 9</a>, <em>HTTP in .NET</em>.</p>
<p>In modern implementations, this will use the secure transport mechanism of whatever underlying transport-layer protocol is being used by the FTP client. Today, that means that it's often leveraging TLS, but historically the encryption mechanism of choice has been SSL. Thus, when you want to configure your FTP clients to leverage FTPS, you simply set the <kbd>EnableSsl</kbd> property on your <kbd>FtpWebRequest</kbd> object to true. Then, provided your server supports FTP over TLS (or SSL), you'll be taking advantage of it every time you connect.</p>
<p>While there is a fair bit more to say on the subject of SSL and TLS and the security they provide, that's the subject of a later chapter. So, for now, just follow the simple rule of always using FTPS in your code where possible. The risks are just not worth it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">SMTP and MIME</h1>
                
            
            
                
<p>Finally, we'll round out our exploration of the application-layer protocols with what is probably the second most common protocol (behind HTTP). And yet, as commonplace as it is, I would guess that a staggering number of people who benefit from SMTP don't even know it exists. So, what is it? How would we use it, and why would we use it?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The email protocol</h1>
                
            
            
                
<p>First defined all the way back in 1982, the <strong>Simple Mail Transfer Protocol</strong> (<strong>SMTP</strong>) is the de-facto protocol for transmitting electronic messages. It's a connection-oriented protocol using the client-server architecture we've become so familiar with over the course of this book. Similar to FTP, SMTP transactions happen over a sequence of commands and responses transmitted over a dedicated SMTP session. Those commands notify the server of what the addressing information is for a message (the To: and From: components of an email), transmit the message itself, and finally confirm receipt of the message.</p>
<p>Unlike FTP, though, these interactions all happen over the same single connection to the server. Once a connection is established to the server (usually on the default SMTP port, <kbd>25</kbd>, for those who were curious), that connection constitutes a session<em>.</em> Once that session has begun, the commands sent by the server are received and responded to until all of the components of the message have been transmitted and the session is terminated.</p>
<p>The important thing to note about SMTP is that it is entirely about the <em>outbound</em> transmission of a new message. There is no mechanism in the protocol itself to request messages back from a server. Applications that maintain a mailbox for users to access are doing so by leveraging entirely different messaging protocols, such as the <strong>Internet Message Access Protocol</strong> (<strong>IMAP</strong>) or the <strong>Post Office Protocol</strong> (<strong>POP</strong>). However, while those protocols are useful to update your phone's mail app, the application will still depend on SMTP to transmit any new messages you want to send to a remote address.</p>
<p>This outbound-only property and the need for software implementing various distinct protocols to meet the expectations of users of an email app means that the full process of managing the receipt and delivery of email can be a painful one. It typically involves multiple subsystems working in tandem to process every step of the transaction reliably.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending SMTP with MIME</h1>
                
            
            
                
<p>Having been defined in 1982, there are a number of limitations to SMTP when implemented strictly according to the standard. This includes the range of valid character encodings and alternative representations of certain content, such as images or sounds, directly in the message body of an email. To that end, IETF extended the protocol with the <strong>Multipurpose Internet Mail Extensions</strong> (<strong>MIME</strong>).</p>
<p>MIME provides users with the following: non-ASCII character representation; audio, image, video, and application attachments; multipart message bodies; and additional context and metadata in the message headers. Interestingly, this is where SMTP overlaps the most with HTTP. Even though MIME was originally designed and implemented as an SMTP extension, the ability to specify the character encoding and data structure of an incoming message was quickly identified as a useful feature for other application protocols transmitting text content. Naturally, it was adopted into use by HTTP in no time. <kbd>MIME-type</kbd> is the name of the value of the <kbd>ContentType</kbd> header sent with HTTP messages that contain a message body, and this is exactly how the extension is used by SMTP.</p>
<p>Hopefully, these commonalities between SMTP, FTP, and HTTP highlight for you just how much of the core application-layer protocol implementations are similar to one another.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">SMTP in .NET Core</h1>
                
            
            
                
<p class="mce-root">There are a lot of reasons why you might want to incorporate SMTP into your software. Maybe you want to give users a feedback mechanism for emailing the development team directly, and you want to do that with an SMTP client behind the scenes. Or maybe you want to wire up your error-handling infrastructure to send out emails to the support staff whenever exceptions of an unacceptable nature start getting thrown by your application. Whatever the case, you'll likely need a client for building those mail messages and sending them out to the target recipient.</p>
<p>While there are solutions for just such a problem available to you, they are not currently provided by Microsoft or the .NET Core framework. While the .NET Framework contained a <kbd>SmtpClient</kbd> class which, along with a <kbd>MailMessage</kbd> class, and could be used to generate and send automated emails to a valid SMTP server, those classes didn't make it into the spec for the .NET Core 1.0 release. They did make it into the initial .NET Core 2.0 release, but almost as soon as they arrived, they were deprecated by Microsoft for insufficient support for modern features of the protocol. What's more, in their deprecation notes, they explicitly state that they deprecated the libraries because they were "poorly designed." I took this to mean "not designed well enough to grow with the protocol."</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>So, now, instead of their internal libraries, Microsoft recommends using a third party called MailKit, the source control and documentation for which can be found here: <a href="https://github.com/jstedfast/MailKit">https://github.com/jstedfast/MailKit</a>.</p>
<p>So, while there is support for robust message generation for SMTP, the nature of the interactions is such that we won't be covering them here. Instead, I'll just allow this to serve as an example as to why you should always check on the status of any libraries you've used in the past before you incorporate them into a new project. Even if they were excellent when you last used them, the march of progress might have rendered them obsolete and deprecated before you managed to use them in a new project. And with that, we can move on from the application-layer protocols and start looking at the lower-level transport layer that makes it all possible.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we covered a lot of ground on some of the most common application-layer protocols still in use today. We looked at how different protocols were designed and optimized to perform different distinct tasks. Then we looked at exactly how FTP is optimized to perform its task of remote file transfer and directory lookup.</p>
<p>We learned how FTP uses two separate connections to communicate between clients. We saw how the command connection is set up to initialize the transfer of files, negotiate authentication, and determine the mechanism for the subsequent data connection. We looked at the variety of ways FTP can format the file for data transmission, and the various transmission techniques an FTP connection can be configured for. We also leveraged our FTP server admin console to observe the under-the-hood interactions going on between our application and the remote server when we were leveraging the high-level abstractions of the .NET <kbd>FtpWebRequest</kbd> and <kbd>FtpWebResponse</kbd> classes.</p>
<p>Once we were able to programmatically interact with our server, we looked at what sort of security considerations need to be made for FTP and got a general sense for how that was accomplished.</p>
<p>We wrapped up this chapter by looking at another common application-layer protocol with SMTP. We compared and contrasted its implementation with that of FTP and HTTP to understand what it does well, and then looked at its future on the .NET Core platform with the deprecation of the .NET libraries and the endorsement of third-party open source solutions. With that topic rounding out our exploration of the application layer of the OSI stack, we're well positioned to finally take a deep dive into the lower-level software components that enable all of this. In the next chapter, we'll finally be looking at the transport-layer protocols that make HTTP, FTP, and SMTP possible in the first place.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What are the primary differences between FTP and HTTP?</li>
<li>What are the two phases of FTP connections? How do they work?</li>
<li>What are the two modes for data transfer in FTP and how are they different from one another? When should you use one over the other?</li>
<li>What are the three modes of FTP data transfer?</li>
<li>What are the three ways to encode data in transit in FTP? When should they be used?</li>
<li>What are the definitions of SMTP and MIME? How do they relate to one another?</li>
<li>How is SMTP distinct from HTTP or FTP?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>If you're interested in some of the ways others have used FTP and SMTP libraries, you can check out <em>.NET Standard</em><em> 2.0 Cookbook,</em> by<em> Fiqri Ismai</em><em>l</em>. There's a chapter dedicated to networking applications that includes an SMTP implementation. You can find it here: <a href="https://www.packtpub.com/application-development/net-standard-20-cookbook">https://www.packtpub.com/application-development/net-standard-20-cookbook.</a></p>


            

            
        
    </body></html>