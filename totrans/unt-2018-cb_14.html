<html><head></head><body>
        

                            
                    <h1 class="header-title">Design Patterns</h1>
                
            
            
                
<p>In this chapter, we will cover:</p>
<ul>
<li>State-driven behavior DIY states</li>
<li>State-driven behavior State Design Pattern classes</li>
<li>State-driven behavior with Unity Scriptable Objects</li>
<li>Publisher-Subscriber pattern C# delegates and events</li>
<li>Model-View-Controller (MVC) pattern</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>In computer programming in general, some types of features and requirements occur commonly. For computer game programming, there are often features for new games that have things in common with existing games. Software <strong>Design Patterns</strong> are reusable, computer-language-independent templates for how to solve common problems.</p>
<p>Not all design patterns are needed for all languages (for example, some computer languages may have features that already provide an easy way to solve a common problem). In this chapter, we'll explore several common design patterns in the context of Unity game programming in the C# programming language.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The big picture</h1>
                
            
            
                
<p>There is no need to reinvent the wheel, and there are many advantages for game programmers to adopt tried-and-tested approaches to solving common features for game projects. Design patterns have been designed by experience, and refined to encourage good programming practice and well-designed architectural software solutions. A common theme in design patterns is the independence of code components, and clearly-defined interfaces for when components do need to know about each other and the protocols for their interactions.</p>
<p>In this chapter, the recipes focus on three main design patterns, all of which are well known and found not only in game software designs but in the design of many interactive software systems, such as web applications and mobile phone programming. The design patterns explored in this chapter are:</p>
<ul>
<li><strong>The State pattern</strong>: States and their transitions</li>
<li><strong>The Publisher-Subscriber pattern</strong>: Observers subscribing to event-publishing objects</li>
<li><strong>The Model-View-Controller (MCV) pattern</strong>: Separating internal workings from UI components and display representations</li>
</ul>
<p>In this chapter, examples are presented in generic object-oriented designs, also there are C#-specific features (such as <strong>delegates</strong> and <strong>events</strong>), and some Unity-specific features (such as <strong>scriptable objects</strong>). While generic approaches have the advantage that programmers from other languages or domains will be instantly familiar with their Unity game implementations, the most significant game memory-speed improvements are found through exploiting language- and engine-specific features.</p>
<p>C# <strong>Delegate</strong> variables are like a container for a function (or collection of functions) that can be passed around and invoked. They have values assigned to them and can be changed at runtime. <strong>Delegates</strong> can multicast through the use of the <kbd>+=</kbd> operator, multiple methods can be assigned a single delegate, and all will be invoked when the delegate is invoked. C# <strong>events</strong> are a special, more secure kind of delegate. By defining public static event variables, we restrict other script classes to only be allowed to:</p>
<ul>
<li>Subscribe one of their methods</li>
<li>Unsubscribe one of their methods</li>
</ul>
<p>Events ensure a good separation of our code logic, and mean that the script class publishing events does not need to know anything about, or how many, other script classes are subscribing to published events.</p>
<p>Here are some sources where you can learn more about <strong>Design Patterns</strong> and Unity:</p>
<ul>
<li>The Unity tutorial about <strong>Scriptable Objects</strong> for enemy state-driven AI: <a href="https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern">https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern</a></li>
<li>The Unity tutorial about <strong>delegates</strong> and <strong>events</strong>:
<ul>
<li><a href="https://unity3d.com/learn/tutorials/topics/scripting/delegates?playlist=17117">https://unity3d.com/learn/tutorials/topics/scripting/delegates?playlist=17117</a></li>
<li><a href="https://unity3d.com/learn/tutorials/topics/scripting/events">https://unity3d.com/learn/tutorials/topics/scripting/events</a></li>
</ul>
</li>
<li>Prime[31]'s video about Unity delegates and events (from 2011, but still a nice introduction): <a href="http://www.youtube.com/watch?v=N2zdwKIsXJs">http://www.youtube.com/watch?v=N2zdwKIsXJs</a></li>
<li>Eric Nordeus' tutorial on Unity and <strong>Design Patterns</strong>: <a href="http://www.habrador.com/tutorials/programming-patterns/">http://www.habrador.com/tutorials/programming-patterns/</a></li>
<li>Unity <strong>Model-View-Controller</strong> tutorials:
<ul>
<li>Gameasutra: <a href="https://www.gamasutra.com/blogs/TabeaIseli/20160926/282062/MVC_in_Unity.php">https://www.gamasutra.com/blogs/TabeaIseli/20160926/282062/MVC_in_Unity.php</a></li>
<li>Eduardo Dias Da Costa: <a href="https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development">https://www.toptal.com/unity-unity3d/unity-with-mvc-how-to-level-up-your-game-development</a></li>
<li>Jackson Dunstan: <a href="https://jacksondunstan.com/articles/3092">https://jacksondunstan.com/articles/3092</a></li>
</ul>
</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">State-driven behavior DIY states</h1>
                
            
            
                
<p>Games as a whole, and individual objects or characters, can often be thought of (or modeled as) passing through different states or modes. Modeling states and changes of state (due to events or game conditions) is a very common way to manage the complexity of games and game components. In this recipe, we create a simple three-state game (game playing/game won/game lost) using a <kbd>GameManager</kbd> class. Buttons and a timer are provided to simulate the events that would allow a player to win or lose the game:</p>
<div><img src="img/db3d658f-f2bb-45a7-b80a-21f607df37ec.png" style="width:25.75em;height:7.58em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To use states to manage object behavior, follow these steps:</p>
<ol>
<li>Create two UI Buttons at the top-middle of the screen. Name one <kbd>Button-win</kbd> and edit its text to read <kbd>Win Game</kbd>. Name the second <kbd>Button-lose</kbd> and edit its text to read <kbd>Lose Game</kbd>.</li>
<li>Create a UI Text object at the top left of the screen. Name this <kbd>Text-state-messages</kbd>, and set its Rect Transform height property to <kbd>300</kbd> and its Text (Script) Paragraph Vertical Overflow property to <kbd>Overflow</kbd>.</li>
<li>Create a new C# script class,&amp;nbsp;<kbd>GameStates.cs</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    public class GameStates<br/>     {<br/>         public enum GameStateType<br/>         {<br/>             GamePlaying,<br/>             GameWon,<br/>             GameLost,<br/>         }<br/>     } </pre>
<ol start="4">
<li>Create the&amp;nbsp;<kbd>MyGameManager.cs</kbd>&amp;nbsp;C# script class, and add an instance object as a component to the Main Camera:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/>     using System;<br/>     using UnityEngine.UI;<br/> <br/>     public class MyGameManager : MonoBehaviour<br/>     {<br/>         public Text textStateMessages;<br/>         public Button buttonWinGame;<br/>         public Button buttonLoseGame;<br/> <br/>         private GameStates.GameStateType currentState;<br/>         private float timeGamePlayingStarted;<br/>         private float timeToPressAButton = 5;<br/> <br/>         void Start()<br/>         {<br/>              currentState = GameStates.GameStateType.GamePlaying;<br/>         }<br/> <br/>         //--------- Update[ S ] - state specific actions<br/>         void Update()<br/>         {<br/>             switch (currentState)<br/>             {<br/>                 case GameStates.GameStateType.GamePlaying:<br/>                     UpdateStateGamePlaying();<br/>                     break;<br/>                 case GameStates.GameStateType.GameWon:<br/>                     // do nothing<br/>                     break;<br/>                 case GameStates.GameStateType.GameLost:<br/>                     // do nothing<br/>                     break;<br/>             }<br/>         }<br/> <br/>         public void NewGameState(GameStates.GameStateType newState)<br/>         {<br/>             // (1) state EXIT actions<br/>             OnMyStateExit(currentState);<br/> <br/>             // (2) change current state<br/>             currentState = newState;<br/> <br/>             // (3) state ENTER actions<br/>             OnMyStateEnter(currentState);<br/> <br/>             PostMessageDivider();<br/>         }<br/> <br/>         public void PostMessageDivider()<br/>         {<br/>             string newLine = "\n";<br/>             string divider = "--------------------------------";<br/>             textStateMessages.text += newLine + divider;<br/>         }<br/> <br/>         public void PostMessage(string message)<br/>         {<br/>             string newLine = "\n";<br/>             string timeTo2DecimalPlaces =<br/>     String.Format("{0:0.00}", Time.time);<br/>             textStateMessages.text += newLine +<br/>     timeTo2DecimalPlaces + " :: " + message;<br/>         }<br/> <br/>         private void DestroyButtons()<br/>         {<br/>             Destroy(buttonWinGame.gameObject);<br/>             Destroy(buttonLoseGame.gameObject);<br/>         }<br/> <br/>         //--------- OnMyStateEnter[ S ] - state specific actions<br/>         private void OnMyStateEnter(GameStates.GameStateType state)<br/>         {<br/>             string enterMessage = "ENTER state: " +<br/>             state.ToString();<br/>             PostMessage(enterMessage);<br/> <br/>             switch (state)<br/>             {<br/>                 case GameStates.GameStateType.GamePlaying:<br/>                     OnMyStateEnterGamePlaying();<br/>                     break;<br/>                 case GameStates.GameStateType.GameWon:<br/>                     // do nothing<br/>                     break;<br/>                 case GameStates.GameStateType.GameLost:<br/>                     // do nothing<br/>                     break;<br/>             }<br/>         }<br/> <br/>         private void OnMyStateEnterGamePlaying()<br/>         {<br/>             // record time we enter state<br/>             timeGamePlayingStarted = Time.time;<br/>         }<br/> <br/>         //--------- OnMyStateExit[ S ] - state specific actions<br/>         private void OnMyStateExit(GameStates.GameStateType state)<br/>         {<br/>             string exitMessage = "EXIT state: " + state.ToString();<br/>             PostMessage(exitMessage);<br/> <br/>             switch (state)<br/>             {<br/>                 case GameStates.GameStateType.GamePlaying:<br/>                     OnMyStateExitGamePlaying();<br/>                     break;<br/>                 case GameStates.GameStateType.GameWon:<br/>                     // do nothing<br/>                     break;<br/>                 case GameStates.GameStateType.GameLost:<br/>                     // do nothing<br/>                     break;<br/>             }<br/>         }<br/> <br/>         private void OnMyStateExitGamePlaying()<br/>         {<br/>             // if leaving gamePlaying state then destroy the 2 buttons<br/>             DestroyButtons();<br/>         }<br/> <br/> <br/>         private void UpdateStateGamePlaying()<br/>         {<br/>             float timeSinceGamePlayingStarted =<br/>             Time.time - timeGamePlayingStarted;<br/>             if (timeSinceGamePlayingStarted &gt; timeToPressAButton)<br/>             {<br/>                 string message = "User waited too long - automatically   <br/>                 going to Game LOST state";<br/>                   PostMessage(message);<br/>                 NewGameState(GameStates.GameStateType.GameLost);<br/>             }<br/>         }<br/>     } </pre>
<ol start="5">
<li>Create the&amp;nbsp;<kbd>ButtonActions.cs</kbd>&amp;nbsp;C# script class, and add an instance object as a component to the Main Camera:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class ButtonActions : MonoBehaviour<br/>     {<br/>         private MyGameManager myGameManager;<br/> <br/>         private void Start()<br/>         {<br/>             myGameManager = GetComponent&lt;MyGameManager&gt;();<br/>         }<br/> <br/>         public void BUTTON_CLICK_ACTION_WIN_GAME()<br/>         {<br/>             string message = "Win Game BUTTON clicked";<br/>             myGameManager.PostMessage(message);<br/>             myGameManager.NewGameState<br/>             (GameStates.GameStateType.GameWon);<br/>         }<br/> <br/>         public void BUTTON_CLICK_ACTION_LOSE_GAME()<br/>         {<br/>             string message = "Lose Game BUTTON clicked";<br/>             myGameManager.PostMessage(message);<br/>             myGameManager.NewGameState<br/>             (GameStates.GameStateType.GameLost);<br/>         }<br/> <br/>     } </pre>
<ol start="6">
<li>In the Hierarchy, select the Button-win button, and for its Button (Script) component, add an OnClick action to call the <kbd>BUTTON_CLICK_ACTION_WIN_GAME()</kbd> method from the ButtonsActions component in the Main Camera GameObject.</li>
<li>In the Hierarchy, select the Button-lose button, and for its Button (Script) component, add an OnClick action to call the <kbd>BUTTON_CLICK_ACTION_LOSE_GAME()</kbd> method from the ButtonActions component in the Main Camera GameObject.</li>
<li>In the Hierarchy, select the Main Camera GameObject. Drag this GameObject into the Inspector to ensure that all three GameManager (Script) public variables (Text State Messages, Button Win Game, and Button Lose Game)&amp;nbsp;have the corresponding Canvas GameObjects dragged into them (the two buttons and the UI Text GameObject).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As can be seen in the following state chart figure, this recipe models a simple game, which starts in the <kbd>GamePlaying</kbd> state; then, depending on the button clicked by the user, the game moves either into the <kbd>GameWon</kbd> state or the <kbd>GameLost</kbd> state. Also, if the user waits too long (five seconds) to click on a button, the game moves into the <kbd>GameLost</kbd> state.</p>
<p>The possible states of the system are defined using the enumerated&amp;nbsp;<kbd>GameStateType</kbd>&amp;nbsp;type in the&amp;nbsp;<kbd>GameStates</kbd> class, and the current state of the system at any point in time is stored in the&amp;nbsp;<kbd>currentState</kbd> variable of GameManager:</p>
<div><img src="img/618d0afd-9a1a-42b7-878d-22f91b072349.png" style="width:22.17em;height:10.83em;"/></div>
<p>The initial state,&amp;nbsp;<kbd>GamePlaying</kbd>, is set in the <kbd>Start()</kbd> method of <kbd>MyGameManager</kbd>.</p>
<div><kbd>GameManager</kbd> seems to now be a special asset name in Unity, for that reason, we have named our game manager script classes <kbd>MyGameManager</kbd> to avoid any issues.</div>
<p>When the <kbd>MyGameManager</kbd> object receives messages (for example, every frame for <kbd>Update()</kbd>), its behavior must be appropriate for the current state. So, we see a <kbd>Switch</kbd> statement in the&amp;nbsp;<kbd>Update()</kbd> method&amp;nbsp;that calls state-specific methods. For example, if the current state is <kbd>GamePlaying</kbd>, when an <kbd>Update()</kbd> message is received, the <kbd>UpdateStateGamePlaying()</kbd> method will be called.</p>
<p>The <kbd>NewGameState(...)</kbd> method first calls the <kbd>OnMyStateExit(...)</kbd> method with the current state, since there may be actions to be performed when a particular state is exited; for example, when the <kbd>GamePlaying</kbd> state is exited, it destroys the two buttons. Next, the <kbd>NewGameState(...)</kbd> method sets the <kbd>currentState</kbd> variable to be assigned the new state. Next, the <kbd>OnMyStateEnter(...)</kbd> method is called, since there may be actions to be performed immediately when a new state is entered. Finally, a message divider is posted to the UI Text box, with a call to the <kbd>PostMessageDivider()</kbd> method.</p>
<p>The <kbd>BUTTON_CLICK_ACTION_WIN_GAME()</kbd> and <kbd>BUTTON_CLICK_ACTION_LOSE_GAME()</kbd> methods are executed if their corresponding buttons have been clicked. They move the game into the corresponding <kbd>GameWon</kbd> or <kbd>GameLost</kbd> state.</p>
<p>Logic has been written in the <kbd>UpdateStateGamePlaying()</kbd> method, so once&amp;nbsp;<kbd>MyGameManager</kbd> has been in the <kbd>GamePlaying</kbd> state for more than a certain time (defined in the&amp;nbsp;<kbd>timeToPressAButton</kbd> variable), the game will automatically change into the <kbd>GameLost</kbd> state.</p>
<p>So, for each state, we may need to write methods for state exit, state entry, and update events, and also a main method for each event with a Switch statement to determine which state method should be called (or not). As can be imagined, the size of our methods and the number of methods in our <kbd>MyGameManager</kbd> class will grow significantly as more states and a more complex game logic are needed for non-trivial games.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The next recipe takes a more sophisticated approach to state-driven games, where each state has its own class. The next recipe in this chapter illustrates how to manage the complexity of states with class inheritance and the State Design Pattern.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">State-driven behavior using the State Design Pattern</h1>
                
            
            
                
<p>The previous pattern illustrated not only the usefulness of modeling game states, but also how a game manager class can grow in size and become unmanageable. To manage the complexity of many states and complex behaviors of states, the State pattern has been proposed in the software-development community. Design patterns are general-purpose software component architectures that have been tried and tested and found to be good solutions to commonly-occurring software-system features. The key features of the State pattern are that each state is modeled by its own class and that all states inherit (are subclassed) from a single parent state class. The states need to know about each other in order to tell the game manager to change the current state. This is a small price to pay for the division of the complexity of the overall game behavior into separate state classes.</p>
<p>Note: Many thanks to the contribution from Bryan Griffiths, which has helped improve this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe builds upon the previous recipe. So, make a copy of that project, open it, and then follow the steps for this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To manage an object's behavior using the State pattern architecture, perform the following steps:</p>
<ol>
<li>Create a new C# script class called <kbd>GameState</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    public class GameState<br/>     {<br/>         public enum EventType<br/>         {<br/>             ButtonWinGame,<br/>             ButtonLoseGame<br/>         }<br/> <br/>         protected MyGameManager gameManager;<br/>         public GameState(MyGameManager manager)<br/>         {<br/>             gameManager = manager;<br/>         }<br/> <br/>         public virtual void OnMyStateEntered() {}<br/>         public virtual void OnMyStateExit() {}<br/>         public virtual void StateUpdate() {}<br/>         public virtual void OnEventReceived(EventType eventType) {}<br/>     } </pre>
<ol start="2">
<li>Create a new C# script class called <kbd>StateGamePlaying</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class StateGamePlaying : GameState<br/>     {<br/>         public StateGamePlaying(MyGameManager manager) : <br/>         base(manager) { }<br/> <br/>         public override void OnMyStateEntered()<br/>         {<br/>             string stateEnteredMessage = "ENTER state: <br/>             StateGamePlaying";<br/>             gameManager.DisplayStateEnteredMessage<br/>             (stateEnteredMessage);<br/>             Debug.Log(stateEnteredMessage);<br/>         }<br/> <br/>         public override void OnEventReceived(EventType eventType)<br/>         {<br/>             switch(eventType){<br/>                 case (EventType.ButtonWinGame):<br/>                     gameManager.NewGameState(gameManager.stateGameWon);<br/>                     break;<br/>                 case (EventType.ButtonLoseGame):<br/>                 case (EventType.TimerFinished):<br/>                     gameManager.NewGameState<br/>                     (gameManager.stateGameLost);<br/>                     break;<br/>             }<br/>         }<br/>     } </pre>
<ol start="3">
<li>Create a new C# script class called <kbd>StateGameWon</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class StateGameWon : GameState<br/>     {<br/>         public StateGameWon(MyGameManager manager) : base(manager) { }<br/> <br/>         public override void OnMyStateEntered()<br/>         {<br/>             string stateEnteredMessage = "ENTER state: StateGameWon";<br/>             gameManager.DisplayStateEnteredMessage<br/>             (stateEnteredMessage);<br/>             Debug.Log(stateEnteredMessage);<br/>         }<br/>     } </pre>
<ol start="4">
<li>Create a new C# script class called <kbd>StateGameLost</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class StateGameLost : GameState<br/>     {<br/>         public StateGameLost(MyGameManager manager) : base(manager) { }<br/> <br/>         public override void OnMyStateEntered()<br/>         {<br/>             string stateEnteredMessage = "ENTER state: StateGameLost";<br/>             gameManager.DisplayStateEnteredMessage<br/>             (stateEnteredMessage);<br/>             Debug.Log(stateEnteredMessage);<br/>         }<br/>     } </pre>
<ol start="5">
<li>Replace the contents of the&amp;nbsp;<kbd>MyGameManager</kbd>&amp;nbsp;C# script class with the following:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/> <br/>     public class MyGameManager : MonoBehaviour<br/>     {<br/>         public Text textGameStateName;<br/>         public Button buttonWinGame;<br/>         public Button buttonLoseGame;<br/> <br/>         [HideInInspector]<br/>         public StateGamePlaying stateGamePlaying;<br/> <br/>         [HideInInspector]<br/>         public StateGameWon stateGameWon;<br/> <br/>         [HideInInspector]<br/>         public StateGameLost stateGameLost;<br/> <br/>         private GameState currentState;<br/> <br/>         private void Awake()<br/>         {<br/>             stateGamePlaying = new StateGamePlaying(this);<br/>             stateGameWon = new StateGameWon(this);<br/>             stateGameLost = new StateGameLost(this);<br/>         }<br/> <br/>         private void Start()<br/>         {<br/>             NewGameState(stateGamePlaying);<br/>         }<br/> <br/>         private void Update()<br/>         {<br/>             if (currentState != null)<br/>                 currentState.StateUpdate();<br/>         }<br/> <br/>         public void NewGameState(GameState newState)<br/>         {<br/>             if (null != currentState)<br/>                 currentState.OnMyStateExit();<br/> <br/>             currentState = newState;<br/>             currentState.OnMyStateEntered();<br/>         }<br/> <br/>         public void DisplayStateEnteredMessage(string  <br/>         stateEnteredMessage)<br/>         {<br/>             textGameStateName.text = stateEnteredMessage;<br/>         }<br/> <br/>         public void PublishEventToCurrentState(GameState.EventType <br/>         eventType)<br/>         {<br/>             currentState.OnEventReceived(eventType);<br/>             DestroyButtons();<br/>         }<br/> <br/>         private void DestroyButtons()<br/>         {<br/>             Destroy(buttonWinGame.gameObject);<br/>             Destroy(buttonLoseGame.gameObject);<br/>         }<br/>     } </pre>
<ol start="6">
<li>In the Hierarchy, select the Button-win button, and for its Button (Script) component, add an OnClick action to call the <kbd>BUTTON_CLICK_ACTION_WIN_GAME()</kbd> method from the GameManager component in the Main Camera GameObject.</li>
<li>In the Hierarchy, select the Button-lose button, and for its Button (Script) component, add an OnClick action to call the <kbd>BUTTON_CLICK_ACTION_LOSE_GAME()</kbd> method from the GameManager component in the Main Camera GameObject.</li>
<li>In the Hierarchy, select the Main Camera GameObject. Drag&amp;nbsp;it into the Inspector to ensure that all three GameManager (Script) public variables (Text State Messages, Button Win Game, and Button Lose Game)&amp;nbsp;have the corresponding Canvas GameObjects dragged into them (the two buttons and the <strong>UI Text</strong> GameObject).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The scene is very straightforward for this recipe. There is the single Main Camera GameObject that has the <kbd>MyGameManager</kbd> script object component attached to it.</p>
<p>A C# scripted class is defined for each state that the game needs to manage—for this example,&amp;nbsp;<kbd>StateGamePlaying</kbd>, <kbd>StateGameWon</kbd>, and <kbd>StateGameLost</kbd>. Each of these state classes is a subclass of <kbd>GameState</kbd>. <kbd>GameState</kbd> defines properties  and methods that all subclass states will possess:</p>
<ul>
<li>An enumerated type <kbd>EventType</kbd>, which defines the two possible button click events that the game might generate: <kbd>ButtonWinGame</kbd> and <kbd>ButtonLoseGame</kbd>.</li>
<li>The <kbd>gameManager</kbd> variable so that each state object has a link to the game manager.</li>
<li>The constructor method that accepts a reference to <kbd>MyGameManager</kbd>, which&amp;nbsp;automatically makes the <kbd>gameManager</kbd> variable refer to the passed-in <kbd>MyGameManager</kbd> object.</li>
<li>The four methods with empty bodies: <kbd>OnMyStateEntered()</kbd>, <kbd>OnMyStateExit()</kbd>, <kbd>OnEventRecieved(...)</kbd>, and <kbd>StateUpdate()</kbd>. Note that these methods are declared virtual so that they can be overridden by subclasses if necessary, but if not overridden then will do nothing.</li>
</ul>
<p>When the <kbd>MyGameManager</kbd> class's&amp;nbsp;<kbd>Awake()</kbd> method is executed, three state objects are created, one for each of the playing/win/lose classes. These state objects are stored in their corresponding variables: <kbd>stateGamePlaying</kbd>, <kbd>stateGameWon</kbd>, and <kbd>stateGameLost</kbd>.</p>
<p>The <kbd>MyGameManager</kbd> class has a variable called <kbd>currentState</kbd>, which is a reference to the current state object at any time while the game runs (initially, it will be null). Since it is of the <kbd>GameState</kbd> class (the parent of all state classes), it can refer to any of the different state objects.</p>
<p>After <kbd>Awake()</kbd>, <kbd>GameManager</kbd> will receive a <kbd>Start()</kbd> message. This method initializes&amp;nbsp;<kbd>currentState</kbd> to be the <kbd>stateGamePlaying</kbd> object.</p>
<p>For each frame,&amp;nbsp;<kbd>GameManager</kbd> will receive <kbd>Update()</kbd> messages. Upon receiving these messages, <kbd>GameManager</kbd> sends a <kbd>StateUpdate()</kbd> messages to&amp;nbsp;<kbd>currentState &amp;nbsp;</kbd>&amp;nbsp;object. So, for each frame, the object for the current state of the game will execute those methods. For example, when&amp;nbsp;<kbd>currentState</kbd> is set to game playing, for each frame, the <kbd>gamePlayingObject</kbd> will calls its (in this case, empty) <kbd>StateUpdate()</kbd> method.</p>
<p>The <kbd>StateGamePlaying</kbd> class implements statements in its <kbd>OnEventReceived()</kbd> method so that when the user clicks on a button, the <kbd>gamePlayingObject</kbd> will call the <kbd>GameManager</kbd> instance's <kbd>NewState(...)</kbd> method, passing it the object corresponding to the new state. So for example, if the user clicks on Button-win, the <kbd>NewState(...)</kbd> method is passed to <kbd>gameManager.stateGameWon</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding the Timer event to lose the game after five seconds</h1>
                
            
            
                
<p>The state pattern solution makes it much simpler, and cleaner to add new features. For example, to add the five-second-timer feature to this recipe, do the following:</p>
<ol>
<li>Create a new C# script class called <kbd>SimpleTimer</kbd>, and add an instance object as a component to the Main Camera GameObject:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class SimpleTimer : MonoBehaviour<br/>     {<br/>         private float timeGamePlayingStarted;<br/>         private float timeToPressAButton = 5;<br/> <br/>         private MyGameManager myGameManager;<br/> <br/>         private void Start()<br/>         {<br/>             myGameManager = GetComponent&lt;MyGameManager&gt;();<br/>             timeGamePlayingStarted = Time.time;<br/>         }<br/> <br/>         void Update ()<br/>         {<br/>             float timeSinceGamePlayingStarted = Time.time - <br/>             timeGamePlayingStarted;<br/> <br/>             if (timeSinceGamePlayingStarted &gt; timeToPressAButton)<br/>             {<br/>                 myGameManager.PublishEventToCurrentState<br/>                 (GameState.EventType.TimerFinished);<br/>             }<br/>         }<br/>     } </pre>
<ol start="2">
<li>Add a new event type of <kbd>TimerFinished</kbd> to the <kbd>GameState</kbd> script class:</li>
</ol>
<pre style="padding-left: 30px">    public enum EventType<br/>     {<br/>         ButtonWinGame,<br/>         ButtonLoseGame,<br/>         TimerFinished<br/>     } </pre>
<ol start="3">
<li>Add a new case to the switch statement in <kbd>StateGamePlaying</kbd>, so that this <kbd>TimerFinished</kbd> event also causes the game to go into the <kbd>GameLost</kbd> state:</li>
</ol>
<pre style="padding-left: 30px">    public override void OnEventReceived(EventType eventType)<br/>     {<br/>         switch(eventType){<br/>             case (EventType.ButtonWinGame):<br/>                 gameManager.NewGameState(gameManager.stateGameWon);<br/>                 break;<br/>             case (EventType.ButtonLoseGame):<br/>             case (EventType.TimerFinished):<br/>                 gameManager.NewGameState(gameManager.stateGameLost);<br/>                 break;<br/>         }<br/>     } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>In this recipe, some of the complexity of different types of events causing the <kbd>MyGameManager</kbd> to change its current state was implemented by other scripted objects (<kbd>ButtonActions</kbd> and <kbd>SimpleTimer</kbd> as scripted object components inside Main Camera) invoking the&amp;nbsp;<kbd>PublishEventToCurrentState(...)</kbd> public method. A better was to implement events in games is provided later in this chapter in the&amp;nbsp;<em>Publisher-Subscriber pattern C# delegates and events</em> recipe.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">State-driven behavior with Unity Scriptable Objects</h1>
                
            
            
                
<p>Unity has a feature called Scriptable Objects. Scriptable Objects are asset files stored in the <kbd>Assets</kbd> folder, like any other asset (such as Materials or Textures). In some ways,&amp;nbsp;Scriptable Objects are like Monobehaviours, but they are not attached to GameObjects. Both logic (code) and data can be stored as asset files in the form of&amp;nbsp;Scriptable Objects.</p>
<p>In this recipe, we implement a state-based game where the game starts in a game-playing state, and goes to a game-lost state when a timer runs out. If two stars are collected before the timer runs out, the game goes into the game-won state. A <strong>UI Button</strong> is offered to the user, which collects a star each time it is clicked.</p>
<p>As you'll see, Scriptable Object asset files are used to represent which decisions cause which state changes to take place.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To manage a game's state-driven behavior with Unity Scriptable Objects, perform the following steps:</p>
<ol>
<li>Create a <strong>UI Button</strong> in the middle of the screen. Name it <kbd>Button-collect-star</kbd> and edit its text to read <kbd>Collect a star</kbd>.</li>
<li>Create a <strong>UI Text</strong> object at the top-right of the screen. Name this <kbd>Text-current-state</kbd>.</li>
<li>Create a <strong>UI Text</strong> object at the top-left of the screen. Name this <kbd>Text-stars-collected</kbd>.</li>
<li>Create a second UI Text object at the top-left of the screen, positioned below <kbd>Text-stars-collected</kbd>. Name this <kbd>Text-seconds-left</kbd>.</li>
<li>Create a new C# script class called <kbd>Decision</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public abstract class Decision : ScriptableObject<br/>     {<br/>         public abstract bool Decide(StateController controller);<br/>     }</pre>
<ol start="6">
<li>Create a new C# script class called <kbd>Transition</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    [System.Serializable]<br/>     public class Transition<br/>     {<br/>         public Decision decision;<br/>         public State trueState;<br/>     } </pre>
<ol start="7">
<li>Create a new C# script class called <kbd>State</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     [CreateAssetMenu(menuName = "MyGame/State")]<br/>     public class State : ScriptableObject<br/>     {         public Transition[] transitions;<br/> <br/>         public void UpdateState(StateController controller)<br/>         {<br/>             CheckTransitions(controller);<br/>         }<br/> <br/>         private void CheckTransitions(StateController controller)<br/>         {<br/>             for (int i = 0; i &lt; transitions.Length; i++)<br/>             {<br/>                 bool decisionSucceeded = <br/>                 transitions[i].decision.Decide(controller);<br/> <br/>                 if (decisionSucceeded)<br/>                 {<br/>                     controller.TransitionToState<br/>                     (transitions[i].trueState);<br/>                 }<br/>             }<br/>         }<br/>     } </pre>
<ol start="8">
<li>Create a new C# script class called <kbd>StateController</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class StateController : MonoBehaviour<br/>     {<br/>         public State currentState;<br/>         [HideInInspector] public MyGameManager gameManager;<br/> <br/>         void Awake()<br/>         {<br/>             gameManager = GetComponent&lt;MyGameManager&gt;();<br/>         }<br/> <br/>         private void Update()<br/>         {<br/>             currentState.UpdateState(this);<br/>             gameManager.DisplayCurrentState(currentState);<br/>         }<br/> <br/>         public void TransitionToState(State nextState)<br/>         {<br/>             currentState = nextState;<br/>         }<br/>     } </pre>
<ol start="9">
<li>Create a new C# script class called <kbd>GameWonDecision</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     [CreateAssetMenu(menuName = "MyGame/Decisions/GameWonDecision")]<br/>     public class GameWonDecision : Decision<br/>     {<br/> <br/>         public override bool Decide(StateController controller)<br/>         {<br/>             return GameWonActionDetected(controller.gameManager);<br/>         }<br/> <br/>         private bool GameWonActionDetected(MyGameManager gameManager)<br/>         {<br/>             return gameManager.HasCollectedAllStars();<br/>         }<br/>     } </pre>
<ol start="10">
<li>Create a new C# script class called <kbd>GameLostDecision</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     [CreateAssetMenu(menuName = "MyGame/Decisions/GameLostDecision")]<br/>     public class GameLostDecision : Decision<br/>     {<br/> <br/>         public override bool Decide(StateController controller)<br/>         {<br/>             return GameLostActionDetected(controller.gameManager);<br/>         }<br/> <br/>         private bool GameLostActionDetected(MyGameManager gameManager)<br/>         {<br/>             return gameManager.GetTimeRemaining() &lt;= 0;<br/>         }<br/>     } </pre>
<ol start="11">
<li>Create a new C# script class called <kbd>MyGameManager</kbd>, and add an instance object as a component of the Main Camera:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/> <br/> <br/>     public class MyGameManager : MonoBehaviour<br/>     {<br/>         public Text textCurrentState;<br/>         public Text textStarsCollected;<br/>         public Text textSecondsLeft;<br/> <br/>         public float secondsLeft = 10;<br/>         public int totalStarsToBeCollected = 2;<br/>         private int starsColleted = 0;<br/> <br/>         void Update()<br/>         {<br/>             secondsLeft -= Time.deltaTime;<br/>             UpdateDisplays();<br/>         }<br/> <br/>         public void DisplayCurrentState(State currentState)<br/>         {<br/>             textCurrentState.text = currentState.name;<br/>         }<br/> <br/>         public bool HasCollectedAllStars()<br/>         {<br/>             return (starsColleted == totalStarsToBeCollected);<br/>         }<br/> <br/>         public float GetTimeRemaining()<br/>         {<br/>             return secondsLeft;<br/>         }<br/> <br/>         public void BUTTON_ACTION_PickupOneStar()<br/>         {<br/>             starsColleted++;<br/>         }<br/> <br/>         private void UpdateDisplays()<br/>         {<br/>             textStarsCollected.text = "stars = " + starsColleted;<br/>             textSecondsLeft.text = "time left = " + secondsLeft;<br/>         }<br/>     } </pre>
<ol start="12">
<li>In the Hierarchy, select the Button-collect-star button, and for its Button (Script) component, add an OnClick action to call the <kbd>BUTTON_ACTION_PickupOneStar()</kbd> method from the <kbd>MyGameManager</kbd> component in the Main Camera GameObject.</li>
<li>In the Project panel, create two new folders, named <kbd>_Decisions</kbd> and <kbd>_States</kbd>. These folders will contain the Scriptable Object asset files for this project.</li>
<li>In the&amp;nbsp;<kbd>_Decisions</kbd> folder, create two new Decision Scriptable Objects named <kbd>GameWonDecision</kbd> and <kbd>GameLostDecision</kbd>. Do this by choosing menu: Assets | Create | MyGame | Decisions.</li>
<li>In the&amp;nbsp;<kbd>_States</kbd> folder, create three new State Scriptable Objects named <kbd>StateGamePlaying</kbd>, <kbd>StateGameWon</kbd>, and <kbd>StateGameLost</kbd>. Do this by choosing menu: Assets | Create | MyGame | State.</li>
<li>In the&amp;nbsp;Project panel folder <kbd>_States</kbd>, select the&amp;nbsp;<kbd>StateGamePlaying</kbd> Scriptable Object, and in the Inspector, set the size of its Transitions property to <kbd>2</kbd>.
<ul>
<li>For Element 0, set the Decision to GameWonDecision and the True&amp;nbsp;state to StateGameWon</li>
<li>For Element 1, set the Decision to GameLostDecision and the True&amp;nbsp;state to StateGameLost:</li>
</ul>
</li>
</ol>
<div><img src="img/36fe5ff2-2a96-4d8a-babb-f9622131b3bf.png" style="width:24.75em;height:13.00em;"/></div>
<ol start="17">
<li>In the Hierarchy, select the Main Camera GameObject. Drag it into the Inspector to ensure that all three GameManager (Script) public variables (Text Current State, Text Stars Collected, and Text Seconds Left)&amp;nbsp;have the corresponding Canvas <strong>UI Text</strong> GameObjects dragged into them.</li>
<li>Run the game. The game should start in <kbd>StateGamePlaying</kbd>. If the user does nothing, when the timer gets to zero, the game should go into <kbd>StateGameLost</kbd>. If the user clicks the button twice (simulating collecting two stars) before the timer hits zero, the game should go into <kbd>StateGameWon</kbd>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>GameManager knows nothing about the state-based decisions going on in this game. It has a public method giving the number of seconds left in the timer: <kbd>GetTimeRemaining()</kbd>. It also has a public method that returns a Boolean (true/false) about whether or not all stars have been collected: <kbd>HasCollectedAllStars()</kbd>. It also has references to the three&amp;nbsp;<strong>UI Text</strong> GameObjects, so it can keep the display updated with the time left and stars collected. A public&amp;nbsp;<kbd>DispayCurrentState(...)</kbd>&amp;nbsp;method also updates the name of current game state (that is, whatever was passed to this method).</p>
<p>The core game behavior is driven by the <kbd>StateController</kbd> script class. This maintains the current state, and has a reference to the instance object of the <kbd>MyGameManager</kbd> class that is its sibling component in the Main Camera. Its <kbd>Awake()</kbd> method gets the reference to the <kbd>MyGameManager</kbd> object. Its <kbd>Update()</kbd>&amp;nbsp;method invokes the current state's <kbd>UpdateState(...)</kbd> method. It passes a reference to itself to the current state. It also has a third public method, <kbd>TransitionToState(...)</kbd>, which allows a state to instruct the controller to change the current state.</p>
<p>The <kbd>Transition</kbd> class has no methods, it simply stores references to two objects: a decision and the state that the system will to change to if the decision is true.</p>
<p>The <kbd>Decision</kbd> class is abstract, which means there will never be any objects created from this class, but subclasses may be defined. It declares that any subclasses must implement a method named <kbd>Decide(...)</kbd>, which&amp;nbsp;returns a Boolean (true/false) value.</p>
<p>The <kbd>State</kbd> class has an array of <kbd>Transition</kbd> objects, and its <kbd>UpdateState()</kbd> method simple invokes its <kbd>CheckTransitions(...)</kbd> method.&amp;nbsp;<kbd>CheckTransitions(...)</kbd> loops through each transition, testing its <kbd>Decision</kbd>. If the decision is true, it tells&amp;nbsp;<kbd>StateController</kbd> to make the current state the true state of the transition.</p>
<p>In this project, we have declared two subclasses of the <kbd>Decision</kbd> class:</p>
<ul>
<li><kbd>GameWonDecision</kbd>: This class' <kbd>Decide(...)</kbd> method returns the value of its&amp;nbsp;<kbd>GameWonActionDetected(...)</kbd> method.&amp;nbsp;<kbd>GameWonActionDetected(...)</kbd> returns the value of the game manager's <kbd>HasCollectedAllStars()</kbd> method, that is, the game-won decision is true when the game manager says that all stars have been collected.</li>
<li><kbd>GameWonDecision</kbd>: This class's&amp;nbsp;<kbd>Decide(...)</kbd> method returns the value of its&amp;nbsp;<kbd>GameLostActionDetected(...)</kbd> method.&amp;nbsp;<kbd>GameLostActionDetected(...)</kbd> returns true if the game manager's timer is zero or less (time has run out).</li>
</ul>
<p>We have created five scriptable object assets:</p>
<ul>
<li><strong>Three states</strong>: <kbd>StateGamePlaying</kbd>, <kbd>StateGameWon</kbd>, <kbd>StateGameLost</kbd></li>
<li><strong>Two decisions</strong>: <kbd>GameWonDecision</kbd> and <kbd>GameLostDecision</kbd></li>
</ul>
<p>We were able to create these Scriptable Object assets via the Create menu through the statements immediately before the script-class declarations for <kbd>Decision</kbd> and <kbd>State</kbd> that declared that there should be a new sub-menu in the Create Asset menu named MyGame:</p>
<pre>[CreateAssetMenu(menuName = "MyGame/Decisions/GameLostDecision")] </pre>
<p>The only one of these Scriptable Objects that needed any customizing was <kbd>StateGamePlaying</kbd>. Two transitions were defined in this object:</p>
<ul>
<li>If <kbd>GameWonDecision</kbd> becomes true, the State Controller should set the current state to <kbd>StateGameWon</kbd></li>
<li>If <kbd>GameLostDecision</kbd> becomes true, the State Controller should set the current state to <kbd>StateGameLost</kbd></li>
</ul>
<p>While it may seem like there was a lot of work for this simple game, what this recipe illustrates is how some generic state-machine classes can be created (<kbd>State</kbd>, <kbd>Decision</kbd>, <kbd>Transition</kbd>, <kbd>StateController</kbd>), and that the actual game behavior is modelled through a set of Scriptable Object assets, and two classes to implement the decision-making for special game events (<kbd>GameWonDecision</kbd> and <kbd>GameLostDecision</kbd>).</p>
<p>Since Scriptable Object are asset files, there are only one of them. At times, we may want the same Scriptable Object to be used by different GameObjects when the game is running—for example, the state transitions for the AI of lots of different enemy characters may share the use of the same Scriptable Object. For this reason, a reference to a <kbd>StateController</kbd> object instance is passed when methods are invoked on <kbd>State</kbd> and <kbd>Decision</kbd> Scriptable Objects,&amp;nbsp;so the logic in the methods of the Scriptable Object can work on whatever run-time controller object is provided with. This is an example of another design pattern known as the <strong>Delegate</strong> design pattern (not to be confused with a C# delegate!).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending the game to model Player health</h1>
                
            
            
                
<p>To further understand the power of this data-centric approach to state-based games, let's add the following behavior to the game:</p>
<ul>
<li>The player has a health value, starting at 100% (a float value of 1.0)</li>
<li>In each frame, a random amount of health is added or subtracted</li>
<li>The game is lost if the health of the player goes down to zero</li>
</ul>
<p>To implement this feature, all we need to do is:</p>
<ol>
<li>Add a test to the&amp;nbsp;<kbd>GameLostDecision</kbd>&amp;nbsp;script class to return true if time or health are zero:</li>
</ol>
<pre style="padding-left: 30px">    private bool GameLostActionDetected(MyGameManager gameManager)<br/>     {<br/>         return (gameManager.GetTimeRemaining() &lt;= 0) || <br/>         (gameManager.GetHealth() &lt;= 0);<br/>     } </pre>
<ol start="2">
<li>Add the <kbd>health</kbd> feature to the&amp;nbsp;<kbd>GameManager</kbd> script class:</li>
</ol>
<pre style="padding-left: 30px">    private float health = 1;<br/>     public float healthPlusMaximum = 0.03f;<br/>     public float healthMinusMaximum = -0.03f;<br/> <br/>     void Update()<br/>     {<br/>         // extra feature<br/>         RandomlyChangeHealth();<br/> <br/>         secondsLeft -= Time.deltaTime;<br/>         UpdateDisplays();<br/>     }<br/> <br/>     // extra freature<br/>     public float GetHealth()<br/>     {<br/>         return health;<br/>     }<br/> <br/>     // health can't go below 0 or above 1<br/>     private void RandomlyChangeHealth()<br/>     {<br/>         float healthChange = Random.Range(healthMinusMaximum,  <br/>         healthPlusMaximum);<br/>         health += healthChange;<br/>         health = Mathf.Clamp(health, 0, 1);<br/>     } </pre>
<p>We could also add another <strong>UI Text</strong> on screen to see the current value of health. If the public <kbd>healthPlusMaximum</kbd> variable is set smaller than the minus maximum (for example,&amp;nbsp;<kbd>0.02</kbd>), the health will go downwards since the random average will be less than zero.</p>
<p class="mce-root"/>
<p>To add another state, such as&amp;nbsp;<kbd>StatePauseGame</kbd>, all that is needed are the following steps:</p>
<ol>
<li>Create new&amp;nbsp;<kbd>GamePausedDecision</kbd> script class, with the logic to detect whether the game is paused (for example, the game manager could have an&amp;nbsp;<kbd>isPaused</kbd>&amp;nbsp;boolean variable that gets set to true when the user presses the <em>P</em> key)</li>
<li>Create a new&amp;nbsp;<kbd>StateGamePaused</kbd> Scriptable Object State</li>
<li>Create a new&amp;nbsp;<kbd>GamePausedDecision</kbd> Scriptable Object State</li>
<li>Add a third transition to the&amp;nbsp;<kbd>StateGamePlaying</kbd>&amp;nbsp;Scriptable Object State (element 2), with <kbd>GamePausedDecision</kbd> and the true state of <kbd>StateGamePaused</kbd></li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>To see this approach to state-driven games using Scriptable Objects taken much further, including adding the feature for actions to be performed during each state, follow the online video Unity tutorial about Scriptable Objects for enemy state-driven AI:&amp;nbsp;<a href="https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern">https://unity3d.com/learn/tutorials/topics/navigation/finite-state-ai-delegate-pattern</a>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Publisher-Subscriber pattern C# delegates and events</h1>
                
            
            
                
<p>When events can be based on visibility, distance, or collisions, we can use such events as <kbd>OnTriggerExit</kbd> and <kbd>OnBecomeInvisible</kbd>. When events can be based on time periods, we can use coroutines. However, some events are unique to each game situation, and C# offers several methods of broadcasting user-defined event messages to scripted objects. One approach is the <kbd>SendMessage(...)</kbd> method, which, when sent to a GameObject, will check every Monobehaviour scripted component and execute the named method if its parameters match. However, this involves an inefficient technique known as reflection. C# offers another event message approach known as delegates and events, which we describe and implement in this recipe.</p>
<p>Delegates and events work in a similar way to <kbd>SendMessage(...)</kbd>, but are much more efficient since Unity maintains a defined list of which objects are listening to the broadcast events. <kbd>SendMessage(...)</kbd> should be avoided if performance is important, since it means that Unity has to analyze each scripted object (reflect over the object) to see whether there is a public method corresponding to the message that has been sent; this is much slower than using delegates and events.</p>
<p>Delegates separate the code declaring the delegate from any of the codes (classes) that use the delegate. The script-class that declares the public delegate does not need to know anything about the object or objects that make use of its delegated functionality.</p>
<p>Delegates and events implement the <strong>Publisher-Subscriber design pattern</strong> (<strong>pubsub</strong>). This is also known as the <strong>Observer</strong> design pattern. Objects can subscribe one of their methods to receive a particular type of event message from a particular publisher. In this recipe, we'll have a manager class that will publish new events when <strong>UI Buttons</strong> are clicked. We'll create some <strong>UI objects</strong>, some of which subscribe to the color-change events. Each time a color-change event is published, subscribed <strong>UI objects</strong> receive the event message and change their color accordingly.</p>
<p>We will also add a console event logger, to listen for and log messages about color-change events.</p>
<p>C# publisher objects don't have to worry about how many objects subscribe to them at any point in time (it could be none or 1,000!). This is known as <strong>loose coupling</strong>, since it allows different code components to be written (and maintained) independently and is a desirable feature of object-oriented code:</p>
<div><img src="img/2154430f-5063-4aa5-a1ab-610c558782c8.png" style="width:33.42em;height:20.25em;"/></div>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, a Unity Package has been provided (<kbd>colorChangeScene.unitypackage</kbd>) in the <kbd>17_04</kbd> folder. This package contains a scene with <strong>UI Buttons</strong> and other objects for the recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To implement the Publisher-Subscriber pattern using C# delegates and events, follow these steps:</p>
<ol>
<li>Create a new Unity project, and delete the default&amp;nbsp;<kbd>Scenes</kbd> folder.</li>
<li>Import the provided Unity package (<kbd>colorChangeScene.unitypackage</kbd>).</li>
<li>Add the following <kbd>ColorManager</kbd> C# script class to the Main Camera:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class ColorManager : MonoBehaviour<br/>     {<br/>         private ColorModel colorModel;<br/>         private ColorChangeListenerConsole colorChangeListenerConsole;<br/> <br/>         void Awake()<br/>         {<br/>             colorModel = new ColorModel();<br/>             colorChangeListenerConsole = new <br/>             ColorChangeListenerConsole();<br/>         }<br/> <br/>         public void BUTTON_ACTION_make_green()<br/>         {<br/>             colorModel.SetColor(Color.green);<br/>         }<br/> <br/>         public void BUTTON_ACTION_make_blue()<br/>         {<br/>             colorModel.SetColor(Color.blue);<br/>         }<br/> <br/>         public void BUTTON_ACTION_make_red()<br/>         {<br/>             colorModel.SetColor(Color.red);<br/>         }<br/>     }</pre>
<ol start="4">
<li>Create the&amp;nbsp;<kbd>ColorChangeListenerImage</kbd>&amp;nbsp;C# script class, and add an instance object as a component to the&amp;nbsp;<kbd>Image-listening</kbd> and <kbd>Slider-listening</kbd> GameObjects (both children of&amp;nbsp;Canvas | listening-game-objects):</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/> <br/>     public class ColorChangeListenerImage : MonoBehaviour<br/>     {<br/>         void OnEnable() {<br/>             ColorModel.OnChangeColor += ChangeColorEvent;<br/>         }<br/> <br/>         void OnDisable(){<br/>             ColorModel.OnChangeColor -= ChangeColorEvent;<br/>         }<br/> <br/>         void ChangeColorEvent(Color newColor)<br/>         {<br/>             GetComponent&lt;Image&gt;().color = newColor;<br/>         }<br/>     } </pre>
<ol start="5">
<li>Create the&amp;nbsp;<kbd>ColorChangeListenerText</kbd>&amp;nbsp;C# script class, and add an instance object as a component to the&amp;nbsp;<kbd>Text-listening</kbd> GameObject&amp;nbsp;(a child of&amp;nbsp;Canvas | listening-game-objects):</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/> <br/>     public class ColorChangeListenerText : MonoBehaviour<br/>     {<br/>         void OnEnable() {<br/>             ColorModel.OnChangeColor += ChangeColorEvent;<br/>         }<br/> <br/>         void OnDisable(){<br/>             ColorModel.OnChangeColor -= ChangeColorEvent;<br/>         }<br/> <br/>         void ChangeColorEvent(Color newColor)<br/>         {<br/>             GetComponent&lt;Text&gt;().color = newColor;<br/>         }<br/>     }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="6">
<li>Create the <kbd>ColorChangeListenerConsole</kbd> C# script class:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class ColorChangeListenerConsole<br/>     {<br/>         public ColorChangeListenerConsole()<br/>         {<br/>             ColorModel.OnChangeColor += ChangeColorEvent;<br/>         }<br/> <br/>         ~ColorChangeListenerConsole()<br/>         {<br/>             ColorModel.OnChangeColor -= ChangeColorEvent;<br/>         }<br/> <br/>         void ChangeColorEvent(Color newColor){<br/>             Debug.Log("new color = " + newColor);<br/>         }<br/>     } </pre>
<ol start="7">
<li>Create the <kbd>ColorModel</kbd> C# script class:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class ColorModel<br/>     {<br/>         private Color color;<br/> <br/>         public delegate void ColorChangeHandler(Color newColor);<br/>         public static event ColorChangeHandler OnChangeColor;<br/> <br/>         private void PublishColorEvent()<br/>         {<br/>             // if there is at least one listener to this delegate<br/>             if (OnChangeColor != null)<br/>                 // broadcast change colour event<br/>                 OnChangeColor(this.color);<br/>         }<br/> <br/>         public void SetColor(Color newColor)<br/>         {<br/>             this.color = newColor;<br/>             PublishColorEvent();<br/>         }<br/>     } </pre>
<ol start="8">
<li>With button-GREEN selected in the Hierarchy, add a new OnClick() event for this button, dragging the Main Camera as the target GameObject and selecting the&amp;nbsp;BUTTON_ACTION_make_green() public function. Do the same for the button-BLUE and button-RED buttons with the&amp;nbsp;BUTTON_ACTION_make_blue() and BUTTON_ACTION_make_red() functions, respectively.</li>
<li>Run the game. When you click a change-color button, the three <strong>UI objects</strong> on the right of the screen show all changes to the corresponding color, while the two <strong>UI objects</strong> at the bottom-left of the screen remain in the default white color. You should also see <kbd>Debug.Log</kbd> messages in the Console panel, showing the RBG color corresponding to the button that was clicked.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We have added an instance object of <kbd>ColorManager</kbd> to the Main Camera. This class does three main things:</p>
<ul>
<li>Creates an instance object of the&amp;nbsp;<kbd>ColorChangeListenerConsole</kbd> script class</li>
<li>Creates an instance object of the&amp;nbsp;<kbd>ColorModel</kbd> script class</li>
<li>Offers three public methods that can be invoked by clicking the red/green/blue UI Buttons</li>
</ul>
<p>Each time a button is clicked, the <kbd>colorModel</kbd> object is told to <kbd>SetColor(...)</kbd> to the corresponding color.</p>
<p>The <kbd>ColorModel</kbd>&amp;nbsp;script class has a private variable of the current color. This value can be changed by invoking its <kbd>SetColor(...)</kbd> method (from the <kbd>ColorManager</kbd> when a button is clicked). As well as changing the value of color, the&amp;nbsp;<kbd>SetColor(...)</kbd>&amp;nbsp;method also invokes the&amp;nbsp;<kbd>PublishColorEvent()</kbd> method. The&amp;nbsp;<kbd>PublishColorEvent()</kbd>&amp;nbsp;method publishes the&amp;nbsp;<kbd>OnChangeColor(this.color)</kbd> event,&amp;nbsp;so that all registered listeners to this event will be invoked with the new color value.</p>
<p>On the right-hand side of the screen, we have three GameObjects: Image-listening, Slider-listening, and Text-listening. Each of these objects has a scripted component of either <kbd>ColorChangeListenerImage</kbd> or <kbd>ColorChangeListenerText</kbd>. These components register their respective <kbd>OnChangeColor(...)</kbd> methods to listen for <kbd>OnChangeColor(this.color)</kbd> events. The <kbd>ColorChangeListenerImage</kbd> and <kbd>ColorChangeListenerText</kbd> script classes both register their <kbd>ChangeColor(...)</kbd> methods to the <kbd>OnChangeColor(...)</kbd> event of the <kbd>ColorModel</kbd> script class.</p>
<p>The&amp;nbsp;<kbd>ColorChangeListenerConsole</kbd>&amp;nbsp;script class also registers its <kbd>ChangeColor(...)</kbd> methods to the <kbd>OnChangeColor(...)</kbd> event of the&amp;nbsp;<kbd>ColorModel</kbd> script class.</p>
<p>Since our scripted objects may be disabled and enabled at different times, each time a scripted <kbd>ColorChangeListener</kbd> object is enabled (such as when its GameObject parent is instantiated), its <kbd>OnChangeColor()</kbd> method is added (<kbd>+=</kbd>) to the list of those subscribed to listen for color-change events, likewise, each time <kbd>ColorChangeListenerImage</kbd> or <kbd>Text</kbd> objects are disabled, those methods are removed (<kbd>-=</kbd>) from the list of event subscribers.</p>
<p>It is very important that methods are removed from the list of subscribers to an event when they are no longer required. Failure to do this can lead to significant problems, such as memory leaks.</p>
<p>When <kbd>ColorChangeListenerImage</kbd> or a <kbd>Text</kbd> object receives a color-change message, its subscribed <kbd>OnChangeColor()</kbd> method is executed and the color of the appropriate component is changed to the received color value (green/red/blue).</p>
<p>The <kbd>ColorManager</kbd> class declares a <strong>Delegate</strong> named <kbd>ColorChangeHandler</kbd>. Delegates define the return type (in this case, <kbd>void</kbd>) and argument signature of methods that can be delegated (subscribed) to an event. In this case, methods must have the argument signature of a single parameter of the&amp;nbsp;<kbd>Color</kbd> type. Our <kbd>OnChangeColor()</kbd> method in the&amp;nbsp;<kbd>ColorChangeListenerImage</kbd>, <kbd>Text</kbd>, and <kbd>Console</kbd>&amp;nbsp;classes matches this argument signature and so is permitted to subscribe to&amp;nbsp;<kbd>changeColorEvent</kbd> in the <kbd>ColorManager</kbd> class.</p>
<p>You may notice that&amp;nbsp;<kbd>ColorChangeListenerConsole</kbd> does not have <kbd>OnEnable</kbd> or <kbd>OnDisable</kbd> methods. This is because it is not a MonoBehaviour, and so does not receive Unity runtime events such as <kbd>Awake()</kbd>, <kbd>Update()</kbd>, or <kbd>OnEnable()</kbd>. However, being a simple class, it can have a constructor method invoked when a new object instance is created with the new keyword, and a destructor method invoked when the object is no longer referenced. So it is in those methods that these objects register and deregister to listen to <kbd>ColorModel.OnChangeColor</kbd> events.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Model-View-Controller (MVC) pattern</h1>
                
            
            
                
<p>The <strong>Model-View-Controller</strong> (<strong>MVC</strong>) pattern is a software architecture that tries to separate the data (Model) from the displays (Views) and actions that change that data (Controller).</p>
<p>In this recipe, we use the MVC pattern to implement a feature of many games—a visual health bar representing the Player's numeric health value (in this case, a float number from 0.0 - 1.0). As the user presses the Up/Down arrow keys (simulating healing and damage), the value of the player's heath changes. With the health-change events, the visual display and a <strong>Console</strong> log are updated to present the new health values to the user:</p>
<div><img src="img/2f1a83c1-3d1a-4ecd-8b51-b8ba25b99953.png" style="width:15.92em;height:4.67em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, two images been provided in the <kbd>17_05</kbd> folder:</p>
<ul>
<li><kbd>health_bar_outline.png</kbd>: A red heart image and outline for the health filler</li>
<li><kbd>health_bar_fill_blue_to_green.png</kbd>: A graduated (blue left to green right) filler image, indicating how much health is left</li>
</ul>
<p>Thanks to Pixel Art Maker for the health bar image:</p>
<ul>
<li><a href="http://pixelartmaker.com/art/49e2498a414f221">http://pixelartmaker.com/art/49e2498a414f221</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To implement the MVC pattern in Unity, follow these steps:</p>
<ol>
<li>Import the two provided images.</li>
<li>Create a <strong>UI Image</strong> named <kbd>Image-health-bar-outline</kbd>, and populate it with the <kbd>health_bar_outline</kbd> image asset.</li>
<li>Create a <strong>UI Image</strong> named <kbd>Image-health-bar-filler</kbd>, and populate it with the <kbd>health_bar_fill_blue_to_green</kbd> image asset. In the Inspector for the Image (Script) component, set the Image Type to Filled, and the Fill Type to Horizontal.</li>
<li>Arrange your <strong>Canvas</strong> so that Image-health-bar-filler is before Image-health-bar in the Hierarchy (the filler appears behind the outline).</li>
<li>Create a new C# script class,&amp;nbsp;<kbd>Player</kbd>:</li>
</ol>
<pre style="padding-left: 30px">   public class Player<br/>    {<br/>        public delegate void HealthChangeAction(float health);<br/>        public static event HealthChangeAction OnHealthChange;<br/> <br/>        private float health;<br/>        const float MIN_HEALTH = 0;<br/>        const float MAX_HEALTH = 1;<br/> <br/>        public Player(float health = 1)<br/>        {<br/>            this.health = health;<br/> <br/>            // ensure initial value published<br/>            PublishHealthChangeEvent();<br/>        } 

<br/>        public float GetHealth()<br/>        {<br/>            return this.health;<br/>        }<br/> <br/>        public void AddHealth(float amount)<br/>        {<br/>            this.health += amount;<br/>            if (this.health &gt; MAX_HEALTH)<br/>            {<br/>                this.health = MAX_HEALTH;<br/>            }<br/>            PublishHealthChangeEvent();<br/>        }<br/> <br/>        public void ReduceHealth(float amount)<br/>        {<br/>            this.health -= amount;<br/>            if (this.health &lt; MIN_HEALTH)<br/>            {<br/>                this.health = MIN_HEALTH;<br/>            }<br/>            PublishHealthChangeEvent();<br/>        }<br/> <br/>        // event<br/>        private void PublishHealthChangeEvent()<br/>        {<br/>            if (null != OnHealthChange)<br/>                OnHealthChange(this.health);<br/>        }<br/>    } </pre>
<ol start="6">
<li>Create a new C# script class,&amp;nbsp;<kbd>PlayerController</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class PlayerController<br/>     {<br/>         private Player player;<br/> <br/>         public PlayerController()<br/>         {<br/>             player = new Player();<br/>         }<br/> <br/>         public void AddToHealth()<br/>         {<br/>             player.AddHealth(0.5f);<br/>         }<br/> <br/>         public void ReduceHealth()<br/>         {<br/>             player.ReduceHealth(0.1f);<br/>         }<br/>     } </pre>
<ol start="7">
<li>Create a new C# script class,&amp;nbsp;<kbd>HealthBarDisplay</kbd>, and add an instance object as a component to <kbd>Image-health-bar-filler</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/> <br/>     public class HealthBarDisplay : MonoBehaviour<br/>     {<br/>         private Image healthMeterFiller;<br/> <br/>         private void Start()<br/>         {<br/>             healthMeterFiller = GetComponent&lt;Image&gt;();<br/>         }<br/> <br/>         private void OnEnable()<br/>         {<br/>             Player.OnHealthChange += UpdateHealthBar;<br/>         }<br/> <br/>         private void OnDisable()<br/>         {<br/>             Player.OnHealthChange -= UpdateHealthBar;<br/>         }<br/> <br/>         public void UpdateHealthBar(float health)<br/>         {<br/>             healthMeterFiller.fillAmount = health;<br/>         }<br/>     } </pre>
<ol start="8">
<li>Create a new C# script class,&amp;nbsp;<kbd>HealthChangeLogger</kbd>:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class HealthChangeLogger<br/>     {<br/>         public HealthChangeLogger()<br/>         {<br/>             Player.OnHealthChange += LogNewHealth;<br/>         }<br/> <br/>         ~HealthChangeLogger()<br/>         {<br/>             Player.OnHealthChange -= LogNewHealth;<br/>         }<br/> <br/>         public void LogNewHealth(float health)<br/>         {<br/>             // 1 decimal place<br/>             string healthAsString = health.ToString("0.0");<br/>             Debug.Log("health = " + healthAsString);<br/>         }<br/>     } </pre>
<ol start="9">
<li>Add the following <kbd>PlayerManager</kbd> C# script class&amp;nbsp;to the Main Camera:</li>
</ol>
<pre style="padding-left: 30px">    using UnityEngine;<br/> <br/>     public class PlayerManager : MonoBehaviour<br/>     {<br/>         private PlayerController playerController;<br/>         private HealthChangeLogger healthChangeLogger;<br/> <br/>         void Start()<br/>         {<br/>             playerController = new PlayerController();<br/>             healthChangeLogger = new HealthChangeLogger();<br/>         }<br/> <br/>         void Update()<br/>         {<br/>             if (Input.GetKeyDown("up"))<br/>                 playerController.AddToHealth();<br/> <br/>             if (Input.GetKeyDown("down"))<br/>                 playerController.ReduceHealth();<br/>         }<br/>     } </pre>
<ol start="10">
<li>Run the game. Pressing the Up/Down arrow keys should raise/lower the player's health, which should be confimed by the meter fill image, and in the <kbd>Debug.Log()</kbd> messages in the <strong>Console</strong>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You were provided with two&amp;nbsp;<strong>UI Images</strong>:&amp;nbsp;one is a health bar outline (red heart and a black outline), the second is the filler image—to show dark blue to light blue to green, for weak to strong health values.</p>
<p class="mce-root"/>
<p>You set the Image Type of Image-health-bar-filler to be Filled, and that it is to be filled Horizontally (left to right). Therefore, the fillAmount property of a UI Image determines how much of this filler image is displayed to the user (from <kbd>0.0</kbd> to <kbd>1.0</kbd>).</p>
<p>The <kbd>PlayerManager</kbd>&amp;nbsp;script class is a manager script that initializes the&amp;nbsp;<kbd>PlayerController</kbd> and <kbd>HealthChangeLogger</kbd> objects, and also allows the user to change the health of the Player by pressing the Up and Down arrow keys (simulating healing/damage during a game). Via the <kbd>Update()</kbd> method, each Up/Down arrow key press invokes the <kbd>PlayerController</kbd> methods:&amp;nbsp;<kbd>AddToHealth()</kbd> and <kbd>ReducedHealth()</kbd>.</p>
<p>The <kbd>PlayerController</kbd>&amp;nbsp;script class creates a <kbd>PlayerModel</kbd> object in its constructor. It has two other methods, <kbd>AddToHealth()</kbd> and <kbd>ReducedHealth()</kbd>, that add to/reduce the health of the <kbd>PlayerModel</kbd> object by <kbd>+0.5</kbd> and <kbd>-0.1</kbd>, respectively.</p>
<p>The <kbd>PlayerModel</kbd>&amp;nbsp;script class manages values for <kbd>Player</kbd> health, and uses delegates and events to publish health changes to any listening <strong>View</strong> classes. When a new object is created, the health property is initialized, and a health-change event is published to all listening objects. Likewise, when the <kbd>AddHealth(...)</kbd> and <kbd>ReduceHealth(...)</kbd> methods are invoked with a value, the value of the health is changed, and the health-change event is published to all listening objects. The&amp;nbsp;<kbd>OnHealthChange</kbd>&amp;nbsp;event is visible to other objects as a static public event. The&amp;nbsp;<kbd>PublishHealthChangeEvent()</kbd>&amp;nbsp;method publishes the new value of health by invoking all listening <kbd>OnHealthChange(...)</kbd> methods.</p>
<p>There are two View classes that register to listen for <kbd>Player.OnHealthChange(...)</kbd> events:</p>
<ul>
<li><kbd>HealthBarDisplay</kbd>: Updates&amp;nbsp;<kbd>fillAmount</kbd> for a UI Image for each new health value received</li>
<li><kbd>HealthChangeLogger</kbd>: Prints messages about the new <kbd>Player health</kbd> value received to the Debug.Log file</li>
</ul>
<p>As can be seen, each of the Model/View/Controller classes is quite small and simple, and each has their own, well-defined responsibilities. It would be easy to add another kind of health-change event listener, perhaps to play a sound, without having to change any code in any of these existing classes. Likewise, it would be straightforward to add a new property to our <kbd>PlayerModel</kbd> (perhaps a score or inventory value of stars collected, and then add another public static event for score/inventory changes to be published to subscribed listening views).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Only&amp;nbsp;<kbd>PlayerManager</kbd> is a MonoBehaviour. One of the advantages of this MVC&amp;nbsp;architecture is that each of these components becomes much easier to unit-test in isolation. A version of this recipe is used as an example in the&amp;nbsp;<em>State Design Pattern</em> <em>PlayMode and Unit Testing a health bar with events, logging, and exceptions</em>&amp;nbsp;recipe in <a href="">Chapter 19</a>, <em>Automated Testing</em>&amp;nbsp;.</li>
</ul>


            

            
        
    </body></html>