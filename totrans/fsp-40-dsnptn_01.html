<html><head></head><body>
<div><div><div><div><h1 class="title"><a id="ch01"/>
 Chapter 1. Begin Thinking Functionally</h1>
</div>
</div>
</div>
<div><blockquote class="blockquote">
<p>

<em>A man with a chainsaw enters a hardware shop and says to the assistant: "Two weeks ago, you told me this thing would allow me to chop down 30 trees in an hour. But I can only manage one tree. I want to return this for a refund". The assistant says "let me see" and starts the chainsaw. The visitor jumps back screaming "What's that noise?!"-
<em>An old joke</em>

</em>

</p>
</blockquote>
</div>
<p>The joke opening my narrative is very relevant to the subject of this chapter: in order to achieve the benefits expected from the use of any tool, you should know how to use that tool the right way. Moreover, an advanced tool used in a wrong manner may be even less productive than the corresponding simple one used the right way. A hammer outperforms a microscope when it comes to nailing wooden boards together.</p>
<p>
<a class="link" title="Chapter 1. Begin Thinking Functionally" href="text00015.html#page">Chapter 1</a>
 , 
<em>Begin Thinking Functionally</em>

 , should help you develop a manner of solving day-to-day software engineering problems that are usually associated with the functional paradigm. This means presenting the solution by verbs rather than nouns, avoiding the use of mutable entities to carry states, avoiding relying upon side-effects, and minimizing the amount of moving parts in the code.</p>
<p>In this chapter, we will cover the following topics:</p>
<div><ul class="itemizedlist">
<li class="listitem">The multi-paradigm nature of F#</li>
<li class="listitem">A comparison of F# paradigms by solving the sample problem applying:<div><ul class="itemizedlist">
<li class="listitem">An imperative monolithic solution</li>
<li class="listitem">An object-oriented solution</li>
<li class="listitem">A functional solution</li>
</ul>
</div>
</li>
<li class="listitem">Properties of the functional paradigm</li>
</ul>
</div>
<p>I will wrap up this chapter with a list of key concepts to retain and recognize, as well as skills to reuse in your functional solutions.</p>
<div><div><div><div><h1 class="title" id="toc_1"><a id="ch01lvl1sec7"/>
 Relationship between F# and programming paradigms</h1>
</div>
</div>
</div>
<p>This chapter, as well as the other chapters, will teach you how to look at any given software problem from the functional paradigm angle. This view may differ significantly from paradigmatic views that you may have already developed while practising other programming approches. This assumption of the required paradigmatic shift is a much anticipated scenario, taking into consideration the factor of the programming language popularity of the so called 
<strong>TIOBE</strong>

 
<strong>Programming Community index</strong>

  (<a class="ulink" href="http://www.tiobe.com/tiobe_index?page=index">http://www.tiobe.com/tiobe_index?page=index</a>
 ), which can be considered an indicator of the popularity of programming languages.</p>
<p>At the time of this writing (February 2016):</p>
<div><ul class="itemizedlist">
<li class="listitem">The winning Rank #1 of TIOBE index is held by the Java programming language, which is strongly associated with the object-oriented programming paradigm</li>
<li class="listitem">Rank #2 belongs to the C programming language, which can be considered representing as the traditional imperative procedural programming paradigm</li>
<li class="listitem">Programming languages associated with the functional programming paradigm make it into the TIOBE index ranks only for the rank range of 21 to 50, where F# carries modest Rank #36</li>
</ul>
</div>
<p>Nevertheless, if you've managed to read upto this point, I can safely assume that your interest in F# is not driven by its mere popularity, which, in turn, is driven by factors that do not belong to the scope of this book. For me, the bearer of an advanced degree in applied math and computer science, engineering program code within the F# ecosystem carries these intangible aesthetic qualities similar to ones of exploring a beautiful solution of a math problem or from analyzing a great chess play.</p>
<p>Talking seriously, I personally value most of the functional paradigm benefits of the functional code readability and maintainability. The same qualities of a typical monolithic imperative C code might be quite poor. However, are these code qualities automatically granted for anyone who has grasped mere F# syntax? Certainly not.</p>
<p>In addition to learning the F# syntax, the preceding point means acquiring certain skills in order to use this programming language in an idiomatic manner. F# is a multi-paradigm programming language indeed. It allows programmers to entertain many programming paradigms. The functional manner of laying out the program code can be used side by side with the imperative monolithic programming manner, or an object-oriented approach may surface when interoperability with the environment is important . Nevertheless, F# makes a claim of being a functional-first programming language. This means that the congenial programming paradigm for F# is the functional one; the language will bring to the table most benefits if it's used in a functional manner, in which case:</p>
<div><blockquote class="blockquote">
<p>

<em>"it empowers users and organizations to tackle complex computing problems with simple, maintainable and robust code"-(<a class="ulink" href="http://fsharp.org/">http://fsharp.org/</a>
 ).</em>

</p>
</blockquote>
</div>
<p>You may wonder what, exactly, idiomatic usage means and whether it will be possible to always use it. The best way of illustrating idiomatic F# use would be by performing a comparative study of correspondent coding examples. Let me take an arbitrary, simple problem and solve it by sticking to imperative, then to object-oriented, and finally, to functional paradigms. Then, I am going to compare solutions to highlight functional approach features. In order to make this comparison absolutely fair, the programming language of implementation in all three cases is going to be F#.</p>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch01lvl1sec8"/>
 A sample problem to solve</h1>
</div>
</div>
</div>
<p>I will use as a problem for the purpose the slightly amended version of Problem 8 of Project Euler (<a class="ulink" href="https://projecteuler.net/problem=8">https://projecteuler.net/problem=8</a>
 ):</p>
<pre class="programlisting">The four adjacent digits (9989) being highlighted in the 1000-digit numbers that have the greatest product are as following: 
9 x 9 x 8 x 9 = 5832. 
 
73167176531330624919225119674426574742355349194934 
96983520312774506326239578318016984801869478851843 
85861560789112949495459501737958331952853208805511 
12540698747158523863050715693290963295227443043557 
66896648950445244523161731856403098711121722383113 
62229893423380308135336276614282806444486645238749 
30358907296290491560440772390713810515859307960866 
70172427121883998797908792274921901699720888093776 
65727333001053367881220235421809751254540594752243 
52584907711670556013604839586446706324415722155397 
53697817977846174064955149290862569321978468622482 
83972241375657056057490261407972968652414535100474 
821663704844031
<strong>9989</strong>



0008895243450658541227588666881 
16427171479924442928230863465674813919123162824586 
17866458359124566529476545682848912883142607690042 
24219022671055626321111109370544217506941658960408 
07198403850962455444362981230987879927244284909188 
84580156166097919133875499200524063689912560717606 
05886116467109405077541002256983155200055935729725 
71636269561882670428252483600823257530420752963450 
 
Find the five adjacent digits in the same 1000-digit number that has the greatest product. What is the value of this product? 
</pre>
<div><div><div><div><h2 class="title" id="toc_1"><a id="ch01lvl2sec5"/>
 An imperative monolithic solution</h2>
</div>
</div>
</div>
<p>Let me begin by approaching the solution in a straightforward monolithic imperative manner: convert the 1000-character string representing the number into a character array, and then convert it into a cycle across all 996 groups of the five adjacent digits, calculating the digit product of each group and maintaining the current maximum. The final value of the current maximum will be the solution; it's that simple.</p>
<p>In order to remove the input number from the way, let's put it into a separate source code file, <code class="literal">HugeNumber.fs</code>
 , pulled to the solution scripts with the F# <code class="literal">#load</code>
 directive. The F# source file <code class="literal">HugeNumber.fs</code>
 is shown as follows:</p>
<pre class="programlisting">[&lt;AutoOpen&gt;] 
module HugeNumber 
let hugeNumber = 
    "73167176531330624919225119674426574742355349194934\ 
    96983520312774506326239578318016984801869478851843\ 
    85861560789112949495459501737958331952853208805511\ 
    12540698747158523863050715693290963295227443043557\ 
    66896648950445244523161731856403098711121722383113\ 
    62229893423380308135336276614282806444486645238749\ 
    30358907296290491560440772390713810515859307960866\ 
    70172427121883998797908792274921901699720888093776\ 
    65727333001053367881220235421809751254540594752243\ 
    52584907711670556013604839586446706324415722155397\ 
    53697817977846174064955149290862569321978468622482\ 
    83972241375657056057490261407972968652414535100474\ 
    82166370484403199890008895243450658541227588666881\ 
    16427171479924442928230863465674813919123162824586\ 
    17866458359124566529476545682848912883142607690042\ 
    24219022671055626321111109370544217506941658960408\ 
    07198403850962455444362981230987879927244284909188\ 
    84580156166097919133875499200524063689912560717606\ 
    05886116467109405077541002256983155200055935729725\ 
 71636269561882670428252483600823257530420752963450" 
</pre>
<p>This file is going to be used by all variants of the problem solutions.</p>
<p>Then, F# script <code class="literal">Ch1_1.fsx</code>
 implementing an imperative solution will look as follows:</p>
<pre class="programlisting">// Imperative monolithic solution a-la C/C++ 
#load "HugeNumber.fs" 
let number = hugeNumber.ToCharArray() 
let mutable maxProduct = 0 
let charZero = int('0') 
for i in 0..995 do 
  let mutable currentProduct = 1 
for j in 0..4 do 
  currentProduct &lt;- currentProduct * (int(number.[i + j]) -      charZero) 
if maxProduct &lt; currentProduct then 
  maxProduct &lt;- currentProduct 
printfn "%s %d" "Imperative solution:" maxProduct 
</pre>
<p>The line <code class="literal">#load "HugeNumber.fs"</code>
 brings a <code class="literal">string</code>
 value <code class="literal">HugeNumber.hugeNumber</code>
 from the external code file <code class="literal">HugeNumber.fs</code>
 into the scope of this script.</p>
<p>The next line, <code class="literal">let number = hugeNumber.ToCharArray()</code>
 converts this <code class="literal">string</code>
 value into an array of 1000 individual characters, each representing a single digit.</p>
<p>The next line, <code class="literal">let mutable maxProduct = 0</code>
 introduces a mutable <code class="literal">int</code>
 value used to carry the running tally of a maximal product of five adjacent digits.</p>
<p>The following line <code class="literal">let charZero = int('0')</code>
 is just a helper value used for converting a character code of a digit into an actual <code class="literal">int</code>
 value in the range of 0 to 9. It represents integer <code class="literal">48</code>
 indeed, not <code class="literal">0</code>
 as some of you may expect. But given <code class="literal">char</code>
 values of decimal digits <code class="literal">'0'</code>
 to <code class="literal">'9'</code>
 all have adjacent values after being converted to <code class="literal">int</code>
 , the simple subtraction of <code class="literal">charZero</code>
 from the result of converting a <code class="literal">char</code>
 digit <code class="literal">x</code>
 into an <code class="literal">int</code>
 will yield exactly <code class="literal">x</code>
 as an integer. More details on this matter will be given as we proceed further in this chapter.</p>
<p>The following seven lines of F# code are the gist of implementation:</p>
<pre class="programlisting">for i in 0..995 do 
  let mutable currentProduct = 1 
for j in 0..4 do 
  currentProduct &lt;- currentProduct * (int(number.[i + j]) -     charZero) 
if maxProduct &lt; currentProduct then 
  maxProduct &lt;- currentProduct 
</pre>
<p>This part of the script performs the following actions:</p>
<div><ul class="itemizedlist">
<li class="listitem">The outer numerical <code class="literal">for</code>
 loop traverses the number array from the leftmost to the rightmost chunk of the five adjacent character digits, keeping the sequential number of the chunk (<code class="literal">0,1,2,...,955</code>
 ) in the counter value <code class="literal">i</code>
 .</li>
<li class="listitem">The binding <code class="literal">let mutable currentProduct = 1</code>
 provides a mutable placeholder for the product of the current chunk's digits.</li>
<li class="listitem">The inner numerical <code class="literal">for</code>
 loop traverses a subarray of length 5, calculating <code class="literal">currentProduct</code>
 by multiplying the intermediary result by the <code class="literal">int</code>
 value of each digit having sequential number <code class="literal">j</code>
 using the expression <code class="literal">(int(number.[i + j]) - charZero)</code>
 . For example, if a current digit is <code class="literal">5</code>
 , then <code class="literal">int('5') - int('0') = 5</code>
 .</li>
<li class="listitem">An <code class="literal">if</code>
 statement closing the outer loop ensures that <code class="literal">maxProduct</code>
 always contains the maximal product of already traversed chunks; hence, when the loop completes iterating, <code class="literal">maxProduct</code>
 contains the sought value.</li>
</ul>
</div>
<p>Finally, the line <code class="literal">printfn "%s %d" "Imperative solution:" maxProduct</code>
 outputs the final result to the system console.</p>
<p>Running the script in its entirety with 
<strong>F# Interactive</strong>

 (
<strong>FSI</strong>

 ) yields the following solution:</p>
<div><img src="img/Image00001.jpg" alt="An imperative monolithic solution"/>
<div><p>Running an imperative solution script in F# Interactive</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>There are a few points that I would like to accentuate prior to covering other approaches to solving the problem as follows:</p>
<div><ul class="itemizedlist">
<li class="listitem">The solution represents detailed "how-to" instructions</li>
<li class="listitem">The solution has been expressed in terms of low-level computer notions, such as statements, loops, and global values</li>
<li class="listitem">Values change along the execution, representing the changing state</li>
<li class="listitem">The solution code does not look structured, it just flows</li>
</ul>
</div>
</div>
<div><div><div><div><h2 class="title" id="toc_2"><a id="ch01lvl2sec6"/>
 An object-oriented solution</h2>
</div>
</div>
</div>
<p>Now let me turn to the object-oriented manner of solving the same problem. It is typical for this kind of approach to hide implementation details inside instances of custom classes and manipulate them with the help of their own methods. I will use for this purpose the F# <code class="literal">type</code>
 feature representing the concept of the .NET object type also known as 
<strong>class</strong>

 (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/classes">https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/classes</a>
 ). An object-oriented solution to the problem is present in the following code (script <code class="literal">Ch1_2.fsx</code>
 ):</p>
<pre class="programlisting">// Object-oriented solution a-la C# with Iterator pattern 
#load "HugeNumber.fs" 
 
open System 
open System.Collections.Generic 
 
type OfDigits(digits: char[]) = 
    let mutable product = 1 
    do 
        if digits.Length &gt; 9 then // (9 ** 10) &gt; Int32.MaxValue 
            raise &lt;| ArgumentOutOfRangeException 
              ("Constrained to max 9 digit numbers") 
        let charZero = int '0' in 
        for d in digits do 
            product &lt;- product * ((int d) - charZero) 
        member this.Product 
            with get() = product 
 
type SequenceOfDigits(digits: string, itemLen: int) = 
    let collection: OfDigits[] = 
       Array.zeroCreate(digits.Length -itemLen + 1) 
    do 
      for i in 0 .. digits.Length - itemLen do 
        collection.[i] &lt;- OfDigits(digits.[i..
           (i+itemLen-1)].ToCharArray()) 
    member this.GetEnumerator() = 
        (collection :&gt; IEnumerable&lt;OfDigits&gt;).GetEnumerator() 
 
let mutable maxProduct = 1 
for item in SequenceOfDigits(hugeNumber,5) do 
    maxProduct &lt;- max maxProduct item.Product 
 
printfn "%s %d" "Object-oriented solution:" maxProduct 
</pre>
<p>This solution is going to manipulate the objects of two classes. The first class named <code class="literal">OfDigits</code>
 represents the entity of the digit sequence, the product of which is the subject of our interest. An instance of <code class="literal">OfDigits</code>
 can be created from an array of a certain size of <code class="literal">char</code>
 elements carrying digits used as an argument to the <code class="literal">OfDigits</code>
 type constructor <code class="literal">OfDigits(digits: char[])</code>
 .</p>
<p>Upon its creation, each instance is associated with the <code class="literal">product</code>
 field representing the product of its digits. There is a reason for it not being possible to initialize <code class="literal">product</code>
 at once: in order to be representable as a positive integer value, the product can be constituted of nine digits or fewer (because the product of 10 or more 9 would exceed the maximum 32-bit <code class="literal">int</code>
 value 2147483647). In order to validate this, <code class="literal">product</code>
 is kept <code class="literal">mutable</code>
 and initially gets a value of <code class="literal">1</code>
 as given in the following line:</p>
<pre class="programlisting">let mutable product = 1 
</pre>
<p>Then, after the length validity check, the <code class="literal">OfDigits</code>
 constructor provides the genuine value to the field by performing the calculation:</p>
<pre class="programlisting">let charZero = int '0' in 
for d in digits do 
  product &lt;- product * ((int d) - charZero) 
</pre>
<p>This value can be accessed via the instance property, <code class="literal">Product</code>
 as shown in the following line:</p>
<pre class="programlisting">member this.Product with get() = product 
</pre>
<p>The another class required to implement the object-oriented solution represents the entity taking a string of digits of arbitrary length and represents it as a generic collection of type <code class="literal">OfDigits</code>
 , allowing enumeration in order to traverse it and find a member with the maximum <code class="literal">Product</code>
 property.</p>
<p>For this purpose, the class named <code class="literal">SequenceOfDigits</code>
 has been equipped with a constructor parameterized by the digits string carrying the input number's digits and the <code class="literal">itemLen</code>
 length of individual <code class="literal">OfDigits</code>
 instance arguments. During the <code class="literal">SequenceOfDigits</code>
 instance construction, all <code class="literal">OfDigits</code>
 instances are created as elements of the collection field array. The <code class="literal">GetEnumerator()</code>
 instance method allows you to enumerate this array by upcasting to the <code class="literal">System.Collections.Generic.IEnumerable&lt;OfDigits&gt;</code>
 interface type and delegating the call to the <code class="literal">GetEnumerator()</code>
 method of the latter in the following instance method definition:</p>
<pre class="programlisting">member this.GetEnumerator() =  (collection :&gt; IEnumerable&lt;OfDigits&gt;).GetEnumerator() 
</pre>
<p>Having the preceding two classes at your disposal makes composing the solution of the original problem rather simple: you construct a <code class="literal">SequenceOfDigits</code>
 instance of five digit <code class="literal">OfDigits</code>
 elements off <code class="literal">hugeNumber</code>
 and traverse it with the help of the <code class="literal">for...in</code>
 cycle, maintaining the maximum product tally similarly to the imperative solution as shown in the following code:</p>
<pre class="programlisting">let mutable maxProduct = 1 
for item in SequenceOfDigits(hugeNumber,5)
  do  maxProduct &lt;- max maxProduct item.Product 
</pre>
<p>In the end, place the result on the system console. Running the script in its entirety with F# FSI yields the result of object-oriented solution as shown in the following screenshot:</p>
<div><img src="img/Image00002.jpg" alt="An object-oriented solution"/>
<div><p>Running object-oriented solution script in F# Interactive</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>For those of you familiar with the object-oriented manner of approaching problem solutions, you may anticipate that the second solution rather differs from the first one:</p>
<div><ul class="itemizedlist">
<li class="listitem">It is distinctively structured, with the segregation of definitions of pertinent classes from the usage of these classes</li>
<li class="listitem">Classes hide details of implementation, allowing usage only through exposed properties and methods</li>
<li class="listitem">The solution follows one of the well-known design patterns, namely the 
<strong>iterator</strong>

 pattern</li>
<li class="listitem">The amount of effort required for scaffolding substantially exceeds the effort required for the solution per se</li>
</ul>
</div>
</div>
<div><div><div><div><h2 class="title" id="toc_3"><a id="ch01lvl2sec7"/>
 A functional solution</h2>
</div>
</div>
</div>
<p>Finally, let me turn to the solution manner that this book targets, namely, functional. Let's think of it as a series of data transformations. Let's look at it in a backward direction, from the sought solution back to the input string of digits as follows:</p>
<div><ul class="itemizedlist">
<li class="listitem">The sought solution is the result of the <code class="literal">max</code>
 aggregate function application to the sequence of all products of five digit sequences.</li>
<li class="listitem">The sequence of all five digit sequences products is the result of the function application that maps each five digit sequence instance from the sequence of such sequences to the reduce of five digit sequence digits to their product.</li>
<li class="listitem">The sequence of all five digit sequences can be produced from the sequence of all initial digits by applying the F# core library windowing function <code class="literal">Seq.windowed&lt;'T&gt;</code>
 to the latter. In other words, this means taking a copy sequence of the first five digits from the left-hand side, placing this sequence in the output, shifting to the right of the source sequence by one digit, taking the first five digit copy and putting them after the first group in the output, shifting to the right by one digit of the source again, taking the first five digits, and so on, until there is no more possibility of taking the first five digits from the source. The output sequence of sequences is the sought function application result.</li>
<li class="listitem">Finally, the sequence of all initial digits is simply the initial string split by single digits, each converted into correspondent <code class="literal">int</code>
 from 0 to 9.</li>
</ul>
</div>
<p>Each preceding step describes what transformation I want to apply to the single input argument in order to get the single result. Each next step takes the result of the previous step and treats it as its own input.</p>
<p>Let me show you how I usually derive the working code from the data transformation sketch similar to the preceding one with the help of the 
<strong>Read-Evaluate-Print-Loop</strong>

 (
<strong>REPL</strong>

 ) mode provided by FSI and the shrinking task dimension. The process of sequential progress toward the solution is shown in 
<em>Fig.1.3</em>

 , where I gradually start adding transformation steps to reproduce the data transformation process sketched earlier for a string consisting of just 10 digits <code class="literal">"0918273645"</code>
 by following these steps:</p>
<div><ol class="orderedlist arabic">
<li class="listitem">The input string is piped forward with the F# operator of the same name 
<strong>pipe-forward </strong>

 <code class="literal">|&gt;</code>
 as the second argument of <code class="literal">Seq.map string</code>
 . The result is the sequence of 10 strings, each representing a single digit.</li>
<li class="listitem">The result of step 1 is piped forward with <code class="literal">|&gt;</code>
 as the second argument of <code class="literal">Seq.map int</code>
 . Now, the result is also the sequence, but it is a sequence of 10 <code class="literal">int</code>
 numbers, each representing the single digit.</li>
<li class="listitem">The result of step 2 is piped forward with <code class="literal">|&gt;</code>
 as the second argument of <code class="literal">Seq.windowed 5</code>
 . The result is the sequence of six arrays, each representing five sequentially taken digits of the result of step 2, each time shifting the beginning of the sequence to the right by one position.</li>
<li class="listitem">The result of step 3 is piped forward with <code class="literal">|&gt;</code>
 as the second argument of <code class="literal">Seq.map (Seq.reduce (*))</code>
 . The first argument is the higher-order function <code class="literal">Seq.reduce</code>
 converting its argument, which is an array of five numbers to the product of these numbers with the help of the multiplication operator (<code class="literal">*</code>
 ). The result of this transformation step is just six numbers, each representing the product of the elements of the corresponding digit array.</li>
<li class="listitem">The result of step 5 is piped into the <code class="literal">Seq.max</code>
 aggregate function, which produces the sought maximal product that equals <code class="literal">2520(7 * 3 * 6 * 4 * 5)w</code>
 :</li>
</ol>
<div></div>
<div><img src="img/Image00003.jpg" alt="A functional solution"/>
<div><p>The incremental process of getting to the smaller problem solution with REPL</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Now, after becoming pretty confident that the thought-out solution is good, I can combine the preceding steps 1 to 5 with just another F# 
<strong>function composition</strong>

 operator <code class="literal">&gt;&gt;</code>
 , which just glues the result of the function to the left as an argument of the function to the right into a very compact F# script provided in the file <code class="literal">Ch1_3.fsx</code>
 as follows:</p>
<pre class="programlisting">#load "HugeNumber.fs" 
hugeNumber |&gt; (Seq.map (string &gt;&gt; int) &gt;&gt; Seq.windowed 5 
&gt;&gt; Seq.map (Seq.reduce (*)) &gt;&gt; Seq.max 
&gt;&gt; printfn "%s %d" "Functional solution:") 
</pre>
<p>The only difference between the preceding complete problem solution code and the smaller problem solution that I was running through a few REPL steps is the input value dimension. The final code uses the same 1000 digit <code class="literal">hugeNumber</code>
 taken from the source file <code class="literal">HugeNumber.fs</code>
 in the same manner as the imperative and object-oriented solutions did previously.</p>
<p>Running the script in its entirety with FSI yields the functional solution result shown in the following figure:</p>
<div><img src="img/Image00004.jpg" alt="A functional solution"/>
<div><p>Running the functional solution script in F# Interactive</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>The code quality achieved by the functional solution, despite somewhat lengthy accompanying comments, is quite outstanding:</p>
<div><ul class="itemizedlist">
<li class="listitem">It does not utilize even a single value carrying an intermediate state</li>
<li class="listitem">It contains just one arithmetic multiplication operator absolutely needed for product calculation</li>
<li class="listitem">It is extremely succinct</li>
<li class="listitem">It almost literally reflects the original "what to do" considerations</li>
<li class="listitem">It uses solely half a dozen core F# library functions combined in a certain way, and we may strongly believe that the implementations of these functions are error-free and performant</li>
</ul>
</div>
<p>The preceding bullet points reflect pretty much all the properties typical for an idiomatic functional solution of a small-scale problem. Now I'm going to decipher these properties one by one.</p>
</div>
</div>


<div><div><div><div><h1 class="title"><a id="ch01lvl1sec9"/>
 Immutability of participating data entities</h1>
</div>
</div>
</div>
<p>The positive qualities of the approach of not using mutable program entities are well known:</p>
<div><ul class="itemizedlist">
<li class="listitem">Given the right state upon construction the immutable cannot be invalidated it during its whole lifetime</li>
<li class="listitem">Immutable entities are easy to test</li>
<li class="listitem">They do not require cloning or copy constructors</li>
<li class="listitem">Immutable entities are automatically thread-safe</li>
</ul>
</div>
<p>I must note that F# is not 100% strict about using immutable entities. As you may have already noticed, I used values, changing the state in my imperative and object-oriented solutions earlier. But the language requires the programmer to make an extra effort to introduce a changeable state (with the <code class="literal">mutable</code>
 modifier to <code class="literal">let</code>
  binding or via <code class="literal">ref</code>
 cells, although F# 4.0 pretty much eliminates the need for the latter).</p>
<p>Also, the majority of data structures introduced by the language are also immutable, which means that a typical data transformation produces a new immutable instance of a data structure from the existing data structure. This consideration requires a certain caution from programmers when dealing with bulk in-memory instances, but as my experience has taught me, developers get used to this feature easily.</p>
</div>


<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>
 Thinking in verbs rather than nouns</h1>
</div>
</div>
</div>
<p>Considering the process of data transformations in terms of verbs rather than nouns is very typical for a functional approach as functions are intuitively associated in our brains with actions, not objects. You may notice the single data item in the script <code class="literal">Ch1_3.fsx</code>
 , which is <code class="literal">hugeNumber</code>
 . The rest are few library functions combined in a certain manner, which transform the <code class="literal">hugeNumber</code>
 data item into a line of the console output. This manner of function combination allows persons reading this code to completely ignore intermediate results of the data transformations at each point where the operator &gt;&gt; occurs in the expression.</p>
<p>The less obvious corollary of this combination is the opportunity for the F# compiler to perform a so-called fusion or the manner of code optimization by merging together some adjacent data transformation steps. For example, when adjacent steps are fused together, the amount of data traversals may decrease.</p>
</div>


<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>
 "What" prevailing over "how"</h1>
</div>
</div>
</div>
<p>This property of the functional solution mental process is easier to demonstrate with an example. I paraphrase here the great one from the early days of F# that's been used by several insiders previously. Imagine yourself in Starbucks for Caffè Americano.</p>
<p>The "how" approach would be to give detailed instructions such as:</p>
<div><ol class="orderedlist arabic">
<li class="listitem">Take a roasted coffee</li>
<li class="listitem">Brew two espresso shots</li>
<li class="listitem">Top them with hot water to produce a layer of crema</li>
<li class="listitem">Put it into a cap of 12 oz size</li>
</ol>
<div></div>
<p>The "what" approach would be to just ask "May I have a tall Caffè Americano?".</p>
<p>The second approach is evidently much more succinct and minimizes an opportunity of getting a result that deviates from the desired one. If you revisit now our three preceding solutions you should spot this property there.</p>
</div>


<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>
 Generalization over specialization</h1>
</div>
</div>
</div>
<p>Another outstanding feature of the functional paradigm is generalization. By this, I mean preferring a general solution over a concrete one, when a concrete problem can be solved by applying a general solution that is accordingly parameterized. Let's turn to our sample problem for evidence of generalization. Adjusting the functional solution to a different length of digit sequences (for example, 8 instead of 5), another math operation on the group (for example, the sum instead of the product), another aggregation property (for example, minimum instead of maximum) are mere changes of parameter values for the correspondent functions. A comparison of how much the code changes will be required in case of the other approaches, which I leave for you as an exercise.</p>
</div>


<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>
 Minimizing moving parts over hiding them</h1>
</div>
</div>
</div>
<p>This property is specifically related to a functional approach in comparison with an object-oriented one. Recall F# script file <code class="literal">Ch1_2.fsx</code>
 , which involved custom classes encapsulating details of implementation and exposing them outside the constructor, the iterator, and the aggregated property. In comparison with the object-oriented approach, the functional approach is flat and does not hide anything; it just combines some known parts.</p>
</div>


<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>
 Reduction to known parts over producing custom parts</h1>
</div>
</div>
</div>
<p>One of the amazing properties of a functional paradigm differentiating it from the others is the limited need for producing custom parts at the level of manipulating data structures. Usually, functional programming newbies tend to implement their own functions for each case of data transformation. This infantile sickness normally ends with finding out from practice that pretty much any transformation upon typical data structures can be expressed as a combination of <code class="literal">filter</code>
 , <code class="literal">map</code>
 , and <code class="literal">fold</code>
 operations. I will devote a substantial amount of contents in relation to this phenomenon.</p>
</div>


<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>
 Lazy over eager data collections</h1>
</div>
</div>
</div>
<p>Let me turn your attention to the comparison of memory consumption of the previously mentioned object-oriented and functional solutions. The object-oriented solution eagerly creates, materializes in computer memory the collection of 996 <code class="literal">OfDigits</code>
 objects; that is, its memory consumption is a linear function of the problem dimensions. In contrast to this approach, the functional solution does not require more than a single instance of <code class="literal">OfDigits</code>
 at any moment of the <code class="literal">max</code>
 aggregation, lazily producing the same 996 objects one by one according to the demand of the <code class="literal">max</code>
 aggregator function, hence having memory consumption that is constant and (almost) independent of the problem dimensions. This is a rather complex quality. If you imagine that the initial condition has suddenly changed and <code class="literal">hugeNumber</code>
 is really huge, then the object-oriented solution may become non-applicable due to the lack of required memory, while the functional solution, being agnostic to this factor, will continue to work. Generalizing this observation, the functional paradigm allows you to solve problems of a bigger scale, rather than taking other approaches by utilizing the lazy manner of data manipulation. The interesting corollary stemming from this approach is the technique of manipulating data sequences of unlimited length that do not require their complete materialization in the memory.</p>
</div>


<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>
 Summary</h1>
</div>
</div>
</div>
<p>The following are the key concepts and the list of skills you should take away after finishing this chapter and strive for absorbing and mastering:</p>
<p>Avoid mutable state and achieve data transformations over immutable values and data structures. Think of programming solutions in terms of verbs rather than nouns. Avoid expressing a solution in highly detailed imperative "how" statements; use the "what to do" approach instead. Generalize: prefer a general parameterized solution to a concrete one. Strive to minimize the moving parts of your solution instead of hiding these moving parts into classes. Try expressing solutions by a few well-known facilities instead of delving into producing custom ones. When appropriate, prefer lazy data collections (sequences) over eager ones.</p>
<p>This process of mastering the functional manner of thinking may be framed around the following three Rs - 
<strong>Retain</strong>

 , 
<strong>Recognize</strong>

 , and 
<strong>Reuse</strong>

 . The sooner you learn to recognize idiomatic functional design patterns which I'm going to cover with a great amount of detail in this book and the sooner you reuse these patterns again and again in your day-to-day coding activities, the better functional programmer you will become.</p>
<p>In the upcoming chapters, I will walk you over the many idiomatic uses of F# in certain development situations. These repeated usages will represent genuine functional programming design patterns. Please keep in mind that many of these patterns only to a certain extent correlate with traditional 
<strong>object-oriented design patterns</strong>

 (<a class="ulink" href="https://en.wikipedia.org/wiki/Design_Patterns">https://en.wikipedia.org/wiki/Design_Patterns</a>
 ), as well as other architecture design patterns of 
<strong>software engineering</strong>

 (<a class="ulink" href="http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420">http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420</a>
 ).</p>
<p>In the next chapter, I'll give you a 360-degree high-level view of the F# language features and parts with their origins and evolvement.</p>
</div>
</body></html>