<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-173"><a id="_idTextAnchor182"/>11</h1>
<h1 id="_idParaDest-174"><a id="_idTextAnchor183"/>Creating MVVM-Friendly Controls</h1>
<p>Up to this point, we’ve navigated through a wide spectrum of topics in MVVM and .NET MAUI – from the fundamental design pattern to data binding, navigation, and even working with remote data. Now, let’s dig into another important topic – <strong class="bold">custom controls</strong>.</p>
<p>Sometimes, the built-in controls might fall short in catering to specific user interface requirements or unique design elements. As a consequence, you’ll need to create your own by combining individual UI elements into a single, more effective unit. Making these elements MVVM-friendly and reusable throughout your app is our goal.</p>
<p>In this chapter, we’ll focus on the following:</p>
<ul>
<li>Building a custom control with bindable properties</li>
<li>Enabling interactions on custom controls</li>
<li>Working with control templates</li>
</ul>
<p>By the end of this chapter, you’ll know how to make custom controls that not only look good but are also easy to manage in an MVVM setup. Ready to dive in?</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor184"/>Technical requirements</h1>
<p>We’ll continue to enhance the <em class="italic">Recipes!</em> app by diving into custom controls and control templates, all designed with an MVVM architecture in mind. To follow along with the code, make sure to visit the GitHub repository at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter11">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter11</a>. The <code>Start</code> folder has the initial code set up to begin this chapter, while the <code>Finish</code> folder contains the completed code for your reference.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor185"/>Building a custom control with bindable properties</h1>
<p>Building a feature-rich application often requires more than just the standard set of UI controls. When you have a<a id="_idIndexMarker746"/> combination of controls appearing together across multiple parts of your application – such as an input field with a list of validation errors or a button that’s always used with an activity indicator – it makes sense to package these into custom controls. These custom, reusable elements not only make the code base more maintainable but also align perfectly with MVVM architecture when made bindable.</p>
<p>The focus of this section is not only to create custom controls but also to make them “bindable,” seamlessly integrating them into our MVVM architecture. By crafting controls that are bindable, you enable straightforward communication with your ViewModel. This is key to ensuring that the UI is always up to date with an application’s data and logic.</p>
<p>So, how do we achieve this?</p>
<p>Over the next few pages, we’ll see how to combine existing controls into a custom, bindable control. We’ll also discuss how to add custom properties and behavior to controls, ensuring they can effortlessly fit into an MVVM-based application architecture.</p>
<p class="callout-heading">Note</p>
<p class="callout">While we will be creating a custom control in XAML throughout this chapter, it’s important to note that everything we do can also be done entirely in code if preferred.</p>
<p>As we dive into creating custom controls with data binding capabilities, it’s important to recall the concept of a binding target, which we covered in <a href="B20941_03.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, <em class="italic">Data Binding Building Blocks in .NET MAUI</em>. In .NET MAUI, a binding target is typically a <code>BindableProperty</code> on a UI element or another <code>BindableObject</code>. To make our custom controls serve as effective binding targets, they need to inherit from <code>BindableObject</code>. Additionally, any properties that we intend to bind must be of type <code>BindableProperty</code>. This ensures that our custom controls will integrate seamlessly into the MVVM data-binding architecture.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor186"/>Implementing FavoriteControl</h2>
<p>In our <em class="italic">Recipes!</em> app, displaying <a id="_idIndexMarker747"/>whether a recipe is marked as a favorite or not is a recurring theme. The “favorite” icon appears across various parts of our app. Each time this icon appears, it behaves the same way – changing colors <a id="_idIndexMarker748"/>when the recipe is marked as a favorite. Instead of repeating the same code everywhere, we can encapsulate this pattern into a reusable <code>FavoriteControl</code>. By doing so, we make our code more maintainable and pave the way for future improvements – such as additional gestures or animations – without needing to alter multiple sections of the code base.</p>
<p>Let’s go ahead and look at the steps needed to create our <code>FavoriteControl</code>:</p>
<ol>
<li>In the <code>Controls</code> folder in the <code>Recipes.Mobile</code> project and select <strong class="bold">Add</strong> | <strong class="bold">New Item…</strong>.</li>
<li>Select <code>FavoriteControl.xaml</code> as the name of the new item. Click <strong class="bold">Add</strong>.</li>
</ol>
<div><div><img alt="Figure 11.1: Select ContentView from the dialog" height="354" src="img/B20941_11_01.jpg" width="984"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1: Select ContentView from the dialog</p>
<p>By following these steps, two new files will be created – <code>FavoriteControl.xaml</code> and its code-behind file, <code>FavoriteControl.xaml.cs</code>, as shown in <em class="italic">Figure 11</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 11.2: Files making up FavoriteControl" height="111" src="img/B20941_11_02.jpg" width="422"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2: Files making up FavoriteControl</p>
<p>The generated <code>FavoriteControl</code> inherits the <code>ContentView</code> class, which itself is a descendant of <code>BindableObject</code>. This allows <code>FavoriteControl</code> to define <code>BindableProperties</code>, which is <a id="_idIndexMarker749"/>essential to make the control bindable. Speaking of which, <code>FavoriteControl</code> should contain a <code>BindableProperty</code> called <code>IsFavoriteProperty</code> and an <code>IsFavorite</code> property of type <code>bool</code>. The following code snippet shows what<a id="_idIndexMarker750"/> this looks like:</p>
<pre class="source-code">
public static readonly BindableProperty IsFavoriteProperty
=
    BindableProperty.Create(nameof(IsFavorite),
        typeof(bool), typeof(FavoriteControl));
public bool IsFavorite
{
    get { return (bool)GetValue(IsFavoriteProperty); }
    set { SetValue(IsFavoriteProperty, value); }
}</pre> <p>Defining a <code>BindableProperty</code> can be confusing or unclear at first. If this concept is still vague, <a href="B20941_03.xhtml#_idTextAnchor051"><em class="italic">Chapter 3</em></a>, <em class="italic">Data Binding Building Blocks in .NET MAUI</em>, covers it in more depth.</p>
<p>With this in place, we can dive into XAML and start working on the visual layer of this <code>FavoriteControl</code>.</p>
<p class="callout-heading">Data binding in a custom control</p>
<p class="callout">When building a custom control, it’s recommended to<a id="_idIndexMarker751"/> design it so that it doesn’t depend on its <code>BindingContext</code>, which it inherits from its parent page or control. Instead of depending on its <code>BindingContext</code>, the custom control should be self-contained and interact directly with its own bindable properties. This approach makes your control more modular and reusable, freeing it from dependencies on any specific ViewModel or data source. Element binding or relative binding is instrumental in achieving this independence. However, it’s worth noting that using data binding within the control is not mandatory. Handling all the logic and value assignments programmatically in the control’s code-behind is also a solid approach. This mostly depends on personal preference.</p>
<p>Let’s have a look at<a id="_idIndexMarker752"/> how to define the control’s appearance<a id="_idIndexMarker753"/> and see how we can efficiently bind to its <code>IsFavorite</code> property:</p>
<ol>
<li>Open the <code>FavoriteControl.xaml</code> file, and add the following <code>local</code> and <code>toolkit</code> XML namespaces and the <code>x:Name</code> attribute:<pre class="source-code">
&lt;ContentView
    x:Class="Recipes.Mobile.Controls.FavoriteControl"
    xmlns="http://schemas.microsoft.com/dotnet/
      2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/
      2009/xaml"
    <strong class="bold">xmlns:local="clr-namespace:</strong>
<strong class="bold">      Recipes.Mobile.Controls"</strong>
<strong class="bold">    xmlns:toolkit="http://schemas.microsoft.com/</strong>
<strong class="bold">      dotnet/2022/maui/toolkit"</strong>
<code>toolkit</code> namespace in place, which refers to the .NET MAUI Community Toolkit, we can add an instance of <code>BoolToObjectConverter</code> to the control’s <code>Resources</code>. This converter can be copied over from <code>RecipesOverviewPage</code> or <code>RecipeDetailPage</code>. The next code block shows what it looks like:<pre class="source-code">
&lt;ContentView.Resources&gt;
    &lt;toolkit:BoolToObjectConverter
        x:Key="isFavoriteToColorConverter"
        x:TypeArguments="Color"
        FalseObject="#E9E9E9E9"
        TrueObject="#FF0000" /&gt;
&lt;/ContentView.Resources&gt;</pre><p class="list-inset">As a reminder, this converter (as it is configured here) will convert a <code>bool</code> value into a color – <code>false</code> will become a color with the hex value of <code>"#E9E9E9E9"</code> while <code>true</code> will be converted to <code>"#FF0000"</code>.</p></li> <li>Next, we can add the <code>Image</code> control to display the <code>"favorite.png"</code> icon. We also want this Image control to <a id="_idIndexMarker754"/>match the dimensions <a id="_idIndexMarker755"/>specified for <code>FavoriteControl</code>. Here’s how to set this up:<pre class="source-code">
&lt;Image
    x:Name="icon"
    HeightRequest="{Binding HeightRequest,
      Source={RelativeSource AncestorType={x:Type
        local:FavoriteControl}}}"
    Source="favorite.png"
    WidthRequest="{Binding WidthRequest, Source=
      {RelativeSource AncestorType={x:Type
        local:FavoriteControl}}}"&gt;
HeightRequest</strong> and <code>WidthRequest</code> properties of the <code>Image</code> control to those of <code>FavoriteControl</code>. By doing so, we ensure that the image scales according to the dimensions defined for <code>FavoriteControl</code>.</pre></li> <li>Finally, to control the tint of the <code>Image</code>, depending on the favorite status, we use <code>IconTintColorBehavior</code>, as shown here:<pre class="source-code">
&lt;Image.Behaviors&gt;
    &lt;toolkit:IconTintColorBehavior
        TintColor="{Binding IsFavorite,
        Source={x:Reference root},
        Converter={StaticResource
        isFavoriteToColorConverter}}" /&gt;
 &lt;/Image.Behaviors&gt;</pre><p class="list-inset">This setup closely <a id="_idIndexMarker756"/>mirrors what we used on <code>RecipesOverviewPage</code> and <code>RecipeDetailPage</code>. The key difference lies in the source of the binding. Here, we bind directly to the <code>IsFavorite</code> property we just created. We achieve this using element binding (via <code>x:Reference root</code>), which refers back to <code>FavoriteControl</code> itself. This is necessary because relative binding isn’t suitable here. Behaviors, unlike other UI elements, are not part of the visual tree, so they can’t perform <a id="_idIndexMarker757"/>relative binding or find ancestors in the same way that other elements can.</p></li> </ol>
<p>With these steps completed, we’ve successfully created our first custom control, <code>FavoriteControl</code>. Now, we can go ahead and replace the existing image and <code>IconTintColorBehavior</code> setup, used to indicate favorite recipes on both <code>RecipesOverviewPage</code> and <code>RecipeDetailPage</code>, with this custom control. Let’s do this in the following steps:</p>
<ol>
<li>Go to <code>RecipesOverviewPage</code> and add an <code>xml</code> namespace, referring to the namespace containing the newly created <code>FavoriteControl</code>, as shown here:<pre class="source-code">
</pre></li> <li>The XML namespace (<code>xmlns:toolkit</code>) pointing to the .NET MAUI Community Toolkit can be removed, as we won’t be using any of its functionalities anymore on this page. This is now encapsulated in our custom control.</li>
<li>Remove the <code>Image</code> UI element along with its associated behavior, which until now served as the<a id="_idIndexMarker758"/> favorite indicator for a recipe.</li>
<li>In place of the deleted <code>Image</code>, insert the <code>FavoriteControl</code> we just created. Here’s how to do it:<pre class="source-code">
&lt;controls:FavoriteControl
    Margin="5"
    HeightRequest="45"
    HorizontalOptions="End"
    <strong class="bold">IsFavorite="{Binding IsFavorite}"</strong>
    IsVisible="{Binding IsFavorite}"
    VerticalOptions="Start"
    WidthRequest="45" /&gt;</pre><p class="list-inset">The layout properties <a id="_idIndexMarker759"/>such as margin, size, visibility, and alignment options are unchanged from the removed <code>Image</code>. Also, observe how easily we can bind the <code>IsFavorite</code> property of our <code>FavoriteControl</code> to the corresponding <code>IsFavorite</code> property on the page’s <code>BindingContext</code>.</p></li> </ol>
<p>For <code>RecipeDetailPage</code>, we can follow a similar approach. Include an XML namespace that points to <code>Recipes.Mobile.Controls</code> and swap out the <code>Image</code>, which previously signaled whether the recipe was a favorite, with the newly created <code>FavoriteControl</code>. This is what the result looks like:</p>
<pre class="source-code">
&lt;ContentPage
    x:Class="Recipes.Mobile.RecipeDetailPage"
    
    
    <strong class="bold"/>
    ...&gt;
...
    &lt;Grid ColumnDefinitions="*, Auto"&gt;
        &lt;Label FontAttributes="Bold" FontSize="22"
            Text="{Binding Path=Title, Mode=OneWay}"
            VerticalOptions="Center" /&gt;
        <strong class="bold">&lt;controls:FavoriteControl Grid.Column="1"</strong>
<strong class="bold">            Margin="5" HeightRequest="35"</strong>
<strong class="bold">            IsFavorite="{Binding IsFavorite}"</strong>
<strong class="bold">            VerticalOptions="Center" WidthRequest="35" /&gt;</strong>
    &lt;/Grid&gt;
...
&lt;/ContentPage&gt;</pre> <p>By consolidating the favorite indicator into a single, reusable <code>FavoriteControl</code>, we’ve achieved multiple <a id="_idIndexMarker760"/>objectives. Firstly, we’ve centralized the code, making it easier to manage and update. Secondly, this control can now be <a id="_idIndexMarker761"/>used consistently across different pages of the app, ensuring a uniform user experience. Finally, by doing so, we’ve also enhanced the readability and maintainability of our code base. <em class="italic">Figure 11</em><em class="italic">.3</em> shows <code>FavoriteControl</code> on different pages of the app. Although nothing has visibly changed for the user, the code and its maintainability profit immensely from this reusable control.</p>
<div><div><img alt="Figure 11.3: FavoriteControl on different pages" height="486" src="img/B20941_11_03.jpg" width="1637"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3: FavoriteControl on different pages</p>
<p>Let’s see how we<a id="_idIndexMarker762"/> can improve this control a <a id="_idIndexMarker763"/>bit more, making the app more attractive to the user.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor187"/>Animating state changes</h2>
<p>As a quick example of reacting to state <a id="_idIndexMarker764"/>changes, let’s explore<a id="_idIndexMarker765"/> how to add a subtle animation to <code>FavoriteControl</code> whenever the <code>IsFavorite</code> property changes. We’ll use the <code>propertyChanged </code> delegate method of <code>IsFavoriteProperty</code> to trigger this animation. Let’s dive in!</p>
<ol>
<li>Modify <code>IsFavoriteProperty</code> by adding a <code>propertyChanged</code> delegate, like this:<pre class="source-code">
public static readonly BindableProperty
  IsFavoriteProperty =
        BindableProperty.Create(nameof(IsFavorite),
        typeof(bool),
        typeof(FavoriteControl),
        <strong class="bold">propertyChanged: OnIsFavoriteChanged</strong>);
private static void OnIsFavoriteChanged(BindableObject
  bindable, object oldValue, object newValue)
{
}</pre><p class="list-inset">With this modification, the static <code>OnIsFavoriteChanged</code> method will be invoked each time the value of the <code>IsFavorite</code> property changes. The <code>BindableObject</code> that gets passed in is the instance on which <code>BindableProperty</code> is set. In this case, it will be an instance of <code>FavoriteControl</code>. The <code>oldValue</code> and <code>newValue</code> parameters are self-explanatory, as they provide the <a id="_idIndexMarker766"/>previous and new values of the property, respectively.</p></li> <li>Next, let’s add the animation we want to play when the control’s state changes. Here’s how we <a id="_idIndexMarker767"/>can add it:<pre class="source-code">
private async Task AnimateChange()
{
    await icon.ScaleTo(1.5, 100);
    await icon.ScaleTo(1, 100);
}</pre><p class="list-inset">The <code>AnimateChange</code> method will scale the <code>Image</code> holding the icon to 1.5 times its size over a period of 100 milliseconds. Afterward, it will be scaled down again to its original size over the same amount of time.</p></li> <li>Finally, we need to call this method from the static <code>OnIsFavoriteChanged</code> method. The following code block shows how this can be done:<pre class="source-code">
private static void OnIsFavoriteChanged(
    BindableObject bindable,
    object oldValue, object newValue)
    =&gt; (bindable as FavoriteControl).AnimateChange();</pre><p class="list-inset">The bindable parameter can safely be cast to <code>FavoriteControl</code>, allowing us to call the <code>AnimateChange</code> method, triggering the animation.</p></li> </ol>
<p>Run the app to see the changes in action! You’ll observe a subtle animation on the <code>RecipeDetailPage</code> each time a recipe is toggled as a favorite. Introducing this custom control brings the convenience of unified animations across the application. Any modification made to the animation within the custom control gets automatically reflected everywhere it’s used. Without such a control, we’d need to manually update the animation at each individual instance<a id="_idIndexMarker768"/> throughout the app. Overlooking even a single instance would lead to inconsistent behavior. Thus, custom controls ensure both consistency and streamlined <a id="_idIndexMarker769"/>maintainability.</p>
<p class="callout-heading">Note</p>
<p class="callout">This example underscores an important point – even when you’re fully committed to using the MVVM pattern, there will be scenarios where writing code in the code-behind is not just acceptable but necessary. This is especially true when creating custom controls, where using code-behind is not only inevitable but also perfectly appropriate.</p>
<p>Next, let’s explore how to add interactions to a custom control by leveraging commanding, thereby further aligning it with MVVM concepts.</p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor188"/>Enabling interactions on custom controls</h1>
<p>In real-world applications, controls often<a id="_idIndexMarker770"/> serve dual roles – they both display data and allow users to interact with it. In this section, we’ll further enhance our <code>FavoriteControl</code> to not only support user interactions through <code>IsFavoriteChangedCommand</code> but also to facilitate two-way data binding. These features will make the control more interactive and further align it with MVVM concepts. We want to allow users to tap the <code>Image</code> on the <code>FavoriteControl</code>. When <code>FavoriteControl</code>’s <code>IsEnabled</code> property is set to <code>true</code>, the <code>IsFavorite</code> property will be updated and <code>IsFavoriteChangedCommand</code> will be executed.</p>
<p>Let’s take a look at the first part of this functionality – updating the <code>IsFavorite</code> property when a user taps on the image and making sure the value bound to this property gets updated as well.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor189"/>User actions and reflecting state</h2>
<p>To start with, let’s add the ability for users to toggle their favorite state by tapping on the control. This user action will then update the <code>IsFavorite</code> property of the control, which, in turn, will reflect back to <a id="_idIndexMarker771"/>update the bound property. The<a id="_idIndexMarker772"/> following steps show how to achieve this:</p>
<ol>
<li>Add a <code>GestureRecognizer</code> to the <code>FavoriteControl</code>’s <code>ContentView</code>, as shown here:<pre class="source-code">
&lt;ContentView.GestureRecognizers&gt;
    &lt;TapGestureRecognizer
        Tapped="TapGestureRecognizer_Tapped" /&gt;
&lt;/ContentView.GestureRecognizers&gt;</pre><p class="list-inset">A <code>GestureRecognizer</code> allows you to handle user interaction events, such as tapping, pinching, and swiping, on a UI element. By adding a <code>TapGestureRecognizer</code> to the <code>ContentView</code>, we effectively instruct the application to listen for a tap event on this control.</p><p class="list-inset">Here’s the <code>TapGestureRecognizer_Tapped</code> event handler in the code-behind:</p><pre class="source-code">private void TapGestureRecognizer_Tapped(
    object sender, TappedEventArgs e)
{
}</pre><p class="list-inset">This method will be triggered when a user taps on the <code>FavoriteControl</code>.</p></li> <li>Now, let’s implement the logic needed to update the <code>IsFavorite</code> property in the <code>TapGestureRecognizer_Tapped</code> method:<pre class="source-code">
private void TapGestureRecognizer_Tapped(
    object sender, TappedEventArgs e)
{
    if (IsEnabled)
    {
        IsFavorite = !IsFavorite;
    }
}</pre><p class="list-inset">Note how we first check the <code>IsEnabled</code> property before updating the <code>IsFavorite</code>. It’s crucial for custom controls to behave consistently with developers’ expectations. In this case, setting the <code>IsEnabled</code> property of a <code>VisualElement</code> to <code>false</code> should disable the control. As a result, we check the <code>IsEnabled</code> property before toggling the value of <code>IsFavorite</code>.</p></li> </ol>
<p>If we run the app and navigate to <code>RecipeDetailPage</code> at this point, tapping <code>FavoriteControl</code> should update its state. The<a id="_idIndexMarker773"/> animation we defined earlier also plays as a reaction to the <code>IsFavorite</code> property being updated. However, the state change is not reflected on the<a id="_idIndexMarker774"/> ViewModel. You might wonder why this is the case. It’s because <code>IsFavoriteProperty</code> has a default binding mode of <code>OneWay</code>. That’s why the updated value doesn’t flow from the control back to the ViewModel. This can easily be adjusted – change the <code>IsFavoriteProperty</code>’s default binding mode to <code>TwoWay</code>, or update the binding statement on the <code>RecipeDetailPage</code> and explicitly set it to <code>TwoWay</code>. Here’s what the first approach – updating the default binding mode – looks like:</p>
<pre class="source-code">
public static readonly BindableProperty
IsFavoriteProperty =
    BindableProperty.Create(nameof(IsFavorite),
        typeof(bool),
        typeof(FavoriteControl),
        <strong class="bold">defaultBindingMode: BindingMode.TwoWay</strong>,
        propertyChanged: OnIsFavoriteChanged);</pre> <p>Alternatively, we can leave the default binding mode to <code>OneWay</code> and update the binding statement on <code>RecipeDetailPage</code>, as shown here:</p>
<pre class="source-code">
&lt;controls:FavoriteControl
    Grid.Column="1"
    Margin="5"
    HeightRequest="35"
    <strong class="bold">IsFavorite="{Binding IsFavorite, Mode=TwoWay}"</strong>
    VerticalOptions="Center"
    WidthRequest="35" /&gt;</pre> <p>Either way, the <code>IsFavorite</code> property on the <code>FavoriteControl</code> will now reflect its state on the ViewModel. How can we<a id="_idIndexMarker775"/> verify this? By adding breakpoints in code of course, but also by simply<a id="_idIndexMarker776"/> tapping the control – note how the visibility of the <code>IsFavorite</code> property on the ViewModel.</p>
<p class="callout-heading">Note</p>
<p class="callout">When defining a bindable property, it’s crucial to select the <code>defaultBindingMode</code> that aligns best with the control’s primary intended behavior or the binding mode that will be most commonly used. In the rare instances where different behavior is required, the developer can always override the default by specifying a different binding mode in the binding statement.</p>
<p><code>IsFavorite</code> property won’t result in the underlying model being updated. Let’s delve into how we can incorporate commands into our <code>FavoriteControl</code> to make it even more versatile.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor190"/>Adding command-based interactions</h2>
<p>Let’s further enhance our <code>FavoriteControl</code> by exposing a command property – <code>ToggledCommand</code>. This <a id="_idIndexMarker778"/>command will be invoked whenever the <code>IsFavorite</code> property is toggled via a tap gesture on the control. To <a id="_idIndexMarker779"/>make this even more robust, the command will send the updated <code>IsFavorite</code> bool value as a parameter.</p>
<p>Adding command-based interactions to custom controls is pretty straightforward, as the following steps show:</p>
<ol>
<li>It all starts by adding a <code>BindableProperty</code> and a property of type <code>ICommand</code>. This code block shows how to add the <code>ToggledCommand</code> property and its corresponding <code>BindableProperty</code> to our <code>FavoriteControl</code>:<pre class="source-code">
public static readonly BindableProperty
  ToggledCommandProperty =
    BindableProperty.Create(
        nameof(ToggledCommand),
        typeof(ICommand), typeof(FavoriteControl));
public ICommand ToggledCommand
{
    get =&gt; (ICommand)
        GetValue(ToggledCommandProperty);
    set =&gt; SetValue(ToggledCommandProperty, value);
}</pre></li> <li>Next, we can call the command’s <code>Execute</code> method whenever the user has tapped the<a id="_idIndexMarker780"/> control and, thus, has updated the <code>IsFavorite</code> property. Here’s what the<a id="_idIndexMarker781"/> updated <code>TapGestureRecognizer_Tapped</code> method looks like:<pre class="source-code">
private void TapGestureRecognizer_Tapped(
    object sender, TappedEventArgs e)
{
    if (IsEnabled)
    {
        IsFavorite = !IsFavorite;
        <strong class="bold">ToggledCommand?.Execute(IsFavorite);</strong>
    }
}</pre><p class="list-inset">Note that we’re using the null-conditional operator (<code>?</code>) to prevent a <code>NullReferenceException</code> in case <code>ToggledCommand</code> is null.</p></li> <li>The following code block shows the <code>FavoriteToggledCommand</code> that we can add to the <code>RecipeDetailViewModel</code>, and which we will bind to the <code>ToggledCommand</code> of the <code>FavoriteControl</code>:<pre class="source-code">
...
public IRelayCommand FavoriteToggledCommand { get; }
...
public RecipeDetailViewModel(...)
{
    ...
    FavoriteToggledCommand =
        new AsyncRelayCommand&lt;bool&gt;(FavoriteToggled);
    ...
}
...</pre></li> <li>Next, let’s add the <code>FavoriteToggled</code> method, which is called by <code>FavoriteToggledCommand</code>. Here’s<a id="_idIndexMarker782"/> what it looks like:<pre class="source-code">
private async Task FavoriteToggled(bool isFavorite)
{
    if(isFavorite)
    {
        await favoritesService.Add(recipeDto.Id);
    }
    else
    {
        await favoritesService.Remove(recipeDto.Id);
    }
}</pre><p class="list-inset">The <code>ToggledCommand</code> of the <code>FavoriteControl</code> sends the updated <code>isFavorite</code> value as<a id="_idIndexMarker783"/> a parameter. We can use this parameter to decide what method to call on the <code>favoritesService</code>.</p></li> <li>With this in place, we can also quickly refactor the existing <code>AddAsFavorite</code> and <code>RemoveAsFavorite</code> methods in order to avoid code duplication, as shown here:<pre class="source-code">
private Task AddAsFavorite()
    =&gt; UpdateIsFavorite(true);
private Task RemoveAsFavorite()
    =&gt; UpdateIsFavorite(false);
private Task UpdateIsFavorite(bool newValue)
{
    IsFavorite = newValue;
    return FavoriteToggled(newValue);
}</pre><p class="list-inset">The <code>UpdateIsFavorite</code> method is added. This method takes in the new value that the <code>IsFavorite</code> property <a id="_idIndexMarker784"/>should get. It assigns this value to the property and calls the <code>FavoriteToggled</code> method that we just introduced. From the <code>AddAsFavorite</code> and <code>RemoveAsFavorite</code> methods, this new <code>UpdateIsFavorite</code> method can now be called, passing in just a <code>bool</code> value.</p></li> <li>The only thing that is left to<a id="_idIndexMarker785"/> do is to bind <code>FavoriteToggledCommand</code> of <code>RecipeDetailViewModel</code> to the <code>ToggledCommand</code> property of the <code>FavoriteControl</code> on the <code>RecipeDetailPage</code>. Here’s how:<pre class="source-code">
&lt;controls:FavoriteControl
    Grid.Column="1"
    Margin="5"
    HeightRequest="35"
    IsFavorite="{Binding IsFavorite, Mode=TwoWay}"
    <strong class="bold">ToggledCommand="{Binding FavoriteToggledCommand}"</strong>
    VerticalOptions="Center"
    WidthRequest="150" /&gt;</pre></li> </ol>
<p>If we run the app now, we’ll see that not only does the <code>IsFavorite</code> property updates when the <code>FavoriteControl</code> is tapped <a id="_idIndexMarker786"/>but the bound <code>FavoriteToggledCommand</code> is also invoked, allowing for seamless interaction and data updates in our application. This completes the integration of a<a id="_idIndexMarker787"/> very basic command-based interaction into our custom control. Let’s continue and make the control better and more intuitive for both the users of our app and other developers.</p>
<h3>Improving developer and user experience</h3>
<p>While the previous example provided a foundational understanding of how to integrate command-based interactions into<a id="_idIndexMarker788"/> our custom control, it merely scratched the surface. Developers aiming to integrate this control across diverse use cases and the end-users who will interact with it both anticipate a solution that’s more polished and adaptable. For instance, we could enhance the user experience by providing visual cues that indicate the control is clickable. On the developer side, we want our control to be predictable; developers expect things to work in a certain way. Ideally, our control should adhere to the bound command’s <code>CanExecute</code> method and adjust its behavior accordingly. In my experience, poorly designed or inadequately thought-through controls have often created headaches for both myself and my colleagues. The goal is to make a custom control intuitive enough that it doesn’t require extensive explanation for straightforward tasks. Let’s see how we can bring our <code>FavoriteControl</code> to another level!</p>
<p>Let’s first introduce a new property called <code>IsInteractive</code> to <code>FavoriteControl</code>. This property will be set to <code>true</code> when the <code>IsEnabled</code> property of the control is set to <code>true</code>, the <code>ToggleCommand</code> is set, and its <code>CanExecute</code> method returns <code>true</code>. In all other situations, the value of the <code>IsInteractive</code> property needs to be <code>false</code>. This property can then be checked inside the control prior to executing an action. Let’s go through this step by step:</p>
<ol>
<li>Add the <code>IsInteractive</code> property to <code>FavoriteControl</code>, as shown here:<pre class="source-code">
public bool IsInteractive { get; private set; }</pre></li> <li>The following code snippet shows the <code>UpdateIsInteractive</code> method. This method is responsible for setting the <code>IsInteractive</code> property:<pre class="source-code">
private void UpdateIsInteractive()
    =&gt; IsInteractive = IsEnabled
    &amp;&amp; (ToggledCommand?.CanExecute(IsFavorite)
    ?? false);</pre></li> <li>Update the <code>TapGestureRecognizer_Tapped</code> method, as shown in the next code <a id="_idIndexMarker789"/>block:<pre class="source-code">
private void TapGestureRecognizer_Tapped(
    object sender, TappedEventArgs e)
{
    <strong class="bold">if (IsInteractive)</strong>
    {
        IsFavorite = !IsFavorite;
        ToggledCommand?.Execute(IsFavorite);
    }
}</pre><p class="list-inset">By updating the code that is shown here, we only allow the <code>IsFavorite</code> property to be toggled when the <code>IsInteractive</code> property is set to <code>true</code>. This means the control is enabled, its <code>ToggleCommand</code> is set, and the <code>ToggleCommand</code>’s <code>CanExecute</code> method returns <code>true</code>.</p></li> </ol>
<p>Next, we need to make sure that the <code>UpdateIsInteractive</code> method is called when its value needs updating. That’s the case in the following three situations:</p>
<ul>
<li>When the value of the <code>IsEnabled</code> property changes</li>
<li>When the <code>ToggleCommand</code> property is updated</li>
<li>When the <code>CanExecuteChanged</code> event of the command is triggered</li>
</ul>
<p>In the following steps, we’ll put everything in place so that the <code>UpdateIsInteractive</code> method is called in the aforementioned situations:</p>
<ol>
<li>In the <code>FavoriteControl</code> class, override the <code>OnPropertyChanged</code> method. This method gets called by the control’s properties in order to trigger the <code>PropertyChanged</code> event, just like we typically have in our ViewModels. Let’s see what <a id="_idIndexMarker790"/>we can do with it:<pre class="source-code">
protected override void OnPropertyChanged(
    [CallerMemberName] string propertyName = null)
{
    base.OnPropertyChanged(propertyName);
    <strong class="bold">if(propertyName == nameof(IsEnabled))</strong>
<strong class="bold">    {</strong>
<strong class="bold">        UpdateIsInteractive();</strong>
<strong class="bold">    }</strong>
}</pre><p class="list-inset">Whenever the passed-in <code>propertyName</code> matches the <code>IsEnabled</code> property, we want to trigger the <code>UpdateIsInteractive</code> method. This ensures that whenever the <code>IsEnabled</code> property is updated, the <code>IsInteractive</code> property gets re-evaluated.</p></li> <li>Next, we move on to make sure that the <code>IsInteractive</code> property gets updated when <code>ToggledCommand</code> is updated. Let’s start by adding a <code>propertyChanged</code> delegate to <code>ToggledCommandProperty</code>, as shown here:<pre class="source-code">
public static readonly BindableProperty
  ToggledCommandProperty =
    BindableProperty.Create(nameof(ToggledCommand),
        typeof(ICommand), typeof(FavoriteControl),
        <strong class="bold">propertyChanged: ToggledCommandChanged</strong>);
private static void ToggledCommandChanged(
    BindableObject bindable,
    object oldValue, object newValue)
{
    var control = bindable as FavoriteControl;
    control.UpdateIsInteractive();
}</pre><p class="list-inset">The <code>ToggledCommandChanged</code> method is called when the value of the command is updated. This is the<a id="_idIndexMarker791"/> ideal place to call the <code>UpdateIsInteractive</code> method so that the <code>IsInteractive</code> property gets updated, based on the new <code>ToggledCommand</code>.</p></li> <li>Finally, our <code>IsInteractive</code> property isn’t solely reliant on the <code>IsEnabled</code> property and the presence of the <code>ToggledCommand</code>. It also takes into account the <code>CanExecute</code> method of the defined command. To achieve this, we need to listen for changes in the command’s <code>CanExecute</code> state by subscribing to its <code>CanExecuteChanged</code> event. Here’s how we can update the <code>ToggleCommandChanged</code> method for that purpose:<pre class="source-code">
private static void ToggledCommandChanged(
    BindableObject bindable,
    object oldValue, object newValue)
{
    var control = bindable as FavoriteControl;
    <strong class="bold">if (oldValue is ICommand oldCommand)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        oldCommand.CanExecuteChanged -=</strong>
<strong class="bold">            control.CanExecuteChanged;</strong>
<strong class="bold">    }</strong>
    <strong class="bold">if (newValue is ICommand newCommand)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        newCommand.CanExecuteChanged +=</strong>
<strong class="bold">            control.CanExecuteChanged;</strong>
<strong class="bold">    }</strong>
    control.UpdateIsInteractive();
}</pre><p class="list-inset">After setting the new command, we’re not just subscribing to its <code>CanExecuteChanged</code> event; we’re also making sure to unsubscribe from the same event on the previous command. This is crucial to ensure that our control only reacts to the current <a id="_idIndexMarker792"/>command’s <code>CanExecute</code> state. The <code>CanExecuteChanged</code> event handler merely calls the <code>UpdateIsInteractive</code> method, as shown here:</p><pre class="source-code">private void CanExecuteChanged(
    object sender, EventArgs e)
    =&gt; UpdateIsInteractive();</pre></li> </ol>
<p>In summary, the <code>IsInteractive</code> property serves as the gateway for user interactions with the control. Its state is determined by a combination of factors – the <code>IsEnabled</code> property of the control, the presence of a command, and that command’s <code>CanExecute</code> method. Importantly, the <code>IsInteractive</code> state is dynamically re-evaluated every time any of these contributing factors change.</p>
<p>Let’s see this in action! For <a id="_idIndexMarker793"/>demo purposes, let’s add a maximum number of times the favorite state of a recipe can be toggled via <code>FavoriteControl</code>. The <code>canExecute</code> delegate of the <code>FavoriteToggledCommand</code> on the <code>RecipeDetailViewModel</code> should return <code>true</code> as long as this number is not exceeded. Let’s see how we can implement this:</p>
<ol>
<li>Let’s start by adding the following two fields to <code>RecipeDetailViewModel</code>:<pre class="source-code">
int updateCount = 0;
int maxUpdatedAllowed = 5;</pre></li> <li>Next, update the <code>FavoriteToggledCommand</code> so that it includes the <code>canExecute</code> predicate, as shown here:<pre class="source-code">
FavoriteToggledCommand = new AsyncRelayCommand&lt;bool&gt;(
    FavoriteToggled,
    <code>FavoriteToggled</code> method so that it keeps track of the number of times it was invoked, as shown here:<pre class="source-code">
private async Task FavoriteToggled(bool isFavorite)
{
    ...
    updateCount++;
    FavoriteToggledCommand.NotifyCanExecuteChanged();
}</pre><p class="list-inset">Not only does this method now keep track of the number of times it was invoked, but it also triggers the <code>NotifyCanExecuteChanged</code> event of the <code>FavoriteToggledCommand</code>. As a result, the <code>CanExecuteChanged</code> method on <code>FavoriteControl</code> will get called, which will eventually call the command’s <code>CanExecute</code> method to see whether it still can be executed.</p></li> </ol>
<p>With this in place, we can run the app and see how the <code>FavoriteControl</code> reacts to the <code>ToggleCommand</code>’s <code>CanExecute</code> method. Go to the detail page of a recipe and press the <code>FavoriteControl</code> a couple of times. You’ll <a id="_idIndexMarker794"/>notice the favorite state will be updated until you’ve clicked five times. After that, the <code>ToggleCommand</code>’s <code>CanExecute</code> method returns <code>false</code>, resulting in <code>IsInteractive</code> being set to <code>false</code> as well. Any following interactions with the control will be ignored because of this. Additionally, on the <code>RecipesOverviewPage</code>, you’ll find that <code>FavoriteControl</code> is not tappable due to the absence of a defined <code>ToggleCommand</code>. Both scenarios illustrate that the controls behave as expected!</p>
<p>Now that we’ve established how the <code>IsInteractive</code> property works, let’s turn our attention to leveraging it for a more intuitive user experience. Specifically, we’ll explore how to use this property to provide a visual cue that indicates whether or not the control is tappable. There’s not that much we can do about our <code>FavoriteControl</code> to make it really clear that it’s tappable. For the purposes of this demo, we’ll add a simple indicator – a black border around the heart icon when it’s tappable. Here’s how we can do this:</p>
<ol>
<li>Open the <code>FavoriteControl.xaml</code> file and surround the existing <code>Image</code> control with <code>Grid</code>, as shown in the following snippet:<pre class="source-code">
<strong class="bold">&lt;Grid&gt;</strong>
    &lt;Image x:Name="icon" ...&gt;
        ...
    &lt;/Image&gt;
<code>Image</code>, prior to the existing one:<pre class="source-code">
&lt;Grid&gt;
    <strong class="bold">&lt;Image</strong>
<strong class="bold">        HeightRequest="{Binding HeightRequest,</strong>
<strong class="bold">            Source={x:Reference icon}}"</strong>
<strong class="bold">        WidthRequest="{Binding WidthRequest,</strong>
<strong class="bold">            Source={x:Reference icon}}"</strong>
<strong class="bold">        IsVisible="{Binding IsInteractive,</strong>
<strong class="bold">            Source={RelativeSource</strong>
<strong class="bold">            AncestorType={x:Type</strong>
<strong class="bold">            local:FavoriteControl}}}"</strong>
<strong class="bold">        Scale="1.2"</strong>
<strong class="bold">        Source="{Binding Source,</strong>
<strong class="bold">            Source={x:Reference icon}}" /&gt;</strong>
    &lt;Image x:Name="icon" ...&gt;
        ...
    &lt;/Image&gt;
&lt;/Grid&gt;</pre><p class="list-inset"><code>Grid</code> allows controls to be placed on top of each other. The added <code>Image</code> will be rendered below the existing favorite icon. Its <code>HeightRequest</code>, <code>WidthRequest</code>, and <code>Source</code> properties are bound to those of the existing Image. Do note its <code>Scale</code> property – it’s set to <code>1.2</code>. As a result, this new <code>Image</code> will be a bit bigger than the <code>Image</code> on<a id="_idIndexMarker795"/> top. This creates the visual effect of a border surrounding the icon. Also, take a look at the <code>IsVisible</code> property – it’s bound to the <code>IsInteractive</code> property we introduced earlier. Because of this, the underlying <code>Image</code> will only be rendered when the control is tappable, giving a user a visual cue.</p></li> <li>Lastly, it’s crucial not to forget to trigger the <code>PropertyChanged</code> event for the <code>IsInteractive</code> property whenever it is updated. Otherwise, the binding engine wouldn’t be notified about the updated value. The following snippet shows how we can update the <code>UpdateIsInteractive</code> method to do that:<pre class="source-code">
private void UpdateIsInteractive()
{
    IsInteractive = IsEnabled
    &amp;&amp; (ToggledCommand?.CanExecute(IsFavorite)
    ?? false);
    <strong class="bold">OnPropertyChanged(nameof(IsInteractive));</strong>
}</pre></li> </ol>
<p>When running the app now and navigating to a <code>RecipeDetailPage</code>, you should see a black border around the favorite icon, indicating that the control is interactive. This border isn’t visible on the <code>RecipeOverviewPage</code> because of the absence of a <code>ToggledCommand</code>. Moreover, when<a id="_idIndexMarker796"/> tapping <code>FavoriteControl</code> on a <code>RecipeDetailPage</code> a few times, after the fifth time, the border will disappear because <code>FavoriteToggledCommand</code>’s <code>CanExecute</code> method returns <code>false</code>. This visual cue informs a user that the control is no longer interactive. <em class="italic">Figure 11</em><em class="italic">.4</em> shows the <code>FavoriteControl</code> on the <code>RecipeDetailPage</code> in all its different states:</p>
<div><div><img alt="Figure 11.4: FavoriteControl in different states" height="430" src="img/B20941_11_04.jpg" width="1560"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4: FavoriteControl in different states</p>
<p>Now that we’ve fine-tuned the user and developer experience, let’s take it a step further by making our control’s design as adaptable as its functionality.</p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor191"/>Working with control templates</h1>
<p>So far, we’ve been dealing with a hardcoded look and feel, but what if we want to offer more flexibility without forcing <a id="_idIndexMarker797"/>developers to rewrite or extend our control? By supporting control templates, we can expose the structure of our control’s visual tree, enabling both styling and structural changes while retaining its core functionality. This is an excellent way to ensure that our custom control seamlessly fits into a diverse array of user interfaces, providing an even greater degree of customization.</p>
<p>You might wonder how this is relevant to MVVM. Consider the following – a control template serves to separate the logic and behavior of a control from its visual representation, much like how MVVM achieves loose coupling between the ViewModel and the View. In this sense, the control effectively serves as a ViewModel for the control template. It exposes properties that the template binds to. The control template, in turn, can be considered as the View. So, just like we are used to, we can use data binding in the control template and use a relative binding source set to <code>TemplatedParent</code> to bind to the properties of the control that the template is applied to.</p>
<p class="callout-heading">TemplateBinding and TemplatedParent</p>
<p class="callout">In the upcoming examples, we’ll use binding statements with their <code>RelativeSource</code> set to <code>TemplatedParent</code>. It’s worth noting that this approach performs the same function as the now-obsolete <code>TemplateBinding</code> markup extension. Essentially, setting <code>RelativeSource</code> to <code>TemplatedParent</code> manually accomplishes what <code>TemplateBinding</code> used to do automatically, creating a binding whose source is the control to which the template is applied. However, since .NET 7, the <code>TemplateBinding</code> markup extension has been marked as “obsolete.”</p>
<p>I want to quickly discuss control templates, as they reflect the MVVM philosophy. Whether you’re extending the visuals of existing controls or creating new ones from scratch, knowing how to properly structure and utilize control templates will make your development process more efficient and your applications more maintainable. I also think that being proficient in the aspects of XAML and data binding directly contributes to effectively applying the MVVM pattern in your projects. Without further ado, let’s dive in!</p>
<p>The next steps show how to define a control template and apply it to the <code>FavoriteControl</code>:</p>
<ol>
<li>On <code>RecipeDetailPage</code>, we can add a <code>ControlTemplate</code> to the page’s <code>Resource</code>s, as shown in the following snippet:<pre class="source-code">
&lt;ControlTemplate x:Key="FavoriteTemplate"&gt;
    &lt;VerticalStackLayout&gt;
        &lt;Label
            FontSize="10" HorizontalOptions="Center"
            Text="Favorite?" /&gt;
        &lt;Switch
            HorizontalOptions="Center"
            InputTransparent="True"
            <strong class="bold">IsEnabled="{Binding IsInteractive,</strong>
<strong class="bold">             Source={RelativeSource TemplatedParent}}"</strong>
            <strong class="bold">IsToggled="{Binding IsFavorite, Source=</strong>
<strong class="bold">              {RelativeSource TemplatedParent},</strong>
<strong class="bold">                </strong><strong class="bold">Mode=OneWay}"</strong>
        /&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ControlTemplate&gt;</pre><p class="list-inset">Note how this template uses <code>TemplatedParent</code> as <code>RelativeSource</code> in its binding<a id="_idIndexMarker798"/> statements. By doing this, we bind to the public properties exposed by the control where this template will be applied, as we will see later on.</p></li> <li>The following code snippet shows how we can use the key associated with the <code>ControlTemplate</code> (<code>FavoriteTemplate</code>), together with the <code>StaticResource</code> Markup extension, to assign it as the template of our <code>FavoriteControl</code>:<pre class="source-code">
&lt;controls:FavoriteControl
    ...
    ControlTemplate="{StaticResource
      FavoriteTemplate}"
    ... /&gt;</pre></li> </ol>
<p>While maintaining the functionality of the <code>FavoriteControl</code>, this template gives an entirely different look to the <a id="_idIndexMarker799"/>control, as you can see in <em class="italic">Figure 11</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 11.5: FavoriteControl with an alternative template" height="177" src="img/B20941_11_05.jpg" width="852"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5: FavoriteControl with an alternative template</p>
<p>However, there is one thing missing. Remember the animation we had on the original control? The animation was triggered by the following code:</p>
<pre class="source-code">
private async Task AnimateChange()
{
    await icon.ScaleTo(1.5, 100);
    await icon.ScaleTo(1, 100);
}</pre> <p>The original visual tree of the control is replaced by the new visual tree defined in the <code>ControlTemplate</code>. Therefore, the original elements are not visible and are not part of the current visual tree. However, those original elements do still exist in memory if you have references to them in your code-behind. Even though they are detached from the visual tree and are not visible, you can still interact with them using code. They just won’t have any impact on what a user sees because they are not in the visual tree anymore. As a result, the code responsible for the animation won’t crash, but there won’t be any visual effect on the screen. Let’s <a id="_idIndexMarker800"/>see how we can access visual elements defined on a <code>ControlTemplate</code>.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor192"/>Accessing elements from a template</h2>
<p>Traditionally, when working with custom controls, UI elements are defined directly within the control. These controls, when given an <code>x:Name</code> attribute, can be accessed and manipulated from the control’s code-behind, which is a perfectly valid approach to defining and working with custom <a id="_idIndexMarker801"/>controls. However, when fully embracing the power of control templates, the need for directly defined UI elements lessens. Instead, the default appearance of the control should ideally be encapsulated within a <code>ControlTemplate</code>.</p>
<p>For illustration, let’s consider <code>FavoriteControlTemplated</code>, which is a variant of <code>FavoriteControl</code>. Unlike the original, this version doesn’t have UI elements defined directly within it. Instead, its default appearance is declared in a <code>ControlTemplate</code>, defined in the control’s <code>Resources</code>. Here’s how it looks in XAML:</p>
<pre class="source-code">
&lt;ContentView
    ...&gt;
    &lt;ContentView.Resources&gt;
        &lt;toolkit:BoolToObjectConverter
            ... /&gt;
        <strong class="bold">&lt;ControlTemplate x:Key="DefaultTemplate"&gt;</strong>
<strong class="bold">            &lt;Grid&gt;</strong>
<strong class="bold">                &lt;Image</strong>
<strong class="bold">                    </strong><strong class="bold">HeightRequest="{Binding HeightRequest,</strong>
<strong class="bold">                     Source={x:Reference TemplatedParent}}"</strong>
<strong class="bold">                    IsVisible="{Binding IsInteractive,</strong>
<strong class="bold">                      Source={RelativeSource</strong>
<strong class="bold">                        TemplatedParent}}"</strong>
<strong class="bold">                    Scale="1.2"</strong>
<strong class="bold">                    Source="{Binding Source, Source=</strong>
<strong class="bold">                      {x:Reference scalableContent}}"</strong>
<strong class="bold">                    WidthRequest="{Binding WidthRequest,</strong>
<strong class="bold">                     Source={x:Reference scalableContent}}"</strong>
<strong class="bold">                       </strong><strong class="bold">/&gt;</strong>
<strong class="bold">                &lt;Image</strong>
<strong class="bold">                    x:Name="scalableContent"</strong>
<strong class="bold">                    HeightRequest="{Binding HeightRequest,</strong>
<strong class="bold">                      Source={RelativeSource</strong>
<strong class="bold">                        TemplatedParent}}"</strong>
<strong class="bold">                    Source="favorite.png"</strong>
<strong class="bold">                    WidthRequest="{Binding WidthRequest,</strong>
<strong class="bold">                      Source={RelativeSource</strong>
<strong class="bold">                        TemplatedParent}}"&gt;</strong>
<strong class="bold">                    </strong><strong class="bold">&lt;Image.Behaviors&gt;</strong>
<strong class="bold">                        ...</strong>
<strong class="bold">                    &lt;/Image.Behaviors&gt;</strong>
<strong class="bold">                &lt;/Image&gt;</strong>
<strong class="bold">            &lt;/Grid&gt;</strong>
<strong class="bold">        &lt;/ControlTemplate&gt;</strong>
    &lt;/ContentView.Resources&gt;
    &lt;ContentView.GestureRecognizers&gt;
        ...
    &lt;/ContentView.GestureRecognizers&gt;
&lt;/ContentView&gt;</pre> <p>As you can see in the next code block, in the constructor of the <code>FavoriteControlTemplated</code> class, a default template is assigned when no other template is specified:</p>
<pre class="source-code">
public FavoriteControlTemplated()
{
    InitializeComponent();
    if(ControlTemplate == null)
    {
        var template = Resources["DefaultTemplate"];
        ControlTemplate = template as ControlTemplate;
    }
}</pre> <p>If the <code>ControlTemplate</code> property is null, it means the developer hasn’t specified a different template. In that case, the<a id="_idIndexMarker802"/> default template from the control’s <code>Resources</code> is retrieved and assigned.</p>
<p>The <code>OnApplyTemplate</code> method is called when the control template is fully loaded. This is where the <code>GetTemplateChild</code> method can be used to access specific elements within the template, like <code>Image</code> in our template, which we assigned the name <code>scalableContent</code>. The following snippet shows how we use the <code>GetTemplateChild</code> method to get a <code>VisualElement</code> named <code>scalableContent</code>:</p>
<pre class="source-code">
VisualElement scalableContent;
protected override void OnApplyTemplate()
{
    base.OnApplyTemplate();
    scalableContent =
        GetTemplateChild("scalableContent")
        as VisualElement;
}</pre> <p>Once a <code>VisualElement</code> with the name <code>scalableContent</code> is retrieved, it can be manipulated programmatically. For example, in the <code>AnimateChange</code> method, scaling animations can be applied to it:</p>
<pre class="source-code">
private async Task AnimateChange()
{
    if (scalableContent is not null)
    {
        await scalableContent.ScaleTo(1.5, 100);
        await scalableContent.ScaleTo(1, 100);
    }
}</pre> <p>By adopting control templates and leveraging methods such as <code>GetTemplateChild</code>, we can maintain a clean separation <a id="_idIndexMarker803"/>between the logic and visual representation of our control, allowing more flexible and reusable components.</p>
<p>Let’s update the <code>FavoriteTemplate</code> we created earlier on <code>RecipeDetailPage</code> by giving a certain UI element the name <code>scalableContent</code>, using <code>FavoriteControlTemplated</code> instead of <code>FavoriteControl</code>. Here’s how:</p>
<ol>
<li>On <code>RecipeDetailPage</code>, update the <code>FavoriteTemplate</code>, as shown here:<pre class="source-code">
&lt;ControlTemplate x:Key="FavoriteTemplate"&gt;
    ...
        &lt;Switch
            <strong class="bold">x:Name="scalebleContent"</strong>
            …  /&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ControlTemplate&gt;</pre><p class="list-inset">By assigning <code>scalebleContent</code> as the name of the <code>Switch</code> control, it can be picked up later by the <code>FavoriteControlTemplated</code> control and have animations applied <a id="_idIndexMarker804"/>to it.</p></li> <li>As shown in the next code block, let’s use the <code>FavoriteControlTemplated</code> custom control instead of the <code>FavoriteControl</code> from earlier:<pre class="source-code">
&lt;controls:FavoriteCo<a id="_idTextAnchor193"/>ntrolTemplated
    Grid.Column="1"
    Margin="5"
    ControlTemplate="{StaticResource
      FavoriteTemplate}"
    IsFavorite="{Binding IsFavorite, Mode=TwoWay}"
    ToggledCommand="{Binding FavoriteToggledCommand}"
    VerticalOptions="Center" /&gt;</pre><p class="list-inset">If you run the app at this stage, you’ll notice the updated favorite indicator. When we tap the control, you’ll notice the <code>Switch</code> is scaled. This is because it was named <code>scalableContent</code> in the template. If you update <code>RecipeDetailPage</code> and leave out the assignment of the <code>ControlTemplate</code> property (<code>ControlTemplate="{StaticResource FavoriteTemplate}"</code>) and run the app again, you’ll see the visualization using the hearts we had earlier. That’s because when no <code>ControlTemplate</code> is assigned explicitly, the control will load the default control template.</p></li> </ol>
<p>It’s worth noting that any control template that includes an element named <code>scalableContent</code> will be compatible with this code. In other words, as long as the template has a UI element with the name <code>scalableContent</code>, our <code>FavoriteControlTemplated</code> class will be able to retrieve it and apply the scaling animation. However, what if there’s no <code>scalableContent</code> element in the template? No worries – the control is designed to degrade gracefully. If the element isn’t found, all functionalities of the control will remain intact; only the animation will be absent. This flexibility allows developers to create a wide array of visual styles while the behavior of the control remains intact.</p>
<p>The principle of separation of concerns is central to MVVM and vital to creating maintainable software. When you’re crafting custom controls, this same principle can be extended through the use of control templates. However, it’s worth mentioning that fully implementing control templates<a id="_idIndexMarker805"/> may not always be necessary. For simpler controls that are unique to your application and maintain a consistent appearance, directly defining UI elements within the control itself is both a practical and valid approach. This allows you to balance complexity with flexibility, enabling you to choose the approach that best suits your project’s specific requirements.</p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor194"/>Summary</h1>
<p>In this chapter, we explored the powerful possibilities offered by custom controls and control templates in .NET MAUI, all within the context of the MVVM architecture. From understanding the basics of custom controls to creating bindable properties, we’ve delved into the intricacies of data binding on custom controls. We also explored how to add interactivity to our control and how commands can be exposed and dealt with. Furthermore, we dived deep into the flexibility and scalability offered by control templates. Collectively, these techniques enhance reusability and adhere to the principles of separation of concerns. Mastering the art of creating UIs – whether through XAML or code-behind – and understanding how to craft MVVM-friendly controls with bindable properties and commands contributes tremendously to being proficient in MVVM. Whether it’s a simple control with a hardcoded appearance or a complex, template-driven control, the key takeaway is understanding when and how to appropriately apply these approaches to create maintainable, adaptable, and highly customizable UI components.</p>
<p>In the next chapter, we’ll explore localization within the context of MVVM, enabling our UI components to be not only flexible and maintainable but also globally adaptable.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor195"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>Create a custom control using handlers: <a href="https://learn.microsoft.com/dotnet/maui/user-interface/handlers/create">https://learn.microsoft.com/dotnet/maui/user-interface/handlers/create</a></li>
<li>Customize controls with handlers: <a href="https://learn.microsoft.com/dotnet/maui/user-interface/handlers/customize">https://learn.microsoft.com/dotnet/maui/user-interface/handlers/customize</a></li>
<li>More about control templates: <a href="https://learn.microsoft.com/dotnet/maui/fundamentals/controltemplate">https://learn.microsoft.com/dotnet/maui/fundamentals/controltemplate</a></li>
<li>Bind to a templated parent: <a href="https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings#bind-to-a-templated-parent">https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings#bind-to-a-templated-parent</a></li>
</ul>
</div>
</div></body></html>