<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer317">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">20</span></h1>
<h1 class="chapterTitle" id="_idParaDest-411"><span class="koboSpan" id="kobo.2.1">Kubernetes</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">This chapter is dedicated to describing the Kubernetes container orchestrator and its implementation in Azure, called </span><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">Azure Kubernetes Service </span></strong><span class="koboSpan" id="kobo.5.1">(</span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">AKS</span></strong><span class="koboSpan" id="kobo.7.1">). </span><span class="koboSpan" id="kobo.7.2">We discussed the importance and the</span><a id="_idIndexMarker1438"/><span class="koboSpan" id="kobo.8.1"> tasks handled by orchestrators in the </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Which tools are needed to manage microservices?</span></em><span class="koboSpan" id="kobo.10.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Chapter 11, Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">Here, it is worth recalling just that Kubernetes is the de facto standard for orchestrators.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.13.1">We will show also how to install and use minikube on your local machine, which is a one-node Kubernetes simulator you can use to try out all of the examples in this chapter, and also to test your own applications. </span><span class="koboSpan" id="kobo.13.2">Simulators are useful both to avoid wasting too much money on an actual cloud-based Kubernetes cluster, and to provide a different Kubernetes cluster to each developer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.14.1">This chapter explains the fundamental Kubernetes concepts and then focuses on how to interact with a Kubernetes cluster and how to deploy a Kubernetes application. </span><span class="koboSpan" id="kobo.14.2">All concepts are put into practice with simple examples. </span><span class="koboSpan" id="kobo.14.3">We recommend reading </span><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 11</span></em><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.18.1">, before reading this chapter, since we will use concepts explained in previous chapters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.19.1">More specifically, in this chapter, we will cover the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Kubernetes basics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Interacting with Azure Kubernetes clusters</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.22.1">Advanced Kubernetes concepts</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.23.1">By the end of this chapter, you will have learned how to implement and deploy a complete solution using Azure Kubernetes Service.</span></p>
<h1 class="heading-1" id="_idParaDest-412"><span class="koboSpan" id="kobo.24.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.25.1">In this chapter, you will require the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.26.1">Visual Studio 2022 free Community Edition or better, with all the database tools installed, or any other </span><code class="inlineCode"><span class="koboSpan" id="kobo.27.1">.yaml</span></code><span class="koboSpan" id="kobo.28.1"> file editor, such as Visual Studio Code.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.29.1">A free Azure account. </span><span class="koboSpan" id="kobo.29.2">The </span><em class="italic"><span class="koboSpan" id="kobo.30.1">Creating an Azure account</span></em><span class="koboSpan" id="kobo.31.1"> section in </span><em class="italic"><span class="koboSpan" id="kobo.32.1">Chapter 1</span></em><span class="koboSpan" id="kobo.33.1">, </span><em class="italic"><span class="koboSpan" id="kobo.34.1">Understanding the Importance of Software Architecture</span></em><span class="koboSpan" id="kobo.35.1">, explains how to create one.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.36.1">An optional minikube installation. </span><span class="koboSpan" id="kobo.36.2">Installation instructions will be given in the </span><em class="italic"><span class="koboSpan" id="kobo.37.1">Using minikube</span></em><span class="koboSpan" id="kobo.38.1"> section of this chapter.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.39.1">The code for this chapter is available at </span><a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E"><span class="url"><span class="koboSpan" id="kobo.40.1">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</span></span></a><span class="koboSpan" id="kobo.41.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-413"><span class="koboSpan" id="kobo.42.1">Kubernetes basics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.43.1">Kubernetes is an advanced open source software for managing distributed applications running on a computer network. </span><span class="koboSpan" id="kobo.43.2">Kubernetes can be used on your private machine’s cluster, or you can use hardware-scalable</span><a id="_idIndexMarker1439"/><span class="koboSpan" id="kobo.44.1"> Kubernetes offerings from all main cloud providers. </span><span class="koboSpan" id="kobo.44.2">This kind of software is called an </span><strong class="keyWord"><span class="koboSpan" id="kobo.45.1">orchestrator</span></strong><span class="koboSpan" id="kobo.46.1"> since it dynamically allocates microservices to the available hardware resources in order to maximize performance. </span><span class="koboSpan" id="kobo.46.2">Moreover, orchestrators </span><a id="_idIndexMarker1440"/><span class="koboSpan" id="kobo.47.1">like Kubernetes provide stable virtual addresses to microservices that they move around from one machine to another, thus changing their physical addresses. </span><span class="koboSpan" id="kobo.47.2">At the time of writing, Kubernetes is the most widespread orchestrator and the </span><em class="italic"><span class="koboSpan" id="kobo.48.1">de facto</span></em><span class="koboSpan" id="kobo.49.1"> standard for cluster orchestration that can be used with a wide ecosystem of tools and applications. </span><span class="koboSpan" id="kobo.49.2">While not being tied to specific languages or frameworks, Kubernetes is a fundamental tool for managing hardware resources and communications in .NET distributed applications based on microservices. </span><span class="koboSpan" id="kobo.49.3">This section introduces the basic Kubernetes concepts and entities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.50.1">A Kubernetes cluster is a cluster of virtual machines running the Kubernetes orchestrator.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.51.1"><img alt="" role="presentation" src="../Images/B19820_20_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.52.1">Figure 20.1: Computer network equipped with Kubernetes</span></p>
<p class="normal"><span class="koboSpan" id="kobo.53.1">Generally, Kubernetes is installed on specific machines </span><a id="_idIndexMarker1441"/><span class="koboSpan" id="kobo.54.1">referred to as </span><strong class="keyWord"><span class="koboSpan" id="kobo.55.1">master nodes</span></strong><span class="koboSpan" id="kobo.56.1">, while all other computers </span><a id="_idIndexMarker1442"/><span class="koboSpan" id="kobo.57.1">simply run an interface software that connects with the software running on the master nodes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.58.1">The virtual machines composing the </span><a id="_idIndexMarker1443"/><span class="koboSpan" id="kobo.59.1">cluster are called </span><strong class="keyWord"><span class="koboSpan" id="kobo.60.1">nodes</span></strong><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">The smallest software unit we can deploy on Kubernetes is not a single application, but an aggregate of containerized applications called </span><strong class="keyWord"><span class="koboSpan" id="kobo.62.1">Pod</span></strong><span class="koboSpan" id="kobo.63.1">. </span><span class="koboSpan" id="kobo.63.2">While </span><a id="_idIndexMarker1444"/><span class="koboSpan" id="kobo.64.1">Kubernetes supports various types of containers, the most commonly used container type is Docker, which we analyzed in </span><em class="italic"><span class="koboSpan" id="kobo.65.1">Chapter 11</span></em><span class="koboSpan" id="kobo.66.1">, </span><em class="italic"><span class="koboSpan" id="kobo.67.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.68.1">, so we will confine our discussion here to Docker. </span><span class="koboSpan" id="kobo.68.2">Pods are aggregates of Docker images, each containing one of your .NET microservices or microservices implemented with other technologies.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.69.1">More specifically, Pods are sets of Docker images constrained to be placed together on the same node during the overall life of the application. </span><span class="koboSpan" id="kobo.69.2">They can be moved to other nodes, but they must be moved together. </span><span class="koboSpan" id="kobo.69.3">This means that they can easily communicate through localhost ports. </span><span class="koboSpan" id="kobo.69.4">Communication between different Pods, however, is more complex since the IP addresses of Pods are ephemeral resources because Pods have no fixed node where they run, but rather are moved from one node to another by the orchestrator. </span><span class="koboSpan" id="kobo.69.5">Moreover, Pods may be replicated to increase performance, so, in general, it makes no sense to address a message to a specific Pod; instead, we address it to any of the identical replicas of the same Pod.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.70.1">Cluster nodes and Pods are managed by master nodes that communicate with cluster administrators through </span><a id="_idIndexMarker1445"/><span class="koboSpan" id="kobo.71.1">an API server, as shown in the following diagram:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.72.1"><img alt="" role="presentation" src="../Images/B19820_20_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.73.1">Figure 20.2: Kubernetes cluster</span></p>
<p class="normal"><span class="koboSpan" id="kobo.74.1">The scheduler allocates Pods to nodes according to the administrator constraints, while the controller manager groups several daemons that monitor the cluster’s actual state and try to move it toward the desired state declared through the API server. </span><span class="koboSpan" id="kobo.74.2">There are controllers for several Kubernetes resources, from Pod replicas to communication facilities. </span><span class="koboSpan" id="kobo.74.3">In fact, each resource has some target objectives to be maintained while the application runs, and the controller verifies these objectives are actually achieved, possibly triggering corrective actions if not, such as moving some Pods running too slowly to less crowded nodes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.75.1">The kubelet manages the interaction of each non-master node with the master nodes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.76.1">In Kubernetes, communication</span><a id="_idIndexMarker1446"/><span class="koboSpan" id="kobo.77.1"> between Pods is handled by resources called </span><strong class="keyWord"><span class="koboSpan" id="kobo.78.1">Services</span></strong><span class="koboSpan" id="kobo.79.1"> that are </span><a id="_idIndexMarker1447"/><span class="koboSpan" id="kobo.80.1">assigned virtual addresses by the Kubernetes infrastructure and that forward their communications to sets of identical Pods. </span><span class="koboSpan" id="kobo.80.2">In short, Services are Kubernetes’ way of assigning consistent virtual addresses to sets of Pod replicas.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.81.1">All Kubernetes entities may be assigned name-value</span><a id="_idIndexMarker1448"/><span class="koboSpan" id="kobo.82.1"> pairs called </span><strong class="keyWord"><span class="koboSpan" id="kobo.83.1">labels</span></strong><span class="koboSpan" id="kobo.84.1"> that are used to reference them through a pattern-matching mechanism. </span><span class="koboSpan" id="kobo.84.2">More specifically, Selectors select Kubernetes entities by listing labels they must have.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.85.1">Thus, for instance, all Pods that receive traffic from the same Service are selected by specifying labels that they must have in the Service definition.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.86.1">The way a Service routes its traffic to all connected Pods depends on the way Pods are organized. </span><span class="koboSpan" id="kobo.86.2">Stateless Pods are organized in so-called </span><code class="inlineCode"><span class="koboSpan" id="kobo.87.1">ReplicaSets</span></code><span class="koboSpan" id="kobo.88.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.89.1">ReplicaSets</span></code><span class="koboSpan" id="kobo.90.1"> have a unique virtual address assigned to the whole group and traffic is split equally among all Pods of the group.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.91.1">Stateful Kubernetes Pod replicas are organized into so-called </span><code class="inlineCode"><span class="koboSpan" id="kobo.92.1">StatefulSets</span></code><span class="koboSpan" id="kobo.93.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.94.1">StatefulSets</span></code><span class="koboSpan" id="kobo.95.1"> use sharding to split the traffic between all their Pods. </span><span class="koboSpan" id="kobo.95.2">For this reason, Kubernetes Services assign a different name to each Pod of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.96.1">StatefulSet</span></code><span class="koboSpan" id="kobo.97.1"> they are connected to. </span><span class="koboSpan" id="kobo.97.2">These names look like the following: </span><code class="inlineCode"><span class="koboSpan" id="kobo.98.1">basename-0.&lt;base URL&gt;</span></code><span class="koboSpan" id="kobo.99.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.100.1">basename-1.&lt;base URL&gt;</span></code><span class="koboSpan" id="kobo.101.1">, ..., </span><code class="inlineCode"><span class="koboSpan" id="kobo.102.1">basename-n.&lt;base URL&gt;</span></code><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">This way, message sharding is easily accomplished as follows:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.104.1">Each time a message must be sent to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.105.1">StatefulSet</span></code><span class="koboSpan" id="kobo.106.1"> composed of </span><em class="italic"><span class="koboSpan" id="kobo.107.1">N</span></em><span class="koboSpan" id="kobo.108.1"> replicas, you compute a hash between </span><code class="inlineCode"><span class="koboSpan" id="kobo.109.1">0</span></code><span class="koboSpan" id="kobo.110.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.111.1">N-1</span></code><span class="koboSpan" id="kobo.112.1">, say </span><code class="inlineCode"><span class="koboSpan" id="kobo.113.1">X</span></code><span class="koboSpan" id="kobo.114.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.115.1">Add the postfix </span><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">X</span></code><span class="koboSpan" id="kobo.117.1"> to a base name to get a cluster address, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.118.1">basename-x.&lt;base URL&gt;</span></code><span class="koboSpan" id="kobo.119.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.120.1">Send the message to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.121.1">basename-x.&lt;base URL&gt; cluster address</span></code><span class="koboSpan" id="kobo.122.1">.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.123.1">Kubernetes has no predefined storing facilities, and you can’t use node disk storage since Pods are moved between the available nodes, so long-term storage must be provided with sharded cloud databases or with other kinds of cloud storage. </span><span class="koboSpan" id="kobo.123.2">While each Pod in a StatefulSet can access a sharded cloud database with the usual connection string technique, Kubernetes offers a technique to abstract disk-like cloud storage provided by the external Kubernetes cluster environment. </span><span class="koboSpan" id="kobo.123.3">We will describe this storage in the </span><em class="italic"><span class="koboSpan" id="kobo.124.1">Advanced Kubernetes concepts</span></em><span class="koboSpan" id="kobo.125.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.126.1">All Kubernetes entities </span><a id="_idIndexMarker1449"/><span class="koboSpan" id="kobo.127.1">mentioned in this short introduction can be defined in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.128.1">.yaml</span></code><span class="koboSpan" id="kobo.129.1"> file, which, once deployed to a Kubernetes cluster, causes the creation of all entities defined in the file. </span><span class="koboSpan" id="kobo.129.2">The subsection that follows describes </span><code class="inlineCode"><span class="koboSpan" id="kobo.130.1">.yaml</span></code><span class="koboSpan" id="kobo.131.1"> files, while the other subsections thereafter describe in detail all the basic Kubernetes objects mentioned so far, and explain how to define them in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.132.1">.yaml</span></code><span class="koboSpan" id="kobo.133.1"> file. </span><span class="koboSpan" id="kobo.133.2">Other Kubernetes objects will be described throughout the chapter.</span></p>
<h2 class="heading-2" id="_idParaDest-414"><span class="koboSpan" id="kobo.134.1">.yaml files</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.135.1">The desired configuration of a </span><a id="_idIndexMarker1450"/><span class="koboSpan" id="kobo.136.1">cluster and the structure of Kubernetes objects are described by the </span><a id="_idIndexMarker1451"/><span class="koboSpan" id="kobo.137.1">developer with a language called YAML, and are packaged in files with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.138.1">.yaml</span></code><span class="koboSpan" id="kobo.139.1"> extension.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.140.1">.yaml</span></code><span class="koboSpan" id="kobo.141.1"> files, like JSON files, can be used to describe nested objects and collections in a human-readable way, but they do it with a different syntax. </span><span class="koboSpan" id="kobo.141.2">You have objects and lists, but object properties are not surrounded by </span><code class="inlineCode"><span class="koboSpan" id="kobo.142.1">{}</span></code><span class="koboSpan" id="kobo.143.1">, and lists are not surrounded by </span><code class="inlineCode"><span class="koboSpan" id="kobo.144.1">[]</span></code><span class="koboSpan" id="kobo.145.1">. </span><span class="koboSpan" id="kobo.145.2">Instead, nested objects are declared by simply indenting their content with spaces. </span><span class="koboSpan" id="kobo.145.3">The number of spaces can be freely chosen, but once they’ve been chosen, they must be used consistently.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.146.1">List items can be distinguished from object properties by preceding them with a hyphen (</span><code class="inlineCode"><span class="koboSpan" id="kobo.147.1">-</span></code><span class="koboSpan" id="kobo.148.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.149.1">Here is an example involving nested objects and collections:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.150.1">Name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.151.1">John</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.152.1">Surname:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.153.1">Smith</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.154.1">Spouse:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.155.1">Name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.156.1">Mary</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.157.1">Surname:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.158.1">Smith</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.159.1">Addresses:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.160.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.161.1">Type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.162.1">home</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.163.1">Country:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.164.1">England</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.165.1">Town:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.166.1">London</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.167.1">Street:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.168.1">My</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.169.1">home</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.170.1">street</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.171.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.172.1">Type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.173.1">office</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.174.1">Country:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.175.1">England</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.176.1">Town:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.177.1">London</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.178.1">Street:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.179.1">My</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.180.1">home</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.181.1">street</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.182.1">The </span><a id="_idIndexMarker1452"/><span class="koboSpan" id="kobo.183.1">preceding </span><code class="inlineCode"><span class="koboSpan" id="kobo.184.1">Person</span></code><span class="koboSpan" id="kobo.185.1"> object has a </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">Spouse</span></code><span class="koboSpan" id="kobo.187.1"> nested object and a nested collection of addresses.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.188.1">The same example</span><a id="_idIndexMarker1453"/><span class="koboSpan" id="kobo.189.1"> in JSON would be:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.190.1">{
</span><span class="hljs-attr"><span class="koboSpan" id="kobo.191.1">Name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.192.1">John</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.193.1">Surname:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.194.1">Smith</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.195.1">Spouse:</span></span><span class="koboSpan" id="kobo.196.1">
{
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.197.1">Name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.198.1">Mary</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.199.1">Surname:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.200.1">Smith</span></span><span class="koboSpan" id="kobo.201.1">
}
</span><span class="hljs-attr"><span class="koboSpan" id="kobo.202.1">Addresses:</span></span><span class="koboSpan" id="kobo.203.1">
[
 {
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.204.1">Type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.205.1">home</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.206.1">Country:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.207.1">England</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.208.1">Town:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.209.1">London</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.210.1">Street:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.211.1">My</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.212.1">home</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.213.1">street</span></span><span class="koboSpan" id="kobo.214.1">
 },
 {
  </span><span class="hljs-attr"><span class="koboSpan" id="kobo.215.1">Type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.216.1">office</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.217.1">Country:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.218.1">England</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.219.1">Town:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.220.1">London</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.221.1">Street:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.222.1">My</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.223.1">home</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.224.1">street</span></span><span class="koboSpan" id="kobo.225.1">
 }
]
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.226.1">As you can see, the syntax is more readable, since it avoids the overhead of parentheses.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.227.1">.yaml</span></code><span class="koboSpan" id="kobo.228.1"> files can contain several sections, each defining a different entity, that are separated by a line containing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.229.1">---</span></code><span class="koboSpan" id="kobo.230.1"> string. </span><span class="koboSpan" id="kobo.230.2">Comments are preceded by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.231.1">#</span></code><span class="koboSpan" id="kobo.232.1"> symbol, which must be repeated on each comment line.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.233.1">Each section starts with the declaration of the Kubernetes API group and version. </span><span class="koboSpan" id="kobo.233.2">In fact, not all objects belong to the same API group. </span><span class="koboSpan" id="kobo.233.3">For objects that belong to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.234.1">core</span></code><span class="koboSpan" id="kobo.235.1"> API group, we can specify just the </span><a id="_idIndexMarker1454"/><span class="koboSpan" id="kobo.236.1">API version, as in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.237.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.238.1">v1</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.239.1">While objects belonging</span><a id="_idIndexMarker1455"/><span class="koboSpan" id="kobo.240.1"> to different API groups must also specify the API name, as in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.241.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.242.1">apps/v1</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.243.1">In the next subsection, we analyze ReplicaSets and the Deployments that are built on top of them.</span></p>
<h2 class="heading-2" id="_idParaDest-415"><span class="koboSpan" id="kobo.244.1">ReplicaSets and Deployments</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.245.1">The most important building block of</span><a id="_idIndexMarker1456"/><span class="koboSpan" id="kobo.246.1"> Kubernetes applications is the ReplicaSet, that is, a Pod replicated </span><em class="italic"><span class="koboSpan" id="kobo.247.1">N</span></em><span class="koboSpan" id="kobo.248.1"> times. </span><span class="koboSpan" id="kobo.248.2">Usually, however, you use a more complex object that is built on top of the ReplicaSet – the Deployment. </span><span class="koboSpan" id="kobo.248.3">Deployments not only create a ReplicaSet, but also monitor them to ensure that the number of replicas is kept constant regardless of hardware faults and other events that might involve the ReplicaSets. </span><span class="koboSpan" id="kobo.248.4">In other words, they are a declarative way of defining ReplicaSets and Pods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.249.1">Replicating the same functionalities, and thus the same Pods, is the simplest operation to optimize for performance: the more replicas we create of the same Pod, the more hardware resources and threads must be made available for the functionality encoded by that Pod. </span><span class="koboSpan" id="kobo.249.2">Thus, when we discover that a functionality becomes a bottleneck in the system, we may just increase the number of replicas of the Pod that encodes that functionality.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.250.1">Each Deployment has a name (</span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">metadata-&gt;name</span></code><span class="koboSpan" id="kobo.252.1">), an attribute that specifies the desired number of replicas (</span><code class="inlineCode"><span class="koboSpan" id="kobo.253.1">spec-&gt;replicas</span></code><span class="koboSpan" id="kobo.254.1">), a key-value pair (</span><code class="inlineCode"><span class="koboSpan" id="kobo.255.1">spec -&gt; selector-&gt; matchLabels</span></code><span class="koboSpan" id="kobo.256.1">) that selects the Pods to monitor, and a template (</span><code class="inlineCode"><span class="koboSpan" id="kobo.257.1">spec-&gt;template</span></code><span class="koboSpan" id="kobo.258.1">) that specifies how to build the Pod replicas:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.259.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.260.1">apps/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.261.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.262.1">Deployment</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.263.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.264.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.265.1">my-deployment-name</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.266.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.267.1">my-namespace</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.268.1">#this is optional</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.269.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.270.1">replicas:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.271.1">3</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.272.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.273.1">matchLabels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.274.1">my-pod-label-name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.275.1">my-pod-label-value</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.276.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.277.1">template:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.278.1">...</span></span>
</code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.279.1">namespace</span></code><span class="koboSpan" id="kobo.280.1"> is optional and, if not provided, a namespace called </span><code class="inlineCode"><span class="koboSpan" id="kobo.281.1">default</span></code><span class="koboSpan" id="kobo.282.1"> is assumed. </span><span class="koboSpan" id="kobo.282.2">Namespaces are a way of keeping separate the objects of a Kubernetes cluster. </span><span class="koboSpan" id="kobo.282.3">For instance, a cluster can host </span><a id="_idIndexMarker1457"/><span class="koboSpan" id="kobo.283.1">the objects of two completely independent applications, each placed in a separate </span><code class="inlineCode"><span class="koboSpan" id="kobo.284.1">namespace</span></code><span class="koboSpan" id="kobo.285.1"> in order to prevent possible name collisions. </span><span class="koboSpan" id="kobo.285.2">In a few words, Kubernetes namespaces have the same purpose as .NET namespaces: preventing name collisions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.286.1">Indented inside the template is the definition of the Pod to replicate. </span><span class="koboSpan" id="kobo.286.2">Complex objects such as Deployments can also contain other kinds of templates, for instance, a template of disk-like memory required by the external environment. </span><span class="koboSpan" id="kobo.286.3">We will discuss this in more detail in the </span><em class="italic"><span class="koboSpan" id="kobo.287.1">Advanced Kubernetes concepts</span></em><span class="koboSpan" id="kobo.288.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.289.1">In turn, the Pod template contains a </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">metadata</span></code><span class="koboSpan" id="kobo.291.1"> section with the labels used to select the Pods, and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.292.1">spec</span></code><span class="koboSpan" id="kobo.293.1"> section with a list of all of the containers:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.294.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.295.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.296.1">my-pod-label-name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.297.1">my-pod-label-value</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.298.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.299.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.300.1">containers:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.301.1">...</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.302.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.303.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.304.1">my-container-name</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.305.1">image:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.306.1">&lt;Docker</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.307.1">imagename&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.308.1">resources:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.309.1">requests:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.310.1">cpu:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.311.1">100m</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.312.1">memory:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.313.1">128Mi</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.314.1">limits:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.315.1">cpu:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.316.1">250m</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.317.1">memory:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.318.1">256Mi</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.319.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.320.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.321.1">containerPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.322.1">6379</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.323.1">env:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.324.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.325.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.326.1">env-name</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.327.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.328.1">env-value</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.329.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.330.1">Each container has a name and must specify the name of the Docker image to use to create the containers. </span><span class="koboSpan" id="kobo.330.2">If the Docker image is not contained in the public Docker registry, the name must be a URI that also includes the repository’s location.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.331.1">Then, containers must </span><a id="_idIndexMarker1458"/><span class="koboSpan" id="kobo.332.1">specify the memory and CPU resources that they need to be created in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.333.1">resources-&gt;requests</span></code><span class="koboSpan" id="kobo.334.1"> object. </span><span class="koboSpan" id="kobo.334.2">A Pod replica is created only if these resources are currently available. </span><span class="koboSpan" id="kobo.334.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.335.1">resources-&gt;limits</span></code><span class="koboSpan" id="kobo.336.1"> object, instead, specifies the maximum resources a container replica can use. </span><span class="koboSpan" id="kobo.336.2">If, during the container execution, these limits are exceeded, action is taken to limit them. </span><span class="koboSpan" id="kobo.336.3">More specifically, if the CPU limit is exceeded, the container is throttled (its execution is stopped to restore its CPU consumption), while, if the memory limits are exceeded, the container is restarted. </span><code class="inlineCode"><span class="koboSpan" id="kobo.337.1">containerPort</span></code><span class="koboSpan" id="kobo.338.1"> must be the port exposed by the container. </span><span class="koboSpan" id="kobo.338.2">Here, we can also specify further information, such as the protocol used.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.339.1">CPU time is expressed in millicores; </span><code class="inlineCode"><span class="koboSpan" id="kobo.340.1">1,000</span></code><span class="koboSpan" id="kobo.341.1"> millicores means </span><code class="inlineCode"><span class="koboSpan" id="kobo.342.1">100%</span></code><span class="koboSpan" id="kobo.343.1"> of the CPU time, while memory is expressed in mebibytes (</span><code class="inlineCode"><span class="koboSpan" id="kobo.344.1">1Mi</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.345.1">=</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.346.1">1,024*1,024 bytes</span></code><span class="koboSpan" id="kobo.347.1">), or other units. </span><code class="inlineCode"><span class="koboSpan" id="kobo.348.1">env</span></code><span class="koboSpan" id="kobo.349.1"> lists all the operating system environment variables to pass to the containers with their values.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.350.1">Both containers and Pod templates can contain other fields, such as properties that define virtual files, and properties that define commands that return the readiness and the health state of the container. </span><span class="koboSpan" id="kobo.350.2">We will analyze these fields in the </span><em class="italic"><span class="koboSpan" id="kobo.351.1">Advanced Kubernetes concepts</span></em><span class="koboSpan" id="kobo.352.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.353.1">The following subsection describes Pod sets conceived to store state information.</span></p>
<h2 class="heading-2" id="_idParaDest-416"><span class="koboSpan" id="kobo.354.1">StatefulSets</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.355.1">StatefulSets are very similar</span><a id="_idIndexMarker1459"/><span class="koboSpan" id="kobo.356.1"> to ReplicaSets, but while the Pods of a ReplicaSet are indistinguishable </span><a id="_idIndexMarker1460"/><span class="koboSpan" id="kobo.357.1">processors that contribute in parallel to the same workload through load-balancing strategies, Pods in a StatefulSet have a unique identity and can contribute to the same workload only through sharding. </span><span class="koboSpan" id="kobo.357.2">This is because StatefulSets were conceived to store information, and information cannot be stored in parallel, merely split among several stores through sharding.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.358.1">For the same reason, each Pod instance is always kept tied to any virtual disk space it requires (see the </span><em class="italic"><span class="koboSpan" id="kobo.359.1">Advanced Kubernetes concepts</span></em><span class="koboSpan" id="kobo.360.1"> section) so that each Pod instance is responsible for writing to a specific store.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.361.1">Moreover, StatefulSets’ Pod instances have ordinal numbers attached to them. </span><span class="koboSpan" id="kobo.361.2">They are started in sequence according to these</span><a id="_idIndexMarker1461"/><span class="koboSpan" id="kobo.362.1"> numbers, and they are stopped in reverse order. </span><span class="koboSpan" id="kobo.362.2">If the StatefulSet contains </span><em class="italic"><span class="koboSpan" id="kobo.363.1">N</span></em><span class="koboSpan" id="kobo.364.1"> replicas, these numbers go from </span><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">0</span></code><span class="koboSpan" id="kobo.366.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.367.1">N-1</span></code><span class="koboSpan" id="kobo.368.1">. </span><span class="koboSpan" id="kobo.368.2">Moreover, a unique name for each instance is obtained by chaining the Pod name specified in the template with the instance </span><a id="_idIndexMarker1462"/><span class="koboSpan" id="kobo.369.1">ordinal, in the following way – </span><code class="inlineCode"><span class="koboSpan" id="kobo.370.1">&lt;pod name&gt;-&lt;instance ordinal&gt;</span></code><span class="koboSpan" id="kobo.371.1">. </span><span class="koboSpan" id="kobo.371.2">Thus, instance names will be something like </span><code class="inlineCode"><span class="koboSpan" id="kobo.372.1">mypodname-0</span></code><span class="koboSpan" id="kobo.373.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.374.1">mypodname-1</span></code><span class="koboSpan" id="kobo.375.1">, and so on. </span><span class="koboSpan" id="kobo.375.2">As we will see in the </span><em class="italic"><span class="koboSpan" id="kobo.376.1">Services</span></em><span class="koboSpan" id="kobo.377.1"> subsection, instance names are used to build unique cluster network URIs for all instances, so that other Pods can communicate with a specific instance of a StateFulSet Pod.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.378.1">Since Pods in a StateFulSet have memory, each of them can only serve the requests that can be processed with the data contained in them. </span><span class="koboSpan" id="kobo.378.2">Therefore, in order to take advantage of several Pods in a StatefulSets, we must share the whole data space in easy-to-compute subsets. </span><span class="koboSpan" id="kobo.378.3">This</span><a id="_idIndexMarker1463"/><span class="koboSpan" id="kobo.379.1"> technique is called sharding. </span><span class="koboSpan" id="kobo.379.2">For instance, Pods of a StatefulSet that handle customers could each be assigned a different set of customer names according to their first letters. </span><span class="koboSpan" id="kobo.379.3">One could handle all customers whose names start with letters in the interval A-C, another the names in the interval D-F, and so on.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.380.1">Here is a typical StatefulSet definition:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.381.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.382.1">apps/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.383.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.384.1">StatefulSet</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.385.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.386.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.387.1">my-stateful-set-name</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.388.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.389.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.390.1">matchLabels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.391.1">my-pod-label-name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.392.1">my-pod-label-value</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.393.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.394.1">serviceName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.395.1">"my-service-name"</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.396.1">replicas:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.397.1">3</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.398.1">template:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.399.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.400.1">The template part is the same as that of Deployments. </span><span class="koboSpan" id="kobo.400.2">The main difference between StatefulSets and Deployments is the </span><code class="inlineCode"><span class="koboSpan" id="kobo.401.1">serviceName</span></code><span class="koboSpan" id="kobo.402.1"> field. </span><span class="koboSpan" id="kobo.402.2">This specifies the name of a service that must be connected with the StatefulSet to provide unique network addresses for all Pod instances. </span><span class="koboSpan" id="kobo.402.3">We will discuss this subject in more detail in the </span><em class="italic"><span class="koboSpan" id="kobo.403.1">Services </span></em><span class="koboSpan" id="kobo.404.1">subsection. </span><span class="koboSpan" id="kobo.404.2">Moreover, usually, StatefulSets use some form of storage. </span><span class="koboSpan" id="kobo.404.3">We will discuss this in detail in the </span><em class="italic"><span class="koboSpan" id="kobo.405.1">Advanced Kubernetes concepts</span></em><span class="koboSpan" id="kobo.406.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.407.1">It is also worth pointing out</span><a id="_idIndexMarker1464"/><span class="koboSpan" id="kobo.408.1"> that the default order of the creation and stop strategy of StatefulSets can be changed </span><a id="_idIndexMarker1465"/><span class="koboSpan" id="kobo.409.1">by specifying an explicit </span><code class="inlineCode"><span class="koboSpan" id="kobo.410.1">Parallel</span></code><span class="koboSpan" id="kobo.411.1"> value for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.412.1">spec-&gt;podManagementPolicy</span></code><span class="koboSpan" id="kobo.413.1"> property (the default value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.414.1">OrderedReady</span></code><span class="koboSpan" id="kobo.415.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.416.1">The following table summarizes the</span><a id="_idIndexMarker1466"/><span class="koboSpan" id="kobo.417.1"> differences between StatefulSets and</span><a id="_idIndexMarker1467"/><span class="koboSpan" id="kobo.418.1"> ReplicaSets:</span></p>
<table class="table-container" id="table001-5">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.419.1">Features</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.420.1">StatefulSets</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.421.1">ReplicaSets</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.422.1">Unique address for the whole set</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.423.1">No. </span><span class="koboSpan" id="kobo.423.2">Each Pod in the set has a different address and takes care of a different kind of requests. </span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.424.1">Yes. </span><span class="koboSpan" id="kobo.424.2">Pods in ReplicaSets are indistinguishable so each request can be served by any of them.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.425.1">Number of replicas can be increased during application lifetime</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.426.1">No. </span><span class="koboSpan" id="kobo.426.2">Since each Pod is in charge of a specific kind of requests and has a unique address, we can't add more Pods.</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.427.1">Yes. </span><span class="koboSpan" id="kobo.427.2">Since Pods are indistinguishable, more Pods can't cause problems, but just improve the performance of the whole set.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.428.1">Pods can store permanent data inside of them</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.429.1">Yes, they are designed for this. </span><span class="koboSpan" id="kobo.429.2">Requests are issued to Pods with the sharding technique. </span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.430.1">No, because they are designed to be undistinguishable, and storing a specific datum in a specific Pod would make a Pod different from the others in the set.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.431.1">Table 20.1: StataefulSets versus ReplicaSets</span></p>
<p class="normal"><span class="koboSpan" id="kobo.432.1">The following subsection describes how to provide stable network addresses to both ReplicaSets and StatefulSets.</span></p>
<h2 class="heading-2" id="_idParaDest-417"><span class="koboSpan" id="kobo.433.1">Services</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.434.1">Since Pod instances can be moved between nodes, they have no stable IP address attached to them. </span><span class="koboSpan" id="kobo.434.2">Services </span><a id="_idIndexMarker1468"/><span class="koboSpan" id="kobo.435.1">take care of assigning a unique and stable virtual address to a whole ReplicaSet and of load balancing the traffic to all its instances. </span><span class="koboSpan" id="kobo.435.2">Services are not </span><a id="_idIndexMarker1469"/><span class="koboSpan" id="kobo.436.1">software objects created in the cluster, but just an abstraction of the various settings and activities needed to implement their functionalities.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.437.1">Services work at level 4 of the protocol stack, so they understand protocols such as TCP, but they aren’t able to perform, for instance, HTTP-specific actions/transformations, such as ensuring a secure HTTPS connection. </span><span class="koboSpan" id="kobo.437.2">Therefore, if you need to install HTTPS certificates on the Kubernetes cluster, you need a more complex object that is capable of interacting at level 7 of the protocol stack. </span><span class="koboSpan" id="kobo.437.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.438.1">Ingress</span></code><span class="koboSpan" id="kobo.439.1"> object was conceived for this. </span><span class="koboSpan" id="kobo.439.2">We will discuss this in</span><a id="_idIndexMarker1470"/><span class="koboSpan" id="kobo.440.1"> the next subsection.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.441.1">Services also handle assigning a unique virtual address to each instance of a StatefulSet. </span><span class="koboSpan" id="kobo.441.2">In fact, there are various kinds of Services; some were conceived for ReplicaSets and others for StatefulSets.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.442.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.443.1">ClusterIP</span></code><span class="koboSpan" id="kobo.444.1"> service type is assigned a unique cluster internal IP address. </span><span class="koboSpan" id="kobo.444.2">It specifies the ReplicaSets or Deployments it is connected to through label pattern matching. </span><span class="koboSpan" id="kobo.444.3">It uses tables maintained by the Kubernetes infrastructure to load balance the traffic it receives between all the Pod instances to which it is connected.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.445.1">Therefore, other Pods can communicate with the Pods connected to a Service by interacting with this Service that is assigned the stable network name </span><code class="inlineCode"><span class="koboSpan" id="kobo.446.1">&lt;service name&gt;.&lt;service namespace&gt;.svc.cluster.local</span></code><span class="koboSpan" id="kobo.447.1">. </span><span class="koboSpan" id="kobo.447.2">Since they are just assigned local IP addresses, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.448.1">ClusterIP</span></code><span class="koboSpan" id="kobo.449.1"> service can’t be accessed from outside the Kubernetes cluster.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.450.1">A ClusterIP is the usual communication choice for Deployments and ReplicaSets that do not communicate with anything outside of their Kubernetes cluster.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.451.1">Here is the definition of a typical </span><code class="inlineCode"><span class="koboSpan" id="kobo.452.1">ClusterIP</span></code><span class="koboSpan" id="kobo.453.1"> service:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.454.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.455.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.456.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.457.1">Service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.458.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.459.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.460.1">my-service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.461.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.462.1">my-namespace</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.463.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.464.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.465.1">my-selector-label:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.466.1">my-selector-value</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.467.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.468.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.469.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.470.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.471.1">http</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.472.1">protocol:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.473.1">TCP</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.474.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.475.1">80</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.476.1">targetPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.477.1">9376</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.478.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.479.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.480.1">https</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.481.1">protocol:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.482.1">TCP</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.483.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.484.1">443</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.485.1">targetPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.486.1">9377</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.487.1">Each Service can work on several ports and can route any port (</span><code class="inlineCode"><span class="koboSpan" id="kobo.488.1">port</span></code><span class="koboSpan" id="kobo.489.1">) to the ports exposed by the containers (</span><code class="inlineCode"><span class="koboSpan" id="kobo.490.1">targetPort</span></code><span class="koboSpan" id="kobo.491.1">). </span><span class="koboSpan" id="kobo.491.2">However, it is very often the case that </span><code class="inlineCode"><span class="koboSpan" id="kobo.492.1">port = targetPort</span></code><span class="koboSpan" id="kobo.493.1">. </span><span class="koboSpan" id="kobo.493.2">Ports can be given names, but these names are optional. </span><span class="koboSpan" id="kobo.493.3">Also, the specification of the protocol is </span><a id="_idIndexMarker1471"/><span class="koboSpan" id="kobo.494.1">optional; when not explicitly specified, all supported level 4 protocols are allowed. </span><span class="koboSpan" id="kobo.494.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.495.1">spec-&gt;selector</span></code><span class="koboSpan" id="kobo.496.1"> property specifies all the name/value pairs that select the Pods for the</span><a id="_idIndexMarker1472"/><span class="koboSpan" id="kobo.497.1"> Service to which to route the communications it receives.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.498.1">Since a </span><code class="inlineCode"><span class="koboSpan" id="kobo.499.1">ClusterIP</span></code><span class="koboSpan" id="kobo.500.1"> service can’t be accessed from outside the Kubernetes cluster, we need other Service types to expose a Kubernetes application on a public IP address.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.501.1">NodePort</span></code><span class="koboSpan" id="kobo.502.1">-type Services are the simplest way to expose Pods to the outside world. </span><span class="koboSpan" id="kobo.502.2">In order to implement a </span><code class="inlineCode"><span class="koboSpan" id="kobo.503.1">NodePort</span></code><span class="koboSpan" id="kobo.504.1"> service, the same port </span><code class="inlineCode"><span class="koboSpan" id="kobo.505.1">x</span></code><span class="koboSpan" id="kobo.506.1"> is opened on all nodes of the Kubernetes cluster and each node routes the traffic it receives on this port to a newly created </span><code class="inlineCode"><span class="koboSpan" id="kobo.507.1">ClusterIP</span></code><span class="koboSpan" id="kobo.508.1"> service.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.509.1">In turn, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.510.1">ClusterIP</span></code><span class="koboSpan" id="kobo.511.1"> service routes its traffic to all Pods selected by the service:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.512.1"><img alt="Diagram  Description automatically generated" src="../Images/B19820_20_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.513.1">Figure 20.3: NodePort service</span></p>
<p class="normal"><span class="koboSpan" id="kobo.514.1">Therefore, you can simply</span><a id="_idIndexMarker1473"/><span class="koboSpan" id="kobo.515.1"> communicate with port </span><code class="inlineCode"><span class="koboSpan" id="kobo.516.1">x</span></code><span class="koboSpan" id="kobo.517.1"> through a public IP of any cluster node in order to access</span><a id="_idIndexMarker1474"/><span class="koboSpan" id="kobo.518.1"> the Pods connected to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.519.1">NodePort</span></code><span class="koboSpan" id="kobo.520.1"> service. </span><span class="koboSpan" id="kobo.520.2">Of course, the whole process is completely automatic and hidden from the developer, whose only preoccupation is getting the port number </span><code class="inlineCode"><span class="koboSpan" id="kobo.521.1">x</span></code><span class="koboSpan" id="kobo.522.1"> so they know where to forward the external traffic.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.523.1">The definition of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.524.1">NodePort</span></code><span class="koboSpan" id="kobo.525.1"> service is similar to the definition of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.526.1">ClusterIP</span></code><span class="koboSpan" id="kobo.527.1"> service, the only difference being that they specify a value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.528.1">NodePort</span></code><span class="koboSpan" id="kobo.529.1"> for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.530.1">spec-&gt;type</span></code><span class="koboSpan" id="kobo.531.1"> property:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.532.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.533.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.534.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.535.1">NodePort</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.536.1">selector:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.537.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.538.1">As a default, a node port </span><code class="inlineCode"><span class="koboSpan" id="kobo.539.1">x</span></code><span class="koboSpan" id="kobo.540.1"> in the range 30000-32767 is automatically chosen for each </span><code class="inlineCode"><span class="koboSpan" id="kobo.541.1">targetPort</span></code><span class="koboSpan" id="kobo.542.1"> specified by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.543.1">Service</span></code><span class="koboSpan" id="kobo.544.1">. </span><span class="koboSpan" id="kobo.544.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.545.1">port</span></code><span class="koboSpan" id="kobo.546.1"> property associated with each </span><code class="inlineCode"><span class="koboSpan" id="kobo.547.1">targetPort</span></code><span class="koboSpan" id="kobo.548.1"> is meaningless for </span><code class="inlineCode"><span class="koboSpan" id="kobo.549.1">NodePort</span></code><span class="koboSpan" id="kobo.550.1"> Services since all traffic passes through the selected node port </span><code class="inlineCode"><span class="koboSpan" id="kobo.551.1">x</span></code><span class="koboSpan" id="kobo.552.1">, and, by convention, is set to the same value as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.553.1">targetPort</span></code><span class="koboSpan" id="kobo.554.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.555.1">The developer can also set the NodePort </span><code class="inlineCode"><span class="koboSpan" id="kobo.556.1">x</span></code><span class="koboSpan" id="kobo.557.1"> directly through a </span><code class="inlineCode"><span class="koboSpan" id="kobo.558.1">nodePort</span></code><span class="koboSpan" id="kobo.559.1"> property:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.560.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.561.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.562.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.563.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.564.1">http</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.565.1">protocol:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.566.1">TCP</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.567.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.568.1">80</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.569.1">targetPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.570.1">80</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.571.1">nodePort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.572.1">30007</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.573.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.574.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.575.1">https</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.576.1">protocol:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.577.1">TCP</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.578.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.579.1">443</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.580.1">targetPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.581.1">443</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.582.1">nodePort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.583.1">30020</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.584.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.585.1">When the Kubernetes cluster is hosted on a cloud, the more convenient way to expose some Pods to the outside world is through a </span><code class="inlineCode"><span class="koboSpan" id="kobo.586.1">LoadBalancer</span></code><span class="koboSpan" id="kobo.587.1"> service, in which case the Kubernetes cluster is</span><a id="_idIndexMarker1475"/><span class="koboSpan" id="kobo.588.1"> exposed to the outside world through a level 4 load balancer of the selected cloud provider.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.589.1">A LoadBalancer is the usual communication choice for Deployments and ReplicaSets that do communicate outside of their Kubernetes cluster but don’t need advanced HTTP features.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.590.1">The definition of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.591.1">LoadBalancer</span></code><span class="koboSpan" id="kobo.592.1"> service</span><a id="_idIndexMarker1476"/><span class="koboSpan" id="kobo.593.1"> is similar to that of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.594.1">ClusterIp</span></code><span class="koboSpan" id="kobo.595.1"> service, the only difference being that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.596.1">spec-&gt;type</span></code><span class="koboSpan" id="kobo.597.1"> property must be set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.598.1">LoadBalancer</span></code><span class="koboSpan" id="kobo.599.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.600.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.601.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.602.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.603.1">LoadBalancer</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.604.1">selector:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.605.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.606.1">If no further specification is added, a dynamic public IP is randomly assigned. </span><span class="koboSpan" id="kobo.606.2">However, if a specific public IP address is required, it can be set as a public IP address for the cluster load balancer by specifying it in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.607.1">spec-&gt;loadBalancerIP</span></code><span class="koboSpan" id="kobo.608.1"> property:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.609.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.610.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.611.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.612.1">LoadBalancer</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.613.1">loadBalancerIP:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.614.1">&lt;your</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.615.1">public</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.616.1">ip&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.617.1">selector:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.618.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.619.1">In </span><strong class="keyWord"><span class="koboSpan" id="kobo.620.1">Azure Kubernetes Service</span></strong><span class="koboSpan" id="kobo.621.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.622.1">AKS</span></strong><span class="koboSpan" id="kobo.623.1">), you must also specify the resource group where the IP address was</span><a id="_idIndexMarker1477"/><span class="koboSpan" id="kobo.624.1"> allocated in an annotation:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.625.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.626.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.627.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.628.1">Service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.629.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.630.1">annotations:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.631.1">service.beta.kubernetes.io/azure-load-balancer-resource-group:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.632.1">&lt;IP</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.633.1">resource</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.634.1">group</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.635.1">name&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.636.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.637.1">my-service-name</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.638.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.639.1">In AKS, you can remain with a dynamic IP address, but you can get a public static domain name of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.640.1">&lt;my-service-label&gt;.&lt;location&gt;.cloudapp.azure.com</span></code><span class="koboSpan" id="kobo.641.1">, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.642.1">&lt;location&gt;</span></code><span class="koboSpan" id="kobo.643.1"> is the geographic label </span><a id="_idIndexMarker1478"/><span class="koboSpan" id="kobo.644.1">you have chosen for your resources. </span><code class="inlineCode"><span class="koboSpan" id="kobo.645.1">&lt;my-service-label&gt;</span></code><span class="koboSpan" id="kobo.646.1"> is a label that you have verified that makes the previous domain name unique. </span><span class="koboSpan" id="kobo.646.2">The chosen label must be declared in an annotation of your service, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.647.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.648.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.649.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.650.1">Service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.651.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.652.1">annotations:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.653.1">service.beta.kubernetes.io/azure-dns-label-name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.654.1">&lt;my-service-label&gt;</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.655.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.656.1">my-service-name</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.657.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.658.1">StatefulSets don’t need any load balancing since each Pod instance has its own identity, but do require a unique URL address for each Pod instance. </span><span class="koboSpan" id="kobo.658.2">This unique URL is provided by the so-called </span><strong class="keyWord"><span class="koboSpan" id="kobo.659.1">headless Services</span></strong><span class="koboSpan" id="kobo.660.1">. </span><span class="koboSpan" id="kobo.660.2">Headless </span><a id="_idIndexMarker1479"/><span class="koboSpan" id="kobo.661.1">Services are defined like </span><code class="inlineCode"><span class="koboSpan" id="kobo.662.1">ClusterIP</span></code><span class="koboSpan" id="kobo.663.1"> services, the only difference </span><a id="_idIndexMarker1480"/><span class="koboSpan" id="kobo.664.1">being that they have their </span><code class="inlineCode"><span class="koboSpan" id="kobo.665.1">spec-&gt;clusterIP</span></code><span class="koboSpan" id="kobo.666.1"> property set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.667.1">none</span></code><span class="koboSpan" id="kobo.668.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.669.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.670.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.671.1">clusterIP:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.672.1">none</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.673.1">selector:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.674.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.675.1">All StatefulSets handled by a headless Service must place the Service name in their </span><code class="inlineCode"><span class="koboSpan" id="kobo.676.1">spec-&gt; serviceName</span></code><span class="koboSpan" id="kobo.677.1"> property, as already stated in the </span><em class="italic"><span class="koboSpan" id="kobo.678.1">StatefulSets</span></em><span class="koboSpan" id="kobo.679.1"> subsection.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.680.1">The unique name provided by a headless Service to all </span><code class="inlineCode"><span class="koboSpan" id="kobo.681.1">StatefulSets</span></code><span class="koboSpan" id="kobo.682.1"> Pod instances it handles is </span><code class="inlineCode"><span class="koboSpan" id="kobo.683.1">&lt;unique pod name&gt;.&lt;service name&gt;.&lt;namespace&gt;.svc.cluster.local</span></code><span class="koboSpan" id="kobo.684.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.685.1">Services only understand low-level protocols, such as TCP/IP, but most web applications are situated on the more sophisticated HTTP protocol. </span><span class="koboSpan" id="kobo.685.2">That’s why Kubernetes offers higher-level entities called I</span><strong class="keyWord"><span class="koboSpan" id="kobo.686.1">ngresses</span></strong><span class="koboSpan" id="kobo.687.1"> that are</span><a id="_idIndexMarker1481"/><span class="koboSpan" id="kobo.688.1"> built on top of services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.689.1">Ingresses are</span><a id="_idIndexMarker1482"/><span class="koboSpan" id="kobo.690.1"> fundamental in the implementation of all web-based applications that need support for HTTP. </span><span class="koboSpan" id="kobo.690.2">Moreover, since at the moment, a substantial amount of applications are web applications, ingresses are a </span><strong class="keyWord"><span class="koboSpan" id="kobo.691.1">must</span></strong><span class="koboSpan" id="kobo.692.1"> for all microservices applications. </span><span class="koboSpan" id="kobo.692.2">In particular, they are needed by all microservices based on ASP.NET Core, which we will discuss in the remainder of the book.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.693.1">The following subsection describes these and explains how to expose a set of Pods through a level 7 protocol load balancer, which can be used to get access to typical HTTP services, instead of through a </span><code class="inlineCode"><span class="koboSpan" id="kobo.694.1">LoadBalancer</span></code><span class="koboSpan" id="kobo.695.1"> Service.</span></p>
<h2 class="heading-2" id="_idParaDest-418"><span class="koboSpan" id="kobo.696.1">Ingresses</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.697.1">Ingresses were conceived to enable each application running in a Kubernetes cluster to expose an HTTP-based interface. </span><span class="koboSpan" id="kobo.697.2">This is </span><a id="_idIndexMarker1483"/><span class="koboSpan" id="kobo.698.1">a fundamental requirement for any orchestrator, since nowadays all microservices applications are web applications that interact with their clients through HTTP-based protocols. </span><span class="koboSpan" id="kobo.698.2">Moreover, Ingresses must be very </span><a id="_idIndexMarker1484"/><span class="koboSpan" id="kobo.699.1">efficient since all communications with the Kubernetes cluster will pass through them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.700.1">Accordingly, ingresses offer all of the typical services offered by an advanced and efficient web server. </span><span class="koboSpan" id="kobo.700.2">They provide the following services:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.701.1">HTTPS termination. </span><span class="koboSpan" id="kobo.701.2">They accept HTTPS connections and route them in HTTP format to any service in the cluster.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.702.1">Name-based virtual hosting. </span><span class="koboSpan" id="kobo.702.2">They associate several domain names with the same IP address and route each domain, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.703.1">&lt;domain&gt;/&lt;path prefix&gt;</span></code><span class="koboSpan" id="kobo.704.1">, to a different cluster Service.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.705.1">Load balancing.</span></li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.706.1">An ingress is the usual communication choice for Deployments and ReplicaSets that do communicate outside of their Kubernetes cluster and need advanced HTTP features.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.707.1">Since rewriting all functionalities of an advanced web server from scratch would be substantially impossible, Ingresses rely on existing web servers to offer their services. </span><span class="koboSpan" id="kobo.707.2">More specifically, Kubernetes offers the possibility to add an interface module called Ingress Controllers to connect each Kubernetes cluster with an existing web server, such as NGINX and Apache.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.708.1">Ingress Controllers are custom</span><a id="_idIndexMarker1485"/><span class="koboSpan" id="kobo.709.1"> Kubernetes objects that must be installed in the cluster. </span><span class="koboSpan" id="kobo.709.2">They handle the interface between Kubernetes and the pre-existing web server software, which can be either an external web server or a web server that is part of the Ingress Controller installation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.710.1">We will describe the installation of an Ingress Controller based on the NGINX web server software in the </span><em class="italic"><span class="koboSpan" id="kobo.711.1">Advanced Kubernetes concepts</span></em><span class="koboSpan" id="kobo.712.1"> section, as an example of the use of Helm. </span><span class="koboSpan" id="kobo.712.2">However, there are Ingress Controllers for all main web servers. </span><span class="koboSpan" id="kobo.712.3">The </span><em class="italic"><span class="koboSpan" id="kobo.713.1">Further reading</span></em><span class="koboSpan" id="kobo.714.1"> section contains information on how to install also an Ingress Controller that interfaces an external Azure Application Gateway.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.715.1">HTTPS termination and name-based virtual hosting (see the explanation of these terms at the beginning of this subsection) can be configured in the Ingress definition in a way that is independent of the chosen Ingress Controller, while the way load balancing is achieved depends on the specific Ingress Controller chosen and on its configuration. </span><span class="koboSpan" id="kobo.715.2">Some Ingress Controller </span><a id="_idIndexMarker1486"/><span class="koboSpan" id="kobo.716.1">configuration data can be passed in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.717.1">metadata-&gt; annotations</span></code><span class="koboSpan" id="kobo.718.1"> field of the Ingress definition.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.719.1">Name-based virtual hosting is defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.720.1">spec-&gt; rules</span></code><span class="koboSpan" id="kobo.721.1"> section of the Ingress definition:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.722.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.723.1">spec:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.724.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.725.1">rules:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.726.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.727.1">host:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.728.1">*.mydomain.com</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.729.1">http:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.730.1">paths:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.731.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.732.1">path:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.733.1">/</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.734.1">pathType:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.735.1">Prefix</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.736.1">backend:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.737.1">service:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.738.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.739.1">my-service-name</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.740.1">port:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.741.1">number:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.742.1">80</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.743.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.744.1">host:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.745.1">my-subdomain.anotherdomain.com</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.746.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.747.1">Each rule specifies an optional hostname that can contain the </span><code class="inlineCode"><span class="koboSpan" id="kobo.748.1">*</span></code><span class="koboSpan" id="kobo.749.1"> wildcard. </span><span class="koboSpan" id="kobo.749.2">If no hostname is provided, the rule matches all hostnames. </span><span class="koboSpan" id="kobo.749.3">For each rule, we can specify several paths, each redirected to a different service/port pair, where the service is referenced through its</span><a id="_idIndexMarker1487"/><span class="koboSpan" id="kobo.750.1"> name. </span><span class="koboSpan" id="kobo.750.2">The way the match with each </span><code class="inlineCode"><span class="koboSpan" id="kobo.751.1">path</span></code><span class="koboSpan" id="kobo.752.1"> is carried out depends on the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.753.1">pathType</span></code><span class="koboSpan" id="kobo.754.1">; if this value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.755.1">Prefix</span></code><span class="koboSpan" id="kobo.756.1">, the specified </span><code class="inlineCode"><span class="koboSpan" id="kobo.757.1">path</span></code><span class="koboSpan" id="kobo.758.1"> must be a prefix of any matching path. </span><span class="koboSpan" id="kobo.758.2">Otherwise, if this value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.759.1">Exact</span></code><span class="koboSpan" id="kobo.760.1">, the match must be exact. </span><span class="koboSpan" id="kobo.760.2">Matches are case-sensitive.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.761.1">HTTPS termination on a specific hostname is specified by associating it with a certificate encoded in a Kubernetes secret:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.762.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.763.1">spec:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.764.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.765.1">tls:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.766.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.767.1">hosts:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.768.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.769.1">www.mydomain.com</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.770.1">secretName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.771.1">my-certificate1</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.772.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.773.1">my-subdomain.anotherdomain.com</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.774.1">secretName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.775.1">my-certificate2</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.776.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.777.1">HTTPS certificates can be obtained free of charge at </span><a href="https://letsencrypt.org/"><span class="url"><span class="koboSpan" id="kobo.778.1">https://letsencrypt.org/</span></span></a><span class="koboSpan" id="kobo.779.1">. </span><span class="koboSpan" id="kobo.779.2">The procedure is explained on the website, but basically, as with all certificate authorities, you provide a key and they return the certificate based on that key. </span><span class="koboSpan" id="kobo.779.3">It is also possible to install a </span><strong class="keyWord"><span class="koboSpan" id="kobo.780.1">certificate manager</span></strong><span class="koboSpan" id="kobo.781.1"> that takes </span><a id="_idIndexMarker1488"/><span class="koboSpan" id="kobo.782.1">care of automatically installing and</span><a id="_idIndexMarker1489"/><span class="koboSpan" id="kobo.783.1"> renewing the certificate. </span><span class="koboSpan" id="kobo.783.2">The way a key/certificate pair is encoded in a Kubernetes secret string is detailed in the </span><em class="italic"><span class="koboSpan" id="kobo.784.1">Advanced Kubernetes concepts</span></em><span class="koboSpan" id="kobo.785.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.786.1">The whole Ingress definition is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.787.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.788.1">networking.k8s.io/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.789.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.790.1">Ingress</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.791.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.792.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.793.1">my-example-ingress</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.794.1">namespace:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.795.1">my-namespace</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.796.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.797.1">tls:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.798.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.799.1">rules:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.800.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.801.1">Here, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.802.1">namespace</span></code><span class="koboSpan" id="kobo.803.1"> is optional, and if not specified, is assumed to be </span><code class="inlineCode"><span class="koboSpan" id="kobo.804.1">default</span></code><span class="koboSpan" id="kobo.805.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.806.1">In the next section, we will </span><a id="_idIndexMarker1490"/><span class="koboSpan" id="kobo.807.1">put into practice some of the concepts explained here by defining an Azure Kubernetes cluster and deploying a simple application.</span></p>
<h1 class="heading-1" id="_idParaDest-419"><span class="koboSpan" id="kobo.808.1">Interacting with Kubernetes clusters</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.809.1">In this section, we will explain</span><a id="_idIndexMarker1491"/><span class="koboSpan" id="kobo.810.1"> both how to create an Azure Kubernetes cluster, and how to install minikube, a Kubernetes simulator, on your local machine. </span><span class="koboSpan" id="kobo.810.2">All examples can be run on both Azure Kubernetes and your local minikube instance.</span></p>
<h2 class="heading-2" id="_idParaDest-420"><span class="koboSpan" id="kobo.811.1">Creating an Azure Kubernetes cluster</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.812.1">To create an AKS cluster, do </span><a id="_idIndexMarker1492"/><span class="koboSpan" id="kobo.813.1">the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.814.1">Type </span><code class="inlineCode"><span class="koboSpan" id="kobo.815.1">AKS</span></code><span class="koboSpan" id="kobo.816.1"> into the Azure search box.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.817.1">Select </span><strong class="keyWord"><span class="koboSpan" id="kobo.818.1">Kubernetes services</span></strong><span class="koboSpan" id="kobo.819.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.820.1">Then click the </span><strong class="keyWord"><span class="koboSpan" id="kobo.821.1">Create</span></strong><span class="koboSpan" id="kobo.822.1"> button.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.823.1">After that, the following form will appear:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.824.1"><img alt="" role="presentation" src="../Images/B19820_20_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.825.1">Figure 20.4: Creating a Kubernetes cluster</span></p>
<p class="normal"><span class="koboSpan" id="kobo.826.1">It is worth mentioning that you can get help simply by hovering over any </span><a id="_idIndexMarker1493"/><span class="koboSpan" id="kobo.827.1"><img alt="" role="presentation" src="../Images/B19820_20_001.png"/></span><span class="koboSpan" id="kobo.828.1"> with the mouse.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.829.1">As usual, you are required to specify a subscription, resource group, and region. </span><span class="koboSpan" id="kobo.829.2">Then, you can choose a unique name (</span><strong class="keyWord"><span class="koboSpan" id="kobo.830.1">Kubernetes cluster name</span></strong><span class="koboSpan" id="kobo.831.1">) and the version of Kubernetes you would</span><a id="_idIndexMarker1494"/><span class="koboSpan" id="kobo.832.1"> like to use. </span><span class="koboSpan" id="kobo.832.2">For computational power, you are asked to select a machine template for each node (</span><strong class="keyWord"><span class="koboSpan" id="kobo.833.1">Node size</span></strong><span class="koboSpan" id="kobo.834.1">) and the number of nodes. </span><span class="koboSpan" id="kobo.834.2">While for an actual application, it is recommended to select at least three nodes, let’s select just two nodes for our exercise in order to save our free Azure credit. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.835.1">Moreover, the default virtual machine should also be set to a cheap one, so click </span><strong class="keyWord"><span class="koboSpan" id="kobo.836.1">Change size</span></strong><span class="koboSpan" id="kobo.837.1"> and select </span><strong class="keyWord"><span class="koboSpan" id="kobo.838.1">DS2 v2</span></strong><span class="koboSpan" id="kobo.839.1">. </span><span class="koboSpan" id="kobo.839.2">Finally, set </span><strong class="keyWord"><span class="koboSpan" id="kobo.840.1">Scale method</span></strong><span class="koboSpan" id="kobo.841.1"> to </span><strong class="keyWord"><span class="koboSpan" id="kobo.842.1">Manual</span></strong><span class="koboSpan" id="kobo.843.1"> to prevent the number of nodes from being automatically changed, which might quickly burn through your free Azure credit.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.844.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.845.1">Availability zones</span></strong><span class="koboSpan" id="kobo.846.1"> setting allows you to spread your nodes across several geographic zones for better fault tolerance. </span><span class="koboSpan" id="kobo.846.2">The default is three zones. </span><span class="koboSpan" id="kobo.846.3">Please change it to two zones since we have just two nodes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.847.1">After implementing the preceding changes, you should see the following settings:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.848.1"><img alt="Graphical user interface, text, application, email  Description automatically generated" src="../Images/B19820_20_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.849.1">Figure 20.5: Chosen settings</span></p>
<p class="normal"><span class="koboSpan" id="kobo.850.1">Now you can create your cluster by clicking the </span><strong class="keyWord"><span class="koboSpan" id="kobo.851.1">Review + create</span></strong><span class="koboSpan" id="kobo.852.1"> button. </span><span class="koboSpan" id="kobo.852.2">A review page should appear. </span><span class="koboSpan" id="kobo.852.3">Confirm and create the cluster.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.853.1">If you click </span><strong class="keyWord"><span class="koboSpan" id="kobo.854.1">Next</span></strong><span class="koboSpan" id="kobo.855.1"> instead of </span><strong class="keyWord"><span class="koboSpan" id="kobo.856.1">Review + create</span></strong><span class="koboSpan" id="kobo.857.1">, you can also define other node types, and then you can provide security information, namely, a </span><em class="italic"><span class="koboSpan" id="kobo.858.1">service principal</span></em><span class="koboSpan" id="kobo.859.1">, and specify whether you wish to enable role-based access control. </span><span class="koboSpan" id="kobo.859.2">In Azure, service principals are accounts that are associated with services you may use to define resource access policies. </span><span class="koboSpan" id="kobo.859.3">You may also change the default network settings and other settings.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.860.1">Deployment may take a little while (10-20 minutes). </span><span class="koboSpan" id="kobo.860.2">After that time, you will have your first Kubernetes cluster! </span><span class="koboSpan" id="kobo.860.3">At the end of the chapter, when the cluster is no longer required, please don’t forget to delete it in order to avoid wasting your free Azure credit.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.861.1">In the next subsection, you </span><a id="_idIndexMarker1495"/><span class="koboSpan" id="kobo.862.1">will learn how to install and use minikube, a single-node Kubernetes simulator, on your local machine.</span></p>
<h2 class="heading-2" id="_idParaDest-421"><span class="koboSpan" id="kobo.863.1">Using minikube</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.864.1">The easiest way to</span><a id="_idIndexMarker1496"/><span class="koboSpan" id="kobo.865.1"> install minikube is the usage of the Windows installer you can find </span><a id="_idIndexMarker1497"/><span class="koboSpan" id="kobo.866.1">in the official installation page: </span><a href="https://minikube.sigs.k8s.io/docs/start/"><span class="url"><span class="koboSpan" id="kobo.867.1">https://minikube.sigs.k8s.io/docs/start/</span></span></a><span class="koboSpan" id="kobo.868.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.869.1">During the installation you </span><a id="_idIndexMarker1498"/><span class="koboSpan" id="kobo.870.1">will be prompted on the kind of virtualization tool to use. </span><span class="koboSpan" id="kobo.870.2">If you already installed Docker Desktop and WSL, please specify Docker.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.871.1">If you have a different operating system, please follow the default choices, instead.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.872.1">The installation of Docker Desktop is explained in the technical requirements of </span><em class="italic"><span class="koboSpan" id="kobo.873.1">Chapter 11, Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.874.1">. </span><span class="koboSpan" id="kobo.874.2">Please note that both WSL and Docker Desktop must be installed and Docker must be configured to use Linux containers by default.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.875.1">Once you have minikube installed, you must add its binary to your computer </span><code class="inlineCode"><span class="koboSpan" id="kobo.876.1">PATH</span></code><span class="koboSpan" id="kobo.877.1">. </span><span class="koboSpan" id="kobo.877.2">The easiest way to do it is to open a PowerShell console and run the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.878.1">$oldPath=[Environment]::GetEnvironmentVariable('Path', [EnvironmentVariableTarget]::Machine)
if ($oldPath.Split(';') -inotcontains 'C:\minikube'){ '
 [Environment]::SetEnvironmentVariable('Path', $('{0};C:\minikube' -f $oldPath), [EnvironmentVariableTarget]::Machine) '
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.879.1">Once installed, your cluster can be run with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.880.1">minikube start
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.881.1">When you have finished working with the cluster, it can be stopped with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.882.1">minikube stop
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.883.1">In the next subsection, you</span><a id="_idIndexMarker1499"/><span class="koboSpan" id="kobo.884.1"> will learn how to interact with your minikube instance or Azure cluster through </span><a id="_idIndexMarker1500"/><span class="koboSpan" id="kobo.885.1">Kubernetes’ official client, kubectl.</span></p>
<h2 class="heading-2" id="_idParaDest-422"><span class="koboSpan" id="kobo.886.1">Using kubectl</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.887.1">Once you have created your </span><a id="_idIndexMarker1501"/><span class="koboSpan" id="kobo.888.1">Azure Kubernetes cluster, you </span><a id="_idIndexMarker1502"/><span class="koboSpan" id="kobo.889.1">can interact with it via the Azure Cloud Shell. </span><span class="koboSpan" id="kobo.889.2">Click on the console icon in the top right of your Azure portal page. </span><span class="koboSpan" id="kobo.889.3">The following screenshot shows the Azure Shell icon:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.890.1"><img alt="" role="presentation" src="../Images/B19820_20_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.891.1">Figure 20.6: Azure Shell icon</span></p>
<p class="normal"><span class="koboSpan" id="kobo.892.1">When prompted, select the </span><strong class="keyWord"><span class="koboSpan" id="kobo.893.1">Bash Shell</span></strong><span class="koboSpan" id="kobo.894.1">. </span><span class="koboSpan" id="kobo.894.2">Then you will be prompted to create a storage account, so confirm and create it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.895.1">We will use this shell to interact with our cluster. </span><span class="koboSpan" id="kobo.895.2">At the top of the shell there is a file icon that we will use to upload our </span><code class="inlineCode"><span class="koboSpan" id="kobo.896.1">.yaml</span></code><span class="koboSpan" id="kobo.897.1"> files:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.898.1"><img alt="Graphical user interface, application  Description automatically generated" src="../Images/B19820_20_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.899.1">Figure 20.7: How to upload files in Azure Cloud Shell</span></p>
<p class="normal"><span class="koboSpan" id="kobo.900.1">It is also possible to download a client called Azure CLI and to install it on your local machine (see </span><a href="https://docs.microsoft.com/en-US/cli/azure/install-azure-cli"><span class="url"><span class="koboSpan" id="kobo.901.1">https://docs.microsoft.com/en-US/cli/azure/install-azure-cli</span></span></a><span class="koboSpan" id="kobo.902.1">), but, in this case, you also need to install all the</span><a id="_idIndexMarker1503"/><span class="koboSpan" id="kobo.903.1"> tools needed to interact with the Kubernetes cluster (kubectl and Helm) that are pre-installed in Azure Cloud Shell.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.904.1">Once you’ve created a Kubernetes cluster, you can interact with it through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.905.1">kubectl</span></code><span class="koboSpan" id="kobo.906.1"> command-line tool. </span><code class="inlineCode"><span class="koboSpan" id="kobo.907.1">kubectl</span></code><span class="koboSpan" id="kobo.908.1"> is integrated into Azure Cloud Shell, so you just need to activate your cluster credentials </span><a id="_idIndexMarker1504"/><span class="koboSpan" id="kobo.909.1">to use it. </span><span class="koboSpan" id="kobo.909.2">You can do this with the following Azure Cloud Shell command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.910.1">az aks get-credentials --resource-group &lt;resource group&gt; --name &lt;cluster name&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.911.1">The preceding command stores the credentials that were automatically created to enable your interaction</span><a id="_idIndexMarker1505"/><span class="koboSpan" id="kobo.912.1"> with the cluster in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.913.1">/.kube/config</span></code><span class="koboSpan" id="kobo.914.1"> configuration file. </span><span class="koboSpan" id="kobo.914.2">From now on, you can issue your </span><code class="inlineCode"><span class="koboSpan" id="kobo.915.1">kubectl</span></code><span class="koboSpan" id="kobo.916.1"> commands with no further authentication.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.917.1">If, instead, you need to interact with your local minikube cluster, you need a local installation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.918.1">kubectl</span></code><span class="koboSpan" id="kobo.919.1">, but minikube installs it automatically for you.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.920.1">In order to use the automatically-installed </span><code class="inlineCode"><span class="koboSpan" id="kobo.921.1">kubectl</span></code><span class="koboSpan" id="kobo.922.1">, all </span><code class="inlineCode"><span class="koboSpan" id="kobo.923.1">kubectl</span></code><span class="koboSpan" id="kobo.924.1"> commands must be preceded by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.925.1">minikube</span></code><span class="koboSpan" id="kobo.926.1"> command and </span><code class="inlineCode"><span class="koboSpan" id="kobo.927.1">kubectl</span></code><span class="koboSpan" id="kobo.928.1"> must be followed by --. </span><span class="koboSpan" id="kobo.928.2">Thus, for instance, if you wanted to run the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.929.1">kubectl get all
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.930.1">Then you would have to write the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.931.1">minkube kubectl -- get all
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.932.1">In the remainder of the chapter, we will write commands that work on actual Kubernetes clusters such as Azure Kubernetes. </span><span class="koboSpan" id="kobo.932.2">Therefore, when using minikube, remember to replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.933.1">kubectl</span></code><span class="koboSpan" id="kobo.934.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.935.1">minikube kubectl</span></code><span class="koboSpan" id="kobo.936.1"> -- in your commands.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.937.1">If you issue the </span><code class="inlineCode"><span class="koboSpan" id="kobo.938.1">kubectl get nodes</span></code><span class="koboSpan" id="kobo.939.1"> command, you get a list of all your Kubernetes nodes. </span><span class="koboSpan" id="kobo.939.2">In general, </span><code class="inlineCode"><span class="koboSpan" id="kobo.940.1">kubectl get &lt;object type&gt;</span></code><span class="koboSpan" id="kobo.941.1"> lists all objects of a given type. </span><span class="koboSpan" id="kobo.941.2">You can use it with </span><code class="inlineCode"><span class="koboSpan" id="kobo.942.1">nodes</span></code><span class="koboSpan" id="kobo.943.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.944.1">pods</span></code><span class="koboSpan" id="kobo.945.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.946.1">statefulset</span></code><span class="koboSpan" id="kobo.947.1">, and so on. </span><code class="inlineCode"><span class="koboSpan" id="kobo.948.1">kubectl get all</span></code><span class="koboSpan" id="kobo.949.1"> shows a list of all the objects created in your cluster. </span><span class="koboSpan" id="kobo.949.2">If you also add the name of a specific object, you will get information on just that specific object, as shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.950.1">kubectl get &lt;object type&gt;&lt;object name&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.951.1">If you add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.952.1">--watch</span></code><span class="koboSpan" id="kobo.953.1"> option, the object list will be continuously updated, so you can see the state of all the selected objects changing over time. </span><span class="koboSpan" id="kobo.953.2">You can leave this watch state by hitting </span><em class="italic"><span class="koboSpan" id="kobo.954.1">Ctrl</span></em><span class="koboSpan" id="kobo.955.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.956.1">C</span></em><span class="koboSpan" id="kobo.957.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.958.1">The following command shows a detailed report on a specific object:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.959.1">kubectl describe &lt;object name&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.960.1">All objects described in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.961.1">.yaml</span></code><span class="koboSpan" id="kobo.962.1"> file, say </span><code class="inlineCode"><span class="koboSpan" id="kobo.963.1">myClusterConfiguration.yaml</span></code><span class="koboSpan" id="kobo.964.1">, can be created with the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.965.1">kubectl create -f myClusterConfiguration.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.966.1">Then, if you modify the </span><code class="inlineCode"><span class="koboSpan" id="kobo.967.1">.yaml</span></code><span class="koboSpan" id="kobo.968.1"> file, you can reflect all the modifications in your cluster with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.969.1">apply</span></code><span class="koboSpan" id="kobo.970.1"> command, as shown</span><a id="_idIndexMarker1506"/><span class="koboSpan" id="kobo.971.1"> here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.972.1">kubectl apply -f myClusterConfiguration.yaml
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.973.1">apply</span></code><span class="koboSpan" id="kobo.974.1"> does the same job as </span><code class="inlineCode"><span class="koboSpan" id="kobo.975.1">create</span></code><span class="koboSpan" id="kobo.976.1"> but, if the resource already exists, </span><code class="inlineCode"><span class="koboSpan" id="kobo.977.1">apply</span></code><span class="koboSpan" id="kobo.978.1"> overrides it, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.979.1">create</span></code><span class="koboSpan" id="kobo.980.1"> exits with </span><a id="_idIndexMarker1507"/><span class="koboSpan" id="kobo.981.1">an error message.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.982.1">You can destroy all objects that were created with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.983.1">.yaml</span></code><span class="koboSpan" id="kobo.984.1"> file by passing the same file to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.985.1">delete</span></code><span class="koboSpan" id="kobo.986.1"> command, as shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.987.1">kubectl delete -f myClusterConfiguration.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.988.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.989.1">delete</span></code><span class="koboSpan" id="kobo.990.1"> command can also be passed an object type and a list of names of objects of that type to destroy, as shown in the following example:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.991.1">kubectl delete deployment deployment1 deployment2...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.992.1">The preceding </span><code class="inlineCode"><span class="koboSpan" id="kobo.993.1">kubectl</span></code><span class="koboSpan" id="kobo.994.1"> commands should suffice for most of your practical needs. </span><span class="koboSpan" id="kobo.994.2">For more details, the </span><em class="italic"><span class="koboSpan" id="kobo.995.1">Further reading</span></em><span class="koboSpan" id="kobo.996.1"> section contains a link to the official documentation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.997.1">In the next subsection, we will use </span><code class="inlineCode"><span class="koboSpan" id="kobo.998.1">kubectl create</span></code><span class="koboSpan" id="kobo.999.1"> to install a simple demo application.</span></p>
<h2 class="heading-2" id="_idParaDest-423"><span class="koboSpan" id="kobo.1000.1">Deploying the demo Guestbook application</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1001.1">The Guestbook application is a </span><a id="_idIndexMarker1508"/><span class="koboSpan" id="kobo.1002.1">demo application used in the</span><a id="_idIndexMarker1509"/><span class="koboSpan" id="kobo.1003.1"> examples in the official Kubernetes documentation. </span><span class="koboSpan" id="kobo.1003.2">We will use it as an example of a Kubernetes application since its Docker images are available in the public Docker repository, so we don’t need to write software.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1004.1">The Guestbook application stores the opinions of customers who visit a hotel or a restaurant.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1005.1">It is composed of a UI, and an in-memory database, based on Redis. </span><span class="koboSpan" id="kobo.1005.2">Moreover, updates are sent to the master copy </span><a id="_idIndexMarker1510"/><span class="koboSpan" id="kobo.1006.1">of the Redis database, which is automatically replicated in </span><em class="italic"><span class="koboSpan" id="kobo.1007.1">N</span></em><span class="koboSpan" id="kobo.1008.1"> read-only Redis replicas.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1009.1"><img alt="" role="presentation" src="../Images/B19820_20_08.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1010.1">Figure 20.8: Architecture of the Guestbook application</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1011.1">The UI application can be deployed in Kubernetes as a Deployment, since it is memoryless.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1012.1">The Redis master store is </span><a id="_idIndexMarker1511"/><span class="koboSpan" id="kobo.1013.1">deployed as a single pod </span><code class="inlineCode"><span class="koboSpan" id="kobo.1014.1">Deployment</span></code><span class="koboSpan" id="kobo.1015.1">. </span><span class="koboSpan" id="kobo.1015.2">We can’t implement it with an </span><em class="italic"><span class="koboSpan" id="kobo.1016.1">N</span></em><span class="koboSpan" id="kobo.1017.1">-pods </span><code class="inlineCode"><span class="koboSpan" id="kobo.1018.1">Deployment</span></code><span class="koboSpan" id="kobo.1019.1"> since we need sharding for parallelizing updates. </span><span class="koboSpan" id="kobo.1019.2">However, we might have used a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1020.1">StatefulSet</span></code><span class="koboSpan" id="kobo.1021.1"> assigning a different data shard to each different master Pod. </span><span class="koboSpan" id="kobo.1021.2">However, since this is your first Kubernetes exercise and since write operations should not be predominant, a single master database should suffice in the practical case of a single restaurant/hotel.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1022.1">Since all slave copies contain the same data and consequently are undistinguishable, they can be implemented with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1023.1">Deployment</span></code><span class="koboSpan" id="kobo.1024.1">, too.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1025.1">The whole application is </span><a id="_idIndexMarker1512"/><span class="koboSpan" id="kobo.1026.1">composed of three </span><code class="inlineCode"><span class="koboSpan" id="kobo.1027.1">.yaml</span></code><span class="koboSpan" id="kobo.1028.1"> files that you can find in the GitHub repository associated with this book (</span><a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E"><span class="url"><span class="koboSpan" id="kobo.1029.1">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</span></span></a><span class="koboSpan" id="kobo.1030.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1031.1">Here is the code for the</span><a id="_idIndexMarker1513"/><span class="koboSpan" id="kobo.1032.1"> master storage based on Redis that is contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1033.1">redis-master.yaml</span></code><span class="koboSpan" id="kobo.1034.1"> file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1035.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1036.1">apps/v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1037.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1038.1">Deployment</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1039.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1040.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1041.1">redis-master</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1042.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1043.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1044.1">redis</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1045.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1046.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1047.1">matchLabels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1048.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1049.1">redis</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1050.1">role:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1051.1">master</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1052.1">tier:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1053.1">backend</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1054.1">replicas:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1055.1">1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1056.1">template:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1057.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1058.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1059.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1060.1">redis</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1061.1">role:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1062.1">master</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1063.1">tier:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1064.1">backend</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1065.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1066.1">containers:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1067.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1068.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1069.1">master</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1070.1">image:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1071.1">docker.io/redis:6.0.5</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1072.1">resources:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1073.1">requests:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1074.1">cpu:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1075.1">100m</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1076.1">memory:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1077.1">100Mi</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1078.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1079.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1080.1">containerPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1081.1">6379</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1082.1">---</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1083.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1084.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1085.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1086.1">Service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1087.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1088.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1089.1">redis-leader</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1090.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1091.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1092.1">redis</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1093.1">role:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1094.1">master</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1095.1">tier:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1096.1">backend</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1097.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1098.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1099.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1100.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1101.1">6379</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1102.1">targetPort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1103.1">6379</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1104.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1105.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1106.1">redis</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1107.1">role:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1108.1">master</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1109.1">tier:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1110.1">backend</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1111.1">The file is composed of two object definitions separated by a line containing just </span><code class="inlineCode"><span class="koboSpan" id="kobo.1112.1">---</span></code><span class="koboSpan" id="kobo.1113.1">, that is, the object definition </span><a id="_idIndexMarker1514"/><span class="koboSpan" id="kobo.1114.1">separator of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1115.1">.yaml</span></code><span class="koboSpan" id="kobo.1116.1"> files. </span><span class="koboSpan" id="kobo.1116.2">It is common to group related objects, such as a Deployment with its associated Service, in the same file separated by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1117.1">---</span></code><span class="koboSpan" id="kobo.1118.1"> objects separator</span><a id="_idIndexMarker1515"/><span class="koboSpan" id="kobo.1119.1"> symbol in order to increase code readability.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1120.1">The first object is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1121.1">Deployment</span></code><span class="koboSpan" id="kobo.1122.1"> with a single replica, and the second object is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1123.1">ClusterIP</span></code><span class="koboSpan" id="kobo.1124.1"> Service that exposes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1125.1">Deployment</span></code><span class="koboSpan" id="kobo.1126.1"> on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1127.1">6379</span></code><span class="koboSpan" id="kobo.1128.1"> port at the internal </span><code class="inlineCode"><span class="koboSpan" id="kobo.1129.1">redis-leader.default.svc.cluster.local</span></code><span class="koboSpan" id="kobo.1130.1"> network address. </span><span class="koboSpan" id="kobo.1130.2">The Deployment pod template defines the three </span><code class="inlineCode"><span class="koboSpan" id="kobo.1131.1">app</span></code><span class="koboSpan" id="kobo.1132.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1133.1">role</span></code><span class="koboSpan" id="kobo.1134.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1135.1">tier</span></code><span class="koboSpan" id="kobo.1136.1"> labels with values that are used in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1137.1">selector</span></code><span class="koboSpan" id="kobo.1138.1"> definition of the Service to connect the Service with the unique Pod defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1139.1">Deployment</span></code><span class="koboSpan" id="kobo.1140.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1141.1">Let’s upload the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1142.1">redis-master.yaml</span></code><span class="koboSpan" id="kobo.1143.1"> file to Azure Cloud Shell, and then deploy it in the cluster with the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1144.1">kubectl create -f redis-master.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1145.1">Once the operation is complete, you can inspect the contents of the cluster with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1146.1">kubectl get all</span></code><span class="koboSpan" id="kobo.1147.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1148.1">The slave storage is defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1149.1">redis-slave.yaml</span></code><span class="koboSpan" id="kobo.1150.1"> file and is created in the same way, the only difference being that this time we have two replicas, and a different Docker image. </span><span class="koboSpan" id="kobo.1150.2">The full code is in the GitHub repository associated with this book.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1151.1">Let’s upload this file as well and deploy it with the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1152.1">kubectl create -f redis-slave.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1153.1">The code for the UI tier is contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1154.1">frontend.yaml</span></code><span class="koboSpan" id="kobo.1155.1"> file. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1156.1">Deployment</span></code><span class="koboSpan" id="kobo.1157.1"> has three replicas and a different</span><a id="_idIndexMarker1516"/><span class="koboSpan" id="kobo.1158.1"> Service type. </span><span class="koboSpan" id="kobo.1158.2">Let’s upload and deploy this file with the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1159.1">kubectl create -f frontend.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1160.1">It is worthwhile analyzing the Service code in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1161.1">frontend.yaml</span></code><span class="koboSpan" id="kobo.1162.1"> file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1163.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1164.1">v1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1165.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1166.1">Service</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1167.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1168.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1169.1">frontend</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1170.1">labels:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1171.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1172.1">guestbook</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1173.1">tier:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1174.1">frontend</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1175.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1176.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1177.1">LoadBalancer</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1178.1">ports:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1179.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1180.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1181.1">80</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1182.1">selector:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1183.1">app:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1184.1">guestbook</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1185.1">tier:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1186.1">frontend</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1187.1">Again, the full code is in the GitHub repository associated with the book.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1188.1">This Service is of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1189.1">LoadBalancer</span></code><span class="koboSpan" id="kobo.1190.1"> type. </span><span class="koboSpan" id="kobo.1190.2">Since this Pod is the application interface with the world outside of the Kubernetes </span><a id="_idIndexMarker1517"/><span class="koboSpan" id="kobo.1191.1">cluster, its service must have a fixed IP and must be load balanced. </span><span class="koboSpan" id="kobo.1191.2">Therefore, we must use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1192.1">LoadBalancer</span></code><span class="koboSpan" id="kobo.1193.1"> service since this is the unique service type that satisfies those requirements. </span><span class="koboSpan" id="kobo.1193.2">(See the </span><em class="italic"><span class="koboSpan" id="kobo.1194.1">Services</span></em><span class="koboSpan" id="kobo.1195.1"> section of this chapter for more information.)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1196.1">If you are in Azure Kubernetes or any other cloud Kubernetes service, in order to get the public IP address assigned to the service, and then to the application, use the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1197.1">kubectl get service
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1198.1">The preceding command should display information on all the installed services. </span><span class="koboSpan" id="kobo.1198.2">You should find the public IP in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1199.1">EXTERNAL-IP</span></code><span class="koboSpan" id="kobo.1200.1"> column of the list. </span><span class="koboSpan" id="kobo.1200.2">If you see only </span><code class="inlineCode"><span class="koboSpan" id="kobo.1201.1">&lt;none&gt;</span></code><span class="koboSpan" id="kobo.1202.1"> values, please repeat the command until the public IP address is assigned to the load balancer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1203.1">If no IP is assigned after</span><a id="_idIndexMarker1518"/><span class="koboSpan" id="kobo.1204.1"> a few minutes, please verify whether there is some error or warning in any of the service descriptions. </span><span class="koboSpan" id="kobo.1204.2">If not, please check whether all deployments are actually running using the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1205.1">kubectl get deployments
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1206.1">If, instead, you are on minikube, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1207.1">LoadBalancer</span></code><span class="koboSpan" id="kobo.1208.1"> services can be accessed by issuing this command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1209.1">minikube service &lt;service name&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1210.1">Thus, in our case:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1211.1">minikube service frontend
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1212.1">The command should automatically open the browser.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1213.1">Once you get the IP address, navigate with the browser to this address. </span><span class="koboSpan" id="kobo.1213.2">The application’s home page should now appear!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1214.1">If the page doesn’t appear, verify </span><a id="_idIndexMarker1519"/><span class="koboSpan" id="kobo.1215.1">whether any service has an error by issuing the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1216.1">kubectl get service
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1217.1">If not, also verify that all deployments are in the running state with the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1218.1">kubectl get deployments
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1219.1">If you find problems, please look for errors in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1220.1">.yaml</span></code><span class="koboSpan" id="kobo.1221.1"> files, correct them, and then update the object defined in the file with:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1222.1">kubectl update -f &lt;file name&gt;
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1223.1">Once you have finished experimenting with the application, make sure to remove the application from the cluster to avoid wasting your free Azure credit (public IP addresses cost money) with the following commands:</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1224.1">kubectl delete deployment frontend redis-master redis-slave</span></code></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1225.1">kubectl delete service frontend redis-leader redis-follower</span></code></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1226.1">In the next section, we will </span><a id="_idIndexMarker1520"/><span class="koboSpan" id="kobo.1227.1">analyze other important Kubernetes features.</span></p>
<h1 class="heading-1" id="_idParaDest-424"><span class="koboSpan" id="kobo.1228.1">Advanced Kubernetes concepts</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1229.1">In this section, we will discuss other important Kubernetes features, including how to assign permanent storage to</span><a id="_idIndexMarker1521"/><span class="koboSpan" id="kobo.1230.1"> StatefulSets; how to store secrets such as passwords, connection strings, or certificates; how a container can inform Kubernetes about its health state; and how to handle complex Kubernetes packages with Helm. </span><span class="koboSpan" id="kobo.1230.2">All of these subjects are organized into dedicated subsections. </span><span class="koboSpan" id="kobo.1230.3">We will start with the problem of permanent storage.</span></p>
<h2 class="heading-2" id="_idParaDest-425"><span class="koboSpan" id="kobo.1231.1">Requiring permanent storage</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1232.1">Since Pods are moved between </span><a id="_idIndexMarker1522"/><span class="koboSpan" id="kobo.1233.1">nodes, they can’t store data on the disk storage offered by the current node where they are running, or they would lose that storage as soon as they are moved to a different node. </span><span class="koboSpan" id="kobo.1233.2">This leaves us with two options:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1234.1">Using external databases</span></strong><span class="koboSpan" id="kobo.1235.1">: With the help of databases, ReplicaSets can also store information. </span><span class="koboSpan" id="kobo.1235.2">However, if we need better performance in terms of write/update operations, we should use distributed sharded databases based on non-SQL engines such as Cosmos DB or MongoDB (see </span><em class="italic"><span class="koboSpan" id="kobo.1236.1">Chapter 12</span></em><span class="koboSpan" id="kobo.1237.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1238.1">Choosing Your Data Storage in the Cloud</span></em><span class="koboSpan" id="kobo.1239.1">). </span><span class="koboSpan" id="kobo.1239.2">In this case, in order to take maximum advantage of table sharding, we need StatefulSets, where each Pod instance takes care of a different table shard.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.1240.1">Using cloud storage</span></strong><span class="koboSpan" id="kobo.1241.1">: Not being tied to a physical cluster node, cloud storage can be associated permanently with specific Pod instances of StatefulSets. </span><span class="koboSpan" id="kobo.1241.2">Cloud storage is discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.1242.1">Redis</span></em><span class="koboSpan" id="kobo.1243.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.1244.1">Azure storage accounts</span></em><span class="koboSpan" id="kobo.1245.1"> sections of </span><em class="italic"><span class="koboSpan" id="kobo.1246.1">Chapter 12</span></em><span class="koboSpan" id="kobo.1247.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1248.1">Since access to external databases doesn’t require any Kubernetes-specific techniques but can be done with the usual connection strings, we will concentrate on cloud storage.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1249.1">Kubernetes offers an abstraction of </span><a id="_idIndexMarker1523"/><span class="koboSpan" id="kobo.1250.1">storage called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1251.1">PersistentVolumeClaim</span></strong><span class="koboSpan" id="kobo.1252.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.1253.1">PVC</span></strong><span class="koboSpan" id="kobo.1254.1">) that is independent of the underlying storage provider. </span><span class="koboSpan" id="kobo.1254.2">More specifically, PVCs are allocation requests that are either matched to predefined resources or allocated dynamically. </span><span class="koboSpan" id="kobo.1254.3">When the Kubernetes cluster is in the cloud, typically, you use dynamic allocation carried out by dynamic providers installed by the cloud provider. </span><span class="koboSpan" id="kobo.1254.4">For more information on cloud storage, please refer to </span><em class="italic"><span class="koboSpan" id="kobo.1255.1">Chapter 12</span></em><span class="koboSpan" id="kobo.1256.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1257.1">Cloud providers such as Azure offer different storage classes with different performance and different costs. </span><span class="koboSpan" id="kobo.1257.2">Moreover, the PVC can also specify the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1258.1">accessMode</span></code><span class="koboSpan" id="kobo.1259.1">, which can be:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1260.1">ReadWriteOnce</span></code><span class="koboSpan" id="kobo.1261.1">: The volume can be mounted as read-write by a single Pod.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1262.1">ReadOnlyMany</span></code><span class="koboSpan" id="kobo.1263.1">: The volume can be mounted as read-only by many Pods.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1264.1">ReadWriteMany</span></code><span class="koboSpan" id="kobo.1265.1">: The</span><a id="_idIndexMarker1524"/><span class="koboSpan" id="kobo.1266.1"> volume can be mounted as read-write by many Pods.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1267.1">Volume claims can be added to StatefulSets in a specific </span><code class="inlineCode"><span class="koboSpan" id="kobo.1268.1">spec-&gt;volumeClaimTemplates</span></code><span class="koboSpan" id="kobo.1269.1"> object:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1270.1">volumeClaimTemplates:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1271.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1272.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1273.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1274.1">my-claim-template-name</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1275.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1276.1">resources:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1277.1">request:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1278.1">storage:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1279.1">5Gi</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1280.1">volumeMode:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1281.1">Filesystem</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1282.1">accessModes:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1283.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1284.1">ReadWriteOnce</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1285.1">storageClassName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1286.1">my-optional-storage-class</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1287.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1288.1">storage</span></code><span class="koboSpan" id="kobo.1289.1"> property contains the storage requirements. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1290.1">volumeMode</span></code><span class="koboSpan" id="kobo.1291.1"> set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1292.1">Filesystem</span></code><span class="koboSpan" id="kobo.1293.1"> is a standard setting that means the storage will be available as a file path. </span><span class="koboSpan" id="kobo.1293.2">The other possible value is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1294.1">Block</span></code><span class="koboSpan" id="kobo.1295.1">, which allocates the memory as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1296.1">unformatted</span></code><span class="koboSpan" id="kobo.1297.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1298.1">storageClassName</span></code><span class="koboSpan" id="kobo.1299.1"> must be set to an existing storage class offered by the cloud provider. </span><span class="koboSpan" id="kobo.1299.2">If it’s omitted, the default storage class will be assumed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1300.1">All available storage classes can be listed with the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1301.1">kubectl get storageclass
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1302.1">Once </span><code class="inlineCode"><span class="koboSpan" id="kobo.1303.1">volumeClaimTemplates</span></code><span class="koboSpan" id="kobo.1304.1"> has defined how to create permanent storage, then each container must specify which file path to attach that permanent storage to in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1305.1">spec-&gt;containers-&gt;volumeMounts</span></code><span class="koboSpan" id="kobo.1306.1"> property:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.1307.1">...</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1308.1">volumeMounts</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1309.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1310.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1311.1">my-claim-template-name</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1312.1">mountPath:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1313.1">/my/requested/storage</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1314.1">readOnly:</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1315.1">false</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1316.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1317.1">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1318.1">name</span></code><span class="koboSpan" id="kobo.1319.1"> must correspond to the name given to the PVC.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1320.1">The following subsection</span><a id="_idIndexMarker1525"/><span class="koboSpan" id="kobo.1321.1"> shows how to use Kubernetes secrets.</span></p>
<h2 class="heading-2" id="_idParaDest-426"><span class="koboSpan" id="kobo.1322.1">Kubernetes secrets</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1323.1">Some data, such as passwords and connection strings, cannot be exposed but need to be protected by some kind of</span><a id="_idIndexMarker1526"/><span class="koboSpan" id="kobo.1324.1"> encryption. </span><span class="koboSpan" id="kobo.1324.2">Kubernetes handles private sensitive data that need encryption through specific objects called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1325.1">secrets</span></strong><span class="koboSpan" id="kobo.1326.1">. </span><strong class="keyWord"><span class="koboSpan" id="kobo.1327.1">Secrets</span></strong><span class="koboSpan" id="kobo.1328.1"> are sets of</span><a id="_idIndexMarker1527"/><span class="koboSpan" id="kobo.1329.1"> key-value pairs that are encrypted to protect them. </span><span class="koboSpan" id="kobo.1329.2">They can be created by putting each value in a file, and then invoking the following </span><code class="inlineCode"><span class="koboSpan" id="kobo.1330.1">kubectl</span></code><span class="koboSpan" id="kobo.1331.1"> command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1332.1">kubectl create secret generic my-secret-name \
  --from-file=./secret1.bin \
  --from-file=./secret2.bin
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1333.1">In this case, the filenames become the keys and the files’ contents are the values.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1334.1">When the values are strings, they can be specified directly in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1335.1">kubectl</span></code><span class="koboSpan" id="kobo.1336.1"> command, as shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1337.1">kubectl create secret generic dev-db-secret \
  --from-literal=username=devuser \
  --from-literal=password='$dsd_weew1'
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1338.1">In this case, keys and values are listed one after the other, separated by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1339.1">=</span></code><span class="koboSpan" id="kobo.1340.1"> character. </span><span class="koboSpan" id="kobo.1340.2">In the previous example, the actual password is enclosed between single quotes to escape special characters like </span><code class="inlineCode"><span class="koboSpan" id="kobo.1341.1">$</span></code><span class="koboSpan" id="kobo.1342.1"> that are usually required to build strong passwords.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1343.1">Once defined, secrets can</span><a id="_idIndexMarker1528"/><span class="koboSpan" id="kobo.1344.1"> be referred to in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1345.1">spec-&gt;volume</span></code><span class="koboSpan" id="kobo.1346.1"> property of a Pod (Deployment or StatefulSet template), as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.1347.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1348.1">volumes:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1349.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1350.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1351.1">my-volume-with-secrets</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1352.1">secret:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1353.1">secretName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1354.1">my-secret-name</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1355.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1356.1">After that, each container can specify on which path to mount them in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1357.1">spec-&gt;containers-&gt;volumeMounts</span></code><span class="koboSpan" id="kobo.1358.1"> property:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.1359.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1360.1">volumeMounts:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1361.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1362.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1363.1">my-volume-with-secrets</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1364.1">mountPath:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1365.1">"/my/secrets"</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1366.1">readOnly:</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1367.1">true</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1368.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1369.1">In the preceding example, each key is seen as a file with the same name as the key. </span><span class="koboSpan" id="kobo.1369.2">The content of the file is the</span><a id="_idIndexMarker1529"/><span class="koboSpan" id="kobo.1370.1"> secret value, base64-encoded. </span><span class="koboSpan" id="kobo.1370.2">Therefore, the code that reads each file must decode its content (in .NET, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1371.1">Convert.FromBase64</span></code><span class="koboSpan" id="kobo.1372.1"> will do the job).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1373.1">When secrets contain strings, they can also be passed as environment variables in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1374.1">spec-&gt;containers-&gt;env</span></code><span class="koboSpan" id="kobo.1375.1"> object:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1376.1">env:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1377.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1378.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1379.1">SECRET_USERNAME</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1380.1">valueFrom:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1381.1">secretKeyRef:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1382.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1383.1">dev-db-secret</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1384.1">key:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1385.1">username</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1386.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1387.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1388.1">SECRET_PASSWORD</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1389.1">valueFrom:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1390.1">secretKeyRef:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1391.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1392.1">dev-db-secret</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1393.1">key:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1394.1">password</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1395.1">Here, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1396.1">name</span></code><span class="koboSpan" id="kobo.1397.1"> property must match the secret’s name. </span><span class="koboSpan" id="kobo.1397.2">Passing secrets as environment variables is very convenient when containers host ASP.NET Core applications, since, in this case, environment </span><a id="_idIndexMarker1530"/><span class="koboSpan" id="kobo.1398.1">variables are all immediately available in the configuration object (see the </span><em class="italic"><span class="koboSpan" id="kobo.1399.1">Loading configuration data and using it with the options framework</span></em><span class="koboSpan" id="kobo.1400.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.1401.1">Chapter 17</span></em><span class="koboSpan" id="kobo.1402.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1403.1">Presenting ASP.NET Core</span></em><span class="koboSpan" id="kobo.1404.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1405.1">Secrets can also encode the key/certificate pair of an HTTPS certificate with the following </span><code class="inlineCode"><span class="koboSpan" id="kobo.1406.1">kubectl</span></code><span class="koboSpan" id="kobo.1407.1"> command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1408.1">kubectl create secret tls test-tls --key="tls.key" --cert="tls.crt"
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1409.1">Secrets defined in this way can be used to enable HTTPS termination in Ingresses. </span><span class="koboSpan" id="kobo.1409.2">You can do this by placing the secret names in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1410.1">spec-&gt;tls-&gt;hosts-&gt;secretName</span></code><span class="koboSpan" id="kobo.1411.1"> properties of an Ingress.</span></p>
<h2 class="heading-2" id="_idParaDest-427"><span class="koboSpan" id="kobo.1412.1">Liveness and readiness checks</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1413.1">Kubernetes automatically monitors all containers to ensure they are still alive and that they keep their resource</span><a id="_idIndexMarker1531"/><span class="koboSpan" id="kobo.1414.1"> consumption within the limits declared in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1415.1">spec-&gt;containers-&gt;resources-&gt;limits</span></code><span class="koboSpan" id="kobo.1416.1"> object. </span><span class="koboSpan" id="kobo.1416.2">When some conditions are violated, the container is either throttled, or restarted, or the whole Pod instance is restarted on a different node. </span><span class="koboSpan" id="kobo.1416.3">How does Kubernetes know that a container is in a healthy state? </span><span class="koboSpan" id="kobo.1416.4">While it can use the operating system to check the healthy state of nodes, it has no universal check that works with all containers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1417.1">Therefore, the containers themselves must inform Kubernetes of their health, otherwise Kubernetes cannot verify them. </span><span class="koboSpan" id="kobo.1417.2">Containers can inform Kubernetes of their health in two ways: either by declaring a console command that returns their health, or by declaring an endpoint that provides the same information.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1418.1">Both declarations are provided in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1419.1">spec-&gt; containers-&gt; livenessProb</span></code><span class="koboSpan" id="kobo.1420.1"> object. </span><span class="koboSpan" id="kobo.1420.2">The console command check is declared as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.1421.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1422.1">livenessProbe:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1423.1">exec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1424.1">command:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1425.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1426.1">cat</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1427.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1428.1">/tmp/healthy</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1429.1">initialDelaySeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1430.1">10</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1431.1">periodSeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1432.1">5</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1433.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1434.1">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.1435.1">command</span></code><span class="koboSpan" id="kobo.1436.1"> returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1437.1">0</span></code><span class="koboSpan" id="kobo.1438.1">, the container is considered healthy. </span><span class="koboSpan" id="kobo.1438.2">In the preceding example, the software running in the container records its state of health in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1439.1">/tmp/healthy</span></code><span class="koboSpan" id="kobo.1440.1"> file, so the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1441.1">cat/tmp/healthy</span></code><span class="koboSpan" id="kobo.1442.1"> command returns it. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1443.1">PeriodSeconds</span></code><span class="koboSpan" id="kobo.1444.1"> is the time between checks, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.1445.1">initialDelaySeconds</span></code><span class="koboSpan" id="kobo.1446.1"> is the initial delay before performing the first check. </span><span class="koboSpan" id="kobo.1446.2">An initial delay is always necessary so as to give the container time to start.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1447.1">The endpoint check is quite similar:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.1448.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1449.1">livenessProbe:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1450.1">exec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1451.1">httpGet:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1452.1">path:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1453.1">/healthz</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1454.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1455.1">8080</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1456.1">httpHeaders:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1457.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1458.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1459.1">Custom-Health-Header</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1460.1">value:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1461.1">container-is-ok</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1462.1">initialDelaySeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1463.1">10</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1464.1">periodSeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1465.1">5</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1466.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1467.1">The test is successful if the HTTP </span><a id="_idIndexMarker1532"/><span class="koboSpan" id="kobo.1468.1">response contains the declared header with the declared value. </span><span class="koboSpan" id="kobo.1468.2">You may also use a pure TCP check, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.1469.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1470.1">livenessProbe:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1471.1">exec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1472.1">tcpSocket:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1473.1">port:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1474.1">8080</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1475.1">initialDelaySeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1476.1">10</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1477.1">periodSeconds:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1478.1">5</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1479.1">...</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1480.1">In this case, the check succeeds if Kubernetes is able to open a TCP socket to the container on the declared port.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1481.1">Similarly, the readiness of containers once they are installed is monitored with a readiness check. </span><span class="koboSpan" id="kobo.1481.2">The readiness check is defined in a similar way as the liveness check, the only difference being that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1482.1">livenessProbe</span></code><span class="koboSpan" id="kobo.1483.1"> is replaced with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1484.1">readinessProbe</span></code><span class="koboSpan" id="kobo.1485.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1486.1">The following subsection explains how to autoscale Deployments.</span></p>
<h2 class="heading-2" id="_idParaDest-428"><span class="koboSpan" id="kobo.1487.1">Autoscaling</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1488.1">Instead of manually modifying the </span><a id="_idIndexMarker1533"/><span class="koboSpan" id="kobo.1489.1">number of replicas in a Deployment to adapt it to a decrease or increase in load, we can let Kubernetes decide for itself the number of replicas needed to keep a declared resource’s consumption constant. </span><span class="koboSpan" id="kobo.1489.2">Thus, for instance, if we declare a target of 10% CPU consumption, then when the average resource consumption of each replica exceeds this limit, a new replica will be created. </span><span class="koboSpan" id="kobo.1489.3">If the average CPU consumption falls below this limit, a replica is destroyed. </span><span class="koboSpan" id="kobo.1489.4">The typical resource used to monitor replicas is CPU consumption, but we can also use memory consumption.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1490.1">In actual high-traffic production systems, autoscaling is a </span><strong class="keyWord"><span class="koboSpan" id="kobo.1491.1">must</span></strong><span class="koboSpan" id="kobo.1492.1">, because it is the only way to adapt quickly the system to changes in the load.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1493.1">Autoscaling is achieved by defining a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1494.1">HorizontalPodAutoscaler</span></code><span class="koboSpan" id="kobo.1495.1"> object. </span><span class="koboSpan" id="kobo.1495.2">Here is an example of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1496.1">HorizontalPodAutoscaler</span></code><span class="koboSpan" id="kobo.1497.1"> definition:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1498.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1499.1">autoscaling/v2beta1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1500.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1501.1">HorizontalPodAutoscaler</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1502.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1503.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1504.1">my-autoscaler</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1505.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1506.1">scaleTargetRef:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1507.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1508.1">extensions/v1beta1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1509.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1510.1">Deployment</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1511.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1512.1">my-deployment-name</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1513.1">minReplicas:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1514.1">1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1515.1">maxReplicas:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1516.1">10</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1517.1">metrics:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1518.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1519.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1520.1">Resource</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1521.1">resource:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1522.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1523.1">cpu</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1524.1">targetAverageUtilization:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1525.1">25</span></span>
</code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1526.1">spec-&gt; scaleTargetRef-&gt;name</span></code><span class="koboSpan" id="kobo.1527.1"> specifies the name of the Deployment to autoscale, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.1528.1">targetAverageUtilization</span></code><span class="koboSpan" id="kobo.1529.1"> specifies the target resource (in our case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1530.1">cpu</span></code><span class="koboSpan" id="kobo.1531.1">) percentage usage (in our case, 25%).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1532.1">The following subsection gives a short introduction to the Helm package manager and Helm charts and explains how to install Helm charts on a Kubernetes cluster. </span><span class="koboSpan" id="kobo.1532.2">An example of how to install an </span><a id="_idIndexMarker1534"/><span class="koboSpan" id="kobo.1533.1">Ingress Controller is given as well.</span></p>
<h2 class="heading-2" id="_idParaDest-429"><span class="koboSpan" id="kobo.1534.1">Helm – installing an Ingress Controller</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1535.1">Helm charts are a way to organize the installation of complex Kubernetes applications that contain several </span><code class="inlineCode"><span class="koboSpan" id="kobo.1536.1">.yaml</span></code><span class="koboSpan" id="kobo.1537.1"> files. </span><span class="koboSpan" id="kobo.1537.2">A Helm </span><a id="_idIndexMarker1535"/><span class="koboSpan" id="kobo.1538.1">chart is a set of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1539.1">.yaml</span></code><span class="koboSpan" id="kobo.1540.1"> files</span><a id="_idIndexMarker1536"/><span class="koboSpan" id="kobo.1541.1"> organized into folders and subfolders. </span><span class="koboSpan" id="kobo.1541.2">Here is a typical folder structure of a Helm chart taken from the official documentation:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1542.1"><img alt="Text  Description automatically generated" src="../Images/B19820_20_09.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1543.1">Figure 20.9: Folder structure of a Helm chart</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1544.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1545.1">.yaml</span></code><span class="koboSpan" id="kobo.1546.1"> files specific to the application are placed in the top </span><code class="inlineCode"><span class="koboSpan" id="kobo.1547.1">templates</span></code><span class="koboSpan" id="kobo.1548.1"> directory, while the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1549.1">charts</span></code><span class="koboSpan" id="kobo.1550.1"> directory may contain other Helm charts used as helper libraries. </span><span class="koboSpan" id="kobo.1550.2">The top-level </span><code class="inlineCode"><span class="koboSpan" id="kobo.1551.1">Chart.yaml</span></code><span class="koboSpan" id="kobo.1552.1"> file contains general</span><a id="_idIndexMarker1537"/><span class="koboSpan" id="kobo.1553.1"> information on the package (name and description), together </span><a id="_idIndexMarker1538"/><span class="koboSpan" id="kobo.1554.1">with both the application version and the Helm chart version. </span><span class="koboSpan" id="kobo.1554.2">The following is a typical example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1555.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1556.1">v2</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1557.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1558.1">myhelmdemo</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1559.1">description:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1560.1">My</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1561.1">Helm</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1562.1">chart</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1563.1">type:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1564.1">application</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1565.1">version:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1566.1">1.3.0</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1567.1">appVersion:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1568.1">1.2.0</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1569.1">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1570.1">type</span></code><span class="koboSpan" id="kobo.1571.1"> can be either </span><code class="inlineCode"><span class="koboSpan" id="kobo.1572.1">application</span></code><span class="koboSpan" id="kobo.1573.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1574.1">library</span></code><span class="koboSpan" id="kobo.1575.1">. </span><span class="koboSpan" id="kobo.1575.2">Only </span><code class="inlineCode"><span class="koboSpan" id="kobo.1576.1">application</span></code><span class="koboSpan" id="kobo.1577.1"> charts can be deployed, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.1578.1">library</span></code><span class="koboSpan" id="kobo.1579.1"> charts are utilities for developing other charts. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1580.1">library</span></code><span class="koboSpan" id="kobo.1581.1"> charts are placed in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1582.1">charts</span></code><span class="koboSpan" id="kobo.1583.1"> folder of other Helm charts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1584.1">In order to configure each specific application installation, Helm chart </span><code class="inlineCode"><span class="koboSpan" id="kobo.1585.1">.yaml</span></code><span class="koboSpan" id="kobo.1586.1"> files contain variables that are specified when Helm charts are installed. </span><span class="koboSpan" id="kobo.1586.2">Moreover, Helm charts also provide a simple templating language that allows some declarations to be included only if some conditions depending on the input variables are satisfied. </span><span class="koboSpan" id="kobo.1586.3">The top-level </span><code class="inlineCode"><span class="koboSpan" id="kobo.1587.1">values.yaml</span></code><span class="koboSpan" id="kobo.1588.1"> file declares default values for the input variables, meaning that the developer needs to specify just the few variables for which they require values different from the defaults. </span><span class="koboSpan" id="kobo.1588.2">We will not describe the Helm chart template language because it would be too extensive, but you can find it in the official Helm documentation referred to in the </span><em class="italic"><span class="koboSpan" id="kobo.1589.1">Further reading</span></em><span class="koboSpan" id="kobo.1590.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1591.1">Helm charts are usually organized in public or private repositories in a way that is similar to Docker images. </span><span class="koboSpan" id="kobo.1591.2">There is a Helm client that you can use to download packages from a remote repository and to install charts in Kubernetes clusters. </span><span class="koboSpan" id="kobo.1591.3">The Helm client is immediately</span><a id="_idIndexMarker1539"/><span class="koboSpan" id="kobo.1592.1"> available in Azure Cloud Shell, so you can start using Helm for your Azure Kubernetes cluster </span><a id="_idIndexMarker1540"/><span class="koboSpan" id="kobo.1593.1">without needing to install it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1594.1">A remote repository must be added before using its packages, as shown in the following example:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1595.1">helm repo add &lt;my-repo-local-name&gt; https://charts.helm.sh/stable
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1596.1">The preceding command makes the packages of a remote repository available and gives a local name to that remote repository. </span><span class="koboSpan" id="kobo.1596.2">After that, any package from the remote repository can be installed with a command such as the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1597.1">helm install &lt;instance name&gt;&lt;my-repo-local-name&gt;/&lt;package name&gt; -n &lt;namespace&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1598.1">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1599.1">&lt;namespace&gt;</span></code><span class="koboSpan" id="kobo.1600.1"> is the namespace in which to install the application. </span><span class="koboSpan" id="kobo.1600.2">As usual, if it’s not provided, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1601.1">default</span></code><span class="koboSpan" id="kobo.1602.1"> namespace is assumed. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1603.1">&lt;instance name&gt;</span></code><span class="koboSpan" id="kobo.1604.1"> is the name that you give to the installed application. </span><span class="koboSpan" id="kobo.1604.2">You need this name to get information about the installed application with the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1605.1">helm status &lt;instance name&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1606.1">You can get also information about all applications installed with Helm with the help of the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1607.1">helm ls
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1608.1">The application name is also needed to delete the application from the cluster by means of the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1609.1">helm delete &lt;instance name&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1610.1">When we install an application, we may also provide a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1611.1">.yaml</span></code><span class="koboSpan" id="kobo.1612.1"> file with all the variable values we want to override. </span><span class="koboSpan" id="kobo.1612.2">We can also specify a specific version of the Helm chart, otherwise the most recent version is used. </span><span class="koboSpan" id="kobo.1612.3">Here is an example with both the version and values overridden:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1613.1">helm install &lt;instance name&gt;&lt;my-repo-local-name&gt;/&lt;package name&gt; -f  values.yaml --version &lt;version&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1614.1">Finally, value overrides can also be provided in-line with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1615.1">--set</span></code><span class="koboSpan" id="kobo.1616.1"> option, as shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1617.1">...--set &lt;variable1&gt;=&lt;value1&gt;,&lt;variable2&gt;=&lt;value2&gt;...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1618.1">We can also upgrade an </span><a id="_idIndexMarker1541"/><span class="koboSpan" id="kobo.1619.1">existing installation with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1620.1">upgrade</span></code><span class="koboSpan" id="kobo.1621.1"> command, as shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1622.1">helm upgrade &lt;instance name&gt;&lt;my-repo-local-name&gt;/&lt;package name&gt;...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1623.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1624.1">upgrade</span></code><span class="koboSpan" id="kobo.1625.1"> command </span><a id="_idIndexMarker1542"/><span class="koboSpan" id="kobo.1626.1">may be used to specify new value overrides with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1627.1">–f</span></code><span class="koboSpan" id="kobo.1628.1"> option or with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1629.1">--set</span></code><span class="koboSpan" id="kobo.1630.1"> option, and a new version with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1631.1">--version</span></code><span class="koboSpan" id="kobo.1632.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1633.1">Let’s use Helm to provide an Ingress for the Guestbook demo application. </span><span class="koboSpan" id="kobo.1633.2">More specifically, we will use Helm to install an Ingress Controller based on Nginx. </span><span class="koboSpan" id="kobo.1633.3">The detailed procedure to be observed is as follows:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1634.1">Add the remote repository:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1635.1">helm repo add gcharts https://charts.helm.sh/stable
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1636.1">Install the Ingress Controller:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1637.1">helm install ingress gcharts/nginx-ingress
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1638.1">When the installation is complete, you should see an entry for the installed Ingress Controller among the installed services if you type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1639.1">kubectl get service</span></code><span class="koboSpan" id="kobo.1640.1">. </span><span class="koboSpan" id="kobo.1640.2">The entry should contain a public IP. </span><span class="koboSpan" id="kobo.1640.3">Please make a note of this IP since it will be the public IP of the application.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1641.1">Open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1642.1">frontend.yaml</span></code><span class="koboSpan" id="kobo.1643.1"> file and remove the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1644.1">type: LoadBalancer</span></code><span class="koboSpan" id="kobo.1645.1"> line. </span><span class="koboSpan" id="kobo.1645.2">Save and upload this to Azure Cloud Shell. </span><span class="koboSpan" id="kobo.1645.3">We changed the service type of the frontend application from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1646.1">LoadBalancer</span></code><span class="koboSpan" id="kobo.1647.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1648.1">ClusterIP</span></code><span class="koboSpan" id="kobo.1649.1"> (the default). </span><span class="koboSpan" id="kobo.1649.2">This service will be connected to the new Ingress you are going to define.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1650.1">Deploy </span><code class="inlineCode"><span class="koboSpan" id="kobo.1651.1">redis-master.yaml</span></code><span class="koboSpan" id="kobo.1652.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1653.1">redis-slave.yaml</span></code><span class="koboSpan" id="kobo.1654.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1655.1">frontend.yaml</span></code><span class="koboSpan" id="kobo.1656.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1657.1">kubectl</span></code><span class="koboSpan" id="kobo.1658.1">, as detailed in the </span><em class="italic"><span class="koboSpan" id="kobo.1659.1">Deploying the demo Guestbook application</span></em><span class="koboSpan" id="kobo.1660.1"> subsection. </span><span class="koboSpan" id="kobo.1660.2">Create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1661.1">frontend-ingress.yaml</span></code><span class="koboSpan" id="kobo.1662.1"> file and place the following code in it:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr"><span class="koboSpan" id="kobo.1663.1">apiVersion:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1664.1">extensions/v1beta1</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1665.1">kind:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1666.1">Ingress</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1667.1">metadata:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1668.1">name:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1669.1">simple-frontend-ingress</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1670.1">spec:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1671.1">rules:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1672.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1673.1">http:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1674.1">paths:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1675.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1676.1">path:/</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1677.1">backend:</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1678.1">serviceName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1679.1">frontend</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1680.1">servicePort:</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1681.1">80</span></span>
</code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1682.1">Upload </span><code class="inlineCode"><span class="koboSpan" id="kobo.1683.1">frontend-ingress.yaml</span></code><span class="koboSpan" id="kobo.1684.1"> to Azure Cloud Shell and deploy it with the following command:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1685.1">kubectl apply -f frontend-ingress.yaml
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1686.1">Open the browser and navigate to the public IP you made a note of in </span><em class="italic"><span class="koboSpan" id="kobo.1687.1">step 3</span></em><span class="koboSpan" id="kobo.1688.1">. </span><span class="koboSpan" id="kobo.1688.2">There, you should see the application running.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1689.1">The public IP allocated to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1690.1">Ingress-Controller</span></code><span class="koboSpan" id="kobo.1691.1"> at </span><em class="italic"><span class="koboSpan" id="kobo.1692.1">Step 3</span></em><span class="koboSpan" id="kobo.1693.1"> is listed also in the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1694.1">Azure Public IP Addresses</span></strong><span class="koboSpan" id="kobo.1695.1"> section of Azure. </span><span class="koboSpan" id="kobo.1695.2">You </span><a id="_idIndexMarker1543"/><span class="koboSpan" id="kobo.1696.1">can find it by searching for this</span><a id="_idIndexMarker1544"/><span class="koboSpan" id="kobo.1697.1"> section in the Azure search box. </span><span class="koboSpan" id="kobo.1697.2">Once in this section, you should see this IP address listed. </span><span class="koboSpan" id="kobo.1697.3">There you can also assign it a hostname of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1698.1">&lt;a name you can choose&gt;.&lt;your Azure region&gt;.cloudeapp.com</span></code><span class="koboSpan" id="kobo.1699.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1700.1">We recommend studying the </span><a href="https://letsencrypt.org/"><span class="url"><span class="koboSpan" id="kobo.1701.1">https://letsencrypt.org/</span></span></a><span class="koboSpan" id="kobo.1702.1"> documentation on how to require a certificate, assign a hostname to the application’s public IP, and then use this hostname to get a free HTTPS certificate from </span><a href="https://letsencrypt.org/"><span class="url"><span class="koboSpan" id="kobo.1703.1">https://letsencrypt.org/</span></span></a><span class="koboSpan" id="kobo.1704.1">. </span><span class="koboSpan" id="kobo.1704.2">Unfortunately, we can’t give more details since the procedure to require a certificate is too extensive. </span><span class="koboSpan" id="kobo.1704.3">Once you get a certificate, you can generate a secret from it with the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1705.1">kubectl create secret tls guestbook-tls --key="tls.key" --cert="tls.crt"
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1706.1">Then you can add the preceding secret to your </span><code class="inlineCode"><span class="koboSpan" id="kobo.1707.1">frontend-ingress.yaml Ingress</span></code><span class="koboSpan" id="kobo.1708.1"> by adding the following </span><code class="inlineCode"><span class="koboSpan" id="kobo.1709.1">spec-&gt;tls</span></code><span class="koboSpan" id="kobo.1710.1"> section to it:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string"><span class="koboSpan" id="kobo.1711.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1712.1">spec:</span></span>
<span class="hljs-string"><span class="koboSpan" id="kobo.1713.1">...</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1714.1">tls:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1715.1">-</span></span> <span class="hljs-attr"><span class="koboSpan" id="kobo.1716.1">hosts:</span></span>
<span class="hljs-bullet"><span class="koboSpan" id="kobo.1717.1">-</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1718.1">&lt;chosen</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1719.1">name&gt;.&lt;your</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1720.1">Azure</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1721.1">region&gt;.cloudeapp.com</span></span>
<span class="hljs-attr"><span class="koboSpan" id="kobo.1722.1">secretName:</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.1723.1">guestbook-tls</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1724.1">Following the correction, upload the file to your Azure Cloud Shell instance and update the previous Ingress definition with the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1725.1">kubectl apply –f frontend-ingress.yaml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1726.1">At this point, you should be </span><a id="_idIndexMarker1545"/><span class="koboSpan" id="kobo.1727.1">able to access the Guestbook application with HTTPS.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1728.1">When you are done </span><a id="_idIndexMarker1546"/><span class="koboSpan" id="kobo.1729.1">experimenting, please don’t forget to delete everything from your cluster to avoid wasting your free Azure credit. </span><span class="koboSpan" id="kobo.1729.2">You can do this by means of the following commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1730.1">kubectl delete –f frontend-ingress.yaml
kubectl delete –f frontend.yaml
kubectl delete –f redis-slave.yaml
kubectl delete –f redis-master.yaml
helm delete ingress
</span></code></pre>
<h1 class="heading-1" id="_idParaDest-430"><span class="koboSpan" id="kobo.1731.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1732.1">In this chapter, we described Kubernetes’ basic concepts and objects, and then we explained how to create an AKS cluster. </span><span class="koboSpan" id="kobo.1732.2">We also showed how to deploy applications and how to monitor and inspect the state of your cluster with a simple demo application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1733.1">The chapter also described more advanced Kubernetes features that have fundamental roles in practical applications, including how to provide persistent storage to the containers running on Kubernetes, how to inform Kubernetes of the health state of your containers, and how to offer advanced HTTP services, such as HTTPS and name-based virtual hosting.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1734.1">Finally, we reviewed how to install complex applications with Helm, and gave a short description of Helm and Helm commands.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1735.1">Up next, we have the book’s case study.</span></p>
<h1 class="heading-1" id="_idParaDest-431"><span class="koboSpan" id="kobo.1736.1">Questions</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1737.1">Why are Services needed?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1738.1">Why is an Ingress needed?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1739.1">Why is Helm needed?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1740.1">Is it possible to define several Kubernetes objects in the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.1741.1">.yaml</span></code><span class="koboSpan" id="kobo.1742.1"> file? </span><span class="koboSpan" id="kobo.1742.2">If yes, how?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1743.1">How does Kubernetes detect container faults?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1744.1">Why are persistent volume claims needed?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1745.1">What is the difference between a ReplicaSet and a StatefulSet?</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-432"><span class="koboSpan" id="kobo.1746.1">Further reading</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1747.1">A good book for extending the knowledge acquired in this chapter is the following: </span><a href="https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671"><span class="url"><span class="koboSpan" id="kobo.1748.1">https://www.packtpub.com/product/hands-on-kubernetes-on-azure-second-edition/9781800209671</span></span></a><span class="koboSpan" id="kobo.1749.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1750.1">The official documentation for Kubernetes and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1751.1">.yaml</span></code><span class="koboSpan" id="kobo.1752.1"> files can be found here: </span><a href="https://kubernetes.io/docs/home/"><span class="url"><span class="koboSpan" id="kobo.1753.1">https://kubernetes.io/docs/home/</span></span></a><span class="koboSpan" id="kobo.1754.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1755.1">More information on Helm and Helm charts can be found in the official documentation. </span><span class="koboSpan" id="kobo.1755.2">This is extremely well written and contains some good tutorials: </span><a href="https://helm.sh/"><span class="url"><span class="koboSpan" id="kobo.1756.1">https://helm.sh/</span></span></a><span class="koboSpan" id="kobo.1757.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1758.1">The official documentation for Azure Kubernetes can be found here: </span><a href="https://docs.microsoft.com/en-US/azure/aks/"><span class="url"><span class="koboSpan" id="kobo.1759.1">https://docs.microsoft.com/en-US/azure/aks/</span></span></a><span class="koboSpan" id="kobo.1760.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1761.1">The official documentation on the Azure Application Gateway-based Ingress Controller is available here: </span><a href="https://github.com/Azure/application-gateway-kubernetes-ingress"><span class="url"><span class="koboSpan" id="kobo.1762.1">https://github.com/Azure/application-gateway-kubernetes-ingress</span></span></a><span class="koboSpan" id="kobo.1763.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1764.1">Ingress certificate release and renewal can be automated as explained here: </span><a href="https://docs.microsoft.com/azure/application-gateway/ingress-controller-letsencrypt-certificate-application-gateway"><span class="url"><span class="koboSpan" id="kobo.1765.1">https://docs.microsoft.com/azure/application-gateway/ingress-controller-letsencrypt-certificate-application-gateway</span></span></a><span class="koboSpan" id="kobo.1766.1">. </span><span class="koboSpan" id="kobo.1766.2">While the procedure specifies an Azure Application Gateway-based ingress controller, it is adequate for any Ingress Controller.</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1767.1">Leave a review!</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1768.1">Enjoying this book? </span><span class="koboSpan" id="kobo.1768.2">Help readers like you by leaving an Amazon review. </span><span class="koboSpan" id="kobo.1768.3">Scan the QR code below for a 20% discount code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1769.1"><img alt="" role="presentation" src="../Images/Leave_a_review_QR.png"/></span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.1770.1">*Limited Offer</span></em></p>
</div>
</body></html>