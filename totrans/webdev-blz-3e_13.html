<html><head></head><body>
<div><h1 class="chapterNumber">13</h1>
<h1 class="chapterTitle" id="_idParaDest-222">Testing</h1>
<p class="normal">In this chapter, we will take a look at testing. Writing tests for our projects will help us develop things rapidly.</p>
<p class="normal">We can run tests to ensure we haven’t broken anything with the latest change. Also, we don’t have to invest our time in testing components manually since it is all done by the tests. Testing will improve the quality of the product since we’ll know that things that worked earlier still function as they should.</p>
<p class="normal">But writing tests for UI elements isn’t always easy; the most common way is to spin up the site, use tools that click on buttons, and then read the output to determine whether things work. The upside of this method is that we can test our site on different browsers and devices. The downside is that it usually takes a lot of time to do these tests. We need to spin up the website, start a web browser, verify the test, close the web browser, and repeat for the next test.</p>
<p class="normal">We can use this method in Blazor as well (as with any ASP.NET site), but with Blazor, we have other opportunities when it comes to testing.</p>
<p class="normal">Steve Sanderson created an embryo of a test framework for Blazor that Microsoft MVP Egil Hansen picked up and continued the development of.</p>
<p class="normal">Egil’s framework is<a id="_idIndexMarker515"/> called <strong class="keyWord">bUnit</strong> and has become an industry standard in the Blazor community for testing Blazor components.</p>
<p class="normal">This chapter covers the following topics:</p>
<ul>
<li class="bulletList">What is bUnit?</li>
<li class="bulletList">Setting up a test project</li>
<li class="bulletList">Mocking the API</li>
<li class="bulletList">Writing tests</li>
<li class="bulletList"><code class="inlineCode">Blazm</code> extension</li>
</ul>
<h1 class="heading-1" id="_idParaDest-223">Technical requirements</h1>
<p class="normal">Make sure you have read the previous chapters or use the <code class="inlineCode">Chapter12</code> folder as a starting point.</p>
<p class="normal">You can find the source code for this chapter’s result at <a href="https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter13">https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter13</a>.</p>
<p class="normal">If you are jumping into this chapter using the code from GitHub, make sure you have added the <code class="inlineCode">Auth0</code> account information in the settings files. You can find the instructions in <em class="chapterRef">Chapter 8</em>, <em class="italic">Authentication and Authorization</em>.</p>
<h1 class="heading-1" id="_idParaDest-224">What is bUnit?</h1>
<p class="normal">As mentioned in<a id="_idIndexMarker516"/> the introduction, some tests spin up web browsers to test pages/components, but bUnit takes another approach.</p>
<p class="normal">bUnit is made specifically for Blazor. It can define and set up tests using C# or Razor syntax. It can mock JavaScript interop as well as Blazor’s authentication and authorization. To make our components more testable, sometimes we need to think about these things from the beginning or make minor changes to our code.</p>
<p class="normal">bUnit doesn’t rely on a web browser but renders the output internally and exposes it to us so that we can test against predefined outputs. This is also a limitation – we are not testing the real site; we are testing the component, so think of this as unit tests, not integration tests.</p>
<p class="normal">It’s time for us to get our hands dirty, so let’s create a test project.</p>
<h1 class="heading-1" id="_idParaDest-225">Setting up a test project</h1>
<p class="normal">To be able to <a id="_idIndexMarker517"/>run <a id="_idIndexMarker518"/>tests, we need a test project:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">To install the <strong class="keyWord">bUnit</strong> templates, open PowerShell and run the following command:
        <pre class="programlisting con"><code class="hljs-con">dotnet new install bunit.template
</code></pre>
</li>
<li class="numberedList">Check which is the latest version of the templates on the bUnit web page: <a href="https://bunit.dev/">https://bunit.dev/</a>.</li>
<li class="numberedList">In Visual Studio, right-click the <strong class="screenText">MyBlog</strong> solution and choose <strong class="screenText">Add</strong> | <strong class="screenText">New Project</strong>.</li>
<li class="numberedList">Search for <strong class="screenText">bUnit</strong>, select <strong class="screenText">bUnit Test Project</strong> in the results, and then click <strong class="screenText">Next</strong>. Sometimes, it takes time to find a template, and we can also change the <strong class="screenText">Project Type</strong> dropdown to <strong class="screenText">bUnit</strong> to find the template. We might need to reboot Visual Studio to find it.</li>
<li class="numberedList">Name the project <code class="inlineCode">MyBlog.Tests</code>, leave the location as is, and click <strong class="screenText">Next</strong>.</li>
<li class="numberedList">Select <strong class="screenText">xUnit</strong> as the unit test framework and target framework: <strong class="screenText">.NET 8.0</strong>, and click <strong class="screenText">Create</strong>.</li>
</ol>
<p class="normal">Great! We now have a test project. Before we mock the API, let’s look at the different methods available to us so we can get a feel for how bUnit works.</p>
<p class="normal">In <code class="inlineCode">MyBlog.Tests</code>, we should have the following four files:</p>
<ul>
<li class="bulletList"><code class="inlineCode">_Imports.razor</code> contains the namespaces that we want all of our Razor files to have access to.</li>
<li class="bulletList"><code class="inlineCode">Counter.razor</code> is a copy of the same <code class="inlineCode">Counter</code> components we get by default in the Blazor template.</li>
<li class="bulletList"><code class="inlineCode">CounterCSharpTest.cs</code> contains tests written in C#.</li>
<li class="bulletList"><code class="inlineCode">CounterRazorTest.razor</code> contains tests written in Razor.</li>
</ul>
<p class="normal">Let’s start with the <code class="inlineCode">CounterCSharpTest.cs</code> file, which contains two tests: one that checks that the<a id="_idIndexMarker519"/> counter <a id="_idIndexMarker520"/>starts at <code class="inlineCode">0</code> and one that clicks the button and verifies the counter is now <code class="inlineCode">1</code>. These two simple tests make sense for testing the <code class="inlineCode">Counter</code> component.</p>
<p class="normal">The <code class="inlineCode">CounterStartsAtZero</code> test looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">[Fact]
public void CounterStartsAtZero()
{
    // Arrange
var cut = RenderComponent&lt;Counter&gt;();
    // Assert that content of the paragraph shows counter
// at zero
    cut.Find("p").MarkupMatches("&lt;p&gt;Current count: 0&lt;/p&gt;");
}
</code></pre>
<p class="normal">Let’s break this down. The <code class="inlineCode">Fact</code> attribute tells the test runner that this is a <em class="italic">normal</em> test with no parameters. We can also use the <code class="inlineCode">Theory</code> attribute to tell the test runner that the <code class="inlineCode">test</code> method needs parameter values, but we don’t need parameters for this use case.</p>
<p class="normal">First, we arrange the test. Simply put, we set up everything we need to do the test. Egil uses <code class="inlineCode">cut</code> as the component’s<a id="_idIndexMarker521"/> name, which stands for <strong class="keyWord">component under testing</strong>.</p>
<p class="normal">In this case, we run the <code class="inlineCode">RenderComponent</code> method and pass in the component type, which is the <code class="inlineCode">Counter</code> component. Next, we assert whether the component outputs the correct thing or not. We use the <code class="inlineCode">Find</code> method to find the first paragraph tag and then verify that the HTML looks like <code class="inlineCode">&lt;p&gt;Current count: 0&lt;/p&gt;</code>.</p>
<p class="normal">The second <a id="_idIndexMarker522"/>test is <a id="_idIndexMarker523"/>a bit more advanced, and it looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">[Fact]
public void ClickingButtonIncrementsCounter()
{
    // Arrange
var cut = RenderComponent&lt;Counter&gt;();
    // Act - click button to increment counter
    cut.Find("button").Click();
    // Assert that the counter was incremented
    cut.Find("p").MarkupMatches("&lt;p&gt;Current count: 1&lt;/p&gt;");
}
</code></pre>
<p class="normal">As with the previous test, we start arranging by rendering our <code class="inlineCode">Counter</code> component. The next step is acting, where we click the button. We look for the button and then click the button in our <code class="inlineCode">Counter</code> component. There is only one button, so in this case, it’s safe to look for the button this way.</p>
<p class="normal">Then it’s time to assert again, and we check the markup in the same way as the previous test, but we look for <code class="inlineCode">1</code> instead of <code class="inlineCode">0</code>.</p>
<p class="normal">There is also another alternative where we can write out tests with Razor syntax. If we look at the <code class="inlineCode">CounterRazorTests.razor</code> files, we can see the exact same tests but with different syntax:</p>
<pre class="programlisting code"><code class="hljs-code">    [Fact]
    public void CounterStartsAtZero()
    {
        // Arrange
var cut = Render(@&lt;Counter /&gt;);
        // Assert that content of the paragraph shows counter at zero
        cut.Find("p").MarkupMatches(@&lt;p&gt;Current count: 0&lt;/p&gt;);
    }
</code></pre>
<p class="normal">It is really only the way we render the component that differs. This does the same thing and is only a matter of preference. I prefer using the Razor version; it is easier to read, and it’s also easier to add parameters to our component while testing.</p>
<p class="normal">Now, let’s run the tests and see whether they pass:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In Visual Studio, bring up <strong class="screenText">Test Explorer</strong> by searching for it using <em class="keystroke">Ctrl</em> + <em class="keystroke">Q</em>. We can also find it in <strong class="screenText">View</strong> | <strong class="screenText">Test Explorer</strong>.</li>
<li class="numberedList">Click <strong class="screenText">Run All Test</strong> in the view. Test Explorer should look like <em class="italic">Figure 13.1</em>:</li>
</ol>
<figure class="mediaobject"><img alt="Figure 13.1 – Visual Studio Test Explorer " src="img/B21849_13_01.png"/></figure>
<p class="packt_figref">Figure 13.1: Visual Studio Test Explorer</p>
<p class="normal">Wonderful! Now, our<a id="_idIndexMarker524"/> first <a id="_idIndexMarker525"/>test is running and hopefully passing.</p>
<p class="normal">Next, we will take a look at mocking the API.</p>
<h1 class="heading-1" id="_idParaDest-226">Mocking the API</h1>
<p class="normal">There are different<a id="_idIndexMarker526"/> ways to test our application. Testing the API is beyond the scope of this book, but we still need to test the components, which are dependent on the API. We could spin up the API and test against the API, but in this case, we are only interested in testing the Blazor component.</p>
<p class="normal">We can then mock the API or create a fake copy of the API that doesn’t read from the database but reads from a predefined dataset. This way, we always know what the output should be.</p>
<p class="normal">Luckily, the interface we created for our API is just what we need to create a mock API.</p>
<p class="normal">We won’t implement 100% of the tests for the project, so we don’t have to mock all the methods. Please feel free to implement tests for all methods as an exercise at the end of the chapter.</p>
<p class="normal">There are two ways we can implement the mock API. We could spin up an in-memory database, but to keep <a id="_idIndexMarker527"/>things simple, we will choose the other option and generate posts when we ask for them:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">MyBlog.Tests</code> project, add a project reference to the <code class="inlineCode">SharedComponents</code> and <code class="inlineCode">BlazorWebApp</code> project.</li>
<li class="numberedList">Create a new class called <code class="inlineCode">BlogApiMock.cs</code>.</li>
<li class="numberedList">Add the following namespaces:
        <pre class="programlisting code"><code class="hljs-code">using Data.Models;
using Data.Models.Interfaces;
using System.Collections.Generic;
using System.Threading.Tasks;
</code></pre>
</li>
<li class="numberedList">Implement the <code class="inlineCode">IBlogApi</code> interface; the class should look like this:
        <pre class="programlisting code"><code class="hljs-code">internal class BlogApiMock :IBlogApi
{
}
</code></pre>
<p class="normal">Now, we will implement each of the methods so we can get data.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="5">For <code class="inlineCode">BlogPost</code>, add the following code in the class:
        <pre class="programlisting code"><code class="hljs-code">public async Task&lt;BlogPost?&gt; GetBlogPostAsync(string id)
{
    BlogPost post = new()
    {
        Id = id,
        Text = $"This is a blog post no {id}",
        Title = $"Blogpost {id}",
        PublishDate = DateTime.Now,
        Category = await GetCategoryAsync("1"),
    };
    post.Tags.Add(await GetTagAsync("1"));
    post.Tags.Add(await GetTagAsync("2"));
    return post;
}
public Task&lt;int&gt; GetBlogPostCountAsync()
{
    return Task.FromResult(10);
}
public async Task&lt;List&lt;BlogPost&gt;?&gt; GetBlogPostsAsync(int numberofposts, int startindex)
    {
        List&lt;BlogPost&gt; list = new();
        for (int a = 0; a &lt; numberofposts; a++)
        {
            list.Add(await GetBlogPostAsync($"{startindex + a}"));
        }
        return list;
    }
</code></pre>
<p class="normal">When we run the GetBlogPostAsync method, we create a blog post and fill it with predefined information we <a id="_idIndexMarker528"/>can use later in our tests. The same thing goes for getting a list of blog posts.</p>
<p class="normal">We also say that we have a total of <code class="inlineCode">10</code> blog posts in the database.</p>
<p class="normal">For categories, add the following code:</p>
<pre class="programlisting code"><code class="hljs-code"> public async Task&lt;List&lt;Category&gt;?&gt; GetCategoriesAsync()
    {
        List&lt;Category&gt; list = new();
        for (int a = 0; a &lt; 10; a++)
        {
            list.Add(await GetCategoryAsync($"{a}"));
        }
        return list;
    }
    public Task&lt;Category?&gt; GetCategoryAsync(string id)
    {
        return Task.FromResult(new Category() { Id = id, Name = $"Category {id}" });
    }
</code></pre>
<p class="normal">Here, we do the same thing: we create categories named <code class="inlineCode">Category</code> followed by a number.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="6">For comments, add the following:
        <pre class="programlisting code"><code class="hljs-code"> public Task&lt;List&lt;Comment&gt;&gt; GetCommentsAsync(string blogPostId)
    {
        var comments= new List&lt;Comment&gt;
        {
            new Comment { BlogPostId = blogPostId, Date = DateTime.Now, Id = "Comment1", Name = "Rocket Raccoon", Text = "I really want that arm!" }
        };
        return Task.FromResult(comments);
    }
</code></pre>
<p class="normal">Here, we <a id="_idIndexMarker529"/>create a comment.</p>
<p class="normal">The same thing goes for tags; add the following code:</p>
<pre class="programlisting code"><code class="hljs-code"> public Task&lt;Tag?&gt; GetTagAsync(string id)
    {
        return Task.FromResult(new Tag() { Id = id, Name = $"Tag {id}" });
    }
    public async Task&lt;List&lt;Tag&gt;?&gt; GetTagsAsync()
    {
        List&lt;Tag&gt; list = new();
        for (int a = 0; a &lt; 10; a++)
        {
            list.Add(await GetTagAsync($"{a}"));
        }
        return list;
    }
</code></pre>
<p class="normal">We will not add tests for other methods in the API. We do need to add them to the mock class to fulfill the interface:</p>
<pre class="programlisting code"><code class="hljs-code"> public Task&lt;BlogPost?&gt; SaveBlogPostAsync(BlogPost item)
    {
        return Task.FromResult(item);
    }
    public Task&lt;Category?&gt; SaveCategoryAsync(Category item)
    {
        return Task.FromResult(item);
    }
    public Task&lt;Tag?&gt; SaveTagAsync(Tag item)
    {
        return Task.FromResult(item);
    }     public Task&lt;Comment?&gt; SaveCommentAsync(Comment item)
    {
        return Task.FromResult(item);
    }
    public Task DeleteBlogPostAsync(string id)
    {
        return Task.CompletedTask;
    }
    public Task DeleteCategoryAsync(string id)
    {
        return Task.CompletedTask;
    }
    public Task DeleteTagAsync(string id)
    {
        return Task.CompletedTask;
    }
  public Task DeleteCommentAsync(string id)
  {
        return Task.CompletedTask;
  }
</code></pre>
</li>
</ol>
<p class="normal">We now have <a id="_idIndexMarker530"/>a mock API that does the same thing repeatedly so we can make reliable tests.</p>
<h1 class="heading-1" id="_idParaDest-227">Writing tests</h1>
<p class="normal">It’s time to write<a id="_idIndexMarker531"/> some tests. As I mentioned earlier in the chapter, we won’t create tests for the entire site; we will leave that to you to finish later if you want to. This is just to get a feel for how to write tests:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">In the <code class="inlineCode">MyBlog.Tests</code> project, create a new folder called <code class="inlineCode">Pages</code>. This is just so we can keep a bit of a structure (the same folder structure as the project we are testing).</li>
<li class="numberedList">Select the <code class="inlineCode">Pages</code> folder and create a new Razor component called <code class="inlineCode">HomeTest.razor</code>.</li>
<li class="numberedList">In the <code class="inlineCode">_Imports</code> file, add the following namespaces:
        <pre class="programlisting code"><code class="hljs-code">@using SharedComponents.Pages
@using Data.Models.Interfaces
@using SharedComponents.ReusableComponents
</code></pre>
</li>
<li class="numberedList">In the <code class="inlineCode">HomeTest.razor</code> file, inherit from <code class="inlineCode">TestContext</code> by adding the following code:
        <pre class="programlisting code"><code class="hljs-code">@inherits TestContext
</code></pre>
</li>
<li class="numberedList">Now, we will add the test. Add the following code:
        <pre class="programlisting code"><code class="hljs-code">@code{
[Fact(DisplayName ="Checks that the Home component shows 10 posts")]
    public void Shows10Blogposts()
    {
        // Act
var cut = Render(@&lt;Home /&gt;);
        // Assert that the content has 10 article tags (each representing a blogpost)
        Assert.Equal(10,cut.FindAll("article").Count());
    }
}
</code></pre>
<p class="normal">We give our<a id="_idIndexMarker532"/> test a display name so we understand what it does. The test is pretty simplistic; we know we have <code class="inlineCode">10</code> blog posts from the mock API. We also know that each blog post is rendered within an <code class="inlineCode">article</code> tag. We find all <code class="inlineCode">article</code> tags and make sure we have <code class="inlineCode">10</code> in total.</p>
<p class="normal">Since we are using injection, we need to configure dependency injection, which we can do in the constructor.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="6">We need to add the <code class="inlineCode">HomeTest</code> method:
        <pre class="programlisting code"><code class="hljs-code">public HomeTest()
{
      Services.AddScoped&lt;IBlogApi, BlogApiMock&gt;();
}
</code></pre>
<p class="normal">This method will run when the class is created, and here, we declare that if the components ask for an instance of <code class="inlineCode">BlogApi</code>, it will return an instance of our mock API.</p>
<p class="normal">This works the same way as with Blazor Server, where we return an API that talks directly to the database, and with Blazor WebAssembly, where we return an instance of the API that talks to a web API.</p>
<p class="normal">In this case, it will return our mock API, which returns data that is easy to test. Now, we need to run the actual test.</p>
</li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="7">Delete the default tests:
        <pre class="programlisting code"><code class="hljs-code">Counter.razor 
CounterCSharpTests.cs
CounterRazorTests.cs
</code></pre>
</li>
<li class="numberedList">In Visual Studio, bring up Test Explorer by searching for it using <em class="keystroke">Ctrl</em> + <em class="keystroke">Q</em>. We can also <a id="_idIndexMarker533"/>find it in <strong class="screenText">View</strong> | <strong class="screenText">Test Explorer</strong>.
    <p class="normal">Run our tests to see whether we get a green light, as shown in <em class="italic">Figure 13.2</em>:</p></li>
</ol>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B21849_13_02.png"/></figure>
<p class="packt_figref">Figure 13.2: Test Explorer with IndexTest</p>
<p class="normal">Now, we have a test that checks that 10 posts are rendered.</p>
<p class="normal">bUnit is an excellent framework for testing, and the fact that it is explicitly written for Blazor so that it takes advantage of Blazor’s power makes it amazing to work with.</p>
<p class="normal">Now, we have a simplistic test for our blog, but bUnit has support for more advanced<a id="_idIndexMarker534"/> features, such as authentication.</p>
<h2 class="heading-2" id="_idParaDest-228">Authentication</h2>
<p class="normal">Using <a id="_idIndexMarker535"/>bUnit, we can test authentication and <a id="_idIndexMarker536"/>authorization.</p>
<p class="normal">It is, however, not the components themselves that are doing the authentication. We added <code class="inlineCode">AuthorizeRouteView</code> to <code class="inlineCode">App.razor</code> in <em class="chapterRef">Chapter 8</em>, <em class="italic">Authentication and Authorization</em>, so testing that in individual components won’t make a difference.</p>
<p class="normal">But we can use <code class="inlineCode">AuthorizeView</code>, for example, and we have it in our blog in the <code class="inlineCode">LoginStatus</code> component, which displays a login link when we are not authorized and a logout link when we are authorized. Please feel free to add these tests as we did in the previous section, or use them as a reference.</p>
<p class="normal">We can use the <code class="inlineCode">AddTestAuthorization</code> method to authorize our tests like this:</p>
<pre class="programlisting code"><code class="hljs-code">    [Fact(DisplayName ="Checks if log in is showed")]
    public void ShouldShowLogin()
    {
        // Arrange
this.AddTestAuthorization();
        // Act
var cut = Render(@&lt;LoginStatus /&gt;);
        
        // Assert that there is a link with the text Log in
        Assert.Equal("Log in",cut.Find("a").InnerHtml);
    }
</code></pre>
<p class="normal">This method adds <code class="inlineCode">TestAuthorization</code> but is not authorized. The page will then display a link with the text <code class="inlineCode">Log in</code>. To test when the user is authorized, we just set the user as authorized:</p>
<pre class="programlisting code"><code class="hljs-code">    [Fact(DisplayName ="Checks if logout is showed")]
    public void ShouldShowLogout()
    {
        // Arrange
var authContext = this.AddTestAuthorization();
        authContext.SetAuthorized("Testuser", AuthorizationState.Authorized);
        // Act
var cut = Render(@&lt;LoginStatus /&gt;);
       
        // Assert that there is a link with the text Log out
        Assert.Equal("Log out",cut.Find("a").InnerHtml);
    }
</code></pre>
<p class="normal">We can add claims, roles, and much more. The user we utilize for testing does not correlate with the users or roles in the database; the authorization is mocked by bUnit.</p>
<p class="normal">Authentication and <a id="_idIndexMarker537"/>authorization could <a id="_idIndexMarker538"/>be tricky to test, but using bUnit is really simple. Testing JavaScript is a bit harder, but bUnit has a solution for that as well.</p>
<h2 class="heading-2" id="_idParaDest-229">Testing JavaScript</h2>
<p class="normal">Testing JavaScript is <a id="_idIndexMarker539"/>not <a id="_idIndexMarker540"/>supported by bUnit, which is understandable. We can, however, test the interop ourselves.</p>
<p class="normal">In this book, we have used the .NET 5 syntax for our JavaScript. In our <code class="inlineCode">SharedComponents\ReusableComponents\BlogButton.razor</code> component, we make a JavaScript interop to confirm the deletion of an item.</p>
<p class="normal">The JavaScript call looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">jsmodule = await jsRuntime.InvokeAsync&lt;IJSObjectReference&gt;("import", "/_content/SharedComponents/ReusableComponents/BlogButton.razor.js");
return await jsmodule.InvokeAsync&lt;bool&gt;("showConfirm", ConfirmMessage);
</code></pre>
<p class="normal">We make sure that we load the JavaScript module and then execute the <code class="inlineCode">showConfirm</code> method.</p>
<p class="normal">JavaScript testing in bUnit can be done in two modes – <code class="inlineCode">strict</code> and <code class="inlineCode">loose</code>. The default value is <code class="inlineCode">strict</code>, so we need to specify every module and every method.</p>
<p class="normal">If we choose <code class="inlineCode">loose</code>, all methods will just return the default value. For a Boolean, it would return <code class="inlineCode">false</code>, for example.</p>
<p class="normal">To test the preceding JavaScript call, we can do that by adding something like this:</p>
<pre class="programlisting code"><code class="hljs-code">var moduleInterop = this.JSInterop.SetupModule("/_content/SharedComponents/ReusableComponents/BlogButton.razor.js");
    var showconfirm = moduleInterop.Setup&lt;bool&gt;("showConfirm", "Are you sure?").SetResult(true);
</code></pre>
<p class="normal">We set up a module with the same path to JavaScript as before. Then, we specify the method and any parameters.</p>
<p class="normal">Lastly, we specify what the result should be. In this case, we return <code class="inlineCode">true</code>, which would return from JavaScript if we want to delete the item. We could also verify whether the JavaScript method is being called. A complete example for testing this in the <code class="inlineCode">ItemList</code> component<a id="_idIndexMarker541"/> would <a id="_idIndexMarker542"/>look like this:</p>
<pre class="programlisting code"><code class="hljs-code">@using Data.Models; @using SharedComponents.ReusableComponents;
@inherits TestContext
@code {
    [Fact(DisplayName = "Test if js method 'showConfirm' is called upon using JS interop")]
    public void ShouldShowConfirm()
    {
        // Arrange
var moduleInterop = this.JSInterop.SetupModule("/_content/SharedComponents/ReusableComponents/BlogButton.razor.js");
        moduleInterop.Setup&lt;bool&gt;("showConfirm", "Are you sure?").SetResult(true);
        var cut = Render(@&lt;BlogButton OnClick="()=&gt;{}" ConfirmMessage="Are you sure?"/&gt;);
        // Act
var buttons = cut.FindAll("button");
        buttons.First().Click();
        // Assert
        JSInterop.VerifyInvoke("showConfirm");
}
}
</code></pre>
<p class="normal">Great job! We now have tests in our project. Even though we aren’t covering all the components, we should have all the building blocks to complete the tests.</p>
<p class="normal">If you want to learn more about bUnit, check out the following link: <a href="https://bunit.dev/docs/getting-started/index.html">https://bunit.dev/docs/getting-started/index.html</a>.</p>
<p class="normal">Their documentation is fantastic.</p>
<p class="normal">It is good to know that it is also possible to use other testing frameworks. We use a combination of Playwright tests and bUnit but we test completely different things. You can find <a id="_idIndexMarker543"/>Playwright<a id="_idIndexMarker544"/> here: <a href="https://playwright.dev/dotnet/docs/intro">https://playwright.dev/dotnet/docs/intro</a>.</p>
<p class="normal">Before we summarize this chapter, we have one more thing to talk about.</p>
<h1 class="heading-1" id="_idParaDest-230">Blazm extension</h1>
<p class="normal">There are things that <a id="_idIndexMarker545"/>are a bit tedious when developing Blazor applications. We have done many of those things throughout the book. I tend to spell things wrong when I code, and when creating an isolated CSS or JavaScript file, I tend to get the name wrong from time to time and even get the file extension wrong. So, I thought, is there a better way to do this?</p>
<p class="normal">Yes, there is!</p>
<p class="normal">I built a Visual Studio extension that will add some very nice features to Visual Studio.</p>
<p class="normal">But why in the world have I waited so long to talk about this!? Well, it’s important to learn the “real” way first, then take the shortcuts. </p>
<p class="normal">You can check out the extension here: <a href="https://marketplace.visualstudio.com/items?itemName=EngstromJimmy.BlazmExtension">https://marketplace.visualstudio.com/items?itemName=EngstromJimmy.BlazmExtension</a></p>
<p class="normal">It can help us add a code-behind file and isolated CSS and JavaScript files. It can also help us move namespaces into the <code class="inlineCode">_imports</code> file and much more. But it can also help us generate tests, not the whole way, but it will help us on the way. Do you remember the <code class="inlineCode">Alerts</code> component we used in <em class="italic">Chapter 4</em>? We can right-click that component and choose <code class="inlineCode">Generate</code> <strong class="screenText">bUnit test</strong>, and then as <strong class="screenText">Razor syntax</strong>. It will generate the code to the clipboard so we can paste it where we want it. It will automatically give us this code:</p>
<pre class="programlisting code"><code class="hljs-code">@inherits TestContext
@using Bunit
@using SharedComponents.ReusableComponents;
@code
    {
        [Fact]
        public void AlertTest()
        {
            //Arrange
            SharedComponents.ReusableComponents.Alert/AlertStyle style = default!;
            var cut = Render(@&lt;Alert
                  Style="@style"
                  &gt;
                  &lt;ChildContent&gt;
&lt;b&gt;ChildContent fragment&lt;/b&gt;&lt;/ChildContent&gt;
                  &lt;/Alert&gt;
);
            //Act
//Assert
        }
    }
</code></pre>
<p class="normal">The result is not perfect as we can see, but it gives us something to stand on. If we were to write a test for<a id="_idIndexMarker546"/> the <code class="inlineCode">Alert</code> component, it would look something like this:</p>
<pre class="programlisting code"><code class="hljs-code">[Fact]
 public void AlertStyleTest()
 {
     //Arrange
     Alert.AlertStyle style = Alert.AlertStyle.Primary;
     var cut = Render(@&lt;Alert Style="@style"&gt;
     &lt;ChildContent&gt;
         &lt;b&gt;ChildContent fragment&lt;/b&gt;
     &lt;/ChildContent&gt;
 &lt;/Alert&gt;
 );
     //Act
//Assert
     cut.MarkupMatches("""&lt;div class="alert alert-primary" role="alert"&gt;&lt;b&gt;ChildContent fragment&lt;/b&gt;&lt;/div&gt;""");
 }
</code></pre>
<p class="normal">We had to clean up some namespaces and add an assertion. It’s pretty neat if you ask me, but then<a id="_idIndexMarker547"/> again, I am pretty biased on this topic. I really hope this extension will help you, and I would love for you to give it a five-star review if you enjoy it.</p>
<h1 class="heading-1" id="_idParaDest-231">Summary</h1>
<p class="normal">In this chapter, we looked at testing our application. We looked at how we can mock an API to make reliable tests. We also covered how to test JavaScript interop as well as authentication.</p>
<p class="normal">Tests can speed up our development and, most importantly, build quality. With bUnit combined with dependency injection, it is easy to build tests that can help us test our components.</p>
<p class="normal">Since we can test every component by itself, we don’t have to log in, navigate to a specific place on our site, and then test the entire page, as many other testing frameworks would have us do.</p>
<p class="normal">Now, our site contains reusable components, authentication, APIs, Blazor Server, Blazor WebAssembly, authentication, shared code, JavaScript interop, state management, and tests. We only have one more thing to do: ship it!</p>
<p class="normal">In the next chapter, <em class="chapterRef">Chapter 14</em>, <em class="italic">Deploying to Production</em>, it’s time to ship.</p>
</div>
</body></html>