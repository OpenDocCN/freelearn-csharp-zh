- en: REST 101 and Getting Started with ASP.NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 101 和 ASP.NET Core 入门
- en: Nowadays, almost all applications rely on web services. A lot of them operate
    using the RESTful method. The resource-centric approach and the simplicity of
    the REST style have become an industry standard. Therefore, it is essential to
    understand the theory behind the REST way of working and why it is important.
    This chapter will introduce you to the **Representational State Transfer** (**REST**)
    method. We will see what the definition of REST is and how to identify REST-compliant
    web services. We will also introduce .NET Core 3.1 and ASP.NET Core, the brand
    new version of the open-source, cross-platform framework provided by Microsoft.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，几乎所有的应用程序都依赖于网络服务。其中许多使用RESTful方法操作。以资源为中心的方法和REST风格的简单性已成为行业标准。因此，了解REST工作方式背后的理论以及为什么它很重要是至关重要的。本章将向你介绍**表征状态转移**（**REST**）方法。我们将看到REST的定义以及如何识别符合REST的网络服务。我们还将介绍.NET
    Core 3.1和ASP.NET Core，这是由微软提供的开源、跨平台框架的最新版本。
- en: 'In summary, this chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章涵盖了以下主题：
- en: Overview of REST architectural elements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST架构元素的概述
- en: A brief introduction to the .NET ecosystem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET生态系统的简要介绍
- en: Why you should choose .NET to build a RESTful web service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该选择.NET来构建RESTful网络服务
- en: By the end of this chapter, you will have an overview of some useful tools and
    IDEs that you can use to start developing on .NET Core.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解一些有用的工具和IDE，你可以使用它们开始开发.NET Core。
- en: This chapter will cover some of the base concepts of .NET Core 3.1 and ASP.NET
    Core. You need to have either Windows, Linux, or macOS installed. The setup process
    will depend on which OS you are using. We'll look at the different tools that
    can be used to develop apps and web services in .NET Core.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖.NET Core 3.1和ASP.NET Core的一些基本概念。你需要安装Windows、Linux或macOS。设置过程将取决于你使用的操作系统。我们将探讨可以用于在.NET
    Core中开发应用程序和网络服务的不同工具。
- en: REST
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST
- en: What is REST? **Representational State Transfer** (**REST**) is usually defined
    as a software architecture style that applies some constraints to a web service.
    It identifies a set of resource-centric rules that describe the roles and the
    interaction between the constraints of a distributed hypermedia system, instead
    of focusing on the implementation of the components. Although it is quite rare
    to find a REST service that does not use HTTP, the definition does not mention
    any of these topics and instead describes REST as media- and protocol-agnostic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是REST？**表征状态转移**（**REST**）通常被定义为一种软件架构风格，它对网络服务施加了一些约束。它确定了一组以资源为中心的规则，这些规则描述了分布式超媒体系统中约束的角色和交互，而不是关注组件的实现。尽管找到不使用HTTP的REST服务相当罕见，但定义并未提及这些主题，而是将REST描述为媒体和协议无关的。
- en: 'The preceding definition can be further explained with an example. Consider
    an e-commerce website. When you browse a list of products and click on one them,
    the browser interprets your click as a request to a specific resource; in this
    case, the details of the product you clicked on. The browser makes an HTTP call
    to the URI, which corresponds to the details of the product and asks for a specific
    resource using the URI. This process is shown in the following diagram:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义可以通过一个示例进一步解释。考虑一个电子商务网站。当你浏览产品列表并点击其中一个时，浏览器将你的点击解释为对特定资源的请求；在这种情况下，你点击的产品详情。浏览器通过HTTP调用URI，该URI对应于产品的详情，并使用URI请求特定的资源。这个过程在以下图中显示：
- en: '![](img/45c0c1b9-0d12-48e2-8f11-351aa8738e9a.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45c0c1b9-0d12-48e2-8f11-351aa8738e9a.png)'
- en: 'The concept of REST is pretty similar: the client asks the server for a specific
    resource, and this allows them to navigate and obtain other information about
    resources stored on the server.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: REST的概念相当相似：客户端向服务器请求特定的资源，这使得它们可以导航并获得关于服务器上存储的其他资源的其他信息。
- en: The importance of being REST compliant
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格遵守REST的重要性
- en: Before we discuss REST, we should understand the importance of web services
    in the modern application development world.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论REST之前，我们应该了解在现代应用程序开发世界中网络服务的重要性。
- en: 'A typical modern application uses web services to obtain and query data. Any
    company that develop any product or solution uses web services to deliver and
    track information. This is because it can be difficult to replicate all the data
    and every behavior you need for every client who uses your application. Web services
    are also useful for providing access to third-party clients and services. Consider,
    for example, the **Application Programming Interfaces** (**APIs**) of Google Maps
    or Instagram: these platforms expose information through HTTP to share it with
    other companies and services.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的现代应用程序使用网络服务来获取和查询数据。任何开发产品或解决方案的公司都使用网络服务来交付和跟踪信息。这是因为很难复制所有客户使用您的应用程序所需的所有数据和每个行为。网络服务对于提供第三方客户端和服务的访问也非常有用。例如，考虑
    Google Maps 或 Instagram 的 **应用程序编程接口**（**APIs**）：这些平台通过 HTTP 暴露信息，与其他公司和服务的共享。
- en: The REST approach to web service architecture became increasingly popular because
    it is straightforward and clear. Unlike some old methods, such as the **Simple
    Object Access Protocol** (**SOAP**) or the **Windows Communication Foundation**
    (**WCF**), REST services provide a clean way of querying data. Different information
    can be obtained using different URIs without the need for adding any overhead
    to requests.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其简单明了，REST 对网络服务架构的方法越来越受欢迎。与一些旧方法（如 **简单对象访问协议**（**SOAP**）或 **Windows Communication
    Foundation**（**WCF**））不同，REST 服务提供了一种查询数据的方式，无需在请求中添加任何开销。不同的信息可以通过不同的 URI 获取。
- en: Today, more than ever, our services need to be prepared to scale so that they
    can be adapted to consumers. In a world of different technologies and distributed
    teams around the globe, we should be able to transform our architecture to solve
    complex business challenges. HTTP and REST help us address these challenges.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，比以往任何时候，我们的服务都需要准备好扩展，以便能够适应消费者。在一个充满不同技术和全球分布式的团队的世界里，我们应该能够调整我们的架构来解决复杂的商业挑战。HTTP
    和 REST 帮助我们应对这些挑战。
- en: REST requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 要求
- en: 'Roy Thomas Fielding is the main person behind the formalization of the HTTP
    protocol and the REST style: he described them in his dissertation, *Architectural
    Styles and the Design of Network-based Software Architectures* ([https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)).
    Moreover, Fielding''s dissertation clearly defines the constraints of a REST system,
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Roy Thomas Fielding 是 HTTP 协议和 REST 风格正式化的主要人物：他在自己的论文《架构风格和网络软件架构设计》（*Architectural
    Styles and the Design of Network-based Software Architectures*）中描述了它们（[https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)）。此外，Fielding
    的论文明确定义了 REST 系统的约束，如下所示：
- en: Uniform interface
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一接口
- en: Stateless
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态
- en: Cacheable
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可缓存
- en: Client-server
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器
- en: Layered system
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层系统
- en: Code on demand
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求代码
- en: 'All of these, apart from code on demand, are essential when we wish to define
    a web service as REST-compliant. To explain these concepts, we will use the APIs
    provided by The New York Times: [https://developer.nytimes.com/](https://developer.nytimes.com/).
    To use these APIs, you need to go through a pre-authentication process. You can
    get an API key for this from the following link: [https://developer.nytimes.com/signup](https://developer.nytimes.com/signup).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了需求代码之外，所有这些都是在我们将网络服务定义为 REST 兼容时必不可少的。为了解释这些概念，我们将使用纽约时报提供的 API：[https://developer.nytimes.com/](https://developer.nytimes.com/)。要使用这些
    API，您需要通过预认证过程。您可以从以下链接获取 API 密钥：[https://developer.nytimes.com/signup](https://developer.nytimes.com/signup)。
- en: Uniform interface
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一接口
- en: Uniform interface refers to the separation between the client and the server.
    This is advantageous because it means that the two systems are independent. The
    first principle of a uniform interface is that it should be r*esource-based,*
    which means that we should start to think in a *resource-oriented way*. Therefore,
    every object or entity inside our system is a resource and a URI uniquely identifies
    each of them. Furthermore, if we think about the HTTP protocol, each resource
    is presented to the client in the form of XML or JSON to decouple the client from
    the server.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 统一接口指的是客户端和服务器之间的分离。这很有优势，因为它意味着这两个系统是独立的。统一接口的第一个原则是它应该是基于资源的，这意味着我们应该开始以资源导向的方式思考。因此，我们系统中的每个对象或实体都是一个资源，每个资源都有一个
    URI 唯一标识。此外，如果我们考虑 HTTP 协议，每个资源都以 XML 或 JSON 的形式呈现给客户端，以解耦客户端和服务器。
- en: 'Let''s use The New York Times APIs to understand this topic. Consider the following
    URI:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用《纽约时报》的API来了解这个主题。考虑以下URI：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It contains some precise information about the resources we are asking for,
    including the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含了一些关于我们请求的资源的确切信息，包括以下内容：
- en: The fact that we are getting information from the *archive* section of the newspaper
    data
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从报纸数据的*存档*部分获取信息的事实
- en: The specific month we are asking for; in this case, June 2018
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们请求的具体月份；在这种情况下，2018年6月
- en: The fact that the resource will be serialized using *JSON format*
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事实是资源将使用*JSON格式*进行序列化
- en: Manipulation of resources through representations
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过表示操纵资源
- en: 'Let''s take another API request provided by The New York Times:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看《纽约时报》提供的另一个API请求：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This provides a list of books based on a category; in this case, this category
    is `Hardcover Fiction`. Let''s analyze the response:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个基于类别的书籍列表；在这种情况下，这个类别是`精装小说`。让我们分析这个响应：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this is a clear representation of the resource. The client has
    all the required information to process and modify data using APIs (if the APIs
    allow that).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是资源的清晰表示。客户端拥有所有必要的信息来使用API（如果API允许）处理和修改数据。
- en: Self-descriptive messages
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自描述消息
- en: 'Let''s look at the response of the following call:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下调用的响应：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we mentioned previously, the response is a representation of the data, either
    stored in a data source or obtained from another system. In any case, some information
    is missing: how does the client know the format of the response? This kind of
    information is usually written in the response header. For example, here are all
    the headers of the previous request:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，响应是数据的表示，无论是存储在数据源中还是从另一个系统获取。在任何情况下，一些信息是缺失的：客户端如何知道响应的格式？这类信息通常写在响应头部。例如，以下是之前请求的所有头部：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The *headers* part tells the client that the response should be processed using
    a specific `content-type`*;* in this case, `application/json`*.* It also provides
    information about encoding, caching, and related meta information, such as the
    `age` header, which contains the time in seconds that the object has been in the
    proxy cache.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*头部*部分告知客户端响应应使用特定的`content-type`*；*进行处理，在这种情况下，`application/json`*.* 它还提供了有关编码、缓存和相关元信息的信息，例如包含对象在代理缓存中存在时间的`age`头部。'
- en: Hypermedia as the Engine of Application State
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超媒体作为应用状态引擎
- en: 'Services usually deliver a state to clients via body content, response codes,
    and response headers. Above all, *hypermedia-driven services (HATEOAS)* include
    the URI of other resources within their responses. The following example describes
    the concept of HATEOAS:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 服务通常通过正文内容、响应代码和响应头部将状态传递给客户端。最重要的是，*超媒体驱动的服务（HATEOAS）*在其响应中包含其他资源的URI。以下示例描述了HATEOAS的概念：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous response provides a list of people, together with the URIs that
    specify detailed information of each person. Therefore, the client knows the right
    URI of the request to use in order to get the information regarding each resource.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的响应提供了一个人员列表，以及指定每个人员详细信息的URI。因此，客户端知道正确的请求URI，以便获取有关每个资源的详细信息。
- en: Stateless
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态
- en: Being stateless is a crucial characteristic of a REST service. Indeed, HTTP,
    as a stateless protocol, doesn't keep track of all the information about the connection
    between the client and the server once the communication ends.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态是REST服务的一个关键特性。确实，HTTP作为一个无状态协议，一旦通信结束，就不会跟踪客户端和服务器之间连接的所有信息。
- en: 'A stateless protocol forces the client to fulfill the request with all the
    required information each time it needs some information from the server. Let''s
    take one of the previous URIs:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态协议迫使客户端每次需要从服务器获取信息时，都必须提供所有必要的信息。让我们看看之前的一个URI：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The client has to send the *API key* with each request to be authenticated by
    the server. Furthermore, it must store the API key information.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端必须在每个请求中发送*API密钥*以供服务器进行身份验证。此外，它必须存储API密钥信息。
- en: Statelessness is very important if we wish to take advantage of REST services.
    Nowadays, with the rise of highly distributed systems, it is difficult to deal
    with stateful services because this requires the states to be managed and replicated
    on different servers. A stateless approach helps delegate state management to
    the client.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望利用REST服务，无状态性非常重要。如今，随着高度分布式系统的兴起，处理有状态服务变得困难，因为这需要在不同的服务器上管理和复制状态。无状态方法有助于将状态管理委托给客户端。
- en: Client-server separation
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器分离
- en: The main aim of REST services is to decouple the server and the client. This
    is very important because it helps keep unique business logic and data storage
    for each client application. Applications are usually distributed across a multitude
    of different clients, including the web, smartphones, smart TVs, and the IoT.
    A REST approach helps us prevent logic replication across clients. This means
    that the client does not have any business logic or storage, and the server does
    not deal with user interfaces or the presentation layer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务的首要目标是解耦服务器和客户端。这非常重要，因为它有助于保持每个客户端应用程序独特的业务逻辑和数据存储。应用程序通常分布在众多不同的客户端上，包括Web、智能手机、智能电视和物联网。REST方法帮助我们防止在客户端之间复制逻辑。这意味着客户端没有任何业务逻辑或存储，服务器也不处理用户界面或表示层。
- en: Layered system
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层次化系统
- en: The concept of a layered system is strictly related to the structure of the
    infrastructure of our application. RESTful services allow a loosely coupled approach
    because the information is transferred over a protocol – in most cases, HTTP –
    and each server has a single high-level purpose. Proxy servers, web servers, and
    database servers are usually isolated and they cover a purpose in our feature,
    if you have one server that provides all the required features, it is often hard
    to maintain and scale.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 层次化系统的概念与我们的应用程序基础设施的结构密切相关。RESTful服务允许松散耦合的方法，因为信息是通过协议传输的——在大多数情况下，是通过HTTP——并且每个服务器都有一个单一的高级目的。代理服务器、Web服务器和数据库服务器通常是隔离的，它们在我们的功能中覆盖一个目的，如果你有一个提供所有必需功能的单一服务器，那么维护和扩展通常很困难。
- en: Richardson maturity model
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理查德森成熟度模型
- en: 'The *Richardson maturity model* is a model that was developed by Leonard Richardson,
    and its purpose is to measure the maturity of APIs by providing some general criteria.
    The model has four classification steps, from **Level 0** to **Level 3**. The
    highest level corresponds to a more compliant service. This model isn''t just
    for theoretical purposes; it also helps us understand some of the recommended
    methods for web service development. Let''s take a look at an overview of these
    different levels. The following diagram shows the structure of the levels in the
    Richardson maturity model:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**理查德森成熟度模型**是由伦纳德·理查德森开发的模型，其目的是通过提供一些一般性标准来衡量API的成熟度。该模型有四个分类步骤，从**级别0**到**级别3**。最高级别对应于更合规的服务。这个模型不仅仅是为了理论目的；它还帮助我们理解一些推荐的Web服务开发方法。让我们来看看这些不同级别的概述。以下图表显示了理查德森成熟度模型中各级别的结构：'
- en: '![](img/0f85cdef-13d5-45cc-a224-12d1f075e2ae.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f85cdef-13d5-45cc-a224-12d1f075e2ae.png)'
- en: 'A generic service is at **Level 0: The Swamp of Plain Old XML** when ituses
    a generic protocol superficially (in the case of web services, this is HTTP).
    An example of this is a heavy SOAP web service. SOAP implementations use only
    one URI and only one HTTP verb, and they wrap each request message within a massive
    envelope.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个通用服务在表面上使用通用协议（在Web服务的情况下，这是HTTP）时，它处于**级别0：普通旧XML的沼泽**。一个例子是重量级的SOAP Web服务。SOAP实现只使用一个URI和一个HTTP动词，并且它们在每个请求消息中包裹一个巨大的信封。
- en: 'As we mentioned previously, thinking in terms of resources is the best way
    to understand and design an API. Therefore, a generic service that''s at **Level
    1** uses multiple URIs associated with different resources. For example, if we
    think about an API of a general store, we could obtain the complete list of product
    categories by calling this sample URI:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，从资源的角度思考是理解和设计API的最佳方式。因此，处于**级别1**的通用服务使用与不同资源相关联的多个URI。例如，如果我们考虑一个普通商店的API，我们可以通过调用以下示例URI来获取产品类别的完整列表：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the same time, we can get the details of a single category by calling the
    following URI:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们可以通过调用以下URI来获取单个类别的详细信息：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On the other hand, we can get a list of products related to a single category
    by calling the following URI:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以通过调用以下URI来获取与单个类别相关的产品列表：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we can obtain different information by calling different URIs.
    There is no envelop, and all the requested information is contained in the URI.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以通过调用不同的 URI 来获取不同的信息。没有封装，所有请求的信息都包含在 URI 中。
- en: 'Level 2, which is related to HTTP verbs, introduces the use of HTTP verbs to
    enhance the information that''s transferred on request. Let''s take the previous
    request URI as an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二级，与 HTTP 动词相关，介绍了使用 HTTP 动词来增强请求上传输的信息。让我们以前一个请求 URI 为例：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This can produce different results, depending on the HTTP verb. The following
    table shows the meanings of various HTTP verbs:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以产生不同的结果，具体取决于 HTTP 动词。以下表格显示了各种 HTTP 动词的含义：
- en: '| **HTTP verbs** | **Performed operations** | **Example** |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 动词** | **执行的操作** | **示例** |'
- en: '| `GET` | Retrieves information about a resource |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 获取有关资源的信息 |'
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `POST` | Creates a new item related to the resource |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 创建与资源相关的新项目 |'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `PUT` | Replaces an item related to the resource |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 替换与资源相关的项目 |'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `PATCH` | Updates an item related to the resource |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 更新与资源相关的项目 |'
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `DELETE` | Deletes an item related to the resource |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除与资源相关的项目 |'
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Different HTTP verbs correspond to various data operations. As opposed to a
    **Level 0** service, which doesn't use any specifications of HTTP to deliver information,
    a **Level 2** service takes advantage of HTTP specifications to deliver as much
    information as possible. Finally, a system witha **Level 3** service implements
    the concept of HATEOAS. As we discussed in the previous section, a HATEOAS provides
    the resource's URI inside its response. A clear advantage of this approach is
    that the client doesn't need any information on its side to navigate through the
    web service's resources. Most importantly, if our web service adds the resource's
    URI, the client immediately has all the information they need.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 HTTP 动词对应着不同的数据操作。与不使用任何 HTTP 规范来传递信息的**0级**服务相反，**2级**服务利用 HTTP 规范尽可能多地传递信息。最终，具有**3级**服务的系统实现了
    HATEOAS 的概念。正如我们在上一节中讨论的，HATEOAS 在其响应中提供了资源的 URI。这种方法的明显优势是客户端不需要任何信息就可以导航 Web
    服务资源。最重要的是，如果我们的 Web 服务添加了资源的 URI，客户端立即就拥有了他们所需的所有信息。
- en: Introducing ASP.NET Core
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 ASP.NET Core
- en: 'At the time of writing this book, .NET Core 3.1 is the **LTS** (short for **Long
    Term Support**) version of the framework powered by Microsoft and the community.
    ASP.NET Core is the highly modular web framework that runs over the .NET Core
    platform: it can be used to develop a wide range of web solutions, such as web
    applications, web assembly client applications and web API projects.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，.NET Core 3.1 是由 Microsoft 和社区支持的框架的**LTS**（长期支持）版本。ASP.NET Core 是一个高度模块化的
    Web 框架，它运行在 .NET Core 平台上：它可以用来开发各种 Web 解决方案，例如 Web 应用程序、Web 程序集客户端应用程序和 Web API
    项目。
- en: To learn about some of the basic concepts of ASP.NET Core, we need to understand
    the **Model View Controller** (**MVC**) pattern that is implemented in ASP.NET
    Core.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 ASP.NET Core 的一些基本概念，我们需要理解 ASP.NET Core 中实现的**模型视图控制器**（MVC）模式。
- en: MVC separates our web application by grouping implementations into three different
    areas. In a web environment, the starting point is usually a web request that's
    made by a client or a generic user. The request passes through a middleware pipeline,
    and the controller then handles it. The controllers also perform some logic operations
    and populate our *model*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 通过将实现分组到三个不同的区域来分离我们的 Web 应用程序。在 Web 环境中，起点通常是客户端或通用用户发起的 Web 请求。请求通过中间件管道，然后控制器处理它。控制器还执行一些逻辑操作并填充我们的
    *模型*。
- en: The model is the representation of the state of the application. When it is
    associated with a view, it is called a **view model**. Once the model is populated,
    the controller returns a specific view, depending on the request. The purpose
    of the views is to present data through HTML pages.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是应用程序状态的表示。当它与视图相关联时，它被称为**视图模型**。一旦模型被填充，控制器根据请求返回一个特定的视图。视图的目的是通过 HTML 页面展示数据。
- en: In the case of a web API stack, which is the typical way of building web services
    in ASP.NET Core, the process is the same except for the view part. Instead of
    this, the controller serializes the model in the response.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web API 堆栈的情况下，这是在 ASP.NET Core 中构建 Web 服务的典型方式，过程与视图部分相同。而不是这个，控制器在响应中将模型序列化。
- en: To understand how ASP.NET Core helps developers build web services, let's go
    through the history of the ASP.NET framework.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 ASP.NET Core 如何帮助开发者构建 Web 服务，让我们回顾一下 ASP.NET 框架的历史。
- en: The evolution of ASP.NET
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET 的演变
- en: The first version of ASP.NET was released in 2002 when Microsoft decided to
    invest in web development. They released ASP.NET Web Forms, which is a set of
    UI components that we can use to build web interfaces. The core idea of this approach
    was to provide a very high-level abstraction tool that can produce a GUI for the
    web. Providing this level of abstraction was a good idea because developers were
    not familiar with the web. However, ASP.NET Web Forms came with a lot of downsides.
    First of all, developers had limited control over HTML, and components had to
    store information in a *v**iew state,* which was transferred and updated between
    the client and the server. Furthermore, the components were not correctly separated,
    and developers tended to mix the presentation code with the business logic code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 的第一个版本于 2002 年发布，当时微软决定投资 Web 开发。他们发布了 ASP.NET Web Forms，这是一个我们可以用来构建
    Web 界面的 UI 组件集合。这种方法的核心思想是提供一个非常高级的抽象工具，可以生成 Web 的 GUI。提供这种级别的抽象是一个好主意，因为开发者对
    Web 不熟悉。然而，ASP.NET Web Forms 带来了很多缺点。首先，开发者对 HTML 的控制有限，组件必须将信息存储在 *视图状态* 中，这些状态在客户端和服务器之间传输和更新。此外，组件没有正确分离，开发者倾向于将表示代码与业务逻辑代码混合。
- en: In order to improve the experience of developing web applications, Microsoft
    announced the arrival of ASP.NET MVC in 2007\. This new development platform ran
    on the ASP.NET framework and used concepts from other development platforms that
    implemented MVC patterns, such as Ruby on Rails. The ASP.NET MVC framework still
    had some points of weakness. It was built on ASP.NET, which means it had to maintain
    its retro compatibility with old web forms and web services frameworks such as
    WCF. Furthermore, it only ran on Windows servers combined with **Internet Information
    Services** (**IIS**).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提升开发 Web 应用程序的经验，微软在 2007 年宣布了 ASP.NET MVC 的到来。这个新的开发平台运行在 ASP.NET 框架上，并采用了其他实现了
    MVC 模式的开发平台的概念，例如 Ruby on Rails。ASP.NET MVC 框架仍然存在一些弱点。它建立在 ASP.NET 之上，这意味着它必须保持与旧的网络表单和网络服务框架（如
    WCF）的向后兼容性。此外，它只能在 Windows 服务器上运行，与 **Internet Information Services**（**IIS**）结合使用。
- en: The latest web framework to be developed by Microsoft is ASP.NET Core. It runs
    on .NET Core, which is cross-platform and open source. With ASP.NET Core, Microsoft
    made the choice to release a new lightweight framework that does not have any
    back-compatibility components derived from previous versions of ASP.NET.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 微软最新开发的 Web 框架是 ASP.NET Core。它运行在 .NET Core 上，这是一个跨平台和开源的平台。通过 ASP.NET Core，微软选择了发布一个没有从前一个版本的
    ASP.NET 派生的任何向后兼容组件的新轻量级框架。
- en: The new .NET ecosystem
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的 .NET 生态系统
- en: 'Let''s look at an overview of the .NET ecosystem to understand the different
    frameworks that act as the foundations of ASP.NET Core. Some of the information
    provided here may sound obvious, but it is essential to clarify the differences
    between different runtimes and frameworks:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们概述一下 .NET 生态系统，以了解作为 ASP.NET Core 基础的不同框架。这里提供的一些信息可能听起来很显然，但澄清不同运行时和框架之间的差异是至关重要的：
- en: '![](img/7274e7a2-f816-46bc-a757-727e6661ce84.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7274e7a2-f816-46bc-a757-727e6661ce84.png)'
- en: The first block is related to **Desktop Packs**, which provides the tools for
    the development of desktop applications starting from **.NET Core 3.0**. We will
    not use these tools in this book since they are strictly related to desktop development.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个块与 **桌面包** 相关，它为从 **.NET Core 3.0** 开始的桌面应用程序开发提供了工具。在这本书中，我们不会使用这些工具，因为它们严格与桌面开发相关。
- en: The second block is related to the cross-platform part of .NET Core. This set
    of tools allows developers to build applications on the **WEB**, **DATA**, and
    **AI/ML** domain. The **WEB** section refers to ASP.NET Core, which is a collection
    of libraries that comes with .NET Core. Usually, ASP.NET Core is combined with
    the **DATA** access part. Later in this book, we will see how we can use **EF
    Core** to access the database layer. Finally, the **AI/ML** section, which will
    not be discussed in this book, provides useful tools in the machine learning domain.
    At the bottom of the preceding diagram, we have a common layer, that is, **.NET
    STANDARD**. It allows developers to build third-party libraries that can be used
    by the **Desktop Packs** and by the **WEB**, **DATA**, and **AI/ML** parts.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分与.NET Core的跨平台部分相关。这组工具允许开发者构建**WEB**、**DATA**和**AI/ML**领域的应用程序。**WEB**部分指的是ASP.NET
    Core，它是随.NET Core一起提供的库集合。通常，ASP.NET Core会与**DATA**访问部分结合使用。在本书的后面部分，我们将看到如何使用**EF
    Core**来访问数据库层。最后，**AI/ML**部分，本书将不会讨论，在机器学习领域提供了有用的工具。在前面的图例底部，我们有一个共同的层，即**.NET
    STANDARD**。它允许开发者构建第三方库，这些库可以被**Desktop Packs**以及**WEB**、**DATA**和**AI/ML**部分使用。
- en: In conclusion, the new .NET ecosystem can be used by any developer, including
    cloud developers, web developers, and desktop developers. As we mentioned previously,
    it also runs anywhere and on any platform. In this book, all of our examples will
    be based on .NET Core.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，新的.NET生态系统可以被任何开发者使用，包括云开发者、Web开发者和桌面开发者。正如我们之前提到的，它可以在任何地方和任何平台上运行。本书中的所有示例都将基于.NET
    Core。
- en: .NET STANDARD
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET STANDARD
- en: '**.NET STANDARD** was introduced along with .NET Core. The aim of the **.NET
    STANDARD** is to provide a common API surface for .NET Core and .NET Framework.
    It works as a unique **Base Class Library** (**BCL**) for our applications in
    both .NET Framework and .NET Core. The release of .NET Standard 2.0 has introduced
    32,000 compatible APIs and supports the following framework versions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET STANDARD**是与.NET Core一起引入的。**.NET STANDARD**的目标是为.NET Core和.NET Framework提供一个共同的API界面。它作为我们.NET
    Framework和.NET Core应用程序的唯一**基础类库**（**BCL**）工作。.NET Standard 2.0的发布引入了32,000个兼容API，并支持以下框架版本：'
- en: .NET Framework 4.6.1 +
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Framework 4.6.1 +
- en: .NET Core 2.0 +
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 2.0 +
- en: Mono 5.4 +
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mono 5.4 +
- en: Recently, Microsoft introduced .NET Standard 2.1\. This new version provides
    new APIs that were introduced as part of the open-source development of .NET Core
    3.0\. .NET Standard 2.1 will be the common point between the new versions of .NET
    Core, starting from the 3.0 version, and the other versions of the upcoming frameworks,
    such as Mono.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，微软推出了.NET Standard 2.1。这个新版本提供了作为.NET Core 3.0开源开发一部分引入的新API。从3.0版本开始，.NET
    Standard 2.1将成为.NET Core新版本和其他即将到来的框架版本（如Mono）的共同点。
- en: 'You may wish to choose the .NET Standard for different reasons:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能出于不同的原因选择.NET Standard：
- en: To build third-party libraries that are compatible with both .NET Core and .NET
    Framework. In that case, your package will target .NET Standard 2.0\. Eventually,
    if you want to use the newly optimized APIs that we described previously, it is
    possible to use multi-targeting to target both .NET Standard 2.0 and .NET Standard
    2.1.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要构建与.NET Core和.NET Framework都兼容的第三方库。在这种情况下，您的包将针对.NET Standard 2.0。最终，如果您想使用我们之前描述的新优化的API，可以使用多目标来同时针对.NET
    Standard 2.0和.NET Standard 2.1。
- en: To migrate your .NET Framework codebase gradually by isolating logic on .NET
    Standard projects.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将逻辑隔离在.NET Standard项目上来逐步迁移您的.NET Framework代码库。
- en: For example, consider a class library project which is used by different versions
    of .NET. The library may run on either .NET Core or .NET Framework. To avoid maintainability
    pitfalls, the library package can be compiled for multiple versions of .NET Standard
    and it can be used by both a *.NET Core* and a *.NET Framework* solution*.*
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个由不同版本的.NET使用的类库项目。该库可能运行在.NET Core或.NET Framework上。为了避免维护陷阱，库包可以编译为多个.NET
    Standard版本，并且可以被*.NET Core*和*.NET Framework*解决方案*使用*。
- en: Why use ASP.NET Core to build RESTful web services?
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用ASP.NET Core来构建RESTful Web服务？
- en: 'There is a massive choice of web frameworks that allow developers to build
    REST web services. One such framework is ASP.NET Core on .NET Core 3.1\. .NET
    Core 3.1 provides a new, lightweight, cross-platform and opensource way to build
    web applications. Most importantly, it is designed to be cloud-ready: the framework
    is no longer part of the server, unlike in .NET Framework; instead, it is shipped
    with the application.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量的 Web 框架可供开发者构建 RESTful Web 服务。其中一个这样的框架是建立在 .NET Core 3.1 上的 ASP.NET Core。.NET
    Core 3.1 提供了一种新的、轻量级、跨平台和开源的方式来构建 Web 应用程序。最重要的是，它被设计为云就绪：与 .NET Framework 不同，该框架不再是服务器的一部分；相反，它与应用程序一起分发。
- en: 'Another key point is that .NET Core maintains a *high level of modularity*,
    which adheres to the Unix philosophy and allows you to use only what you need
    in tailored applications. ASP.NET Core also introduces two new hosting solutions
    for web applications and web services:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键点是 .NET Core 保持 *高度模块化*，遵循 Unix 哲学，并允许你在定制应用程序中仅使用所需的部分。ASP.NET Core 还为
    Web 应用程序和 Web 服务引入了两种新的托管解决方案：
- en: '**Kestrel**: The default HTTP server for ASP.NET Core. It supports HTTPS and
    web sockets, and it runs on Windows, Linux, and macOS. *Kestrel* is usually combined
    with a *reverse-proxy,* such as NGINX, IIS, or Apache.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kestrel**：ASP.NET Core 的默认 HTTP 服务器。它支持 HTTPS 和 WebSockets，并在 Windows、Linux
    和 macOS 上运行。*Kestrel* 通常与 *反向代理* 结合使用，例如 NGINX、IIS 或 Apache。'
- en: '**HTTP.sys**: A Windows-only HTTP server that can be used as an alternative
    to Kestrel on Windows.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP.sys**：一个仅适用于 Windows 的 HTTP 服务器，可以用作 Windows 上 Kestrel 的替代品。'
- en: 'ASP.NET Core and .NET Core are developed by Microsoft and the community, and
    they are *open source projects*. In the case of ASP.NET Core, open source isn''t
    just a buzzword; all the features are community-driven, and the ASP.NET team streams
    a community standup video on YouTube every week, in which they discuss roadmaps,
    deadlines, and issues. All the .NET Core code is available on GitHub at the following
    links:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 和 .NET Core 是由微软和社区共同开发的，它们是 *开源项目*。在 ASP.NET Core 的情况下，开源不仅仅是一个口号；所有功能都是由社区驱动的，并且
    ASP.NET 团队每周在 YouTube 上发布社区站立会议视频，其中讨论路线图、截止日期和问题。所有 .NET Core 代码都可以在以下链接的 GitHub
    上找到：
- en: '**.NET Core**: The repository of .NET Core ([https://github.com/dotnet/core](https://github.com/dotnet/core))'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET Core**：.NET Core 的存储库 ([https://github.com/dotnet/core](https://github.com/dotnet/core))'
- en: '**ASP.NET Core**: Contains all the references to ASP.NET Core projects ([https://github.com/aspnet/AspNetCore](https://github.com/aspnet/AspNetCore))'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASP.NET Core**：包含所有 ASP.NET Core 项目的引用 ([https://github.com/aspnet/AspNetCore](https://github.com/aspnet/AspNetCore))'
- en: All the repositories usually come with a roadmap and some contributing guidelines.
    It is possible to open issues and contribute to the code base. Microsoft has also
    founded the .NET foundation, an independent organization that fosters open development
    and collaboration around the .NET ecosystem.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有存储库通常都附带路线图和一些贡献指南。你可以打开问题并为代码库做出贡献。微软还成立了 .NET 基金会，这是一个独立的组织，旨在促进围绕 .NET
    生态系统的开放开发和协作。
- en: 'The ASP.NET Core team is also focused on the performance of the framework.
    All the benchmark results are available on GitHub: [https://github.com/aspnet/benchmarks](https://github.com/aspnet/benchmarks).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 团队也专注于框架的性能。所有基准测试结果都可以在 GitHub 上找到：[https://github.com/aspnet/benchmarks](https://github.com/aspnet/benchmarks)。
- en: Preparing your development environment
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备你的开发环境
- en: In this section, we will show you how to set up your development environment
    so that you can develop web services using ASP.NET Core. As we mentioned previously,
    .NET Core is cross-platform, so it can run on the most common OSes. We will also
    look at how to interact with the .NET Core CLI, which is the starting point for
    building, running, developing, and testing our services.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何设置您的开发环境，以便您可以使用 ASP.NET Core 开发 Web 服务。正如我们之前提到的，.NET Core 是跨平台的，因此它可以在最常用的操作系统上运行。我们还将探讨如何与
    .NET Core CLI 交互，这是构建、运行、开发和测试我们的服务的起点。
- en: First of all, let's start by downloading .NET Core 3.1 from [https://www.microsoft.com/net/download/](https://www.microsoft.com/net/download/).
    In our case, we'll install the SDK version, which contains all the components
    that are required for our development environment, including ASP.NET Core.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从 [https://www.microsoft.com/net/download/](https://www.microsoft.com/net/download/)
    下载 .NET Core 3.1 开始。在我们的案例中，我们将安装 SDK 版本，它包含我们开发环境所需的所有组件，包括 ASP.NET Core。
- en: .NET Core CLI
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core CLI
- en: 'Unlike the .NET framework, .NET Core provides an easy to use CLI that exposes
    all the necessary functionalities we can use to build applications and services.
    Once .NET Core is installed on your machine, run the `dotnet --help` command.
    You will see the following result:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与.NET框架不同，.NET Core提供了一个易于使用的命令行界面（CLI），它暴露了我们用于构建应用程序和服务的所有必要功能。一旦.NET Core安装到您的机器上，运行`dotnet
    --help`命令。您将看到以下结果：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first thing to notice is the version of .NET Core, which is the version
    of .NET Core, that is, `.NET Core SDK (3.1.100)`, followed by a list of **Software
    Development Kit** (**SDK**) commands. This contains the commands that are commonly
    executed during the development stage, such as `dotnet build`, `dotnet restore`,
    and `dotnet run`. These are used to build our projects, restore the NuGet dependencies,
    and run our project, respectively. Another relevant section is a*dditional tools,*
    which contain all the third-party CLI packages we will require, such as EF Core.
    In fact, the .NET Core CLI allows you to extend its functionality by adding specific
    tools in the form of NuGet packages.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是.NET Core的版本，即.NET Core的版本，也就是`.NET Core SDK (3.1.100)`，后面跟着一个**软件开发工具包（SDK**）命令列表。这包含了在开发阶段通常执行的命令，如`dotnet
    build`、`dotnet restore`和`dotnet run`。这些用于构建我们的项目、恢复NuGet依赖项以及运行我们的项目。另一个相关的部分是*附加工具*，它包含了我们将需要的所有第三方命令行界面（CLI）包，例如EF
    Core。实际上，.NET Core CLI允许您通过添加特定工具的NuGet包来扩展其功能。
- en: IDEs and development tools in ASP.NET Core
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core中的IDE和开发工具
- en: '.NET Core CLI is a base upon which higher-level tools such as IDEs, code editors,
    and **continuous integration** (**CI**) tools can be placed. Even though .NET
    Core is a cross-platform framework, there are various tools that can be used to
    build web applications and services on different platforms. The following table
    provides a recap of the different IDEs and editors that can be used to build ASP.NET
    Core:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core CLI是构建在IDE、代码编辑器和**持续集成（CI**）工具等高级工具之上的基础。尽管.NET Core是一个跨平台框架，但仍有各种工具可用于在不同平台上构建Web应用程序和服务。以下表格总结了可用于构建ASP.NET
    Core的不同IDE和编辑器：
- en: '| **Softwares** | **Windows** | **Linux** | **macOS X** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **软件** | **Windows** | **Linux** | **macOS X** |'
- en: '| Visual Studio 2019 (Community, Pro, and Enterprise) | Supported | - | - |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| Visual Studio 2019（社区版、专业版和企业版） | 支持 | 不支持 | 支持 |'
- en: '| Visual Studio Code and OmniSharp | Supported | Supported | Supported |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| Visual Studio Code 和 OmniSharp | 支持 | 支持 | 支持 |'
- en: '| Rider | Supported | Supported | Supported |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| Rider | 支持 | 支持 | 支持 |'
- en: '| Visual Studio for Mac | - | - | Supported |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| Visual Studio for Mac | 不支持 | 不支持 | 支持 |'
- en: 'As you can see, it is possible to use different IDEs and code editors for different
    platforms. The choice you make usually depends on different factors. Let''s look
    at an overview of the different editors:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，针对不同的平台，可以使用不同的集成开发环境（IDE）和代码编辑器。您所做的选择通常取决于不同的因素。让我们来看看不同编辑器的概述：
- en: '**Visual Studio 2019 (Community, Pro, and Enterprise)**: An editor that is
    well-known to anyone who has already developed on the .NET ecosystem. The community
    version of this product is totally free, and you can find it at [https://visualstudio.microsoft.com/it/downloads/](https://visualstudio.microsoft.com/it/downloads/).Visual
    Studio 2019 is the most comfortable choice if you wish to start building on Windows.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio 2019（社区版、专业版和企业版）**：对于已经在.NET生态系统上开发过的人来说，这是一个众所周知的编辑器。该产品的社区版完全免费，您可以在[https://visualstudio.microsoft.com/it/downloads/](https://visualstudio.microsoft.com/it/downloads/)找到它。如果您想在Windows上开始构建，Visual
    Studio 2019是最舒适的选择。'
- en: '**Visual Studio Code and OmniSharp**: A popular and open source editor powered
    by Microsoft and the community. It is cross-platform and built on Electron. OmniSharp
    is a useful third-party package for Visual Studio Code and other code editors
    that provides some integration with .NET Core projects. It also provides an IntelliSense
    feature.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code 和 OmniSharp**：由Microsoft和社区提供支持的一个流行且开源的编辑器。它是跨平台的，基于Electron构建。OmniSharp是Visual
    Studio Code和其他代码编辑器的一个有用的第三方包，它为.NET Core项目提供了一些集成。它还提供了一个智能感知（IntelliSense）功能。'
- en: '**Rider**: A brand new IDE powered by JetBrains and based on the IntelliJ platform
    and ReSharper. It is compatible with every platform, but it is not free. I''ve
    tried it in large projects, and it works well, primarily to provide the ReSharper
    integration out of the box.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rider**：由JetBrains提供支持，基于IntelliJ平台和ReSharper的新IDE。它与所有平台兼容，但不是免费的。我在大型项目中尝试过它，它运行良好，主要因为它提供了开箱即用的ReSharper集成。'
- en: '**Visual Studio for Mac**: A new IDE powered by Microsoft. It is only compatible
    with macOS and provides a few functionalities we can use to write C# or F# code
    in the .NET Core ecosystem. This IDE is still at an early stage, but it has a
    lot of advanced features.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio for Mac**：由微软推出的一款新IDE。它仅兼容macOS，并提供了一些我们可以用于在.NET Core生态系统中编写C#或F#代码的功能。这个IDE仍处于早期阶段，但它拥有许多高级功能。'
- en: In conclusion, tools such as Visual Studio 2019, Rider, and Visual Studio for
    Mac provide a great experience when combined with .NET Core. On the other hand,
    Visual Studio Code is the lightest and fastest editor. In the upcoming chapters
    and code demonstrations, I will use the .NET Core CLI to reproduce the same steps
    in different operating systems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Visual Studio 2019、Rider和Visual Studio for Mac等工具与.NET Core结合使用时，提供了极佳的体验。另一方面，Visual
    Studio Code是最轻便且最快的编辑器。在接下来的章节和代码演示中，我将使用.NET Core CLI在不同的操作系统上重现相同的步骤。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have taken an overview of the REST style by considering
    some concrete some concrete examples. We also learned about some of the basic
    concepts of the .NET ecosystem, including how it is structured and why ASP.NET
    Core is an excellent choice if we wish to build web services. We also looked at
    an overview of the .NET Core CLI and the IDEs and code editors related to the
    .NET ecosystem.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过考虑一些具体的例子，对REST风格进行了概述。我们还了解了一些.NET生态系统的基本概念，包括其结构以及为什么如果我们想构建网络服务，ASP.NET
    Core是一个极佳的选择。我们还概述了.NET Core CLI以及与.NET生态系统相关的IDE和代码编辑器。
- en: The topics we covered in this chapter provide a good understanding of what REST
    means and why is important to follow this kind of principle when we develop a
    web service. Furthermore, we also looked at the fundamentals for setting up .NET
    Core in our local environment.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们讨论的主题为我们提供了对REST的含义以及为什么在开发网络服务时遵循此类原则很重要的良好理解。此外，我们还探讨了在本地环境中设置.NET Core的基本原则。
- en: The next chapter will focus on ASP.NET Core and ASP.NET Core MVC. You'll learn
    how to set up a project using the .NET CLI and explore some of the fundamentals
    concepts of ASP.NET Core.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专注于ASP.NET Core和ASP.NET Core MVC。你将学习如何使用.NET CLI设置项目，并探索ASP.NET Core的一些基本概念。
