- en: Chapter 2. A Sample Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a structure of our own in Microsoft Dynamics NAV. To do this, we
    must think of something that is not already available in the standard package
    but can be built on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: For our example application, we will run a squash court. Running a squash court
    is simple to understand but something we cannot do without changing and expanding
    the product. In order to define our changes, we first need to make a fit-gap analysis.
  prefs: []
  type: TYPE_NORMAL
- en: After this chapter, you will have better understanding on how to reuse the framework
    of the Microsoft Dynamics NAV application. We will show how to reverse engineer
    the application and to study its functionality by going into the application code.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, some new and changed objects are required. The [Appendix](apa.html
    "Appendix A. Installation Guide"), *Installation Guide*, describes where to find
    the objects and how to install and activate them.
  prefs: []
  type: TYPE_NORMAL
- en: In the first part, we will look at how to reverse engineer the standard application
    to look at and learn how it works and how to reuse the structures in our own solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of the chapter, we will learn how to use the journals and
    entries in a custom application.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will look at how to integrate our solution with the standard application;
    in our case, sales invoicing.
  prefs: []
  type: TYPE_NORMAL
- en: Fit-gap analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we do a fit-gap analysis, we look at the company's processes and define
    what we can and cannot do with the standard package. When a business process can
    be handled with the standard software we call this a **Fit**. When this cannot
    be done it's called a **Gap**. All gaps have to be either developed or we need
    to purchase an add-on.
  prefs: []
  type: TYPE_NORMAL
- en: However, even when something could be done with standard software features it
    does not necessarily mean that doing this is wise. The standard application should
    be used for what it is designed for. Using standard features for something else
    might work in the current version but if it changes in a new version it might
    no longer fit. For this reason it is better to design something new instead of
    wrongly using standard features.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a squash court application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic process of a squash court company is renting the courts to squash
    players; both members and non-members. There is a reservation and invoicing process
    handling different rates for members and non-members.
  prefs: []
  type: TYPE_NORMAL
- en: Although this could be implemented using items as squash courts and customers
    as players, this would be a typical example of using standard features wrongly.
    Instead of doing this, we will look at how items and customers are designed and
    use this to create a new squash court application.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a specific application using standard NAV features is a matter of
    **total cost of ownership** (**TCO**). If only one customer would use this solution,
    it would be better to use the standard application in a creative way. However,
    if we deploy the design from this chapter on a multi-tenant architecture and let
    thousands of companies run it, it would be economically possible to make the best
    application for the job. Keep this in mind each time you make a decision to design.
  prefs: []
  type: TYPE_NORMAL
- en: Look, learn, and love
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To determine the design for this application, we will first look at the parts
    of the standard application, which we can use to learn how they work. We will
    use this knowledge in our own design.
  prefs: []
  type: TYPE_NORMAL
- en: In Microsoft Dynamics NAV, customer and vendor master data are maintained using
    **relationship management** (**RM**). For our solution, we will create a new master
    data for squash players being the business part of the application. This will
    also be integrated with RM.
  prefs: []
  type: TYPE_NORMAL
- en: To design the squash court, we will look at the design of items in the standard
    package. The squash court will be the product part of our application with a journal
    to create reservation entries, which we can invoice.
  prefs: []
  type: TYPE_NORMAL
- en: For this invoicing process, we will use and integrate with the sales part of
    Microsoft Dynamics NAV.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the table and posting schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After we have decided on the design of our application, we can draw the tables
    and post the routines as we did in the previous chapter. This will clarify the
    design for others and guide us through the development process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing the table and posting schema](img/0365EN_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the objects in **Relationship Management** and **Sales**
    are standard objects that we will possibly need to modify. The objects for the
    **Squash Application** are new objects but based on similar objects in the standard
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The project approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to keep track of our project, we'll cut the changes into smaller tasks.
    The first task will be to do the changes in relationship management to be able
    to create a squash player from a contact. The second part is to create squash
    courts. The reservation and invoice processes are part three and four.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing with the standard application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our schema, we can see that we have two processes where we need to work on
    the standard Microsoft Dynamics NAV processes, which are **Relationship Management**
    and **Sales**.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create the squash court application, we can use proven design patterns. This
    will limit the risk of our development's success and make it easy to communicate
    with others who are familiar with the patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of the patterns we will use are master data, number series, and journals.
  prefs: []
  type: TYPE_NORMAL
- en: Not everything that you need will be documented in patterns. Sometimes it is
    necessary to innovate. If you do this, it is important to still imagine your design
    as a pattern and document it for future use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first part of the design process, we will look at how to reverse engineer
    the standard application in order to learn and reuse the knowledge in our own
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Creating squash players
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the administration of our squash players, we use the data from the contact
    table. In the standard product, it is possible to create a customer or vendor
    with the contact data. We require the same functionality to create squash players
    so let's have a look at how this is done by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **Contact Card** and try to find this function, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating squash players](img/0365EN_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We want a function like this for our squash players. So let''s get in and see
    what it does. For this, we need to design the page and look at the actions. The
    page number in this case is **5050**, which we can find by clicking on **About
    this Page** in the top-right corner of the page, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating squash players](img/0365EN_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This option can be very useful to find information about the fields that are
    not on the page, the filters, or the source table.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating squash players](img/0365EN_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To open the page, we need to open **Object Designer** in **Development Environment**
    (*Shift* + *F12*), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating squash players](img/0365EN_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can find **5050 Contact Card** in **Page**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating squash players](img/0365EN_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are looking for **Actions** on this page. They are kind of difficult to find
    if you are unfamiliar with **Page Designer**. To open **Actions**, the cursor
    should be on the blank line below the last populated line. Then click on the right
    mouse button and **Actions** or select **Actions** from the **View** drop-down
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating squash players](img/0365EN_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively, you can also use the **Preview** option from the **View** drop-down
    menu to find the action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are in the **Action Designer** and we can search for the **Create as**
    option. To see what it does, we need to go into the C/AL code by pressing *F9*
    or by selecting **C/AL Code** from the **View** drop-down menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating squash players](img/0365EN_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: CreateVendor versus CreateCustomer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Microsoft Dynamics NAV, there is a small difference between creating a customer
    and a vendor from a contact. When creating a customer, the system will ask us
    to select a customer template. The **Vendor** option does not have that. To keep
    things simple, we will look at and learn from the `Vendor` function in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The customer and vendor table are almost identical in structure and fields are
    numbered similarly in both tables. This is called transaction mirroring between
    sales and purchasing, which we will discuss further in [Chapter 6](ch06.html "Chapter 6. Trade"),
    *Trade*. We will mirror our new table in a similar way to the other Microsoft
    Dynamics NAV tables.
  prefs: []
  type: TYPE_NORMAL
- en: The C/AL code in **Action** tells us that when clicking on the **Menu** option,
    the function `CreateVendor` in the contact table is started. To copy this feature,
    we need to create a new function, `CreateSquashPlayer`. Let's keep that in mind
    while we dive further in this code.
  prefs: []
  type: TYPE_NORMAL
- en: '![CreateVendor versus CreateCustomer](img/0365EN_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the contact table (5050) and search for the function `CreateVendor`. You
    can find functions in a table by going into the C/AL code (*F9*) from anywhere
    in the table designer, and by using the **Find [Ctrl+F]** function, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CreateVendor versus CreateCustomer](img/0365EN_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reverse engineering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to reverse engineer this code in order to see what we need to create
    for our `CreateSquashPlayer` function. We will look at each part of the C/AL code
    in order to decide whether we need it or not.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering](img/0365EN_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What does the following piece of code do?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This tests the current record for a valid `Company No`. If this fails, we cannot
    continue and the end user gets a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This reads the `Marketing Setup` table from the system and tests whether the
    `Bus. Rel. Code for Vendors` is valid. We need a new code for squash players here,
    which will be added as a new field to the setup table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `Vendor` table is cleared and a function is called within that table,
    then a new record is inserted in the database while activating the necessary business
    logic. Then the same function is called again with another parameter. Since the
    `Vendor` table is what we are copying, we will write down that we might need a
    similar function as `SetInsertFromContact`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code checks whether the current contact is a company. If so, it populates
    the `ContComp` variable with this record. If not, it populates `ContComp` with
    the company our current contact is related to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ContBusRel` function refers to the table Contact Business Relation (5054)
    and is a linking table in the Microsoft Dynamics NAV data model. Technically,
    a contact can be connected to multiple customers and vendors although this does
    not make sense. This table is populated here. Let''s write down that we need to
    look into this table and see if it needs changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`UpdateCustVendBank` is an external codeunit that is used with the function
    `UpdateVendor`. We might need a copy of this function for our Squash players.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives a message box for the end user that the record is
    created with the new number. Now, we have a number of things on our to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a master data table that looks like the `Vendor` table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to copy the `CreateVendor` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at the `Contact Business Relation` table and the `CustVendBank-Update (5055)`
    codeunit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at the latter to learn something important before we start with
    the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code synchronizes the contact table with the vendor table. It does that
    by using the `TRANSFERFIELDS` function. This function transfers all fields with
    the same number from one table to another. This means that we cannot be creative
    with our field numbering. For example, in the contact table, the **Name** field
    is number **2**. If we were to use a different number for the **Name** field,
    `TRANSFERFIELDS` would not copy the information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this information, our table should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering](img/0365EN_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that we use field **19** for our **Squash Player** specific field. This
    is because field **19** was used for **Budgeted Amount** in the vendor table.
    We can therefore safely assume that Microsoft will not use field **19** in the
    contact table in future.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach for this if we wanted to be even safer is to add the
    fields that are specific to our solution as fields in our add-on number series.
    In our case, it would be 123.456.700.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can copy and paste fields from one table to another table. Note that table
    relations and C/AL code in the `OnValidate` and `OnLookup` trigger is copied as
    well. If the table we want to create is similar to an existing table, we could
    also use the **Save As** option from the **File** drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add some business logic to the table. We want this table
    to use number series functionality just like the vendor table. This requires some
    standard steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First we create the setup table. A number series is defined in a setup table.
    As the **Squash Court** module will be quite sophisticated, we'll create our own.![Reverse
    engineering](img/0365EN_02_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: On MSDN, you can watch a video about the singleton pattern at [http://msdn.microsoft.com/en-us/dynamics/nav/dn722393.aspx](http://msdn.microsoft.com/en-us/dynamics/nav/dn722393.aspx).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A setup table always has a single **Primary Key** field, as shown in the preceding
    screenshot, and the necessary setup fields. This table is designed to only have
    one single record.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we create a link to the number series. Our **Squash Player** table is
    now required to have a link to the number series. We can copy this field from
    the vendor table and can make a table relation to the **No. Series** table, as
    shown in the following screenshot:![Reverse engineering](img/0365EN_02_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we add the C/AL business logic to our table, but first we need to define
    the variables that are required. These are our new **Squash Setup** table and
    the **Number Series Management** codeunits.![Reverse engineering](img/0365EN_02_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can define the variables in the specially created **C/AL Globals** menu.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Reverse engineering](img/0365EN_02_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It is highly recommended to use the Microsoft naming standard, which allows
    you to copy and paste a lot of code and makes it easier for others to read your
    code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Number Series require three places of code. This code makes sure that the business
    logic of the Number Series functionality is always followed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code goes into the `OnInsert` trigger. It populates the `No.`
    field with the next value of the Number Series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `OnValidate` trigger of the `No.` field tests when a user manually enters
    a value if that is allowed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we create a new `AssistEdit` function. This function is for readability
    and others reading your code afterwards. The code is used in the page or form
    and allows users to switch between linked number series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the Number Series are in place, we can make the necessary change in the
    Contact Business Relation table.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this table, we need to add the possibility to link squash players to contacts.
    This is done in the **Properties** window of **Table Designer** that can be accessed
    by pressing (*Shift* + *F4*) or by using the **Properties** option from the **View**
    drop-down menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering](img/0365EN_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, we add the **Squash player** option to the **Link to Table** field,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering](img/0365EN_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Options are converted to SQL Integer data types. Make sure to add some blank
    options so when Microsoft releases other functionality we are not impacted. Changing
    the integer value of an existing option field requires a lot of work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we create a table relation with our new table, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering](img/0365EN_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to expand the **CustVendBank-Update** codeunit with a new `UpdateSquashPlayer`
    function. This is a copy of the `UpdateVendor` function that we discussed before.
    We can add functions in the **Globals** menu.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to copy a function. We can create a new function manually
    and copy the C/AL code and variables, or we can select a function from the list
    and use copy and paste and then rename the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering](img/0365EN_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add the `---` line to the function, others can see that it is not a
    Microsoft function. You can also include the project name like `---Squash`. This
    also makes the code easier to upgrade or to merge with other code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code also requires a new global variable, `SquashPlayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The final piece of preparation work is to add the **Bus. Rel. Code for Squash
    Players** field to the **Marketing Setup** table, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering](img/0365EN_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the same numbering in our fields as in our objects. This makes it easier
    in the future to see what belongs to what if more functionality is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this preparation work, we can now finally go ahead and make our function
    in the contact table (5050) that we can call from the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we do not need the `SetInsertFromContact` function. This function
    enables users to create a new vendor first and create a contact using the vendor
    information. We do not want to support this method in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add the function to the page and test our functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering](img/0365EN_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Designing a journal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it is time to start on the product part of the squash application. In this
    part, we will no longer reverse engineer in detail. We will learn how to search
    in the standard functionality and reuse parts in our own software.
  prefs: []
  type: TYPE_NORMAL
- en: For this part, we will look at resources in Microsoft Dynamics NAV. Resources
    are similar to using as products as items but far less complex making it easier
    to look and learn.
  prefs: []
  type: TYPE_NORMAL
- en: Squash court master data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our company has 12 courts that we want to register in Microsoft Dynamics NAV.
    This master data is comparable to resources so we'll go ahead and copy this functionality.
    Resources are not attached to the contact table like the vendor/squash player
    tables. We need the number series again so we'll add a new number series to our
    Squash Setup table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Squash Court** table should look like this after creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Squash court master data](img/0365EN_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chapter objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this chapter some objects are required. A description of how to import
    these objects can be found in the [Appendix](apa.html "Appendix A. Installation
    Guide"), *Installation Guide*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter objects](img/0365EN_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After the import process is completed, make sure that your current database
    is the default database for the Role Tailored Client and run page 123456701, **Squash
    Setup**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter objects](img/0365EN_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From this page, select the action **Initialize Squash Application**. This will
    execute the C/AL code in the `InitSquashApp` function of this page, which will
    prepare the demo data for us to play with. The objects are prepared and tested
    in a Microsoft Dynamics NAV 2013 R2 W1 database.
  prefs: []
  type: TYPE_NORMAL
- en: Reservations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When running a squash court, we want to be able to keep track of reservations.
    Looking at standard Dynamics NAV functionality, it might be a good idea to create
    a squash player journal. The journal can create entries for reservations that
    can be invoiced.
  prefs: []
  type: TYPE_NORMAL
- en: A journal needs the object structure. The journal is prepared in the objects
    delivered with this chapter. Creating a new journal from scratch is a lot of work
    and can easily lead to making mistakes. It is easier and safer to copy an existing
    journal structure from the standard application that is similar to the journal
    we need for our design.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we have copied the Resource Journals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reservations](img/0365EN_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can export these objects in text format and then rename and renumber the
    objects to be reused easily. The Squash Journal objects are renumbered and renamed
    from the Resource Journal.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in [Chapter 1](ch01.html "Chapter 1. Introduction to Microsoft
    Dynamics NAV"), *Introduction to Microsoft Dynamics NAV*, all journals have the
    same structure. The template, batch, and register tables are almost always the
    same whereas the journal line and ledger entry table contain function-specific
    fields. Let's have a look at all of them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Journal Template** has several fields, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reservations](img/0365EN_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s discuss these fields in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: This is the unique name. It is possible to define as many templates
    as required but usually one template per form ID and one for recurring will do.
    If you want journals with different source codes, you need to have more templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: A readable and understandable description for its purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test Report ID**: All templates have a test report that allows the user to
    check for posting errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Form ID**: For some journals, more UI objects are required. For example,
    the General Journals have a special form for bank and cash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Posting Report ID**: This report is printed when a user selects **Post**
    and **Print**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Force Posting Report**: Use this option when a posting report is mandatory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source Code**: Here you can enter a trail code for all the postings done
    via this journal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reason Code**: This functionality is similar to **Source Code**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recurring**: Whenever you post lines from a recurring journal, new lines
    are automatically created with a posting date defined in the recurring date formula.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No. Series**: When you use this feature the **Document No.** in the journal
    line is automatically populated with a new number from this Number Series.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Posting No. Series**: Use this feature for recurring journals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Journal Batch** has various fields, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reservations](img/0365EN_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s discuss these fields in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Journal Template Name**: The name of the journal template this batch refers
    to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: Each batch should have a unique code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: A readable and explaining description for this batch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reason Code**: When populated this **Reason Code** will overrule **the Reason
    Code** from the **Journal Template**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No. Series**: When populated this **No. Series** will overrule the **No.
    Series** from the **Journal Template**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Posting No. Series**: When populated this **Posting No. Series** will overrule
    the **Posting No. Series** from the **Journal Template**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Register** table has various fields, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reservations](img/0365EN_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Terms from the **Journal Register** tab that you need to know would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No.**: This field is automatically and incrementally populated for each transaction
    with this journal and there are no gaps between the numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**From Entry No.**: A reference to the first ledger entry created is with this
    transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To Entry No.**: A reference to the last ledger entry is created with this
    transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creation Date**: Always populated with the real date when the transaction
    was posted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User ID**: The ID of the end user who has posted the transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The journal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The journal line has a number of mandatory fields that are required for all
    journals and some fields that are required for their designed functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the journal should create a reservation which then can be invoiced.
    This requires some information to be populated in the lines.
  prefs: []
  type: TYPE_NORMAL
- en: Reservation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reservation process is a logistical process that requires us to know the
    number of the squash court, the date, and the time of the reservation. We also
    need to know how long the players want to play. To check the reservation, it might
    also be useful to store the number of the squash player.
  prefs: []
  type: TYPE_NORMAL
- en: Invoicing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the invoicing part, we need to know the price we need to invoice. It might
    also be useful to store the cost to see our profit. For the system to figure out
    the proper G/L Account for the turnover, we also need to define a General Product
    Posting Group. We will see more of how that works later in [Chapter 3](ch03.html
    "Chapter 3. Financial Management"), *Financial Management*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Invoicing](img/0365EN_02_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s discuss these fields in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Journal Template Name**: This is a reference to the current **Journal Template**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line No.**: Each journal has a virtually unlimited number of lines; this
    number is automatically incremented by 10000 allowing lines to be created in between.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entry Type**: This is the reservation or invoice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document No.**: This number can be used to give to the squash player as a
    reservation number. When the **Entry Type** is **Invoice**, it is the invoice
    number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Posting Date**: This is usually the reservation date but when the **Entry
    Type** is **Invoice**, it might be the date of the invoice, which might differ
    from the posting date in the general ledger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Squash Player No.**: This is a reference to the squash player who has made
    the reservation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Squash Court No.**: This is a reference to the squash court.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: This is automatically updated with the number of the squash
    court, reservation date, and times, but can be changed by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reservation Date**: This is the actual date of the reservation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**From Time**: This is the starting time of the reservation. We only allow
    whole and half hours.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To Time**: This is the ending time of the reservation. We only allow whole
    and half hours. This is automatically populated when people enter a quantity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quantity**: This is the number of hours'' playing time. We only allow units
    of 0.5 to be entered here. This is automatically calculated when the times are
    populated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit Cost**: This is the cost to run a squash court for one hour.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Total Cost**: This is the cost for this reservation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit Price**: This is the invoice price for this reservation per hour. This
    depends on whether or not the squash player is a member or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Total Price**: This is the total invoice price for this reservation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shortcut Dimension Code 1 & 2**: This is a reference to the dimensions used
    for this transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Applies-to Entry No.**: When a reservation is invoiced, this is the reference
    to the **Squash Entry No.** of the reservation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source Code**: This is inherited from the journal batch or template and used
    when posting the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chargeable**: When this option is used, there will not be an invoice for
    the reservation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Journal Batch Name**: This is a reference to the journal batch that is used
    for this transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reason Code**: This is inherited from the journal batch or template and used
    when posting the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recurring Method**: When the journal is a recurring journal, you can use
    this field to determine if the **Amount** field is blanked after posting the lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recurring Frequency**: This field determines the new posting date after the
    recurring lines are posted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gen. Bus. Posting Group**: The combination of general business and product
    posting group determines the G/L Account for turnover when we invoice the reservation.
    The **Gen. Bus. Posting Group** is inherited from the bill-to customer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gen. Prod. Posting Group**: This will be inherited from the squash player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External Document No.**: When a squash player wants us to note a reference
    number, we can store it here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Posting No. Series**: When the **Journal Template** has a **Posting No. Series**,
    it is populated here to be used when posting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bill-to Customer No.**: This determines who is paying for the reservation.
    We will inherit this from the squash player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So now we have a place to enter reservations but we have something to do before
    we can start doing this. Some fields were determined to be inherited and calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: The time field needs calculation to avoid people entering wrong values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Unit Price** should be calculated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Unit Cost**, **Posting groups**, and **Bill-to Customer No.** need to
    be inherited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the final cherry on top, we will look at implementing dimensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time calculation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to the time, we want only to allow specific start and end times.
    Our squash court can be used in blocks of half an hour. The **Quantity** field
    should be calculated based on the entered times and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have the most flexible solution possible, we will create a new table with
    allowed starting and ending times. This table will have two fields: **Reservation
    Time** and **Duration**.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Duration** field will be a decimal field that we will promote to a **SumIndexField**.
    This will enable us to use SIFT to calculate the quantity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time calculation](img/0365EN_02_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When populated the table will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time calculation](img/0365EN_02_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The time fields in the squash journal table will now get a table relation with
    this table. This prevents a user entering values that are not in the table, thus
    entering only valid starting and ending times. This is all done without any C/AL
    code and is flexible when times change later.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time calculation](img/0365EN_02_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need some code that calculates the quantity based on the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When a user enters a value in the **From Time** or **To Time** fields, the `CalcQty`
    function is executed. This checks if both fields have a value and then checks
    whether **To Time** is larger than **From Time**.
  prefs: []
  type: TYPE_NORMAL
- en: Then we place a filter on the **Reservation Time** table. Now, when a user makes
    a reservation from `8:00` to `9:00`, there are three records in the filter making
    the result of the `Calcsums` (total of all records) of duration `1,5`. Therefore,
    we find the previous reservation time and use that.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows how easy it is to use the built-in Microsoft Dynamics NAV
    functionality such as table relations and `Calcsums` instead of complex time calculations,
    which we could have also used.
  prefs: []
  type: TYPE_NORMAL
- en: Price calculation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [Chapter 1](ch01.html "Chapter 1. Introduction to Microsoft
    Dynamics NAV"), *Introduction to Microsoft Dynamics NAV*, there is a special technique
    to determine prices. Prices are stored in a table with all possible parameters
    as fields and by filtering down on these fields, the best price is determined.
    If required, extra logic is need to find the lowest (or highest) price, if more
    prices are found.
  prefs: []
  type: TYPE_NORMAL
- en: To look, learn, and love this part of the standard application, we have used
    table Sales Price (7002) and codeunit Sales Price Calc. Mgt. (7000), even though
    we only need a small part of this functionality. This mechanism of price calculation
    is used throughout the application and offers a normalized way of calculating
    sales prices. A similar construction is used for purchase prices with the table
    Purchase Price (7012) and codeunit Purch. Price Calc. Mgt. (7010).
  prefs: []
  type: TYPE_NORMAL
- en: Squash prices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our case, we have already determined that we have a special rate for members,
    but let's say we have also a special rate for daytime and evening in winter and
    summer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This could make our table look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Squash prices](img/0365EN_02_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can make special prices for members on dates for winter and summer and make
    a price valid only until a certain time. We can also make a special price for
    a court.
  prefs: []
  type: TYPE_NORMAL
- en: This table could be creatively expanded with all kinds of codes until we end
    up with table Sales Price (7002) in the standard product, which was the template
    for our example.
  prefs: []
  type: TYPE_NORMAL
- en: Price Calc Mgt. codeunit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To calculate the price, we need a codeunit similar to the standard product.
    This codeunit is called with a squash journal line record and stores all valid
    prices in a buffer table and then finds the lowest price if there is any overlap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is no price in the filter, it uses the unit price from the squash
    court, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Inherited data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use the journal for the product part of the application, we want to inherit
    some of the fields from the master data tables. In order to make that possible,
    we need to copy and paste these fields from other tables to our master data table
    and populate it.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we can copy and paste the fields from the Resource table (156).
    We also need to add code to the `OnValidate` triggers in the journal line table.
  prefs: []
  type: TYPE_NORMAL
- en: '![Inherited data](img/0365EN_02_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The squash court table, for example, is expanded with the fields **Unit Code**,
    **Unit Price**, **Gen. Prod. Posting Group**, and **VAT Prod. Posting Group**,
    as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: We can now add code to the `OnValidate` of the `Squash Court No.` field in the
    Journal Line table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Please note that unit price is used in the Squash Price Calc. Mgt. codeunit
    that is executed from the `FindSquashPlayerPrice` function.
  prefs: []
  type: TYPE_NORMAL
- en: Dimensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Microsoft Dynamics NAV, dimensions are defined in master data and posted
    to the ledger entries to be used in analysis view entries. In [Chapter 3](ch03.html
    "Chapter 3. Financial Management"), *Financial Management*, we will discuss how
    to analyze the data generated by dimensions. In between that journey they move
    around a lot in different tables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 348 | Dimension**: This is where the main dimension codes are defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table 349 | Dimension Value**: This is where each dimension can have an unlimited
    number of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table 350 | Dimension Combination**: In this table, we can block certain
    combinations of dimension codes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table 351 | Dimension Value Combination**: In this table, we can block certain
    combinations of dimension values. If this table is populated, the value `Limited`
    is populated in the dimension combination table for these dimensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table 352 | Default Dimension**: This table is populated for all master data
    that has dimensions defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table 354 | Default Dimension Priority**: When more than one master data
    record in one transaction have the same dimensions, it is possible here to set
    priorities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table 480 | Dimension Set Entry**: This table contains a matrix of all used
    dimension combinations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Codeunit 408 | Dimension Management**: This codeunit is the single point
    in the application where all dimension movement is done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our application, dimensions are moved from the squash player, squash court,
    and customer table via the squash journal line to the squash ledger entries. When
    we create an invoice, we move the dimensions from the ledger entries to the sales
    line table.
  prefs: []
  type: TYPE_NORMAL
- en: Master data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To connect dimensions to master data, we first need to allow this changing codeunit
    408 dimension management.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `TableIDArray` variable has a default number of 23 dimensions. This we have
    changed to `50`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By leaving gaps we allow Microsoft to add master data tables in future without
    us having to change our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without this change, the system would return the following error message when
    we try to use dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Master data](img/0365EN_02_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next change is to add the **Global Dimension** fields to the master data tables.
    They can be copied and pasted from other master data tables.
  prefs: []
  type: TYPE_NORMAL
- en: '![Master data](img/0365EN_02_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When these fields are validated, the `ValidateShortcutDimCode` function is
    executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Journal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we use the master data records in the journal table, the dimensions are
    copied from the default dimension table to the dimension set entry table. This
    is done using the folowing piece of code that is called from `OnValidate` of each
    master data reference field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To decide which dimensions to inherit, we should first analyze which master
    data is used in our Journal that is using default dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In our case, `Table[1]` is `Squash Player`, `Table[2]` is `Squash Court`, and
    `Table[3]` is `Customer`. The dimension management codeunit makes sure everything
    is copied. We can use standard Microsoft Dynamics NAV functions.
  prefs: []
  type: TYPE_NORMAL
- en: Posting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we post a journal using `Codeunit Squash Jnl.-Post Line (123456703)`,
    the dimensions are copied using the dimension set ID as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This field is also used from our combine invoicing report, which we will create
    later in this chapter in the **Invoicing** section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The posting process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our journal is now ready to be posted. We've implemented all business logic,
    except the posting code.
  prefs: []
  type: TYPE_NORMAL
- en: '![The posting process](img/0365EN_02_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The posting process of a journal in Microsoft Dynamics NAV has several codeunits
    for the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Jnl.-Check Line`: This codeunit checks if the journal line is valid for posting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jnl.-Post Line`: This codeunit does the actual creation of the ledger entry
    and register tables and calls other `Jnl.-Post Line` codeunits if necessary to
    provide the transaction structure in [Chapter 1](ch01.html "Chapter 1. Introduction
    to Microsoft Dynamics NAV"), *Introduction to Microsoft Dynamics NAV*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jnl.-Post Batch`: This codeunit loops though all journal lines in a journal
    batch and posts all the lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jnl.-Post`: This is the codeunit that is called from the page. It calls the
    `Jnl.-Post Batch` codeunit and takes care of some user messaging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jnl.-Post+Print`: This is the codeunit that is called when you click on **Post
    + Print**. It does the same as the `Jnl.-Post` codeunit but with the additional
    printing of a report defined in the journal template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jnl.-B.Post`: This posts all the journal lines that have no errors and marks
    the ones that have errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jnl.-B.Post+Print`: This does the same as `Jnl.-B.Post` but with the additional
    printing of a report defined in the journal template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s have a look at the check line codeunit. When it comes to testing, Microsoft
    Dynamics NAV has a simple rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Test near, Test far, Do it, Clean up*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to test the field in the journal line table, then read external
    data tables to check if all is good, and then post the lines and delete the data
    from the journal table.
  prefs: []
  type: TYPE_NORMAL
- en: It does not make sense to read the G/L setup table from the database if the
    document no. in our own table is blank, or to start the posting process and error
    out because the posting date is outside of a valid range. This would cause a lot
    of unnecessary I/O from the database to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can clearly see that fields in our table are checked
    first, and then the date validation, and lastly the dimension checking.
  prefs: []
  type: TYPE_NORMAL
- en: Post line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The actual posting code turns out to be quite simple. The values are checked
    and then a register is created or updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: All the fields are simply moved to the ledger entry table. This is what makes
    Microsoft Dynamics NAV simple and powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can clearly see how easy it is to add a field to a posting process.
    Just add the fields to the journal line, the ledger entry, and add one line of
    code to the posting process.
  prefs: []
  type: TYPE_NORMAL
- en: Invoicing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last issue on our to-do list is the invoicing process. For this, we use
    a part of the standard application.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in [Chapter 1](ch01.html "Chapter 1. Introduction to Microsoft
    Dynamics NAV"), *Introduction to Microsoft Dynamics NAV*, invoicing is done using
    a document structure with a header and a line table. This has a posting routine
    that will start the journal transactions.
  prefs: []
  type: TYPE_NORMAL
- en: For our application, we need to create the invoice document and make sure that
    when posted, it updates our sub administration.
  prefs: []
  type: TYPE_NORMAL
- en: Invoice document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sales invoice documents in Microsoft Dynamics NAV are stored in the Sales
    Header (36) and Sales Line (37) tables. We will create a report that will combine
    the outstanding reservation entries into invoices allowing the user to filter
    on a specific entry or any other field value in the squash ledger entry table.
  prefs: []
  type: TYPE_NORMAL
- en: Reports in Microsoft Dynamics NAV are not just for printing documents; we can
    also use its dataset capabilities to start batch jobs.
  prefs: []
  type: TYPE_NORMAL
- en: To enable this, our batch job needs to have a special property, `ProcessingOnly`,
    so let's start a blank report and do this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Invoice document](img/0365EN_02_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The report will browse through the squash ledger entries filtered on entry type
    **Reservation** and open **Yes**. The sorting is **Open**, **Entry Type**, **Bill-to
    Customer No.**, and **Reservation Date**. To use sorting, the fields must be defined
    together as a key in the table definition.
  prefs: []
  type: TYPE_NORMAL
- en: '![Invoice document](img/0365EN_02_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As **Bill-to Customer No.** is the first non-filtered value in the sorting,
    we can assume that if this value changes, we need a new sales header.
  prefs: []
  type: TYPE_NORMAL
- en: 'For every squash ledger entry, we will generate a sales line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Sales header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code to create a sales header is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `SetHideValidationDialog` function makes sure we don't get pop-up messages
    while validating values. This is a standard function in Microsoft Dynamics NAV,
    which is designed for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The `TRUE` parameter to the `INSERT` statement makes sure that the Number Series
    are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Sales line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a sales line, we need a minimum of the following code. Please note
    that we added the field `Applies-to Squash Entry No.` to the sales line table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add fields to the sales and purchase document tables, make sure to
    also add these to the posted equivalents of these tables with the same number.
    This way you make sure that the information is copied to the historic data. This
    is done using the `TRANSFERFIELDS` command. We will discuss these tables in [Chapter
    6](ch06.html "Chapter 6. Trade"), *Trade*.
  prefs: []
  type: TYPE_NORMAL
- en: Dialog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the combined invoicing takes some time, it might be good to show the user
    a process bar. For this, Microsoft Dynamics NAV has a standard structure.
  prefs: []
  type: TYPE_NORMAL
- en: The window shows the bill-to customer no. it is currently processing and a bar
    going from 1 percent to 100 percent. This is calculated by keeping a counter.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the process, we show a message telling the user how many invoices
    were created out of the number of squash ledger entries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To do this, we need some variables. The **Window** variable is of type **Dialog**
    whilst **Counter**, **CounterTotal**, and **CounterOK** are integers, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dialog](img/0365EN_02_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The constant **Text000** has the special values **#1##########** and **@2@@@@@@@@@@@@@**.
    The first allows us to show and update some text; the latter is used to create
    the process bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dialog](img/0365EN_02_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The result will look like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dialog](img/0365EN_02_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a best practice document about using progress bars in combination with
    the impact on performance at [http://www.mibuso.com/howtoinfo.asp?FileID=17](http://www.mibuso.com/howtoinfo.asp?FileID=17).
  prefs: []
  type: TYPE_NORMAL
- en: Posting process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, our Sales Invoice is ready so we can start making the necessary changes
    to the posting process. Posting a sales document is done using a single posting
    codeunit and some helper objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Report 297**: This report can be used to post more than one document at the
    same time with a filter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Codeunit 80**: This is the actual posting routine we are going to change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Codeunit 81**: This codeunit is called from the user interface and has a
    dialog if the user wants to ship, invoice, or both if the document is an order
    and a yes/no if the document is an invoice or credit memo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Codeunit 82**: When the user chooses post and print, this codeunit is executed,
    which does the same as **Codeunit 81** plus printing a report.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So we will make a change to **Codeunit 80**. This codeunit has a specific structure
    that we need to understand before we go in and make the change.
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The codeunit also has the *Test Near*, *Test Far*, *Do it*, and *Clean up* strategy
    so the first step is to make sure everything is in place before the actual posting
    starts. Let's have a look at how this codeunit is structured.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Sales-Post codeunit is too long to discuss in detail. We will focus on the
    most important parts and learning how to read this type of code routine.
  prefs: []
  type: TYPE_NORMAL
- en: This first part does the test near step and a part of the test far step. The
    `Ship`, `Invoice`, and `Receive` fields are set in codeunit 81 and 82 but checked
    and completed to make sure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is moving the sales header information to the history tables
    for shipment, invoice, credit memo, or return receipt header. These sections are
    commented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will discuss the relation between a sales header and the sales shipment,
    sales invoice, sales credit memo, and return receipt in [Chapter 6](ch06.html
    "Chapter 6. Trade"), *Trade*.
  prefs: []
  type: TYPE_NORMAL
- en: When this is done, the sales lines are processed. They are also moved to the
    various posted line tables. This is all part of the *Do it* section of the posting
    routine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If there is a drop shipment in a purchase order, this is handled here. We will
    discuss drop shipments in [Chapter 6](ch06.html "Chapter 6. Trade"), *Trade*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Then there is a section that creates the financial information in the general
    journal. We will go deeper into this section in [Chapter 3](ch03.html "Chapter 3. Financial
    Management"), *Financial Management*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Then the *Clean up* section starts by calculating remaining quantities, VAT,
    and deleting the sales header and sales lines if possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The *Clean up* section ends by deleting the sales document and related information
    and clearing the variables used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Making the change
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The change we are going to make is in the section where the lines are handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We will create a new function, `PostSquashJnlLn`. This way we minimize the impact
    on standard code and when we upgrade to a newer version, we can easily copy and
    paste our function and only need to change the calling place if required.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always try to design for easy upgrading whenever possible. Remember that Microsoft
    might change this code in newer versions so the more flexible we are and the more
    we manage to minimize the impact on standard code, the better.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Our new function first gets the squash ledger entry it applies to and tests
    if it's still open and the bill-to customer no. has not changed. Then, we populate
    the squash journal line with the help of the sales line and the old squash ledger
    entry. Then dimensions are handled and the squash journal line is posted.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The journal lines are never actually inserted into the database. This is for
    performance and concurrency reasons. All journal transactions here are handled
    in the service tier cache. A journal is also never populated using `Validate`.
    This makes it very clear for you to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we post an invoice, we can see that the invoice entries are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the change](img/0365EN_02_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Navigate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now covered everything that is necessary for our squash court application
    to run but there is one special function of Microsoft Dynamics NAV that needs
    changing when we add new documents and ledger entries: the `Navigate` function.'
  prefs: []
  type: TYPE_NORMAL
- en: The functionality was already discussed in [Chapter 1](ch01.html "Chapter 1. Introduction
    to Microsoft Dynamics NAV"), *Introduction to Microsoft Dynamics NAV*. The object
    is a single page (344) in the application that requires two changes.
  prefs: []
  type: TYPE_NORMAL
- en: FindRecords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first function we change is `FindRecords`. This browses through the database
    finding all possible combinations of document no. and posting date.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The function first checks if we have permission to read the squash ledger entry
    table. If our system administrator does not allow us to see this table, it should
    not show up.
  prefs: []
  type: TYPE_NORMAL
- en: The filtering is done on the document no. and posting date. When ready, the
    system inserts the number of found records in the result table.
  prefs: []
  type: TYPE_NORMAL
- en: ShowRecords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second function to change is `ShowRecords`. This makes sure we see the squash
    ledger entries when we click on the **Show** action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now when we navigate from an invoice we posted that was generated from our
    combine invoicing report, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing](img/0365EN_02_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created our own vertical add-on application for Microsoft
    Dynamics NAV. We used similar data model and posting structures and reused parts
    of the standard application where appropriate but never wrongly used standard
    features.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to reverse engineer Microsoft Dynamics NAV code in order to find
    out what similar standard functionality to copy, paste, and change for our application.
  prefs: []
  type: TYPE_NORMAL
- en: We also found out how a journal and document posting code unit works and how
    to structure using *Test near*, *Test far*, *Do it*, and *Clean up*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the financial functionality of Microsoft
    Dynamics NAV and even make some changes to this part of the application.
  prefs: []
  type: TYPE_NORMAL
