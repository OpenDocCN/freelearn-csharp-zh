- en: Chapter 8. Reactive Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at another interesting .NET library that helps
    us create asynchronous programs, **Reactive Extensions** (**Rx**). We will cover
    the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting a collection to asynchronous `Observable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a custom `Observable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Subject` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an `Observable` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LINQ queries against an `Observable` collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating asynchronous operations with Rx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have already learned, there are several approaches to creating asynchronous
    programs in .NET and C#. One of them is event-based asynchronous pattern, which
    has already been mentioned in the previous chapters. The initial goal of introducing
    events was to simplify the implementation of the `Observer` design pattern. This
    pattern is common for implementing notifications between objects.
  prefs: []
  type: TYPE_NORMAL
- en: When we discussed the Task Parallel Library, we noted that the event's main
    shortcoming was their inability to be effectively composed with each other. The
    other drawback was that the Event-based Asynchronous Pattern was not supposed
    to be used to deal with the sequence of notifications. Imagine that we have `IEnumerable<string>`
    that gives us string values. However, when we iterate it, we do not know how much
    time one iteration will take. It could be slow, and if we use the regular `foreach`
    loop or other synchronous iteration constructs, we will block our thread until
    we have the next value. This situation is called the **pull-based** approach,
    when we as a client pull values from the producer.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite approach is the **push-based** approach, when the producer notifies
    the client about new values. This allows to offload work to the producer, while
    the client is free to do anything else in the time it waits for another value.
    Therefore, the goal is to get something like the asynchronous version of `IEnumerable`,
    which produces a sequence of values and notifies the consumer about each item
    in the sequence, when the sequence is complete or when an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework starting from version 4.0 contains the definition of the `IObservable<out
    T>` and `IObserver<in T>` interfaces that together represent the asynchronous
    push-based collection and its client. They come from the library called Reactive
    Extensions (or simply Rx) that was created inside Microsoft to help us effectively
    compose the sequence of events and all other types of asynchronous programs using
    observable collections. The interfaces were included in .NET Framework, but their
    implementations and all other mechanics are still distributed separately in the
    Rx library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rx globally is a cross-platform library. There are libraries for .NET 3.5, Silverlight,
    and Windows Phone. It is also available in JavaScript, Ruby, and Python. It is
    also open source; you can find Reactive Extensions' source code for .NET on the
    CodePlex website and other implementations on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The most amazing thing is that the observable collections are compatible with
    LINQ, and therefore, we are able to use declarative queries to transform and compose
    those collections in an asynchronous manner. This also makes it possible for us
    to use the extension methods to add functionalities to the Rx programs in the
    same way it is used in the usual LINQ providers. Reactive Extensions also supports
    transition from all asynchronous programming patterns (including the Asynchronous
    Programming Model, the Event-based Asynchronous Pattern, and the Task Parallel
    Library) to observable collections, and it supports its own way of running asynchronous
    operations, which is still quite similar to TPL.
  prefs: []
  type: TYPE_NORMAL
- en: The Reactive Extensions library is a very powerful and complex instrument, which
    is worthy of writing a separate book. In this chapter, I would like to review
    the most useful scenario, that is, how to work with asynchronous event sequences
    effectively. We will observe key types of the Reactive Extensions framework, learn
    to create sequences and manipulate them in different ways, and finally, check
    how we could use Reactive Extensions to run asynchronous operations and manage
    their options.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a collection to an asynchronous Observable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe walks you through the process of creating an observable collection
    from an `Enumerable` class and how to process it asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to create an observable collection from an `Enumerable` class
    and process it asynchronously, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a reference to the **Reactive Extensions Main Library** NuGet package by
    following these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **References** folder in the project, and select the **Manage
    NuGet Packages…** menu option.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the **Reactive Extensions - Main Library** NuGet package. You can
    search for **rx-main** in the **Manage NuGet Packages** dialog, as shown in the
    following screenshot:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/B05292_08_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we simulate a slow enumerable collection with the `EnumerableEventSequence`
    method. Then, we iterate it with the usual `foreach` cycle, and we can see that
    it is actually slow; we wait for each iteration to complete.
  prefs: []
  type: TYPE_NORMAL
- en: We then convert this enumerable collection to Observable with the help of the
    `ToObservable` extension method from the Reactive Extensions library. Next, we
    subscribe to the updates of this observable collection, providing the `Console.Write`
    method as the action, which will be executed on each update of the collection.
    As a result, we get exactly the same behavior as before; we wait for each iteration
    to complete because we use the main thread to subscribe to the updates.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We wrap the subscription objects into using statements. Although it is not always
    necessary, disposing off the subscriptions is a good practice that will help you
    avoid lifetime-related bugs.
  prefs: []
  type: TYPE_NORMAL
- en: To make the program asynchronous, we use the `SubscribeOn` method, providing
    it with the TPL task pool scheduler. This scheduler will place the subscription
    to the TPL task pool, offloading the work from the main thread. This allows us
    to keep the UI responsive and do something else while the collection gets updated.
    To check this behavior, you could remove the last `Console.ReadLine` call from
    the code. When doing so, we finish our main thread immediately, which forces all
    background threads (including the TPL task pool worker threads) to end as well,
    and we will get no output from the asynchronous collection.
  prefs: []
  type: TYPE_NORMAL
- en: If we are using a UI framework, we have to interact with the UI controls only
    from within the UI thread. To achieve this, we should use the `ObserveOn` method
    with the corresponding scheduler. For Windows Presentation Foundation, we have
    the `DispatcherScheduler` class and the `ObserveOnDispatcher` extension method
    defined in a separate NuGet package named Rx-XAML or Reactive Extensions XAML
    support library. For other platforms, there are corresponding separate NuGet packages
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom Observable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to implement the `IObservable<in T>` and `IObserver<out
    T>` interfaces to get the custom Observable sequence and properly consume it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to implement the `IObservable<in T>` and `IObserver<out T>`
    interfaces to get the custom Observable sequence and consume it, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous observable* recipe for more details
    on how to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we implement our observer first by simply printing out to the console
    the information about the next item from the observable collection, error, or
    sequence completion. This is a very simple consumer code and there is nothing
    special about it.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part is our observable collection implementation. We accept
    an enumeration of numbers into a constructor and do not check it for null on purpose.
    When we have a subscribing observer, we iterate this collection and notify the
    observer about each item in the enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we demonstrate the actual subscription. As we can see, the asynchrony
    is achieved by calling the `SubscribeOn` method, which is an extension method
    to `IObservable` and contains asynchronous subscription logic. We do not care
    about asynchrony in our observable collection; we use standard implementation
    from the Reactive Extensions library.
  prefs: []
  type: TYPE_NORMAL
- en: When we subscribe to the normal observable collection, we just get all the items
    from it. It is now asynchronous, so we need to wait for some time for the asynchronous
    operation to complete and only then print the message and wait for the user input.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we try to subscribe to the next observable collection, where we are
    iterating a null enumeration and therefore getting a null reference exception.
    We see that the exception has been properly handled and the `OnError` method was
    executed to print out the error details.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Subject type family
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to use the `Subject` type family from the Reactive
    Extensions library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the use of the `Subject` type family from the Reactive Extensions
    library, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous observable* recipe for details
    on how to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this program, we look through different variants of the `Subject` type family.
    The `Subject` type represents both the `IObservable` and `IObserver` implementations.
    This is useful in different proxy scenarios when we want to translate events from
    multiple sources to one stream, or vice versa, to broadcast an event sequence
    to multiple subscribers. Subjects are also very convenient for experimenting with
    Reactive Extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the basic `Subject` type. It retranslates an event sequence
    to subscribers as soon as they subscribe to it. In our case, the `A` string will
    not be printed out because the subscription happened after it was transmitted.
    Besides that, when we call the `OnCompleted` or `OnError` methods on `Observable`,
    it stops further translation of the event sequence, so the last string will also
    not be printed out.
  prefs: []
  type: TYPE_NORMAL
- en: The next type, `ReplaySubject`, is quite flexible and allows us to implement
    three additional scenarios. First, it can cache all the events from the beginning
    of their broadcasting, and if we subscribe later, we will get all the preceding
    events first. This behavior is illustrated in the second example. Here, we will
    have all four strings on the console because the first event will be cached and
    translated to the latter subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can specify the buffer size and the time window size for `ReplaySubject`.
    In the next example, we set the subject to have a buffer for two events. If more
    events are broadcasted, only the last two will be retranslated to the subscriber.
    So here, we will not see the first string because we have `B` and `C` in the subject
    buffer when subscribing to it. The same is the case with a time window. We can
    specify that the `Subject` type only caches events that took place less than a
    certain time ago, discarding the older ones. Therefore, in the fourth example,
    we will only see the last two events; the older events do not fit into the time
    window.
  prefs: []
  type: TYPE_NORMAL
- en: The `AsyncSubject` type is something like a `Task` type from the TPL globally.
    It represents a single asynchronous operation. If there are several events published,
    it waits for the event sequence completion and provides only the last event to
    the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: The `BehaviorSubject` type is quite similar to the `ReplaySubject` type, but
    it caches only one value and allows us to specify a default value in case we did
    not send any notifications. In our last example, we will see all the strings printed
    out because we provided a default value, and all other events take place after
    the subscription. If we move the `behaviorSubject.OnNext("B");` line upwards below
    the `Default` event, it will replace the default value in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Observable object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe different ways to create an `Observable` object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe could be found at `BookSamples\Chapter8\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand different ways of creating an `Observable` object, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous Observable* recipe for details
    on how to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we walk through different scenarios of creating `observable` objects.
    Most of this functionality is provided as static factory methods of the `Observable`
    type. The first two samples show how we can create an `Observable` method that
    produces a single value and one that produces no value. In the next example, we
    use `Observable.Throw` to construct an `Observable` class that triggers the `OnError`
    handler of its observers.
  prefs: []
  type: TYPE_NORMAL
- en: The `Observable.Repeat` method represents an endless sequence. There are different
    overloads of this method; here, we construct an endless sequence by repeating
    42 values. Then, we use LINQ's `Take` method to take five elements from this sequence.
    `Observable.Range` represents a range of values, pretty much like `Enumerable.Range`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Observable.Create` method supports more custom scenarios. There are a lot
    of overloads that allow us to use cancellation tokens and tasks, but let's look
    at the simplest one. It accepts a function, which accepts an instance of observer
    and returns an `IDisposable` object representing a subscription. If we had any
    resources to clean up, we would be able to provide the cleanup logic here, but
    we just return an empty disposable as we actually do not need it.
  prefs: []
  type: TYPE_NORMAL
- en: The `Observable.Generate` method is another way to create a custom sequence.
    We must provide an initial value for a sequence and then a predicate that determines
    whether we should generate more items or complete the sequence. Then, we provide
    an iteration logic, which increments a counter in our case. The last parameter
    is a selector function that allows us to customize the results.
  prefs: []
  type: TYPE_NORMAL
- en: The last two methods deal with timers. `Observable.Interval` starts producing
    timer tick events with the `TimeSpan` period, and `Observable.Timer` specifies
    the startup time as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using LINQ queries against an observable collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to use LINQ to query an asynchronous sequence of events.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe5`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the use of LINQ queries against the observable collection, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous observable* recipe for details
    on how to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to use LINQ against the `Observable` event sequences is the main
    advantage of the Reactive Extensions framework. There are many different useful
    scenarios as well; unfortunately, it is impossible to show all of them here. I
    tried to provide a simple, yet very illustrative example, which does not have
    many complex details and shows the very essence of how a LINQ query could work
    when applied to asynchronous observable collections.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an `Observable` event that generates a sequence of numbers,
    one number every 50 milliseconds, and we start from the initial value of zero,
    taking 21 of those events. Then, we compose LINQ queries to this sequence. First,
    we select only the even numbers from the sequence, and then only the odd numbers.
    Then, we concatenate these two sequences.
  prefs: []
  type: TYPE_NORMAL
- en: The final query shows us how to use a very useful method, `Do`, which allows
    us to introduce side effects and, for example, logging each value from the resulting
    sequence. To run all queries, we create nested subscriptions, and because the
    sequences are initially asynchronous, we have to be very careful about the subscription's
    lifetime. The outer scope represents a subscription to the timer, and the inner
    subscriptions deal with the combined sequence query and the side effects query,
    respectively. If we press *Enter* too early, we just unsubscribe from the timer
    and thus stop the demo.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the demo, we see the actual process of how different queries interact
    in real time. We can see that our queries are lazy, and they start running only
    when we subscribe to their results. The timer event's sequence is printed in the
    first column. When the even numbers query gets an even number, it prints it out
    as well using the `---` prefix to distinguish this sequence result from the first
    one. The final query results are printed in the right-hand column.
  prefs: []
  type: TYPE_NORMAL
- en: When the program runs, we can see that the timer sequence, the even-number sequence,
    and the side effect sequence run in parallel. Only the concatenation waits until
    the even-number sequence is complete. If we do not concatenate those sequences,
    we will have four parallel sequences of events interacting with each other in
    the most effective way! This shows the real power of Reactive Extensions and could
    be a good start to learn this library in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Creating asynchronous operations with Rx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to create an `Observable` from the asynchronous operations
    defined in other programming patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need Visual Studio 2015\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe6`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to create asynchronous operations with Rx, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous observable* recipe for details
    on how to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `Main` method with the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows you how to convert different types of asynchronous operations
    to an `Observable` class. The first code snippet uses the `Observable.Start` method,
    which is quite similar to `Task.Run` from TPL. It starts an asynchronous operation
    that gives out a string result and then gets completed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I would strongly suggest that you use the Task Parallel Library for asynchronous
    operations. Reactive Extensions supports this scenario as well, but to avoid ambiguity,
    it is much better to stick with tasks when speaking about separate asynchronous
    operations and to go with Rx only when we need to work with sequences of events.
    Another suggestion is to convert every type of separate asynchronous operation
    to tasks and only then convert a task to an observable class, if you need it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we do the same with tasks and convert a task to an `Observable` method
    by simply calling the `ToObservable` extension method. The next code snippet is
    about converting the Asynchronous Programming Model pattern to `Observable`. Normally,
    you would convert APM to a task and then a task to `Observable`. However, there
    is a direct conversion, and this example illustrates how to run an asynchronous
    delegate and wrap it into an `Observable` operation.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the code snippet shows that we are able to use the `await`
    operator in an `Observable` operation. As we are not able to use the `async` modifier
    on an entry method such as `Main`, we introduce a separate method that returns
    a task and waits for this resulting task to be complete inside the `Main` method.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of this code snippet is the same as the code which converts APM
    pattern to Observable, but now, we convert the Event-based Asynchronous Pattern
    directly to an `Observable` class. We create a timer and consume its events for
    5 seconds. We then dispose the timer to clean up the resources.
  prefs: []
  type: TYPE_NORMAL
