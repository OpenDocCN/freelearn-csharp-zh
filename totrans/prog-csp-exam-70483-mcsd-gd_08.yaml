- en: Creating and Using Types in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Types are the building blocks of a C# program. Even while writing a basic C#
    program, we must use the right types while creating our program. In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml),
    *Understanding Classes, Structures, and Interfaces*, we learned the basics of
    types in a C# program. We learned about the value and reference type variables
    that are present in a C# program.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In addition to awareness of the different types, we should also understand that
    it's quite important for us to use each type in the best possible circumstance
    or situation. We also should be aware of the best practices regarding the creation
    and usage of these types. We will be going through this in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We will walk through the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Creating types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use properties to enforce encapsulation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using of optional and named parameters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating indexed properties
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different operations related to string manipulation in C#
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will have an overview of **reflection** and try to understand how it can
    help us find, execute, and create types at runtime. In [Chapter 10](b7bdae98-fc5b-4430-bb0d-b8541ca64f8d.xhtml),
    *Find, Execute, and Create Types at Runtime Using Reflection*, we will do a deep
    dive into reflection.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like in the previous chapters covered in this book, the programs explained in
    this book will be developed in Visual Studio 2017.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Creating types
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we create a variable in C#, it provides us with plenty of options to choose
    the appropriate type of the variable. For example, we can choose the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: We can choose an `enum` type if we would like the variable to acquire a defined
    set of variables. For example, if we define `Day` as an `enum` type, it can acquire
    the values `Monday`, `Tuesday`, `Wednesday`, `Thursday`, `Friday`, `Saturday`,
    and `Sunday`.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, if we choose an `int` type, we tell **common language runtime** (**CLR**)
    that it cannot have decimal digits.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, while defining types for any variables, we have to analyze the usage
    of the variable logically and then declare its type in C#. In the next section,
    we will just do a brief revision of the different types that we covered in the
    *Data types in C#* section in [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml),
    *Understanding Classes, Structures, and Interfaces*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Types in C#
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml), *Understanding
    Classes, Structures, and Interfaces*, we learned that a variable can acquire the
    following types of values:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Value types**: In value types, the variables contain the actual value of
    the variable. This basically implies that if any change is made to a value type
    variable in a different scope of the program, the change is not reflected back
    once the control shifts to the calling function.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值类型**：在值类型中，变量包含变量的实际值。这基本上意味着，如果在程序的不同作用域中对值类型变量进行更改，更改在控制权转移到调用函数后不会反映回来。'
- en: '**Reference types**: The data member contains the exact address of the variable
    in memory. As the variable just contains a reference to a memory address, two
    separate reference type variables can point to the same memory address. Therefore,
    if a change is made in a reference type variable, the change is made directly
    at the memory location of the variable and hence is carried forward to the different
    scopes present in the program execution.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用类型**：数据成员包含变量在内存中的确切地址。由于变量仅包含对内存地址的引用，两个单独的引用类型变量可以指向相同的内存地址。因此，如果对引用类型变量进行更改，更改将直接在变量的内存位置进行，因此会传播到程序执行中的不同作用域。'
- en: '**Pointer types**: Pointers are another type of variable possible in C#. The
    pointer type is used to save the memory address of variable allowing us to any
    operation involving the memory location of the variable.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指针类型**：指针是 C# 中可能存在的另一种变量类型。指针类型用于保存变量的内存地址，使我们能够执行涉及变量内存位置的任何操作。'
- en: In the next section, we will do a deep dive into pointers and understand the
    implications and benefits of using them in our application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入研究指针，并了解它们在我们应用程序中使用时的影响和好处。
- en: Unsafe code and the use of pointer types
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全代码和指针类型的使用
- en: 'In languages such as C or C++, developers have the features to create *pointers*
    or `*`, which is an object that stores the memory address of another variable.
    This object allowed very low-level access of the memory to the application. However,
    due to the possibility of *dangling pointers,* the performance of the application
    suffers greatly. A dangling pointer is a potential situation that could exist
    in C when a pointer object is still pointing to a memory location that is no longer
    allocated in the application. Please refer to the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 或 C++ 等语言中，开发者具有创建 *指针* 或 `*` 的功能，这是一个存储另一个变量内存地址的对象。该对象允许应用程序对内存进行非常低级别的访问。然而，由于存在
    *悬垂指针* 的可能性，应用程序的性能会大大降低。悬垂指针是 C 中可能存在的一种潜在情况，即指针对象仍然指向应用程序中不再分配的内存位置。请参考以下图表：
- en: '![](img/802e881c-7877-43ee-bb98-865128cbac44.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/802e881c-7877-43ee-bb98-865128cbac44.png)'
- en: In the diagram, we have an application running in C or C++ that declared Pointer
    B and pointed it to the memory address of variable A. The pointer saves the memory
    address of the variable. Hence, in other words, Pointer B will not contain the
    memory address of variable A. Now, at some point during the program run, memory
    location A was released by the application. Even though the memory was released,
    there could be circumstances when we do not explicitly clear out the contents
    of the pointers containing the respective memory address. Due to this mistake
    or oversight, Pointer B was not updated to point to a new block of memory or pointing
    it to null. As a result, the pointer is still referring to a memory location that
    no longer exists in the application. This situation is called **dangling pointers**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们有一个运行在 C 或 C++ 中的应用程序，它声明了指针 B 并将其指向变量 A 的内存地址。指针保存了变量的内存地址。换句话说，指针 B
    不会包含变量 A 的内存地址。现在，在程序运行期间某个时刻，应用程序释放了内存位置 A。尽管内存已被释放，但可能存在我们未明确清除包含相应内存地址的指针内容的情形。由于这个错误或疏忽，指针
    B 没有更新以指向新的内存块或将其指向 null。因此，该指针仍然引用着应用程序中不再存在的内存位置。这种情况被称为 **悬垂指针**。
- en: C# removes the possibility of dangling pointers because, explicitly, it does
    not allow the use of pointers. Instead, it encourages people to use *reference
    types*. The memory management of *reference types* is managed by a garbage collector.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: C# 通过明确不允许使用指针来消除悬垂指针的可能性。相反，它鼓励人们使用 *引用类型*。引用类型的内存管理由垃圾回收器管理。
- en: In [Chapter 9](b13c398c-8c38-4c9e-804f-2e0a2eb0ddbe.xhtml), *Managing the Object
    Life Cycle*, we will look further at how the garbage collector works in .NET.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 9 章](b13c398c-8c38-4c9e-804f-2e0a2eb0ddbe.xhtml)，*管理对象生命周期* 中，我们将进一步探讨垃圾回收器在
    .NET 中的工作原理。
- en: However, there are still some circumstances when developers feel the need to
    use pointers in their C# application. This is useful in scenarios where we need
    to do some operations with the underlying operating system, such as Windows or
    Linux, in which the application is running. In such circumstances, we will need
    pointers. To cater to such scenarios, C# has the concept of `unsafe` *code* in
    which it allows developers to use pointers in their code. The code that uses pointers
    must be classified clearly with an identifier of `unsafe`. This keyword conveys
    the message to **Common Language Runtime** (**CLR**) that the code block is unmanaged
    or unsafe—or, in other words, has used pointers. Let's go through a code example
    to see how we use pointer types in C#.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，开发者仍然觉得需要在他们的 C# 应用程序中使用指针。这在需要与底层操作系统（如 Windows 或 Linux）进行某些操作的场景中很有用，在这些操作中应用程序正在运行。在这种情况下，我们将需要指针。为了适应这些场景，C#
    有一个名为 `unsafe` 的 *代码* 概念，它允许开发者在代码中使用指针。使用指针的代码必须明确地用 `unsafe` 标识符进行分类。这个关键字向
    **公共语言运行时**（**CLR**）传达信息，即代码块是不受管理的或是不安全的——换句话说，已经使用了指针。让我们通过一个代码示例来看看我们如何在 C#
    中使用指针类型。
- en: 'In the code example, we are creating a function block in which we are using
    a pointer variable. We will be saving the address of an `int` type in an `int`
    pointer type variable. Please refer to the following screenshot. Note that the
    user gets an error when they try to compile the program:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，我们创建了一个函数块，在其中我们使用指针变量。我们将保存 `int` 类型地址的 `int` 指针类型变量。请参考以下截图。请注意，当用户尝试编译程序时，他们会得到一个错误：
- en: '![](img/510e540a-326a-4c58-aedf-aa5e70fec8a2.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/510e540a-326a-4c58-aedf-aa5e70fec8a2.png)'
- en: 'The reason is that, by default, the C# compiler will not allow any code containing
    a pointer or `unsafe` code block to be executed. We can override this behavior
    of C# by using the `unsafe` keyword in the function block:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是，默认情况下，C# 编译器不会允许任何包含指针或 `unsafe` 代码块的代码执行。我们可以通过在函数块中使用 `unsafe` 关键字来覆盖
    C# 的这种行为：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To allow the compilation of `unsafe` code, we will need to change the build
    setting in Visual Studio. To update the settings, we need to right-click on the
    Project and click on Properties. Now, navigate to the Build section. Please refer
    to the following screenshot, which highlights the Visual Studio setting that we
    need to specify to allow compilation of `unsafe` code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许编译 `unsafe` 代码，我们需要更改 Visual Studio 的构建设置。要更新设置，我们需要右键单击项目并单击属性。现在，导航到构建部分。请参考以下截图，它突出显示了我们需要指定的
    Visual Studio 设置，以允许编译 `unsafe` 代码：
- en: '![](img/8ace30ca-abea-4c55-9fe6-ed2b5b31f0ee.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ace30ca-abea-4c55-9fe6-ed2b5b31f0ee.png)'
- en: Now we have revisited the different types possible in C#. The next section explains
    the guiding principles that help us select a particular variable type over another.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了 C# 中可能的不同类型。下一节将解释帮助我们选择特定变量类型而不是其他类型的指导原则。
- en: Choosing the type of variable
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择变量类型
- en: In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml), *Understanding Classes,
    Structures, and Interfaces*, in the *Data types in C#* section, we saw the different
    data types that are possible for both value and reference types. We also did a
    code implementation to see the difference in the behavior of `Struct`, which is
    a value type, and `Class`, which is a reference type. In this section, we will
    do a deep dive and see this difference in behavior and how it can help us to choose
    the correct type for our variable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml) 的 *理解类、结构和接口* 部分，在 *C#
    中的数据类型* 部分中，我们看到了值类型和引用类型可能的不同数据类型。我们还进行了代码实现，以查看 `Struct`（值类型）和 `Class`（引用类型）的行为差异。在本节中，我们将深入探讨这种行为差异，以及它如何帮助我们为变量选择正确的类型。
- en: 'Let''s analyze how the following code statements for value and reference types
    and see how they differ in implementation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析以下代码语句中的值类型和引用类型，看看它们在实现上的差异：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we have declared the value type variables `x` and `y`.
    While declaring, the `x` variable has been assigned a value. In the next step,
    we are assigning `x` to `y`. Similarly, we have a class named `Class` and we have
    created an object of `c`. In the next statement, we have declared another object
    of the same class and have assigned `c` to `c2`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了值类型变量 `x` 和 `y`。在声明时，`x` 变量已被赋予一个值。在下一步中，我们将 `x` 赋予 `y`。同样，我们有一个名为
    `Class` 的类，我们创建了 `c` 的对象。在下一个语句中，我们声明了同一类的另一个对象，并将 `c` 赋予 `c2`。
- en: 'Please refer to the following diagram, which shows how these types are implemented
    and managed inside memory:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下图表，它显示了这些类型如何在内存中实现和管理：
- en: '![](img/73206554-2d6c-496d-be16-c0840aab7814.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73206554-2d6c-496d-be16-c0840aab7814.png)'
- en: 'In the preceding diagram, we have declared variable `x` as an `int` data type
    and `c` as an object of the `Car` class. Now, we know that `int` is a value type,
    while `Class` is a reference type. So let''s try to analyze why the behavior differs
    for both of them:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们已将变量`x`声明为`int`数据类型，将`c`声明为`Car`类的对象。现在，我们知道`int`是值类型，而`Class`是引用类型。所以让我们尝试分析为什么两者的行为不同：
- en: For `x`, in the first statement, that is, `int x = 10`, a block of memory is
    reserved by the application. The rectangular block below the declaration conveys
    that.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`x`，在第一个语句中，即`int x = 10`，应用程序为其保留了一块内存。声明下方的矩形块表示这一点。
- en: Now, when we execute the `int y = x` statement, we are declaring another variable,
    `y`, and it is assigned the value currently in `x`. What it does internally is
    it allocates another block of memory for `y` in memory. Therefore, as `x` and
    `y` are not pointing to the same memory location, they will hold different values.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，当我们执行`int y = x`语句时，我们正在声明另一个变量`y`，并将其分配给`x`当前值。它内部所做的就是为`y`在内存中分配另一块内存。因此，由于`x`和`y`不指向相同的内存位置，它们将持有不同的值。
- en: 'On the other hand, if we look at the `Car` class, we have just declared two
    attributes in it: the registration number and color. Now, when we use the `new`
    statement, what it does is that it creates an object for the class and allocates
    it memory. However, as against the value type implementation, it does not save
    the value in the object. Instead, in the object, it just saves a reference to
    the allocated memory block. In the rectangular shape in the preceding diagram,
    you will see that, once the `c` object is created for the `Car` class, a pointer
    is saved in the created object.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，如果我们看看`Car`类，我们刚刚在其中声明了两个属性：注册号和颜色。现在，当我们使用`new`语句时，它所做的就是为该类创建一个对象并为其分配内存。然而，与值类型实现相反，它不会在对象中保存值。相反，在对象中，它只保存对分配的内存块的引用。在前面的矩形图中，您将看到，一旦为`Car`类创建了`c`对象，就会在创建的对象中保存一个指针。
- en: Now, when we execute the `Car c2 = c;` statement, internally, it creates a new
    object, `c2`, but does not allocate a new memory block for the object. Instead,
    it just saves a reference to the memory location shared with the object, `c`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，当我们执行`Car c2 = c;`语句时，内部会创建一个新的对象`c2`，但不会为该对象分配新的内存块。相反，它只是保存了对与对象`c`共享的内存位置的引用。
- en: As illustrated by the preceding implementation, whenever a new value type variable
    is declared, a new block of memory is reserved by the application, which is different
    from reference type variables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的实现所示，每当声明一个新的值类型变量时，应用程序都会为其保留一块新的内存，这与引用类型变量不同。
- en: 'Hence, in much simpler terms, the following factors can help us to choose between
    value and reference type:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用更简单的术语来说，以下因素可以帮助我们选择值类型和引用类型：
- en: '**A value type variable is logically immutable**: In very simple terms, it
    means that on every declaration of the value type, a new block of memory is reserved
    by the application. As they are different memory allocations, it implies that
    if we execute any operation on one memory location, the change is not transmitted
    across to the other memory location.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值类型变量的逻辑不可变性**：用非常简单的话来说，这意味着在每次声明值类型时，应用程序都会为其保留一块新的内存。由于它们是不同的内存分配，这意味着如果我们对某个内存位置执行任何操作，该变化不会传递到另一个内存位置。'
- en: '**Whether there are lots of objects**: If there lots of objects being created
    in the application, it might be better to not create them as value type as it
    would exponentially increase the memory requirements of the application.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象的数量**：如果应用程序中创建了大量的对象，那么最好不将它们作为值类型创建，因为这会指数级增加应用程序的内存需求。'
- en: '**Whether the object is small**: If the object is small, then it may make sense
    to have them as value type variables. However, if we think that the object is
    bound to have too many properties, a reference type variable will make more sense.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象的大小**：如果对象很小，那么将它们作为值类型变量可能是有意义的。然而，如果我们认为对象可能有很多属性，那么引用类型变量将更有意义。'
- en: '**Memory management**: Value type variables are managed on a stack whereas
    reference type variables are managed on a heap. When we move to [Chapter 9](b13c398c-8c38-4c9e-804f-2e0a2eb0ddbe.xhtml),
    *Manage the Object Life Cycle*, we will look further into memory management and
    how the garbage collector works.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存管理**：值类型变量在栈上管理，而引用类型变量在堆上管理。当我们进入第9章[Chapter 9](b13c398c-8c38-4c9e-804f-2e0a2eb0ddbe.xhtml)，*管理对象生命周期*时，我们将进一步探讨内存管理以及垃圾回收器的工作原理。'
- en: Now that we have a fair understanding of how we can create and consume different
    data types in a C# application, we will be looking at some of the features of
    C# that help us to set correct behavior for the different types we use in the
    application. In the next section, we will be looking at static variables and how
    they are implemented in C#.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何在C#应用程序中创建和消费不同数据类型有了相当的了解，我们将探讨一些C#的特性，这些特性帮助我们为应用程序中使用的不同类型设置正确的行为。在下一节中，我们将探讨静态变量以及它们在C#中的实现方式。
- en: Static variables
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态变量
- en: When we went over the section on value type versus reference type, we understood
    that all of the objects created in C# have a definite scope in the program execution.
    However, there could be some circumstances when we would like to have a variable
    acquire a constant value that is consistent across all instances of the objects.
    We can do this using the `Static` keyword. A `Static` keyword in a modifier in
    C# ensures that just one instance of the variable is created and its scope is
    throughout the entire run of the program. We can use a `Static` variable against
    a class, its member variable, and its member methods and constructors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论值类型与引用类型时，我们了解到在C#中创建的所有对象在程序执行中都有确定的范围。然而，在某些情况下，我们可能希望变量获取一个在所有对象实例中一致的常量值。我们可以使用`Static`关键字来实现这一点。在C#中，`Static`关键字作为修饰符确保只创建一个变量的实例，并且其作用域是整个程序的运行。我们可以使用`Static`变量针对类、其成员变量、其成员方法和构造函数。
- en: Let's now look at code examples involving the `Static` keyword.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些涉及`Static`关键字的代码示例。
- en: Static member variables
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态成员变量
- en: 'In this section, we will look at how we can use the `Static` keyword against
    a class and its member variables. In the following code example, we have created
    a `Static` class called `Configuration`. Just for the sake of explanation, we
    will not be using the `Static` keyword for a member variable present in it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用`Static`关键字针对类及其成员变量。在下面的代码示例中，我们创建了一个名为`Configuration`的`Static`类。仅为了解释，我们不会在其中的成员变量上使用`Static`关键字：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s try to compile the program. We get an error stating that the `ConnectionString`
    member variable must be declared `static` as well:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编译程序。我们得到一个错误，指出`ConnectionString`成员变量也必须声明为`static`：
- en: '![](img/6928a105-8aa5-4b1c-8cd7-77d02081d970.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6928a105-8aa5-4b1c-8cd7-77d02081d970.png)'
- en: 'Once we use the `static` keyword against the `ConnectionString` member variable
    as well, the error goes away. This is the correct representation of the class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将`static`关键字应用于`ConnectionString`成员变量，错误就会消失。这是类的正确表示：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we need to use `Set`/`Get` value in the member variable, we can access it
    directly by using the name of the class. Here is the code snippet for this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在成员变量中使用`Set`/`Get`值，我们可以通过使用类的名称直接访问它。以下是这个代码片段：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code example, we had a `Static` class `Configuration` in which
    it was mandatory to have the `static` modifier against all of the member variables
    and properties. However, there could be some circumstances when we don't want
    the entire class to be static but just a particular member variable present inside
    it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们有一个名为`Configuration`的`Static`类，其中所有成员变量和属性都必须有`static`修饰符。然而，在某些情况下，我们可能不希望整个类都是静态的，而只是其中的某个成员变量。
- en: 'We can achieve this in C# by using the `static` modifier not against the class
    but against the particular member variable. If we need to use this in the preceding
    code, the following would be the updated code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在C#中使用`static`修饰符而不是类来达到这一点，而是针对特定的成员变量。如果我们需要在前面代码中使用它，以下将是更新的代码：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, there will be no change in the way we access this property. It can
    still be done by using the name of the class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，访问这个属性的方式将不会改变。我们仍然可以通过使用类的名称来完成。
- en: Static methods
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法
- en: 'In C#, a class can have two types of methods: static methods and non-static
    methods. Static methods are shared across the different instances of the class
    objects, whereas non-static methods are unique for each instance. Just like static
    member variables, we can declare a method as static by the use of the `static`
    keyword and can access them by directly using the class name.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，一个类可以有两种类型的方法：静态方法和非静态方法。静态方法在类的不同实例对象之间共享，而非静态方法对每个实例都是唯一的。就像静态成员变量一样，我们可以使用`static`关键字声明一个方法为静态，并通过直接使用类名来访问它们。
- en: 'The following code example indicates how we create a `static` method in a class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例表明我们如何在类中创建一个`static`方法：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To execute a static method, we can use the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行静态方法，我们可以使用以下代码片段：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the next section, we will look at constructors and how they are implemented
    in C#.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨构造函数及其在C#中的实现。
- en: Constructors
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: Constructors are called whenever an object is created for a `class` or `struct`
    type. They can help us to set some default values against the member variables
    present in these types.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每当为`class`或`struct`类型创建对象时都会调用构造函数。它们可以帮助我们在这些类型中设置一些默认值。
- en: In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml), *Understanding Classes,
    Structures, and Interfaces*, while understanding the difference between a `class`
    and `struct` type, we mentioned that, unlike classes, structs do now have a default
    constructor. That constructor, in programming terms, is known as a **parameter
    less constructor**. If a programmer does not specify any constructor for the class,
    then whenever an object is created for the class the default constructor triggers
    and sets default values against the member variables present in the class. The
    default values are set in accordance with the default values of the type of those
    member variables.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml)“理解类、结构和接口”中，当我们理解`class`和`struct`类型之间的区别时，提到与类不同，结构体现在没有默认构造函数。在编程术语中，这个构造函数被称为**无参构造函数**。如果一个程序员没有为类指定任何构造函数，那么每当创建类的对象时，默认构造函数就会触发，并为类中存在的成员变量设置默认值。这些默认值是根据这些成员变量的类型默认值设置的。
- en: In terms of syntax, a constructor is just a method the name of which is the
    same as that of its respective type. In the method signature, it has got a parameter
    list that can be mapped to the member variables present in the type. It does not
    have any return type.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法方面，构造函数只是名称与其相应类型相同的函数。在方法签名中，它有一个参数列表，可以映射到类型中存在的成员变量。它没有返回类型。
- en: Please note that a class or struct can have multiple constructors each differing
    with each other based on the parameter list present in the method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个类或结构体可以有多种构造函数，每种构造函数的参数列表都不同。
- en: 'Let''s look at a code example in which we will implement constructors:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码示例，我们将在这个示例中实现构造函数：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code example, we have declared an `Animal` class with two member
    variables, `Name` and `Type`. We have also declared a two-parameter constructor
    in which we are passing `Name` and `Type` as string parameters. Using the `this`
    operator, we are then assigning the values passed to the member variables present
    in the class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们声明了一个具有两个成员变量`Name`和`Type`的`Animal`类。我们还声明了一个接受`Name`和`Type`作为字符串参数的两个参数构造函数。然后，我们使用`this`运算符将传递给成员变量的值赋给类中存在的成员变量。
- en: 'We can use the following code implementation to call this constructor:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码实现来调用这个构造函数：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the next section, we will look at how named parameters are implemented in
    C#.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在C#中实现命名参数。
- en: Named parameters
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名参数
- en: Named parameters were introduced in C# 4.0, and they allow us to pass arguments
    to a method/constructor/delegate/indexer using parameter names instead of the
    sequence in which the parameters are passed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数是在C# 4.0中引入的，它允许我们使用参数名而不是参数传递的顺序将参数传递给方法/构造函数/委托/索引器。
- en: 'Using named parameters, developers no longer need to be concerned about the
    sequence in which they need to pass parameters. As long as they associate the
    values being passed with the right parameter name, the sequence will not matter.
    The parameter names are compared against the names of the parameters in the method
    definition. Let''s look at the following code example to understand how it works:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名参数，开发者不再需要担心传递参数的顺序。只要他们将与传递的值关联正确的参数名称，顺序就无关紧要。参数名称将与方法定义中参数的名称进行比较。让我们通过以下代码示例来了解它是如何工作的：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code example, we are calculating compound interest by passing
    the principal amount, interest rate, and number of years for which the amount
    was put in the bank.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们通过传递本金、利率和金额存入银行的时间长度来计算复利。
- en: 'If we call the method without using named parameters, we would use the following
    code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用命名参数来调用方法，我们将使用以下代码片段：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we look closely at the preceding example, while calling the function, the
    developer will need to be fully aware of the sequence of the principle and interest
    rate parameters. That's because if the developer makes a mistake while calling
    the function, the resultant output will be incorrect.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察前面的示例，在调用函数时，开发者需要完全清楚本金和利率参数的顺序。这是因为如果开发者在调用函数时出错，结果输出将是不正确的。
- en: 'With named parameters, we can call the method using the following syntax:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名参数，我们可以使用以下语法调用方法：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that, in the preceding code, we are not passing values to the parameters
    in the sequence there are defined in the method. Instead, we are using parameter
    names to map the passing values with the parameters declared in the method. In
    the next section, we will look at another feature, *optional parameters,* which
    was introduced in C# 4.0 along with named parameters.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的代码中，我们不是按照方法中定义的顺序传递参数值，而是使用参数名称将传递的值与方法中声明的参数进行映射。在下一节中，我们将探讨 C# 4.0
    中引入的另一个特性，即 *可选参数*，它与命名参数一起引入。
- en: Optional parameters
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选参数
- en: Optional parameters in C# allow us to define a method in such a way that some
    of the parameters are optional. In other words, while defining the function for
    the optional parameters, a default value is specified.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的可选参数允许我们以这种方式定义方法，即某些参数是可选的。换句话说，在定义可选参数的函数时，我们指定了一个默认值。
- en: 'If, while calling the method, no value is passed for the optional parameter,
    it assumes a default value. Let''s look at a code example to understand how optional
    parameters work in C#:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用方法时未为可选参数传递值，它将假定一个默认值。让我们通过一个代码示例来了解 C# 中可选参数的工作方式：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code example, we have defined a `MultiplyNumbers` method with
    three parameters, `num1`, `num2`, and `num3`. The `num1` parameter is mandatory,
    while the other two parameters, `num2` and `num3`, are optional.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们定义了一个具有三个参数的 `MultiplyNumbers` 方法，分别是 `num1`、`num2` 和 `num3`。`num1`
    参数是必需的，而其他两个参数 `num2` 和 `num3` 是可选的。
- en: Please note that, while defining the function, the optional parameters, if any,
    must come after all of the required parameters have been specified in the sequence.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在定义函数时，如果存在可选参数，则必须将它们放在所有必需参数之后指定。
- en: 'If we need to execute the preceding method, we can use any of the following
    code snippets:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要执行前面的方法，我们可以使用以下任何代码片段：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that there would be no compiler errors and if any optional parameters are
    not passed, the default value defined in the function declaration would be used.
    In the next section, we will look at how generic types are implemented in C#.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果没有传递任何可选参数，编译器将不会出现错误，并且如果未传递任何可选参数，则将使用函数声明中定义的默认值。在下一节中，我们将探讨泛型类型在 C#
    中的实现方式。
- en: Generics types
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型
- en: Generics allow us to design classes and methods without the notion of data types.
    In simpler terms, when we talk about methods, generics allow us to define methods
    without specifying the type of the input variables.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型允许我们设计不涉及数据类型概念的类和方法。换句话说，当我们谈论方法时，泛型允许我们定义方法而不指定输入变量的类型。
- en: 'Let''s go through the following code implementation and see how it can help
    us. In the following example, we have created a function that compares the values
    between two `int` variables, `A` and `B`. If the value is the same, it returns
    `true`; however, if the value is not same, it returns `false`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码实现来了解它如何帮助我们。在以下示例中，我们创建了一个函数，用于比较两个 `int` 变量 `A` 和 `B` 之间的值。如果值相同，它返回
    `true`；如果值不同，它返回 `false`：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s say we try to pass a variable with a data type that is not `int`.
    In the following screenshot, we are trying to pass `string` instead of `int`,
    to which the compiler gives us an error:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们尝试传递一个不是 `int` 类型的变量。在以下屏幕截图中，我们尝试传递 `string` 而不是 `int`，编译器给出错误：
- en: '![](img/584e7232-e0d1-4df1-9649-492b26818b65.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/584e7232-e0d1-4df1-9649-492b26818b65.png)'
- en: 'As illustrated in the following screenshot, it will give us the following error:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下屏幕截图所示，它将给出以下错误：
- en: '![](img/ff83eaec-b056-4d41-a548-7d51c30582fe.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff83eaec-b056-4d41-a548-7d51c30582fe.png)'
- en: As illustrated by the preceding screenshot, the `IsEqual` function is accepting
    inputs of the `int` type. However, while calling the function, we are passing
    variables of the `string` type. Due to the type mismatch, the compiler is showing
    the error.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，`IsEqual` 函数接受 `int` 类型的输入。然而，在调用函数时，我们传递的是 `string` 类型的变量。由于类型不匹配，编译器显示错误。
- en: To correct this error, we need to make the `IsEqual` function generic. We can
    do this by altering the function so that instead of accepting the input variables
    of the `int` type, it can accept the input variables of the `object` type.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这个错误，我们需要将 `IsEqual` 函数泛型化。我们可以通过修改函数，使其不再接受 `int` 类型的输入变量，而是接受 `object`
    类型的输入变量。
- en: Please note that all of the variables in C# inherit from `object`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，C# 中的所有变量都继承自 `object`。
- en: 'In this code example, we are calling the `IsEqual` function twice and are passing
    different input parameters. In the first call, we are passing `string`; however,
    in the second call, we are passing `int`. Note that when we compile the project,
    no compile time error is retrieved and the function compares the passed variables
    irrespective of type:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，我们两次调用 `IsEqual` 函数并传递不同的输入参数。在第一次调用中，我们传递 `string`；然而，在第二次调用中，我们传递
    `int`。请注意，当我们编译项目时，没有检索到编译时错误，并且函数比较传递的变量，而不考虑类型：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Although the preceding code implementation will be generic for all of the data
    types, it will lead to the following issues:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的代码实现对所有数据类型都是泛型的，但它会导致以下问题：
- en: '**Performance degradation**:In the `IsEqual` function definition, the data
    types of variables is `object`. Due to this, for all calls being made to this
    function, the variables will need to be converted from their original type, that
    is, `int` or `string`, into `object`. This conversion will be an extra load for
    the application, which will lead to performance degradation. In programming terms,
    this conversion is known as **boxing and unboxing**, which we will cover shortly
    in this chapter.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能下降**：在 `IsEqual` 函数定义中，变量的数据类型是 `object`。由于这个原因，对于所有调用此函数的情况，变量都需要从其原始类型（即
    `int` 或 `string`）转换为 `object`。这种转换将给应用程序增加额外的负担，从而导致性能下降。在编程术语中，这种转换被称为 **装箱和拆箱**，我们将在本章稍后讨论。'
- en: '**Type unsafe**: This approach will not be type unsafe. For example, I will
    call the function by passing the following variables:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型不安全**：这种方法不会导致类型不安全。例如，我将通过传递以下变量来调用该函数：'
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If I do so, the compiler will not give any error, even though we understand
    that the call makes no sense. To avoid these issues while still providing us with
    the capability of making the calls generic, C# provides us with the tool of using
    *generic types*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我这样做，编译器不会给出任何错误，尽管我们知道这个调用没有意义。为了避免这些问题，同时仍然提供给我们进行泛型调用的能力，C# 提供了使用 *泛型类型*
    的工具。
- en: 'Using generic types, we can avoid specifying any data type to the input variables
    of the functions. Hence, the implementation of `IsEqual` will look like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型类型，我们可以避免指定函数输入变量的任何数据类型。因此，`IsEqual` 的实现将如下所示：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code example, please note that we are using `T` to illustrate
    the data type, hence making it generic for all data types.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，请注意，我们使用 `T` 来表示数据类型，因此使其对所有数据类型都是泛型的。
- en: 'As we are not using `object`, there will be no boxing and unboxing of variables.
    If we still try to pass incorrect data types to this function, as illustrated
    in the following screenshot, the compiler will give us an error:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有使用 `object`，因此不会有变量的装箱和拆箱。如果我们仍然尝试向此函数传递错误的数据类型，如以下截图所示，编译器将给出错误：
- en: '![](img/dce39b3e-cc88-4d9e-bc76-a67b944712cc.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/dce39b3e-cc88-4d9e-bc76-a67b944712cc.png)'
- en: In the next topic, we will not go through the different concepts C# uses to
    work on the types of the data variables. We will go through how we can use boxing
    and unboxing in C# to convert one data type into another and the different things
    we should keep in mind when we are consuming variables of different types.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们不会介绍 C# 使用来处理数据变量类型的不同概念。我们将介绍如何在 C# 中使用装箱和拆箱将一种数据类型转换为另一种类型，以及我们在消费不同类型的变量时应注意的不同事项。
- en: Consuming data types in C#
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 中的数据类型消费
- en: 'C# is a strongly-typed language. This basically means that, when we declare
    a variable with a particular data type, as in the following example, we cannot
    declare the `x` variable again:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是一种强类型语言。这基本上意味着，当我们声明一个特定数据类型的变量时，如以下示例所示，我们不能再次声明 `x` 变量：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In addition to this, we cannot assign to this `x` variable any value that is
    not an integer. Hence, the following statement will give us an error:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们无法将任何非整数值赋给此 `x` 变量。因此，以下语句将给出错误：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To overcome this strongly typed feature, C# provides some capabilities when
    we are consuming a type. This includes boxing and unboxing of value type variables,
    use of the dynamics keyword, and implicit and explicit conversion of a variable
    of one data type to a variable of a different data type. Let's go through each
    of these concepts and understand how they work in C#.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这种强类型特性，C# 在我们消费类型时提供了一些功能。这包括值类型变量的装箱和拆箱、使用动态关键字以及将一个数据类型的变量隐式或显式转换为另一个数据类型的变量。让我们逐一了解这些概念，并理解它们在
    C# 中的工作原理。
- en: Boxing and unboxing
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装箱和拆箱
- en: In C#, boxing means converting a value type variable into a reference type variable.
    Unboxing is the opposite of boxing. It refers to the conversion of a reference
    type variable into a value type variable. Boxing and unboxing are detrimental
    to the performance of the application as they are an overhead to the compiler.
    As developers, we should try to avoid them as much as possible; however, it's
    not always possible and there are several instances that we encounter during programming
    that make us use this concept.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，装箱意味着将值类型变量转换为引用类型变量。拆箱是装箱的相反操作。它指的是将引用类型变量转换为值类型变量。装箱和拆箱对应用程序的性能有害，因为它们是编译器的开销。作为开发者，我们应该尽可能地避免它们；然而，这并不总是可能的，我们在编程过程中会遇到一些情况，迫使我们使用这个概念。
- en: 'Let''s look at the following example to see how boxing and unboxing works:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来了解装箱和拆箱是如何工作的：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the code implementation, we can see the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码实现中，我们可以看到以下内容：
- en: We have declared a variable, `i`, of the `int` type and have assigned it a value
    of `3`. Now we know that, being `int`, this is a value type reference.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已声明一个 `i` 变量，其类型为 `int`，并已赋予它 `3` 的值。现在我们知道，作为 `int`，这是一个值类型的引用。
- en: Next, we declare an `obj` variable of the `object` type and have assigned it
    the value in `i`. We know that `object` is a reference type variable. Therefore,
    internally, the CLR will undergo boxing and convert the value into the `i` variable
    into a reference type variable.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个 `obj` 变量，其类型为 `object`，并将其赋值为 `i` 中的值。我们知道 `object` 是一个引用类型变量。因此，在内部，CLR
    将执行装箱，并将 `i` 变量中的值转换为引用类型变量。
- en: Next, in the third statement, we are doing the reverse. We are trying to assign
    the value in a reference type variable, that is, `obj`, to a value type variable,
    `i`. At this stage, the CLR will do the unboxing of the value.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，在第三条语句中，我们正在进行相反的操作。我们试图将一个引用类型变量中的值，即 `obj`，赋给一个值类型变量，`i`。在这个阶段，CLR 将执行拆箱操作。
- en: 'Please note that, while doing boxing, we do not need to explicitly cast the
    value type to a reference type. However, when we are doing the unboxing, we need
    to explicitly specify the type into which we are converting the variable. This
    approach of explicitly specifying the type into which we are converting a variable
    is known as casting. To do casting, we can use the following syntax:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在进行装箱操作时，我们不需要显式地将值类型转换为引用类型。然而，当我们进行拆箱操作时，我们需要显式指定要转换到的变量类型。这种显式指定要转换到的变量类型的方法被称为类型转换。要进行类型转换，我们可以使用以下语法：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What it basically means is that there are possibilities that this conversion
    can lead to an exception of the `InvalidCastException` type. For example, in the
    preceding example, we know that the value in `obj` is `10`. However, if it were
    to acquire a value that cannot be cast to an `int` value, for example, `string`,
    the compiler will give us a runtime error.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上意味着这种转换可能导致`InvalidCastException`类型的异常。例如，在上面的例子中，我们知道`obj`中的值是`10`。然而，如果它获取一个无法转换为`int`值的值，例如`string`，编译器将给出运行时错误。
- en: Now, in the next section, we will look at the different techniques C# provides
    us with for converting between data types.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在下一节中，我们将探讨C#为我们提供用于在数据类型之间进行转换的不同技术。
- en: Type conversions in C#
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#中的类型转换
- en: Type conversion in C# basically implies converting a variable from one data
    type into another. Now we will look into the different types of conversions available
    in C#.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的类型转换基本上意味着将变量从一个数据类型转换为另一个数据类型。现在我们将探讨C#中可用的不同类型转换。
- en: Implicit conversion
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式转换
- en: 'Implicit conversion is done by the compiler automatically. It''s done by the
    compiler without any intervention or command from the developer. The following
    two conditions must be fulfilled for a compiler to execute implicit type conversion:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换是由编译器自动完成的。编译器在没有任何开发者干预或命令的情况下执行隐式类型转换。编译器执行隐式类型转换必须满足以下两个条件：
- en: '**No data** **l****oss**: The compiler must determine that if it executes the
    conversion implicitly, there will be no data loss. In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml),
    *Understanding Classes, Structures, and Interfaces*, in the *Data Types* section,
    we saw that each data type acquires a space in memory. Therefore, if we try to
    assign a variable with the type as `float`, which acquires 32 bytes of memory,
    to double, which acquires 64 bytes of memory, we can be sure that there won''t
    be any data loss in the conversion.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无数据丢失**：编译器必须确定如果它隐式执行转换，将不会发生数据丢失。在[第2章](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml)，“理解类、结构和接口”，在“数据类型”部分，我们看到了每种数据类型都会在内存中占用空间。因此，如果我们尝试将一个类型为`float`的变量（占用32字节内存）赋值给一个类型为`double`的变量（占用64字节内存），我们可以确信在转换过程中不会发生数据丢失。'
- en: '**No chance of cast exception**: The compiler must determine that there is
    no chance of an exception during the casting of the value from one data type to
    another. For example, if we try to set a `string` value to a `float` variable,
    the compiler will not do the implicit conversion as it would be an invalid cast.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无转换异常的可能性**：编译器必须确定在将值从一种数据类型转换为另一种数据类型的过程中不会发生异常。例如，如果我们尝试将一个`string`值设置到一个`float`变量中，编译器将不会执行隐式转换，因为这将会是一个无效的转换。'
- en: 'Now, let''s look at the following code implementation to see how implicit conversion
    works in C#:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下以下代码实现，以了解C#中隐式转换是如何工作的：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code example, we have declared a variable, `i`, of the `int`
    type and have assigned it a value of `100`. In the next statement, we have declared
    a variable, `f`, of the `float` type and have assigned it the value in `i`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们声明了一个`int`类型的变量`i`，并给它赋值为`100`。在下一个语句中，我们声明了一个`float`类型的变量`f`，并将其值赋给`i`。
- en: Now, the compiler would determine that both the required conditions for implicit
    conversions are being met, that is, `float` acquires more memory than `int` and
    there is no chance of an invalid cast exception—an `int` value is also a valid
    value in a `float` variable. Hence, the compiler gives no error and does the implicit
    conversion.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译器会确定隐式转换所需的两个条件都已满足，即`float`占用的内存比`int`多，并且不存在无效转换异常的可能性——`int`值也是`float`变量中的一个有效值。因此，编译器不会报错，并执行隐式转换。
- en: 'However, if we do the reverse, which is trying to assign a `float` value in
    `int`, the compiler will determine that the conditions are not being fulfilled
    and will give us a compile-time error. Please refer to the following screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们进行反向操作，即尝试将 `float` 值赋给 `int`，编译器将确定条件未满足，并将给出编译时错误。请参考以下截图：
- en: '![](img/dcd025b4-b567-4c1f-8397-14a238c0ad19.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcd025b4-b567-4c1f-8397-14a238c0ad19.png)'
- en: However, in certain circumstances, even if there is a chance of data loss, we
    would still like to have those conversions. C# provides us with *explicit conversion*,
    which allows us to explicitly instruct the compiler to let the conversion take
    place. Let's go through how *explicit conversion* takes place.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，即使有可能数据丢失，我们仍然希望进行这些转换。C# 提供了 *显式转换*，允许我们明确指示编译器让转换发生。让我们看看 *显式转换*
    是如何进行的。
- en: Explicit conversion
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式转换
- en: When the compiler is not able to implicitly change the type of variables, but
    we still want the conversion to happen, we need to explicitly instruct the compiler
    to convert the value. This is referred to as *explicit conversion*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器无法隐式更改变量的类型，但我们仍然希望进行转换时，我们需要明确指示编译器进行转换。这被称为*显式转换*。
- en: 'There are two ways to do explicit conversion in C#:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，有两种进行显式转换的方法：
- en: '**Using a type cast operation**: In this, we use the base data type to instruct
    the compiler to do explicit conversion. For example, for the code implementation
    that we were trying in the preceding example, the following would be the syntax:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用类型转换操作**：在这种情况下，我们使用基本数据类型来指示编译器进行显式转换。例如，对于前面示例中尝试的代码实现，以下将是语法：'
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we are explicitly telling the compiler to do type conversion
    by using the `int` class conversion before the float variable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过在浮点变量之前使用 `int` 类转换来明确告诉编译器进行类型转换。
- en: '**Using the** `Convert` **class**: C# provides us with the `Convert` class,
    which we can use to do type casting between multiple data types. If we were to
    use the `Convert` class instead of the `int` keyword, the following would be the
    syntax:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 `Convert` 类**：C# 提供了 `Convert` 类，我们可以使用它来进行多种数据类型之间的类型转换。如果我们使用 `Convert`
    类而不是 `int` 关键字，以下将是语法：'
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Convert class can be used for type casting among different data types. Please
    refer to the following screenshot to get an idea of the different options that
    are available in the `Convert` class. Depending on the usage, we can use the appropriate
    method in the `Convert` class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Convert` 类可用于不同数据类型之间的类型转换。请参考以下截图以了解 `Convert` 类中可用的不同选项。根据使用情况，我们可以使用 `Convert`
    类中的适当方法：'
- en: '![](img/3f5171d1-5c82-499b-85c0-85c8a71d192d.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f5171d1-5c82-499b-85c0-85c8a71d192d.png)'
- en: 'Hence, the overall implementation of the program will look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，程序的总体实现将如下所示：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s try to run this program to see the output it gives:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试运行这个程序来看看它给出的输出：
- en: '![](img/54cf7e2a-e0a1-420a-8833-6692490ed6f2.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54cf7e2a-e0a1-420a-8833-6692490ed6f2.png)'
- en: It implies that when we use the type cast keyword, that is, `(int)k`, the compiler
    tried to extract the integer component from the `float` variable, `k`, which turned
    out to be `100`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们使用类型转换关键字，即 `(int)k`，编译器尝试从 `float` 变量 `k` 中提取整数部分，结果为 `100`。
- en: On the other hand, when we used the `Convert` class, that is, `Convert.ToInt32(k)`,
    it tried to extract the nearest integer to the float variable, `k`, which turned
    out to be `101`. This is one of the key differences that developers need to be
    aware of while deciding between using type casting and the `Convert` class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们使用 `Convert` 类，即 `Convert.ToInt32(k)`，它会尝试提取与浮点变量 `k` 最接近的整数，结果为 `101`。这是开发者在决定使用类型转换和
    `Convert` 类之间需要了解的关键区别之一。
- en: 'While we are looking at explicit type conversions, we need to be aware of two
    helper methods that help us do conversions:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看显式类型转换时，我们需要注意两个辅助方法，这些方法帮助我们进行转换：
- en: '`Parse`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parse`'
- en: '`TryParse`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryParse`'
- en: 'Both the `Parse` and `TryParse` methods are used to convert `string` into a
    different data type. However, there is a slight difference in the way invalid
    case exceptions are handled. Let''s look at the following example to see how they
    work and the difference between them:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parse` 和 `TryParse` 方法都用于将 `string` 转换为不同的数据类型。然而，在处理无效情况异常的方式上存在细微差别。让我们通过以下示例来看看它们是如何工作的以及它们之间的区别：'
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding example, we have declared a string object and have assigned
    it a value of `100`. Now, we are trying to convert the value into an integer using
    the `Parse` method. When we run the program, we see the following output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明了一个字符串对象，并给它赋值为`100`。现在，我们正在尝试使用`Parse`方法将这个值转换为整数。当我们运行程序时，我们看到以下输出：
- en: '![](img/f3d439ed-e0cf-44b3-9532-2f306ed94e51.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f3d439ed-e0cf-44b3-9532-2f306ed94e51.png)'
- en: It implies that the parse method converts the string into its integer equivalent
    and assigns the value to another variable, `num`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着解析方法将字符串转换为它的整数等价物，并将值赋给另一个变量，`num`。
- en: 'Now, let''s suppose the value in the number is `100wer`. Now, it''s evident
    that the value in the `number` string cannot be converted into `int` because it
    has some characters that cannot be categorized in an integer object. When we run
    this program, we get the following exception:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设数字中的值是`100wer`。现在很明显，`number`字符串中的值不能转换为`int`，因为它包含一些无法归类到整数对象中的字符。当我们运行这个程序时，我们得到以下异常：
- en: '![](img/f5cbe848-768a-4b09-9e8b-09bc6c571ba4.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f5cbe848-768a-4b09-9e8b-09bc6c571ba4.png)'
- en: 'To avoid such situations, we use `TryParse`. In `TryParse`, CLR tries to convert
    the string object into the specified data type. However, if the conversion returns
    an error, `TryParse` returns `false` or, in other words, *the conversion failed*.
    In other cases, it returns true. Hence, if we were to write the same implementation
    with `TryParse`, we would do the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们使用`TryParse`。在`TryParse`中，CLR尝试将字符串对象转换为指定的数据类型。然而，如果转换返回错误，`TryParse`返回`false`，换句话说，*转换失败*。在其他情况下，它返回`true`。因此，如果我们用`TryParse`编写相同的实现，我们会这样做：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding program, we have declared a variable of the `string` type
    and we are using `TryParse` to convert this value into a variable of the `int`
    type. We are checking whether the conversion is a success. If it''s a success,
    we print out the number and in other cases, we print a statement to show that
    there was an error during the type conversion. When we run the program, we get
    the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们声明了一个`string`类型的变量，并使用`TryParse`将其值转换为`int`类型的变量。我们正在检查转换是否成功。如果成功，我们打印出数字；在其他情况下，我们打印一条语句来显示在类型转换过程中出现了错误。当我们运行程序时，我们得到以下输出：
- en: '![](img/8d07724f-5c34-4655-b6b4-a5936b275a7e.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d07724f-5c34-4655-b6b4-a5936b275a7e.png)'
- en: As we see from the output, the compiler tells us that there was an error doing
    the `TryParse`; however, it does not throw an exception in the application as
    opposed to the `Parse` method, which threw an invalid case exception in the same
    scenario.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，编译器告诉我们`TryParse`操作出现了错误；然而，与在相同场景下抛出无效案例异常的`Parse`方法不同，它并没有在应用程序中抛出异常。
- en: In the next section, we will do a quick recap of encapsulation, which we covered
    in [Chapter 3](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml), *Understanding Object-Oriented
    Programming*, and we'll see how to implement properties for class member variables
    objects, allowing us to consume them without worrying about the hidden complexities.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将快速回顾封装的概念，这是我们已经在[第3章](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml)《理解面向对象编程》中讨论过的，我们将看到如何为类的成员变量对象实现属性，这样我们就可以在不用担心隐藏复杂性的情况下消费它们。
- en: Enforcing encapsulation
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制封装
- en: 'Previously, we went through the following concepts in [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml),
    *Understanding Classes, Structures, and Interfaces*, and [Chapter 3](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml),
    *Understanding Object-Oriented Programming*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前，我们在[第2章](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml)《理解类、结构和接口》和[第3章](8acdf308-13c5-4298-bdba-7bef6e8b087b.xhtml)《理解面向对象编程》中讨论了以下概念：
- en: Accessing modifiers and how they help us to control access to methods and fields
    in the same class, in the same assembly, and in the derived classes
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问修饰符及其如何帮助我们控制同一类、同一程序集和派生类中方法和字段的访问。
- en: Encapsulation and how it helps us to group together related fields and methods
    together in the same object
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装及其如何帮助我们将在同一对象中相关联的字段和方法组合在一起。
- en: However, there is another concept in encapsulation called properties, which
    makes sure that no one can have direct access to the data fields outside the class.
    This helps us to make sure that we have control over the modification of the data
    fields.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，封装中还有一个叫做属性的概念，它确保没有人可以直接访问类外的数据字段。这有助于我们确保我们对数据字段的修改有控制权。
- en: A property is very similar to the field of a class. Just like the field of a
    class, it has a type, name, and access modifier. However, what makes it different
    is the presence of accessors. Accessors are the `get` and `set` keywords that
    allow us to set and retrieve values from a field.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 属性与类的字段非常相似。就像类的字段一样，它有一个类型、名称和访问修饰符。然而，使其不同的地方在于存在访问器。访问器是允许我们从字段设置和检索值的`get`和`set`关键字。
- en: 'The following is what the syntax of a property looks like:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的语法如下：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, please note the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意以下几点：
- en: For the `SampleProperty` class, we have declared a `name` field and a `Name`
    property.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`SampleProperty`类，我们已声明了一个`name`字段和一个`Name`属性。
- en: The `name` field has been marked `private`, hence it won't be accessed outside
    the `SampleProperty` class.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`字段已被标记为`private`，因此它不会在`SampleProperty`类外部被访问。'
- en: The `Name` property has been marked `public` and has the `get` and `set` accessors.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`属性已被标记为`public`，并具有`get`和`set`访问器。'
- en: In the `set` method, we are checking whether the value passed is null or not.
    If it's null, we are raising an argument exception. Therefore, we are putting
    rules around the value that can be set on the `name` field.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`set`方法中，我们正在检查传递的值是否为null。如果是null，我们将引发一个参数异常。因此，我们在`name`字段上可以设置的值周围设置了规则。
- en: In this way, properties help us in consume the fields of a class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，属性帮助我们消费类的字段。
- en: Manipulating strings
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串操作
- en: Strings are a very important data type in C#. The string data type is used for
    saving text as `string`. In programming terms, it's a sequence of characters.
    String is a reference type variable unlike other basic data type variables, such
    as `int`, `float`, and `double`, which are value type variables. Also, strings
    are immutable in nature, that is, the values present in them cannot change. In
    this section, we will look at different operations related to this data type.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是C#中一个非常重要的数据类型。字符串数据类型用于保存文本为`string`。在编程术语中，它是一系列字符。字符串是一个引用类型变量，与其他基本数据类型变量（如`int`、`float`和`double`，它们是值类型变量）不同。此外，字符串在本质上是不变的，也就是说，它们中存在的值不能改变。在本节中，我们将探讨与该数据类型相关的不同操作。
- en: 'So, look at the following code example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请看以下代码示例：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When we are assigning a `Test` value to the already declared `string` objects,
    internally, CLR allocates a new memory block for the modified `string` object.
    Hence, for every operation that we do on a string, instead of modifying of the
    same `string` object, a new `string` object is declared in CLR. Due to this, we
    need to be very careful while doing operations on `string`, for example, if we
    execute the following loop operation on a string object:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`Test`值分配给已声明的`string`对象时，CLR内部会为修改后的`string`对象分配一个新的内存块。因此，对于我们在字符串上进行的每个操作，而不是修改相同的`string`对象，CLR会声明一个新的`string`对象。由于这个原因，我们在对字符串进行操作时需要非常小心，例如，如果我们在一个字符串对象上执行以下循环操作：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we are concatenating the string object, `s`, with a character,
    `a`, in the loop. This loop will run `100` times. Therefore, the CLR will go on
    allocating more and more memory for the `string` object. Hence, due to memory
    usage, performance-wise, the preceding operation is not good.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在循环中将字符串对象`s`与一个字符`a`连接起来。这个循环将运行`100`次。因此，CLR将不断为`string`对象分配更多的内存。因此，由于内存使用，从性能角度来看，前面的操作并不好。
- en: To help to improve this feature in `string`, C# provides us with two built-in
    classes, `Stringbuilder` and `StringWriter`, which we will discuss next. We will
    also look at some of the features available with us for executing string searching
    in C#.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助改进`string`中的这个特性，C#为我们提供了两个内置类，`Stringbuilder`和`StringWriter`，我们将在下一节中讨论它们。我们还将查看C#中可用于执行字符串搜索的一些功能。
- en: StringBuilder
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`StringBuilder`'
- en: '`Stringbuilder` is an internal class provided by C# that helps us to improve
    `string` manipulation functions. To explain the idea, we will be executing a `for`
    loop from `0` to `100` and will be concatenating the resultant output in each
    loop with the letter `a`. Internally, a string builder uses a buffer to modify
    the string value instead of allocating memory on every string manipulation. The
    following code example shows how we can use string builder for string manipulation
    operations:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stringbuilder` 是 C# 提供的一个内部类，它帮助我们改进 `string` 操作函数。为了解释这个想法，我们将执行一个从 `0` 到
    `100` 的 `for` 循环，并在每个循环中将结果输出与字母 `a` 连接起来。内部，字符串构建器使用缓冲区来修改字符串值，而不是在每次字符串操作时分配内存。以下代码示例展示了我们如何使用字符串构建器进行字符串操作：'
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we are declaring a `StringBuilder` object, `sb`, and
    are appending its value with `a` in the loop. Internally, instead of allocating
    memory on every concatenation, `StringBuilder` will use an internal buffer to
    manage these operations.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个 `StringBuilder` 对象 `sb`，并在循环中将其值与 `a` 连接。内部，`StringBuilder`
    将使用内部缓冲区来管理这些操作。
- en: StringReader and StringWriter
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串读取器和字符串写入器
- en: The `StringReader` and `StringWriter` classes derive from the `TextReader` and
    `TextWriter` classes respectively. `TextReader` and `TextWriter` are used for
    dealing with APIs such as reading from an XML file, generating an XML file, or
    reading from a file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringReader` 和 `StringWriter` 类分别从 `TextReader` 和 `TextWriter` 类派生。`TextReader`
    和 `TextWriter` 用于处理诸如从 XML 文件读取、生成 XML 文件或从文件读取等 API。'
- en: We will study the `TextReader` and `TextWriter` classes more in [Chapter 14](ed867897-1e3b-47fe-b646-28484f783f37.xhtml),
    *Performing I/O Operations*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 14 章 [执行 I/O 操作](ed867897-1e3b-47fe-b646-28484f783f37.xhtml)中更详细地研究 `TextReader`
    和 `TextWriter` 类。
- en: Using the `StringReader` and `StringWriter` classes, we can interact with these
    I/O operations by manipulating the objects of strings and string builders.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `StringReader` 和 `StringWriter` 类，我们可以通过操作字符串和字符串构建器的对象来与这些 I/O 操作进行交互。
- en: Let's go through the following example in order to understand the methods better.
    In the following example, using `StringWriter`, we are firstly creating an extract
    of an XML file and then we will pass the resultant XML representation to `StringReader`,
    which will try to read an element present in it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来更好地理解这些方法。在以下示例中，我们使用 `StringWriter` 首先创建一个 XML 文件的摘录，然后我们将结果 XML
    表示传递给 `StringReader`，它将尝试读取其中的元素。
- en: 'In the following code example, we are using `XMLWriter` to create an XML file
    with the start element as `Student` and an attribute of `Name`. We are saving
    the string representation of the XML file using `StringWriter`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们使用 `XMLWriter` 创建一个以 `Student` 为起始元素并具有 `Name` 属性的 XML 文件。我们使用 `StringWriter`
    保存 XML 文件的字符串表示：
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Suppose we print the output of the program; we will get the following result:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们打印程序的输出；我们将得到以下结果：
- en: '![](img/a68b5ea5-6854-4116-92f4-e517e562ee0d.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a68b5ea5-6854-4116-92f4-e517e562ee0d.png)'
- en: 'Now, in the following code snippet, we will use `StringReader` to read through
    this XML file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在以下代码片段中，我们将使用 `StringReader` 来读取这个 XML 文件：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Please note that we are passing a string parameter to the function, which is
    first converted into a `StringReader` object. From that `StringBuilder` object,
    we are creating an `XmlReader` object.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们向函数传递了一个字符串参数，该参数首先被转换为 `StringReader` 对象。从那个 `StringBuilder` 对象，我们创建了一个
    `XmlReader` 对象。
- en: 'The `ReadToFollowing` function reads the XML file until it finds an element
    with the respective name, which is passed as a parameter to the function. In the
    preceding code example, we are passing a parameter of `Name` to the `XmlReader`
    object. Based upon the XML file we have passed to it, it will take us to the element
    `Rob`. To read the text representation of the element, we can use the `ReadInnerXml`
    function on the `reader` object. Hence, in the preceding example, the `studentName`
    variable will be assigned the value of `Rob`. If we execute the code snippet,
    we will get the following output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadToFollowing` 函数读取 XML 文件，直到找到具有相应名称的元素，该名称作为参数传递给函数。在前面的代码示例中，我们将 `Name`
    参数传递给 `XmlReader` 对象。根据我们传递给它的 XML 文件，它将带我们到 `Rob` 元素。为了读取元素的文本表示，我们可以使用 `reader`
    对象上的 `ReadInnerXml` 函数。因此，在前面的示例中，`studentName` 变量将被分配 `Rob` 的值。如果我们执行代码片段，我们将得到以下输出：'
- en: '![](img/ca8789ae-ce24-45c5-8943-a61418924161.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca8789ae-ce24-45c5-8943-a61418924161.png)'
- en: In the next section, we will go through some functions we can use to search
    for particular characters in a string object.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些我们可以用来在字符串对象中搜索特定字符的函数。
- en: String searching
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串搜索
- en: As the name suggests, string searching involves searching the presence of a
    particular letter or string in another string. C# provides several methods for
    doing this.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，字符串搜索涉及在另一个字符串中搜索特定字母或字符串的存在。C# 提供了多种方法来完成这项工作。
- en: Please note that C# is a case-sensitive language. Therefore, searching for a
    character, let's suppose *C*, is not the same as searching for the character *c*
    in the string.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，C# 是一种区分大小写的语言。因此，搜索字符，比如 *C*，与在字符串中搜索字符 *c* 是不同的。
- en: 'Please refer to the following different types of searching that are possible
    with the `string` object:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下使用 `string` 对象可以进行的不同类型的搜索：
- en: '`Contains`: When we want to check whether a particular character exists in
    the string, we use the `Contains` function. The following example checks whether
    a character, `z`, exists in the string object. If it exists, it returns `true`;
    otherwise, it returns `false`.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contains`: 当我们想要检查一个特定字符是否存在于字符串中时，我们使用 `Contains` 函数。以下示例检查字符 `z` 是否存在于字符串对象中。如果存在，它返回
    `true`；否则，返回 `false`。'
- en: 'Let''s take a look at the following example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code, using the `Contains` function, we are checking whether
    `z` occurs in the string against which we are calling the function. As we are
    calling it for a variable with the value `hello australia`, it will return the
    `false` value as `z` does not occur in the string. Hence, we get the following
    output when the code is executed:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用 `Contains` 函数，我们正在检查 `z` 是否出现在我们调用函数的字符串中。由于我们为具有值 `hello australia`
    的变量调用它，因此它将返回 `false` 值，因为 `z` 不在字符串中出现。因此，当代码执行时，我们得到以下输出：
- en: '![](img/e726d1e7-4fb5-4bbc-8a35-05a8f098a627.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e726d1e7-4fb5-4bbc-8a35-05a8f098a627.png)'
- en: '`IndexOf`: We use this function if we want to find out the index in the string
    at which a particular character is present.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndexOf`: 如果我们想要找出字符串中特定字符出现的位置，我们会使用这个函数。'
- en: 'For example, in the following code example, we are finding the first and the
    last index of occurrence of the `a` character in the string `hello australia`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的代码示例中，我们正在寻找字符串 `hello australia` 中字符 `a` 的首次和末次出现的位置：
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When we execute the program, we will get the first occurrence as 6 and the
    last occurrence as 14\. The `IndexOf` function retrieves the index the first appearance
    of a character or a string in the string against which we are using the function.
    Please also note that it does not ignore spaces. Hence, the whitespace is also
    counted as a character. Similarly, the `LastIndexOf` function retrieves the last
    index of the appearance of the respective character or string:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行程序时，我们将得到首次出现的位置为 6，末次出现的位置为 14。`IndexOf` 函数检索字符或字符串在字符串中首次出现的位置，请注意，它不会忽略空格。因此，空白也被计为一个字符。同样，`LastIndexOf`
    函数检索相应字符或字符串出现的最后一个索引：
- en: '![](img/ad91476c-0e17-41d2-8c33-6ccd430b106c.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad91476c-0e17-41d2-8c33-6ccd430b106c.png)'
- en: Please note that in C#, for any array or string, the index of the first character
    is zero.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 C# 中，对于任何数组或字符串，第一个字符的索引为零。
- en: '`StartsWith`/`EndsWith`: We use this function if we want to check whether a
    string starts or ends with a particular character.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartsWith`/`EndsWith`: 如果我们想要检查一个字符串是否以特定的字符开始或结束，我们会使用这个函数。'
- en: 'The following code example shows a scenario in which we are checking whether
    the same string object used previously starts with `h` and ends with `h`. In the
    following code, in the first statement, we are checking whether the `s` string
    variable starts with `h`. Based on the evaluation, we print the output in the
    console window. Similarly, in the next statement, we are checking whether the
    same string variable ends with `h`. Based on the evaluation, we print the output
    in the console window again:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了一个场景，其中我们正在检查之前使用的相同字符串对象是否以 `h` 开始和结束。在以下代码中，在第一个语句中，我们正在检查 `s` 字符串变量是否以
    `h` 开始。根据评估结果，我们在控制台窗口中打印输出。同样，在下一个语句中，我们正在检查相同的字符串变量是否以 `h` 结束。根据评估结果，我们再次在控制台窗口中打印输出：
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Please refer to the following output for the preceding code example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下输出以了解前面的代码示例：
- en: '![](img/d1b02d4e-a82a-4a9e-82e7-ff5db9ae53ef.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1b02d4e-a82a-4a9e-82e7-ff5db9ae53ef.png)'
- en: '`Substring`: We use this function if we want to extract a substring from a
    particular string object. There are two variants of substring possible in C#.
    In one, we specify just the start index and extract the substring from that particular
    index. In another variant, we specify both the start and end index and extract
    the characters present in that substring.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Substring`：如果我们想从一个特定的字符串对象中提取子字符串，我们将使用此函数。在 C# 中，可能的子字符串有两种变体。在一个中，我们只指定起始索引并从该特定索引提取子字符串。在另一个变体中，我们指定起始和结束索引，并提取该子字符串中的字符。'
- en: 'Here is a code example of this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个代码示例：
- en: '[PRE38]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code example, we are finding two substrings of a string object,
    `hello australia`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们正在寻找字符串对象 `hello australia` 的两个子字符串。
- en: In the first substring, we have passed the start index as 3 and the end index
    as 6\. Therefore, the substring will return us the values, `lo aus`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个子字符串中，我们传递了起始索引为 3，结束索引为 6。因此，子字符串将返回值，`lo aus`。
- en: 'In the second substring, we are just passing the start index, 3\. Hence, it
    will return the entire string from this index. The following is the screenshot
    of the output from this execution:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个子字符串中，我们只传递了起始索引，3。因此，它将从该索引返回整个字符串。以下是此执行输出的截图：
- en: '![](img/6ce71ca3-d860-434c-b634-e699c5b69c1a.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ce71ca3-d860-434c-b634-e699c5b69c1a.png)'
- en: These are the different string manipulation functions available in C#. In the
    next section, we will go through an overview of reflection and learn how it helps
    us to get structure—in other words, classes and their methods and properties—from
    an assembly.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 C# 中可用的不同字符串操作函数。在下一节中，我们将概述反射，并了解它是如何帮助我们从程序集获取结构——换句话说，类及其方法和属性。
- en: Overview of reflection
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射概述
- en: 'Reflection in C# means inspecting the contents of an assembly at run time.
    It returns the metadata for each class present in the assembly—so, it returns
    the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，反射意味着在运行时检查程序集的内容。它返回程序集中每个类的元数据——因此，它返回以下内容：
- en: The name of the class
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的名称
- en: All of the properties present in the class
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类中存在的所有属性
- en: All of the methods along with their return types and function parameters
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有方法及其返回类型和函数参数
- en: All of the attributes present in the class
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类中存在的所有属性
- en: In [Chapter 10](b7bdae98-fc5b-4430-bb0d-b8541ca64f8d.xhtml), *Find, Execute,
    and Create Types at Runtime Using Reflection*, we will do a deep dive on reflection;
    however, in this chapter, we will just go through a code sample of how we can
    implement reflection in C# to decode all of the metadata present in the assembly.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 10 章](b7bdae98-fc5b-4430-bb0d-b8541ca64f8d.xhtml)，*使用反射在运行时查找、执行和创建类型*，我们将深入探讨反射；然而，在本章中，我们只会通过一个代码示例来展示如何在
    C# 中实现反射，以解码程序集中存在的所有元数据。
- en: 'To use reflection, we need to include the `System.Reflection` namespace, which
    helps us to use required classes such as `Assembly`. Please refer to the following
    function, which reads a particular assembly based on its path and reads all of
    the classes, methods, and parameters present in the assembly:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用反射，我们需要包含 `System.Reflection` 命名空间，它帮助我们使用所需的类，例如 `Assembly`。请参考以下函数，该函数根据其路径读取特定的程序集，并读取程序集中存在的所有类、方法和参数：
- en: '[PRE39]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code base, we have declared a fully qualified path for an assembly
    in C#. Next, we have declared an object of the `Assembly` class and have retrieved
    an array of all `Types` present in the assembly. Then, we are looping through
    each type and finding out the methods in each of those types. Once we have a list
    of methods for each of the types, we retrieve the list of parameters present in
    that method and their parameter types.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码库中，我们已声明了一个 C# 中程序集的完全限定路径。接下来，我们已声明了一个 `Assembly` 类的对象，并检索了程序集中所有 `Types`
    的数组。然后，我们正在遍历每个类型，并找出这些类型中的方法。一旦我们为每个类型获取了方法列表，我们就检索该方法中存在的参数列表及其参数类型。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to manage types in C#. We had a recap of the
    different data types available in C#. We did a deep dive into value and reference
    types in C#. We also had a review of the pointer data type and learned how it
    works. We had a look at some of the practices a user can use to choose the type
    of a variable. We had a look at generic types and learned how they help us to
    improve the performance of a system.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在C#中管理类型。我们对C#中可用的不同数据类型进行了回顾。我们深入探讨了值类型和引用类型。我们还回顾了指针数据类型，并学习了它是如何工作的。我们还查看了一些用户可以选择变量类型的实践。我们还查看了一般类型，并学习了它们如何帮助我们提高系统的性能。
- en: Then, we looked at the different techniques we use to consume a type declared
    in C#. We learned how boxing and unboxing work in C#. We then had a look at how
    to we consume these data types. We also looked at type conversions, both implicit
    and explicit, and learned how they help us to convert one data type into another.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了我们在C#中声明类型时使用的不同技术。我们学习了C#中的装箱和拆箱是如何工作的。然后，我们查看如何消费这些数据类型。我们还探讨了类型转换，包括隐式和显式转换，并学习了它们如何帮助我们转换一种数据类型到另一种数据类型。
- en: Then, we had a look at `Properties` and how it helps us to have more control
    over setting and retrieving values from the field attributes of a class. Then,
    we worked on strings and learned how they work. We looked at the immutable nature
    of strings. We looked at using `StringBuilder`, `StringWriter`, and `StringReader`,
    which help us to improve the performance aspect of using strings. We then looked
    at the different functions in C# that help us to do different manipulation functions
    on a string. Finally, we did a high-level review of reflection and, using a code
    example, we learned how we can retrieve the metadata present in an assembly.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们查看了一下`Properties`以及它是如何帮助我们更好地控制从类的字段属性设置和检索值的。然后，我们研究了字符串以及它们是如何工作的。我们探讨了字符串的不可变特性。我们探讨了使用`StringBuilder`、`StringWriter`和`StringReader`，这些工具帮助我们提高使用字符串的性能。然后，我们查看C#中帮助我们在字符串上执行不同操作函数的不同函数。最后，我们对反射进行了高级回顾，并通过代码示例学习了我们如何检索程序集中的元数据。
- en: In the next chapter, we will look at how garbage collection is performed in
    C#. We will look at how the CLR manages memory for different data types in C#.
    We will look at how C# allows us to manage "unmanaged resources" or the "pointer
    types" that we saw in this chapter. We will also look at how we implement the
    `IDisposable` interface to manage unmanaged resources.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨C#中垃圾回收是如何执行的。我们将探讨CLR如何在C#中管理不同数据类型的内存。我们将探讨C#如何允许我们管理“非托管资源”或本章中我们看到的“指针类型”。我们还将探讨我们如何实现`IDisposable`接口来管理非托管资源。
- en: Questions
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the keyword we use in the program function when we are using a pointer
    declaration?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用指针声明时，我们在程序函数中使用的关键字是什么？
- en: Sealed
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密封
- en: Safe
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全
- en: Internal protected
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部受保护
- en: Unsafe
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不安全
- en: What would be the output of the following code snippet?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段的输出会是什么？
- en: '[PRE40]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '100'
  id: totrans-291
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '100'
- en: Compile-time error
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译时错误
- en: '101'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '101'
- en: Runtime error
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时错误
- en: What would be the output of the following code snippet?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段的输出会是什么？
- en: '[PRE41]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It's present
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它存在
- en: It's not present
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它不存在
- en: Answers
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '**Unsafe**'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不安全**'
- en: '**Compile-time error**'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译时错误**'
- en: '**It''s not present**'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它不存在**'
