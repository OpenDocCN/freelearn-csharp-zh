<html><head></head><body>
		<div id="_idContainer059">
			<h1 id="_idParaDest-166" class="chapter-number"><a id="_idTextAnchor250"/>15</h1>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor251"/>Roslyn Compiler Extensions</h1>
			<p>Roslyn compiler extensions<a id="_idIndexMarker614"/> offer a powerful way to modify and extend the behavior of the C# compiler. With the Roslyn compiler, developers can write code that analyzes and modifies C# code at compile-time, opening new possibilities for code generation, code transformation, <span class="No-Break">and optimization.</span></p>
			<p>In this chapter, we will explore the technical setup of a Roslyn compiler extension project. The chapter itself is not focused on metaprogramming, but rather, on the technical setup for the two following chapters. We’ll delve into the process of packaging a Roslyn compiler extension for reuse. We’ll explore the different packaging options available, such as NuGet packages, and discuss best practices for making your extension easy to consume by <span class="No-Break">other developers.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>How to set up a project and its <span class="No-Break">moving parts</span></li>
				<li>How to package your extension <span class="No-Break">for reuse</span></li>
			</ul>
			<p>By the end of this chapter, you will have a solid understanding of how to set up a Roslyn compiler extension project and package it for reuse. You’ll be equipped with the knowledge and tools needed to start building powerful and flexible extensions that can significantly enhance the functionality of the <span class="No-Break">C# compiler.</span><a id="_idTextAnchor252"/></p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor253"/>Technical requirements</h1>
			<p>The source code specific to the chapter can be found on GitHub, (<a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter15">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter15</a>) and it builds on top of the <strong class="source-in ine">Fundamentals</strong> code that is found on <span class="No-Break">GitHub (</span><a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals"><span class="No-Break">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals</span></a><span class="No-Break">).</span><a id="_idTextAnchor254"/></p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor255"/>How to set up a project and its moving parts</h1>
			<p>The <a id="_idIndexMarker615"/>C# compiler, powered <a id="_idIndexMarker616"/>by the Roslyn framework (<a href="https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/">https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/</a>), provides a mechanism to load and use custom extensions in the form of analyzer and code fix providers. These extensions can be packaged as NuGet packages or included as project references, and they are loaded into the compilation process to analyze or modify the source code <span class="No-Break">being compiled.</span></p>
			<p>When the C# compiler encounters a project that includes a reference to a Roslyn extension, <span class="No-Break">it uses</span>
.NET’s<strong class="source-in ine"> AssemblyLoadContext</strong> to load the extension’s assembly into the compilation process. This allows the extension’s code to be executed during the compilation process and participate in the analysis and transformation of the <span class="No-Break">source code.</span></p>
			<p>The <a id="_idIndexMarker617"/>Roslyn extensions are loaded into the compiler as analyzers, or source generators. Analyzers <a id="_idIndexMarker618"/>are responsible for examining the <a id="_idIndexMarker619"/>source code and reporting diagnostics, which are warnings, errors, or suggestions about potential issues in the code. Code fix providers provide suggestions or <a id="_idIndexMarker620"/>automated fixes to resolve the reported issues and are used by your code editor. Source generators, on the other hand, generate additional source code during compilation based on specific rules <span class="No-Break">or templates.</span></p>
			<p>The C# compiler scans the loaded assemblies for types that implement interfaces defined by the Roslyn framework for different extension points. It then creates instances of these types and invokes their methods to perform the analysis and transformation of the <span class="No-Break">source code.</span></p>
			<p>The loading of Roslyn extensions occurs dynamically at compile-time, allowing for flexibility in adding or removing extensions without modifying the compiler itself, a great example of how the open / closed principle can be applied.. This dynamic loading also enables the reuse of extensions across different projects and solutions, as they can be packaged and distributed as NuGet packages or shared as <span class="No-Break">project refer<a id="_idTextAnchor256"/>ences.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor257"/>What can they do?</h2>
			<p>Roslyn compiler extensions provide a robust and flexible platform for metaprogramming in C#. With Roslyn, you have full access to the syntax tree and semantic model of the code being compiled, giving you deep insights into the structure, syntax, and semantics of the code. This allows you to perform sophisticated code analysis, generate code based on patterns or conventions, and apply transformations to the code to achieve <span class="No-Break">various goals.</span></p>
			<p>Here are some ways in which Roslyn compiler extensions can be powerful tools <span class="No-Break">for metaprogramming:</span></p>
			<ul>
				<li><strong class="bo d">Code generation</strong>: Roslyn <a id="_idIndexMarker621"/>compiler extensions allow you to generate code during compilation. This can be used to automatically generate repetitive code patterns, such as data access layers, serialization code, or boilerplate code for repetitive tasks. You can also generate code based on conventions, configuration, or metadata, making it easy to create reusable and customizable <span class="No-Break">code-generation tools.</span></li>
				<li><strong class="bo d">Code analysis</strong>: Roslyn <a id="_idIndexMarker622"/>compiler extensions enable you to perform custom code analysis during compilation. This can help you catch potential issues, enforce coding standards, and provide automated code review feedback. For example, you can use a Roslyn extension to identify and flag code smells, security vulnerabilities, or other code quality issues early in the development process, helping you maintain a high level of code quality in <span class="No-Break">your projects.</span></li>
				<li><strong class="bo d">Domain-Specific Language</strong> (<strong class="bo d">DSL</strong>): Roslyn compiler extensions can be used to create DSLs <a id="_idIndexMarker623"/>that provide specialized syntax and semantics tailored to specific problem domains. This allows you to define your own DSL and use it in your projects to improve expressiveness and maintainability. With a Roslyn extension, you can create custom syntax, create custom semantic rules, and enforce domain-specific conventions, making it easier to work with complex <span class="No-Break">domain-specific concepts.</span></li>
				<li><strong class="bo d">Tooling and productivity</strong>: Roslyn<a id="_idIndexMarker624"/> compiler extensions can be used to create custom tools and productivity features for development environments such as Visual Studio or VSCode. For example, you can create code refactoring tools, code completion providers, or diagnostics and quick fixes to streamline development workflows and catch common mistakes. With a Roslyn extension, you can create tailored tooling that fits your team’s specific needs and development<a id="_idIndexMarker625"/> practices, enhancing productivity and <span class="No-Break">code quality.</span></li>
				<li><strong class="bo d">Experimentation and innovation</strong>: Roslyn compiler extensions provide a platform for<a id="_idIndexMarker626"/> experimentation and innovation in the field of programming languages and compilers. You can use a Roslyn extension to prototype new language features, experiment with different programming paradigms, or implement novel programming techniques. This allows you to push the boundaries of what’s possible with C# and explore new ideas in the field of <span class="No-Break">software development.</span></li>
			</ul>
			<p>Roslyn compiler extensions are a valuable tool in the toolbox of any C# developer interested in metaprogramming and pushing the boundaries of what’s possi<a id="_idTextAnchor258"/>ble <span class="No-Break">with C#.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor259"/>Setting it up</h2>
			<p>In Visual Studio and <a id="_idIndexMarker627"/>other IDEs, you have project templates that allow you to create a Roslyn compiler extension easily. An extension is nothing more than a class library with the correct package references, depending on what type of extension you <span class="No-Break">are creating.</span></p>
			<p>Since we’re not targeting a specific IDE, we’ll be doing this from scratch with the .NET CLI and configuring the different <span class="No-Break">files manually.</span></p>
			<p>The first thing we’ll need is a project folder. Since we’re going to be reusing the extension project for the following chapters, let’s create a folder <span class="No-Break">called </span><span class="No-Break"><strong class="source-in ine">Roslyn.Extensions</strong></span><span class="No-Break">.</span></p>
			<p>Within the <strong class="source-in ine">Roslyn.Extensions</strong> folder, run <span class="No-Break">the following:</span></p>
			<pre class="source-code">
dotnet new classlib</pre>
			<p>You should now get two files called <strong class="source-in ine">Roslyn.Extensions.csproj</strong> and <strong class="source-in ine">Class1.cs</strong>. Delete the <strong class="source-in ine">Class1.cs</strong> file, as you won’t be <span class="No-Break">needing it.</span></p>
			<p>Open the <strong class="source-in ine">Roslyn.Extensions.csproj</strong> file in your editor. It should look something<a id="_idIndexMarker628"/> like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</pre>
			<p>You need to change this up a little bit for it to work with <span class="No-Break">the compiler:</span></p>
			<pre class="source-code">
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
    &lt;LangVersion&gt;11.0&lt;/LangVersion&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;EnforceExtendedAnalyzerRules&gt;true&lt;/EnforceExtendedAnalyzerRules&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</pre>
			<p>The change of <strong class="source-in ine">TargetFramework</strong> is necessary for it to work. The C# compiler won’t be able to load it otherwise. However, you might still want to write your extension using the latest C# edition, so you set <strong class="source-in ine">LangVersion</strong> to reflect the version of C# you want. You keep <strong class="source-in ine">ImplicitUsings</strong> and <strong class="source-in ine">Nullable</strong> if that is desirable. A project containing analyzers or source generators needs also to set <strong class="source-in ine">EnforceExtendedAnalyzerRules</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-in ine">true</strong></span><span class="No-Break">.</span></p>
			<p>For developing analyzers or source code generators, we’re going to have to add a couple of NuGet package references. As mentioned earlier, the goal of this chapter is to set up a common package for the chapters following this one, so we’ll be including what we want for those and<a id="_idIndexMarker629"/> a little <span class="No-Break">bit more.</span></p>
			<p>Within the <strong class="source-in ine">&lt;Project&gt;</strong> tag of the <strong class="source-in ine">Roslyn.Extensions.csproj</strong> file, after the initial <strong class="source-in ine">&lt;PropertyGroup&gt;</strong> add the following <strong class="source-in ine">&lt;</strong><span class="No-Break"><strong class="source-in ine">ItemGroup&gt;</strong></span><span class="No-Break"> block:</span></p>
			<pre class="source-code">
&lt;ItemGroup&gt;
    &lt;PackageReference
      Include="Microsoft.CodeAnalysis.CSharp"
      Version="4.5.0" PrivateAssets="all" /&gt;
    &lt;PackageReference
      Include="Microsoft.CodeAnalysis.Analyzers"
      Version="3.3.4" PrivateAssets="all" /&gt;
    &lt;PackageReference
      Include="Microsoft.CodeAnalysis.CSharp.CodeStyle"
      Version="4.5.0" PrivateAssets="all"/&gt;
    &lt;PackageReference
      Include="Microsoft.CodeAnalysis.NetAnalyzers"
      Version="7.0.1" PrivateAssets="all"/&gt;
    &lt;PackageReference Include="StyleCop.Analyzers"
      Version="1.1.118" PrivateAssets="all"/&gt;
&lt;/ItemGroup&gt;</pre>
			<p>The first three packages are for the development of analyzers and source code generators. While the next two packages are analyzers, we want to be used to making sure our code adheres <span class="No-Break">to standards.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">The <strong class="source-in ine">PrivateAssets</strong> attribute used in the packages is for dependencies for the project they’re added to, and anyone referencing this will not inherit these dependencies directly. This is important for when we package this project as a <span class="No-Break">NuGet package.</span></p>
			<p>If you want all the package references to be private to this package, you can do a neat little MSBuild trick by adding the following <span class="No-Break"><strong class="source-in ine">ItemGroup</strong></span><span class="No-Break"> code:</span></p>
			<pre class="source-code">
&lt;ItemGroup&gt;
    &lt;PackageReference Update="@(PackageReference)"
      PrivateAssets="All" /&gt;
&lt;/ItemGroup&gt;</pre>
			<p>By doing that, you don’t have to have the <strong class="source-in ine">PrivateAssets="All"</strong> attribute for all <span class="No-Break">your references.</span></p>
			<p>Depending on the <a id="_idIndexMarker630"/>version of your .NET installation, the version numbers of referenced packages might be different. You can read more about which version is right for you <span class="No-Break">here: </span><a href="https://github.com/dotnet/roslyn/blob/main/docs/wiki/NuGet-packages.md"><span class="No-Break">https://github.com/dotnet/roslyn/blob/main/docs/wiki/Nu<span id="_idTextAnchor260"/>Get-packages.md</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor261"/>Adding common rules</h2>
			<p>One of the great things <a id="_idIndexMarker631"/>about how the .NET compiler and the underlying MSBuild engine that handles all the building works is that you can have a project with all your rules for how you want things. Every project that references it will then <span class="No-Break">inherit this.</span></p>
			<p>EditorConfig (<a href="https://editorconfig.org">https://editorconfig.org</a>) is one of these items that can be reused among projects. Most IDEs and code editors out there honor the configuration of EditorConfig, which is great, because you can have a team using all kinds of editors, and they all adhere to the <span class="No-Break">same settings.</span></p>
			<p>At the<a id="_idIndexMarker632"/> root of a repository, you can place a file called <strong class="source-in ine">.editorconfig</strong>, which contains the common setup of rules that apply to every file within your project. The rules can be anything from formatting, tabs versus spaces, indentation levels, and specific rules picked up by compilers such as the <span class="No-Break">C# compiler.</span></p>
			<p>This is great to get consistency in your codebase, avoid potential problems, and increase the maintainability of the source code. With .NET, we can go one further by packaging it in a project and making it so that every project that references it will get these rules. The benefit of this is that you can then reuse it outside the realms of your repository, which we’ll come back to a little bit later in <span class="No-Break">this chapter.</span></p>
			<p>Let’s create a file called <strong class="source-in ine">.globalconfig</strong> in the <strong class="source-in ine">Roslyn.Extensions</strong> folder. Add the following code <span class="No-Break">to it:</span></p>
			<pre class="source-code">
is_global = true
end_of_line = lf
indent_style = space
indent_size = 4
charset = utf-8</pre>
			<p>This configuration sets <strong class="source-in ine">is_global</strong> to <strong class="source-in ine">true</strong> to indicate it should be a global settings file. It then goes on to specify how the end of the line is, the indentation style, and size, and then the <span class="No-Break">charset used.</span></p>
			<p>You can then go on and specify different rules specific to .NET. There are quite a few settings and rules you can configure, and I recommend reading more <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options">about it all <span class="No-Break">here: </span><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code</span></a><span class="No-Break">-style-rule-options</span><span class="No-Break">.</span></p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">In the GitHub repository for this book, you’ll find a more complete <strong class="source-in ine">.globalconfig</strong> file with a lot of .NET and C#-specific rules specified. Be aware that the rules put in place are a reflection of how I personally like the code <span class="No-Break">to be.</span></p>
			<p>Since <a id="_idIndexMarker633"/>you added a dependency to <strong class="source-in ine">StyleCop</strong>, we can also configure global options for it. Add a file called <strong class="source-in ine">stylecop.json</strong> in the <strong class="source-in ine">Roslyn.Extensions</strong> folder and add the following code <span class="No-Break">to it:</span></p>
			<pre class="source-code">
{
    "$schema": "https://raw.githubusercontent.com/DotNetAnalyzers/
     StyleCopAnalyzers/master/StyleCop.Analyzers/StyleCop.Analyzers/
     Settings/stylecop.schema.json",
    "settings": {
        "indentation": {
            "useTabs": false,
            "indentationSize": 4,
            "tabSize": 4
        },
        "orderingRules": {
            "systemUsingDirectivesFirst": true,
            "usingDirectivesPlacement": "outsideNamespace",
            "blankLinesBetweenUsingGroups": "omit"
        }
    }
}</pre>
			<p>As you can<a id="_idIndexMarker634"/> see, it duplicates the indentation style, which is recommended. It then goes on to specify specific rules for how you want the code to look. In this case, it specifies that the <strong class="source-in ine">using</strong> directives should be sorted with those prefixed with <strong class="source-in ine">System</strong> first. Then, it says that the using directives should be outside the namespace blocks and then omit any blank lines between using groups. These and more option<a href="https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/Configuration.md">s can be found <span class="No-Break">here: </span><span class="No-Break">https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documenta</span></a><span class="No-Break">ti<a id="_idTextAnchor262"/>on/Configuration.md</span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor263"/>Common project settings</h1>
			<p>If you have a set of <a id="_idIndexMarker635"/>configuration properties you want for all your projects, you can create a common <strong class="source-in ine">.props</strong> file that will automatically be picked up and used. All you need is a file called the same as the project with a <strong class="source-in ine">.props</strong> extension. In our case, the project name is <strong class="source-in ine">Roslyn.Extensions</strong>, so the file needed would be <span class="No-Break">called </span><span class="No-Break"><strong class="source-in ine">Roslyn.Extensions.props</strong></span><span class="No-Break">.</span></p>
			<p>A props file is basically just an MSBuild project file as the <strong class="source-in ine">.csproj</strong> file. MSBuild has a convention of automatically importing this file from a common extension project like this into consumers of the <span class="No-Break">extension package.</span></p>
			<p>Within a common project settings file, you can do more than just add properties. You can include files, add package references, or do anything that you can do in a regular <strong class="source-in ine">.csproj</strong> file. That is super powerful when you want to apply and enforce <span class="No-Break">common settings.</span></p>
			<p>Add a file called <strong class="source-in ine">Roslyn.Extensions.props</strong> to the <strong class="source-in ine">Roslyn.Extensions</strong> project and put the following code <span class="No-Break">into it:</span></p>
			<pre class="source-code">
&lt;Project&gt;
    &lt;PropertyGroup&gt;
        &lt;!-- Compiler settings --&gt;
        &lt;Nullable&gt;enable&lt;/Nullable&gt;
        &lt;TreatWarningsAsErrors&gt;True&lt;/TreatWarningsAsErrors&gt;
        &lt;MSBuildTreatWarningsAsErrors&gt;true
          &lt;/MSBuildTreatWarningsAsErrors&gt;
        &lt;!-- Code Analysis --&gt;
        &lt;CodeAnalysisTreatWarningsAsErrors&gt;True
          &lt;/CodeAnalysisTreatWarningsAsErrors&gt;
        &lt;RunAnalyzersDuringBuild&gt;True
          &lt;/RunAnalyzersDuringBuild&gt;
        &lt;RunAnalyzersDuringLiveAnalysis&gt;True
          &lt;/RunAnalyzersDuringLiveAnalysis&gt;
        &lt;RunAnalyzers&gt;True&lt;/RunAnalyzers&gt;
        &lt;AnalysisMode&gt;AllEnabledByDefault&lt;/AnalysisMode&gt;
        &lt;!-- Code Style --&gt;
        &lt;StyleCopTreatErrorsAsWarnings&gt;false
          &lt;/StyleCopTreatErrorsAsWarnings&gt;
        &lt;EnforceCodeStyleInBuild&gt;true
          &lt;/EnforceCodeStyleInBuild&gt;
    &lt;/PropertyGroup&gt;
&lt;/Project&gt;</pre>
			<p>The properties added configure first a couple of standard C# compiler settings. It enables <strong class="source-in ine">Nullable</strong> and then tells the compiler to be strict and treat any warnings as errors. Then, it tells the MSBuild engine to do <span class="No-Break">the same.</span></p>
			<p>Since we <a id="_idIndexMarker636"/>included code analysis, the next section configures it to force the compiler to run analyzers during the build and enable <span class="No-Break">them all.</span></p>
			<p>Lastly, it sets up the style cop analyzers to specifically not treat errors as warnings and enforces it <span class="No-Break">during build.</span></p>
			<p>The last thing you’re going to need is to make sure the <strong class="source-in ine">.globalconfig</strong> file and <strong class="source-in ine">stylecop.json</strong> file get used in any projects referencing this one. This is done by adding <strong class="source-in ine">ItemGroup</strong> after <strong class="source-in ine">PropertyGroup</strong> in the <strong class="source-in ine">Roslyn.Extensions.props</strong> file, and it looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
&lt;ItemGroup&gt;
    &lt;GlobalAnalyzerConfigFiles
      Include="$(MSBuildThisFileDirectory).globalconfig"/&gt;
    &lt;AdditionalFiles
      Include="$(MSBuildThisFileDirectory)stylecop.json"
      Link="stylecop.json" /&gt;
&lt;/ItemGroup&gt;</pre>
			<p>This lets the compiler know about the two files for configuring static code analysis and code styles. It uses a variable called <strong class="source-in ine">MSBuildThisFileDirectory</strong>, which is a well-known MSBuild variable that gets set to the folder of the file it is processing. Omitting this would make it look for this file relative to the current directory, which would be different for every project referencing this <span class="No-Break">common project.</span></p>
			<p>To this point, all<a id="_idIndexMarker637"/> you’ve done is wrap up common things in a common project that can, within a repository, be referenced and automatically configure all projects referencing it. Sometimes, you want to go beyond the boundaries of a single repository and publish the common project as a package that can then be reused by other projects and<a id="_idTextAnchor264"/> get the <span class="No-Break">same benefits.</span></p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor265"/>How to package your extension for reuse</h1>
			<p>One of the key<a id="_idIndexMarker638"/> advantages of Roslyn compiler extensions is their potential for reuse across different projects and solutions. Once you have developed a Roslyn extension, you can package it for reuse and share it with other developers or teams, providing a number of benefits <span class="No-Break">and advantages:</span></p>
			<ul>
				<li><strong class="bo d">Code consistency</strong>: Reusing Roslyn extensions can help enforce consistent coding practices across different projects and solutions. You can create Roslyn extensions that encapsulate coding standards, conventions, or best practices, and share them across your organization. This ensures that all projects adhere to the same coding guidelines, reducing inconsistencies and improving <span class="No-Break">code quality.</span></li>
				<li><strong class="bo d">Productivity</strong>: Reusing Roslyn extensions can enhance developer productivity by automating repetitive tasks and providing productivity features. For example, you can create Roslyn extensions that generate boilerplate code, automate code refactoring, or provide custom code completion providers. By reusing such extensions, you can save time and effort, and improve overall <span class="No-Break">development productivity.</span></li>
				<li><strong class="bo d">Maintainability</strong>: Reusing Roslyn extensions can improve code maintainability by encapsulating complex logic or code generation patterns. You can create Roslyn extensions that encapsulate DSLs, custom syntax, or semantic rules, and share them across projects. This makes it easier to maintain and update the codebase, as changes can be made in a central location and propagated to all projects using the <span class="No-Break">shared extension.</span></li>
				<li><strong class="bo d">Extensibility</strong>: Reusing Roslyn extensions can make your codebase more extensible by providing hooks or extension points for other developers. You can create Roslyn extensions that provide extensibility points, such as custom code generation templates or code analysis rules, which can be extended or customized by other developers as needed. This promotes collaboration and enables other teams or developers to extend the functionality of <span class="No-Break">your codebase.</span></li>
				<li><strong class="bo d">Innovation</strong>: Reusing <a id="_idIndexMarker639"/>Roslyn extensions can foster innovation by sharing new ideas, techniques, or approaches with the community. If you have developed a novel or innovative Roslyn extension, sharing it with the community can encourage others to build upon your work, leading to new discoveries, solutions, or techniques. This contributes to the growth and advancement of the Roslyn ecosystem, benefiting the <span class="No-Break">entire community.</span></li>
			</ul>
			<p>By sharing and reusing Roslyn extensions, you can improve code quality, enhance productivity, and foster collaboration, contributing to a more robust and vibrant <span class="No-Break">Roslyn ecosystem.</span></p>
			<p>Roslyn extensions can be a powerful tool for metaprogramming, which involves writing code that generates or manipulates other code. By creating and packaging Roslyn extensions, you can leverage metaprogramming techniques to automate repetitive tasks, enforce coding standards, or apply compliance rules such as <strong class="bo d">General Data Protection Regulation</strong> (<strong class="bo d">GDPR</strong>) across<a id="_idIndexMarker640"/> different projects <span class="No-Break">and solutions.</span></p>
			<p>For example, consider a <a id="_idIndexMarker641"/>scenario where you have multiple projects that need to comply with GDPR by ensuring that certain data handling practices are followed consistently. Instead of manually checking and updating each project’s codebase, you can create a Roslyn extension that encapsulates the compliance rules and distributes them across the projects. This way, you can ensure that the same compliance rules are applied uniformly in all projects, saving time and effort and reducing the risk of <span class="No-Break">human error.</span></p>
			<p>Furthermore, Roslyn extensions can also provide powerful metaprogramming capabilities to generate code or refactor existing code based on specific requirements. For instance, you can create a Roslyn extension that generates code snippets for common patterns or templates, such as implementing design patterns, handling common scenarios, or generating boilerplate code. By packaging and sharing this extension across projects, you can ensure that the generated code adheres to your organization’s coding standards or follows specific patterns, promoting consi<a id="_idTextAnchor266"/>stency <span class="No-Break">and maintainability.</span></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor267"/>Common package properties</h2>
			<p>All NuGet<a id="_idIndexMarker642"/> packages can have additional metadata. This metadata is very useful when published to a NuGet package repository<a href="https://nuget.org"> such as the<span id="_idIndexMarker643"/> off</a>icial one at <a href="https://nuget.org">https://nuget.org</a>. This metadata is typically then displayed on the information page of a package. The metadata you add contains information about the authors, copyright notices, where the project is located, <span class="No-Break">and more.</span></p>
			<p>Let’s add all the properties for the metadata. Open the <strong class="source-in ine">Roslyn.Extensions.csproj</strong> file and add the following code, typically after the first <strong class="source-in ine">&lt;PropertyGroup&gt;</strong> instance within the <strong class="source-in ine">&lt;</strong><span class="No-Break"><strong class="source-in ine">Project&gt;</strong></span><span class="No-Break"> tag:</span></p>
			<pre class="source-code">
&lt;PropertyGroup&gt;
  &lt;Copyright&gt;Packt Publishing&lt;/Copyright&gt;
  &lt;Authors&gt;all contributors&lt;/Authors&gt;
  &lt;RepositoryUrl&gt;https://github.com/PacktPublishing/Metaprogramming-
     in-C-Sharp&lt;/RepositoryUrl&gt;
  &lt;RepositoryType&gt;git&lt;/RepositoryType&gt;
  &lt;PublishRepositoryUrl&gt;true&lt;/PublishRepositoryUrl&gt;
  &lt;PackageLicenseExpression&gt;MIT&lt;/PackageLicenseExpression&gt;
  &lt;PackageProjectUrl&gt;https://github.com/PacktPublishing/
     Metaprogramming-in-C-Sharp&lt;/PackageProjectUrl&gt;
  &lt;PackageIcon&gt;logo.png&lt;/PackageIcon&gt;
  &lt;PackageReadmeFile&gt;README.md&lt;/PackageReadmeFile&gt;
&lt;/PropertyGroup&gt;</pre>
			<p>Obviously, you <a id="_idIndexMarker644"/>can set all these properties to what is right for your project. It includes also <strong class="source-in ine">logo.png</strong> and a <strong class="source-in ine">README.md</strong> file. If you don’t have these, you can just take these out. Having a <strong class="source-in ine">README.md</strong> file is, however, recommended when publishing to a package repository. Putting information into this file about how to use the package and what it is for would then be very helpful for the consumer of <span class="No-Break">the package.</span></p>
			<p>The metadata only points to the <strong class="source-in ine">logo.png</strong> file and <strong class="source-in ine">README.md</strong> file, but they have to be explicitly added for them to be part of the package. Add the following <strong class="source-in ine">ItemGroup</strong> text after the <span class="No-Break"><strong class="source-in ine">PropertyGroup</strong></span><span class="No-Break"> metadata:</span></p>
			<pre class="source-code">
&lt;ItemGroup&gt;
    &lt;None Include="$(MSBuildThisFileDirectory)logo.png"
      Pack="true" Visible="false" PackagePath="" /&gt;
    &lt;Content Include="$(MSBuildThisFileDirectory)README.md"
      PackagePath="/" /&gt;
&lt;/ItemGroup&gt;</pre>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">Notice the use of the <strong class="source-in ine">PackagePath</strong> attribute. This instructs the NuGet packager which target path to put the file into. For the <strong class="source-in ine">README.md</strong> file, it will be put at the root of <span class="No-Break">the package.</span></p>
			<p>For the common <a id="_idIndexMarker645"/>code properties, code analysis, and code style rules you added to the project earlier, they also need to be explicitly added to the package for them to work. Add another <strong class="source-in ine">ItemGroup</strong> block for <span class="No-Break">these files:</span></p>
			<pre class="source-code">
&lt;ItemGroup&gt;
    &lt;Content Include=".globalconfig" PackagePath="build\" /&gt;
    &lt;Content Include="stylecop.json" PackagePath="build\" /&gt;
    &lt;Content Include="Roslyn.Extensions.props"
      PackagePath="build\" /&gt;
&lt;/ItemGroup&gt;</pre>
			<p>For the <strong class="source-in ine">Roslyn.Extensions.props</strong> file to work when used as a package reference, it needs to sit inside a folder called <strong class="source-in ine">build</strong> within the package. Since we referred to the common files with a path prefixed with the <strong class="source-in ine">MSBuildThisFileDirectory</strong> MSBuild variable, it means that the common files also have to be in the<a id="_idTextAnchor268"/> <strong class="source-in ine">build</strong> path within <span class="No-Break">the package.</span></p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor269"/>Analyzer</h2>
			<p>The last piece of <a id="_idIndexMarker646"/>the puzzle is for the analyzer itself. For it to work, it needs to be within a specific part of the NuGet package, in a directory <span class="No-Break">called </span><span class="No-Break"><strong class="source-in ine">analyzers/dotnet/cs</strong></span><span class="No-Break">.</span></p>
			<p>Add another <strong class="source-in ine">ItemGroup</strong> block to the <span class="No-Break"><strong class="source-in ine">Roslyn.Extensions.csproj</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&lt;ItemGroup&gt;
    &lt;None Include="$(OutputPath)\$(AssemblyName).dll"
            Pack="true"
            PackagePath="analyzers/dotnet/cs"
            Visible="false" /&gt;
&lt;/ItemGroup&gt;</pre>
			<p><strong class="source-in ine">ItemGroup</strong> adds the DLL file of the project based on <strong class="source-in ine">OutputPath</strong>, which will vary depending on whether you’re building a debug or release version. Typically, for a release version, it would be <strong class="source-in ine">bin/Release/netstandard2.0</strong> and then the <strong class="source-in ine">AssemblyName</strong> variable reflects the output assembly name, which, in our case, would <span class="No-Break">be </span><span class="No-Break"><strong class="source-in ine">Roslyn.Extensions</strong></span><span class="No-Break">.</span></p>
			<p>Running <strong class="source-in ine">dotnet pack -c release</strong> in a terminal from the root of the <strong class="source-in ine">Roslyn.Extensions</strong> project should now create a package with all the artifacts <span class="No-Break">in place.</span></p>
			<p>The package will be output to the <strong class="source-in ine">bin/release</strong> folder and <span class="No-Break">called </span><span class="No-Break"><strong class="source-in ine">Roslyn.Extensions.1.0.0.nupkg</strong></span><span class="No-Break">.</span></p>
			<p>We can investigate the content of the package to see that everything we wanted it to include is included and in the correct locations. The NuGet package is nothing more than a compressed ZIP file. That means we can open it with your favorite ZIP utility and see whether the content is <span class="No-Break">as expected.</span></p>
			<p>The content should be something like <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B19418_15_01.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – Checking package content</p>
			<p>This package <a id="_idIndexMarker647"/>would now be ready to be published to a centralized package manager such as NuGet. You can read more about how to package NuGet packages at Microsoft’s official documentation for <span class="No-Break">this (</span><a href="https://learn.microsoft.com/en-us/nuget/nuget-org/publish-a-package"><span class="No-Break">https://learn.microsoft.com/en-us/nuget/nuget-org/publish-a-package</span></a><span class="No-Break">).</span></p>
			<p>That is pretty much it. You’ve now configured everything for a Roslyn extension and also put in common properties you want for every project referencing th<a id="_idTextAnchor270"/>e package you have <span class="No-Break">just created.</span></p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor271"/>Summary</h1>
			<p>In this chapter, we explored the technical setup of a Roslyn compiler extension project, covering the key moving parts of a Roslyn compiler extension. We discussed the various ways in which a Roslyn compiler extension can modify <span class="No-Break">C# code.</span></p>
			<p>We also delved into the process of packaging a Roslyn compiler extension for reuse, exploring the different packaging options available and discussing best practices for making your extension easy to consume by <span class="No-Break">other developers.</span></p>
			<p>In the next chapter, we will focus on generating code with Roslyn compiler extensions. We’ll explore techniques for generating new code based on existing code, and we’ll discuss best practices for ensuring that the generated code is of high quality and conforms to established conventions and standards. With the knowledge gained in this chapter and the next, you’ll be well on your way to building powerful and flexible Roslyn compiler extensions that can significantly enhance the functionality of the <span class="No-Break">C# compiler.</span></p>
		</div>
	</body></html>