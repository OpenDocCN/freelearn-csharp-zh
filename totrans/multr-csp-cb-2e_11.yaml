- en: Chapter 11. There's More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look through a new programming paradigm in the Windows
    10 operating system. Also, you will learn how to run .NET programs on OS X and
    Linux. You will learn the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a timer in a Universal Windows Platform application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using WinRT from usual applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `BackgroundTask` in Universal Windows Platform applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a .NET Core application on OS X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a .NET Core application on Ubuntu Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft released the first public beta build of Windows 8 at the Build conference
    on September 13, 2011\. The new OS tried to address almost every problem that
    Windows had by introducing features such as a responsive UI suitable for tablet
    devices with touch, lower power consumption, a new application model, new asynchronous
    APIs, and tighter security.
  prefs: []
  type: TYPE_NORMAL
- en: The core of Windows API improvements was a new multiplatform component system,
    **WinRT**, which is a logical development of COM. With WinRT, a programmer can
    use native C++ code, C# and .NET, and even JavaScript and HTML to develop applications.
    Another change is the introduction of a centralized application store, which did
    not exist on the Windows platform before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being a new application platform, Windows 8 had backward compatibility and
    allowed us to run the usual Windows applications. This lead to a situation where
    there were two major classes of applications: the Windows Store applications,
    where new programs are distributed via the Windows Store, and the usual classic
    applications that had not changed since the previous version of Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: However, Windows 8 was only the first step toward the new application model.
    Microsoft got a lot of feedback from the users, and it became clear that Windows
    Store applications were too different from what people were used to. Besides that,
    there was a separate smartphone OS, Windows 8 Phone, that had a different application
    store and a slightly different set of APIs. This made an application developer
    create two separate applications for desktop and smartphone platforms.
  prefs: []
  type: TYPE_NORMAL
- en: To improve the situation, the new Windows 10 OS was introduced as a unified
    platform for all Windows-powered devices. There is a single application store
    that supports every device family, and now, it is possible to create an application
    that works on phones, tablets, and desktops. Thus, Windows Store applications
    are now called Universal Windows Platform applications (UWP apps). This, of course,
    means a lot of limitations for your application—it should not use any platform-specific
    APIs, and as a programmer, you have to comply with specific rules. The program
    has to respond in a limited time to start up or to finish, keeping the whole operating
    system and other applications responsive. To save the battery, your applications
    are no longer running in the background by default; instead of that, they get
    suspended and actually stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: New Windows APIs are asynchronous, and you can only use whitelisted API functions
    in your application. For example, you are not allowed to create a new `Thread`
    class instance anymore. You have to use a system-managed thread pool instead.
    A lot of usual APIs cannot be used anymore, and you have to study new ways to
    achieve the same goals as before.
  prefs: []
  type: TYPE_NORMAL
- en: But this is not all. Microsoft began to understand that supporting operating
    systems other than Windows is also important. And now, you can write cross-platform
    applications using a new subset of .NET that is called .NET Core. Its source can
    be found on GitHub, and it is supported on platforms such as OS X and Linux. You
    can use any text editor, but I would suggest you take a look at Visual Studio
    Code—a new lightweight, cross-platform code editor, which runs on OS X and Linux
    and understands the C# syntax well.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how a Universal Windows Platform application is
    different from the usual Windows application and how we can use some of the WinRT
    benefits from the usual applications. We will also go through a simplified scenario
    of a Universal Windows Platform application with background notifications. You
    will also learn to run a .NET program on OS X and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Using a timer in a Universal Windows Platform application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to use a simple timer in Universal Windows Platform
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, you will need Visual Studio 2015 and the Windows
    10 operating system. No other prerequisites are required. The source code for
    this recipe can be found at `BookSamples\Chapter11\Recipe1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to use a timer in a Windows Store application, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# **Blank App (Universal Windows)**
    project in the `Windows\Universal` folder.![How to do it...](img/B05292_11_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are asked to enable developer mode for Windows 10, you have to enable
    it in the control panel.![How to do it...](img/B05292_11_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, confirm that you are sure you want to turn on developer mode.![How to
    do it...](img/B05292_11_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MainPage.xaml` file, add the `Name` attribute to the `Grid` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `MainPage.xaml.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet above the `MainPage` constructor definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `MainPage()` constructor with the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `OnNavigatedTo()` method under the `MainPage` constructor definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `OnNavigatedTo` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right-click on the project in Visual Studio **Solution Explorer** and choose
    **Deploy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the program runs, it creates an instance of a `MainPage` class. Here, we
    instantiate `DispatcherTimer` in the constructor and initialize the `ticks` counter
    to `0`. Then, in the `OnNavigatedTo` event handler, we create our UI controls
    and bind the start and stop buttons to the corresponding lambda expressions, which
    contain the `start` and `stop` logics.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `timer` event handler works directly with the UI controls.
    This is okay because `DispatcherTimer` is implemented in such a way that the handlers
    of the `Tick` event of `timer` are run by the UI thread. However, if you run the
    program and then switch to something else and then switch to the program after
    a couple of minutes, you may notice that the seconds counter is far behind the
    real amount of time that passed. This happens because Universal Windows Platform
    applications have completely different life cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be aware that Universal Windows Platform applications behave much like the applications
    on smartphone and tablet platforms. Instead of running in the background, they
    become suspended after some time, and this means that they are actually frozen
    until the user switches back to them. You have a limited time to save the current
    application state before it becomes suspended, and you are able to restore the
    state when the applications run again.
  prefs: []
  type: TYPE_NORMAL
- en: While this behavior could save power and CPU resources, it creates significant
    difficulties for program applications that are supposed to do some processing
    in the background. Windows 10 has a set of special APIs to program such applications.
    We will go through such a scenario later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using WinRT from usual applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to create a console application that will be able
    to use the WinRT API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, you will need Visual Studio 2015 and the Windows
    10 operating system. There are no other prerequisites. The source code for this
    recipe can be found at `BookSamples\Chapter11\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to use WinRT from usual applications, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# console application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the created project in Visual Studio **Solution Explorer** and
    select the **Unload Project…** menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the unloaded project and select the **Edit ProjectName.csproj**
    menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following XML code below the `<TargetFrameworkVersion>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the `.csproj` file, right-click on the unloaded project in Visual Studio
    **Solution Explorer**, and select the **Reload Project** menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the project and select **Add Reference** from the **Core** library
    under **Windows**. Then, click on the **Browse** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `C:\Program Files (x86)\Windows Kits\10\UnionMetadata` and click
    on `Windows.winmd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `C:\Program Files\Reference Assemblies\Microsoft\Framework\.NETCore\v4.5`
    and click on the `System.Runtime.WindowsRuntime.dll` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet to the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Program` class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we used quite a tricky way to consume the WinRT API from a common .NET
    console application. Unfortunately, not all available APIs will work in this scenario,
    but still, it could be useful to work with movement sensors, GPS location services,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To reference WinRT in Visual Studio, we manually edit the `.csproj` file, specifying
    the target platform for the application as Windows 10\. Then, we manually reference
    `Windows.winmd` to get access to Windows 10 APIs and `System.Runtime.WindowsRuntime.dll`
    to leverage the `GetAwaiter` extension method implementation for WinRT asynchronous
    operations. This allows us to use `await` on WinRT APIs directly. There is a backward
    conversion as well. When we create a WinRT library, we have to expose the WinRT
    native `IAsyncOperation` interfaces family for asynchronous operations, so they
    could be consumed from JavaScript and C++ in a language-agnostic manner.
  prefs: []
  type: TYPE_NORMAL
- en: File operations in WinRT are quite self-descriptive; here, we have asynchronous
    file create and delete operations. Still, file operations in WinRT contain security
    restrictions, encouraging you to use special Windows folders for your application
    and not allowing you to work with just any file path on your disk drive.
  prefs: []
  type: TYPE_NORMAL
- en: Using BackgroundTask in Universal Windows Platform applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe walks you through the process of creating a background task in a
    Universal Windows Platform application, which updates the application's live tile
    on a desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, you will need Visual Studio 2015 and the Windows
    10 operating system. There are no other prerequisites. The source code for this
    recipe can be found at `BookSamples\Chapter11\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to use `BackgroundTask` in Universal Windows Platform applications,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2015\. Create a new C# **Blank App (Universal Windows)**
    project under `Windows\Universal` folder. If you need to enable the Windows 10
    developer mode, refer to the *Using a timer in a Windows Store application* recipe
    for detailed instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Package.appxmanifest` file. In the **Declarations** tab, add **Background
    Tasks** to **Supported Declarations**. Under **Properties**, check the supported
    properties **System event** and **Timer** and set the name of **Entry point**
    to `YourNamespace.TileSchedulerTask`. `YourNamespace` should be the namespace
    of your application.![How to do it...](img/B05292_11_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MainPage.xaml` file, insert the following XAML code into the `Grid`
    element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `MainPage.xaml.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet above the `MainPage` constructor definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `MainPage` constructor with the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet above the `OnNavigatedTo` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet to the `OnNavigatedTo` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code snippet below the `MainPage` class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding program shows how to create a background time-based task and how
    to show the updates from this task on a live tile on the Windows 10 start menu.
    Programming Universal Windows Platform applications is quite a challenging task
    itself—you have to care about an application suspending/restoring its state and
    many other things. Here, we are going to concentrate on our main task, leaving
    behind the secondary issues.
  prefs: []
  type: TYPE_NORMAL
- en: Our main goal is to run some code when the application itself is not in the
    foreground. First, we create an implementation of the `IBackgroundTask` interface.
    This is our code, and the `Run` method will be called when we get a trigger signal.
    It is important that if the `Run` method contains asynchronous code with `await`
    in it, we have to use a special deferral object as shown in the recipe to explicitly
    specify when we begin and end the `Run` method execution. In our case, the method
    call is synchronous, but to illustrate this requirement, we work with the deferral
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our task in the `Run` method, we create a set of tile updates each minute
    for 4 hours and register it in `TileUpdateManager` with the help of the `ScheduledTaskNotification`
    class. A tile uses a special XML format to specify exactly how the text should
    be positioned in it. When we trigger our task from the system, it schedules one-minute
    tile updates for the next 4 hours. Then, we need to register our background task.
    We do this twice; one registration provides a `UserPresent` trigger, which means
    that this task will be triggered when a user is logged in. The next trigger is
    a time trigger, which runs the task once every 3 hours.
  prefs: []
  type: TYPE_NORMAL
- en: When the program runs, it creates a timer, which runs when the application is
    in the foreground. At the same time, it tries to register background tasks; to
    register these tasks, the program needs user permission, and it will show a dialog
    requesting permissions from the user. Now, we have scheduled live tile updates
    for the next 4 hours. If we close our application, the live tile will continue
    to show the new time every minute. In the next 3 hours, the time trigger will
    run our background task once again, and we will schedule another live tile update.
  prefs: []
  type: TYPE_NORMAL
- en: Running a .NET Core application on OS X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to install a .NET Core application on OS X and how to
    build and run a .NET console application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, you will need a Mac OS X operating system. There
    are no other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter11\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to run .NET Core applications, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install .NET Core on your OS X machine. You can visit [http://dotnet.github.io/getting-started/](http://dotnet.github.io/getting-started/)
    and follow the installation instructions there. Since .NET Core is in the pre-release
    stage, the installation and usage scenarios could change before this book is published.
    Refer to the site instructions in that case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you have downloaded the `.pkg` file, hold the *Control* key while opening
    it. It will unblock the file and will allow you to install it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you have installed the package, you will need to install OpenSSL. The
    easiest way is to install the homebrew package manager first. Open the terminal
    window and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you can install OpenSSL by typing the following in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is also the small catch that .NET Core at the time of writing needs to
    increase the open files limit. This can be achieved by typing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you have installed .NET Core and are ready to go. To create a sample Hello
    World application, you can create a directory and create an empty application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s check whether the default application works. To run the code, we have
    to restore dependencies and build and run the application. To achieve this, type
    the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s try to run some asynchronous code. In the `Program.cs` file, change
    the code to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program with the `dotnet run` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we download a `.pkg` file with the .NET Core installation package from
    the site and install it. We also install the OpenSSL library using the homebrew
    package manager (which also gets installed). Besides that, we increase the open
    files limit in OS X to be able to restore .NET Core dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create a separate folder for the .NET Core application, create a blank
    console application, and check whether everything works fine with restoring dependencies
    and running the code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create a simple asynchronous code and try to run it. It should run
    well, showing the messages that the first task completed successfully. The second
    task caused an exception, which was correctly handled. But if you try to uncomment
    a line that is intended to show the thread-specific information, the code will
    not be compiled, since .NET Core has no support for Thread APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Running a .NET Core application on Ubuntu Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to install a .NET Core application on Ubuntu and how to
    build and run a .NET console application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, you will need an Ubuntu Linux 14.04 operating system.
    There are no other prerequisites. The source code for this recipe can be found
    at `BookSamples\Chapter11\Recipe5`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to run .NET Core applications, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install .NET Core on your Ubuntu machine. You can visit [http://dotnet.github.io/getting-started/](http://dotnet.github.io/getting-started/)
    and follow the installation instructions there. Since .NET Core is in the pre-release
    stage, the installation and usage scenarios could change by the time this book
    is published. Refer to the site instructions in that case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, open a terminal window and run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you can install .NET Core by typing the following in the terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you have installed .NET Core and are ready to go. To create a sample Hello
    World application, you can create a directory and create an empty application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s check whether the default application works. To run the code, we have
    to restore dependencies and build and run the application. To achieve this, type
    the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s try to run some asynchronous code. In the `Program.cs` file, change
    the code to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the program with `dotnet run` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we start with setting up the apt-get feed that hosts the .NET Core packages
    that we need. This is necessary since at the time of writing, .NET Core for Linux
    may not have been released. For sure, when the release happens, it will get into
    normal apt-get feeds and you won't have to add custom feeds to it. After completing
    this, we use apt-get to install the currently working version of .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create a separate folder for the .NET Core application, create a blank
    console application, and check whether everything works fine with restoring dependencies
    and running the code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create a simple asynchronous code and try to run it. It should run
    well, showing messages that the first task completed successfully, and the second
    task caused an exception, which was correctly handled. But if you try to uncomment
    a line that is intended to show the thread-specific information, the code will
    not be compiled, since .NET Core has no support for Thread APIs.
  prefs: []
  type: TYPE_NORMAL
