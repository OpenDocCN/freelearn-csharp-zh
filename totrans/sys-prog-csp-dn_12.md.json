["```cs\n{\n  \"MyPublicSettings\": {\n    \"Setting1\": \"Value1\",\n    \"Setting2\": \"Value2\",\n    \"Setting3\": \"Value3\"\n  },\n  \"MySecretSettings\": {\n    \"MySecretSetting1\": \"SecretValue1\",\n    \"MySecretSetting2\": \"SecretValue2\"\n  }\n}\n```", "```cs\nvar serviceCollection = new ServiceCollection();\nserviceCollection.AddDataProtection();\nvar serviceProvider = serviceCollection.BuildServiceProvider();\nvar dataProtector = serviceProvider.GetDataProtector(\"MySecureData\");\n```", "```cs\nvar configuration = new ConfigurationBuilder()\n    .SetBasePath(Directory.GetCurrentDirectory())\n    .AddJsonFile(\"appsettings.json\")\n    .Build();\n```", "```cs\nvar json = File.ReadAllText(\"appsettings.json\");\n```", "```cs\nvar secretSection = configuration.GetSection(\"MySecretSettings\");\nforeach (var key in secretSection.GetChildren())\n{\n    var originalValue = key.Value;\n    var encryptedValue = dataProtector.Protect(originalValue);\n    var oldValue = $\"\\\"{key.Key}\\\": \\\"{originalValue}\\\"\";\n    var newValue = $\"\\\"{key.Key}\\\": \\\"{encryptedValue}\\\"\";\n    json = json.Replace(oldValue, newValue);\n}\nFile.WriteAllText(\"appsettings.json\", json);\n```", "```cs\nconfiguration.Reload();\nvar encryptedSection = configuration.GetSection(\"MySecretSettings\");\nvar someSecretValue = encryptedSection[\"MySecretSetting1\"];\nvar decryptedValue = dataProtector.Unprotect(someSecretValue);\n$\"Encrypted value was: {someSecretValue}\\nDecrypted this becomes: {decryptedValue}\".Dump();\n```", "```cs\nvar secondProtector = serviceProvider.GetDataProtector(\"AnotherSection\");\nvar decryptedValue = secondProtector.Unprotect(someSecretValue);\n```", "```cs\nserviceCollection\n    .AddDataProtection()\n    .PersistKeysToFileSystem(new DirectoryInfo(myKeyFolder));\n```", "```cs\nvar myOpenString = \"This is my Open String\";\nConsole.ReadLine();\n```", "```cs\nName:        System.String\nMethodTable: 00007ffaf832ec08\nEEClass:     00007ffaf830a500\nTracked Type: false\nSize:        66(0x42) bytes\nFile:        C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\8.0.5\\System.Private.CoreLib.dll\nString:      This is my Open String\nFields:\n              MT    Field   Offset                 Type VT\nAttr            Value Name\n00007ffaf82b1188  400033b        8         System.Int32  1 instance               22 _stringLength\n00007ffaf82bb538  400033c        c          System.Char  1 instance               54 _firstChar\n00007ffaf832ec08  400033a       c8        System.String  0   static 000001ee80000008 Empty\n```", "```cs\nusing var secureString = new SecureString();\n```", "```cs\nvar sourceString = \"This is a big secret\";\nforeach (var c in sourceString)\n{\n    secureString.AppendChar(c);\n}\nsecureString.MakeReadOnly();\n```", "```cs\nvoid OverwriteAndClearString(ref string str)\n{\n    if (str == null) return;\n    unsafe\n    {\n        fixed (char* ptr = str)\n        {\n            for (int i = 0; i < str.Length; i++)\n            {\n                ptr[i] = '\\0'; // Overwrite with null characters\n            }\n        }\n    }\n    str = null; // Dereference the string\n}\n```", "```cs\npublic async Task<string> GetSecretAsync(string keyVaultUrl, string secretName)\n{\n    var client =\n        new SecretClient(\n            new Uri(keyVaultUrl),\n            new DefaultAzureCredential());\n    var secret =\n        await client.GetSecretAsync(secretName);\n    return secret.Value.Value;\n}\n```", "```cs\n$env:MY_SECRET_ID = 12345678\n```", "```cs\nWrite-Host $env:MY_SECRET_ID\n```", "```cs\n$env:MY_SECRED_ID = $null\n```", "```cs\nsetx MY_SECRET_ID 87654321\n```", "```cs\nsetx MY_GLOBAL_SECRET_ID 87654321 /m\n```", "```cs\nstring mySecretdId =\n   Environment.GetEnvironmentVariable(\"MY_SECRET_ID\");\n```", "```cs\nvar mySecretdId =\n Environment.GetEnvironmentVariable(\"MY_GLOBAL_SECRET_ID\");\n```", "```cs\n[DllImport(\"advapi32.dll\", SetLastError = true, CharSet = CharSet.Auto)]\npublic static extern bool LogonUser(\n    string lpszUsername,\n    string lpszDomain,\n    string lpszPassword,\n    int dwLogonType,\n    int dwLogonProvider,\n    out SafeAccessTokenHandle phToken);\n[DllImport(\"kernel32.dll\", CharSet = CharSet.Auto)]\npublic static extern bool CloseHandle(IntPtr handle);\n```", "```cs\nprivate const int LOGON32_LOGON_BATCH = 4;\nprivate const int LOGON32_PROVIDER_DEFAULT = 0;\n```", "```cs\npublic static void RunAsAdmin(\n    string userName, string domain,\n    string password, Action action)\n{\n    var returnValue = LogonUser(\n        userName, domain,\n        password, LOGON32_LOGON_BATCH,\n        LOGON32_PROVIDER_DEFAULT,\n        out var safeAccessTokenHandle);\n    if (!returnValue)\n    {\n        var ret = Marshal.GetLastWin32Error();\n        throw new Win32Exception(ret);\n    }\n    try\n    {\n        WindowsIdentity.RunImpersonated(safeAccessTokenHandle, () => {           action(); });\n    }\n    finally\n    {\n        safeAccessTokenHandle.Dispose();\n    }\n}\n```", "```cs\nvar userName = Environment.UserName;\n$\"Current user: {userName}\".Dump();\nvar adminUserName = \"MySecureAdmin\";\nvar domain = \"dennismachine\";\nvar password = \"P@ssw0rd!\";\nImpersonationHelper.RunAsAdmin(\n    adminUserName, domain, password, () =>\n{\n    var otherUserName = Environment.UserName;\n    $\"Username {otherUserName}\".Dump();\n});\n```", "```cs\nMakeCert -r -pe -ss PrivateCertStore -n \"CN=localhost\" -sv testcer.pvk testcer.cer\n```", "```cs\npvk2pfx -pvk .\\testcer.pvk -spc .\\testcer.cer -pfx testcer.pfx -po \"password\"\n```", "```cs\ncertutil -importpfx testcer.pfx\n```", "```cs\npublic SecureServer(int port,\n    string certificatePath,\n    string certificatePassword)\n{\n    _port = port;\n    _serverCertificate = new X509Certificate2(\n        certificatePath,\n        certificatePassword);\n}\n```", "```cs\npublic async Task StartAsync()\n{\n    \"Server is starting...\".Dump();\n    var listener = new TcpListener(IPAddress.Any, _port);\n    listener.Start();\n    $\"Server is listening on port {_port}...\".Dump();\n    while (true)\n    {\n        var clientSocket = await listener.AcceptSocketAsync();\n        _ = HandleClientConnection(clientSocket);\n    }\n}\n```", "```cs\nprivate async Task HandleClientConnection(Socket clientSocket)\n{\n    try\n    {\n        await using var sslStream =\n            new SslStream(\n                new NetworkStream(clientSocket),\n                false);\n        await sslStream.AuthenticateAsServerAsync(\n            _serverCertificate,\n            false,\n            SslProtocols.Tls12,\n            true);\n        $\"Client connected: {clientSocket.RemoteEndPoint}\".Dump();\n```", "```cs\n        var buffer = new byte[1024];\n        var bytesRead =\n            await sslStream.ReadAsync(\n                buffer,\n                0,\n                buffer.Length);\n        var receivedString =\n            Encoding.UTF8.GetString(\n                buffer,\n                0,\n                bytesRead);\n        $\"Received from client: {receivedString}\".Dump();\n    }\n    catch (Exception ex)\n    {\n        ex.Message.Dump();\n    }\n}\n```", "```cs\nvar certificatePath = @\"d:\\Certificate\\testcer.pfx\";\nvar certificatePassword = \"password\";\nvar server = new SecureServer(\n    8081,\n    certificatePath,\n    certificatePassword);\nawait server.StartAsync();\n```", "```cs\npublic SecureClient(\n    string server,\n    int port)\n{\n    _server = server;\n    _port = port;\n}\n```", "```cs\npublic async Task ConnectAsync()\n{\n    using var clientSocket = new TcpClient(_server, _port);\n    await using var networkStream = clientSocket.GetStream();\n    await using var sslStream =\n        new SslStream(\n            networkStream,\n            false,\n            ValidateServerCertificate);\n    try\n    {\n        await sslStream.AuthenticateAsClientAsync(_server);\n        \"SSL authentication successful\".Dump();\n        var message = $\"Hello, server! {DateTime.Now.TimeOfDay}\";\n        var messageBytes = Encoding.UTF8.GetBytes(message);\n        await sslStream.WriteAsync(messageBytes, 0, messageBytes.Length);\n    }\n    catch (Exception ex)\n    {\n        ex.Message.Dump(ConsoleColor.Red);\n    }\n}\n```", "```cs\nprivate static bool ValidateServerCertificate(\n    object sender,\n    X509Certificate certificate, X509Chain chain,\n    SslPolicyErrors sslPolicyErrors)\n{\n    if (sslPolicyErrors == SslPolicyErrors.None)\n    {\n        \"Server certificate is valid\".Dump();\n        return true;\n    }\n    \"Server certificate is invalid\".Dump(ConsoleColor.Red);\n    return false;\n}\n```", "```cs\nvar secureClient = new SecureClient(\"localhost\", 8081);\nawait secureClient.ConnectAsync();\n```"]