<html><head></head><body>
		<div><h1 id="_idParaDest-217" class="chapter-number"><a id="_idTextAnchor216"/>9</h1>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor217"/>Authentication and Authorization with Services and Clients</h1>
			<p>Not every user and application should be allowed to access all API services. Some APIs should only be accessible from specific applications, and others should be restricted to a group of users.</p>
			<p>In this chapter, you’ll <a id="_idIndexMarker675"/>learn how to use <strong class="bold">business-to-consumer</strong> (<strong class="bold">B2C</strong>) to allow users to register with our application and protect APIs. We’ll use <a id="_idIndexMarker676"/>Azure <strong class="bold">Active Directory</strong> (<strong class="bold">AD</strong>) B2C for this. For an on-premises solution (which can also be used in the cloud), we’ll be using ASP.NET Core Identity.</p>
			<p>Instead <a id="_idIndexMarker677"/>of securing every API project, you’ll learn about Microsoft <strong class="bold">Yet Another Reverse Proxy</strong> (<strong class="bold">YARP</strong>), a proxy that is put in front of the APIs that are available to restrict access to the services in the backend.</p>
			<p>In this chapter, you’ll learn how to do the following:</p>
			<ul>
				<li>Create an Azure AD B2C tenant</li>
				<li>Secure REST APIs</li>
				<li>Use Microsoft YARP</li>
				<li>Use ASP.NET Core Identity</li>
			</ul>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor218"/>Technical requirements</h1>
			<p>In this chapter, like the previous chapters, you’ll need an Azure subscription, Docker Desktop, and .NET Aspire.</p>
			<p>The code for this chapter can be found in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</a>.</p>
			<p>The <code>ch09</code> folder contains the following projects, along with their outputs:</p>
			<ul>
				<li><code>Codebreaker.ApiGateway</code>: This is a new project that will act as an application gateway in front of the <code>game-apis</code> service and <code>bot-service</code> and secure the APIs with the help of YARP</li>
				<li><code>WebAppAuth</code>: This is a new project for the client part that focuses on creating new users with Azure AD B2C, providing authentication from the client side, and invoking <code>bot-service</code> via the gateway</li>
				<li><code>Codebreaker.ApiGateway.Identities</code>: This is a new project that can be used instead of <code>Codebreaker.ApiGateway</code> where instead of using Azure AD B2C, local users are created and managed</li>
			</ul>
			<p>To help you go through the code with this chapter, start by using the code from the previous chapter.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor219"/>Choosing an identity solution</h1>
			<p>Different options are available to authenticate users with .NET solutions. If you require a local database <a id="_idIndexMarker678"/>that can manage users, you can use <strong class="bold">ASP.NET Core Identity</strong>, which makes <a id="_idIndexMarker679"/>use of EF Core (see <a href="B21217_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>). It allows you to store local users and integrate user accounts, such as those from Microsoft, Facebook, and <a id="_idIndexMarker680"/>Google, with <strong class="bold">OpenID Connect</strong> (<strong class="bold">OIDC</strong>). For the database, SQL Server and MySQL can be used, while the data schema is completely customizable.</p>
			<p>To reduce the work required, and to enhance security, it’s not necessary to implement this functionality with every service – here, Microsoft YARP can be used to forward the requests and send the required claims.</p>
			<p>If external applications are accessing the identity management solution, an <strong class="bold">OIDC</strong> server should be used to manage identities. If storing user data in a cloud service is not an option, a third-party service such as Identity Server from Duende (<a href="https://duendesoftware.com/products/communityedition">https://duendesoftware.com/products/communityedition</a>) can be used. This is free for small companies.</p>
			<p>To store user <a id="_idIndexMarker681"/>data in a cloud service, many companies use <strong class="bold">Microsoft Entra</strong>. This can <a id="_idIndexMarker682"/>easily be integrated with .NET applications. This service offers <strong class="bold">business-to-business</strong> (<strong class="bold">B2B</strong>) functionality that allows you <a id="_idIndexMarker683"/>to add external users (<strong class="bold">Entra External Identities</strong>). Microsoft, Facebook, and Google accounts are on the list of supported external users. However, at the <a id="_idIndexMarker684"/>time of writing, <strong class="bold">Microsoft Entra</strong> does not allow <a id="_idIndexMarker685"/>users to register themselves. For this, <strong class="bold">Azure AD B2C</strong> is a great option. This service can also be used with services running on-premises and accessing authentication from the cloud.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">With its user data residency requirement, Azure AD B2C allows you to select a country when you’re creating a directory and shows the location for the data. However, if, for example, the requirement is to keep the user data in Switzerland, it’s stored in Europe, which might not be enough for the legal requirements of some businesses.</p>
			<p>For the Codebreaker solution, we’ll use Azure AD B2C and ASP.NET Core Identity.</p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor220"/>Creating an Azure AD B2C tenant</h1>
			<p>The Codebreaker solution should allow users to register with the application and play different game types. Some limited game types are available to anonymous users. All the game <a id="_idIndexMarker686"/>types and more functionalities are available to registered users. Some parts of the solution should only be accessible to specific user groups – for example, <code>bot-service</code> should not be accessible from normal registered playing users. Specific user permissions (or claims) are required for differentiation.</p>
			<p>To create a new AAD B2C tenant, open the Azure portal and click <strong class="bold">Create a resource</strong>. Select <strong class="bold">Identity</strong> from the left bar and choose <strong class="bold">Azure Active Directory B2C</strong>. Then, select <strong class="bold">Create a new Azure AD B2C Tenant</strong>. This will open the screen shown in <em class="italic">Figure 9</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/B21217_09_01.jpg" alt="Figure 9.1 – Creating an AAD B2C tenant"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Creating an AAD B2C tenant</p>
			<p>To create a <a id="_idIndexMarker687"/>new AAD B2C tenant, you need to enter the name of the organization, the name of the domain name (a domain name that does not exist yet), the location that will be used to define the region where the user data is stored, a subscription, and a resource group. Once you’ve done this, click <strong class="bold">Review + Create</strong>, then <strong class="bold">Create</strong>.</p>
			<p>You’ll need to wait a short time for the directory to be created. To list the directories available to you, and to switch directories, within the Azure portal, click the <strong class="bold">Settings</strong> button. Select the new directory and click <strong class="bold">Switch</strong> to change to it. Similarly, you can switch back to the directory where you run Azure resources.</p>
			<p>In the <a id="_idIndexMarker688"/>next few sections, we’ll do the following:</p>
			<ul>
				<li>Specify identity providers so that the user doesn’t need to enter another password</li>
				<li>Configure user attributes to define what information the application needs from the user</li>
				<li>Define user flows to specify how the user information flows</li>
				<li>Create app registrations to define service applications that offer APIs and client applications for accessing APIs</li>
			</ul>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/>Specifying identity providers</h2>
			<p>When you <a id="_idIndexMarker689"/>are in an Azure AD B2C, you can open the Azure AD B2C configuration. The B2C directory supports a large list of different identity providers. Users don’t need to remember another password when they use identity providers. Within the Azure AD B2C configuration, in the <strong class="bold">Manage</strong> category in the left pane, select <strong class="bold">Identity provider</strong> (see <em class="italic">Figure 9</em><em class="italic">.2</em>):</p>
			<div><div><img src="img/B21217_09_02.jpg" alt="Figure 9.2 – Identity providers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Identity providers</p>
			<p>By default, <strong class="bold">Local account</strong> is configured so that a password is stored locally with AAD B2C. You can <a id="_idIndexMarker690"/>configure Microsoft, Google, Facebook, and other accounts that support OIDC. The Codebreaker directory has GitHub configured as a provider because most developers already have a GitHub account.</p>
			<p>For each provider, you’re what needs to be done to configure it. You just need to click on the provider to get that information. With GitHub, for example, you need to create a GitHub OAuth application to get all the values you need to configure this provider. For authenticating services with AAD B2C, you can keep the default settings.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/>Configuring user attributes</h2>
			<p>No matter <a id="_idIndexMarker691"/>which provider you choose, you must have a way to identify users. To gather such information, you must ask your users for details. You can also create custom attributes that should be stored in the directory. Within the <strong class="bold">Manage</strong> category, select <strong class="bold">User Attributes</strong>, as shown in <em class="italic">Figure 9</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/B21217_09_03.jpg" alt="Figure 9.3 – User Attributes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – User Attributes</p>
			<p>Here, several built-in attributes, such as <code>Gamer Name</code> of the <code>String</code> type.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Due <a id="_idIndexMarker693"/>to the <strong class="bold">General Data Protection Regulation</strong> (<strong class="bold">GDPR</strong>), you need to ensure you only collect necessary data and keep it secured, allow the user to ask for the data that you’ve stored, and allow the user to delete that data if it doesn’t need to be stored for legal reasons.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/>Defining user flows</h2>
			<p>With user <a id="_idIndexMarker694"/>flows, you define what information should be collected from the user when registering or editing the user profile, and what information should be sent to the application within <strong class="bold">claims</strong>.</p>
			<p>Within the AAD B2C configuration, from the left pane, within the <code>B2C_1_</code>. Add a name (for example, <code>SUSI</code>) and select the <strong class="bold">Email</strong> signup identity provider. You can also select social providers such as GitHub. Regarding the <strong class="bold">User attributes and token claims</strong> category, select the user attributes the user should enter when this dialogue is shown, as well as the claims that are passed to the application within a token, as shown in <em class="italic">Figure 9</em><em class="italic">.4</em>:</p>
			<div><div><img src="img/B21217_09_04.jpg" alt="Figure 9.4 – Creating a user flow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Creating a user flow</p>
			<p>When defining what information to ask from the user, keep GDPR in mind.</p>
			<p>Azure AD B2C allows you to customize user flow dialogues by specifying company branding, changing the page layout, returning custom pages, and adding API connectors for custom <a id="_idIndexMarker695"/>validators when a user registers.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">User attributes <a id="_idIndexMarker696"/>can be filled by creating user flows or <strong class="bold">custom policies</strong>. See the links in the <em class="italic">Further reading</em> section for more information. Also, check out the source code in the Codebreaker Backend repository (<a href="https://github.com/codebreakerapp/Codebreaker.Backend">https://github.com/codebreakerapp/Codebreaker.Backend</a>), which contains a custom policy for adding groups for privileged users.</p>
			<p>As soon as an application has been registered (the next step), you can test the user flow, as shown in <em class="italic">Figure 9</em><em class="italic">.5</em>:</p>
			<div><div><img src="img/B21217_09_05.jpg" alt="Figure 9.5 – Testing the user flow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Testing the user flow</p>
			<p>Selecting the user attributes that should be collected defines the input elements of the dialogue. The icon, colors, and <a id="_idIndexMarker697"/>layout can be customized. It’s even possible to create complete custom dialogues.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/>Creating app registrations</h2>
			<p>Next, we’ll <a id="_idIndexMarker698"/>learn how to register apps. Here, we <a id="_idIndexMarker699"/>will register the application gateway that offers APIs and a client application. Other applications can be registered similarly.</p>
			<p>In the <strong class="bold">Manage</strong> category in the left pane, click <strong class="bold">App registrations</strong>. This opens the <strong class="bold">App registrations</strong> page, as shown in <em class="italic">Figure 9</em><em class="italic">.6</em>:</p>
			<div><div><img src="img/B21217_09_06.jpg" alt="Figure 9.6 – Registering an app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Registering an app</p>
			<p>Add multiple <a id="_idIndexMarker700"/>app registrations: the <code>Codebreaker.GameAPIs</code> application <a id="_idIndexMarker701"/>offers the game APIs, <code>Codebreaker.Bot</code> and <code>Codebreaker.Blazor</code> are web applications that need API permissions, and <code>Codebreaker.Client</code> is a client application that needs API permissions.</p>
			<p>When you configure the app registration process, you specify what accounts are allowed to use this application. Here, we’ll allow all accounts, externally registered users, and the <a id="_idIndexMarker702"/>redirect URI. To test the <code>game-apis</code> service from <a id="_idIndexMarker703"/>the local developer system, specify the port number that’s used when running it locally, such as <code>http://localhost:5453</code>, and click the <strong class="bold">Register</strong> button. The link to the Azure container app needs to be added later.</p>
			<h3>Defining scopes</h3>
			<p>You can specify <a id="_idIndexMarker704"/>applications that offer APIs via the app registration process. In the <code>games</code>. Within this scope, add the <code>Games.Play</code> and <code>Games.Query</code> scopes, as shown in <em class="italic">Figure 9</em><em class="italic">.7</em>:</p>
			<div><div><img src="img/B21217_09_07.jpg" alt="Figure 9.7 – Defining scopes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Defining scopes</p>
			<h3>Creating a secret</h3>
			<p>To only allow <a id="_idIndexMarker705"/>applications that have been identified applications, you can add a certificate or a secret. Instead of using secrets, a better approach could be to run the application with a user that is allowed to access the service. Here, managed identities can be used. This is not possible in all scenarios.</p>
			<p>Using the <strong class="bold">Certificates and secrets</strong> option from the left pane, create a client secret. Secrets cannot be read from the portal again, only after creation. Copy the secret before leaving the page.</p>
			<h3>Adding API permissions</h3>
			<p>For application <a id="_idIndexMarker706"/>registrations that invoke APIs, you need to configure <strong class="bold">API permissions</strong>, as shown in <em class="italic">Figure 9</em><em class="italic">.8</em>:</p>
			<div><div><img src="img/B21217_09_08.jpg" alt="Figure 9.8 – Adding API permissions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Adding API permissions</p>
			<p>The <code>Codebreaker.Blazor</code> and <code>Codebreaker.Client</code> application registrations need the <code>Games.Play</code> and <code>Games.Query</code> application permissions. After adding these permissions, click <strong class="bold">Grant </strong><strong class="bold">admin consent</strong>.</p>
			<h3>Evaluating the app registration process</h3>
			<p>With this <a id="_idIndexMarker707"/>configuration complete, open <code>bot-service</code> and the client applications). Then, click <strong class="bold">Evaluate my app registration</strong>, as shown in <em class="italic">Figure 9</em><em class="italic">.9</em>:</p>
			<div><div><img src="img/B21217_09_09.jpg" alt="Figure 9.9 – Integration assistant results"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Integration assistant results</p>
			<p>The integration <a id="_idIndexMarker708"/>assistant offers great information for development, testing, releasing, and monitoring when you click the tabs above the recommended configurations. If you see some warnings or errors, click the ellipsis (<strong class="bold">…</strong>). From here, you can check the documentation and open a page where you can change your configuration.</p>
			<p>With Azure AD B2C configured, let’s implement some code so that we can make use of AAD B2C.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor225"/>Securing an API</h1>
			<p>We can now <a id="_idIndexMarker709"/>secure every API project. However, there are different ways we can do this so that we can reduce the work we need to do. One option is to use Azure Container Apps to configure authentication. Instead of configuring this for every container app, let’s create a new project that will be secured and routed to multiple services. For this, we’ll use <strong class="bold">YARP</strong>.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor226"/>Creating a new project with authentication</h2>
			<p>Create a new <a id="_idIndexMarker710"/>Web API project by using the .NET template with the <code>-au</code> authentication option:</p>
			<pre class="console">
dotnet new webapi -minimal -au IndividualB2C -o Codebreaker.ApiGateway</pre>
			<p>Using the .NET CLI, you can also pass all the values needed to configure the B2C service, such as <code>--domain</code> for the domain, <code>--aad-b2c-instance</code> to pass the domain link for logging in, <code>--client-id</code> for the application ID, <code>--susi-policy-id</code> for the signup user flow (before it was called <em class="italic">user flow</em>, it was called <em class="italic">policy</em>), and <code>--default-scope</code> to configure a scope. If you don’t assign parameter values for these configurations, you just need to change them after they’ve been created in the <code>appsettings.json</code> file.</p>
			<p>The NuGet packages related to authentication and authorization that have been added to this project are as follows:</p>
			<ul>
				<li><code>Microsoft.AspNetCore.Authentication.JwtBearer</code>: This package supports <a id="_idIndexMarker711"/>authentication using <strong class="bold">JSON Web </strong><strong class="bold">Tokens</strong> (<strong class="bold">JWT</strong>)</li>
				<li><code>Microsoft.AspNetCore.Authentication.OpenIdConnect</code>: This package allows authentication with an OIDC against identity providers, such as Azure AD B2C</li>
				<li><code>Microsoft.Identity.Web</code>: This package provides utilities and middleware for authentication flows and user authorization</li>
				<li><code>Microsoft.Identity.Web.DownstreamApi</code>: This package helps call downstream APIs using the same authentication context</li>
			</ul>
			<p>Next, we’ll add YARP to this project.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor227"/>Creating an application gateway with YARP</h2>
			<p>When creating a microservices solution, it’s not necessary to implement authentication with every service. Instead, you can create a service that acts as a reverse proxy. Clients only <a id="_idIndexMarker712"/>call into the reverse proxy. This proxy forwards authenticated requests to other services. Here, we’ll use Microsoft YARP. A reverse proxy sits in front of backend services and intercepts invocations from a client before it is sent to the service. The YARP proxy offers different features, such as load balancing, rate limiting, switching of protocols, selecting services based on different versions, and more. Based on Layer 7, the proxy can read HTTP requests to route based on links and HTTP headers, as well as change the protocol that’s used. Here, we’ll use a reverse proxy to deal with authentication and authorization before forwarding the requests to the backend service.</p>
			<p><em class="italic">Figure 9</em><em class="italic">.10</em> shows the new way to communicate with the services:</p>
			<div><div><img src="img/B21217_09_10.jpg" alt="Figure 9.10 – Communication via YARP"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Communication via YARP</p>
			<p>The reverse proxy routes incoming requests to backend services. The backend services that have been routed are <code>game-apis</code> and <code>bot-service</code>. The client applications don’t interact with these services; they just use the YARP gateway.</p>
			<p>In <a id="_idIndexMarker713"/>addition to the NuGet packages we added earlier, we need to add the <code>Yarp.ReverseProxy</code> and <code>Microsoft.Extensions.ServiceDiscovery.Yarp</code> NuGet packages. The first one is the package for YARP, while the second one allows us to use.NET service discovery with YARP.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor228"/>Mapping routes with YARP</h2>
			<p>How the <a id="_idIndexMarker714"/>proxy service communicates with the backend APIs can be configured both programmatically and using a configuration file. We’ll use the second option with the <code>appsettings.json</code> file. First, let’s configure the addresses of the <code>game-apis</code> service and <code>bot-service</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGatewayIntro/appsettings.json</p>
			<pre class="source-code">
{
  "ReverseProxy": {
    <strong class="bold">"Clusters":</strong> {
      "gamesapicluster": {
        <strong class="bold">"Destinations":</strong> {
          "gamescluster/destination1": {
            "Address": "http://gameapis"
          }
        }
      }
      "botcluster": {
<strong class="bold">        "Destinations": {</strong>
          "botcluster/destination1": {
            "Address": "http://bot"
          }
        }
      },
    },
    // configuration removed for brevity
  }
}</pre>
			<p>The complete <a id="_idIndexMarker715"/>reverse proxy configuration is added to the <code>ReverseProxy</code> section, The configuration section, called <code>Clusters</code>, defines the list of systems that are available for the <code>game-apis</code> service and <code>bot-service</code>. With every service, multiple addresses can be added. Using the service discovery YARP package, we can use the .NET Aspire named endpoints.</p>
			<p>The following code configures the routes that use the cluster configuration:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGatewayIntro/appsettings.json</p>
			<pre class="source-code">
{
  "ReverseProxy": {
    // configuration removed for brevity
    <strong class="bold">"Routes":</strong> {
      "gamesRoute": {
        "ClusterId": "gamesapicluster",
        <strong class="bold">"Match":</strong> {
          <strong class="bold">"Path":</strong> "/games/{*any}"
        }
      },
      "botRoute": {
        "ClusterId": "botcluster",
        <strong class="bold">"Match":</strong> {
          <strong class="bold">"Path":</strong> "/bot/{*any}"
        }
      }
    }
  }
}</pre>
			<p>The <code>Routes</code> configuration contains a list of routes. <code>gamesRoute</code> references the previously specified <code>gamesapicluster</code>, while <code>botRoute</code> references the hosts defined by <code>botcluster</code>. The <code>Match</code> configuration specifies the <code>Path</code> that’s used to map the request to the corresponding cluster.</p>
			<p>We just <a id="_idIndexMarker716"/>need to make a small update to the startup code to activate this reverse proxy library:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway/Program.cs</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
<strong class="bold">builder.Services.AddReverseProxy()</strong>
<strong class="bold">  .LoadFromConfig(</strong>
<strong class="bold">    builder.Configuration.GetSection("ReverseProxy"));</strong>
var app = builder.Build();
<strong class="bold">app.MapReverseProxy();</strong>
app.Run();</pre>
			<p>The <code>AddReverseProxy</code> method registers the services that are needed by the reverse proxy to the DI container. The <code>LoadFromConfig</code> method retrieves the configuration values from the previously specified configuration. The <code>MapReverseProxy</code> method configures the middleware to forward the requests, as defined by the configuration.</p>
			<p>With the <code>AppHost</code> project, after adding a reference to the gateway project, the gateway can be added to the app model:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var gameAPIs = builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis")
  .WithReference(cosmos)
  .WithEnvironment("DataStore", dataStore);
var bot = builder.AddProject&lt;Projects.CodeBreaker_Bot&gt;("bot")
  .WithReference(gameAPIs);
<strong class="bold">builder.AddProject&lt;Projects.Codebreaker_ApiGateway&gt;("gateway")</strong>
<strong class="bold">  .WithReference(gameAPIs)</strong>
<strong class="bold">  </strong><strong class="bold">.WithReference(bot)</strong>
<strong class="bold">  .WithExternalHttpEndpoints();</strong>
// code removed for brevity</pre>
			<p>The API <a id="_idIndexMarker717"/>gateway needs to reference the <code>game-apis</code> service and <code>bot-service</code>. Here, external HTTP endpoints are no longer needed. Only the gateway needs references from outside when it’s deployed to the Azure Container Apps environment, thus only the gateway configuration uses the <code>WithExternalHttpEndpoints</code> method.</p>
			<p>With this in place, you can start the application and invoke the two services via the gateway. The requests are forwarded to the specific service.</p>
			<p>Next, we’ll add authentication to the gateway.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor229"/>Adding authentication to the gateway</h2>
			<p>Using the .NET <a id="_idIndexMarker718"/>template for the Web API with Identity already added some code for authentication and authorization. We will enhance this code now.</p>
			<p>We can configure the DI container to authenticate users by invoking the <code>AddAuthentication</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway/Program.cs</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.<strong class="bold">AddAuthentication</strong>(JwtBearerDefaults.AuthenticationScheme)
  .<strong class="bold">AddMicrosoftIdentityWebApi</strong>(
    <strong class="bold">builder.Configuration.GetSection("AzureAdB2C")</strong>);
// code removed for brevity</pre>
			<p>The <code>AddAuthentication</code> method registers services that are needed for authentication. The <code>JwtBearerDefaults.AuthenticationScheme</code> argument returns <strong class="bold">Bearer</strong> as the authentication scheme. Bearer tokens are used with most REST APIs because they can be used easily and don’t require encryption but need to perform HTTPS encryption to secure it.</p>
			<p><code>AddMicrosoftIdentityWebApi</code> is an extension method that extends <code>AuthenticationBuilder</code> and protects the API using the Microsoft Identity platform. <code>AzureAdB2C</code> is a configuration section that specifies the values from AADB2C from <code>appsettings.json</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway/appsettings.json</p>
			<pre class="source-code">
{
  // configuration removed for brevity
  «AzureAdB2C»: {
<strong class="bold">    «Instance»: «https://&lt;domain&gt;.b2clogin.com»,</strong>
<strong class="bold">    «Domain»: «&lt;domain&gt;.onmicrosoft.com»,</strong>
<strong class="bold">    "ClientId": "&lt;app-id&gt;",</strong>
<strong class="bold">    "SignedOutCallbackPath": "/signout/B2C_1_SUSI",</strong>
<strong class="bold">    "SignUpSignInPolicyId": "B2C_1_SUSI"</strong>
  }
}</pre>
			<p>With the <code>appsettings.json</code> configuration file, you need to configure your Azure AD B2C <a id="_idIndexMarker719"/>domain name, the application ID, and the previously configured user flow.</p>
			<p>The <code>AddAuthentication</code> method specifies the authentication configuration:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway/Program.cs</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
// code removed for brevity
builder.Services.<strong class="bold">AddAuthentication</strong>(JwtBearerDefaults.AuthenticationScheme)
  .<strong class="bold">AddMicrosoftIdentityWebApi</strong>(
    builder.Configuration.GetSection("AzureAdB2C"));
builder.Services.<strong class="bold">AddAuthorization</strong>(options =&gt;
{
<strong class="bold">  options.AddPolicy("playPolicy", config =&gt;</strong>
<strong class="bold">  </strong><strong class="bold">{</strong>
<strong class="bold">    config.RequireScope("Games.Play");</strong>
<strong class="bold">  });</strong>
<strong class="bold">  options.AddPolicy("queryPolicy", config =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    config.RequireScope("Games.Query");</strong>
<strong class="bold">    config.RequireAuthentication();</strong>
<strong class="bold">  }</strong>
});</pre>
			<p>The <code>AddAuthorization</code> method <a id="_idIndexMarker720"/>allows configuration with an <code>AuthorizationOptions</code> delegate. The options allow you to specify a default policy and named policies. The preceding code snippet defines the <code>playPolicy</code> and <code>queryPolicy</code> policies. <code>playPolicy</code> requires the <code>Games.Play</code> scope to be set, whereas <code>queryPolicy</code> requires the <code>Games.Query</code> scope to be set. <code>queryPolicy</code> also requires <a id="_idIndexMarker721"/>the user to be authenticated. You can define a claim to be passed with the token by using the <code>RequireClaim</code> method.</p>
			<p>With the policies in place, routes can be restricted to the required policies:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway/appsettings.json</p>
			<pre class="source-code">
// configuration removed for brevity
  "ReverseProxy": {
    "Routes": {
      "botRoute": {
        "ClusterId": "botcluster",
<strong class="bold">        "AuthorizationPolicy": "botPolicy",</strong>
        "Match": {
          "Path": "/bot/{*any}"
        }
      },</pre>
			<p>Using the <code>AuthorizationPolicy</code> configuration, alongside <code>botRoute</code>, <code>botPolicy</code> is referenced to require authenticated users and the application to send the correct scope.</p>
			<p>Now that we’ve configured the DI container, the middleware needs to be configured:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPis/Program.cs</p>
			<pre class="source-code">
var app = builder.Build();
<strong class="bold">app.UseAuthentication();</strong>
<strong class="bold">app.UseAuthorization();</strong>
// code removed for brevity</pre>
			<p>The <code>UseAuthentication</code> method adds <a id="_idIndexMarker722"/>authentication middleware, while the <code>UseAuthorization</code> method adds authorization middleware.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If the minimal API needs to be restricted directly, the <code>RequireAuthorization</code> extension method can be used. A policy can be passed as an argument to check for the policy’s requirements. Upon injecting <code>ClaimsPrincipal</code> as an argument to a minimal API method, information about the user and claim information can be retrieved programmatically. This allows us to check for restrictions based on values that are retrieved with the API.</p>
			<p>To test <a id="_idIndexMarker723"/>this out, we’ll update our client application.</p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor230"/>Authentication using Microsoft Identity with ASP.NET Core web applications</h1>
			<p>To <a id="_idIndexMarker724"/>authenticate <a id="_idIndexMarker725"/>using Azure AD B2C, we’ll use the Microsoft Identity platform. In this section, we’ll focus on creating accounts with Azure AD B2C, logging in, and invoking secured REST APIs with ASP.NET Core web applications.</p>
			<p>Like with the minimal API we created earlier, a .NET template can be used. Invoke this command to create a new project:</p>
			<pre class="console">
dotnet new webapp -au IndividualB2C -o WebAppAuth</pre>
			<p>In creating this project, several NuGet packages are added for identities and authentication. These were discussed when we secured the API. An additional package that hasn’t been used before is <code>Microsoft.Identity.Web.UI</code>. This package integrates with <code>Microsoft.Identity.Web</code> and offers pre-built UI elements for login, logout, and profile management.</p>
			<p>With <a id="_idIndexMarker726"/>the DI <a id="_idIndexMarker727"/>container configuration, authentication is added. So, we need to customize it for calling APIs:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">WebAppAuth/Program.cs</p>
			<pre class="source-code">
IConfigurationSection scopeSections = builder.Configuration
  .GetSection("AzureAdB2C").GetSection("Scopes");
String[] scopes = scopeSection.Get&lt;string[]&gt;() == [];
<strong class="bold">builder.Services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme)</strong>
<strong class="bold">  .AddMicrosoftIdentityWebApp(</strong>
<strong class="bold">    builder.Configuration.GetSection("AzureAdB2C"))</strong>
<strong class="bold">  .EnableTokenAcquisitionToCallDownstreamApi(scopes)</strong>
<strong class="bold">  .AddInMemoryTokenCaches();</strong></pre>
			<p>To use Azure AAD B2C, <code>AddAuthentication</code> is invoked using the configuration from the <code>AzureAdB2C</code> section within <code>appsettings.json</code>. <code>AddMicrosoftIdentityWeb</code> is an extension method from the <code>Microsoft.Identity.Web</code> NuGet package. This configures supporting cookies and <code>OpenIdConnect</code>. The <code>EnableTokenAcquisitionToCallDownstreamApi</code> method allows us to pass tokens that have been received from the application so that we can forward them to the APIs that have been invoked by the application via <code>HttpClient</code>. When using this method, the <code>ITokenAcquisition</code> interface is registered in the DI container. This can be used to retrieve the tokens and pass them to the HTTP headers of <code>HttpClient</code>.</p>
			<p>For the Microsoft Identity user interface, the <code>AddMicrosoftIdentityUI</code> method needs to be configured with the DI container:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">WebAppAuth/Program.cs</p>
			<pre class="source-code">
<strong class="bold">builder.Services.AddRazorPages()</strong>
<strong class="bold">  .AddMicrosoftIdentityUI();</strong></pre>
			<p>This <a id="_idIndexMarker728"/>method <a id="_idIndexMarker729"/>configures <code>AccountController</code> (based on ASP.NET Core MVC) with <code>SignIn</code> and <code>SignOut</code> methods in the <code>MicrosoftIdentity</code> area.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When creating Blazor client applications, AD B2C support is built-in with .NET 7 templates, but not with .NET 8. Support has been planned for .NET 9. You can add AD B2C integration manually.</p>
			<p class="callout">Some differences in authentication can be implemented with different client technologies. Check out the links in the <em class="italic">Further reading</em> section for more information. Also, check out the Codebreaker GitHub (<a href="https://github.com/codebreakerapp">https://github.com/codebreakerapp</a>) for implementations for Blazor, WinUI, .NET MAUI, WPF, and Uno Platform.</p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor231"/>Specifying authentication with Azure Container Apps</h1>
			<p>Instead of <a id="_idIndexMarker730"/>needing to manage authentication with the service itself, we can do this directly with Azure Container Apps. After selecting the deployed games API, within the Azure portal, choose <strong class="bold">Authentication</strong> from the <strong class="bold">Settings</strong> category in the left pane. Here, you can add an <strong class="bold">identity provider</strong>. By selecting <strong class="bold">Microsoft</strong>, you can configure <strong class="bold">Workforce</strong> or <strong class="bold">Customer</strong> tenant types. <strong class="bold">Workforce</strong> is for B2B scenarios. Here, you can directly create an app registration within Microsoft Entra. For B2C, select <strong class="bold">Customer</strong>.</p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor232"/>Using ASP.NET Core Identity to store user information in a local database</h1>
			<p>If Azure <a id="_idIndexMarker731"/>AD B2C is not <a id="_idIndexMarker732"/>an option for you, you can use <strong class="bold">ASP.NET Core Identity</strong>, which .NET offers for storing users in a local database. We’ll use this as an alternative way to run the solution without the need to configure Azure AD B2C.</p>
			<p>With <code>-au </code><code>Individual</code> option:</p>
			<pre class="console">
dotnet new blazor -au Individual -int Auto -o Codebreaker.ApiGateway.Identities</pre>
			<p>This creates two projects: <code>Codebreaker.ApiGateway.Identities</code> and <code>Codebreaker.ApiGateway.Identities.Client</code>. The second project is a library that <a id="_idIndexMarker734"/>contains <strong class="bold">Razor components</strong> that can be run on the client <a id="_idIndexMarker735"/>with <strong class="bold">interactive WebAssembly rendering</strong>, as <a id="_idIndexMarker736"/>well as <strong class="bold">interactive server rendering</strong>. This library was referenced in the first project, which hosts the Blazor application and contains Razor components that support interactive server rendering. This project contains a huge list of Razor components for registering users to help users with forgotten passwords, as well as components for managing user information.</p>
			<p>Let’s cover some important parts of this application, beginning with the database.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor233"/>Customizing the EF Core configuration</h2>
			<p>With this <a id="_idIndexMarker737"/>project, user information is <a id="_idIndexMarker738"/>stored in a relational database via EF Core. By default, MySQL is used. This can easily be changed to SQL Server, but using MySQL for this scenario is great as well.</p>
			<p>What information about users is stored is defined with the <code>ApplicationDbContext</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway.Identities/Data/ApplicationDbContext.cs</p>
			<pre class="source-code">
public class <strong class="bold">ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options) :</strong>
<strong class="bold">  IdentityDbContext&lt;ApplicationUser&gt;(options)</strong>
{
}</pre>
			<p><code>ApplicationDbContext</code> is an EF Core context with a hierarchy of base classes. The body of this class is empty as it was created from the template. Adding custom <code>DbSet</code> properties <a id="_idIndexMarker739"/>allows you to add <a id="_idIndexMarker740"/>additional tables to the database. The base class, <code>IdentityDbContext</code>, uses the <code>ApplicationUser</code> class as a generic parameter to define what information to store about the user:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway.Identities/Data/ApplicationUser.cs</p>
			<pre class="source-code">
public class <strong class="bold">ApplicationUser</strong> : <strong class="bold">IdentityUser</strong>
{
}</pre>
			<p>Adding properties to this class allows you to customize the <code>users</code> table with additional columns. To see the defined properties, you need to follow the base classes, starting with <code>IdentityUser</code>. <code>IdentityUser</code> derives from <code>IdentityUser&lt;string&gt;</code>. The generic string parameter specifies the use of GUID values for the key. The generic <code>IdentiyUser</code> type defines the <code>UserName</code>, <code>Email</code>, <code>PasswordHash</code>, and <code>PhoneNumber</code> properties, among others, to map to columns.</p>
			<p><code>IdentityDbContext&lt;TUser&gt;</code> has some more base classes, such as <code>IdentityUserContext&lt;TUser</code>, <code>TRole</code>, <code>TKey</code>, <code>TUserClaim</code>, <code>TuserLogin</code>, and <code>TUserToken&gt;</code>, to define several tables that are used.</p>
			<p>The EF Core context needs to be configured with the DI container:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway.Identities/Program.cs</p>
			<pre class="source-code">
// code removed for brevity
<strong class="bold">builder.AddMySqlDbContext&lt;ApplicationDbContext&gt;("usersdb");</strong></pre>
			<p>Here, the EF Core configuration has been changed to use the <code>Aspire.Pomelo.EntityFrameworkCore.MySql</code> NuGet package with the MySQL Entity Framework .NET Aspire component.</p>
			<p>With that, the EF Core context has been configured with ASP.NET Core Identity.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor234"/>Configuring ASP.NET Core Identity</h2>
			<p>When <a id="_idIndexMarker741"/>configuring ASP.NET Core Identity, EF Core must be mapped:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway.Identities/Program.cs</p>
			<pre class="source-code">
// code removed for brevity
<strong class="bold">builder.Services.AddIdentityCore&lt;ApplicationUser&gt;(options =&gt;</strong>
<strong class="bold">  options.SignIn.RequireConfirmedAccount = true)</strong>
<strong class="bold">  .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()</strong>
<strong class="bold">  .AddSignInManager()</strong>
<strong class="bold">  .AddDefaultTokenProviders();</strong></pre>
			<p>The <code>AddIdentityCore</code> method configures the <code>ApplicationUser</code> class (the same class that was used with the EF Core model) for ASP.NET Core Identity. When the user registers, before using the account, it needs to be confirmed by setting the <code>RequireConfirmedAccount</code> property (discussed next). With the invocation of <code>AddEntityFrameworkStores</code>, the EF Core context, <code>ApplicationDbContext</code>, is mapped to ASP.NET Core Identity. The <code>AddSignInManager</code> method registers the <code>SignInManager</code> class with the DI container. <code>SignInManager</code> can be used to log the user in and out, retrieve claims, and work with two-factor authentication options. The <code>AddDefaultTokenProviders</code> method registers token providers by implementing the <code>IUserTwoFactorTokenProvider</code> interface to return and validate tokens for two-factor authentication, such as email, phone, and so on.</p>
			<p>To confirm an account, the <code>IEmailSender</code> interface needs to be registered with the DI container:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.ApiGateway.Identities/Data/ApplicationUser.cs</p>
			<pre class="source-code">
<strong class="bold">builder.Services.AddSingleton&lt;IEmailSender&lt;ApplicationUser&gt;, IdentityNoOpEmailSender&gt;();</strong></pre>
			<p>With the <a id="_idIndexMarker742"/>default configuration, a no-op <code>IdentityNoOpEmailSender</code> class is implemented. This is practical for testing purposes but needs to be changed to verify a user’s email address.</p>
			<p>Now, let’s configure the project with the .NET Aspire AppHost project:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CodebreakerAppHost/Program.cs</p>
			<pre class="source-code">
string startupMode = Environment.GetEnvironmentVariable("STARTUP_MODE") ?? "Azure";
bool useAzureADB2C = startupMode == "Azure";
// code removed for brevity
if (startupMode == "OnPremises")
{
  var usersDbName = "usersdb";
  var mySqlPassword = builder.AddParameter("mysql-password", secret: true);
<strong class="bold">  var usersDb = builder.AddMySql("mysql", password: mySqlPassword)</strong>
<strong class="bold">    .WithEnvironment("MYSQL_DATABASE", usersDbName)</strong>
<strong class="bold">    .WithDataVolume()</strong>
<strong class="bold">    .WithPhpMyAdmin()</strong>
<strong class="bold">    .AddDatabase(usersDbName);</strong>
<strong class="bold">  var gateway = builder.AddProject&lt;Projects.Codebreaker_ApiGateway_</strong>
    <strong class="bold">Identities&gt;("gateway-identities")</strong>
    .WithReference(gameAPIs)
    .WithReference(bot)
<strong class="bold">    .WithReference(usersDb)</strong>
    .WithExternalHttpEndpoints();</pre>
			<p>Here, the AppHost project uses multiple launch profiles to either start the solution with Azure AD B2C (the <code>Azure</code> launch profile), or with the local database (the <code>OnPremises</code> launch profile). When it comes to the different launch profile settings, the <code>STARTUP_MODE</code> environment variable is configured, which is then used to differentiate <a id="_idIndexMarker743"/>the projects to be started and how they are configured. When launching <code>OnPremises</code> mode, the newly created project is configured to reference the MySQL database running in a container via the <code>Aspire.Hosting.MySql</code> NuGet package. The <code>WithDataVolume</code> method creates a named Docker volume (see <a href="B21217_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>) to have persistence, while the <code>WithPhpMyAdmin</code> method adds an admin UI.</p>
			<p>If we run the solution now, we can register a new user, as shown in <em class="italic">Figure 9</em><em class="italic">.11</em>:</p>
			<div><div><img src="img/B21217_09_11.jpg" alt="Figure 9.11 – Registering a local user"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Registering a local user</p>
			<p>When registering <a id="_idIndexMarker744"/>the user, you might need to apply EF Core migrations to create the database. On receiving the registration confirmation, choose <strong class="bold">Click here to confirm your account</strong> to approve the email. Then, click the <strong class="bold">Login</strong> button on the left pane. After logging in, the email will be shown on the <strong class="bold">Auth </strong><strong class="bold">Required</strong> page.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Instead of having the user remember another password, with ASP.NET Core Identity, it’s also possible to add external providers, such as Microsoft, Facebook, and Google accounts, as shown at <a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social">https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social</a>.</p>
			<p>With phpMyAdmin enabled, you can open the management UI and see the tables that have been created, as shown in <em class="italic">Figure 9</em><em class="italic">.12</em>:</p>
			<div><div><img src="img/B21217_09_12.jpg" alt="Figure 9.12 – MySQL admin UI"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – MySQL admin UI</p>
			<p>Using this <a id="_idIndexMarker745"/>admin UI, you can perform SQL queries and easily change and delete records.</p>
			<p>With ASP.NET Core Identity in place, users can now register with this application and manage their accounts. This option is great if user data isn’t stored within a managed cloud service and can be implemented easily. What about using desktop client applications? They can use an API to access this data. We’ll learn how to add this API in the next section.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor235"/>Creating identity API endpoints</h2>
			<p>.NET 8 offers identity API endpoints that use the ASP.NET Core Identity infrastructure.</p>
			<p>With the <a id="_idIndexMarker746"/>EF Core configuration <a id="_idIndexMarker747"/>for ASP.NET Core Identity in place, all we need to do is configure the identity endpoints with the DI container and the middleware. The DI container must be configured first:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Gateway.Identity/Program.cs</p>
			<pre class="source-code">
// code removed for brevity
builder.Services
<strong class="bold">  .AddIdentityApiEndpoints&lt;ApplicationUser&gt;()</strong>
<strong class="bold">  .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();</strong></pre>
			<p>The <code>AddIdentityApiEndpoints</code> method adds authentication with a Bearer token and identity cookies, as well as options and validators to validate allowed passwords and usernames, register <code>UserManager</code>, and provide a factory for user claims. <code>IEmailSender</code>, which is used to validate correct emails, is configured to use <code>NoOpEmailSender</code>. When you have a real implementation of <code>IEmailSender</code> in place (using your email provider), you need to make sure you register this class after the invocation of <code>AddIdentityApiEndpoints</code> to overwrite <code>NoOpEmailSender</code> with your configuration. The <code>AddEntityFrameworkStores</code> method is an extension method for the returned <code>IdentityBuilder</code> object and adds the EF Core store for user and role data.</p>
			<p>The middleware can be configured using the <code>MapIdentityApi</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Gateway.Identity/Program.cs</p>
			<pre class="source-code">
// code removed for brevity
<strong class="bold">app.MapGroup("/identity")</strong>
<strong class="bold">  .MapIdentityApi&lt;ApplicationUser&gt;();</strong></pre>
			<p>The <code>MapGroup</code> method is used to add a common prefix for the identity API. <code>MapIdentityApi</code> itself defines several URIs, such as <code>/register</code> to register a new user by using <code>RegisterRequest</code> with the body of a POST request, and <code>/login</code> to log a user in while passing <code>LoginRequest</code>, which can include username, password, and two-factor codes, links to reset a forgotten password, confirmation of the email, and more.</p>
			<p>Some of these APIs allow anonymous access (for example, when registering or logging in), while with others, authentication is required. The API group with the <code>/manage</code> link is configured to require authentication.</p>
			<p>When <a id="_idIndexMarker748"/>Swagger is enabled, you’ll see <a id="_idIndexMarker749"/>all these APIs, as shown in <em class="italic">Figure 9</em><em class="italic">.13</em>. This means you can test them before using them from a client application:</p>
			<div><div><img src="img/B21217_09_13.jpg" alt="Figure 9.13 – Identity API endpoints"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Identity API endpoints</p>
			<p>Try invoking the <code>/register</code> API and create a new user passing two values. With a success, HTTP status code <code>200</code> is returned with an empty HTTP body if you didn’t create a custom implementation of the <code>IEmailSender</code> interface. If this is the case, you can use the MySQL admin UI to approve the user (or change the ASP.NET Core Identity configuration so that it doesn’t require confirmed accounts) before logging in; otherwise, login will be denied.</p>
			<p>With a successful login, Bearer tokens are returned. You receive access and refresh tokens and <a id="_idIndexMarker750"/>expiration information <a id="_idIndexMarker751"/>that is set to 3,600 seconds by default. The refresh token can be used with the <code>/refresh</code> API to get new access and refresh tokens.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To learn how <a id="_idIndexMarker752"/>to use SendGrid to implement <code>IemailSender</code>, take a look at the following article: <a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/accconfirm">https://learn.microsoft.com/en-us/aspnet/core/security/authentication/accconfirm</a>.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor236"/>Summary</h1>
			<p>In this chapter, you learned how to authenticate users with Azure AD B2C using Microsoft Identities and ASP.NET Core Identity. With Azure AD B2C, you added custom user attributes, specified user flows, and registered applications.</p>
			<p>Instead of implementing protection with every API, you created a reverse proxy using Microsoft YARP and protected the APIs with a gateway service. Using YARP, we defined routes to map different backend services and configured policies with routes to require authenticated clients.</p>
			<p>You also learned to use ASP.NET Core Identity as an alternative option for authentication and authorization with built-in ASP.NET Core functionality but a simpler feature set.</p>
			<p>The next chapter covers how to test microservices solutions, from unit tests to integration tests, including testing services with Microsoft Playwright.</p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor237"/>Further reading</h1>
			<p>To learn more about the topics that were discussed in this chapter, please refer to the following links:</p>
			<ul>
				<li><em class="italic">Azure AD B2C Claims </em><em class="italic">Schema</em>: <a href="https://learn.microsoft.com/en-us/azure/active-directory-b2c/claimsschema">https://learn.microsoft.com/en-us/azure/active-directory-b2c/claimsschema</a></li>
				<li><em class="italic">Enrich tokens with claims from external sources using API </em><em class="italic">connectors</em>: <a href="https://learn.microsoft.com/en-us/azure/active-directory-b2c/add-api-connector-token-enrichment">https://learn.microsoft.com/en-us/azure/active-directory-b2c/add-api-connector-token-enrichment</a></li>
				<li><em class="italic">ASP.NET Core </em><em class="italic">Middleware</em>: <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware</a></li>
				<li><em class="italic">How to use Identity to secure a Web API backend for </em><em class="italic">SPAs</em>: <a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity-api-authorization">https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity-api-authorization</a></li>
				<li><em class="italic">GitHub repository for </em><em class="italic">YARP</em>: <a href="https://github.com/microsoft/reverse-proxy">https://github.com/microsoft/reverse-proxy</a></li>
				<li><em class="italic">Securing a Blazor WASM app with Azure AD </em><em class="italic">B2C</em>: <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/hosted-with-azure-active-directory-b2c">https://learn.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/hosted-with-azure-active-directory-b2c</a></li>
				<li><em class="italic">Securing a WPF desktop app with Aure AD </em><em class="italic">B2C</em>: <a href="https://learn.microsoft.com/en-us/azure/active-directory-b2c/configure-authentication-sample-wpf-desktop-app">https://learn.microsoft.com/en-us/azure/active-directory-b2c/configure-authentication-sample-wpf-desktop-app</a></li>
				<li><em class="italic">Choosing an identity management </em><em class="italic">solution</em>: <a href="https://learn.microsoft.com/en-us/aspnet/core/security/how-to-choose-identity-solution">https://learn.microsoft.com/en-us/aspnet/core/security/how-to-choose-identity-solution</a></li>
				<li><em class="italic">Azure API </em><em class="italic">Management</em>: <a href="https://learn.microsoft.com/en-us/azure/api-management/">https://learn.microsoft.com/en-us/azure/api-management/</a></li>
			</ul>
		</div>
	

		<div><h1 id="_idParaDest-239" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor238"/>Part 3: Troubleshooting and Scaling</h1>
			<p>In this part, the focus shifts towards ensuring the smooth operation of the application and promptly addressing any emerging issues. Emphasis is placed on early issue detection through unit testing. You will delve into creating integration tests using .NET Aspire libraries and implementing end-to-end testing with Microsoft Playwright. The importance of logs, metrics, and distributed tracing, facilitated by Open Telemetry and supported by .NET Aspire, will be explored. Monitoring service interactions, performance metrics, memory consumption, and more during development will be facilitated by the .NET Aspire dashboard. Within the Azure environment, Azure Log Analytics and Application Insights will be utilized, alongside alternative options like <strong class="bold">Prometheus</strong> and <strong class="bold">Grafana</strong> that can be deployed in both on-premises and cloud environments. When scaling services, insights gained from previous chapters will be leveraged, with caution advised when using Azure Load Testing to prevent exceeding budget limits. Before scaling up and out, potential performance enhancements will be identified and implemented.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B21217_10.xhtml#_idTextAnchor239"><em class="italic">Chapter 10</em></a>, <em class="italic">All about Testing the Solution</em></li>
				<li><a href="B21217_11.xhtml#_idTextAnchor263"><em class="italic">Chapter 11</em></a>, <em class="italic">Logging and Monitoring</em></li>
				<li><a href="B21217_12.xhtml#_idTextAnchor294"><em class="italic">Chapter 12</em></a><em class="italic">, Scaling Services</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>