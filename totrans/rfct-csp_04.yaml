- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Refactoring at the Method Level
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法级别的重构
- en: In the last chapter, we covered improving individual lines of code. We’ll expand
    on those lessons to cover refactoring entire methods and solving issues with how
    code comes together to form larger methods that then interact with each other.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了改进单个代码行的内容。我们将在此基础上扩展这些课程，涵盖重构整个方法和解决代码如何组合形成更大方法的问题，这些方法随后相互交互。
- en: 'We saw a little of this in [*Chapter 2*](B21324_02.xhtml#_idTextAnchor026)
    when we covered the extract method refactoring. However, in this chapter, we’ll
    expand our set of tools covering the basics of refactoring methods and then move
    into more advanced areas as we cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第 2 章*](B21324_02.xhtml#_idTextAnchor026) 中介绍提取方法重构时已经看到了一些这方面的内容。然而，在本章中，我们将扩展我们的工具集，涵盖重构方法的基础知识，然后在我们介绍以下主要主题时进入更高级的领域：
- en: Refactoring the flight tracker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构航班跟踪器
- en: Refactoring methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构方法
- en: Refactoring constructors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构构造函数
- en: Refactoring parameters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构参数
- en: Refactoring to functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构为函数
- en: Introducing static methods and extension methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入静态方法和扩展方法
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter04/Ch4BeginningCode` folder.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起始代码可在 GitHub 的 [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    中的 `Chapter04/Ch4BeginningCode` 文件夹中找到。
- en: Refactoring the flight tracker
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构航班跟踪器
- en: 'This chapter’s code focuses largely on a single `FlightTracker` class intended
    to track and display the outgoing flights from a commercial airport for passengers
    in the terminal, as pictured in *Figure 4**.1*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码主要关注一个 `FlightTracker` 类，旨在跟踪和显示商业机场为候机楼乘客提供的出发航班，如图 *图 4.1* 所示：
- en: '![Figure 4.1 – FlightTracker displaying outbound flight statuses](img/B21324_04_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – FlightTracker 显示出发航班状态](img/B21324_04_01.jpg)'
- en: Figure 4.1 – FlightTracker displaying outbound flight statuses
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – FlightTracker 显示出发航班状态
- en: 'The `FlightTracker` class has a number of methods related to managing and displaying
    flights. It is supported by the `Flight` class which represents an individual
    flight in the system and the `FlightStatus` `enum` which represents all relevant
    statuses of a flight, as shown in the class diagram in *Figure 4**.2*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlightTracker` 类包含许多与管理和显示航班相关的方法。它由表示系统中单个航班的 `Flight` 类和支持表示航班所有相关状态的 `FlightStatus`
    枚举类支持，如图 *图 4.2* 所示：'
- en: '![Figure 4.2 – A class diagram showing FlightTracker and supporting classes](img/B21324_04_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 展示 FlightTracker 和支持类的类图](img/B21324_04_02.jpg)'
- en: Figure 4.2 – A class diagram showing FlightTracker and supporting classes
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 展示 FlightTracker 和支持类的类图
- en: 'We’ll explore these pieces of code throughout this chapter, but for now, we
    need to understand that the key responsibilities of `FlightTracker` include the
    following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中探讨这些代码片段，但就目前而言，我们需要了解 `FlightTracker` 的关键职责包括以下内容：
- en: Tracking a list of flights
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪航班列表
- en: Scheduling new flights (adding them to the list)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排新的航班（将其添加到列表中）
- en: Marking flights as arrived, departed, or delayed
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记航班为到达、出发或延误
- en: Displaying all flights
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有航班
- en: Finding a flight by its ID
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过航班 ID 查找航班
- en: This is a fairly simple flight tracker class, but we’ll see a slightly more
    complicated version of one in the next chapter as we explore object-oriented refactoring.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的航班跟踪器类，但我们在下一章中将会看到一个稍微复杂一点的版本，届时我们将探讨面向对象的重构。
- en: For now, let’s look at a few simple steps we can take to improve these methods.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们可以采取的一些简单步骤来改进这些方法。
- en: Refactoring methods
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构方法
- en: In this section, we’ll explore a number of refactorings related to methods and
    their interactions. We’ll start by discussing the access modifier of a method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨与方法和它们交互相关的一系列重构。我们将从讨论方法访问修饰符开始。
- en: Changing method access modifiers
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改方法访问修饰符
- en: 'During my time as a professional C# instructor, I noticed my students often
    tended to not think about the **access modifiers** they used in their code. Specifically,
    my students would usually do one of two things:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我担任专业 C# 教练的时间里，我注意到我的学生往往不太考虑他们在代码中使用的 **访问修饰符**。具体来说，我的学生通常会做以下两件事之一：
- en: They marked all methods as **public** by default unless someone (usually me)
    suggested they use a different access modifier
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们默认将所有方法标记为 **public**，除非有人（通常是本人）建议他们使用不同的访问修饰符
- en: They marked all methods as **private** by default (or omitted the access modifier
    entirely, defaulting to **private** anyway) until the compiler gave them an issue
    requiring them to make a method more accessible
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们默认将所有方法标记为 **private**（或者完全省略访问修饰符，默认为 **private**），直到编译器给出问题，要求他们使方法更易于访问
- en: 'Both approaches are insufficient for a simple reason: we want to explicitly
    declare the visibility level of our methods. This way, whenever you read code,
    you are reminded explicitly by the access modifier what other code can access
    the code you’re working with. This is particularly useful when working with non-private
    methods that can be referenced outside of the class.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都不足以简单的原因：我们希望明确声明我们方法的可见级别。这样，每次阅读代码时，你都会通过访问修饰符明确地提醒你其他代码可以访问你正在处理的代码。这在处理可以在类外引用的非私有方法时尤其有用。
- en: Access modifiers
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: C# has several access modifiers as of C# 12 that govern what other areas can
    refer to your code. The current access modifiers are `public`, `private`, `protected`,
    `internal`, `protected internal`, `private internal`, and the new `file` access
    modifier that restricts access to something within a single source file. While
    these access modifiers all have their uses, I’m going to focus primarily on `public`
    and `private` in this section for simplicity’s sake.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 C# 12，C# 有几个访问修饰符来控制其他区域可以引用你的代码。当前的访问修饰符有 `public`、`private`、`protected`、`internal`、`protected
    internal`、`private internal` 以及新的 `file` 访问修饰符，该修饰符限制了对单个源文件内某物的访问。虽然这些访问修饰符都有其用途，但为了简单起见，我将主要关注本节中的
    `public` 和 `private`。
- en: If we mark a method as **public**, **protected**, or **internal**, there should
    be a good reason for that – typically related to the method being a primary way
    in which we intend for others to use our code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将方法标记为 **public**、**protected** 或 **internal**，那么应该有很好的理由——通常与该方法是我们打算让他人使用我们代码的主要方式有关。
- en: 'Our `FlightTracker` class has a `public` method called `FindFlightById` that
    is used by most of the other methods in the class but nothing outside of the class.
    This method looks up the flight by `ID` and returns it if one is found:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `FlightTracker` 类有一个名为 `FindFlightById` 的 `public` 方法，该方法被类中的大多数其他方法使用，但类外部的任何地方都没有使用。此方法通过
    `ID` 查找航班，如果找到则返回：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Given these circumstances, you might make an explicit decision to mark the
    method as `private`, restricting its usage within this class, as shown in the
    following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能会明确决定将方法标记为 `private`，限制其在类内的使用，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By marking this method as `private`, you have greater freedom in the future
    to rename it, change how it works, modify its parameters, or remove it entirely.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此方法标记为 `private`，你将来在重命名它、更改其工作方式、修改其参数或完全删除它时拥有更大的自由度。
- en: Changing the access modifier is generally safe if nothing outside the class
    uses the method. Otherwise, this decision will cause compiler errors.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类外没有使用该方法，更改访问修饰符通常是安全的。否则，此决定将导致编译器错误。
- en: Renaming methods and parameters
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重命名方法和参数
- en: 'Let’s take a look at three very similar methods for managing flights in `FlightTracker`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `FlightTracker` 中用于管理航班的三个非常相似的方法：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each of these methods takes in a `DateTime` and a flight identifier string.
    However, the naming of these parameters and even these methods are not incredibly
    consistent.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法都接受一个 `DateTime` 和一个航班标识符字符串。然而，这些参数的命名以及这些方法本身并不非常一致。
- en: '`DelayFlight` calls its flight ID variable `fId` and its new departure time
    `newTime`. `MarkFlightArrived` uses `time` for the arrival time and `id` for the
    flight identifier. `MarkFlightDeparted` uses `id` but chose `t` to denote the
    departure time.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelayFlight` 调用其航班ID变量为 `fId`，以及新的出发时间为 `newTime`。`MarkFlightArrived` 使用 `time`
    表示到达时间，而使用 `id` 表示航班标识符。`MarkFlightDeparted` 使用 `id`，但选择了 `t` 来表示出发时间。'
- en: While some of these naming choices are better than others on their own, the
    lack of naming consistency in methods within the same class can hurt other people’s
    ability to work effectively with your code. This can lead them to feel less confident
    in your abilities and can even introduce bugs from misunderstandings of what parameters
    or methods represent – all due to a lack of consistency.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些命名选择中的一些比其他的好，但同一类方法中命名的不一致性可能会损害其他人有效使用你的代码的能力。这可能会让他们对你的能力感到不那么自信，甚至可能因为对参数或方法代表的内容理解错误而引入错误
    – 所有这些都归因于缺乏一致性。
- en: 'To fix this, we can use the *rename parameter* refactoring to rename individual
    parameters to ensure consistency. This can be done by right-clicking on a parameter
    and selecting **Rename…** from the context menu, or pressing *Ctrl* + *R* twice
    with the parameter selected. See *Figure 4**.3*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用*重命名参数*重构来重命名单个参数以确保一致性。这可以通过右键单击一个参数并从上下文菜单中选择**重命名…**来完成，或者在选择参数时按*Ctrl*
    + *R*两次。参见*图4.3*：
- en: '![Figure 4.3 – Activating the rename parameter refactoring via the context
    menu](img/B21324_04_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 通过上下文菜单激活重命名参数重构](img/B21324_04_03.jpg)'
- en: Figure 4.3 – Activating the rename parameter refactoring via the context menu
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 通过上下文菜单激活重命名参数重构
- en: 'Next, type the new name you want to use for the parameter and press *Enter*
    to complete the change. See *Figure 4**.4*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入你想要使用的参数的新名称，然后按*Enter*键完成更改。参见*图4.4*：
- en: '![Figure 4.4 – Renaming the parameter](img/B21324_04_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 重命名参数](img/B21324_04_04.jpg)'
- en: Figure 4.4 – Renaming the parameter
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 重命名参数
- en: While choosing your names, you’ll want to pick something that is clear and consistent
    with the terminology and names you use in your class already. Avoid very short
    and single-letter parameters wherever possible (excluding some cases, such as
    `x` and `y` for coordinates or other established usages of short parameter names).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择名称时，你希望选择一些清晰且与你在类中已经使用的术语和名称一致的东西。尽可能避免使用非常短的单字母参数（排除一些情况，例如坐标的`x`和`y`或其他短参数名的既定用法）。
- en: In the case of this code, I chose to rename all the flight identifiers to `id`
    and chose to be more explicit about the names of the `DateTime` parameters to
    indicate what the parameter represented.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码的例子中，我选择将所有航班标识符重命名为`id`，并选择更明确地命名`DateTime`参数，以表明参数代表的内容。
- en: 'I also chose to use the same rename tool to rename the entire method of `DelayFlight`
    to `MarkFlightDelayed` to be more consistent with the other methods in this class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我还选择使用相同的重命名工具来重命名整个`DelayFlight`方法为`MarkFlightDelayed`，以便与其他类中的方法保持一致性：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Some of these names are perhaps a bit longer than I might like (particularly
    when trying to fit code onto a page in a book!), but clear parameter and method
    names can save a lot of confusion and even prevent certain bugs from occurring
    later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称中的一些可能比我想要的要长一些（尤其是在尝试将代码放入一本书的页面时！），但清晰的参数和方法名称可以节省很多困惑，甚至可以防止以后发生某些错误。
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the inconsistent ordering of parameters annoys you, don’t worry. We’ll fix
    parameter ordering later on in this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数顺序的不一致让你感到烦恼，不用担心。我们将在本章后面修复参数顺序。
- en: Overloading methods
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载方法
- en: Let’s shift gears and talk about how methods can work together in tandem. First,
    we’ll look at an example of **overloading** and then an example of **chaining**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转换一下话题，谈谈方法如何协同工作。首先，我们将看看一个**重载**的例子，然后是一个**链式调用**的例子。
- en: 'Let’s start by looking at the `ScheduleNewFlight` method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看`ScheduleNewFlight`方法：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method takes in four parameters representing flight information. It uses
    them to instantiate a `Flight` object, adds the flight to the private list of
    flights, and then returns the newly-created `Flight` object.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受四个代表航班信息的参数。它使用它们来实例化一个`Flight`对象，将航班添加到私有航班列表中，然后返回新创建的`Flight`对象。
- en: As the system grows, it’s reasonable to expect that someone might want to provide
    their own `Flight` object. To accommodate that, you can overload the `ScheduleNewFlight`
    method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的增长，合理地预期有人可能想要提供自己的`Flight`对象。为了适应这一点，你可以重载`ScheduleNewFlight`方法。
- en: Overloading
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重载
- en: Overloading is where you offer a method with the same name as another method
    but a different set of types of parameters that can be accepted by the method.
    For example, you can have a method that takes in an `int` and another method that
    takes in two `strings`, but you can’t have two methods that both take in only
    a single `int`, even if the parameter names are different. From the compiler’s
    perspective, overloaded methods are entirely separate methods that just happen
    to have the same name.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重载是在提供与另一个方法相同名称的方法，但具有不同参数类型集的方法。例如，你可以有一个接受 `int` 类型的参数的方法，另一个接受两个 `string`
    类型的参数的方法，但你不能有两个都只接受单个 `int` 参数的方法，即使参数名称不同。从编译器的角度来看，重载方法是完全独立的方法，只是恰好具有相同的名称。
- en: 'The overloaded `ScheduleNewFlight` method that takes in a `Flight` object might
    look something like the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接受 `Flight` 对象的重载 `ScheduleNewFlight` 方法可能看起来像以下这样：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Overloading the `ScheduleNewFlight` method is helpful because it helps people
    discover the different options for scheduling a flight based on Visual Studio’s
    suggestions, as shown in *Figure 4**.5*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重载 `ScheduleNewFlight` 方法是有帮助的，因为它有助于人们发现基于 Visual Studio 的建议进行航班安排的不同选项，如图
    *图 4.5* 所示：
- en: '![Figure 4.5 – Visual Studio suggestions showing available overloads for ScheduleNewFlight](img/B21324_04_05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – Visual Studio 建议显示 ScheduleNewFlight 可用的重载](img/B21324_04_05.jpg)'
- en: Figure 4.5 – Visual Studio suggestions showing available overloads for ScheduleNewFlight
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – Visual Studio 建议显示 ScheduleNewFlight 可用的重载
- en: By providing overloads, following standard conventions, and having consistent
    and predictable methods and parameters, you help others discover how to use your
    classes safely and effectively.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供重载、遵循标准约定、保持方法和参数的一致性和可预测性，你帮助他人发现如何安全有效地使用你的类。
- en: Chaining methods
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法链式调用
- en: 'You may have noticed a few lines of duplication between our two `ScheduleNewFlight`
    overloads. Let’s take a look at them side by side for reference:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了我们两个 `ScheduleNewFlight` 重载之间的一些重复行。让我们并排查看它们以供参考：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While this duplication is very minimal, I could see new requirements come in
    that would necessitate changing both places. For example, the business might require
    that whenever a new flight is scheduled, a log entry should be written, or perhaps
    a new `LastScheduleChange` property needs to be set to the current time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种重复非常微小，但我可以预见会有新的需求出现，这需要改变这两个地方。例如，业务可能要求每次安排新的航班时，都应该写入日志条目，或者可能需要将新的
    `LastScheduleChange` 属性设置为当前时间。
- en: When these types of changes occur, developers run the risk of introducing bugs
    unless they change all the affected areas. This means that code duplication, even
    minor code duplication such as this example, leads to additional work and additional
    sources of bugs if not every place with similar logic is updated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些类型的更改发生时，如果开发者没有更改所有受影响的区域，他们就有引入错误的风险。这意味着代码重复，即使是像这个例子中这样的微小代码重复，如果没有更新所有具有类似逻辑的地方，会导致额外的工作和额外的错误来源。
- en: One thing that can help with this is **method chaining**. Method chaining is
    when one method calls another related method and has it accomplish its work for
    it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于这一点的是 **方法链式调用**。方法链式调用是指一个方法调用另一个相关方法，并让它为自己完成工作。
- en: 'In this case, we can modify our first `ScheduleNewFlight` method to be responsible
    for creating a `Flight` object and then handing off that object to the other `ScheduleNewFlight`
    overload, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以修改我们的第一个 `ScheduleNewFlight` 方法，使其负责创建一个 `Flight` 对象，然后将该对象传递给其他
    `ScheduleNewFlight` 重载，如下所示：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Not only is this less code, but if we ever need to alter what happens when a
    new flight is scheduled, we now only have one place to modify.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅代码更少，而且如果我们需要更改安排新航班时发生的事情，我们现在只需要修改一个地方。
- en: Now that we’ve covered some of the basics of refactoring methods, let’s look
    briefly at some parallels with **constructors**. After all, constructors are essentially
    a special type of method that gets called when an object is instantiated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些方法重构的基础知识，让我们简要地看看与 **构造函数** 的相似之处。毕竟，构造函数本质上是一种特殊的方法，当对象被实例化时会被调用。
- en: Refactoring constructors
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构构造函数
- en: When you think about the job of a constructor, its whole reason for being is
    to get the object into its correct initial position. Once the constructor completes,
    the object is generally considered ready for use by other code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑构造函数的工作时，其存在的全部原因就是将对象置于正确的初始位置。一旦构造函数完成，对象通常被认为可以供其他代码使用。
- en: This means that constructors can be very handy for ensuring that certain pieces
    of information are in place.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着构造函数可以非常方便地确保某些信息已就绪。
- en: 'Right now, our `Flight` class is defined fairly minimally and only has the
    default constructor that .NET provides in the absence of any explicit constructor:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的 `Flight` 类定义得相当简单，并且只有 .NET 在没有显式构造函数的情况下提供的默认构造函数：
- en: Flight.cs
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Flight.cs
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The problem with our `Flight` class lacking any explicit constructor is that
    flights don’t make sense without some of these pieces of information.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `Flight` 类缺少任何显式构造函数的问题在于，没有这些信息之一，航班就没有意义。
- en: While more recent versions of C# have given us things such as the `required`
    keyword, which we’ll explore in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209),
    the classic approach to requiring some piece of information at object creation
    has been to make the constructor take it in as a parameter. To demonstrate this,
    let’s add a parameterized constructor next.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然较新的 C# 版本已经为我们提供了诸如 `required` 关键字之类的功能，我们将在 [*第 10 章*](B21324_10.xhtml#_idTextAnchor209)
    中探讨，但要求在对象创建时提供某些信息的经典方法是将构造函数作为参数接收。为了演示这一点，让我们添加一个参数化构造函数。
- en: Generating constructors
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成构造函数
- en: While we could manually write a constructor, Visual Studio gives us some great
    code generation tools, including a *generate* *constructor* refactoring.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以手动编写构造函数，但 Visual Studio 提供了一些优秀的代码生成工具，包括一个 *生成* *构造函数* 重构功能。
- en: 'To use this refactoring, select the class and open the **Quick Actions** menu.
    Then, select **Generate constructor…**, as shown in *Figure 4**.6*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此重构功能，请选择类并打开 **快速操作** 菜单。然后，选择 **生成构造函数…**，如图 *图 4**.6* 所示：
- en: '![Figure 4.6 – Generating a constructor](img/B21324_04_06.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 生成构造函数](img/B21324_04_06.jpg)'
- en: Figure 4.6 – Generating a constructor
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 生成构造函数
- en: 'This will open a dialog that will allow you to select what members get initialized
    from the constructor when creating a `Flight`, as shown in *Figure 4**.7*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个对话框，允许你选择在创建 `Flight` 时从构造函数初始化哪些成员，如图 *图 4**.7* 所示：
- en: '![Figure 4.7 – Selecting required members for the constructor](img/B21324_04_07.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 为构造函数选择所需的成员](img/B21324_04_07.jpg)'
- en: Figure 4.7 – Selecting required members for the constructor
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 为构造函数选择所需的成员
- en: In this case, I chose to make `Id`, `Destination`, and `DepartureTime` part
    of the constructor and left the others unchecked. I also unchecked the **Add null
    checks** checkbox to prevent the generated code from being too complex for this
    example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我选择将 `Id`、`Destination` 和 `DepartureTime` 作为构造函数的一部分，并留出其他选项未选中。我还取消选中了
    **添加空检查** 复选框，以防止生成的代码对于这个示例来说过于复杂。
- en: 'This generated the following constructor:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了以下构造函数：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The resulting code correctly sets the required properties based on its parameters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码根据其参数正确地设置了所需的属性。
- en: If you wanted to, you could go back in and generate a new constructor with a
    different set of parameters, since classes can have any number of overloaded constructors.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以返回并生成一个具有不同参数集的新构造函数，因为类可以有任意数量的重载构造函数。
- en: 'In fact, we’ll add another constructor in the next section to illustrate this.
    However, for now, we have a problem we need to resolve in the form of a build
    error:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们将在下一节中添加另一个构造函数来演示这一点。然而，目前我们遇到了一个需要解决的问题，表现为构建错误：
- en: '![Figure 4.8 – Build error trying to instantiate a Flight instance](img/B21324_04_08.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 尝试实例化一个 Flight 实例时的构建错误](img/B21324_04_08.jpg)'
- en: Figure 4.8 – Build error trying to instantiate a Flight instance
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 尝试实例化一个 Flight 实例时的构建错误
- en: If you tried to build your project after adding the `Flight` constructor, you’ll
    see an error similar to that shown in *Figure 4**.8*. This “no argument given
    that corresponds to the required parameter” error exists because the `Flight flight
    = new()` code in `ScheduleNewFlight` is trying to invoke the default constructor
    for `Flight`, but that constructor no longer exists.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在添加 `Flight` 构造函数后尝试构建你的项目，你会看到一个类似于 *图 4**.8* 中显示的错误。这个“没有给出与所需参数对应的参数”错误存在是因为
    `ScheduleNewFlight` 中的 `Flight flight = new()` 代码试图调用 `Flight` 的默认构造函数，但该构造函数已不再存在。
- en: When we added our constructor a moment ago, this didn’t move the `Flight` class
    from having no constructors to one constructor. Instead, we went from having .NET’s
    default constructor with no parameters to one constructor with the new parameters
    we generated, removing the default constructor entirely.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们刚才添加构造函数时，这并没有将 `Flight` 类从没有构造函数的状态转变为只有一个构造函数。相反，我们是从拥有没有任何参数的 .NET 默认构造函数转变为拥有我们生成的新参数的一个构造函数，完全移除了默认构造函数。
- en: 'We can add the default constructor back manually by explicitly defining it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过显式定义来手动添加默认构造函数：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This constructor does nothing aside from allowing others to instantiate the
    class by providing no parameters to the constructor. As soon as you declare your
    own constructor, .NET no longer provides the default constructor for you.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数除了允许通过不向构造函数提供任何参数来实例化类之外，不做任何事情。一旦你声明了自己的构造函数，.NET 就不再为你提供默认构造函数。
- en: To fix this compiler error, we can either add a new constructor that takes in
    no parameters or we can adjust the `ScheduleNewFlight` code to use our new constructor
    instead of the default one that no longer exists.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个编译器错误，我们可以添加一个不带参数的新构造函数，或者我们可以调整 `ScheduleNewFlight` 代码以使用我们新的构造函数而不是不再存在的默认构造函数。
- en: 'Since part of the intent of adding a new constructor is to require certain
    pieces of information at the time of object creation, it makes more sense to change
    `ScheduleNewFlight` to use the new constructor, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于添加新构造函数的部分意图是在对象创建时要求某些信息，因此将 `ScheduleNewFlight` 改为使用新构造函数更有意义，如下所示：
- en: FlightTracker.cs
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: FlightTracker.cs
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A nice side effect of doing this is that we no longer need to set those properties
    in the object initializer since the constructor does that for us.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的副作用之一是，我们不再需要在对象初始化器中设置那些属性，因为构造函数会为我们完成这个工作。
- en: Chaining constructors
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链式连接构造函数
- en: Earlier, we saw how we can chain together overloaded methods to work together
    to reduce code duplication. I also hinted that constructors are really just special
    methods. When you have multiple constructors, they act exactly like overloaded
    methods.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何通过链式调用重载的方法来共同工作，以减少代码重复。我还暗示构造函数实际上只是特殊的方法。当你有多个构造函数时，它们的行为就像重载方法一样。
- en: We can put all of these concepts together by **chaining constructors** together,
    so one constructor calls to the other.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将所有这些概念结合起来，通过**链式连接构造函数**，所以一个构造函数调用另一个构造函数。
- en: 'First, let’s look at an example of *not* doing this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看一个**不**这样做的情况的例子：
- en: Flight.cs
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Flight.cs
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we have two constructors for `Flight` that are nearly identical, except
    the second one also accepts a `status` parameter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有 `Flight` 的两个构造函数，它们几乎完全相同，除了第二个构造函数还接受一个 `status` 参数。
- en: 'While this isn’t an excessive amount of duplication, it can be avoided by chaining
    constructors together with `: this()` syntax, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然这并不是大量的重复，但可以通过使用 `: this()` 语法链式连接构造函数来避免，如下所示：'
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this case, the second `Flight` constructor starts out by calling the first
    constructor through its use of `: this`. Once that call completes, control will
    move back to the second constructor and it will execute the `Status =` `status;`
    line.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，第二个 `Flight` 构造函数首先通过使用 `: this` 调用第一个构造函数。一旦这个调用完成，控制权将返回到第二个构造函数，并执行
    `Status = status;` 这一行。'
- en: Chaining constructors together adds a little complexity to your code, but it
    also reduces duplicated code while making it such that you can add new initialization
    logic in one place and multiple constructors can take advantage of the addition.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 链式连接构造函数会给你的代码增加一点复杂性，但同时也减少了重复代码，使得你可以在一个地方添加新的初始化逻辑，而多个构造函数都可以利用这个添加。
- en: Refactoring parameters
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构参数
- en: Now that we’ve explored the basics of methods and constructors, let’s talk about
    managing parameters. This is important because it is possible that poorly thought-out
    parameters can quickly reduce the maintainability of your code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了方法和构造函数的基础知识，让我们谈谈管理参数。这很重要，因为思考不周的参数可能会迅速降低你代码的可维护性。
- en: Let’s look at a few common refactorings you’ll want to perform over the life
    of your methods.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你会在方法的生命周期中想要执行的一些常见重构。
- en: Reordering parameters
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新排序参数
- en: Sometimes, you’ll realize that the order of parameters in a method doesn’t make
    as much sense as another arrangement might. At other times, you might notice that
    a few of your methods take in the same kinds of parameters, but with inconsistent
    ordering. In either case, you’ll find yourself wanting to reorder your method
    parameters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会意识到方法中参数的顺序可能不如另一种排列合理。在其他时候，你可能会注意到一些方法接受相同类型的参数，但顺序不一致。在任何情况下，你都会发现自己想要重新排列方法参数。
- en: 'Let’s look at a practical example from the various `MarkX` methods we saw earlier:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前看到的 `MarkX` 方法中的一个实际例子：
- en: FlightTracker.cs
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: FlightTracker.cs
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we have three methods that all take in `string` and `DateTime` parameters,
    but their ordering is inconsistent.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有三个方法，它们都接受 `string` 和 `DateTime` 参数，但它们的顺序不一致。
- en: In this case, looking at these three methods, you decide that the most intuitive
    order is to put the flight ID first and then the time component as the second
    parameter. This means that `MarkFlightDelayed` and `MarkFlightDeparted` are correct
    but `MarkFlightArrived` needs to be adjusted.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，查看这三个方法，你决定最直观的顺序是将航班 ID 放在第一位，然后是时间组件作为第二个参数。这意味着 `MarkFlightDelayed`
    和 `MarkFlightDeparted` 是正确的，但 `MarkFlightArrived` 需要调整。
- en: 'You can add, remove, and reorder parameters from the same refactoring dialog
    in Visual Studio by selecting the method you want to refactor and then choosing
    **Change signature…** from the **Quick Actions** menu, as shown in *Figure 4**.9*:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过选择要重构的方法，然后从**快速操作**菜单中选择**更改签名…**，在 Visual Studio 的相同重构对话框中添加、删除和重新排列参数，如图
    *图 4.9* 所示：
- en: '![Figure 4.9 – Triggering the Change signature… refactoring](img/B21324_04_09.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 触发更改签名…重构](img/B21324_04_09.jpg)'
- en: Figure 4.9 – Triggering the Change signature… refactoring
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 触发更改签名…重构
- en: 'This will bring up the **Change Signature** dialog (see *Figure 4**.10*) and
    allow you to use the up and down buttons in the upper right to reorder parameters
    until the order in the preview matches your expectations:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将弹出**更改签名**对话框（见 *图 4.10*），并允许你使用右上角的上下按钮重新排列参数，直到预览中的顺序符合你的预期：
- en: '![Figure 4.10 – Reordering parameters in the Change Signature dialog](img/B21324_04_10.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 在更改签名对话框中重新排列参数](img/B21324_04_10.jpg)'
- en: Figure 4.10 – Reordering parameters in the Change Signature dialog
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 在更改签名对话框中重新排列参数
- en: Once you are done, click **OK** and Visual Studio will update your method as
    well as everything that was called out to that method to use the revised parameter
    order.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，点击**确定**，Visual Studio 将更新你的方法以及所有调用该方法的内容，以使用修订后的参数顺序。
- en: Tip
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are other ways of making which parameters a method requires more explicit
    using C#. One such way would be to use the **named arguments** feature of C# that
    allows you to specify method parameters by name followed by a colon, making the
    parameter usage explicit.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C# 有其他方法可以使方法所需的参数更加明确，其中一种方法就是使用 C# 的**命名参数**功能，允许你通过冒号后跟参数名来指定方法参数，从而使参数使用更加明确。
- en: An example of using this to call our `MarkFlightArrived` method would be `MarkFlightArrived(arrivalTime:DateTime.Now,
    id:"MyId")`. Note that when using named arguments, you can specify arguments in
    whatever order you prefer. See the *Further reading* section for more details.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法调用我们的 `MarkFlightArrived` 方法的例子将是 `MarkFlightArrived(arrivalTime:DateTime.Now,
    id:"MyId")`。注意，当使用命名参数时，你可以按你喜欢的任何顺序指定参数。有关更多详细信息，请参阅 *进一步阅读* 部分。
- en: Adding parameters
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加参数
- en: 'Occasionally, you’ll want to add a new parameter to your method. The most natural
    thing to do is generally to add the parameter to the end of the list of parameters.
    This, however, can have two downsides:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想给你的方法添加一个新参数。最自然的事情通常是将其添加到参数列表的末尾。然而，这有两个缺点：
- en: The new parameter might not make the most sense when added to the end of the
    list instead of earlier on in the sequence of parameters
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新参数如果添加到列表的末尾而不是参数序列的早期，可能不太合理
- en: Manually adding a parameter means you must now manually adjust anything that
    was calling your method and provide a new value for the parameter
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动添加参数意味着你现在必须手动调整所有调用你的方法的内容，并为参数提供一个新值
- en: Let’s look at a practical example and see how the **Change Signature** dialog
    can help.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际例子，看看**更改签名**对话框如何有所帮助。
- en: 'The `MarkFlightArrived` method currently finds the flight by its `Id` and then
    updates its arrival time and status to match the parameters:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarkFlightArrived` 方法目前通过 `Id` 查找航班，然后更新其到达时间和状态以匹配参数：'
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s say we need to update this method to take in the gate that the plane should
    taxi to. While we could manually add it to the end of the parameter list, this
    would break every method that calls out to this method.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要更新这个方法，以便它能够接收飞机应该滑行到的航站楼。虽然我们可以手动将其添加到参数列表的末尾，但这会破坏所有调用此方法的函数。
- en: Right now, that’s not a lot of places, since only the tests are calling this
    method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这并不是很多地方，因为只有测试在调用这个方法。
- en: FlightTrackerTests.cs
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: FlightTrackerTests.cs
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, the *Change Signature* refactoring tools in Visual Studio provide
    a safer option when you click the **Add** button:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Visual Studio 中的**更改签名**重构工具在点击**添加**按钮时提供了一个更安全的选项：
- en: '![Figure 4.11 – Adding a new gate parameter to MarkFlightArrived](img/B21324_04_11.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 向 MarkFlightArrived 添加新的航站楼参数](img/B21324_04_11.jpg)'
- en: Figure 4.11 – Adding a new gate parameter to MarkFlightArrived
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 向 MarkFlightArrived 添加新的航站楼参数
- en: 'The **Add Parameter** dialog is one of the more complex ones in Visual Studio,
    but all it really needs is the following few things:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加参数**对话框是 Visual Studio 中较为复杂的对话框之一，但它实际上只需要以下几件事情：'
- en: The parameter name and type that is being added
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在被添加的参数名称和类型
- en: Whether this parameter is required or optional (more on this shortly)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否需要此参数（稍后将有更多介绍）
- en: The value to use in places that are already calling the method
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在已经调用该方法的地方使用该值
- en: In this case, our new parameter is going to be a `string` named `gate`. Callers
    must provide a value and any existing callers should use the `"A4"` string for
    now.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的新参数将是一个名为 `gate` 的 `string` 类型。调用者必须提供值，而现有的调用者现在应使用 `"A4"` 字符串。
- en: This use of `"A4"` may seem like a random string because it is. The only place
    using this method right now is a unit test where the gate really doesn’t matter
    for that test. If more places were using this method, I’d likely choose **Infer
    from context** or **Introduce undefined** **TODO variables**.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用 `"A4"` 的方法可能看起来像是一个随机的字符串，因为它确实是。目前唯一使用这种方法的地方是一个单元测试，在那个测试中航站楼实际上并不重要。如果更多的地方使用这种方法，我可能会选择**从上下文推断**或**引入未定义**的**TODO**变量。
- en: Clicking **OK** will display the *Change Signature* dialog again with your new
    parameter listed, allowing you to reorder it as needed. Clicking **OK** in this
    dialog will add the parameter to your method and update your code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**将再次显示**更改签名**对话框，其中列出了你的新参数，允许你按需重新排序。在此对话框中点击**确定**将添加参数到你的方法并更新你的代码。
- en: 'This updates your method signature for `MarkFlightArrived` and the test calling
    your code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新 `MarkFlightArrived` 方法的签名以及调用你的代码的测试：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the new parameter in place, you can update the `MarkFlightArrived` method
    to use it to set the flight’s `Gate` property:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在新参数就位后，你可以更新 `MarkFlightArrived` 方法以使用它来设置航班的 `Gate` 属性：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This workflow is a common one you’ll go through as you find yourself expanding
    methods to take in new parameters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现自己需要扩展方法以接受新参数时，这个工作流程是一个常见的流程。
- en: Next, let’s see some ways to simplify method calls using optional parameters.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一些使用可选参数简化方法调用的方法。
- en: Introducing optional parameters
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入可选参数
- en: If you’re not a fan of the **Change Signature** dialog and would rather write
    the code yourself, you can always take advantage of optional parameters to safely
    add new parameters to the end of your parameter list.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢**更改签名**对话框，而更愿意自己编写代码，你可以利用可选参数来安全地在参数列表末尾添加新的参数。
- en: With an optional parameter, you specify a default value. Places that call your
    method can either specify the value for this parameter or not pass any value at
    all. In cases where no value is passed, the default value will be used instead.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可选参数时，你指定一个默认值。调用你的方法的地方可以指定此参数的值，也可以不传递任何值。在没有传递值的情况下，将使用默认值。
- en: Note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This only works with parameters at the end of your parameter list due to how
    optional parameters work in C#. Additionally, the compiler doesn’t allow certain
    types of default values such as new objects and certain literals.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C# 中可选参数的工作方式，这仅适用于参数列表末尾的参数。此外，编译器不允许某些类型的默认值，例如新对象和某些字面量。
- en: 'If you wanted to declare `gate` as optional and default to `"TBD"` (short for
    “to be determined”), your method would look like the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将`gate`参数声明为可选并默认为`"TBD"`（代表“待定”），你的方法看起来会像下面这样：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The code calling your method could then be left in its prior state:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 调用你的方法的代码可以保持其先前的状态：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the code would compile, but “TBD” would be used for the gate.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码可以编译，但“TBD”将用于`gate`。
- en: 'Alternatively, you could specify the value for `gate` manually by providing
    a value for that parameter:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过为该参数提供一个值来手动指定`gate`的值：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Optional parameters can be particularly nice not just for expanding methods,
    but also for providing common defaults that callers can customize if they want.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数不仅可以用于扩展方法，还可以提供常见的默认值，调用者可以根据需要自定义。
- en: Removing parameters
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除参数
- en: 'Currently, the code requires you to specify the gate whenever a new flight
    is scheduled:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，代码要求你在安排新航班时指定航站楼：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let’s say that you decide that since gates are now assigned at arrival, you
    shouldn’t need to specify the `gate` when you schedule a new flight.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你决定，由于航站楼现在在到达时分配，你不需要在安排新航班时指定`gate`。
- en: While you could go in and just remove the `gate` parameter from the code, this
    won’t update any methods that are calling that method and will result in compiler
    errors you must resolve.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以直接从代码中移除`gate`参数，但这不会更新调用该方法的任何方法，并会导致你必须解决的编译错误。
- en: 'Instead, you can use the **Change Signature** dialog, select the parameter
    you want to remove, and click **Remove**, as shown in *Figure 4**.12*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以使用**更改签名**对话框，选择要删除的参数，然后点击**删除**，如图*图4.12*所示：
- en: '![Figure 4.12 – Removing the gate parameter from ScheduleNewFlight](img/B21324_04_12.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12 – 从ScheduleNewFlight中移除gate参数](img/B21324_04_12.jpg)'
- en: Figure 4.12 – Removing the gate parameter from ScheduleNewFlight
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – 从ScheduleNewFlight中移除gate参数
- en: When you click `gate` parameter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击`gate`参数时。
- en: Of course, this isn’t magic, and it will leave behind code that relied on that
    gate parameter or code that was put in place to get the value ready to pass into
    `ScheduleNewFlight`. Still, the refactoring does a remarkable job of cleaning
    up the method definition and the direct calls of that method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是魔法，它将留下依赖于该`gate`参数的代码或放置在准备传递给`ScheduleNewFlight`的值的代码。尽管如此，重构在清理方法定义和该方法的直接调用方面做得非常出色。
- en: 'Applying the refactoring to remove the `gate` parameter results in a simpler
    method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将重构应用于移除`gate`参数，结果是一个更简单的方法：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now that we’ve covered the basics of methods, constructors, and parameters,
    let’s get into the more adventuresome aspects of refactoring methods: working
    with functions.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了方法、构造函数和参数的基础知识，让我们深入了解重构方法的更具冒险性的方面：与函数一起工作。
- en: Refactoring to functions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构为函数
- en: In this section, we’ll explore some aspects of refactoring related to **functional
    programming**. Functional programming is an approach to programming that focuses
    on functions and their interactions instead of purely on objects and classes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨与**函数式编程**相关的重构方面。函数式编程是一种编程方法，它关注函数及其交互，而不是仅仅关注对象和类。
- en: Functional programming has become more popular over the last decade and that
    popularity has influenced the C# language with the addition of new forms of syntax.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程在过去十年中变得更加流行，这种流行趋势影响了C#语言，并添加了新的语法形式。
- en: We’ll explore a few of the syntactical improvements related to functional programming
    and see how they can help make concise and flexible programs. While this is not
    a book about functional programming, we’ll still find ourselves exploring a few
    of these concepts in this section and [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209),
    *Defensive* *Coding Techniques*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨与函数式编程相关的几个语法改进，并看看它们如何帮助编写简洁灵活的程序。虽然这不是一本关于函数式编程的书，但在这个章节和[*第10章*](B21324_10.xhtml#_idTextAnchor209)“防御性编程技术”中，我们仍将探索这些概念中的一些。
- en: Using expression-bodied members
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表达式主体成员
- en: 'To start dipping our toes into the waters of the more functional syntax, let’s
    take a look at the `FindFlightById` method in `FlightTracker`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始尝试更函数式的语法，让我们看看`FlightTracker`中的`FindFlightById`方法：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Clearly, this is a very brief method with only a single statement. At the same
    time, this method takes up three lines of the screen. Since developers usually
    leave a blank line above and below each method, the existence of this simple method
    takes up five lines of the screen. These five lines can be a significant portion
    of the visible region of the screen, as shown in *Figure 4**.13*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个非常简短的方法，只有一条语句。同时，此方法占据了屏幕的三行。由于开发者通常在每个方法上方和下方留出空白行，因此这个简单的方法占据了屏幕的五行。这五行可能是屏幕可见区域的一个重要部分，如图
    *图 4*.13* 所示：
- en: '![Figure 4.13 – The visual footprint of a method with a single statement](img/B21324_04_13.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 单语句方法的视觉影响](img/B21324_04_13.jpg)'
- en: Figure 4.13 – The visual footprint of a method with a single statement
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 单语句方法的视觉影响
- en: 'Instead, we can take advantage of expression-bodied members and convert our
    method to a single-line declaration using this new syntax by activating the **Use
    expression body for method** refactoring on the **Quick Actions** menu with the
    method selected, as shown in *Figure 4**.14*:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以利用表达式体成员，通过在**快速操作**菜单上激活**使用表达式体进行方法重构**来将我们的方法转换为单行声明，如图 *图 4*.14*
    所示：
- en: '![Figure 4.14 – Triggering the Use expression body for method refactoring^](img/B21324_04_14.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – 触发方法重构的 Use 表达式体^](img/B21324_04_14.jpg)'
- en: Figure 4.14 – Triggering the Use expression body for method refactoring^
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 触发方法重构的 Use 表达式体
- en: 'This converts our code to the following, more concise format:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们的代码转换为以下更简洁的格式：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This style only works for single-line implementations and it isn’t for everyone.
    However, if you use it for simple code, it helps reduce the “scrolling penalty”
    you face with many small methods in a larger file.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格仅适用于单行实现，并不适合所有人。然而，如果你用它来编写简单代码，它可以帮助减少在大型文件中许多小方法带来的“滚动惩罚”。
- en: Passing functions as parameters with actions
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将带有动作的函数作为参数传递
- en: While expression-bodied members are less functional programming and more functional
    syntax, let’s shift gears and get a taste of what’s possible by thinking about
    methods as **actions** that you can store in variables and pass around to other
    methods.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表达式体成员在功能上更接近函数语法而非函数式编程，但让我们转换一下思路，通过将方法视为可以存储在变量中并在其他方法之间传递的**动作**来体验一下可能实现的内容。
- en: 'Before we talk about *how* to do this, let’s explore *why* we’d want to do
    this by looking at our `MarkFlightX` methods in `FlightTracker`. We’ll start with
    the `MarkFlightDelayed` method:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论**如何**做之前，让我们通过查看 `FlightTracker` 中的 `MarkFlightX` 方法来探讨**为什么**我们要这样做。我们将从
    `MarkFlightDelayed` 方法开始：
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This method does a few discrete things:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法执行以下几项离散操作：
- en: It searches for a flight by its ID
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过航班ID搜索航班
- en: If it finds the flight, it updates the properties on the flight and writes out
    the delay
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到航班，它将更新航班上的属性并输出延误
- en: If the flight can’t be found, a warning is written to the console
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找不到航班，将在控制台写入警告
- en: 'On its own, this method is fine. Let’s look at `MarkFlightDeparted` now:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，这种方法是可行的。现在让我们看看 `MarkFlightDeparted` 方法：
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Compare this method to the last one and you’ll see that there are few differences
    between them. The method still must find a flight by its ID, check to see whether
    the flight was found or not, and update the flight. The only difference in this
    method is what updates occur to the flight and what message gets written to the
    console.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将此方法与上一个方法进行比较，你会发现它们之间几乎没有差异。该方法仍然必须通过其ID查找航班，检查是否找到了航班，并更新航班。此方法中唯一的区别是更新航班的内容以及写入控制台的消息。
- en: 'Let’s round out our look at these methods with a look at `MarkFlightArrived`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看 `FlightTracker` 中的 `MarkFlightArrived` 方法来完善对这些方法的探讨：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the pattern repeats itself. The only major difference between these three
    methods is what happens if the flight is found.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模式重复出现。这三个方法之间唯一的重大区别是如果找到航班会发生什么。
- en: 'Thinking about it in that way, consider our logic with the following pseudocode:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式思考，考虑以下伪代码：
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `ApplyUpdateToFlight` is a placeholder for some method or function we
    could apply to the flight object. This is because the *action* we take turns out
    to be the only thing that varies here.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ApplyUpdateToFlight` 是一个占位符，代表我们可以应用于航班对象的某个方法或函数。这是因为我们采取的 *动作* 是这里唯一变化的东西。
- en: 'In fact, .NET has a class called an `Action` that can serve this very purpose:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，.NET 有一个名为 `Action` 的类可以用来完成这个目的：
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, the `updateAction` parameter represents a specific function that can be
    called. What function is it? We don’t know. The exact function will be provided
    by whoever called the `UpdateFlight` method – just like any other parameter.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`updateAction` 参数代表一个可以调用的特定函数。它是哪个函数？我们不知道。确切的函数将由调用 `UpdateFlight` 方法的任何人提供——就像任何其他参数一样。
- en: However, because `updateAction` is defined as `Action<Flight>`, we know that
    the function takes in a single parameter of the `Flight` type, which is why we
    can provide that parameter to the function when we invoke it inside this method.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因为 `updateAction` 被定义为 `Action<Flight>`，我们知道该函数接受一个 `Flight` 类型的单个参数，这就是为什么我们可以在调用此方法时向该函数提供该参数。
- en: 'To help the idea of `Action` syntax sink in a little more, let’s see a few
    other signatures:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 `Action` 语法更易于理解，让我们看看几个其他的签名：
- en: '`Action<int>` – A function taking in a single integer parameter'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Action<int>` – 一个接受单个整数参数的函数'
- en: '`Action<string, bool>` – A function taking in a string and then a boolean'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Action<string, bool>` – 一个接受字符串然后是布尔值的函数'
- en: '`Action` – A function taking in no parameters at all'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Action` – 一个不接受任何参数的函数'
- en: 'Now that declaring the `Action` parameters makes a little more sense syntactically,
    let’s see how one of our old methods might be updated to use this new method:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在声明 `Action` 参数在语法上更有意义，让我们看看我们的一个旧方法如何更新以使用这个新方法：
- en: '[PRE31]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, the `MarkFlightDelayed` method calls directly into the `UpdateFlight`
    method and provides an `Action<Flight>` in the form of the `(flight) => { }` syntax.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MarkFlightDelayed` 方法直接调用 `UpdateFlight` 方法，并提供了 `(flight) => { }` 语法形式的
    `Action<Flight>`。
- en: When the `UpdateFlight` method runs, it checks to see whether the flight exists
    and, if it does, the method calls the arrow function we provided to actually update
    the flight.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `UpdateFlight` 方法运行时，它会检查航班是否存在，如果存在，该方法会调用我们提供的箭头函数来实际更新航班。
- en: 'If the syntax of this is difficult, here’s a different way of representing
    the same thing, by using a local variable to hold the `Action<Flight>`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个语法很难理解，这里有一个用本地变量来持有 `Action<Flight>` 的不同方式来表示相同的事情：
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It’s undoubtedly possible to have a happy and productive career as a developer
    without declaring an `Action` variable. However, I’ve found that when I’m able
    to think in terms of discrete `Actions`, it can open some very interesting and
    flexible solutions to problems.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，作为开发者，即使不声明 `Action` 变量，也能有一个快乐且富有成效的职业生涯。然而，我发现当我能够以离散的 `Action` 为术语进行思考时，它可以打开一些非常有趣和灵活的解决方案来解决问题。
- en: Returning data from Actions with Funcs
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Funcs 从 Actions 返回数据
- en: Before we move on to talking about static and extension methods, let’s take
    a brief look at `Funcs`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论静态和扩展方法之前，让我们简要地看看 `Funcs`。
- en: A `Action` in that it represents a *function* that can be invoked and potentially
    passed parameters. However, while `Actions` do not return any results, `Funcs`
    do.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action` 代表一个可以调用并可能传递参数的 *函数*。然而，尽管 `Actions` 不返回任何结果，`Funcs` 会返回。'
- en: 'Let’s examine a simple C# method that adds two numbers together and displays
    their result in an equation string:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个简单的 C# 方法，它将两个数字相加，并将结果显示在方程字符串中：
- en: '[PRE33]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This method has a `void` return type, meaning it doesn’t return any value.
    As a result, it could be stored in an `Action` and invoked in that way:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法具有 `void` 返回类型，这意味着它不返回任何值。因此，它可以存储在 `Action` 中并以这种方式调用：
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let’s look at a slightly different version of the `Add` method:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `Add` 方法的略微不同的版本：
- en: '[PRE35]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, `AddFunc` has a return type of `string`. Because the method no longer
    returns a void, it can no longer be considered an `Action` and is now considered
    a `Func` because it returns some value.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`AddFunc` 的返回类型为 `string`。因为方法不再返回空值，所以它不再被视为 `Action`，现在被视为 `Func`，因为它返回了一些值。
- en: 'As a result, if we wanted to store a reference to this method, we’d need to
    do so in a `Func`, as shown here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想存储对这个方法的引用，我们需要在 `Func` 中这样做，如下所示：
- en: '[PRE36]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that in addition to using a `Func` instead of an `Action`, we now have
    a third `Func` represents the return type of the `Func`. In the case of `myFunc`,
    the third generic type parameter indicates that `AddFunc` returns a `string`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了使用 `Func` 而不是 `Action` 之外，我们现在还有一个代表 `Func` 返回类型的第三个 `Func`。在 `myFunc`
    的情况下，第三个泛型类型参数表示 `AddFunc` 返回一个 `string`。
- en: '`Action` and `Func` are very closely related with the only significant difference
    being that `Func` returns a value. In practice, I tend to use `Action` when I
    want to accomplish something, such as in the earlier example of updating flights.
    On the other hand, I tend to use `Func` to determine when to do something or how
    to get a specific value I need.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action` 和 `Func` 非常相似，唯一的显著区别是 `Func` 返回一个值。在实践中，我倾向于在想要完成某事时使用 `Action`，例如在更新航班的早期示例中。另一方面，我倾向于使用
    `Func` 来确定何时做某事或如何获取所需的特定值。'
- en: 'For example, I might declare a method that takes in a `Func<Flight, bool>`
    that it uses to determine whether a flight from a list of flights should be displayed:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我可能声明一个接受 `Func<Flight, bool>` 的方法，它使用它来确定从航班列表中显示的航班：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This method calls the `shouldDisplay` Func for every flight in the list in order
    to determine whether it should be displayed. Flights only display if the `shouldDisplay`
    Func returns `true` for that flight.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法为列表中的每个航班调用 `shouldDisplay` Func，以确定它是否应该显示。只有当 `shouldDisplay` Func 为该航班返回
    `true` 时，航班才会显示。
- en: 'This structure allows the same method to be used for different scenarios, including
    the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构允许同一方法用于不同的场景，包括以下内容：
- en: Listing upcoming flights
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出即将到来的航班
- en: Listing delayed flights
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出延误的航班
- en: Listing flights heading to a specific airport
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出前往特定机场的航班
- en: The only difference between these is what the `shouldDisplay` parameter holds.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这些之间的唯一区别是 `shouldDisplay` 参数的内容。
- en: Introducing static methods and extension methods
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍静态方法和扩展方法
- en: 'Now that we’ve explored some of the more functional aspects of method refactoring,
    let’s take a look at some of the features that helped revolutionize .NET: **static
    methods** and **extension methods**.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了一些方法重构的更多功能方面，让我们看看一些帮助革命化 .NET 的功能：**静态方法**和**扩展方法**。
- en: Making methods static
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使方法静态
- en: 'Sometimes, your classes will have methods that don’t work directly with instance
    members (fields, properties, or non-static methods) of that class. For example,
    `FlightTracker` has a `Format` method that converts a `DateTime` to a string resembling
    “Wed Jul 12 23:14 PM”:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您的类将会有不直接与该类实例成员（字段、属性或非静态方法）工作的方法。例如，`FlightTracker` 有一个 `Format` 方法，它将
    `DateTime` 转换为类似于“Wed Jul 12 23:14 PM”的字符串：
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, `Format` doesn’t rely on anything other than the parameters it is provided
    to calculate a result. Because of this, we can make `Format` a static method.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Format` 不依赖于除了它提供的参数以外的任何东西来计算结果。正因为如此，我们可以将 `Format` 作为一个静态方法。
- en: Static methods are methods associated with the class itself and not with an
    instance of the class. As a result, you don’t need to instantiate an instance
    of the class to call them. The C# compiler is also able to make occasional optimizations
    surrounding static code that can result in faster code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法是与类本身相关联的方法，而不是与类的实例相关联的方法。因此，您不需要实例化类的实例来调用它们。C# 编译器还能够对静态代码进行偶尔的优化，这可能导致代码运行更快。
- en: Typically, static methods can also be considered **pure methods** – that is
    to say, methods without direct side effects that always produce the same result
    when given the same input.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，静态方法也可以被认为是**纯方法**——也就是说，没有直接副作用的方法，当给定相同的输入时总是产生相同的结果。
- en: 'As shown in *Figure 4**.14*, you can mark a method as static by adding the
    `static` keyword after the access modifier or by choosing the **Make static**
    option on the **Quick** **Actions** menu:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如**图 4**.14 所示，您可以通过在访问修饰符后添加 `static` 关键字或通过在**快速操作**菜单中选择**使静态**选项来将方法标记为静态：
- en: '![Figure 4.15 – Moving a method to a static method](img/B21324_04_15.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – 将方法移动到静态方法](img/B21324_04_15.jpg)'
- en: Figure 4.15 – Moving a method to a static method
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 将方法移动到静态方法
- en: 'The static version of **Format** looks very similar and works almost identically:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**Format** 的静态版本看起来非常相似，并且几乎以相同的方式工作：'
- en: '[PRE39]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `Format` method can still be called simply with `Format(DateTime.Now)` as
    it could before, but adding static also allows you to call it from the class itself,
    such as `FlightTracker.Format(DateTime.Now)`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Format` 方法仍然可以通过 `Format(DateTime.Now)` 简单地调用，就像之前一样，但添加静态也允许您从类本身调用它，例如 `FlightTracker.Format(DateTime.Now)`。'
- en: 'Marking a method as static has a few advantages:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法标记为静态有几个优点：
- en: The compiler can make optimizations resulting in faster runtime performance
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器可以做出优化，从而实现更快的运行时性能
- en: Code can call the static method without needing to instantiate the class
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可以在不实例化类的情况下调用静态方法
- en: The static method could be converted to an extension method, as we’ll see later
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法可以转换为扩展方法，我们将在后面看到。
- en: The `static` keyword may seem like a great thing to use everywhere you can due
    to these added features. Unfortunately, `static` has some drawbacks as well. Marking
    a method as `static` also means it can no longer call non-`static` methods or
    access instance-level data.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些附加功能，`static`关键字似乎可以在任何地方使用都是一件好事。不幸的是，`static`也有一些缺点。将方法标记为`static`也意味着它不能再调用非`static`方法或访问实例级数据。
- en: There are certainly many uses for `static`, but it’s still something that many
    developers find distasteful or consider an anti-pattern in excess.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`static`有很多用途，但仍然有很多开发者认为它令人反感，或者认为过度使用是反模式。
- en: Personally, I find `static` is appropriate for “helper methods” and, in some
    cases, to simplify unit testing complex classes that can be complex to instantiate
    in testing scenarios. However, I draw the line at making fields `static` whenever
    possible, as `static` data can lead to many problems in developing and testing
    applications.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我认为`static`适用于“辅助方法”，在某些情况下，为了简化在测试场景中难以实例化的复杂类的单元测试，也是合适的。然而，我总是尽量避免将字段设置为`static`，因为`static`数据可能导致开发和测试应用程序时出现许多问题。
- en: Moving static members to another type
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将静态成员移动到另一个类型
- en: Sometimes, it doesn’t make sense for a static method to remain in the class
    it started in.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，静态方法保留在它开始的类中是没有意义的。
- en: For example, our `Format` method takes any `DateTime` and returns a customized
    string appropriate to Cloudy Skies Airlines’ business needs. This logic is currently
    inside of the `FlightTracker` class, and yet is completely unrelated to tracking
    flights and could be useful to have in any number of places throughout their application.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的`Format`方法接受任何`DateTime`并返回适合Cloudy Skies Airlines业务需求的定制字符串。这种逻辑目前位于`FlightTracker`类中，而且与跟踪航班完全无关，可以在应用程序的任何地方都很有用。
- en: In this scenario, it makes sense to pull `Format` into a different class where
    other developers can more readily discover these formatting capabilities.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将`Format`拉入另一个类是有意义的，这样其他开发者可以更容易地发现这些格式化功能。
- en: 'Visual Studio provides a built-in refactoring for this. To use it, select a
    static method and open the **Quick Actions** menu, then click **Move static members
    to another type...**, as shown in *Figure 4**.16*:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 为此提供了内置的重构功能。要使用它，请选择一个静态方法并打开**快速操作**菜单，然后点击**将静态成员移动到另一个类型...**，如图**4.16**所示。16：
- en: '![Figure 4.16 – Moving static members to another type](img/B21324_04_16.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图**4.16** – 将静态成员移动到另一个类型](img/B21324_04_16.jpg)'
- en: Figure 4.16 – Moving static members to another type
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图**4.16** – 将静态成员移动到另一个类型
- en: Next, you will be prompted to select the Type your static methods should be
    moved to. This can be the name of a new class if you don’t currently have a class
    suitable for this. For Cloudy Skies, there is no existing Type that should own
    this, so creating one named `DateHelpers` makes sense.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将被提示选择要将静态方法移动到的类型。如果您目前没有适合此目的的类，这可以是新类的名称。对于Cloudy Skies，没有现有的类型应该拥有这个，因此创建一个名为`DateHelpers`的类是有意义的。
- en: 'Additionally, you will be asked to check or uncheck the static methods you
    want to move with an option to **Select Dependents** (see *Figure 4**.17*) and
    select any methods that your selected static methods call:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您将需要检查或取消检查您想要移动的静态方法，并有一个选项来**选择依赖项**（见图**4.17**）并选择任何您的选择静态方法调用的方法：
- en: '![Figure 4.17 – Selecting the destination type and the members to move](img/B21324_04_17.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图**4.17** – 选择目标类型和要移动的成员](img/B21324_04_17.jpg)'
- en: Figure 4.17 – Selecting the destination type and the members to move
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图**4.17** – 选择目标类型和要移动的成员
- en: Click **OK** to move your selected method and create a new class.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**以移动您选择的方法并创建一个新类。
- en: Important note
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The current behavior of Visual Studio is to keep your method’s current access
    modifier and create the new static class as `internal`. This may introduce compiler
    errors if your method was `private`, as code at the old location will no longer
    be able to access your code. I recommend changing your static class and its methods
    to `public` to avoid issues.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 当前行为是保持您方法当前的可访问修饰符，并将新静态类创建为`internal`。如果您的该方法为`private`，这可能会引入编译错误，因为旧位置中的代码将无法访问您的代码。我建议将您的静态类及其方法更改为`public`以避免问题。
- en: 'Here’s the resulting **static class** after adjusting its modifiers:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 调整修饰符后的结果**静态类**如下：
- en: '[PRE40]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now we have a dedicated class just for “helper methods” associated with dates
    and times.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个专门用于与日期和时间相关的“辅助方法”的专用类。
- en: Static classes
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类
- en: If you’re not familiar with static classes, a static class can only have static
    methods in it and cannot be instantiated or inherited from. Static classes are
    required for extension methods.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉静态类，静态类只能包含静态方法，不能被实例化或继承。静态类对于扩展方法是必需的。
- en: The refactoring we just performed also updated any code that was using the old
    `Format` method to point to `DateTimeHelpers.Format`. For example, in `FlightTracker`,
    the `MarkFlightArrived` method’s flight logging now says `Console.WriteLine($"{id}
    arrived` `at {DateHelpers.Format(arrivalTime)}.");`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才进行的重构还更新了任何使用旧`Format`方法的代码，使其指向`DateTimeHelpers.Format`。例如，在`FlightTracker`中，`MarkFlightArrived`方法的航班记录现在显示`Console.WriteLine($"{id}
    arrived at {DateHelpers.Format(arrivalTime)});`。
- en: By pulling static members into their own dedicated type, we’ve created a home
    where date-related logic can live and help a wide variety of classes, and we’ve
    made our `FlightTracker` class more focused on its core job instead of being focused
    on date formatting as well as flight tracking.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将静态成员拉入它们自己的专用类型，我们创建了一个可以存放与日期相关的逻辑并帮助各种类的地方，并且我们使`FlightTracker`类更加专注于其核心任务，而不是同时关注日期格式化和航班跟踪。
- en: Unfortunately, this change has somewhat hurt the readability of our code because
    callers must now specify `DateHelpers.Format` instead of just `Format`. An extension
    method can help with this, as we’ll see next.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个改动多少伤害了我们代码的可读性，因为调用者现在必须指定`DateHelpers.Format`而不是仅仅`Format`。一个扩展方法可以帮助解决这个问题，就像我们接下来要看到的那样。
- en: Creating extension methods
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建扩展方法
- en: Extension methods allow you to “extend” an existing Type by adding your own
    static methods that appear like they’re part of that Type.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法允许你通过添加自己的静态方法来“扩展”现有的类型，这些方法看起来就像该类型的一部分。
- en: 'That might sound intimidating, but if you’ve used LINQ, you’ve seen extension
    methods in action. Let’s look at the `FindFlightById` method in `FlightTracker`
    as an example:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有些吓人，但如果你使用过LINQ，你已经在实际中看到了扩展方法。让我们以`FlightTracker`中的`FindFlightById`方法为例：
- en: '[PRE41]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, `_flights` is defined as a `List<Flight>`. Given that the code to find
    a flight by its ID, it’s understandable to suspect that `List` must have a method
    called `FirstOrDefault`; however, it does not.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`_flights`被定义为`List<Flight>`。鉴于查找航班ID的代码，人们可能会怀疑`List`必须有一个名为`FirstOrDefault`的方法；然而，它并没有。
- en: Instead, the `FirstOrDefault` method is not defined on the `List<T>` type in
    the `System.Collections.Generic` namespace, but rather is defined as an extension
    method in a static class called `Enumerable` in the `System.Linq` namespace.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`System.Collections.Generic`命名空间中的`List<T>`类型并没有定义`FirstOrDefault`方法，而是在`System.Linq`命名空间中一个名为`Enumerable`的静态类中定义为一个扩展方法。
- en: 'In other words, it is perfectly feasible to rewrite our code from earlier to
    explicitly use the `Enumerable` class, as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，将我们之前的代码重写为显式使用`Enumerable`类是完全可行的，如下所示：
- en: '[PRE42]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: While this is perfectly valid code, nobody I’ve ever worked with writes code
    in this way because using `FirstOrDefault` as an extension method is far more
    intuitive and readable.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码完全有效，但我从未见过与我共事的人以这种方式编写代码，因为将`FirstOrDefault`用作扩展方法要直观得多，可读性也更强。
- en: 'This highlights the key point of extension methods: *extension methods allow
    you to add new features to existing classes in a way that appears like those methods
    were present on the object to begin with*, resulting in more intuitive code.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这突出了扩展方法的关键点：*扩展方法允许你以似乎那些方法从一开始就存在于对象上的方式向现有类添加新功能*，从而产生更直观的代码。
- en: 'To declare a method as an extension method, the following things must be true:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要将方法声明为扩展方法，以下条件必须成立：
- en: The method must be static
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法必须是静态的
- en: The method must be inside a static class
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法必须在静态类内部
- en: The first parameter of the method must start with the `this` keyword
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的第一个参数必须以`this`关键字开头
- en: 'Our `DateHelpers` class and its `Format` method are both static, which means
    we can convert the method to an extension method by adding the `this` keyword
    to the method signature:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DateHelpers`类及其`Format`方法都是静态的，这意味着我们可以通过在方法签名中添加`this`关键字将方法转换为扩展方法：
- en: '[PRE43]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Moving a static method to an extension method doesn’t mean you have to use it
    as an extension method and so our previous code will still compile. However, in
    order to get the most value out of our extension method, we should update prior
    code to take advantage of its new syntax.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 将静态方法移动到扩展方法并不意味着你必须将其用作扩展方法，因此我们之前的代码仍然可以编译。然而，为了最大限度地利用我们的扩展方法，我们应该更新之前的代码以利用其新的语法。
- en: 'Let’s take another look at the `MarkFlightArrived` method in `FlightTracker`.
    This time, if you delete the `DateFormatHelpers.Format(arrivalTime)`, instead
    write `arrivalTime.For`, and allow Visual Studio’s **IntelliSense** to suggest
    values, it will list your new extension method:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看`FlightTracker`中的`MarkFlightArrived`方法。这次，如果你删除`DateFormatHelpers.Format(arrivalTime)`，而是写`arrivalTime.For`，并允许Visual
    Studio的**IntelliSense**建议值，它将列出你的新扩展方法：
- en: '![Figure 4.18 – IntelliSense suggesting the new extension method](img/B21324_04_18.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图4.18 – IntelliSense建议的新扩展方法](img/B21324_04_18.jpg)'
- en: Figure 4.18 – IntelliSense suggesting the new extension method
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 – IntelliSense建议的新扩展方法
- en: Because `arrivalTime` is a `DateTime` and our extension method is built to work
    on any `DateTime`, the new `Format` method we wrote appears here on the `DateTime`
    type provided in .NET through the power of extension methods.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`arrivalTime`是`DateTime`类型，我们的扩展方法是为了在任意`DateTime`上工作而构建的，所以我们在.NET中通过扩展方法的力量编写的新`Format`方法出现在这里。
- en: Rewriting the call to `arrivalTime.Format()` has the correct effect of calling
    out to the extension method, resulting in a far more readable experience.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写对`arrivalTime.Format()`的调用会产生正确调用扩展方法的效果，从而带来更易读的体验。
- en: If you’d prefer, you can still call out to the `Format` method via `DateHelpers.Format(arrivalTime)`.
    Introducing an extension method just gives you another option for how your syntax
    is structured.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你仍然可以通过`DateHelpers.Format(arrivalTime)`调用`Format`方法。引入扩展方法只是为你提供了另一种语法结构的选择。
- en: 'The downsides of extension methods are, primarily, as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法的主要缺点如下：
- en: Extension methods require the use of static, which some teams avoid because
    it tends to spread throughout your code
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法需要使用静态，这有些团队会避免，因为它往往会散布到你的代码中
- en: It can be confusing that you’re using an extension method
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扩展方法可能会让人感到困惑
- en: It can be confusing where the new extension methods are defined
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的扩展方法定义在哪里可能会让人感到困惑
- en: Thankfully, Visual Studio allows you to go to the definition of any method,
    member, or type simply by holding *Ctrl* and clicking on the item you want to
    navigate to. Alternatively, you can select the identifier and press *F12* on your
    keyboard or right-click on it and choose **Go To Definition** to navigate to where
    the extension method is declared.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Visual Studio允许你通过简单地按住*Ctrl*并单击你想要导航到的任何方法、成员或类型来跳转到其定义。或者，你可以选择标识符并按键盘上的*F12*，或者右键单击它并选择**转到定义**来导航到扩展方法声明的位置。
- en: Reviewing and testing our refactored code
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查和测试我们的重构代码
- en: Over the course of this chapter, we took a repetitive `FlightTracker` class
    and restructured it to ensure that its method signatures were more consistent
    and that common logic was reused wherever possible.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将重复的`FlightTracker`类重构，以确保其方法签名更加一致，并且尽可能重用常见逻辑。
- en: Refactored code
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的代码
- en: The final refactored code from this chapter is available in the [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    repository inside of the `Chapter04/Ch4RefactoredCode` folder.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最终重构的代码可在[https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)仓库中的`Chapter04/Ch4RefactoredCode`文件夹内找到。
- en: Before we move on, we should ensure that all tests still pass by running the
    unit tests from the **Test** menu and then selecting the **Run All Tests** menu
    item.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们应该确保所有测试仍然通过，通过从**测试**菜单运行单元测试，然后选择**运行所有测试**菜单项。
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how various methods, constructors, and parameter refactorings
    can be applied to keep your code orderly. We saw how overloading and chaining
    together methods and constructors gives you more options, while renaming, adding,
    removing, and reordering parameters helps ensure consistency.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何将各种方法、构造函数和参数重构应用于保持代码的整洁。我们看到了如何通过重载和链式调用方法和构造函数来提供更多选项，同时重命名、添加、删除和重新排序参数有助于确保一致性。
- en: Near the end of this chapter, we covered `Actions`, `Funcs`, static methods,
    and extension methods, and showed how thinking about your code in terms of small,
    reusable functions can help solve certain types of problems more effectively.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章接近尾声时，我们介绍了`Actions`、`Funcs`、静态方法和扩展方法，并展示了如何通过将代码视为小型、可重用的函数来更有效地解决某些类型的问题。
- en: In the next chapter, we’ll cover object-oriented refactoring techniques and
    revisit our parameter refactorings in this chapter by exploring how large sets
    of parameters can be brought under control by extracting classes.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍面向对象的重构技术，并通过探索如何通过提取类来控制大量参数来回顾本章中的参数重构。
- en: Questions
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Are there any areas of your code where you seem to be confused more frequently
    by the parameter ordering or naming?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的代码中是否有任何区域，你似乎经常因为参数的顺序或命名而感到困惑？
- en: Can you think of any places in your code where slightly different actions are
    performed based on the same or similar conditions? If so, does moving to use an
    `Action` or a `Func` make sense?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能否想到你的代码中任何根据相同或类似条件执行稍微不同操作的地方？如果是这样，那么转向使用`Action`或`Func`是否有意义？
- en: Does your code have a set of “helper methods” that might make sense to make
    static and put into a static class? If so, would switching to extension methods
    improve your code elsewhere?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的代码中是否有一组“辅助方法”，这些方法可能适合将其设置为静态并放入静态类中？如果是这样，转向使用扩展方法是否会改善你代码的其他部分？
- en: Further reading
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more information about the materials discussed in this chapter
    at the following URLs:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下URL中找到有关本章讨论的材料更多信息：
- en: '*Refactor into pure* *functions*: [https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-pure-functions](https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-pure-functions)'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重构为纯* *函数*：[https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-pure-functions](https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-pure-functions)'
- en: '*Action-Oriented* *C#*: [https://killalldefects.com/2019/09/15/action-oriented-c/](https://killalldefects.com/2019/09/15/action-oriented-c/)'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向操作* *C#*：[https://killalldefects.com/2019/09/15/action-oriented-c/](https://killalldefects.com/2019/09/15/action-oriented-c/)'
- en: '*Refactor using an extension* *method*: [https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-extension-method](https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-extension-method)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用扩展方法重构* *方法*：[https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-extension-method](https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-extension-method)'
- en: '*Named and Optional* *Arguments*: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命名和可选* *参数*：[https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments)'
