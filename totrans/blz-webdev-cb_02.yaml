- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Synchronous and Asynchronous Data Binding
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步和异步数据绑定
- en: In this chapter, we will explore various facets of data binding in Blazor. **Binding**
    is a cornerstone in modern web development. We’ll start with the fundamentals
    of binding values with DOM elements. Then, we will progress to binding specific
    DOM events, ensuring that your Blazor application is highly interactive and responsive.
    Most commercial applications will require integration with an external data provider.
    With that, you will have to perform asynchronous actions. We will explore how
    to pair them with bindings as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Blazor中数据绑定的各个方面。**绑定**是现代网络开发的一个基石。我们将从绑定值与DOM元素的基本原理开始。然后，我们将进一步探讨绑定特定的DOM事件，确保你的Blazor应用程序高度交互和响应。大多数商业应用程序都需要与外部数据提供者集成。因此，你必须执行异步操作。我们将探讨如何将它们与绑定配对。
- en: Further, we’ll cover customizing getters and setters, allowing for greater data
    handling flexibility. We will also cover the **bind-Value** binding pattern, which
    should simplify most of your binding scenarios. Lastly, we will implement a commercial
    scenario of seamless binding with an external data provider. That comes in handy
    when implementing search modules or data persistence mechanisms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将介绍自定义获取器和设置器，以提供更大的数据处理灵活性。我们还将介绍**bind-Value**绑定模式，它应该简化你大多数的绑定场景。最后，我们将实现一个与外部数据提供者无缝绑定的商业场景。这在实现搜索模块或数据持久化机制时非常有用。
- en: However, we will fully skip building forms or using Blazor-native components
    that can simplify binding – we cover that in [*Chapter 6*](B22020_06.xhtml#_idTextAnchor203)
    , which covers *building* *interactive forms* .
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将完全跳过构建表单或使用可以简化绑定的Blazor原生组件——我们将在[*第6章*](B22020_06.xhtml#_idTextAnchor203)中介绍，该章节涵盖*构建*
    *交互式表单*。
- en: By the end of this chapter, you will gain a deep understanding of data binding
    in Blazor. It will enable you to build more dynamic and user-friendly web applications.
    All interactivity you’ll come to implement will come down to binding. You’ll have
    recipes at hand to handle those synchronous and asynchronous scenarios.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将深入理解Blazor中的数据绑定。这将使你能够构建更动态和用户友好的网络应用程序。你将要实现的全部交互性都将归结为绑定。你将手头有食谱来处理那些同步和异步场景。
- en: 'Here’s the list of recipes we’ll cover in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将在本章中介绍的食谱列表：
- en: Binding values with markup elements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标记元素绑定值
- en: Binding to a specific DOM event
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定到特定的DOM事件
- en: Performing asynchronous actions after binding
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定后执行异步操作
- en: Customizing get and set binding logic
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义获取和设置绑定逻辑
- en: Simplifying binding with the **bind-Value** pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**bind-Value**模式简化绑定
- en: Binding with an external data provider
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部数据提供者进行绑定
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As we will be exploring fundamental concepts of Blazor and web development,
    you won’t need any paid add-ons or additional tools. You will, however, need the
    following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将探讨Blazor和Web开发的基本概念，你不需要任何付费插件或额外工具。然而，你需要以下内容：
- en: A modern IDE (of your choice)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个现代IDE（你选择的）
- en: A modern web browser ( supporting **WebAssembly** )
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个现代网络浏览器（支持**WebAssembly**）
- en: A Blazor project
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Blazor项目
- en: 'All the code examples (and data samples) that you’ll see next can be found
    in a dedicated GitHub repository at :'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来将看到的全部代码示例（和数据样本）可以在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter0
    2](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter02)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter02](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter02)'
- en: Binding values with markup elements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标记元素绑定值
- en: In this recipe, we introduce the foundational concept of data binding in Blazor
    applications. This feature bridges the gap between the user interface and the
    application’s data or state. A deep understanding of this concept will allow you
    to level up the interactivity of your projects. We start with mastering the basics.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们介绍了Blazor应用程序中数据绑定的基础概念。这个特性连接了用户界面与应用程序的数据或状态之间的差距。对这个概念有深入的理解将使你能够提升你项目的交互性。我们首先从掌握基础知识开始。
- en: Let’s bind a simple text field to a backing variable to see the data flowing
    from the user interface to the backend.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绑定一个简单的文本字段到一个后端变量，以查看数据从用户界面流向后端。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you dive into binding, create a **Recipe01** directory – this will be
    your working directory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始绑定之前，创建一个 **Recipe01** 目录 – 这将是你的工作目录。
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to bind a C# value with a markup element:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤绑定 C# 值与标记元素：
- en: 'Add a routable **IntroduceYourself** component that renders in an **InteractiveWebAssembly**
    mode:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个可路由的 **IntroduceYourself** 组件，以 **InteractiveWebAssembly** 模式渲染：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the **@code** block of **IntroduceYourself** , initialize a **User**
    variable to store the user input value:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **IntroduceYourself** 的 **@code** 块中，初始化一个 **User** 变量以存储用户输入的值：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the **IntroduceYourself** markup, add a call to action and an input field
    with a **@bind** attribute assigned to the **User** variable:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **IntroduceYourself** 标记中，添加一个号召性用语和一个带有 **@bind** 属性的输入字段，该属性分配给 **User**
    变量：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As part of the **IntroduceYourself** markup, construct a little logic to dynamically
    display a greeting once the user fills the input field:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为 **IntroduceYourself** 标记的一部分，构建一些逻辑以在用户填写输入字段后动态显示问候语：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We kick off the recipe with a routine step in Blazor development – the creation
    of a new component. In *step 1* , we execute a routine step in Blazor development
    – we create a new **IntroduceYourself** component and declare its render mode.
    In our case, we opt for **InteractiveWebAssembly** . In *step 2* , we jump to
    the **@code** block of **IntroduceYourself** and initialize a **User** backing
    field – crucial for our data-binding operation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以 Blazor 开发中的一个常规步骤开始这个食谱 – 创建一个新的组件。在 *步骤 1* 中，我们执行 Blazor 开发中的一个常规步骤 – 创建一个新的
    **IntroduceYourself** 组件并声明其渲染模式。在我们的案例中，我们选择 **InteractiveWebAssembly**。在 *步骤
    2* 中，我们跳转到 **IntroduceYourself** 的 **@code** 块并初始化一个 **User** 后备字段 – 这对于我们的数据绑定操作至关重要。
- en: The actual binding magic starts in *step 3* . We move to the **IntroduceYourself**
    markup and, next to a call to action, we embed an **input** element and leverage
    Blazor’s native **@bind** attribute for the first time. The **@bind** attribute
    enables a two-way data binding – not only assigning the input value to the **User**
    backing field but also ensuring that the UI is updated to reflect this change.
    In *step 4* , we add another section of the **IntroduceYourself** markup – we
    display the current **User** value when a user fills the input. That will help
    us to visualize the behavior of our binding.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的绑定魔法从 *步骤 3* 开始。我们转向 **IntroduceYourself** 标记，并在号召性用语旁边嵌入一个 **input** 元素，并首次利用
    Blazor 的原生 **@bind** 属性。**@bind** 属性启用双向数据绑定 – 不仅将输入值分配给 **User** 后备字段，还确保 UI
    更新以反映这一变化。在 *步骤 4* 中，我们添加 **IntroduceYourself** 标记的另一个部分 – 当用户填写输入时，我们显示当前的 **User**
    值。这将帮助我们可视化绑定的行为。
- en: The two-way binding, facilitated by the **@bind** attribute, simplifies the
    implementation of user interactivity. It is a go-to method for most simple binding
    cases, where you don’t need to execute additional logic. Notably, by default,
    this binding occurs when the user exits the input box, but that’s fully customizable.
    We will explore and clarify this behavior and its underlying mechanics in the
    next recipe.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由 **@bind** 属性促进的双向绑定简化了用户交互的实现。对于大多数简单的绑定情况，这是一个首选方法，其中不需要执行额外的逻辑。值得注意的是，默认情况下，此绑定发生在用户退出输入框时，但这完全可定制。我们将在下一个食谱中探索和阐明这种行为及其背后的机制。
- en: Binding to a specific DOM event
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定到特定的 DOM 事件
- en: Now, we will dive into targeted and efficient handling of user interactions
    in Blazor applications. While general data binding is crucial, binding specific
    actions to specific **DOM events** takes your application’s interactivity to the
    next level. This approach allows for a more controlled and responsive user experience.
    You can directly link an event, such as a click or a key press, to a corresponding
    C# method or action. You’ll learn how to identify and bind to these events and
    which events are bindable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深入探讨在 Blazor 应用程序中针对用户交互的精确和高效处理。虽然一般数据绑定至关重要，但将特定操作绑定到特定的 **DOM 事件**
    可以将应用程序的交互性提升到下一个层次。这种方法允许更受控和响应的用户体验。你可以直接将事件（如点击或按键）链接到相应的 C# 方法或操作。你将学习如何识别和绑定到这些事件以及哪些事件是可以绑定的。
- en: Let’s implement a simple text field but trigger binding as the user types, not
    when they exit the field, which is the default behavior.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的文本字段，但触发绑定是在用户输入时，而不是他们退出字段时，这是默认行为。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before exploring binding on a specific event, do the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索特定事件的绑定之前，请执行以下操作：
- en: Create a **Recipe02** directory – this will be your working directory
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Recipe02** 目录 – 这将是你的工作目录
- en: Copy your **IntroduceYourself** component from the *Binding values with markup
    elements* recipe or copy its implementation from the **Chapter02** / **Recipe01**
    directory of the GitHub repository
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*绑定值与标记元素*菜谱复制您的**IntroduceYourself**组件，或者从GitHub仓库的**Chapter02** / **Recipe01**目录复制其实现。
- en: How to do it…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To bind to a specific DOM event, follow these instructions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要绑定到特定的DOM事件，请遵循以下说明：
- en: Navigate to the **@code** block in your **IntroduceYourself** component.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**IntroduceYourself**组件中的**@code**块。
- en: 'Alongside the existing **User** variable, initialize a new **Greeting** variable.
    We will use it to hold a greeting for the user:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了现有的**用户**变量外，初始化一个新的**问候**变量。我们将使用它来保存对用户的问候：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement the **IsGreetingReady** and **IsUserFilled** methods, which allow
    you to evaluate the state of the **User** and **Greeting** variables:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现了**IsGreetingReady**和**IsUserFilled**方法，这些方法允许您评估**用户**和**问候**变量的状态：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add a **SayHello()** method that prepares a greeting message:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**SayHello()**方法来准备问候信息：
- en: '[PRE6]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the **IntroduceYourself** markup, extend the input field binding by adding
    **@** **bind:event="oninput"** :'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**IntroduceYourself**标记中，通过添加**@** **bind:event="oninput"**来扩展输入字段绑定：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Extend the input field binding further by attaching a **SayHello()** behavior
    to the **@** **onfocusout** event:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将**SayHello()**行为附加到**@** **onfocusout**事件来进一步扩展输入字段绑定：
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Remove any existing checks of the **User** value from the previous implementation
    and implement a conditional greeting rendering based on the state-checking methods:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从之前的实现中移除对**用户**值的任何现有检查，并基于状态检查方法实现条件问候渲染：
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we’re enhancing the **IntroduceYourself** component to make
    it more interactive and engaging. Our goal is to enable the component to greet
    the user and display the progress of the user name input.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们正在增强**IntroduceYourself**组件，使其更具交互性和吸引力。我们的目标是使组件能够问候用户并显示用户名输入的进度。
- en: In *step 1* , we navigate to the **IntroduceYourself** component, and in *step
    2* , we go straight to the **@code** block and initialize an additional **Greeting**
    variable to store the generated greeting message. That sets the stage for our
    dynamic user interaction. In *step 3* , we introduce **IsUserFilled** and **IsGreetingReady**
    parameterless methods that check the state of the **User** and **Greeting** variables
    and allow us to simplify the markup code and make our logic more readable. Moving
    on to *step 4* , we add another method – **SayHello()** . We will invoke **SayHello()**
    when the user finishes typing their name to generate a greeting and assign it
    to the **Greeting** variable. It adds a personalized touch to the user experience.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1步*中，我们导航到**IntroduceYourself**组件，在*第2步*中，我们直接进入**@code**块并初始化一个额外的**问候**变量来存储生成的问候信息。这为我们的动态用户交互奠定了基础。在*第3步*中，我们引入了**IsUserFilled**和**IsGreetingReady**这两个无参方法，它们检查**用户**和**问候**变量的状态，并允许我们简化标记代码并使我们的逻辑更易于阅读。继续到*第4步*，我们添加了另一个方法——**SayHello()**。当用户完成他们的名字输入时，我们将调用**SayHello()**来生成问候并将其分配给**问候**变量。这为用户体验增添了个性化元素。
- en: '*Step 5* is where we take control of the binding logic. You can trigger binding
    on any event applicable in script-based frameworks, such as **oncopy** , **onpaste**
    , or **onblur** . We chose the **oninput** event for this example. We override
    the default binding event with **@bind:event="oninput"** and enable **User** value
    live updates as the user types. Notice the lowercase syntax of the **@bind:event**
    attribute, as Razor is a case-sensitive language framework. In *step 6* , we take
    interactivity a step further. We use a native Blazor reference to the **@onfocusout**
    event and when the user navigates away from the input field, we invoke the **SayHello()**
    method, effectively generating the greeting message.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*第5步*是我们控制绑定逻辑的地方。您可以在适用于脚本框架的任何事件上触发绑定，例如**oncopy**、**onpaste**或**onblur**。我们选择了**oninput**事件作为此示例。我们使用**@bind:event="oninput"**覆盖默认绑定事件，并启用**用户**值在用户输入时实时更新。注意**@bind:event**属性的语法是区分大小写的，因为Razor是一个区分大小写的语言框架。在*第6步*中，我们将交互性提升到一个新的层次。我们使用原生的Blazor引用到**@onfocusout**事件，当用户从输入字段导航离开时，我们调用**SayHello()**方法，从而生成问候信息。'
- en: Finally, in *step 7* , we implement a little rendering logic to ensure that
    the greeting is displayed only when the user has finished typing. Until then,
    the message **Introducing...** is generated. That way, we provide a clear indicator
    of UI interactivity and progress.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 *步骤 7* 中，我们实现了一些渲染逻辑，以确保只有当用户完成输入时，问候语才会显示。在此之前，将生成 **Introducing...**
    消息。这样，我们提供了一个清晰的 UI 交互和进度指示器。
- en: There’s more…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It’s important to know that Blazor allows you to intercept all event arguments.
    You can accomplish this by adding a parameter that matches the event argument
    type corresponding to the triggered event.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，Blazor 允许您拦截所有事件参数。您可以通过添加一个与触发事件对应的事件参数类型匹配的参数来实现这一点。
- en: For instance, let’s consider **DragEventArgs** . When a user is dragging elements
    into or within your application, you can intercept cursor positions and any active
    keyboard combinations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑 **DragEventArgs**。当用户将元素拖入或拖动到您的应用程序中时，您可以拦截光标位置和任何活动的键盘组合。
- en: 'Here’s how simple it is to intercept a dragging event:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截拖拽事件的简单方法如下：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Similarly, with **InputFileChangeEventArgs** , you can access the details of
    the file that the user has uploaded. It also exposes the **IBrowserFile** object,
    which you can use to stream the content to your servers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用 **InputFileChangeEventArgs**，您可以访问用户已上传的文件的详细信息。它还公开了 **IBrowserFile**
    对象，您可以使用它将内容流式传输到您的服务器。
- en: 'Here’s how you can intercept details of a file uploaded by a user:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何拦截用户上传文件细节的方法：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The capability to intercept specific events and details of those actions opens
    possibilities for more advanced and nuanced event handling in your Blazor applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截特定事件及其细节的能力为在 Blazor 应用程序中实现更高级和细致的事件处理提供了可能性。
- en: Performing asynchronous actions after binding
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定后执行异步操作
- en: Asynchronous actions are pivotal in modern web applications, especially when
    dealing with data-intensive operations such as fetching data from an **API** or
    database. It’s also crucial that your application remains responsive as it’s executing
    a long-running task. In this recipe, I’ll guide you through data binding when
    working with asynchronous tasks. You will learn how to integrate asynchronous
    actions, allowing non-blocking UI updates and smoother user experiences.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 异步操作在现代网络应用中至关重要，尤其是在处理如从 **API** 或数据库获取数据等数据密集型操作时。同时，当您的应用程序正在执行长时间运行的任务时，保持其响应性也非常关键。在本食谱中，我将指导您在处理异步任务时进行数据绑定。您将学习如何集成异步操作，以实现非阻塞的
    UI 更新和更流畅的用户体验。
- en: Let’s enable an **auto-complete** feature on a simple input field and generate
    a list of suggestions as the user types their name.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个简单的输入字段上启用 **自动完成** 功能，并在用户输入他们的名字时生成一个建议列表。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before diving into the auto-complete implementation, do the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入到自动完成实现之前，请执行以下操作：
- en: Create a **Recipe03** directory – this will be your working directory
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Recipe03** 目录——这将作为您的工作目录。
- en: Copy your **IntroduceYourself** component from the *Binding to a specific DOM
    event* recipe or copy its implementation from the **Chapter02** / **Recipe02**
    directory of the GitHub repository
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *绑定到特定的 DOM 事件* 食谱复制您的 **IntroduceYourself** 组件，或者从 GitHub 仓库的 **Chapter02**/
    **Recipe02** 目录复制其实现。
- en: Next to **Recipe03** , copy the **Chapter02** / **Data** directory from the
    GitHub repository, containing the **SuggestionsApi** class required in this recipe
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **Recipe03** 旁边，从 GitHub 仓库复制 **Chapter02**/ **Data** 目录，其中包含本食谱所需的 **SuggestionsApi**
    类。
- en: How to do it…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to trigger asynchronous actions after data binding:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在数据绑定后触发异步操作：
- en: 'Open the **Program** file of your application and register the **SuggestionsApi**
    service to enable communication with the API:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的应用程序的 **Program** 文件，并注册 **SuggestionsApi** 服务以启用与 API 的通信：
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Navigate to the **@code** block of the **IntroduceYourself** component and
    clean up the section, so only the **User** variable is still there:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **IntroduceYourself** 组件的 **@code** 块，清理该部分，以确保只有 **User** 变量仍然存在：
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Inside the **@code** block, inject the **SuggestionsApi** service and initialize
    a **Suggestions** collection that will hold the autocomplete results:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **@code** 块内部，注入 **SuggestionsApi** 服务并初始化一个 **Suggestions** 集合，该集合将保存自动完成的结果：
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Still within the **@code** block, implement a new asynchronous **AutocompleteAsync()**
    method responsible for calling the API and updating the **Suggestions** collection
    based on user input:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**@code**块中，实现一个新的异步**AutocompleteAsync()**方法，负责调用API并根据用户输入更新**建议**集合：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the **IntroduceYourself** markup, find the **input** field and replace the
    **@onfocusout** assignment with the **@bind:after** attribute that triggers the
    **AutocompleteAsync()** method:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**自我介绍**标记中，找到**输入**字段，并将**@onfocusout**赋值替换为触发**AutocompleteAsync()**方法的**@bind:after**属性：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Below **input** , under the **<hr />** separator, clear out the existing greeting
    and introduction sections and construct a fast-return when suggestions are currently
    unavailable:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**输入**下方，在**<hr />**分隔符下，清除现有的问候和介绍部分，并在建议当前不可用时构建快速返回：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Lastly, at the end of the **IntroduceYourself** markup, render the **Suggestions**
    collection received from the API response.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在**自我介绍**标记的末尾，渲染从API响应中接收到的**建议**集合。
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In *step 1* , we add a **SuggestionsApi** service to the **dependency injection**
    container of our application. That makes **SuggestionsApi** readily available
    for injection across the application, ensuring we can utilize it wherever needed.
    Similar to other .NET web frameworks, Blazor can manage services with three lifetimes
    – singleton, scoped, and transient:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们将**SuggestionsApi**服务添加到我们应用程序的**依赖注入**容器中。这使得**SuggestionsApi**在整个应用程序中都可以用于注入，确保我们可以在需要的地方使用它。类似于其他.NET
    Web框架，Blazor可以管理具有三种生命周期——单例、作用域和瞬态——的服务：
- en: '**Singleton** services are created once per application and shared across all
    components and requests.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例**服务在每个应用程序中只创建一次，并在所有组件和请求之间共享。'
- en: '**Transient** services are created anew each time they are requested, which
    makes them perfect for lightweight, stateless services (i.e. API integrations).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬态**服务每次请求时都会被重新创建，这使得它们非常适合轻量级、无状态的服务（例如API集成）。'
- en: '**Scoped** services are a little trickier. In client-side applications, scoped
    services generally behave like singleton services because there is no connection
    context to differentiate sessions. However, that changes when an **OwningComponentBase**
    component comes into play. **OwningComponentBase** is a base class for components
    ensuring that the component and its dependencies are disposed of gracefully when
    Blazor destroys the component instance.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域**服务稍微复杂一些。在客户端应用程序中，作用域服务通常表现得像单例服务，因为没有连接上下文来区分会话。然而，当**OwningComponentBase**组件介入时，情况就改变了。**OwningComponentBase**是一个基类，确保组件及其依赖项在Blazor销毁组件实例时能够优雅地释放。'
- en: In *step 2* , we move on to the **IntroduceYourself** component and clear out
    the greeting implementation, so only the **User** variable remains. In *step 3*
    , we inject **SuggestionsApi** into our **IntroduceYourself** component and initialize
    a **Suggestions** collection to store the results from calls we make to the API.
    Moving on to *step 4* , we implement the **AutocompleteAsync()** asynchronous
    method, playing a crucial role in simplifying the logic within the markup. **AutocompleteAsync()**
    checks whether the user has entered any input and calls the API’s **FindAsync()**
    method to fetch suggestions; otherwise, it short-circuits the operation, returning
    an empty array.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中，我们继续到**自我介绍**组件，并清除问候实现，因此只剩下**用户**变量。在**步骤 3**中，我们将**SuggestionsApi**注入到我们的**自我介绍**组件中，并初始化一个**建议**集合来存储我们从API调用中获取的结果。进入**步骤
    4**，我们实现**AutocompleteAsync()**异步方法，在简化标记逻辑中起着至关重要的作用。**AutocompleteAsync()**检查用户是否已输入任何内容，并调用API的**FindAsync()**方法来获取建议；否则，它将短路操作，返回一个空数组。
- en: In *step 5* , we enhance the markup of **IntroduceYourself** . We refine the
    binding logic on the input field, by removing the **@onfocusout** event and replacing
    it with the **@bind:after** directive, which invokes the **AutocompleteAsync()**
    method immediately after the binding completes. With this setup, we ensure that
    a new set of auto-suggestions is requested from the API each time the user modifies
    the input. Finally, in *step 6* and *step 7* , we introduce additional markup
    to display the results of the auto-complete operation. We render a list of found
    names, starting with the same set of characters that the user entered, if the
    API returns any.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤5**中，我们增强了**IntroduceYourself**的标记。我们通过移除**@onfocusout**事件并替换为**@bind:after**指令来细化输入字段的绑定逻辑，该指令在绑定完成后立即调用**AutocompleteAsync()**方法。通过这种设置，我们确保每次用户修改输入时，都会从API请求一组新的自动完成建议。最后，在**步骤6**和**步骤7**中，我们引入了额外的标记来显示自动完成操作的结果。我们渲染一个找到的名称列表，以用户输入的相同字符集开始，如果API返回任何结果。
- en: There’s more…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'In our example, we utilized the **[Inject]** attribute to inject **SuggestionsApi**
    into a component. However, Blazor provides additional methods for service injection.
    Let’s review all of them:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了**[Inject]**属性将**SuggestionsApi**注入到组件中。然而，Blazor还提供了其他服务注入方法。让我们回顾一下所有这些方法：
- en: 'You will commonly use the **[Inject]** attribute when injecting services within
    the **@code** block of a **.** **razor** file:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在**.** **razor**文件的**@code**块中注入服务时，你通常会使用**[Inject]**属性：
- en: '[PRE19]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You would also use the **[Inject]** attribute if you were adopting a code-behind
    approach, where you separate your Blazor component’s logic in a **.** **cs** file:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你采用代码后置（code-behind）方法，你也会使用**[Inject]**属性，其中你将Blazor组件的逻辑分离到一个**.** **cs**文件中：
- en: '[PRE20]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When working in a code-behind fashion, you can also leverage a **constructor
    injection** pattern and avoid using any attributes at all:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当以代码后置方式工作时，你还可以利用构造函数注入模式，并且根本不需要使用任何属性：
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Lastly, Blazor allows injecting services directly within the component’s markup
    – in that case, you would use the **@** **inject** directive:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，Blazor允许在组件的标记中直接注入服务 - 在这种情况下，你会使用**@** **inject**指令：
- en: '[PRE22]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All those methods serve the same purpose but accommodate various coding styles
    and preferences. None is better than the other, so choose what best fits the structure
    and organization of your code base.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都服务于相同的目的，但适应了不同的编码风格和偏好。没有哪一个比另一个更好，所以选择最适合你代码库结构和组织的选项。
- en: Customizing get and set binding logic
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义获取和设置绑定逻辑
- en: Data binding is not just about connecting a UI element to a data source. It’s
    also about how data is retrieved and updated. Customizing these **get** and **set**
    operations makes state management and data flow more flexible. In this recipe,
    I’ll guide you through the caveats of using **get** and **set** explicitly and
    executing asynchronous logic when setting values. These mechanisms will allow
    you to simplify your code and take even greater control of the interactivity of
    your Blazor application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定不仅仅是将UI元素连接到数据源。它还涉及到数据的检索和更新方式。自定义这些**get**和**set**操作可以使状态管理和数据流更加灵活。在本食谱中，我将指导你了解显式使用**get**和**set**的注意事项，以及在设置值时执行异步逻辑。这些机制将允许你简化代码，并更好地控制Blazor应用程序的交互性。
- en: Let’s implement a simple text field with explicit **get** and **set** operations
    so we can execute additional, asynchronous logic as binding is commencing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的文本字段，具有显式的**get**和**set**操作，这样我们就可以在绑定开始时执行额外的异步逻辑。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This time, we will take a shortcut with preparations for this upcoming recipe:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将通过简化准备工作来为即将到来的食谱做准备：
- en: Create a **Recipe04** directory – this will be your working directory
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Recipe04**目录 - 这将是你的工作目录
- en: Copy your **IntroduceYourself** component from the *Performing asynchronous
    actions after binding* recipe or copy its implementation from the **Chapter02**
    / **Recipe03** directory of the GitHub repository
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*执行绑定后的异步操作*食谱中复制你的**IntroduceYourself**组件，或者从GitHub仓库的**Chapter02**/ **Recipe03**目录中复制其实现。
- en: Next to **Recipe04** , copy the **Chapter02** / **Data** directory from the
    GitHub repository, containing the objects required in this recipe
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**Recipe04**旁边，从GitHub仓库复制**Chapter02**/ **Data**目录，其中包含本食谱所需的对象
- en: How to do it…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To customize **get** and **set** binding logic, follow these instructions:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要自定义**get**和**set**绑定逻辑，请遵循以下说明：
- en: 'Locate the **input** field within the **IntroduceYourself** component’s markup.
    Keep the **@bind:event** directive but replace others with custom **@bind:get**
    and **@** **bind:set** logic:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**IntroduceYourself**组件的标记中定位**input**字段。保留**@bind:event**指令，但将其他指令替换为自定义的**@bind:get**和**@**
    **bind:set**逻辑：
- en: '[PRE23]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Navigate to the **@code** block of **IntroduceYourself** and adapt the **AutocompleteAsync()**
    method to align with a setter pattern, enforced by the **@** **bind:set** directive:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**IntroduceYourself**的**@code**块，并调整**AutocompleteAsync()**方法以符合由**@** **bind:set**指令强制执行的setter模式：
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we update the binding logic on the **input** field. We keep the
    **oninput** event because we want our methods to execute as the user types but
    we replace the other directives with **@bind:get** and **@bind:set** . We use
    **@bind:get** to specify where Blazor should retrieve the input value from – which
    in our case is just a reference to the **User** variable. With the **@bind:set**
    directive, we define the logic to execute when Blazor binds the input value to
    the component’s state. That’s when we trigger the **AutocompleteAsync()** method.
    At this point, your IDE should highlight a compilation error.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们更新了**input**字段的绑定逻辑。我们保留**oninput**事件，因为我们希望我们的方法在用户输入时执行，但我们用**@bind:get**和**@bind:set**替换了其他指令。我们使用**@bind:get**来指定Blazor应从哪里检索输入值——在我们的例子中，这只是对**User**变量的引用。通过**@bind:set**指令，我们定义了当Blazor将输入值绑定到组件状态时要执行的逻辑。那就是我们触发**AutocompleteAsync()**方法的时候。此时，你的IDE应该会突出显示一个编译错误。
- en: 'Typically, a **set** method in C# receives a **value** object by default:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，C#中的**set**方法默认接收一个**value**对象：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In Blazor, the method used for **@bind:set** must follow a similar pattern.
    The difference is that we can define the name of the incoming **value** object,
    offering greater control and clarity. So, in *step 2* , we extend **AutocompleteAsync()**
    by adding a **value** parameter and keeping it in line with the conventional **get**
    - **set** pattern. Pay extra attention to the parameter type consistency. Since
    we bound **input** to the **User** object of type **string** , the **AutocompleteAsync()**
    method also expects a string. If, for instance, you were binding to an **Age**
    variable of type **int** , your binding method would need to accept an **int**
    parameter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blazor中，用于**@bind:set**的方法必须遵循类似的模式。区别在于我们可以定义传入的**value**对象的名称，从而提供更大的控制和清晰度。因此，在*步骤
    2*中，我们通过添加**value**参数扩展**AutocompleteAsync()**，并保持与传统的**get** - **set**模式一致。请特别注意参数类型的一致性。由于我们将**input**绑定到类型为**string**的**User**对象，因此**AutocompleteAsync()**方法也期望一个字符串。例如，如果你将绑定到类型为**int**的**Age**变量，你的绑定方法需要接受一个**int**参数。
- en: There’s more…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: So why do **@bind:after** and **@bind:set** both exist if they do virtually
    the same thing? The execution time of each event is critical. When you need to
    execute additional logic, often asynchronous, using the default binding operation,
    **@bind:after** , should be your choice as it spares you the complexity of persisting
    the incoming value manually. On the other hand, **@bind:set** provides more flexibility
    as it’s executed upon setting the binding value. It enables the integration of
    validation logic, including asynchronous operations, into the binding process.
    Crucially, **@bind:set** allows you to assess the incoming value and, based on
    the outcome of any validation, decide whether to discard or accept it before it
    becomes part of the component state. Both features are invaluable for ensuring
    data integrity and implementing sophisticated validation mechanisms in your Blazor
    applications.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么**@bind:after**和**@bind:set**都存在，尽管它们几乎做的是同一件事？每个事件的执行时间至关重要。当你需要使用默认的绑定操作**@bind:after**执行额外的逻辑，通常是异步的，你应该选择它，因为它可以避免你手动持久化传入值的复杂性。另一方面，**@bind:set**提供了更多的灵活性，因为它在设置绑定值时执行。它允许将验证逻辑（包括异步操作）集成到绑定过程中。关键的是，**@bind:set**允许你在任何验证结果的基础上评估传入的值，并在它成为组件状态的一部分之前决定是否丢弃或接受它。这两个功能对于确保数据完整性和在Blazor应用程序中实现复杂的验证机制都非常有价值。
- en: Simplifying binding with the bind-Value pattern
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用bind-Value模式简化绑定
- en: The **bind-Value** pattern is a game-changer in simplifying the linking process
    of your UI elements to data properties. It enhances the clarity and conciseness
    of your code by reducing the boilerplate often associated with handling two-way
    data binding. In this recipe, I will guide you through a practical example, showcasing
    the pattern’s utility in creating more maintainable and simple code, ultimately
    enhancing your development workflow.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**bind-Value**模式是简化UI元素与数据属性链接过程的一个变革性工具。它通过减少与双向数据绑定相关的样板代码，提高了代码的清晰性和简洁性。在本食谱中，我将通过一个实际示例指导您，展示该模式在创建更易于维护和简单的代码中的实用性，从而最终提升您的开发工作流程。'
- en: Let’s implement a component that allows binding directly to its parameters in
    a structure similar to the standard binding to HTML elements.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个组件，它允许直接绑定到其参数，其结构类似于标准绑定到HTML元素。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we start implementing a component that enables the **bind-Value** pattern,
    do the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现启用**bind-Value**模式的组件之前，执行以下操作：
- en: Create a **Recipe05** directory – this will be your working directory
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Recipe05**目录——这将成为您的工作目录
- en: Next to **Recipe05** , copy the **Chapter02** / **Data** directory from the
    GitHub repository, containing **SkillLevel** and **DataSeed** , required in this
    recipe
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**Recipe05**旁边，从GitHub仓库复制**Chapter02**/ **Data**目录，其中包含**SkillLevel**和**DataSeed**，这是本食谱所需的。
- en: How to do it…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to apply the **bind-Value** binding pattern:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤应用**bind-Value**绑定模式：
- en: 'Create an **IntroductionForm** component and add the required assembly reference
    at the top:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**IntroductionForm**组件并在顶部添加所需的程序集引用：
- en: '[PRE26]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the **@code** block of **IntroductionForm** , declare a **string** parameter
    for **Name** . Alongside it, add **EventCallback<string>** to communicate changes
    to the **Name** value:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**IntroductionForm**的**@code**块中，声明一个**string**参数用于**Name**。在其旁边，添加**EventCallback<string>**以将**Name**值的更改通知：
- en: '[PRE27]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, right below **Name** and **NameChanged** , add a **Skill** and an
    **EventCallback<SkillLevel>** parameters to manage the skill level state:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，在**Name**和**NameChanged**下方，添加一个**Skill**和一个**EventCallback<SkillLevel>**参数来管理技能级别状态：
- en: '[PRE28]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Still within the **@code** block, implement a method invoking the **NameChanged**
    callback and propagating changes to the **Name** value:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**@code**块中，实现一个调用**NameChanged**回调并传播**Name**值更改的方法：
- en: '[PRE29]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lastly, complete the **@code** block with another method, handling changes
    of the **Skill** value, that retrieves the **ChangeEventArgs** parameter and sets
    the skill level based on the resolved value and underlying **DataSeed.SkillLevels**
    data source:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在**@code**块中添加另一个方法，处理**Skill**值的更改，该方法检索**ChangeEventArgs**参数并根据解析的值和底层的**DataSeed.SkillLevels**数据源设置技能级别：
- en: '[PRE30]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the **IntroductionForm** markup, below **@using** , add a section where
    the user can input their name. Declare the binding to occur on the **oninput**
    event and set it to trigger the **OnNameChanged** method after the binding is
    complete:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**IntroductionForm**标记中，在**@using**下方添加一个用户可以输入其姓名的部分。声明绑定将在**oninput**事件上发生，并在绑定完成后触发**OnNameChanged**方法：
- en: '[PRE31]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add another markup section below allowing you to select the user’s skill level.
    Utilize the **DataSeed.SkillLevels** data source to populate the selection options
    and ensure that the binding of selection changes occurs with the **onchange**
    event:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下方添加另一个标记部分，允许您选择用户的技能级别。利用**DataSeed.SkillLevels**数据源来填充选择选项，并确保选择更改的绑定与**onchange**事件一起发生：
- en: '[PRE32]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a new **IntroduceYourself** routable component, rendering in an **InteractiveWebAssembly**
    mode, and reference the data objects assembly:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**IntroduceYourself**可路由组件，以**InteractiveWebAssembly**模式渲染，并引用数据对象程序集：
- en: '[PRE33]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the **@code** block, initialize **Name** and **Skill** variables to capture
    the user input and generate the greeting:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**@code**块中，初始化**Name**和**Skill**变量以捕获用户输入并生成问候语：
- en: '[PRE34]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Still within the **@code** block, implement an **IsGreetingReady** method,
    allowing you to check whether the greeting is ready to render:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**@code**块中，实现一个**IsGreetingReady**方法，允许您检查问候语是否准备好渲染：
- en: '[PRE35]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the **IntroduceYourself** markup, embed **IntroductionForm** and leverage
    the **bind-Value** pattern to dynamically bind the **Name** and **Skill** parameters
    to the corresponding target variables:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**IntroduceYourself**标记中，嵌入**IntroductionForm**并利用**bind-Value**模式动态绑定**Name**和**Skill**参数到相应的目标变量：
- en: '[PRE36]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Complete the **IntroduceYourself** markup by adding a section separator and
    conditional rendering of the user greeting, when it’s ready:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一个部分分隔符和条件渲染用户问候，当它准备好时，完成**IntroduceYourself**标记：
- en: '[PRE37]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we create an **IntroductionForm** component and reference the
    assembly with sample data at the top. In *step 2* , we define a pair of parameters
    of type **string** and **EventCallback<string>** , that we will bind to the form,
    and we intentionally call them **Name** and **NameChanged** respectively. In *step
    3* , we add a similar pair to handle the skill level and name them **Skill** and
    **SkillChanged** respectively. The pairing of a value of type **T** and a matching
    **EventCallback<T>** handler forms the basis of the **bind-Value** pattern. Similar
    to recognizing **ChildContent** implicitly, when working with **RenderFragment**
    , Blazor’s code generators recognize **T** and **EventCallback<T>** and compile
    the **@bind-Value** directive. In *step 4* , we declare an **OnNameChanged()**
    method to invoke the intended **EventCallback** and propagate the changes in **Name**
    . To handle value changes of the **Skill** parameter, we implement a bit more
    complex logic in *step 5* . We intercept a **ChangeEventArgs** object that carries
    the selected option’s value, which we use to retrieve the corresponding **SkillLevel**
    object from the **DataSeed.SkillLevels** collection. We then pass this value to
    the intended **EventCallback** handler.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1步*中，我们创建了一个**IntroductionForm**组件，并在顶部引用了包含样本数据的汇编。在*第2步*中，我们定义了一对类型为**string**和**EventCallback<string>**的参数，我们将它们绑定到表单上，并且故意将它们命名为**Name**和**NameChanged**。在*第3步*中，我们添加了一对类似的参数来处理技能水平，并将它们命名为**Skill**和**SkillChanged**。类型为**T**的值与其匹配的**EventCallback<T>**处理器的配对构成了**bind-Value**模式的基础。类似于隐式识别**ChildContent**，当使用**RenderFragment**时，Blazor的代码生成器会识别**T**和**EventCallback<T>**并编译**@bind-Value**指令。在*第4步*中，我们声明了一个**OnNameChanged()**方法来调用预期的**EventCallback**并传播**Name**的变化。为了处理**Skill**参数的值变化，我们在*第5步*中实现了一些更复杂的逻辑。我们拦截了一个携带所选选项值的**ChangeEventArgs**对象，我们使用它从**DataSeed.SkillLevels**集合中检索相应的**SkillLevel**对象。然后我们将此值传递给预期的**EventCallback**处理器。
- en: With the logic in place, in *step 6* , we proceed to the **IntroductionForm**
    markup. We add a simple **input** field and bind it to the **Name** parameter.
    We also hook up the **OnNameChanged()** method, so it’s triggered after the binding
    completes. In *step 7* , we construct a **select** field to allow the user to
    choose their skill level. We render a neutral option, displaying **-** , and skill
    options from the **DataSeed.SkillLevels** collection. We wire the **@onchanged**
    event of the **select** field to the **OnSkillChanged()** method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑设置到位后，在*第6步*中，我们继续进行到**IntroductionForm**标记。我们添加了一个简单的**输入**字段并将其绑定到**Name**参数。我们还连接了**OnNameChanged()**方法，以便在绑定完成后触发。在*第7步*中，我们构建了一个**选择**字段，允许用户选择他们的技能水平。我们渲染了一个中性的选项，显示**-**，以及来自**DataSeed.SkillLevels**集合的技能选项。我们将**选择**字段的**@onchanged**事件连接到**OnSkillChanged()**方法。
- en: In *step 8* , we create a routable **IntroduceYourself** component that renders
    in an **InteractiveWebAssembly** mode. We also reference the sample data assembly,
    leveraging the **@using** directive. In *step 9* , we initialize a **@code** block
    within the **IntroduceYourself** component and declare **Name** and **Skill**
    backing properties for binding and generating the user’s greeting. In *step 10*
    , we implement a simple **IsGreetingReady** method that checks whether both **Name**
    and **Skill** have meaningful values and a greeting can be safely generated.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8步*中，我们创建了一个可路由的**IntroduceYourself**组件，以**InteractiveWebAssembly**模式渲染。我们还引用了示例数据汇编，利用了**@using**指令。在*第9步*中，我们在**IntroduceYourself**组件内初始化一个**@code**块，并声明**Name**和**Skill**后端属性以进行绑定和生成用户的问候。在*第10步*中，我们实现了一个简单的**IsGreetingReady**方法，该方法检查**Name**和**Skill**是否具有有意义的值，并且可以安全地生成问候。
- en: In *step 11* , we jump to the **IntroduceYourself** markup and witness the **bind-Value**
    pattern in action. Since **IntroductionForm** exposes **Name** and **Skill** parameters
    with pattern-matching event callbacks, we can dynamically bind them using **@bind-Name**
    and **@bind-Skill** . Your IDE will recognize this pattern automatically and should
    even suggest these directives. We finalize the markup in *step 12* by adding a
    conditional rendering of a greeting message built from the current **Name** and
    **Skill** values.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤11*中，我们跳转到**IntroduceYourself**标记并见证**bind-Value**模式的作用。由于**IntroductionForm**公开了具有模式匹配事件回调的**Name**和**Skill**参数，我们可以使用**@bind-Name**和**@bind-Skill**动态绑定它们。您的IDE将自动识别此模式，甚至可能建议这些指令。我们在*步骤12*中通过添加基于当前**Name**和**Skill**值的问候消息的条件渲染来最终确定标记。
- en: The **bind-Value** pattern encapsulates binding logic and validation within
    a component, greatly simplifying unit testing and enhancing the parent component’s
    cleanliness and robustness. It only requires the parent component to provide backing
    variables, streamlining the development process. It’s even more powerful as all
    the binding directives that we’ve covered ( **@bind:after** , **@bind:get** ,
    **@bind:set** ), you can also pair with the **bind-Value** pattern.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**bind-Value**模式封装了组件内的绑定逻辑和验证，极大地简化了单元测试，并增强了父组件的整洁性和健壮性。它只需要父组件提供后端变量，从而简化了开发过程。它甚至更强大，因为我们所涵盖的所有绑定指令（**@bind:after**，**@bind:get**，**@bind:set**），都可以与**bind-Value**模式搭配使用。'
- en: Binding with an external data provider
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与外部数据提供者绑定
- en: When building web applications that interact with external data sources, it’s
    common to trigger API calls in response to user input. However, this can lead
    to a flood of requests, straining the API and degrading the user’s experience.
    To address that challenge, we’ll implement input **throttling** – a technique
    that moderates the rate at which requests are sent based on user input. In this
    recipe, I will guide you through setting up input throttling in a Blazor component,
    ensuring efficient and responsible usage of external APIs. You’ll create more
    robust and user-friendly applications capable of handling a heavy load of user
    interactions without overwhelming your data providers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建与外部数据源交互的Web应用程序时，通常会在用户输入时触发API调用。然而，这可能导致请求洪水，使API过载并降低用户体验。为了应对这一挑战，我们将实现输入**节流**——一种根据用户输入调节请求发送速率的技术。在本食谱中，我将指导您在Blazor组件中设置输入节流，确保高效且负责任地使用外部API。您将创建更健壮、用户友好的应用程序，能够处理大量用户交互而不会压垮您的数据提供者。
- en: Let’s implement a simple text field that uses throttling to limit calls to the
    external API and seamlessly waits for a user to finish typing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的文本字段，该字段使用节流来限制对外部API的调用，并无缝等待用户完成输入。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you dive into throttling implementation, do the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始节流实现之前，请执行以下操作：
- en: Create a **Recipe06** directory – this will be your working directory
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Recipe06**目录——这将作为您的工作目录
- en: Next to **Recipe06** , copy the **Chapter02** / **Data** directory from the
    GitHub repository, containing a **SuggestionsApi** class required in this recipe
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**Recipe06**旁边，从GitHub仓库复制**Chapter02** / **Data**目录，其中包含本食谱所需的**SuggestionsApi**类
- en: Copy the **IntroduceYourself** component from the **Chapter02** / **Recipe03**
    directory of the GitHub repository
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库的**Chapter02** / **Recipe03**目录复制**IntroduceYourself**组件
- en: How to do it…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To implement throttling when calling an external API, follow these steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用外部API时实现节流，请按照以下步骤操作：
- en: 'Open the **Program** file of your application and register the **SuggestionsApi**
    service to enable communication with the API:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您应用程序的**程序**文件，并将**SuggestionsApi**服务注册以启用与API的通信：
- en: '[PRE38]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Enhance the **IntroduceYourself** component with the implementation of the
    **IDisposable** interface using the **@implements** directive, below the **@**
    **rendermode** directive:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**@implements**指令在**@** **rendermode**指令下方增强**IntroduceYourself**组件的实现**IDisposable**接口：
- en: '[PRE39]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Inside the **@code** block of the **IntroduceYourself** component, declare
    the **Timer** variable and two **TimeSpan** variables – for throttling and overall
    timeout:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**IntroduceYourself**组件的**@code**块内部，声明**Timer**变量和两个**TimeSpan**变量——用于节流和整体超时：
- en: '[PRE40]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Still within the **@code** block, implement an **OnUserInput()** method with
    a proxy logic that uses the **Timer** and **TimeSpan** variables to throttle the
    API requests encapsulated inside the **AutocompleteAsync()** method:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**@code**块内，实现一个使用**Timer**和**TimeSpan**变量进行节流的**OnUserInput()**方法，该方法使用代理逻辑来封装在**AutocompleteAsync()**方法内的API请求：
- en: '[PRE41]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To complete the **@code** block, implement the **Dispose()** lifecycle method,
    required by the **IDisposable** interface, and explicitly dispose of the **_debounceTimer**
    instance:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成**@code**块，实现**IDisposable**接口所需的**Dispose()**生命周期方法，并显式地销毁**_debounceTimer**实例：
- en: '[PRE42]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the **IntroduceYourself** markup, update the **@bind:after** directive to
    invoke the **OnUserInput()** method, where we’ve added the throttling logic:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**IntroduceYourself**标记中，更新**@bind:after**指令以调用**OnUserInput()**方法，其中我们添加了节流逻辑：
- en: '[PRE43]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we register the **SuggestionsApi** service in the application’s
    dependency injection container. If you’re following along with the entire chapter,
    you might already have **SuggestionsApi** there.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们在应用程序的依赖注入容器中注册了**SuggestionsApi**服务。如果你正在跟随整个章节，你可能已经有了**SuggestionsApi**。
- en: In *step 2* , with the help of the **@implements** directive, we enhance the
    **IntroduceYourself** component with an **IDisposable** pattern. In Blazor, the
    **IDisposable** interface is used to release unmanaged resources or detach event
    handlers when disposing of a component. **IDisposable** requires the implementation
    of a **Dispose()** method, which Blazor will then automatically invoke when a
    component is removed from the UI, ensuring proper cleanup and preventing memory
    leaks. Without the **Dispose()** method in place, your IDE will highlight compilation
    errors. We will address that in subsequent steps.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中，借助**@implements**指令，我们使用**IDisposable**模式增强了**IntroduceYourself**组件。在Blazor中，**IDisposable**接口用于在销毁组件时释放未管理资源或断开事件处理器。**IDisposable**需要实现一个**Dispose()**方法，Blazor将在组件从UI中移除时自动调用该方法，确保适当的清理并防止内存泄漏。如果没有实现**Dispose()**方法，你的IDE将突出显示编译错误。我们将在后续步骤中解决这个问题。
- en: 'In *step 3* , we lay the groundwork for throttling logic. In the **@code**
    block of the **IntroduceYourself** component, we initialize two key variables:
    **_throttle** , which defines the idle time (500 milliseconds in our example)
    between user interactions and API calls, and **_timeout** , which sets an overall
    timeout for the external communication. We also declare a **_debounceTimer** variable
    of type **Timer** , which is the backbone of managing the frequency of API calls.
    The **Timer** class wraps a scheduler that delays the execution of a method for
    a specified time, making it ideal for throttling. In *step 4* , still within the
    **@code** block, we implement an **OnUserInput()** method with throttling proxy
    logic. First, we stop the currently scheduled operation, by disposing of the **_debounceTimer**
    instance, to avoid any overlapping executions. Next, we instantiate a new **Timer**
    object, wrapping the existing **AutocompleteAsync()** method within the **InvokeAsync()**
    method for thread safety. As we don’t need to maintain any state between timer
    invocations, we pass **null** for the state object and complete the **_debounceTimer**
    initialization with the **_throttle** and **_timeout** variables. In *step 5*
    , we complete the **@code** block by implementing the missing **Dispose()** method
    to gracefully dispose of the **_debounceTimer** instance. The compilation errors
    should now be gone.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 3**中，我们为节流逻辑打下基础。在**IntroduceYourself**组件的**@code**块中，我们初始化了两个关键变量：**_throttle**，它定义了用户交互和API调用之间的空闲时间（在我们的示例中为500毫秒），以及**_timeout**，它为外部通信设置了一个总超时时间。我们还声明了一个**_debounceTimer**变量，其类型为**Timer**，这是管理API调用频率的骨干。**Timer**类封装了一个调度器，它将方法的执行延迟指定的时间，这使得它非常适合节流。在**步骤
    4**中，仍然在**@code**块内，我们实现了一个具有节流代理逻辑的**OnUserInput()**方法。首先，我们通过销毁**_debounceTimer**实例来停止当前计划的操作，以避免任何重叠执行。接下来，我们实例化一个新的**Timer**对象，将现有的**AutocompleteAsync()**方法包装在**InvokeAsync()**方法中以确保线程安全。由于我们不需要在定时器调用之间维护任何状态，我们传递**null**作为状态对象，并使用**_throttle**和**_timeout**变量完成**_debounceTimer**的初始化。在**步骤
    5**中，我们通过实现缺失的**Dispose()**方法来完成**@code**块，以优雅地销毁**_debounceTimer**实例。现在应该没有编译错误了。
- en: Lastly, in *step 6* , we slightly update the **input** field in the **IntroduceYourself**
    markup. Rather than invoking **AutocompleteAsync()** after the binding completes,
    we update the **@bind:after** attribute to invoke the **OnUserInput()** method,
    containing our throttling logic. Now, every keystroke goes through the throttling
    mechanism, optimizing application responsiveness and reducing the load on the
    external API.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*第6步*中，我们稍微更新了**IntroduceYourself**标记中的**输入**字段。而不是在绑定完成后调用**AutocompleteAsync()**，我们将**@bind:after**属性更新为调用**OnUserInput()**方法，其中包含我们的节流逻辑。现在，每个按键都通过节流机制，优化应用程序的响应速度并减少对外部API的负载。
