<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer042">
<h1 id="_idParaDest-121"><em class="italic"><a id="_idTextAnchor120"/>Chapter 7</em>: Task Parallel Library (TPL) and Dataflow</h1>
<p>The <strong class="bold">Task Parallel Library</strong> (<strong class="bold">TPL</strong>) <strong class="bold">dataflow library</strong> contains building blocks to orchestrate asynchronous workflows in .NET. This chapter will introduce the TPL Dataflow library, describe the types of <strong class="bold">dataflow blocks</strong> in the library, and illustrate some common patterns for using dataflow blocks through hands-on examples.</p>
<p>The dataflow library can be useful when processing large amounts of data in multiple stages or when your application receives data in a continuous stream. The dataflow blocks provide a fantastic way of implementing the <strong class="bold">producer/consumer design pattern</strong>. </p>
<p>To understand this, we will create a sample project that implements this pattern and examine other real-world uses of the dataflow library.</p>
<p class="callout-heading">Note</p>
<p class="callout">It’s important to know that the TPL Dataflow library isn’t distributed as part of the .NET runtime or SDK. It’s available as a NuGet package from Microsoft. We will add it to our sample projects with <strong class="bold">NuGet Package Explorer</strong> (<strong class="bold">NPE</strong>) in Visual Studio.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Introducing the TPL Dataflow library</li>
<li>Implementing the producer/consumer pattern</li>
<li>Creating a data pipeline with multiple blocks</li>
<li>Manipulating data from multiple data sources</li>
</ul>
<p>By the end of this chapter, you will understand the purpose of each type of dataflow block and be able to add the dataflow library to your projects, where appropriate. </p>
<p>You will also know when dataflow blocks do not provide an advantage over simpler parallel programming alternatives, such as <strong class="source-inline">Parallel.ForEach</strong>.</p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows developers:</p>
<ul>
<li>Visual Studio 2022 version 17.0 or later</li>
<li>.NET 6</li>
<li>To complete the WPF sample, you will need to install the .NET desktop development workload for Visual Studio</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later, JetBrains Rider, or Visual Studio Code will work just as well.</p>
<p>The code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07</a>.</p>
<p>Let’s get started by discussing the TPL Dataflow library and why it can be a great way to implement parallel programming in .NET.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/>Introducing the TPL Dataflow library</h1>
<p>The <a id="_idIndexMarker350"/>TPL Dataflow library has been available for as long as TPL itself. It was released in 2010 after <strong class="bold">.NET Framework 4.0</strong> reached its RTM milestone. The members of the dataflow library are part of the <strong class="source-inline">System.Threading.Tasks.Dataflow</strong> namespace. The dataflow library is intended to build on the basics of parallel programming that are provided in TPL, expanding to address data flow scenarios (hence the name of the library). The dataflow library is made up of foundational classes<a id="_idIndexMarker351"/> called <strong class="bold">blocks</strong>. Each data flow block is responsible for a particular action or step in the overall flow.</p>
<p>The dataflow library consists of three basic types of blocks:</p>
<ul>
<li><strong class="bold">Source blocks</strong>: These<a id="_idIndexMarker352"/> blocks implement the <strong class="source-inline">ISourceBlock&lt;TOutput&gt;</strong> interface. Source<a id="_idIndexMarker353"/> blocks can have their data read from the workflow you define.</li>
<li><strong class="bold">Target blocks</strong>: This<a id="_idIndexMarker354"/> type of block implements the <strong class="source-inline">ITargetBlock&lt;TInput&gt;</strong> interface<a id="_idIndexMarker355"/> and is a data receiver.</li>
<li><strong class="bold">Propagator blocks</strong>: These <a id="_idIndexMarker356"/>blocks act as both source and target. They<a id="_idIndexMarker357"/> implement the <strong class="source-inline">IPropagatorBlock&lt;TInput, TOutput&gt;</strong> interface. Applications can read data from these blocks and write to them.</li>
</ul>
<p>When you connect multiple dataflow blocks to create a workflow, the resulting system is referred to<a id="_idIndexMarker358"/> as a <strong class="bold">dataflow pipeline</strong>. You can connect a source block to a target block with the <strong class="source-inline">ISourceBlock&lt;TOutput&gt;.LinkTo</strong> method. This is where propagator blocks can fit in the middle of a pipeline. They can act as both the source and target of a link in the workflow. If a message from a source block can be processed by more than one target, you can add filtering to examine the properties of the object provided by the source to determine which target or propagator block should receive the object.</p>
<p>The objects that are passed between dataflow blocks are commonly referred to as <strong class="bold">messages</strong>. You can <a id="_idIndexMarker359"/>think of a dataflow pipeline <a id="_idIndexMarker360"/>as a <strong class="bold">network</strong> or messaging system. The units of data that flow through the network are the messages. Each block is responsible for reading, writing, or transforming each message in some way.</p>
<p>To send a <a id="_idIndexMarker361"/>message to a target block, you can use the <strong class="source-inline">Post</strong> method to send it synchronously or the <strong class="source-inline">SendAsync</strong> method to send it asynchronously. In source blocks, messages can be received with the <strong class="source-inline">Receive</strong>, <strong class="source-inline">TryReceive</strong>, and <strong class="source-inline">ReceiveAsync</strong> methods. The <strong class="source-inline">Receive</strong> and <strong class="source-inline">TryReceive</strong> methods are both synchronous. The <strong class="source-inline">Choose</strong> method will monitor multiple source blocks for data and return a message from the first source to provide data.</p>
<p>To offer a <a id="_idIndexMarker362"/>message from a source block to a target block, the source can call the <strong class="source-inline">OfferData</strong> method of a target. The <strong class="source-inline">OfferData</strong> method returns a <strong class="source-inline">DataflowMessageStatus</strong> enum that has several possible values:</p>
<ul>
<li><strong class="source-inline">Accepted</strong>: The message was accepted and will be processed by the target.</li>
<li><strong class="source-inline">Declined</strong>: The message was declined by the target. The source block still owns the message and cannot process its next message until the current message has been accepted by another target.</li>
<li><strong class="source-inline">DecliningPermanently</strong>: The message was declined, and the target is no longer available for processing. All subsequent messages will be declined by the current target. Source blocks will unlink from a target that returns this status.</li>
<li><strong class="source-inline">Postponed</strong>: Accepting the message has been postponed. It may be accepted by the target at a later time. In this case, the source can wait or attempt to pass the message to an alternative target block.</li>
<li><strong class="source-inline">NotAvailable</strong>: The <a id="_idIndexMarker363"/>message was no longer available when the target tried to accept it. This can occur when the target attempts to accept a message after it had been postponed, but the source block has already passed the message to a different target block.</li>
</ul>
<p>Dataflow blocks support the concept of <strong class="bold">completion</strong> by providing a <strong class="source-inline">Complete</strong> method and a <strong class="source-inline">Completion</strong> property. The <strong class="source-inline">Complete</strong> method is called to request completion on a block, while the <strong class="source-inline">Completion</strong> property returns a <strong class="source-inline">Task</strong>, known as the block’s <strong class="bold">completion task</strong>. These<a id="_idIndexMarker364"/> completion members are part of the <strong class="source-inline">IDataflowBlock</strong> interface, which is inherited by both <strong class="source-inline">ISourceBlock</strong> and <strong class="source-inline">ITargetBlock</strong>. </p>
<p>The completion task <a id="_idIndexMarker365"/>can be used to determine if a block has encountered an error or has been canceled. Let’s see how:</p>
<ol>
<li>The simplest way to handle errors encountered by a dataflow block is to call <strong class="source-inline">Wait</strong> on the <strong class="source-inline">Completion</strong> property of the block and handle the <strong class="source-inline">AggregateException</strong> exception type in the <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block:<p class="source-code">try</p><p class="source-code">{</p><p class="source-code">   inputBlock.Completion.Wait();</p><p class="source-code">}</p><p class="source-code">catch (AggregateException ae)</p><p class="source-code">{</p><p class="source-code">   ae.Handle(e =&gt;</p><p class="source-code">   {</p><p class="source-code">      Console.WriteLine($"Error processing input - </p><p class="source-code">          {e.GetType().Name}: {e.Message}");</p><p class="source-code">   });</p><p class="source-code">}</p></li>
<li>If you want to do the same thing without using the blocking <strong class="source-inline">Wait</strong> call, you can <strong class="source-inline">await</strong> the <a id="_idIndexMarker366"/>completion task and handle the <strong class="source-inline">Exception</strong> type:<p class="source-code">try</p><p class="source-code">{</p><p class="source-code">    await inputBlock.Completion;</p><p class="source-code">}</p><p class="source-code">catch (Exception e)</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine($"Error processing input - </p><p class="source-code">        {e.GetType().Name}: {e.Message}");</p><p class="source-code">}</p></li>
<li>Another alternative is to use the <strong class="source-inline">ContinueWith</strong> method on the completion task. Inside the continuation block, you can check the status of the task to determine if it is <strong class="source-inline">Faulted</strong> or <strong class="source-inline">Canceled</strong>:<p class="source-code">try</p><p class="source-code">{</p><p class="source-code">    <strong class="bold">inputBlock.ContinueWith(task =&gt;</strong></p><p class="source-code"><strong class="bold">    {</strong></p><p class="source-code"><strong class="bold">        Console.WriteLink($"Task completed with a </strong></p><p class="source-code">            <strong class="bold">status of {task.Status}");</strong></p><p class="source-code"><strong class="bold">    });</strong></p><p class="source-code">    await inputBlock.Completion;</p><p class="source-code">}</p><p class="source-code">catch (Exception e)</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine($"Error processing input - </p><p class="source-code">        {e.GetType().Name}: {e.Message}");</p><p class="source-code">}</p></li>
</ol>
<p>We will see more comprehensive examples of dataflow block use when we create a sample project using the producer/consumer pattern in the next section. Before we examine the types of dataflow blocks, let’s discuss why Microsoft created the library.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/>Why use the TPL Dataflow library?</h2>
<p>The <a id="_idIndexMarker367"/>TPL dataflow library was created by Microsoft as a means of orchestrating asynchronous data processing workflows. Data flows into the first dataflow block in the pipeline from a data source. The source can be a database, a local or network folder, a camera, or just about any other type of input device that .NET can access. One or more blocks can be part of the pipeline, with each being responsible for a single operation. The following diagram illustrates two abstractions of dataflow pipelines:</p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<img alt="Figure 7.1 – Dataflow pipeline examples " height="582" src="image/Figure_7.1_B18552.jpg" width="1167"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Dataflow pipeline examples</p>
<p>One <a id="_idIndexMarker368"/>real-world example you can consider is using a webcam to capture image frames. In a two-step flow, as shown in <em class="italic">Example 1</em>, consider the webcam as <strong class="bold">Data Input</strong>. <strong class="bold">Dataflow Block 1</strong> could perform some image processing to optimize the image appearance, while <strong class="bold">Dataflow Block 2</strong> will call an <strong class="bold">Azure Cognitive Services</strong> API to identify objects in each image. <strong class="bold">Result</strong> would contain a new .NET class for each input image containing the image binary data and properties that contain the identified objects within each image.</p>
<p>Next, let’s learn about the types of blocks available in the dataflow library.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Types of dataflow blocks</h2>
<p>There are<a id="_idIndexMarker369"/> nine predefined blocks in the dataflow library. These can be divided into three different categories. The first category is <strong class="bold">buffering blocks</strong>.</p>
<h3>Buffering blocks</h3>
<p>The<a id="_idIndexMarker370"/> purpose of <strong class="bold">buffering blocks</strong> is <a id="_idIndexMarker371"/>to buffer input data to be consumed. Buffering blocks are all propagator blocks, meaning they can be both a data source and <a id="_idIndexMarker372"/>target in a dataflow pipeline. There are three <a id="_idIndexMarker373"/>types of buffering blocks: <strong class="source-inline">BufferBlock&lt;T&gt;</strong>, <strong class="source-inline">BroadcastBlock&lt;T&gt;</strong>, and <strong class="source-inline">WriteOnceBlock&lt;T&gt;</strong>.</p>
<h4>BufferBlock</h4>
<p><strong class="source-inline">BufferBlock&lt;T&gt;</strong> is an <a id="_idIndexMarker374"/>asynchronous queuing mechanism that implements a <strong class="bold">first-in, first-out</strong> (<strong class="bold">FIFO</strong>) queue of objects. <strong class="source-inline">BufferBlock</strong> can have multiple data sources and multiple targets configured. However, each message in a <strong class="source-inline">BufferBlock</strong> can only be delivered to one target block. The message is removed from the queue after it has been successfully delivered.</p>
<p>The following snippet pushes customer names into a <strong class="source-inline">BufferBlock</strong> and subsequently reads the first five names out to the console:</p>
<pre class="source-code">BufferBlock&lt;string&gt; customerBlock = new();</pre>
<pre class="source-code">foreach (var customer in customers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    await customerBlock.SendAsync(customer.Name);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">for (int i = 0; i &lt; 5; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Console.WriteLine(await customerBlock.ReceiveAsync());</pre>
<pre class="source-code">}</pre>
<pre class="source-code">// The code could display the following output:</pre>
<pre class="source-code">//    Robert Jones</pre>
<pre class="source-code">//    Jita Smith</pre>
<pre class="source-code">//    Patty Xu</pre>
<pre class="source-code">//    Sam Alford</pre>
<pre class="source-code">//    Melissa Allen</pre>
<h4>BroadcastBlock</h4>
<p><strong class="source-inline">BroadcastBlock&lt;T&gt;</strong> is <a id="_idIndexMarker375"/>used similarly to <strong class="source-inline">BufferBlock</strong>, but it is intended to provide only the most recently posted message available to consumers. It can also be used to send the same value to many consumers. The message that’s posted to a <strong class="source-inline">BroadcastBlock</strong> is not removed after it has been received by a consumer.</p>
<p>The following snippet will read the same alert message each time the <strong class="source-inline">Receive</strong> method is called:</p>
<pre class="source-code">var alertBlock = new BroadcastBlock&lt;string&gt;(null);</pre>
<pre class="source-code">alertBlock.Post("Network is unavailable!");</pre>
<pre class="source-code">for (int i = 0; i &lt; 5; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Console.WriteLine(alertBlock.Receive());</pre>
<pre class="source-code">}</pre>
<h4>WriteOnceBlock</h4>
<p>As the name<a id="_idIndexMarker376"/> suggests, <strong class="source-inline">WriteOnceBlock&lt;T&gt;</strong> can only be written to once. After the first message has been received, all calls to <strong class="source-inline">Post</strong> or <strong class="source-inline">SendAsync</strong> will be ignored by the block. No exceptions will be thrown. The data is simply discarded.</p>
<p>The following example is similar to our <strong class="source-inline">BufferBlock</strong> snippet. However, because we’re now using a <strong class="source-inline">WriteOnceBlock</strong>, only the first customer’s name will be accepted by the block:</p>
<pre class="source-code">WriteOnceBlock&lt;string&gt; customerBlock = new();</pre>
<pre class="source-code">foreach (var customer in customers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    await customerBlock.SendAsync(customer.Name);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">Console.WriteLine(await customerBlock.ReceiveAsync());</pre>
<h3>Execution blocks</h3>
<p><strong class="bold">Execution blocks</strong> are <a id="_idIndexMarker377"/>blocks that execute a delegate method for each <a id="_idIndexMarker378"/>message that’s received. There are three types of execution blocks in the dataflow library. <strong class="source-inline">ActionBlock&lt;TInput&gt;</strong> is a <strong class="bold">target</strong> block, while <strong class="source-inline">TransformBlock&lt;TInput, TOuput&gt;</strong> and <strong class="source-inline">TransformManyBlock&lt;TInput, TOutput&gt;</strong> are both <strong class="bold">propagator</strong> blocks.</p>
<h4>ActionBlock</h4>
<p><strong class="source-inline">ActionBlock</strong> is a block <a id="_idIndexMarker379"/>that accepts either <strong class="source-inline">Action&lt;T&gt;</strong> or <strong class="source-inline">Func&lt;TInput, Task&gt;</strong> as its constructor. An action on an input message is considered complete when the action returns or the task of <strong class="source-inline">Func</strong> completes. You can use an action for synchronous delegates or <strong class="source-inline">Func</strong> for async operations.</p>
<p>In this snippet, we will output customer names to the console with <strong class="source-inline">Console.WriteLine</strong>, which is provided in an <strong class="source-inline">Action</strong>, to the block:</p>
<pre class="source-code">var customerBlock = new ActionBlock&lt;string&gt;(name =&gt; </pre>
<pre class="source-code">    Console.WriteLine(name));</pre>
<pre class="source-code">foreach (var customer in customers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">   await customerBlock.SendAsync(customer.Name);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">customerBlock.Complete();</pre>
<pre class="source-code">await customerBlock.Completion;</pre>
<h4>TransformBlock</h4>
<p><strong class="source-inline">TransformBlock&lt;TInput, TOutput&gt;</strong> is similar to <strong class="source-inline">ActionBlock</strong>. However, as a propagator block, it returns<a id="_idIndexMarker380"/> an output value for each message that’s received. The two possible delegate signatures that can be provided to the <strong class="source-inline">TransformBlock</strong> constructor are <strong class="source-inline">Func&lt;TInput, TOutput&gt;</strong> for synchronous operations and <strong class="source-inline">Func&lt;TInput, Task&lt;TOutput&gt;&gt;</strong> for asynchronous operations.</p>
<p>The following <a id="_idIndexMarker381"/>example uses a <strong class="source-inline">TransformBlock</strong> that will convert a customer name into all capitals before the first five output values are retrieved to be displayed on the console:</p>
<pre class="source-code">var toUpperBlock = new TransformBlock&lt;string, string&gt;(name </pre>
<pre class="source-code">      =&gt; name.ToUpper());</pre>
<pre class="source-code">foreach (var customer in customers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">   toUpperBlock.Push(customer.Name);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">for (int i = 0; i &lt; 5; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">   Console.WriteLine(toUpperBlock.Receive());</pre>
<pre class="source-code">}</pre>
<h4>TransformManyBlock</h4>
<p><strong class="source-inline">TransformManyBlock&lt;TInput, TOutput&gt;</strong> is similar to <strong class="source-inline">TransformBlock</strong> except that the block can <a id="_idIndexMarker382"/>return one or more values for every input value that’s received. The possible delegate signatures for <strong class="source-inline">TransformManyBlock</strong> are <strong class="source-inline">Func&lt;TInput, IEnumerable&lt;TOutput&gt;&gt;</strong> and <strong class="source-inline">Func&lt;TInput, Task&lt;IEnumerable&lt;TOutput&gt;&gt;&gt;</strong> for synchronous and asynchronous operations, respectively.</p>
<p>In this snippet, we will pass one customer name to <strong class="source-inline">TransformManyBlock</strong>, which will return an enumerable containing the individual characters in the customer’s name:</p>
<pre class="source-code">var nameCharactersBlock = new TransformManyBlock&lt;string, </pre>
<pre class="source-code">    char&gt;(name =&gt; name.ToCharArray());</pre>
<pre class="source-code">nameCharactersBlock.Post(customerName);</pre>
<pre class="source-code">for (int i = 0; i &lt; (customerName.Length; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">   Console.WriteLine(nameCharactersBlock.Receive());</pre>
<pre class="source-code">}</pre>
<h3>Grouping blocks</h3>
<p><strong class="bold">Grouping blocks</strong> can<a id="_idIndexMarker383"/> combine objects from one or more<a id="_idIndexMarker384"/> sources. There are three types of grouping blocks. <strong class="source-inline">BatchBlock&lt;T&gt;</strong> is a propagator block, while <strong class="source-inline">JoinBlock&lt;T1, T2&gt;</strong> and <strong class="source-inline">BatchedJoinBlock&lt;T1, T2&gt;</strong> are both source blocks.</p>
<h4>BatchBlock</h4>
<p><strong class="source-inline">BatchBlock</strong> accepts batches<a id="_idIndexMarker385"/> of data and produces arrays of output data. When creating a <strong class="source-inline">BatchBlock</strong>, you specify the input batch size. <strong class="source-inline">BatchBlock</strong> has a <strong class="source-inline">Greedy</strong> property in the <strong class="source-inline">dataflowBlockOptions</strong> optional constructor parameter that specifies<a id="_idIndexMarker386"/> the <strong class="bold">greedy mode</strong>:</p>
<ul>
<li>When <strong class="source-inline">Greedy</strong> is <strong class="source-inline">true</strong>, which is its default value, the block continues processing every input value as it is received and outputs an array as the batch size is reached. </li>
<li>When <strong class="source-inline">Greedy</strong> is <strong class="source-inline">false</strong>, incoming messages can be paused while an array of the batch size is being created.</li>
</ul>
<p><strong class="source-inline">Greedy</strong> mode usually performs better, but if you are coordinating input from multiple sources, you may need to<a id="_idIndexMarker387"/> use <strong class="bold">non-greedy mode</strong>.</p>
<p>In this example, <strong class="source-inline">BatchBlock</strong> separates student names into classes with a maximum size of 12:</p>
<pre class="source-code">var studentBlock = new BatchBlock&lt;string&gt;(12);</pre>
<pre class="source-code">// Assume studentList contains 20 students.</pre>
<pre class="source-code">foreach (var student in studentList)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">   studentBlock.Post(student.Name);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">// Signal that we are done adding items.</pre>
<pre class="source-code">studentBlock.Complete();</pre>
<pre class="source-code">// Print the size of each class.</pre>
<pre class="source-code">Console.WriteLine($"The number of students in class 1 is { </pre>
<pre class="source-code">    studentBlock.Receive().Count()}.");  // 12 students</pre>
<pre class="source-code">Console.WriteLine($"The number of students in class 2 is { </pre>
<pre class="source-code">    studentBlock.Receive().Count()}.");  // 8 students</pre>
<h4>JoinBlock</h4>
<p><strong class="source-inline">JoinBlock</strong> has two<a id="_idIndexMarker388"/> signatures: <strong class="source-inline">JoinBlock&lt;T1, T2&gt;</strong> and <strong class="source-inline">JoinBlock&lt;T1, T2, T3&gt;</strong>. <strong class="source-inline">JoinBlock&lt;T1, T2&gt;</strong> has <strong class="source-inline">Target1</strong> and <strong class="source-inline">Target2</strong> properties to accept inputs and returns a <strong class="source-inline">Tuple&lt;T1, T2&gt;</strong> as each pair of targets is filled. <strong class="source-inline">JoinBlock&lt;T1, T2, T3&gt;</strong> has <strong class="source-inline">Target1</strong>, <strong class="source-inline">Target2</strong>, and <strong class="source-inline">Target3</strong> properties and returns a <strong class="source-inline">Tuple&lt;T1, T2, T3&gt;</strong> as each set of targets is completed.</p>
<p><strong class="source-inline">JoinBlock</strong> also has greedy and non-greedy modes, with greedy mode being the default behavior. When you switch to non-greedy mode, all input is postponed to targets that have already received input until a complete output set is populated and sent as output.</p>
<p>In this example, we will create a <strong class="source-inline">JoinBlock</strong> to combine a person’s first name, last name, and age into the output tuple:</p>
<pre class="source-code">var joinBlock = new JoinBlock&lt;string, string, int&gt;();</pre>
<pre class="source-code">joinBlock.Target1.Post("Sally");</pre>
<pre class="source-code">joinBlock.Target1.Post("Raj");</pre>
<pre class="source-code">joinBlock.Target2.Post("Jones");</pre>
<pre class="source-code">joinBlock.Target2.Post("Gupta");</pre>
<pre class="source-code">joinBlock.Target3.Post(7);</pre>
<pre class="source-code">joinBlock.Target3.Post(23);</pre>
<pre class="source-code">for (int i = 0; i &lt; 2; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">   var data = joinBlock.Receive();</pre>
<pre class="source-code">   if (data.Item3 &lt; 18)</pre>
<pre class="source-code">   {</pre>
<pre class="source-code">         Console.WriteLine($"{data.Item1} {data.Item2} is a </pre>
<pre class="source-code">             child.");</pre>
<pre class="source-code">   }</pre>
<pre class="source-code">   else</pre>
<pre class="source-code">   {</pre>
<pre class="source-code">         Console.WriteLine($"{data.Item1} {data.Item2} is </pre>
<pre class="source-code">             an adult.");</pre>
<pre class="source-code">   }</pre>
<pre class="source-code">}</pre>
<h4>BatchedJoinBlock</h4>
<p>A <strong class="source-inline">BatchedJoinBlock</strong> is <a id="_idIndexMarker389"/>like a <strong class="source-inline">JoinBlock</strong> except the tuple in the output contains <strong class="source-inline">IList</strong> items of the size of the batch specified in the constructor: <strong class="source-inline">Tuple(IList(T1), IList(T2))</strong> or <strong class="source-inline">Tuple(IList(T1), IList(T2), IList(T3))</strong>. The batching concept is the same as it is for <strong class="source-inline">BatchBlock</strong>.</p>
<p>As an exercise, try to build on the <strong class="source-inline">JoinBlock</strong> example to add more people to the list, divide them into batches of four, and output the name of the oldest person in each batch.</p>
<p>Now that we have explored examples of all of the available dataflow blocks, let’s get into some real-world dataflow examples. In the next section, we will use some dataflow blocks to create a producer/consumer implementation.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/>Implementing the producer/consumer pattern</h1>
<p>The <a id="_idIndexMarker390"/>blocks in the TPL Dataflow library provide a fantastic platform for implementing the <strong class="bold">producer/consumer pattern</strong>. If you are not familiar with this design pattern, it involves two operations and a queue of work. The <strong class="bold">producer</strong> is the <a id="_idIndexMarker391"/>first operation. It is responsible for filling the queue with data or units of work. The <strong class="bold">consumer</strong> is<a id="_idIndexMarker392"/> responsible for taking items from the queue and acting on them in some way. There can be one or more producers and one or more consumers in the system. You can change the number of producers or consumers, depending on which part of the process is the bottleneck.</p>
<p class="callout-heading">Real-World Scenario Example</p>
<p class="callout">To relate the producer/consumer pattern to a <em class="italic">real-world scenario</em>, think about preparing gifts for a holiday gathering. You and a partner are working together to prepare the gifts. You are fetching and staging the gifts to be wrapped. You are the <em class="italic">producer</em>. Your partner is taking items from your queue and wrapping each gift. They are the <em class="italic">consumer</em>. If the queue starts to get backed up, you can find another friend (or consumer) to help with the wrapping and increase the overall throughput. If, on the other hand, you are taking too much time to find each gift to be wrapped, you can add another producer to help find them and fill the queue. This will keep the consumers busy and increase the efficiency of the process.</p>
<p>In our .NET producer/consumer example, we are going to build a simple WPF application that fetches blog posts from multiple RSS feeds and displays them in a single <strong class="source-inline">ListView</strong> control. Each row in the list will include the blog post’s date, categories, and an HTML summary of the post’s content. The producers in the application will fetch posts from an RSS feed and add a <strong class="source-inline">SyndicationItem</strong> to the queue for each blog post. We will get posts from three blogs and create a producer for each.</p>
<p>The consumers will take a <strong class="source-inline">SyndicationItem</strong> from the queue and use an <strong class="source-inline">ActionBlock</strong> delegate to create a <strong class="source-inline">BlogPost</strong> object for each <strong class="source-inline">SyndicationItem</strong>. We will create three consumers to keep up with the items that have been queued by our three producers. When the process completes, the list of <strong class="source-inline">BlogPost</strong> objects will be set as <strong class="source-inline">ItemSource</strong> for <strong class="source-inline">ListView</strong>. Let’s get started:</p>
<ol>
<li value="1">Start by<a id="_idIndexMarker393"/> creating a new WPF project with .NET 6. Name the project <strong class="source-inline">ProducerConsumerRssFeeds</strong>.</li>
<li>Open <strong class="bold">NuGet Package Manager</strong> for the solution, search for <strong class="bold">Syndication</strong> on the <strong class="bold">Install</strong> tab, and add the <strong class="bold">System.ServiceModel.Syndication</strong> package to the project. This package will make it simple to fetch data from any RSS feed.</li>
<li>Add a new class to the project named <strong class="source-inline">BlogPost</strong>. This will be our model object for each blog post to be displayed in <strong class="source-inline">ListView</strong>. Add the following properties to the new class:<p class="source-code">public class BlogPost</p><p class="source-code">{</p><p class="source-code">    public string PostDate { get; set; } = "";</p><p class="source-code">    public string? Categories { get; set; }</p><p class="source-code">    public string? PostContent { get; set; }</p><p class="source-code">}</p></li>
<li>Now, it’s time to create a service class to fetch the blog posts for a given RSS feed URL. Add a new class named <strong class="source-inline">RssFeedService</strong> to the project and add a method named <strong class="source-inline">GetFeedItems</strong> to the class:<p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.ServiceModel.Syndication;</p><p class="source-code">using System.Xml;</p><p class="source-code">...</p><p class="source-code">public static IEnumerable&lt;SyndicationItem&gt; </p><p class="source-code">    GetFeedItems(string feedUrl)</p><p class="source-code">{</p><p class="source-code">    using var xmlReader = XmlReader.Create(feedUrl);</p><p class="source-code">    SyndicationFeed rssFeed = SyndicationFeed.Load</p><p class="source-code">        (xmlReader);</p><p class="source-code">    return rssFeed.Items;</p><p class="source-code">}</p></li>
</ol>
<p>The static <strong class="source-inline">SyndicationFeed.Load</strong> method uses <strong class="source-inline">XmlReader</strong> to fetch the XML from the provided <strong class="source-inline">feedUrl</strong> and transform it into <strong class="source-inline">IEnumerable&lt;SyndicationItem&gt;</strong> to return from the method.</p>
<ol>
<li value="5">Next, create <a id="_idIndexMarker394"/>a new class named <strong class="source-inline">FeedAggregator</strong>. This class will contain the producer/consumer logic that calls <strong class="source-inline">GetFeedItems</strong> for each blog and transforms the feed data for each blog post so that it can be displayed in the UI. The three blogs that we are aggregating are as follows:<ul><li>The .NET blog</li>
<li>The Windows blog </li>
<li>The Microsoft 365 blog</li>
</ul></li>
</ol>
<p>The first step with <strong class="source-inline">FeedAggregator</strong> is creating a producer method named <strong class="source-inline">ProduceFeedItems</strong> and a parent method named <strong class="source-inline">QuseueAllFeeds</strong> that will start three instances of the producer method:</p>
<p class="source-code">private async Task QueueAllFeeds(BufferBlock</p>
<p class="source-code">    &lt;SyndicationItem&gt; itemQueue)</p>
<p class="source-code">{</p>
<p class="source-code">    Task feedTask1 = ProduceFeedItems(itemQueue, </p>
<p class="source-code">       "https://devblogs.microsoft.com/dotnet/feed/");</p>
<p class="source-code">    Task feedTask2 = ProduceFeedItems(itemQueue, </p>
<p class="source-code">        "https://blogs.windows.com/feed");</p>
<p class="source-code">    Task feedTask3 = ProduceFeedItems(itemQueue, </p>
<p class="source-code">        "https://www.microsoft.com/microsoft-</p>
<p class="source-code">            365/blog/feed/");</p>
<p class="source-code">    await Task.WhenAll(feedTask1, feedTask2, </p>
<p class="source-code">         feedTask3);</p>
<p class="source-code">    itemQueue.Complete();</p>
<p class="source-code">}</p>
<p class="source-code">private async Task ProduceFeedItems</p>
<p class="source-code">    (BufferBlock&lt;SyndicationItem&gt; itemQueue, string </p>
<p class="source-code">        feedUrl)</p>
<p class="source-code">{</p>
<p class="source-code">    IEnumerable&lt;SyndicationItem&gt; items = </p>
<p class="source-code">        RssFeedService.GetFeedItems(feedUrl);</p>
<p class="source-code">    foreach (SyndicationItem item in items)</p>
<p class="source-code">    {</p>
<p class="source-code">        await itemQueue.SendAsync(item);</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>We are<a id="_idIndexMarker395"/> using <strong class="source-inline">BufferBlock&lt;SyndicationItem&gt;</strong> as our queue. Every producer calls <strong class="source-inline">GetFeedItems</strong> and adds each <strong class="source-inline">SyndicationItem</strong> that’s returned to <strong class="source-inline">BufferBlock</strong>. The <strong class="source-inline">QueueAllFeeds</strong> method uses <strong class="source-inline">Task.WhenAll</strong> to wait for all of the producers to finish adding items to the queue. Then, it signals to <strong class="source-inline">BufferBlock</strong> that all the producers are done by calling <strong class="source-inline">itemQueue.Complete()</strong>.</p>
<ol>
<li value="6">Next, we <a id="_idIndexMarker396"/>will create our consumer method. This method, named <strong class="source-inline">ConsumeFeedItem</strong>, will be responsible for taking a <strong class="source-inline">SyndicationItem</strong> provided by <strong class="source-inline">BufferBlock</strong> and converting it into a <strong class="source-inline">BlogPost</strong> object. Each <strong class="source-inline">BlogPost</strong> will be added to <strong class="source-inline">ConcurrentBag&lt;BlogPost&gt;</strong>. We’re using a thread-safe collection here because there will be multiple consumers adding output to the list:<p class="source-code">private void ConsumeFeedItem(SyndicationItem nextItem, </p><p class="source-code">    ConcurrentBag&lt;BlogPost&gt; posts)</p><p class="source-code">{</p><p class="source-code">    if (nextItem != null &amp;&amp; nextItem.Summary != null)</p><p class="source-code">    {</p><p class="source-code">        BlogPost newPost = new();</p><p class="source-code">        newPost.PostContent = nextItem.Summary.Text</p><p class="source-code">            .ToString();</p><p class="source-code">        newPost.PostDate = nextItem.PublishDate</p><p class="source-code">            .ToLocalTime().ToString("g");</p><p class="source-code">        if (nextItem.Categories != null)</p><p class="source-code">        {</p><p class="source-code">            newPost.Categories = string.Join(",", </p><p class="source-code">                nextItem.Categories.Select(c =&gt; </p><p class="source-code">                    c.Name));</p><p class="source-code">        }</p><p class="source-code">        posts.Add(newPost);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Now, it’s time<a id="_idIndexMarker397"/> to tie the producer/consumer logic together. Create a method named <strong class="source-inline">GetAllMicrosoftBlogPosts</strong>:<p class="source-code">public async Task&lt;IEnumerable&lt;BlogPost&gt;&gt; </p><p class="source-code">    GetAllMicrosoftBlogPosts()</p><p class="source-code">{</p><p class="source-code">    var posts = new ConcurrentBag&lt;BlogPost&gt;();</p><p class="source-code">    // Create queue of source posts</p><p class="source-code">    BufferBlock&lt;SyndicationItem&gt; itemQueue = new(new </p><p class="source-code">        DataflowBlockOptions { BoundedCapacity = </p><p class="source-code">            10 });</p><p class="source-code">    // Create and link consumers</p><p class="source-code">    var consumerOptions = new Execution</p><p class="source-code">        DataflowBlockOptions { BoundedCapacity = 1 };</p><p class="source-code">    var consumerA = new ActionBlock&lt;SyndicationItem&gt;</p><p class="source-code">        ((i) =&gt; ConsumeFeedItem(i, posts), </p><p class="source-code">            consumerOptions);</p><p class="source-code">    var consumerB = new ActionBlock&lt;SyndicationItem&gt;</p><p class="source-code">        ((i) =&gt; ConsumeFeedItem(i, posts), </p><p class="source-code">            consumerOptions);</p><p class="source-code">    var consumerC = new ActionBlock&lt;SyndicationItem&gt;</p><p class="source-code">        ((i) =&gt; ConsumeFeedItem(i, posts), </p><p class="source-code">            consumerOptions);</p><p class="source-code">    var linkOptions = new DataflowLinkOptions { </p><p class="source-code">        PropagateCompletion = true, };</p><p class="source-code">    itemQueue.LinkTo(consumerA, linkOptions);</p><p class="source-code">    itemQueue.LinkTo(consumerB, linkOptions);</p><p class="source-code">    itemQueue.LinkTo(consumerC, linkOptions);</p><p class="source-code">    // Start producers</p><p class="source-code">    Task producers = QueueAllFeeds(itemQueue);</p><p class="source-code">    // Wait for producers and consumers to complete</p><p class="source-code">    await Task.WhenAll(producers, consumerA.Completion,</p><p class="source-code">        consumerB.Completion, consumerC.Completion);</p><p class="source-code">    return posts;</p><p class="source-code">}</p><ol><li>The method <a id="_idIndexMarker398"/>starts by creating a <strong class="source-inline">ConcurrentBag&lt;BlogPost&gt;</strong> to aggregate the final list of posts for the UI. Then, it creates the <strong class="source-inline">itemQueue</strong> object with a <strong class="source-inline">BoundedCapacity</strong> of <strong class="source-inline">10</strong>. This bounded capacity means that no more than 10 items can be enqueued at any time. Once the queue reaches 10, all the producers must wait for the consumers to dequeue some items. This can slow the performance of the process, but it prevents potential out-of-memory issues in production code. Our sample is not in any danger of running out of memory when processing posts from three blogs, but you can see how to use <strong class="source-inline">BoundedCapacity</strong> when it is needed in your applications. You can create the queue with no <strong class="source-inline">BoundedCapacity</strong> like this:</li>
</ol><p class="source-code">BufferBlock&lt;SyndicationItem&gt; itemQueue = new();</p><ol><li value="2">The next part of the method creates three consumers that use <strong class="source-inline">ActionBlock&lt;SyndicationItem&gt;</strong> with <strong class="source-inline">ConsumeFeedItem</strong> as the provided delegate. Each consumer is linked to the queue with the <strong class="source-inline">LinkTo</strong> method. Setting <strong class="source-inline">BoundedCapacity</strong> of the consumers to <strong class="source-inline">1</strong> tells the producers to move on to the next consumer if the current one is already busy processing an item.</li>
<li>Once the links have been established, we can start the producers by calling <strong class="source-inline">QueueAllFeeds</strong>. Then, we must <strong class="source-inline">await</strong> the producers and the <strong class="source-inline">Completion</strong> object of each consumer <strong class="source-inline">ActionBlock</strong>. By linking the completion of the producers and consumers, we don’t need to explicitly <strong class="source-inline">await</strong> the <strong class="source-inline">Completion</strong> object of the consumers:</li>
</ol><p class="source-code">var linkOptions = new DataflowLinkOptions { </p><p class="source-code">    PropagateCompletion = true, };</p></li>
<li>The next step is<a id="_idIndexMarker399"/> to create some UI controls to display the information to our users. Open the <strong class="source-inline">MainWindow.xaml</strong> file and replace the existing <strong class="source-inline">Grid</strong> with the following markup:<p class="source-code">&lt;Grid&gt;</p><p class="source-code">    &lt;ListView x:Name="mainListView"&gt;</p><p class="source-code">        &lt;ListView.ItemTemplate&gt;</p><p class="source-code">            &lt;DataTemplate&gt;</p><p class="source-code">                &lt;Grid&gt;</p><p class="source-code">                    &lt;Grid.ColumnDefinitions&gt;</p><p class="source-code">                        &lt;ColumnDefinition </p><p class="source-code">                            Width="150"/&gt;</p><p class="source-code">                        &lt;ColumnDefinition </p><p class="source-code">                            Width="300"/&gt;</p><p class="source-code">                        &lt;ColumnDefinition </p><p class="source-code">                            Width="500"/&gt;</p><p class="source-code">                    &lt;/Grid.ColumnDefinitions&gt;</p><p class="source-code">                    &lt;TextBlock Grid.Column="0"  </p><p class="source-code">                        Text="{Binding PostDate}"</p><p class="source-code">                            Margin="3"/&gt;</p><p class="source-code">                    &lt;TextBox IsReadOnly="True" </p><p class="source-code">                        Grid.Column="1"</p><p class="source-code">                           Text="{Binding Categories}"</p><p class="source-code">                               Margin="3"</p><p class="source-code">                                 TextWrapping="Wrap"/&gt;</p><p class="source-code">                    &lt;TextBox IsReadOnly="True" </p><p class="source-code">                        Grid.Column="2" </p><p class="source-code">                          Text="{Binding PostContent}"</p><p class="source-code">                             Margin="3"/&gt;</p><p class="source-code">                &lt;/Grid&gt;</p><p class="source-code">            &lt;/DataTemplate&gt;</p><p class="source-code">        &lt;/ListView.ItemTemplate&gt;</p><p class="source-code">    &lt;/ListView&gt;</p><p class="source-code">&lt;/Grid&gt;</p></li>
</ol>
<p>Explaining the details of WPF, XAML, and data binding are outside the scope of this book. If you would like to learn more about WPF, check out <em class="italic">Mastering Windows Presentation Foundation</em>, by Sheridan Yeun: <a href="https://www.packtpub.com/product/mastering-windows-presentation-foundation-second-edition/9781838643416">https://www.packtpub.com/product/mastering-windows-presentation-foundation-second-edition/9781838643416</a>. What this markup does is create a new <strong class="source-inline">ListView</strong> control with a <strong class="source-inline">DataTemplate</strong> to define the structure of each list item in the control. For each item, we are defining either a <strong class="source-inline">TextBlock</strong> or <strong class="source-inline">TextBox</strong> to hold the values for each <strong class="source-inline">BlogPost</strong> object in the list.</p>
<ol>
<li value="9">The last thing<a id="_idIndexMarker400"/> we must do is call the <strong class="source-inline">GetAllMicrosoftBlogPosts</strong> method and populate the UI. Open <strong class="source-inline">MainWindow.xaml.cs</strong> and add the following code:<p class="source-code">public MainWindow()</p><p class="source-code">{</p><p class="source-code">    InitializeComponent();</p><p class="source-code">    <strong class="bold">Loaded += MainWindow_Loaded;</strong></p><p class="source-code">}</p><p class="source-code"><strong class="bold">private async void MainWindow_Loaded(object sender, </strong></p><p class="source-code"><strong class="bold">    RoutedEventArgs e)</strong></p><p class="source-code"><strong class="bold">{</strong></p><p class="source-code"><strong class="bold">    FeedAggregator aggregator = new();</strong></p><p class="source-code"><strong class="bold">    var items = await aggregator</strong></p><p class="source-code"><strong class="bold">        .GetAllMicrosoftBlogPosts();</strong></p><p class="source-code"><strong class="bold">    mainListView.ItemsSource = items;</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
</ol>
<p>After <strong class="source-inline">MainWindow</strong> has loaded, the items that have been returned from <strong class="source-inline">GetAllMicrosoftBlogPosts</strong> are set as <strong class="source-inline">mainListView.ItemsSource</strong>. This will allow the data to bind to the elements in <strong class="source-inline">DataTemplate</strong>, which we defined in the XAML.</p>
<ol>
<li value="10">Now, run the project and see how things look:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer039">
<img alt="Figure 7.2 – Running the ProducerConsumerRssFeeds WPF application for the first time " height="821" src="image/Figure_7.2_B18552.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Running the ProducerConsumerRssFeeds WPF application for the first time</p>
<p>As you<a id="_idIndexMarker401"/> can see, the list displays 10 blog post summaries from each of the Microsoft blogs. This is the default maximum number of items that can be returned by Microsoft’s blogs.</p>
<p>You can try experimenting by increasing or decreasing the number of producers and consumers in the project. Does adding more consumers speed up the process? Try adding some of your favorite blogs’ feeds to the list of producers and see what happens.</p>
<p class="callout-heading">Note</p>
<p class="callout">You may have noticed that the content summary that’s returned by the RSS feeds contains HTML, and we are just rendering it as plain text in a <strong class="source-inline">TextBox</strong> control. If you would like to use a <strong class="source-inline">RichTextBox</strong> that renders the HTML properly, take a look at this sample project on CodeProject that uses a WPF <strong class="bold">Behavior</strong> to render HTML in a <strong class="source-inline">RichTextBox</strong>: <a href="https://www.codeproject.com/articles/1097390/displaying-html-in-a-wpf-richtextbox">https://www.codeproject.com/articles/1097390/displaying-html-in-a-wpf-richtextbox</a>.</p>
<p>In the next section, we will create another example that uses different types of dataflow blocks to create a data pipeline.</p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Creating a data pipeline with multiple blocks</h1>
<p>One of the <a id="_idIndexMarker402"/>biggest advantages of using dataflow <a id="_idIndexMarker403"/>blocks is the ability to link them and create a complete workflow or data pipeline. In the previous section, we saw how this linking worked between producer and consumer blocks. In this section, we will create a console application with a pipeline of five dataflow blocks all linked together to complete a series of tasks. We will leverage <strong class="source-inline">TransformBlock</strong>, <strong class="source-inline">TransformManyBlock</strong>, and <strong class="source-inline">ActionBlock</strong> to take an RSS feed and output a list of categories that are unique across all blog posts in the feed. Follow these steps:</p>
<ol>
<li value="1">Start by creating a new .NET 6 console application in Visual Studio named <strong class="source-inline">OutputBlogCategories</strong>.</li>
<li>Add the <strong class="bold">System.ComponentModel.Syndication</strong> NuGet package that we used in the previous example.</li>
<li>Add the same <strong class="source-inline">RssFeedService</strong> class from the previous example. You can right-click on the project in <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add</strong> | <strong class="bold">Existing Item</strong> or you can create a new class named <strong class="source-inline">RssFeedService</strong> and copy/paste the same code we used in the previous example.</li>
<li>Add a new class named <strong class="source-inline">FeedCategoryTransformer</strong> to the project and create a method named <strong class="source-inline">GetCategoriesForFeed</strong>:<p class="source-code">public static async Task GetCategoriesForFeed(string </p><p class="source-code">    url)</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>Over the next few steps, we will create the implementation for the <strong class="source-inline">GetCategoriesForFeed</strong> method. First, create a <strong class="source-inline">TransformBlock</strong> named <strong class="source-inline">downloadFeed</strong> that accepts <strong class="source-inline">url</strong> as a string and returns <strong class="source-inline">IEnumerable&lt;SyndicationItem&gt;</strong> from the <strong class="source-inline">GetFeedItems</strong> method:<p class="source-code">// Downloads the requested blog posts.</p><p class="source-code">var downloadFeed = new TransformBlock&lt;string, </p><p class="source-code">    IEnumerable&lt;SyndicationItem&gt;&gt;(url =&gt;</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine("Fetching feed from '{0}'...", </p><p class="source-code">        url);</p><p class="source-code">    return RssFeedService.GetFeedItems(url);</p><p class="source-code">});</p></li>
<li>Next, create <a id="_idIndexMarker404"/>a <strong class="source-inline">TransformBlock</strong> that<a id="_idIndexMarker405"/> accepts <strong class="source-inline">IEnumerable&lt;SyndicationItem&gt;</strong> and returns <strong class="source-inline">List&lt;SyndicationCategory&gt;</strong>. This block will fetch the complete list of categories from every blog post and return them as a single list:<p class="source-code">// Aggregates the categories from all the posts.</p><p class="source-code">var createCategoryList = new TransformBlock</p><p class="source-code">    &lt;IEnumerable&lt;SyndicationItem&gt;, List</p><p class="source-code">        &lt;SyndicationCategory&gt;&gt;(items =&gt;</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine("Getting category list...");</p><p class="source-code">    var result = new List&lt;SyndicationCategory&gt;();</p><p class="source-code">    foreach (var item in items)</p><p class="source-code">    {</p><p class="source-code">        result.AddRange(item.Categories);</p><p class="source-code">    }</p><p class="source-code">    return result;</p><p class="source-code">});</p></li>
<li>Now, create another <strong class="source-inline">TransformBlock</strong>. This block will accept <strong class="source-inline">List&lt;SyndicationCategory&gt;</strong> from the previous block, remove all duplicates, and return the filtered <strong class="source-inline">List&lt;SyndicationCategory&gt;</strong>:<p class="source-code">// Removes duplicates.</p><p class="source-code">var deDupList = new TransformBlock&lt;List</p><p class="source-code">    &lt;SyndicationCategory&gt;, List&lt;SyndicationCategory&gt;&gt;</p><p class="source-code">        (categories =&gt;</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine("De-duplicating category </p><p class="source-code">        list...");</p><p class="source-code">    var categoryComparer = new CategoryComparer();</p><p class="source-code">    return categories.Distinct(categoryComparer)</p><p class="source-code">        .ToList();</p><p class="source-code">});</p></li>
</ol>
<p>To use the LINQ<a id="_idIndexMarker406"/> Distinct extension method on a<a id="_idIndexMarker407"/> complex object such as <strong class="source-inline">SyndicationCategory</strong>, a custom comparer that implements <strong class="source-inline">IEqualityComparer&lt;T&gt;</strong> is required. You can get the complete source for <strong class="source-inline">CategoryComparer</strong> from this chapter’s GitHub repository: <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07</a>.</p>
<ol>
<li value="8">Next, create a <strong class="source-inline">TransformManyBlock</strong> named <strong class="source-inline">createCategoryString</strong>. This block will accept the de-duplicated <strong class="source-inline">List&lt;SyndicationCategory&gt;</strong> and return a string for each <strong class="source-inline">Name</strong> property of the categories. So, the block is invoked once for the entire list, but it will, in turn, invoke the next block in the flow once for every item in the list:<p class="source-code">// Gets the category names from the list of category </p><p class="source-code">    objects.</p><p class="source-code">var createCategoryString = new TransformManyBlock</p><p class="source-code">    &lt;List&lt;SyndicationCategory&gt;, string&gt;(categories =&gt;</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine("Extracting category names...");</p><p class="source-code">    return categories.Select(c =&gt; c.Name);</p><p class="source-code">});</p></li>
<li>The final <a id="_idIndexMarker408"/>block is an <strong class="source-inline">ActionBlock</strong> named <strong class="source-inline">printCategoryInCaps</strong>. This block will output each category name to the<a id="_idIndexMarker409"/> console in all caps using <strong class="source-inline">ToUpper</strong>:<p class="source-code">// Prints the upper-cased unique categories to the </p><p class="source-code">    console.</p><p class="source-code">var printCategoryInCaps = new ActionBlock&lt;string&gt;</p><p class="source-code">    (categoryName =&gt;</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine($"Found CATEGORY </p><p class="source-code">        {categoryName.ToUpper()}");</p><p class="source-code">});</p></li>
<li>Now that the dataflow blocks have been configured, it’s time to link them. Create a <strong class="source-inline">DataflowLinkOptions</strong> that will propagate the completion of each block. Then, use the <strong class="source-inline">LinkTo</strong> method to link each block in the chain to the next one:<p class="source-code">var linkOptions = new DataflowLinkOptions { </p><p class="source-code">    PropagateCompletion = true };</p><p class="source-code">downloadFeed.LinkTo(createCategoryList, linkOptions);</p><p class="source-code">createCategoryList.LinkTo(deDupList, linkOptions);</p><p class="source-code">deDupList.LinkTo(createCategoryString, linkOptions);</p><p class="source-code">createCategoryString.LinkTo(printCategoryInCaps, </p><p class="source-code">    linkOptions);</p></li>
<li>The last few steps of creating the <strong class="source-inline">GetCategoriesForFeed</strong> method involve sending <strong class="source-inline">url</strong> to the first block, marking it as <strong class="source-inline">Complete</strong>, and waiting for the last block in the chain:<p class="source-code">await downloadFeed.SendAsync(url);</p><p class="source-code">downloadFeed.Complete();</p><p class="source-code">await printCategoryInCaps.Completion;</p></li>
<li>Now, open <strong class="source-inline">Program.cs</strong> and <a id="_idIndexMarker410"/>update the code so that<a id="_idIndexMarker411"/> it calls <strong class="source-inline">GetCategoriesForFeed</strong>, providing the URL for the Windows blog RSS feed:<p class="source-code">using OutputBlogCategories;</p><p class="source-code">Console.WriteLine("Hello, World!");</p><p class="source-code">await FeedCategoryTransformer.GetCategoriesForFeed</p><p class="source-code">    ("https://blogs.windows.com/feed");</p><p class="source-code">Console.ReadLine();</p></li>
<li>Run the program and examine the list of categories in the output:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer040">
<img alt="Figure 7.3 – Displaying a deduplicated list of categories from the Windows blog feed " height="596" src="image/Figure_7.3_B18552.jpg" width="828"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Displaying a deduplicated list of categories from the Windows blog feed</p>
<p>Now that you understand how to create a data pipeline with a series of dataflow blocks, we will look at an example of combining data from multiple sources with a <strong class="source-inline">JoinBlock</strong>.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor127"/>Manipulating data from multiple data sources</h1>
<p>A <strong class="source-inline">JoinBlock</strong> can be <a id="_idIndexMarker412"/>configured to receive different data types from two or three data sources. As each set of data types is completed, the block is completed with a <strong class="source-inline">Tuple</strong> containing all three object types to be acted upon. In this example, we will create a <strong class="source-inline">JoinBlock</strong> that accepts a <strong class="source-inline">string</strong> and <strong class="source-inline">int</strong> pair and passes <strong class="source-inline">Tuple(string, int)</strong> along to an <strong class="source-inline">ActionBlock</strong>, which outputs their values to the console. Follow these steps:</p>
<ol>
<li value="1">Start by creating a new console application in Visual Studio</li>
<li>Add a new class named <strong class="source-inline">DataJoiner</strong> to the project and add a static method to the class named <strong class="source-inline">JoinData</strong>:<p class="source-code">public static void JoinData()</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>Add<a id="_idIndexMarker413"/> the following code to create two <strong class="source-inline">BufferBlock</strong> objects, a <strong class="source-inline">JoinBlock&lt;string, int&gt;</strong>, and an <strong class="source-inline">ActionBlock&lt;Tuple&lt;string, int&gt;&gt;</strong>:<p class="source-code">var stringQueue = new BufferBlock&lt;string&gt;();</p><p class="source-code">var integerQueue = new BufferBlock&lt;int&gt;();</p><p class="source-code">var joinStringsAndIntegers = new JoinBlock&lt;string, </p><p class="source-code">    int&gt;(</p><p class="source-code">    new GroupingDataflowBlockOptions</p><p class="source-code">    {</p><p class="source-code">        Greedy = false</p><p class="source-code">    });</p><p class="source-code">var stringIntegerAction = new ActionBlock</p><p class="source-code">    &lt;Tuple&lt;string, int&gt;&gt;(data =&gt;</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine($"String received: </p><p class="source-code">        {data.Item1}");</p><p class="source-code">    Console.WriteLine($"Integer received: </p><p class="source-code">        {data.Item2}");</p><p class="source-code">});</p></li>
</ol>
<p>Setting the block to non-greedy mode means it will wait for an item of each type before executing the block.</p>
<ol>
<li value="4">Now, create the links between the blocks:<p class="source-code">stringQueue.LinkTo(joinStringsAndIntegers.Target1);</p><p class="source-code">integerQueue.LinkTo(joinStringsAndIntegers.Target2);</p><p class="source-code">joinStringsAndIntegers.LinkTo(stringIntegerAction);</p></li>
<li>Next, push <a id="_idIndexMarker414"/>some data to the two <strong class="source-inline">BufferBlock</strong> objects, wait for a second, and then mark them both as complete:<p class="source-code">stringQueue.Post("one");</p><p class="source-code">stringQueue.Post("two");</p><p class="source-code">stringQueue.Post("three");</p><p class="source-code">integerQueue.Post(1);</p><p class="source-code">integerQueue.Post(2);</p><p class="source-code">integerQueue.Post(3);</p><p class="source-code">stringQueue.Complete();</p><p class="source-code">integerQueue.Complete();</p><p class="source-code">Thread.Sleep(1000);</p><p class="source-code">Console.WriteLine("Complete");</p></li>
<li>Add the following code to <strong class="source-inline">Program.cs</strong> to run the example code:<p class="source-code">using JoinBlockExample;</p><p class="source-code">DataJoiner.JoinData();</p><p class="source-code">Console.ReadLine();</p></li>
<li>Finally, run the application and examine the output. You will see that <strong class="source-inline">ActionBlock</strong> outputs a <strong class="source-inline">string</strong> and <strong class="source-inline">integer</strong> pair for each set of values provided:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer041">
<img alt="Figure 7.4 – Running the JoinBlockExample console application " height="436" src="image/Figure_7.4_B18552.jpg" width="1260"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Running the JoinBlockExample console application</p>
<p>That’s all <a id="_idIndexMarker415"/>there is to using the <strong class="source-inline">JoinBlock</strong> dataflow block. Try making some changes on your own, such as changing the <strong class="source-inline">Greedy</strong> option or the order in which data is added to each <strong class="source-inline">BufferBlock</strong>. How does that impact the output?</p>
<p>Before we finish up this chapter, let’s review everything we’ve learned.</p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor128"/>Summary</h1>
<p>In this chapter, we learned all about the various blocks in the TPL Dataflow library. We started by learning a little about each block type and providing a brief code snippet for each. Next, we created a practical example that implemented the producer/consumer pattern to fetch blog data from three different Microsoft blogs. We also examined <strong class="source-inline">TransformBlock</strong>, <strong class="source-inline">TransformManyBlock</strong>, and <strong class="source-inline">JoinBlock</strong> more closely in .NET console applications. You should now feel confident in your ability to use some of the dataflow blocks in your applications to automate some complex data workflows.</p>
<p>If you would like some additional reading about the TPL Dataflow library, you can download <em class="italic">Introduction to TPL Dataflow</em> from the Microsoft Download Center: <a href="https://www.microsoft.com/en-us/download/details.aspx?id=14782">https://www.microsoft.com/en-us/download/details.aspx?id=14782</a>.</p>
<p>In the next chapter, <a href="B18552_08_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>, we will take a closer look at the collections in the <strong class="source-inline">System.Collections.Concurrent</strong> namespace. We will also discover some practical uses of PLINQ in modern .NET applications.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li value="1">What type of data flow block aggregates data from two or three data sources?</li>
<li>What type of block is a <strong class="source-inline">BufferBlock</strong>?</li>
<li>What type of block is populated by a producer in the producer/consumer pattern?</li>
<li>What method links the completion of two blocks?</li>
<li>What method is called to signal that our code is done adding data to a source block?</li>
<li>What is the async equivalent of calling <strong class="source-inline">Post()</strong>?</li>
<li>What is the async equivalent of calling <strong class="source-inline">Receive()</strong>?</li>
</ol>
</div>
</div>
</body></html>