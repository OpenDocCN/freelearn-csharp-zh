- en: '*Chapter 3*: Introducing C# 10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：介绍 C# 10'
- en: C# is an elegant and type-safe object-oriented programming language that allows
    developers to build a wide range of secure and robust applications that run in
    the .NET ecosystem and is in the top 5 of the popular programming languages list
    published by GitHub.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是一种优雅且类型安全的面向对象编程语言，它允许开发者构建各种安全且健壮的应用程序，这些应用程序在 .NET 生态系统中运行，并在 GitHub 发布的流行编程语言排行榜上名列前茅。
- en: C# was initially developed by Anders Hejlsberg at Microsoft as part of the .NET
    initiative. Since its first release in January 2002, there have been new features
    added consistently to the language to improve performance and productivity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C# 最初由微软的 Anders Hejlsberg 开发，作为 .NET 创新计划的一部分。自 2002 年 1 月首次发布以来，该语言一直持续添加新功能，以提高性能和生产力。
- en: 'C# 10 released with .NET 6 comes with some cool new language features along
    with enhancements to the features released in earlier versions, which improve
    developer productivity. In this chapter, we will explore some of the new C# language
    features:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10 与 .NET 6 一起发布，带来了一些酷炫的新语言特性，以及对早期版本中发布特性的增强，从而提高了开发者的生产力。在本章中，我们将探讨一些新的
    C# 语言特性：
- en: Simplification of the using directives
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指令的简化
- en: The record structs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录结构体
- en: Improvements to the Lambda expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式的改进
- en: Enhancements to interpolated strings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值字符串的增强
- en: Extended property patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展属性模式
- en: Additions to the caller argument attributes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者参数属性的添加
- en: By end of this chapter, you'll be familiar with the major new additions to C#
    10\. Also, this chapter will help us to upskill ourselves to build our next enterprise
    application in C#.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉 C# 10 的主要新增功能。此外，本章将帮助我们提升技能，以便用 C# 构建我们的下一个企业级应用程序。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following to understand the concepts of this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解本章的概念，你需要以下内容：
- en: Visual Studio 2022 version 17.0 Community Edition with the .NET 6.0 runtime
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配备 .NET 6.0 运行的 Visual Studio 2022 版本 17.0 社区版
- en: A basic understanding of Microsoft .NET
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 Microsoft .NET 的基本理解
- en: The code used in this chapter can be found at [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter03).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的代码可以在 [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter03)
    找到。
- en: Simplification of the using directives
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指令的简化
- en: 'A top-level statement is a new feature introduced in C# 9.0, which makes it
    easy for developers to remove the ceremony code. The project templates that come
    with Visual Studio 2022 embrace the language changes introduced in C# such as
    top-level statements. For example, if you create a `Console` application, you
    will see the `Program.cs` file contains the code shown in the following snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级语句是 C# 9.0 中引入的新特性，它使得开发者能够轻松移除仪式性代码。Visual Studio 2022 中的项目模板采用了 C# 中引入的语言变化，如顶级语句。例如，如果你创建一个
    `Console` 应用程序，你将看到 `Program.cs` 文件包含以下代码片段：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code came with a `console` application template that did not have
    the ceremony code such as class definition and the `main` method. This simplified
    the number of lines we could write by removing the redundant code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码包含了一个没有仪式性代码（如类定义和 `main` 方法）的 `console` 应用程序模板。通过删除冗余代码，这简化了我们能够编写的行数。
- en: The concepts of the `implicit` using directives and `global` using directives
    introduced in C# 10 reduce the repetition of the `using` statements in each CS
    file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10 中引入的 `implicit` 使用指令和 `global` 使用指令的概念减少了每个 CS 文件中 `using` 语句的重复。
- en: The global using directives
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局使用指令
- en: 'With the `global` `using` directives, we do not repeat the namespace `using`
    statements in all the `.cs` files. The `global` keyword is used to mark a `global`
    `using` directive as shown in the following code snippet:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局 `using` 指令，我们不需要在所有 `.cs` 文件中重复 `namespace using` 语句。`global` 关键字用于标记全局
    `using` 指令，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we marked `System.Threading` as `global`. Now, we can
    reference the types under `System.Threading` by having the `using` directive at
    the start of the `.cs` file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `System.Threading` 标记为 `global`。现在，我们可以在 `.cs` 文件的开头使用 `using` 指令来引用
    `System.Threading` 下的类型。
- en: 'We can also create `global` aliases to the namespaces to resolve the namespace
    conflicts, as shown in the following code snippet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建对命名空间的 `global` 别名，以解决命名空间冲突，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By defining this, we can refer to all the classes defined under `System.Runtime.Serialization`
    using the alias name, `SRS`. We can also define a `global using static` directive
    as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义这一点，我们可以使用别名 `SRS` 来引用 `System.Runtime.Serialization` 下定义的所有类。我们还可以定义一个全局
    `using static` 指令，如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this, we can use all the `static` functions defined in the `System.Console`
    class directly without referring to the class name. For example, to write a line
    to the console, we can just call the `WriteLine` method without referring to the
    `Console` class name, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以直接使用 `System.Console` 类中定义的所有 `static` 函数，而无需引用类名。例如，要向控制台写入一行，我们只需调用
    `WriteLine` 方法，而无需引用 `Console` 类名，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can specify `global` `using` directives in any `.cs` file of the project.
    The only constraint is they should appear before any regular file-scoped using
    directives. The common practice seen among the developers is to create a `.cs`
    with the name `GlobalUsings.cs` and add the `global` `using` directive in that
    file. This will help to restrict the change to a single file when we need to add
    or remove a `global` `using` directive. The scope of the `global` `using` directives
    is the complication unit that is the current project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在项目的任何 `.cs` 文件中指定全局 `using` 指令。唯一的约束是它们应该出现在任何常规文件作用域的 `using` 指令之前。开发者中常见的做法是创建一个名为
    `GlobalUsings.cs` 的 `.cs` 文件，并在该文件中添加全局 `using` 指令。这样，当我们需要添加或删除全局 `using` 指令时，可以限制更改仅限于单个文件。全局
    `using` 指令的作用域是当前项目的工作单元。
- en: The implicit using directives
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式 `using` 指令
- en: 'In C#, we find a few framework namespaces, such as `System` and `System.Linq`,
    are present in almost all the classes. With C# 10, these commonly-used namespaces
    are implicitly added as `global` using directives. The namespaces added implicitly
    are based on the project target SDK and are documented here: https://docs.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，我们发现一些框架命名空间，如 `System` 和 `System.Linq`，几乎存在于所有类中。在 C# 10 中，这些常用命名空间被隐式添加为全局
    `using` 指令。隐式添加的命名空间基于项目目标 SDK，并在以下位置进行文档说明：https://docs.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives。
- en: 'In addition to these, if we wish to include any other namespace to be part
    of these implicit directives or remove any of the predefined namespaces, we can
    do so by adding `ItemGroup` to the `.csproj` file, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们希望将任何其他命名空间包含在这些隐式指令中或从预定义的命名空间中删除任何命名空间，我们可以通过向 `.csproj` 文件中添加 `ItemGroup`
    来实现，如下所示：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous snippet, we are including `System.Threading` and removing `System.IO`
    from the `implicit` `using` directives.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们包括了 `System.Threading` 并从隐式 `using` 指令中移除了 `System.IO`。
- en: 'To completely remove the `implicit` `using` directives, we can uncheck the
    `ImplicitUsings` flag in the `.csproj` file as shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全移除隐式 `using` 指令，我们可以在 `.csproj` 文件中取消选中 `ImplicitUsings` 标志，如下所示：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The simplification of `using` directives is another step toward removing the
    redundant ceremony code and making the content in the `.cs` files concise.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 指令的简化是朝着移除冗余的仪式代码并使 `.cs` 文件中的内容简洁的又一步。'
- en: In the next section, we will explore the `record` structs introduced with C#
    10.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 C# 10 中引入的 `record` 结构体。
- en: The record structs
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录结构体
- en: The *record types* introduced in C# 9 provide type declaration to create immutable
    reference types with synthesized methods for equality check and `ToString`. C#
    10 brings us the *record structs*. In this section, we will see what `record struct`
    is and how it is different from `record class`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9 中引入的 *record types* 提供了类型声明，用于创建具有合成方法（用于检查相等性和 `ToString`）的不可变引用类型。C#
    10 带来了 *record structs*。在本节中，我们将了解 `record struct` 是什么以及它与 `record class` 的区别。
- en: 'We use the `record` keyword to declare `record class`, and we use the same
    `record` keyword to declare `record struct`, as shown in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `record` 关键字来声明 `record class`，同样使用相同的 `record` 关键字来声明 `record struct`，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In C# 9, to declare a `record` class, we don''t explicitly use the `class`
    keyword. We simply specify `record` to declare it as shown here: `public` record
    `Shape(string Name);`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 9 中，要声明一个 `record` 类，我们不需要显式使用 `class` 关键字。我们只需指定 `record` 来声明它，如下所示：`public`
    record `Shape(string Name);`
- en: Simply using the `record` keyword will continue to work in C# 10 to declare
    a `record` class, but it is recommended to specify `class` or `struct` explicitly
    for better readability.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用 `record` 关键字将继续在 C# 10 中工作以声明 `record` 类，但为了更好的可读性，建议明确指定 `class` 或 `struct`。
- en: '`record struct` offers similar benefits to what `record class` offers, such
    as the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`record struct` 提供了与 `record class` 类似的好处，例如以下内容：'
- en: Simplified declaration syntax
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化的声明语法
- en: Value equality
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值相等性
- en: Reference semantics
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用语义
- en: Deconstruction
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构
- en: Meaningful `ToString` output
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有意义的 `ToString` 输出
- en: 'Let''s understand these by creating a sample `Console` application and defining
    an `EmployeeRecord` record struct. Add the following code to the `Program.cs`
    file, which is using the `EmployeeRecord` record struct defined in the previous
    code snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个示例 `Console` 应用程序并定义一个 `EmployeeRecord` 记录结构体来理解这些内容。将以下代码添加到 `Program.cs`
    文件中，该文件使用前面代码片段中定义的 `EmployeeRecord` 记录结构体：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we are creating two instances of the `EmployeeRecord`
    record struct with name field values using the simplified declaration syntax,
    then printing the hash code of the instance objects, and then checking the equality.
    Here, we are also deconstructing the fields from the `employee` object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用简化的声明语法创建了两个 `EmployeeRecord` 记录结构体实例，并使用名称字段值，然后打印实例对象的哈希码，并检查相等性。在这里，我们还在从
    `employee` 对象中解构字段。
- en: 'When we run the code, we see the output as shown in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们看到如下截图所示的输出：
- en: '![Figure 3.1 – Output of record struct example'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.1 – 记录结构体示例的输出'
- en: '](img/Figure_3.1_B18507.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.1 – 图 3.1](img/Figure_3.1_B18507.jpg)'
- en: Figure 3.1 – Output of record struct example
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 记录结构体示例的输出
- en: When we look at the output, we observe that `ToString` is overridden to include
    the contents of the instance. As expected, the hash code of both instances is
    the same, as the field values are the same. In a regular struct, the hash code
    of the object is generated based on the first non-nullable field. In the `record`
    struct, the `GetHashCode` method is also overridden to include all the fields
    to generate the hash code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看输出时，我们观察到 `ToString` 被重写以包含实例的内容。正如预期的那样，两个实例的哈希码相同，因为字段值相同。在常规结构体中，对象的哈希码是基于第一个非空字段生成的。在
    `record` 结构体中，`GetHashCode` 方法也被重写以包含所有字段以生成哈希码。
- en: The `record` struct synthesizes the implementation of the `IEquatable<T>` interface.
    It also implements the `==` and `!=` operators. The regular struct does not have
    these operators implemented by default. The regular struct has the `Equals` method
    inherited from `ValueType`, which uses reflection to do the equality check. So,
    the synthesized equality check in the `record` struct is more performant. The
    `record` struct also synthesizes the `Deconstruct` method to populate the fields
    out of the object. If you take a closer look at the deconstruction code, you will
    notice the mixed declaration of the variables. We have `lastName` being declared
    during deconstruction, whereas `firstName` was declared in the preceding statement.
    This mixed declaration of variables is only possible in C#10 and above.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`record` 结构体综合了 `IEquatable<T>` 接口的实现。它还实现了 `==` 和 `!=` 操作符。常规结构体默认没有实现这些操作符。常规结构体从
    `ValueType` 继承了 `Equals` 方法，该方法使用反射来进行相等性检查。因此，`record` 结构体中的综合相等性检查性能更优。`record`
    结构体还综合了 `Deconstruct` 方法来填充对象外的字段。如果你仔细查看解构代码，你会注意到变量的混合声明。我们在解构过程中声明了 `lastName`，而在前面的语句中声明了
    `firstName`。这种变量的混合声明仅在 C#10 及以上版本中是可能的。'
- en: 'When we disassemble the code in a disassembler tool such as ILSpy or Reflector,
    we see the generated code as shown in the following figure:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在反汇编工具（如 ILSpy 或 Reflector）中反汇编代码时，我们看到生成的代码如下所示：
- en: '![Figure 3.2 – Generated code of the Employee class'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.2 – 员工类生成的代码'
- en: '](img/Figure_3.2_B18507.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.2 – 图 3.2](img/Figure_3.2_B18507.jpg)'
- en: Figure 3.2 – Generated code of the Employee class
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 员工类生成的代码
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can install ILSpy from [https://marketplace.visualstudio.com/items?itemName=SharpDevelopTeam.ILSpy](https://marketplace.visualstudio.com/items?itemName=SharpDevelopTeam.ILSpy).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [https://marketplace.visualstudio.com/items?itemName=SharpDevelopTeam.ILSpy](https://marketplace.visualstudio.com/items?itemName=SharpDevelopTeam.ILSpy)
    安装 ILSpy。
- en: 'If we look closely at the `Employee` type definition, we can see all the plumbing
    synthesized by the C# compiler for the `record struct` type. From this, we can
    understand that the `record` struct is basically a struct that implements the
    `IEquatable` interface and overrides the `GetHashCode` and `ToString` methods.
    You can overwrite the `ToString` method to create your own string representation
    for the record type. Beginning with C# 10, you can also mark the `ToString` override
    as sealed, which prevents the compiler from synthesizing a `ToString` method or
    derived types from overriding it. Sealing the `ToString` method in the base record
    type ensures that the string representation is consistent across all derived types.
    The compiler also provides the `Deconstruct` method, which is used to deconstruct
    the `record` struct into its component properties. Unlike `record` classes, the
    `record` structs are mutable. To make a `record` struct immutable, we can add
    a `readonly` modifier to the declaration:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细查看 `Employee` 类型的定义，我们可以看到 C# 编译器为 `record struct` 类型合成的所有管道。从这一点，我们可以理解
    `record` 结构体基本上是一个实现了 `IEquatable` 接口并重写了 `GetHashCode` 和 `ToString` 方法的结构体。您可以重写
    `ToString` 方法以创建记录类型的自定义字符串表示形式。从 C# 10 开始，您还可以将 `ToString` 重写标记为 sealed，这可以防止编译器合成
    `ToString` 方法或派生类型重写它。在基记录类型中密封 `ToString` 方法确保了所有派生类型的字符串表示形式的一致性。编译器还提供了 `Deconstruct`
    方法，它用于将 `record` 结构体分解为其组件属性。与 `record` 类不同，`record` 结构体是可变的。要使 `record` 结构体不可变，我们可以在声明中添加
    `readonly` 修饰符：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To change the fields of the `readonly record` struct, we can use the operator
    as shown here like with the `record` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改 `readonly record` 结构体的字段，我们可以使用如下所示的运算符，就像使用 `record` 类一样：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this section, we have learned about the `record` struct introduced in C#
    10 and how it compares with the `record` class and regular struct. In the next
    section, let's learn about improvements to Lambda expressions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 C# 10 中引入的 `record` 结构体以及它与 `record` 类和常规结构体的比较。在下一节中，我们将学习 Lambda
    表达式的改进。
- en: Improvements to Lambda expressions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式的改进
- en: A Lambda expression is a way to represent an anonymous method. It allows us
    to define the method implementation inline.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式是一种表示匿名方法的方式。它允许我们内联定义方法实现。
- en: A delegate type may be created from any Lambda expression. The types of a Lambda
    expression's parameters and return value determine the delegate type to which
    it can be transformed. A Lambda expression can be changed to an `Action` delegate
    type if it doesn't return a value; otherwise, it can be converted to one of the
    `Func` delegate types. In this section, we will learn about the improvements C#
    10 brings to Lambda expressions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从任何 Lambda 表达式创建委托类型。Lambda 表达式的参数类型和返回值类型决定了它可以转换成的委托类型。如果 Lambda 表达式不返回值，则可以将其更改为
    `Action` 委托类型；否则，它可以转换为 `Func` 委托类型之一。在本节中，我们将学习 C# 10 带给 Lambda 表达式的改进。
- en: Inferring the expression type
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推断表达式类型
- en: 'C# language compiler will now infer the expression type if the parameter''s
    types are explicit and the return type can be inferred. For example, consider
    the following code snippet where we defined a Lambda expression to find the square
    of the given integer:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数的类型是显式的并且可以推断出返回类型，则 C# 语言编译器现在将推断表达式类型。例如，考虑以下代码片段，其中我们定义了一个 Lambda 表达式来查找给定整数的平方：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, the parameter `x` type is specified as `int` and the
    return type is inferred as `int` from the expression. If we mouse-hover on `var`
    in Visual Studio, we can see the inferred type of the `Square` Lambda expression,
    as shown in the next screenshot, which uses the `Func` delegate:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，参数 `x` 的类型指定为 `int`，返回类型从表达式中推断为 `int`。如果我们将鼠标悬停在 Visual Studio 中的 `var`
    上，我们可以看到 `Square` Lambda 表达式的推断类型，如下一张截图所示，它使用 `Func` 委托：
- en: '![Figure 3.3 – Inferred type of Square expression'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – Square 表达式的推断类型]'
- en: '](img/Figure_3.3_B18507.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.3_B18507.jpg)'
- en: Figure 3.3 – Inferred type of Square expression
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – Square 表达式的推断类型
- en: 'For the code shown here, the compiler will use the `Action` delegate, as the
    expression return type is `void`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这里显示的代码，编译器将使用 `Action` 委托，因为表达式的返回类型是 `void`：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The inferred type will use `Func` or `Action` delegates if it is suitable.
    Otherwise, the compiler will synthesize a delegate type, for example, if the Lambda
    expression is taking a `ref` type, as shown in the following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果合适，推断的类型将使用 `Func` 或 `Action` 委托。否则，编译器将合成一个委托类型，例如，如果 Lambda 表达式接受 `ref`
    类型，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The synthesized type for the previous expression will be an `anonymous` delegate
    type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 之前表达式的合成类型将是一个匿名委托类型。
- en: The compiler will try to infer the return type based on the expression. Sometimes,
    it may not be possible to infer the type. We will get a compilation error if it
    is unable to infer the type information.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将尝试根据表达式推断返回类型。有时，可能无法推断类型。如果无法推断类型信息，我们将得到编译错误。
- en: Return types for Lambda expressions
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 表达式的返回类型
- en: 'In situations where it is not possible for the compiler to infer the return
    type, we can specify explicitly in C# 10\. Consider the following code snippet,
    where we have `record` classes of `Employee` and `Manager` inherited from a `Person`
    record class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译器无法推断返回类型的情况下，我们可以在 C# 10 中显式指定。考虑以下代码片段，其中我们定义了从 `Person` 记录类继承的 `Employee`
    和 `Manager` 记录类：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `createExpression` term in the preceding code snippet creates an instance
    of an `Employee` or `Manager` type based on the condition passed in. In this situation,
    the compiler cannot infer the return type, which will result in a compilation
    error. With C#10, we can now explicitly specify the return type for a Lambda expression
    as shown in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码片段中的 `createExpression` 术语根据传入的条件创建 `Employee` 或 `Manager` 类型的实例。在这种情况下，编译器无法推断返回类型，这将导致编译错误。从
    C#10 开始，我们可以显式指定 Lambda 表达式的返回类型，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The expression type inferred for the preceding code is `Func<bool, Person>`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码推断的表达式类型是 `Func<bool, Person>`。
- en: Adding attributes to Lambda expressions
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 Lambda 表达式添加属性
- en: 'Starting from C# 10, we can add attributes to the Lambda expressions and their
    parameters and return types. The following code snippet defines a Lambda expression
    to retrieve employees for the given ID:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C# 10 开始，我们可以向 Lambda 表达式及其参数和返回类型添加属性。以下代码片段定义了一个 Lambda 表达式，用于检索给定 ID 的员工：
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `GetEmployeeeById` expression has the `[Authorize]` attribute and the `id`
    parameter is attributed with `[FromRoute]`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetEmployeeeById` 表达式具有 `[Authorize]` 属性，而 `id` 参数带有 `[FromRoute]` 属性。'
- en: Attributes on Lambda expressions don't have any effect when they are invoked,
    as the invocation is via the underlying delegate type. The attributes defined
    on Lambda expressions can be discovered via reflection.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式上的属性在调用时没有任何效果，因为调用是通过底层委托类型进行的。Lambda 表达式上定义的属性可以通过反射发现。
- en: The minimal API introduced with ASP.NET 6.0 is one of the driving factors behind
    these improvements. We will see the usage of this in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040),
    *Creating an ASP.NET Core 6 Web API*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 6.0 中引入的最小 API 是这些改进背后的驱动力之一。我们将在 [*第 10 章*](B18507_10_Epub.xhtml#_idTextAnchor1040)
    中看到它的用法，即 *创建一个 ASP.NET Core 6 Web API*。
- en: In this section, we have learned about the improvements to the Lambda expressions;
    in the next section, we will see improvements to interpolated strings.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 Lambda 表达式的改进；在下一节中，我们将看到对插值字符串的改进。
- en: Enhancements to interpolated strings
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对插值字符串的改进
- en: 'Almost every application will have some sort of text processing. In .NET, there
    are many ways available for string manipulation, such as the `string` primitive
    type, `StringBuilder`, `ToString` overrides on types, String concatenation, and
    `string.Format`, which provides functionality to build a string from a composite
    format string. `String.Format` takes a format string and format items as input
    and generates the formatted string as depicted in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序都会有一些文本处理的需求。在 .NET 中，有许多字符串操作的方法可用，例如 `string` 原始类型、`StringBuilder`、类型上的
    `ToString` 覆盖、字符串连接以及 `string.Format`，后者提供了从复合格式字符串构建字符串的功能。`String.Format` 接收一个格式字符串和格式项作为输入，并生成如以下代码所示的格式化字符串：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the previous code, the positions `{0}` and `{1}` in the format string will
    be filled with the `Greeting` and `Message` format items respectively passed in
    as arguments. To make it more friendly and readable, C# 6 added a new language
    syntax called **interpolated strings**, as shown in the following code snippet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，格式字符串中的 `{0}` 和 `{1}` 位置将被分别传递的 `Greeting` 和 `Message` 格式项填充。为了使其更友好和易于阅读，C#
    6 添加了一种新的语言语法，称为 **插值字符串**，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When interpolated strings syntax is used, the .NET compiler generates the code
    that is best suited for the interpolated string to produce the same result.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用插值字符串语法时，.NET 编译器生成最适合插值字符串以产生相同结果的代码。
- en: 'Use a disassembler such as ILSpy or SharpLab to look at the generated code
    for the previous code snippet; it will look something like the following code
    snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反汇编器，如 ILSpy 或 SharpLab，查看之前代码片段生成的代码；它将类似于以下代码片段：
- en: '[PRE43]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[https://sharplab.io/](https://sharplab.io/) is a .NET code playground that
    shows the intermediate results of code compilation.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://sharplab.io/](https://sharplab.io/) 是一个 .NET 代码沙盒，它显示了代码编译的中间结果。'
- en: For the `message` interpolated string, the code was generated using concatenation.
    For the second string, `messageWithVersion`, where a non-string literal is involved,
    the generated code uses `string.Format`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `message` 插值字符串，代码是通过连接生成的。对于第二个字符串 `messageWithVersion`，其中涉及非字符串字面量，生成的代码使用
    `string.Format`。
- en: 'The compiler did what was intended, but it had a few issues where the code
    was generated using `string.Format`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器做了它打算做的事情，但它有几个问题，其中代码是通过使用 `string.Format` 生成的：
- en: The compiler parsed the interpolated string to generate code with `string.Format`.
    The same string must be parsed by the .NET runtime also to find the literal positions.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器解析了插值字符串以生成使用 `string.Format` 的代码。相同的字符串也必须由 .NET 运行时解析以找到字面量位置。
- en: The argument type of the literals in the `string.Format` method is `Object`.
    So, any value type used in `string.Format` involves boxing.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string.Format` 方法中字面量的参数类型是 `Object`。因此，在 `string.Format` 中使用的任何值类型都会涉及装箱。'
- en: The overload of `string.Format` takes a maximum of three arguments. Beyond three
    is served by the overload that takes `params object[]`. So, more than three arguments
    require the instantiation of an array.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string.Format` 的重载最多接受三个参数。超过三个参数由接受 `params object[]` 的重载提供支持。因此，超过三个参数需要实例化一个数组。'
- en: Since `string.Format` accepts only the `Object` type, we cannot use `ref struct`
    types such as `Span<T>` and `ReadOnlySpan<char>`.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `string.Format` 只接受 `Object` 类型，因此我们不能使用 `ref struct` 类型，如 `Span<T>` 和 `ReadOnlySpan<char>`。
- en: Since `ToString` is called on the captured expression, multiple transient strings
    will be created.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `ToString` 是在捕获的表达式上被调用的，因此会创建多个临时字符串。
- en: 'All the shortcomings mentioned here will be addressed with C# 10 by generating
    code with a series of appends to the string builder. For the same code that we
    discussed, if you look at the generated code in C# 10, it uses `DefaultInterpolatedStringHandler`
    as shown in the following code snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的所有缺点都将通过 C# 10 生成一系列追加到字符串构建器的代码来解决。对于之前讨论的相同代码，如果你查看 C# 10 中生成的代码，它将使用
    `DefaultInterpolatedStringHandler`，如下面的代码片段所示：
- en: '[PRE48]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: For interpolated strings, instead of using `string.Format`, C# 10 compiler now
    uses `DefaultInterpolatedStringHandler`. In the previously-generated code, `DefaultInterpolatedStringHandler`
    is constructed by passing in the two arguments, the number of characters in the
    literal portion of the interpolated string, and the number of positions in the
    string to be filled. `AppendLiteral` or `AppendFormatted` are called to append
    the literal or to append the formatted string, respectively. With the introduction
    of interpolated string handlers, the concerns discussed previously were addressed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于插值字符串，C# 10 编译器现在使用 `DefaultInterpolatedStringHandler` 而不是 `string.Format`。在之前生成的代码中，`DefaultInterpolatedStringHandler`
    是通过传递两个参数构建的，即插值字符串字面部分中的字符数和要填充的字符串中的位置数。通过调用 `AppendLiteral` 或 `AppendFormatted`
    来分别追加字面量或格式化字符串。随着插值字符串处理器的引入，之前讨论的问题得到了解决。
- en: For the same interpolated string code written in earlier versions of C#, there
    will be an improvement in the performance in C# 10\. We can also build our custom
    interpolated string handlers, which may be useful in situations when the data
    isn't going to be used as a string, or where conditional execution would be a
    logical fit for the target method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用 C# 早期版本编写的相同插值字符串代码，在 C# 10 中将会有性能提升。我们还可以构建我们自己的自定义插值字符串处理器，这在数据不打算用作字符串或条件执行对目标方法来说是逻辑上的合适选择的情况下可能很有用。
- en: In this section, we have learned about the improvements to the interpolated
    string, which gives us better performance over earlier versions. In the next section,
    let's learn about the extended property patterns.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了插值字符串的改进，它使我们比早期版本有更好的性能。在下一节中，让我们学习扩展属性模式。
- en: Extended property patterns
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展属性模式
- en: Pattern matching is a way to check an object's value or the value of a property
    having a full or partial match to a sequence. This is supported in C# in the form
    of `if…else` and `switch…case` statements. In modern languages, especially in
    functional programming languages such as F#, there is advanced support for pattern
    matching. With C# 7.0, new pattern matching concepts were introduced. Pattern
    matching provides a different way to express conditions to have more human-readable
    code. Pattern matching is being extended with every major release of C# since
    its introduction in C# 7.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是一种检查对象值或具有完整或部分匹配到序列的属性值的方法。这在 C# 中以 `if…else` 和 `switch…case` 语句的形式得到支持。在现代语言中，尤其是在像
    F# 这样的函数式编程语言中，有对模式匹配的高级支持。从 C# 7.0 开始，引入了新的模式匹配概念。模式匹配提供了一种不同的方式来表达条件，以使代码更具可读性。自
    C# 7 引入以来，模式匹配在每次主要版本发布时都得到了扩展。
- en: In this section, let's learn about the extended property pattern introduced
    in C# 10.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们学习 C# 10 中引入的扩展属性模式。
- en: 'Consider the following code snippet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE60]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In this code snippet, we have an object of the `Product` type, which contains
    the location of the product origin. Prior to C# 10, if we wanted to check whether
    the country of origin of this product was the USA, we would do something similar
    to the following code snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们有一个 `Product` 类型的对象，它包含产品的产地位置。在 C# 10 之前，如果我们想检查这个产品的原产国是否为美国，我们会做类似于以下代码片段的事情：
- en: '[PRE70]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'With C# 10, we can access the extended properties to make it more readable,
    as shown in the following code snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 10 中，我们可以访问扩展属性以使其更具可读性，如下面的代码片段所示：
- en: '[PRE72]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the preceding code, we are validating the `Country` property of `Location`
    using an extended property pattern.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在使用扩展属性模式验证 `Location` 的 `Country` 属性。
- en: In this section, we have learned about extended property patterns. Let's learn
    about the new addition to `caller` argument attributes in the next section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了关于扩展属性模式的内容。让我们在下一节中学习 `caller` 参数属性的新增内容。
- en: Addition to the caller argument attributes
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到调用者参数属性
- en: 'C# 5 first introduced `caller` argument attributes. They are `CallerMemberName`,
    `CallerFilePath`, and `CallerLineNumber`. These attributes make the compiler populate
    the method arguments in the generated code. They are used in various scenarios
    such as populating more data in the debug traces while firing an `OnNotifyPropertyChanged`
    event in the MVVM pattern. For example, consider the following code snippet, which
    defines a `Gift` model:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: C# 5 首次引入了 `caller` 参数属性。它们是 `CallerMemberName`、`CallerFilePath` 和 `CallerLineNumber`。这些属性使得编译器在生成的代码中填充方法参数。它们在各种场景中使用，例如在
    MVVM 模式下触发 `OnNotifyPropertyChanged` 事件时填充更多的调试跟踪数据。例如，考虑以下代码片段，它定义了一个 `Gift`
    模型：
- en: '[PRE74]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In the preceding `Gift` class definition, the `OnPropertyChanged` method is
    called every time the setter of the `Description` property is called. In the `OnProperyChanged`
    method implementation, we have the `propertyName` argument attributed with `CallerMemberName`.
    This will make the compiler generate a setter as shown in the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `Gift` 类定义中，每当 `Description` 属性的设置器被调用时，都会调用 `OnPropertyChanged` 方法。在 `OnPropertyChanged`
    方法实现中，我们有一个带有 `CallerMemberName` 属性的 `propertyName` 参数。这将使编译器生成如下所示的设置器：
- en: '[PRE101]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: In this generated code, the argument to `OnProperyChanged` is auto-populated
    with the property name, `Description`, by the compiler. This is a handy feature
    for the developer that helps to write error-free code. The other two `caller`
    argument attributes, `CallerFilePath` and `CallerLineNumber`, populate the file
    path of the `caller` method and line number respectively.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段生成的代码中，编译器自动填充了 `OnProperyChanged` 的参数，即属性名 `Description`。这对于开发者来说是一个方便的功能，有助于编写无错误的代码。其他两个
    `caller` 参数属性 `CallerFilePath` 和 `CallerLineNumber` 分别填充调用方法的文件路径和行号。
- en: '`CallerArgumentExpression` is a new addition to these in C# 10\. As the name
    suggests, the attribute makes the compiler auto-populate the argument expression.
    Let''s build a simple argument validation helper class that does the `null` check
    for the parameters passed. Consider the following implementation of an `ArgumentValidation`
    class, which implements a helper method that throws `ArgumentException` if the
    argument value is `null`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallerArgumentExpression` 是 C# 10 中新增的功能之一。正如其名所示，该属性使编译器自动填充参数表达式。让我们构建一个简单的参数验证辅助类，该类对传递的参数执行
    `null` 检查。考虑以下 `ArgumentValidation` 类的实现，它实现了一个辅助方法，如果参数值为 `null`，则抛出 `ArgumentException`：'
- en: '[PRE110]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'In the `ThrowIfNull` method, we are performing the `null` check and throwing
    `ArgumentException` with the details including the parameter name, which is picked
    from `CallerArgumentExpression`. We can use the preceding helper class to perform
    the `null` check on the arguments passed to a method. For example, consider the
    following method, which adds the passed-in product to the cart:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ThrowIfNull` 方法中，我们执行 `null` 检查，并使用从 `CallerArgumentExpression` 中选择的参数名抛出
    `ArgumentException`。我们可以使用前面的辅助类对传递给方法的参数执行 `null` 检查。例如，考虑以下方法，该方法将传入的产品添加到购物车中：
- en: '[PRE123]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In this method, we use the `ArgumentValidation` helper class to check the `null`
    condition of the `product` argument. The generated code for the call to the `ThrowIfNull`
    helper method will be `ArgumentValidation.ThrowIfNull(product, "product");`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们使用 `ArgumentValidation` 辅助类来检查 `product` 参数的 `null` 条件。调用 `ThrowIfNull`
    辅助方法的生成代码将是 `ArgumentValidation.ThrowIfNull(product, "product");`。
- en: The compiler auto-populated the parameter name in the string argument. Caller
    arguments will be useful where we want to add more details to the traces, which
    will help in troubleshooting the issue.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器自动填充了字符串参数中的参数名。调用参数将在我们想要向跟踪添加更多详细信息的地方很有用，这将有助于解决问题。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the major additions to the C# language
    features in version 10\. We have seen how C# 10 simplifies the code written with
    `implicit` and `global` using directives. We have learned about `record` structs
    and how they compare with the `record` class introduced in C# 9\. We have also
    learned about the improvements to Lambda expressions, expression type inference,
    and explicitly specifying the return type for the expression. We have also seen
    performance improvements in interpolated strings. We have also learned how to
    build throw helpers using the `CallerArgumentExpression` attribute.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 C# 10 版本中语言特性的主要新增功能。我们看到了 C# 10 如何简化使用 `implicit` 和 `global` 使用指令编写的代码。我们了解了
    `record` 结构体以及它们与 C# 9 中引入的 `record` 类的比较。我们还学习了 Lambda 表达式、表达式类型推断以及显式指定表达式返回类型的改进。我们还看到了字符串插值的性能提升。我们还学习了如何使用
    `CallerArgumentExpression` 属性构建抛出辅助器。
- en: 'With this chapter, we have gained the skills to leverage these new features
    of C# 10 features in the enterprise e-commerce application that we are going to
    build in the coming chapters. In addition to these, there are a few more small
    enhancements. You can refer to the C# language documentation to learn more here:
    [https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10).
    We will be highlighting the new features of C# 10 and .NET 6 throughout this book
    while implementing different features of our e-commerce application.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们获得了利用 C# 10 新特性的技能，这些特性将在接下来的章节中构建的企业电子商务应用中使用。除此之外，还有一些其他的小增强。您可以参考
    C# 语言文档以了解更多信息：[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10)。在实现我们的电子商务应用的不同功能的同时，我们将在这本书中突出显示
    C# 10 和 .NET 6 的新特性。
- en: In the upcoming part, we will learn about the cross-cutting concerns that form
    the building blocks of our e-commerce application.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将学习构成我们电子商务应用程序构建块的一些横切关注点。
- en: Questions
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'After reading the chapter, you should be able to answer the following questions:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，你应该能够回答以下问题：
- en: 'True or false? Record structs are mutable:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确或错误？记录结构体是可变的：
- en: a. True
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b. False
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: '**Answer: a**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：a**'
- en: Which keyword should you use to make a record struct immutable?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该使用哪个关键字来使记录结构体不可变？
- en: a. A record struct is immutable by default.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: a. 记录结构体默认是不可变的。
- en: b. `readonly`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: b. `readonly`.
- en: c. `finally`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: c. `finally`.
- en: d. `sealed`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: d. `sealed`.
- en: '**Answer: b**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：b**'
- en: 'True or false? A compiler will infer the type expressions in all the scenarios:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确或错误？编译器将在所有场景中推断类型表达式：
- en: a. True
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b. False
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: '**Answer: b**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：b**'
- en: In which version of C# were caller argument attributes first introduced?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哪个版本的 C# 中首次引入了调用者参数属性？
- en: a. C# 9
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: a. C# 9
- en: b. C# 8
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: b. C# 8
- en: c. C# 5
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: c. C# 5
- en: d. C# 7
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: d. C# 7
- en: '**Answer: c**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：c**'
