- en: Routing System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes the routing functionalities of ASP.NET Core. The routing
    part of the framework is designed to provide a dynamic routing system that's fully
    customizable and overridable to cover most of the use cases of a web service.
    Here, we will discover how to use *conventional* and *attribute routing* approaches,
    and then we will dig into the use of routing constraints in order to match complex
    rules and provide higher customization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of the routing system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conventional routing versus attribute routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding routing parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom attribute routing and custom routing constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The topics covered in this chapter provide some basic knowledge around the routing
    system of ASP.NET Core and how to use the routing engine of ASP.NET Core to cover
    all the use cases that are needed by our web service.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the routing system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The routing system of ASP.NET Core maps an incoming request to a *route handler*.
    In ASP.NET Core, the `Startup` class is responsible for configuring the routes
    that are needed by the application. Furthermore, the routing functionalities of
    ASP.NET Core are implemented using a middleware approach. Let''s take a closer
    look at the `Startup` class and how it initializes the routing system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses two extension methods: `UseRouting` and `UseEndpoints`.
    These methods were introduced in the latest release of ASP.NET Core. In the previous
    version of the framework, the routing system was initialized with the `UseMvc`
    extension method, which is now deprecated. The `UseRouting` extension method is
    used to define where, in the middleware pipeline, the routing decisions are made.
    On the other side, the `UseEndpoints` extension method declares the mapping of
    effective routes. For example, in the preceding code snippet, the `Startup` class
    uses the `MapControllers()` extension method to map the controller routes and
    declares the default routing convention that''s implemented by ASP.NET Core.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, when the `Startup` class executes the `UseRouting` and `UseEndpoints`
    extension methods, ASP.NET Core adds a new `EndpointRoutingMiddleware` class to
    mark the routing point and `EndpointMiddleware` in the pipeline, which describes
    our routes. The preceding calls can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf3f48b4-907b-4e22-a636-b9c151f486d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Furthermore, it is possible to define new *route templates* inside our `Startup`
    class using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This implementation creates a new *route template* that maps a generic route
    such as `https://myhostname/mycontroller/myaction`with a controller named `MyController`
    and an action named `MyAction`. This way of defining routing is called **conventional
    routing**, in the sense that it establishes a convention between our handlers
    (the controllers) and the URI system. We will discuss conventional routing in
    more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Conventional routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *conventional* *routing* is the default routing approach in ASP.NET Core*.*
    As we have already seen, this approach uses the `app.UseEndpoints` extension method
    in the `Startup` class to declare routing templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, ASP.NET Core applies the `default` *route template* to the routing
    engine, which maps each segment of our URL with the `controller` name, the `action`
    name, and the `id` name*,* respectively*.* Furthermore, it is possible to define
    multiple routes in our application by adding them to the routing builder in the
    `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `https://myhostname/order/givemeorders` route will be mapped
    to the `Get` action of `OrderController`. We should notice that therouting template
    example we defined in the preceding code is not compliant with the REST architectural
    style. Accordingly, it doesn''t respect the 2^(nd) level of the Richardson Maturity
    Model, as mentioned in [Chapter 1](b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml),
    *REST 101 and Getting Started with ASP.NET Core*. Furthermore, if we apply the
    `default` routing template to `OrderController` we discussed in previous chapters,
    the `Get` action method will respond to the following URI: `https://localhost/order/get`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our routing template compliant with the Richardson Maturity Model,
    let''s introduce the `Map` method that''s provided by ASP.NET Core. It is possible
    to map different HTTP verbs using *routing templates*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `MapGet`, `MapPost`, `MapPut`, and `MapDelete` methods accept the *route
    template* as the first parameter and a `RequestDelegate` method, which provides
    a way to handle `HttpContext` of the current request. However, it is not possible
    to call the `OrderController` logic in `RequestDelegate` because there isn't an
    effortless way to access the controllers' instances from the context. Therefore,
    there isn't an easy way to implement a REST-compliant routing system using *conventional
    routing.* In general, conventional routing is mainly designed for web applications
    that serve views and HTML. An alternative solution is to use the *attribute routing*
    technique, which is the most solid way to implement controllers' routing in a
    web services context.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *attribute routing* technique is a different way to implement routing in
    ASP.NET Core. It moves the declaration of routing within the controllers'' implementation
    using attributes to describe the routes in a metaprogramming way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Route` attribute declares the routing template within the controller or
    the action. The routing attribute is the default approach of the web API template
    in ASP.NET Core. Another critical thing to notice is that this practice doesn't
    need any route definition in the `Startup` class; therefore, `app.MapControllers()`
    is invoked without route parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, this kind of approach also provides more flexibility when it comes
    to binding each action method with a specific route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding controller uses `HttpVerb` to map each action method to one particular
    HTTP verb. Furthermore, it also uses the `HttpVerb` attribute to define the last
    segment of the URI, which usually contains the parameters of our target resource.
  prefs: []
  type: TYPE_NORMAL
- en: The `Route("api/order")` attribute defines a static route segment. ASP.NET Core
    provides some reserved placeholders, that is, `[controller]`, `[action]`, and
    `[area]`*,* whichare replaced at runtime with the corresponding `controller`,
    `action`, or `area`. For example, we can achieve the same result by using `Route("api/[controller]")`
    because the `OrderController` name will replace the `[controller]` placeholder.
    As I mentioned in the previous chapter, I strongly suggest that you avoid this
    kind of approach because, in a real-world application, you may accidentally change
    the route of your API by merely refactoring a controller's name.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, let's have a look at custom attribute routing.
  prefs: []
  type: TYPE_NORMAL
- en: Custom attribute routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The routing engine of ASP.NET Core also provides a way for us to create our
    routing attributes. This technique is useful in complex routing systems where
    it is essential to keep a conceptual order between different routes. An example
    of a custom routing definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The class extends the `Attribute` abstract class, which is to be applied as
    an attribute. It implements `IRouteTemplateProvider` to get the attributes of
    the r*outing template workflow.* As a result, the application of the attribute
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This approach is really useful when we want to implement a more complex routing
    system. Therefore, it is possible to apply concepts such as inheritance to improve
    the reusability of the implemented routing rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section provided an understanding of different routing approaches of ASP.NET
    Core: *conventional routing* and *attribute routing*. In the next section, we
    will discover how to use the *routing constraints* rules provided by the framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Routing constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Routing constraints* are part of the templating routing system of ASP.NET
    Core. They provide a way for us to match a route with a parameter type or a set
    of values, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, our route template will match all the `https://myhostname/mycontroller/myaction`
    calls and all the calls that present a valid `Guid` as an `id` parameter, for
    example, `https://myhostname/mycontroller/myaction/4e10de48-9590-4531-9805-799167d58a44`.
    The `{id:guid?}` expression gives us two pieces of information about constraints:
    first, the parameter must have the `guid` type, and secondly, it is specified
    as optional using the `?` character. ASP.NET Core provides a rich set of built-in
    *routing constraints* such as *min* and *max* *values*, *regular expressions,*
    and *range*. It is also possible to combine them using the colon operator (`:`),
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are combining the `int` constraint with the `min(1)` constraint.
    Therefore, we can cover a large number of use cases and business rules. In addition,
    we can improve our routing matching logic by providing different action methods
    for the same URI that is receiving a different type of data. It is also important
    to note that the same *routing constraints* can also be applied to the attribute
    routing part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'ASP.NET Core provides a rich set of default routing constraints that can be
    used out of the box. The following link lists all the additional default routing
    constraints of ASP.NET Core: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0#route-constraint-reference](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0#route-constraint-reference).'
  prefs: []
  type: TYPE_NORMAL
- en: Custom constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If default constraints don''t cover all the business rules of your application,
    ASP.NET Core exposes all the necessary components to extend the behavior of route
    constraints so that you can define your own rules. It is possible to extend routing
    constraints by implementing the `IRouteConstraint` interface provided by `Microsoft.AspNetCore.Routing`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows an example of the implementation of `IRouteConstraint`.
    The interface exposes the `Match` method, which allows us to match the incoming
    route values with a custom set of values. In this case, the constraint matches
    a set of currencies. In order to use `CurrencyConstraint`, it is necessary to
    configure it in the `ConfigureServices` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to use the custom `CurrencyConstraint` routing constraint using
    the regular syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `default` route will match only the parameter that's using
    the logic that's implemented in the `CurrencyConstraint` class. Therefore, it
    will match the `https://localhost/controller/action/eur`, `https://localhost/controller/action/usd`,
    and `https://localhost/controller/action/gbp` URIs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ASP.NET Core routing system can be extended and used to cover a lot of use
    cases. In general, it provides all the necessary functionalities out of the box.
    It is essential to understand that *conventional routing* is generally used by
    web applications, while web services routing is usually achieved by applying the
    *attribute routing*. This chapter described how to deal with these two approaches,
    how to use the out-of-box constraints provided by ASP.NET Core and how to implement
    our custom routing constraints. In the next chapter, we will look at how to deal
    with the filter pipeline of ASP.NET Core and in which way they differ from the
    implementation of the middleware classes.
  prefs: []
  type: TYPE_NORMAL
