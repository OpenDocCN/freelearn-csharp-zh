- en: 4 REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter delves into the heart of web application communication–REST APIs.
    In today''s connected digital world, effective communication between different
    applications is paramount, and RESTful APIs play a pivotal role in facilitating
    this interaction.We start by exploring the basic fabric of the web: the HTTP protocol.
    We touch on the core HTTP methods such as GET, POST, PUT, and DELETE to see how
    they carry out CRUD (Create, Read, Update, Delete) operations in a RESTful context.
    We then turn our attention to HTTP status codes–the system''s way of informing
    clients about the status of their requests–and HTTP headers.Since APIs evolve
    and managing these changes without disrupting existing clients is a significant
    challenge, we look at different strategies for API versioning and the trade-offs
    involved with each.Then we learn about the Data-Transfer Object (DTO) pattern.
    Packaging data into DTOs can provide many benefits, from reducing the number of
    calls to better encapsulation and improved performance when sending data over
    the network.Finally, we also explore the importance of defining clear and robust
    API contracts, which ensures API stability. We discuss techniques for designing
    and documenting these contracts, ensuring they serve as practical guides for API
    consumers.By the end of this chapter, you''ll know how REST APIs work and will
    be ready to start building some using ASP.NET Core as we move further into our
    architectural journey in the next few chapters.In this chapter, we cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: REST & HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data Transfer Object (DTO)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin with REST.
  prefs: []
  type: TYPE_NORMAL
- en: REST & HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**REST**, or **Representational State Transfer**, is a way to create internet-based
    services, known as web services, web APIs, REST APIs, or RESTful APIs. Those services
    commonly use HTTP as their transport protocol. REST reuses well-known HTTP specifications
    instead of recreating new ways of exchanging data. For example, returning an HTTP
    status code `200 OK` indicates success, while `400 Bad Request` indicates failure.Here
    are some defining characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Statelessness:** In a RESTful system, every client-to-server request should
    contain all the details necessary for the server to comprehend and execute it.
    The server retains no information about the client''s most recent HTTP request.
    This enhances both reliability and scalability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching capabilities:** Clients should be able to cache responses to enhance
    performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity and lose coupling:** REST uses HTTP to ensure a simplified, decoupled
    architecture. This makes the development, maintenance, and scaling of REST APIs
    easier and facilitates their usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource identifiability:** Each REST API endpoint is a distinct resource,
    enabling us to secure each piece of the system separately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface as a contract:** The REST API layer serves as an exchange contract
    or an abstraction. It effectively conceals the backend system''s underlying implementation,
    fostering streamlined interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we could delve much deeper into the intricacies of REST APIs, the preceding
    characteristics serve as foundational knowledge, providing good enough knowledge
    to get started with RESTful services. Having navigated through these essentials,
    let's shift our focus toward understanding how REST APIs harness the power of
    HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'HTTP methods, also known as verbs, define the type of action a client can perform
    on a resource in a RESTful API. Each method represents a specific operation that
    defines the endpoint''s intent on a resource. Here is a list of the most frequently
    used methods, what they are for, and their expected success status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Typical role** | **Success status code** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Retrieve a resource (read data). | 200 OK |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Create a new resource. | 201 CREATED |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Replace a resource. | 200 OK or 204 No Content |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Delete a resource. | 200 OK or 204 No Content |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Partially update a resource. | 200 OK |'
  prefs: []
  type: TYPE_TB
- en: Next, we explore the commonly used status codes.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Status code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'HTTP status codes are part of the HTTP response and provide the client with
    information about the success or failure of their request; the status of the request.Status
    codes touching similar subjects are grouped under the same broad “hundredth” categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1XX` (informational) codes indicate that the request was received and the
    process is continuing, such as **100 Continue** and **101 Switching Protocols**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2XX` (successful) codes indicate that the request was received successfully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3XX` (redirection) codes indicate that the client must take further action
    to complete the redirection request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4XX` (client error) codes indicate an error on the client''s part, such as
    validation errors. The client sent an empty required field, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5XX` (server error) codes indicate that the server failed to fulfill an apparently
    valid request and that the client cannot do anything about it (retrying the request
    is not an option).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table explains some of the most common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Status code** | **Role** |'
  prefs: []
  type: TYPE_TB
- en: '| **200 OK** | Indicates the request has succeeded. It usually includes data
    related to the resource in the response body. |'
  prefs: []
  type: TYPE_TB
- en: '| **201 CREATED** | Indicates the has succeeded and the system created a resource.
    It should also include a `Location` HTTP header pointing to the newly created
    resource and can include the new entity in the response body. |'
  prefs: []
  type: TYPE_TB
- en: '| **202 ACCEPTED** | Indicates the request has been accepted for processing
    but is not processed yet. We use this code for asynchronous operations.In an event-driven
    system (see *Chapter 17*, *Introduction to Microservices Architecture*), this
    could mean that an event has been published, the current resource has completed
    its job (published the event), but to know more, the client needs to contact another
    resource, wait for a notification, just wait, or can’t know. |'
  prefs: []
  type: TYPE_TB
- en: '| **204 NO CONTENT** | Indicates the request has succeeded with no content
    in the response body. |'
  prefs: []
  type: TYPE_TB
- en: '| **302 FOUND** | Indicates that the requested resource resides temporarily
    under a different URL specified in the `Location` header. We commonly use this
    status code for redirection. |'
  prefs: []
  type: TYPE_TB
- en: '| **400 BAD REQUEST** | Indicates that the server could not understand or process
    the request. This usually relates to a validation error like a bad input or a
    missing field. |'
  prefs: []
  type: TYPE_TB
- en: '| **401 UNAUTHORIZED** | Indicates that the request requires user authentication
    to access the resource. |'
  prefs: []
  type: TYPE_TB
- en: '| **403 FORBIDDEN** | Indicates that the server understood the request but
    refused to authorize it. This usually means the client lacks the access rights
    for the resource (authorization). |'
  prefs: []
  type: TYPE_TB
- en: '| **404 NOT FOUND** | Indicates the resource does not exist or was not found.
    REST APIs often return this from valid endpoints. |'
  prefs: []
  type: TYPE_TB
- en: '| **409 CONFLICT** | Indicates that the server cannot complete the request
    due to a conflict with the current state of the resource. A typical scenario would
    be that the entity has changed between its read operation ( `GET` ) and the current
    update ( `PUT` ) operation. |'
  prefs: []
  type: TYPE_TB
- en: '| **500 INTERNAL SERVER ERROR** | Indicates that an unhandled error occurred
    on the server side and prevented it from fulfilling the request. |'
  prefs: []
  type: TYPE_TB
- en: Now that we covered the HTTP methods and status codes, we look at how to pass
    more metadata between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'REST APIs leverage HTTP headers to transmit clients’ information and describe
    their options and capabilities. Headers are part of both the request and the response.One
    well-known header is the `Location` header, that we use for different purposes.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: After creating an entity (`201 Created`), the `Location` header should point
    to the `GET` endpoint where the client can access that new entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After starting an asynchronous operation (`202 Accepted`), the `Location` header
    could point to the status endpoint where you can poll for the state of the operation
    (has it completed, failed, or is it still ongoing).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a server wants to instruct a client to load another page (a redirection),
    the `Location` header contains the destination URL. The following status codes
    are the most common for redirections: `301 Moved Permanently`, `302 Found`, `303
    See Other`, `307 Temporary Redirect`, and `308 Permanent Redirect`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Retry-After` header can also come in handy when mixed with `202` `Accepted`,
    `301 Moved Permanently`, `429 Too Many Requests`, or `503 Service Unavailable`.
    The `ETag` header identifies the version of the entity and can be used in conjunction
    with `If-Match` to avoid *mid-air collisions*. The `ETag` and `If-Match` headers
    form a sort of *optimistic concurrency* method that prevents *request two* from
    overwriting changes made by *request one* when changes are happening simultaneously
    or not in the expected order; a.k.a. a way to manage conflicts. We can also add
    the following to the mix as an example of HTTP headers that describe a REST endpoint:
    `Allow`, `Authorization`, and `Cache-Control`. The list is very long, and it would
    help no one to enumerate all HTTP headers here.'
  prefs: []
  type: TYPE_NORMAL
- en: This information should be enough theory to get you started with HTTP and REST.
    In case you want to know more, I left links to the MDN web docs about HTTP in
    the Further Reading section at the end of the chapter.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we look at versioning because nothing stays the same forever; business
    needs change, and APIs must evolve with them.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Versioning is a crucial aspect of a REST API. Whether the version of the API
    is long-lived or transitory (during the decommissioning cycle of an old endpoint,
    for example), both ends of the pipe must know what to expect; what API contract
    to respect. Unless you are your only consumer, you’ll need a way for the API clients
    to query specific API versions when the contract changes.This section explores
    a few ways to think about our versioning strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Default versioning strategy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The default strategy is the first thing to consider when versioning an API.
    What happens when no version is specified? Will the endpoint return an error,
    the first or the latest version?If the API returns an error, you should implement
    that versioning strategy from day one so clients know a version is required. In
    this case, there is no real drawback. On the other hand, putting this strategy
    in place after the fact will break all clients that do not specify a version number,
    which might not be the best way to keep your consumers happy.The second way is
    always to return the first version. This method is an excellent way to preserve
    backward compatibility. You can add more endpoint versions without breaking your
    consumers.The opposite way is always to return the latest version. For consumers,
    this means specifying a version to consume or be up to date or break, and this
    might not be the best user experience to provide to your consumers. Nonetheless,
    many have opted for this default strategy.Another way to go is to pick any version
    as the default baseline for the API (like version 3.2, for example) or even choose
    a different version per endpoint. Say you default to 3.2, then deploy 4.0\. Since
    the clients must opt-in to access the new API, they won’t break automatically
    and will have the time to update from 3.2 to 4.0 following their own roadmap.
    This is a good strategy to default to a well-known and stable API version before
    moving forward with breaking changes.
  prefs: []
  type: TYPE_NORMAL
- en: No matter what you choose, always think it through by weighing the pros and
    cons.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we explore ways to define those versions.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning strategy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Of course, there are multiple ways to think this through. You can leverage
    URL patterns to define and include the API version, like `https://localhost/v2/some-entities`.
    This strategy is easier to query from a browser, making it simple to know the
    version at a glance, but the endpoint is not pointing to a unique resource anymore
    (a key principle of REST), as each resource has one endpoint for each version.
    Nonetheless, this way of versioning an API is used extensively and is one of the
    most popular, if not *the* most popular way of doing REST versioning, even if
    it violates one of its core principles (debatably).The other way is to use HTTP
    headers. You can use a custom header like `api-version` or `Accept-version`, for
    example, or the standard `Accept` header. This way allows resources to have unique
    endpoints (URI) while enabling multiple versions of each entity (multiple versions
    of each API contract describing the same entity).For example, a client could specify
    an HTTP header while calling the endpoint like this (custom header):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or like the following, by leveraging the `Accept` header for *content negotiation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Different people are using different values for the `Accept` headers, for example:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`application/vnd.myapplication.v2+json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/vnd.myapplication.entity.v2+json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/vnd.myapplication.api+json; version=2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/json; version=2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whether you are using one way or another, you’ll most likely need to version
    your APIs at some point. Some people are strong advocates of one way or the other,
    but ultimately, you should decide on a case-by-case basis what best covers your
    needs and capacities: simplicity, formality, or a mix of both.'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a method (verb), the client (and the endpoint) can express the intent to
    create, update, read, or delete an entity. With a status code, the endpoint can
    tell the client the state of the operation. Adding HTTP headers, clients, and
    servers can add more metadata to the request or response. Finally, by adding versioning,
    the REST API can evolve without breaking existing clients while giving them options
    to consume specific versions.With what we just covered, you should have more than
    what’s needed to follow along with the examples in this book and build a few REST
    APIs along the way. Next, we explore how those HTTP pieces create API contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Data Transfer Object (DTO)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Data Transfer Object (DTO) design pattern is a robust approach to managing
    and transferring data in a service-oriented architecture like REST APIs. The DTO
    pattern is about organizing the data to deliver it to API clients optimally. DTOs
    are an integral part of the API contract, that we explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A DTO's objective is to *control an endpoint's inputs and outputs* by loosely
    coupling the exposed API surface from the application’s inner workings. DTOs empower
    us to craft our web services the way we want the consumers to interact with them.
    So, no matter the underlying system, we can use DTOs to design endpoints that
    are easier to consume, maintain, and evolve.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each DTO represents an entity with all the necessary properties. That entity
    is either an input or an output and allows crafting the interaction between the
    clients and the API.DTOs serve to loosely couple our domain from the data exposed
    over the API by adding a level of abstraction. This allows us to change the underlying
    domain model without affecting the data exposed to the API consumers and vice
    versa.Another way to use a DTO is by packaging related pieces of information together,
    allowing a client to make a single call to fetch all necessary data, thereby eliminating
    the need for multiple requests.Based on REST and HTTP, the flow of a request goes
    like the following: an HTTP request comes in, some code is executed (domain logic),
    and an HTTP response goes back to the client. The following diagram represents
    this flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: An HTTP request getting in and out of a REST API endpoint.](img/file20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: An HTTP request getting in and out of a REST API endpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we take that flow and change HTTP with DTO, we can see that a DTO can
    be part of the data contract as an input or an output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: An input DTO hitting some domain logic, then the endpoint returning
    an output DTO](img/file21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: An input DTO hitting some domain logic, then the endpoint returning
    an output DTO'
  prefs: []
  type: TYPE_NORMAL
- en: 'How can the HTTP request become an object? Most of the time:'
  prefs: []
  type: TYPE_NORMAL
- en: We use deserialization or data binding for inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use serialization for outputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptual examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conceptually, say that we are building a web application allowing people to
    register for events. We explore two use cases next.
  prefs: []
  type: TYPE_NORMAL
- en: Registering for an activity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first scenario we are exploring is a user registering for an activity.
    An activity is a sort of event in the system. We use an external payment gateway,
    so our application never handles financial data. Nevertheless, we must send transaction
    data to our backend to associate and complete the payment. The following diagram
    depicts the workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: The DTOs implicated in an activity registration flow.](img/file22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: The DTOs implicated in an activity registration flow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the request could look like the following JSON snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the following JSON snippet could represent the body of the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this is a very lightweight version of a registration system. The
    objective is to show that:'
  prefs: []
  type: TYPE_NORMAL
- en: Three entities came in as an HTTP POST request (a registrant, an activity, and
    payment information).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system executed some business logic to register the person to the activity
    and to complete the financial transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The API returned mixed information to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This pattern is handy to input and output only what you need. If you are designing
    the user interface that consumes the API, outputting a well-thought DTO can ensure
    that the UI renders the next screen just by reading the response from the server,
    saving your UI to fetch more data, speeding up the process, and improving the
    user experience.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We explore fetching information about an activity registration next.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching activity registration details
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the same system, the user wants to review the details of an activity he
    registered using the preceding process. In this case, the flow goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends the registration identifier over a `GET` request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system fetches the registrant information, the activity information, and
    the number of seats the user reserved for that activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server returns the data to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram visually represents the use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: The DTOs implicated in fetching the info related to a registered
    activity.](img/file23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: The DTOs implicated in fetching the info related to a registered
    activity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the input would be part of the URL, like `/registrations/123`.
    The output would be part of the response body, and could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By creating that endpoint using a well-crafted output DTO, we condensed three
    HTTP requests into one: the registrant, the activity, and the registration (number
    of seats). This powerful technique applies to any technology, not just ASP.NET
    Core, and allows us to design APIs without connecting clients directly to our
    data (loose coupling).'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A data transfer object (DTO) allows us to design an API endpoint with specialized
    input and output instead of exposing the domain or data model. Those DTOs shield
    our internal business logic, which improves our ability to design our APIs and
    also helps us make them more secure.
  prefs: []
  type: TYPE_NORMAL
- en: By defining DTOs, we can avoid a malicious actor trying to bind data that he
    should not have access to. For example, when using an input “Login DTO” that only
    contains a `username` and `password` properties, a malicious user could not try
    to bind the `IsAdmin` field available in our domain and database. There are other
    ways to mitigate this, but they are out of the scope of this chapter, yet, a DTO
    is a great candidate to mitigate this attack vector.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This separation between the presentation and the domain is a crucial element
    that leads to having multiple independent components instead of a bigger, more
    fragile one or leaking the internal data structure to the clients consuming the
    API.We explore building APIs in the next few chapters and explore some topics
    more in-depth in *Section 4*, *Designing at Application Scale*.Using the DTO pattern
    helps us follow the SOLID principles in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: A DTO adds clear boundaries between the domain logic or the data and
    the API contract, dividing one model into several distinct responsibilities to
    help keep things isolated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: A DTO is a smaller, specifically crafted model that serves a clear purpose.
    With a DTO, we now have two models (domain and API contract) and several classes
    (input DTO, output DTO, and domain or data entities) instead of a generic one
    (only the domain or data entity).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: N/A'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we look at how we can glue the pieces that we explored so far into API
    contracts.
  prefs: []
  type: TYPE_NORMAL
- en: API contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'API Contracts serve as an essential blueprint, outlining the rules of engagement
    between your API and its consumers. This includes available endpoints, HTTP methods
    they support, expected request formats, and potential response structures, including
    HTTP status codes.These contracts provide clarity, robustness, consistency, and
    interoperability, facilitating seamless system interactions, no matter the language
    they are built with. Moreover, well-documented API contracts are a reliable reference
    guide, helping developers understand and utilize your API effectively. Thus, designing
    comprehensive and clear API contracts is critical in building high-quality, maintainable,
    and user-friendly APIs.An API contract describes a REST API, so a consumer should
    know how to call an endpoint and what to expect from it in return. What an endpoint
    does or the capability it provides should be clear just by reading its contract.Each
    endpoint in a REST API should provide at least the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: A Uniform Resource Identifier (URI) that indicates where to access it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An HTTP method that describes the type of operation it does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An input that defines what is needed for the operation to happen. For example,
    the input can be the HTTP body, URL parameters, query parameters, HTTP headers,
    or even a combination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An output that defines what the client should expect. A client should expect
    multiple output definitions since an endpoint will not return the same information
    if the request succeeds or fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input and output of an endpoint are often DTOs, making DTOs even more important.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are multiple ways to define API contracts. For example, to define an
    API contract, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open any text editor, such as MS Word or Notepad, and start writing a document
    describing our web APIs; this is probably the most tedious and least flexible
    way. I do not recommend this for many reasons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing specifications in Markdown files and saving those files within your
    project Git repository for easy discoverability. Very similar to MS Word, but
    more accessible for all team members to consume. This approach is better than
    Word, yet not optimal since you need to manually update those files when the API
    changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an existing standard, such as the OpenAPI specification (formerly Swagger).
    This technique implies a learning curve, but the result should be easier to consume.
    Moreover, many tools allow us to create automation using the OpenAPI specs. This
    approach is starting to remove the need for manual intervention.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a code-first approach and ASP.NET Core tooling to extract the OpenAPI specs
    from your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use any other tools that fit our requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Postman is a fantastic tool for building web APIs documentation, test suites,
    and experimenting with your APIs. It supports OpenAPI specifications, allows you
    to create mock servers, supports environments, and more.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'No matter the tools, there are two major trends in how to design the API contract
    of a REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: Design the contract first, then build the API (contract-first).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the API, then extract the contract for the code (code-first).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To design the contract-first, one must adopt a tool to write the specifications,
    then code the API according to the specs.
  prefs: []
  type: TYPE_NORMAL
- en: I left a link in the *Further Reading* section below about Open API.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On the other hand, to use a code-first approach and automatically extract the
    OpenAPI specifications from the API, we must ensure our endpoints are discoverable
    by the .NET `ApiExplorer`.No matter how you do it, in ASP.NET Core, we use classes
    and struct to represent the data contract of our REST APIs; whether it happens
    before or after you write the API contract does not matter. Since I prefer to
    write C# to YAML or JSON, we explore how to leverage Swagger to generate a data
    contract in a code-first manner next.
  prefs: []
  type: TYPE_NORMAL
- en: Code-first API Contract
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we have a tiny API with two endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the specified entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code doesn’t do much and returns fake data, but it is enough to explore
    its data contract.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that code is like playing LEGO® blocks, but we connect many tiny patterns
    used together to create our software and create value. Understanding and learning
    that skill will lead you beyond just being able to use some canned magic recipe,
    which limits you to what people share with you.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this sample, we use the OpenAPI specification to describe our API. To save
    ourselves from writing JSON and go code-first instead, we leverage the SwagerGen
    package.
  prefs: []
  type: TYPE_NORMAL
- en: To use SwaggerGen, we must install the `Swashbuckle.AspNetCore.SwaggerGen` NuGet
    package.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here’s the `Program.cs` file, without the endpoints, showing how to leverage
    SwaggerGen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines are the only things we must do to use SwaggerGen in a
    project, which will generate the API contract in the OpenAPI specification for
    us. The JSON file is very long (113 lines), so I only pasted some snippets in
    the book for clarity. However, you can navigate to the `/swagger/v1/swagger.json`
    URL to access the complete JSON code or open the `swagger.json` file in the project.
  prefs: []
  type: TYPE_NORMAL
- en: I created the `swagger.json` file in the project for convenience. The tool does
    not generate a physical file.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s have a look at those endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: The first endpoint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The code of the first endpoint that allows a client to read an entity looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the API contract we can extract from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Contract segment** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP Method | GET |'
  prefs: []
  type: TYPE_TB
- en: '| URI | `/{id}` (for example, `/123` ) |'
  prefs: []
  type: TYPE_TB
- en: '| Input | The `id` parameter |'
  prefs: []
  type: TYPE_TB
- en: '| Output | An instance of the `ReadOneDto` class. |'
  prefs: []
  type: TYPE_TB
- en: 'Sending the following HTTP request (you can use the `ReadOneEntity.http` file)
    results in the output that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The trimmed-down response is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, when we query the API for the entity `id=123`, the endpoint returns
    that entity with a `200 OK` status code, and the response body is a serialized
    instance of the `ReadOneDto` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `.http` files are new to VS 2022 and allow us to write and execute HTTP
    requests from VS itself. I left a link in the *Further Reading* section if you
    want to know more.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'SwaggerGen generated the following OpenAPI specs for the first endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'That snippet describes the endpoint and references our output model (highlighted
    line). The schemas are at the bottom of the JSON file. Here’s the schema that
    represents the `ReadOneDto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the highlighted lines, that schema has a property `name`
    of type `string` and a property `id` of type `integer`, the same as our `ReadOneDto`
    class. Fortunately, we don’t need to write that JSON since the tool generates
    it based on our code. Next, we look at the second endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The second endpoint
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The code of the second endpoint that allows a client to create an entity looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the API contract we can extract from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Contract segment** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP Method | POST |'
  prefs: []
  type: TYPE_TB
- en: '| URI | `/` |'
  prefs: []
  type: TYPE_TB
- en: '| Input | An instance of the `CreateDto` class. |'
  prefs: []
  type: TYPE_TB
- en: '| Output | An instance of the `CreatedDto` class. |'
  prefs: []
  type: TYPE_TB
- en: 'Sending the following HTTP request (you can use the `CreateEntity.http` file)
    results in the output that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The trimmed-down response is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the preceding request, the client sent a serialized instance
    of the `CreateDto` class, set the name to Jane Doe, and received that same entity
    back but with a numeric `id` property (an instance of the `CreatedDto` class).The
    OpenAPI specs of our endpoint look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The input and output schemas are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the first endpoint, SwaggerGen translates our C# classes into OpenAPI
    specs. Let’s wrap this up.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some ASP.NET Core templates come with SwaggerGen preconfigured. It also comes
    with the Swagger UI that lets you visually explore the API contract from your
    application and even query it. NSwag is another tool that offers similar features.
    Plenty of online documentation shows how to take advantage of those tools.Besides
    exploring tooling, we defined that an API contract is fundamental and promotes
    robustness and reliability. Each endpoint has the following pieces as part of
    the overall API contract:'
  prefs: []
  type: TYPE_NORMAL
- en: The URI it is accessible from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP method that best defines the operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more outputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single URI can lead to multiple endpoints by combining different HTTP methods
    and inputs. For example, `GET /api/entities` may return a list of entities, while
    `POST /api/entities` may create a new entity. Using the entity's name in its plural
    form is a convention used by many.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We explore data transfer objects next to add more clarity to that pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'REST APIs facilitate communication between applications in today''s interconnected
    digital world. We explored the HTTP protocol, HTTP methods, HTTP status codes,
    and HTTP headers. We then explored API versioning, the Data Transfer Objects (DTOs),
    and the importance of API contracts. Here are a few Key Takeaways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**REST & HTTP**: REST APIs are integral to web application communication. They
    use HTTP as their transport protocol, leveraging its methods, status codes, and
    headers to facilitate interaction between different applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP Methods**: HTTP methods or verbs (GET, POST, PUT, DELETE, PATCH) define
    the type of action a client can perform on a resource in a RESTful API. Understanding
    these methods is crucial for carrying out CRUD operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP Status Codes and Headers**: HTTP status codes inform clients about the
    success or failure of their requests. HTTP headers transmit additional information
    and describe clients'' options and capabilities. Both are essential components
    of HTTP communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**: Managing changes in APIs without disrupting existing clients
    is a significant challenge. Different strategies for API versioning can help address
    this issue, but each comes with its own trade-offs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Transfer Object (DTO)**: DTOs package data into a format that can provide
    many benefits, including reducing the number of HTTP calls, improving encapsulation,
    and enhancing performance when sending data over the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Contracts**: Clear and robust API contracts ensure API stability. They
    serve as a blueprint for interaction between an API and its consumers, outlining
    available endpoints, supported HTTP methods, expected request formats, and potential
    response structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Practical Application**: Understanding these concepts is not only theoretically
    important but also practically helpful in building and working with REST APIs
    using ASP.NET Core or any other similar technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By now, you should have a solid understanding of REST APIs and be ready to
    explore how to implement one using ASP.NET Core. ASP.NET Core makes writing REST
    APIs using MVC or minimal APIs a breeze. MVC is a well-used pattern that is almost
    impossible to avoid. However, the new minimal API model makes the process leaner.
    Moreover, with application patterns like Request-EndPoint-Response (REPR) or Vertical
    Slice Architecture, we can organize our API per feature instead of by layer, leading
    to an improved organization. We cover those topics in *Section 4*: *Application
    patterns*.Next, we explore designing with ASP.NET Core, starting with Minimal
    APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the most common status code sent in a REST API after creating an entity?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you introduce a default strategy that returns the lowest possible version
    when no version is specified, would it break existing clients?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to read data from the server, what HTTP method would you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can DTOs add flexibility and robustness to a system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are DTOs part of an API contract?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some links to build on what we have learned in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP request methods (MDN): [https://adpg.link/MFWb](https://adpg.link/MFWb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTTP response status codes (MDN): [https://adpg.link/34Jq](https://adpg.link/34Jq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTTP headers (MDN): [https://adpg.link/Hx55](https://adpg.link/Hx55)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use .http files in Visual Studio 2022: [https://adpg.link/cbhv](https://adpg.link/cbhv)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenAPI specification: [https://adpg.link/M4Uz](https://adpg.link/M4Uz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An API usually returns the status code `201 Created` after creating a new entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, it will not break clients because they will either be using the lowest API
    version or have already specified a specific version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We typically use the HTTP GET method to read data from a REST API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, Data Transfer Objects (DTOs) can add flexibility and robustness to a system.
    They allow you to control exactly what data you expose to the client and can reduce
    the amount of unnecessary data that needs to be sent over the network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, DTOs are part of an API contract. They define the data format exchanged
    between the client and server, ensuring both sides understand the data being sent
    and received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
