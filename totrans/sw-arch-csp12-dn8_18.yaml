- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Frontend Microservices with ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Chapter 14*, *Implementing Microservices with .NET*, described general techniques
    for implementing microservices in .NET but focused mainly on worker microservices,
    that is, on microservices that perform background jobs without communicating with
    anything outside of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices that communicate with the world outside of the application bring
    with them other problems and need further techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, microservices that communicate with a human user must implement
    a presentation layer, while microservices that expose APIs must conform to well-established
    standards and should preferably have documentation. Moreover, web APIs that target
    **single-page applications** (**SPAs**) must conform with browser policies; that
    is, either they are exposed on a single domain that is the same domain the SPA
    was downloaded from, or they must configure CORS policies. We will see how to
    address both CORS and issues due to browser policies in *Chapter 19*, *Client
    Frameworks: Blazor*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Worth mentioning also are all the challenges brought by any presentation layer,
    that is, ensuring a fast and effective interaction with the user and managing
    the state of the interaction with the user with maintainable code without falling
    into spaghetti code. General usability problems and solutions were discussed in
    *Chapter 2, Non-Functional Requirements*. We will discuss more technology-specific
    usability and status management problems in this chapter and in *Chapter 19*,
    *Client Frameworks: Blazor*.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all front end microservices must put solid security policies in place
    to defend the application from hackers. Some techniques are common to both front-ends
    and web APIs and are automatically handled by all major web servers, such as countermeasures
    against path-transversal attacks and denial of service. Others, instead, are specific
    to HTML pages, such as forgery. ASP.NET Core MVC defenses against forgery are
    discussed in the *Chapter 21,* *Case study*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Techniques for implementing public self-documented web APIs were described
    in *Chapter 15*, *Applying Service-Oriented Architectures with .NET*, while techniques
    for implementing server-based presentation layers were covered in *Chapter 17*,
    *Presenting ASP.NET Core*, and techniques for implementing client-based presentation
    layers will be covered in *Chapter 19*, *Client Frameworks: Blazor*. Moreover,
    general techniques for implementing microservices were covered in *Chapter 11*,
    *Applying a Microservice Architecture to Your Enterprise Application*, *Chapter
    7*, *Understanding the Different Domains in Software Solutions*, and *Chapter
    14*, *Implementing Microservices with .NET*.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in this chapter, after a short section about concepts and techniques
    specific to front-end microservices, we will show you how to put all these concepts
    and techniques together in the practical implementation of a front-end microservice.
    More specifically, we will discuss various implementation options and how to architect
    the whole layer structure of a front-end microservice. A complete example that
    shows how all layers of a front-end microservice work together, in practice, is
    described in the *A frontend microservice* section of *Chapter 21, Case Study*.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, this chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Front-ends and micro-frontends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the domain layer interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the domain layer implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the application layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the onion architecture and the patterns described in *Chapter 7*,
    *Understanding the Different Domains in Software Solutions*.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the free Visual Studio 2022 Community edition or better
    with all database tools installed.
  prefs: []
  type: TYPE_NORMAL
- en: The code samples necessary to clarify the concepts in this chapter will be taken
    from a practical example application based on the `WWTravelClub` book use case.
    The full example application is described in detail in the *A front end microservice*
    section of *Chapter 21, Case Study*. Its code is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  prefs: []
  type: TYPE_NORMAL
- en: Front-ends and micro-frontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main peculiarity of front-end microservices is that they need a robust web
    server that is able to optimize all the request/response handling and ensure the
    needed level of security. Moreover, high-traffic applications also need a load
    balancer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of services offered by robust web servers like IIS, Apache, and NGINX
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Limiting access to just some file types and directories to prevent access to
    private files and to prevent remote file execution; that is, execution of server
    commands/scripts through web requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking dangerous requests that might cause access to unwanted files or directories
    (path-traversal attacks).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking requests that exceed a customizable length since they might cause a
    denial of service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging and IP address blocking to discover and contrast hacker attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting requests to the application associated with each URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queueing requests and assigning them to available threads. This capability is
    fundamental for performance optimization since executing too many requests compared
    to the available processor cores might cause unacceptable performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring the isolation of applications running on the same process but in different
    threads and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the front-end service is hosted on a Kubernetes cluster, both an adequate
    web server and load balancing can be provided through an **Ingress**.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, **Azure App Service** (see the *Further reading* section) might be
    a good option since it offers a scalable level of load balancing, excellent security,
    monitoring services, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A front-end microservice doesn’t need to interface directly with anything outside
    of an application. In fact, in micro-frontend architectures, there is no unique
    front-end, but the role of the front-end is split among several microservices.
    In these architectures, typically, the role of directing traffic toward the right
    front-end and/or of combining several responses into a unique response is taken
    by an interface front-end that is load-balanced and carries the burden of ensuring
    the right level of security.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reasons for using micro-frontends are the same as the ones for using other
    microservices. We discussed them in detail in *Chapter 11*, *Applying a Microservice
    Architecture to Your Enterprise Application*, but it is worth repeating the more
    important ones here:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the usage of hardware resources by scaling just the microservices
    that need more resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having independent software lifecycles for each microservice, so each microservice
    can evolve independently from the others to match the user needs and so that each
    microservices developer team can work independently from the others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Micro-frontend architectures use quite different techniques for HTML websites,
    like ASP.NET Core MVC websites, and for web APIs. Actually, the word “micro-frontend”
    is used just with HTML websites/SPAs, while web APIs exposed to the outside world
    are referred to as public web APIs. We will describe public web APIs and HTML
    micro-frontends and the techniques they use in two dedicated subsections, starting
    with public web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Public web APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the case of web APIs, all microservices are accessible through a unique load-balanced
    piece of software called an **API gateway** that sits in between the clients and
    the various API services. The basic role of an API gateway is to make the whole
    API accessible from a unique domain to both avoid problems with the browser’s
    unique domain policy and make the usage of all API services simpler.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_18_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.1: API gateway'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the API gateway offers the opportunity to centralize other functions
    that are common to all API services, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**, that is, validating and decoding the authentication token
    that comes with each request (please do not confuse authentication with login).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**, that is, caching responses according to configurable caching policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Translation**, that is, adapting the interface, as seen by the client, to
    the actual signature of the various API methods. This way, each API can change
    its interface without affecting existing clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**, that is, directing each request toward a compatible version
    of each API service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**, that is, offering a unique documentation endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API gateways have continued to evolve, absorbing and offering more and more
    functions, giving rise to the so-called **API management systems** that now automate
    and take care of most of the burden of handling public web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure, like all clouds, offers a good API management service. You can find
    more information about it here: [https://azure.microsoft.com/en-us/services/api-management/#overview](https://azure.microsoft.com/en-us/services/api-management/#overview).'
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth mentioning **Ocelot** ([https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-ith-ocelot"](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-ith-ocelot)),
    a library for easily creating custom API gateways. You can either use it to fill
    in configuration files or as a base for a completely custom API gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to discuss HTML micro-frontends, which also add the challenge
    of combining several HTML fragments into a unique HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: HTML micro-frontends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several HTML micro-frontends can cooperate on the same application by furnishing
    each with a different set of web pages. In this case, coordinating them requires
    nothing more than links pointing to the other micro-frontends and a common sign-in
    so that users don’t need to log in each time they move to a different micro-frontend.
  prefs: []
  type: TYPE_NORMAL
- en: However, very often, several micro-frontends cooperate in the construction of
    the same page by supplying various page areas. In this case, a software component
    must take the burden of assembling the various parts into a unique page.
  prefs: []
  type: TYPE_NORMAL
- en: The main difficulty of combining several HTML fragments into a single HTML page
    is offering a coherent experience to the user, thus avoiding assembling all page
    areas in a way that is hard to understand for the user. Another problem is avoiding
    the continuous page flipping and reorganization each time new content reaches
    the browser. In what follows, we will discuss how these problems are solved by
    different technologies.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of classic web applications that build the HTML on the server side,
    an interface application furnishes the page layout and then calls the various
    micro-frontends to fill the various layout areas.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_18_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.2: Server-side micro-frontend'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, there is no browser page flipping and reorganization issue since
    the whole HTML page is assembled on the server side and sent to the browser only
    when it is ready. However, we pay for this advantage with the memory consumption
    for the whole time needed to assemble the whole page before sending it to the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Both the layout to use and which calls to make to the involved micro-frontends
    are obtained by processing the request URL according to rules that are either
    hardwired in the code or, better, stored in one or more configuration sources
    (in the simplest case, a unique configuration file). Using predefined page patterns
    ensures coherence and a good user experience, but we pay the cost in maintainability
    because we need to update and test the interface application at each non-trivial
    change of any single micro-frontend that furnishes page areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of SPAs, the assembly process takes place on the client, that is,
    in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: A kernel application furnishes the initial HTML page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The kernel application downloads a JavaScript file from each micro-frontend.
    Each of these JavaScript files is a micro-SPA that creates page areas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The kernel application, based on the current URL, decides which URL to pass
    to each micro-SPA and then puts the HTML produced by each micro-SPA in the right
    place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19820_18_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.3: Client-side micro-frontend'
  prefs: []
  type: TYPE_NORMAL
- en: The various micro-SPAs do not interfere with each other because each of them
    runs in a separate JavaScript scope. Therefore, for instance, we can mix micro-SPAs
    implemented with different and incompatible versions of Angular and/or React.
  prefs: []
  type: TYPE_NORMAL
- en: 'Micro-frontends can also be implemented using WebAssembly frameworks like Blazor
    (see *Chapter 19*, *Client Frameworks: Blazor*) that run .NET code. However, in
    this case, the various micro-SPAs do not run in separate environments, so they
    must be based on compatible .NET versions.'
  prefs: []
  type: TYPE_NORMAL
- en: SPA micro-frontends have the same maintainability costs as server-based micro-frontends
    and have browser page flipping and reorganization issues since the page is created
    dynamically as new content and/or data reach the browser. This problem can be
    solved by pre-allocating each content area of the browser page with fixed-size
    HTML tags. Thus, for instance, we may pre-allocate a 300 px X 300 px area to show
    weather forecasts and some pictures or animation while the actual content is loading.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will introduce the architectural schema for building
    a front-end microservice based on ASP.NET Core MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the application architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application will be implemented with the **Domain-Driven Design** (**DDD**)
    approach and associated patterns described in *Chapter 7*, *Understanding the
    Different Domains in Software Solutions*, and *Chapter 13*, *Interacting with
    Data in C# – Entity Framework Core*, so having a good understanding of the content
    covered in those chapters is a fundamental prerequisite to reading this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application is organized based on a DDD approach and uses SOLID principles
    to map your domain sections. That is, the application is organized into three
    layers, each implemented as a different project:'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a domain layer, which contains the repository’s implementation and the
    classes describing database entities. It is a .NET library project. However, since
    it needs some interfaces, like `IServiceCollection`, which are defined in `Microsoft.NET.Sdk.web`,
    and since the `DBContext` layer must inherit from the identity framework in order
    to also handle the application authentication and authorization database tables,
    we must add a reference not only to the .NET SDK but also to the ASP.NET Core
    SDK. However, it is also common to implement custom user management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s also a domain layer abstraction, which contains repository specifications;
    that is, interfaces that describe repository implementations and DDD aggregates.
    In our implementation, we decided to implement aggregates by hiding the forbidden
    operations/properties of root data entities behind interfaces, as discussed in
    the *How data and domain layers communicate with other layers* section of *Chapter
    13, Interacting with Data in C# – Entity Framework Core*. Hence, for instance,
    the `Package` data layer class, which is an aggregate root, has a corresponding
    `IPackage` interface in the domain layer abstraction that hides all the property
    setters of the `Package` entity. The domain layer abstraction also contains the
    definitions of all the domain events, while the event handlers that will subscribe
    to these events are defined in the application layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there’s the application layer – that is, the ASP.NET Core MVC application
    (ASP.NET Core MVC is discussed in *Chapter 17*, *Presenting ASP.NET Core*) – where
    we define DDD queries, commands, command handlers, and event handlers. Controllers
    fill query objects and execute them to get ViewModels they can pass to Views.
    They update storage by filling command objects and executing their associated
    command handlers. In turn, command handlers use `IRepository` interfaces and `IUnitOfWork`
    instances coming from the domain layer to manage and coordinate transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application uses the **Command Query Responsibility Segregation** (**CQRS**)
    pattern; therefore, it uses command objects to modify the storage and the query
    object to query it. CQRS was described in the *Command Query Responsibility Segregation
    (CQRS) pattern* subsection of *Chapter 7, Understanding the Different Domains
    in Software Solutions.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The query is simple to use and implement: controllers fill their parameters
    and then call their execution methods. In turn, query objects have direct LINQ
    implementations that project results directly onto the ViewModels used by the
    controller Views with `Select` LINQ methods. You may also decide to hide the LINQ
    implementation behind the same repository classes used for the storage update
    operations, but this would turn the definition and modification of simple queries
    into very time-consuming tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: In any case, it could be beneficial to encapsulate query objects behind interfaces
    so that their implementations can be replaced by fake implementations when you
    test controllers.
  prefs: []
  type: TYPE_NORMAL
- en: However, the chain of objects and calls involved in the execution of commands
    is more complex. This is because it requires the construction and modification
    of aggregates, as well as a definition of the interaction between several aggregates
    and between aggregates and other applications through domain events to be provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a sketch of how storage update operations are performed.
    The circles are data being exchanged between the various layers, while the rectangles
    are the procedures that process them. Moreover, dotted arrows connect interfaces
    with the types that implement them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_18_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18.4: Diagram of command execution'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the flow of action through *Figure 18.4* as a list of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A controller’s action method receives one or more ViewModels and performs validation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One or more ViewModels containing changes to apply are hidden behind interfaces
    (`IMyUpdate`) defined in the domain layer. They are used to fill the properties
    of a command object. These interfaces must be defined in the domain layer since
    they will be used as arguments of the repository aggregate methods defined there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A command handler matching the previous command is retrieved via **Dependency
    Injection** (**DI**) in the controller action method. Then, the handler is executed.
    During its execution, the handler interacts with various repository interface
    methods and with the aggregates they return.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When creating the command handler discussed in *step 3*, the ASP.NET Core DI
    engine automatically injects all parameters declared in its constructor. In particular,
    it injects all `IRepository` implementations needed to perform all command handler
    transactions. The command handler performs its job by calling the methods of these
    `IRepository` implementations received in its constructor to build aggregates
    and modify the built aggregates. Aggregates either represent already-existing
    entities or newly created ones. Handlers use the `IUnitOfWork` interface contained
    in each `IRepository`, as well as the concurrency exceptions returned by the data
    layer, to organize their operations as transactions. It is worth pointing out
    that each aggregate has its own `IRepository` and that the whole logic for updating
    each aggregate is defined in the aggregate itself, not in its associated `IRepository`,
    to keep the code more modular.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Behind the scenes, in the data layer, `IRepository` implementations use Entity
    Framework to perform their job. Aggregates are implemented by root data entities
    hidden behind interfaces defined in the domain layer, while `IUnitOfWork` methods,
    which handle transactions and pass changes to the database, are implemented with
    `DbContext` methods. In other words, `IUnitOfWork` is implemented with the application’s
    `DbContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Domain events are generated during each aggregate processing and are added to
    the aggregates themselves by calling their `AddDomainEvent` methods. However,
    they are not triggered immediately. Usually, they are triggered at the end of
    all the aggregates’ processing and before changes are passed to the database;
    however, this is not a general rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application handles errors by throwing exceptions. A more efficient approach
    would be to define a request-scoped object in the dependency engine, where each
    application subpart may add its errors as domain events. However, while this approach
    is more efficient, it increases the complexity of the code and the application
    development time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Visual Studio solution is composed of three projects:'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a project containing the domain layer abstraction, which is a .NET Standard
    2.1 library. When a library doesn’t use features or NuGet packages that are specific
    to a .NET version, it is a good practice to implement it as a .NET Standard library
    because this way, it doesn’t need modifications when the application is moved
    to a newer .NET version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a project containing the whole data layer, which is a .NET 8.0 library
    based on Entity Framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there’s an ASP.NET Core MVC 8.0 project that contains both the application
    and presentation layers. When you define this project, select **No Authentication**;
    otherwise, the user database will be added directly to the ASP.NET Core MVC project
    instead of to the database layer. We will add the user database manually in the
    data layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the remaining sections, we will describe the implementation of each layer
    that composes the architecture described so far, starting with domain layer abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the domain layer interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the `PackagesManagementDomain` Standard 2.1 library project has been added
    to the solution, we’ll add a `Tools` folder to the project root. Then, we’ll place
    all the `DomainLayer` tools contained in the code associated with `ch7`. Since
    the code contained in this folder uses data annotations and defines DI extension
    methods, we must also add references to the `System.ComponentModel.Annotations`
    and `Microsoft.Extensions.DependencyInjection.Abstration` NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need an `Aggregates` folder containing all the aggregate definitions
    (which, as already said, we will implement as interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example of an aggregate definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It contains the same properties as the `Package` entity, which we saw in *Chapter
    13*, *Interacting with Data in C# – Entity Framework Core*. The only differences
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It inherits from `IEntity<int>`, which furnishes all basic functionalities of
    aggregates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has no `Id` property since it is inherited from `IEntity<int>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All properties are read-only, and it has a `FullUpdate` method since all aggregates
    can only be modified through update operations defined in the user domain (in
    our case, the `FullUpdate` method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s also add a `DTOs` folder. Here, we place all interfaces used to pass
    updates to the aggregates. Such interfaces are implemented by the application
    layer ViewModels used to define such updates. In our case, it contains `IPackageFullEditDTO`,
    which we can use to update existing packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `IRepositories` folder contains all repository specifications; the following
    is an example repository interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Repositories always contain just a few methods since all business logic should
    be represented as aggregate methods – in our case, just the methods to create
    a new package, retrieve an existing package, and delete an existing package. The
    logic to modify an existing package is included in the `FullUpdate` method of
    `IPackage`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also have an event folder containing all domain event definitions.
    We can name this folder `Events`. Events are triggered whenever a change to an
    aggregate has consequences either on other aggregates or on other microservices.
    They are a way to implement weak interactions between aggregates and microservices
    while keeping the code of aggregates independent of each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using events, we may keep the code of each aggregate substantially independent
    of the code of other aggregates that are involved in the same database transactions:
    each aggregate generates events that might interest other aggregates, such as
    a price change in a touristic package aggregate, and all other aggregates that
    depend on this price subscribe to that event, so they can update their data coherently.
    This way, when a new aggregate that depends on the tourist package price is added
    during system maintenance, we don’t need to modify the tourist package aggregate.'
  prefs: []
  type: TYPE_NORMAL
- en: When the event might also interest other microservices, the event is also passed
    to a message broker, which makes the event also available for subscription to
    code in other microservices. Message brokers were discussed in *Chapter 14*, *Implementing
    Microservices with .NET*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example event definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When an aggregate sends all its changes to another microservice, it should have
    a version property. The microservice that receives the changes uses this version
    property to apply all changes in the right order. An explicit version number is
    necessary because changes are sent asynchronously, so the order in which they
    are received may differ from the order in which they were sent. For this purpose,
    events that are used to publish changes outside of the application have both `OldVersion`
    (the version before the change) and `NewVersion` (the version after the change)
    properties. Events associated with delete events have no `NewVersion` since, after
    being deleted, an entity can’t store any versions.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection explains how all interfaces defined in the domain layer
    are implemented in the data layer.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the domain layer implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The domain layer implementation contains the implementation of all repository
    interfaces and aggregate interfaces defined in the domain layer interface. In
    the case of .NET 8, it uses Entity Framework Core entities to implement aggregates.
    Adding a domain layer interface in between the domain layer’s actual implementation
    and the application layer decouples the application layer from EF and entity-specific
    details. Moreover, it conforms with the onion architecture, which, in turn, is
    an advised way to architect microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The domain layer implementation project should contain references to `Microsoft.AspNetCore.Identity.EntityFrameworkCore`
    and `Microsoft.EntityFrameworkCore.SqlServer` NuGet packages, since we are using
    Entity Framework Core with SQL Server. It references `Microsoft.EntityFrameworkCore.Tools`
    and `Microsoft.EntityFrameworkCore.Design`, which is needed to generate database
    migrations, as explained in the *Entity Framework Core migrations* section of
    *Chapter 13*, *Interacting with Data in C# – Entity Framework Core*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should have a `Models` folder that contains all database entities. They
    are similar to the ones in *Chapter 13*. The only differences are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They inherit from `Entity<T>`, which contains all the basic features of aggregates.
    Please note that inheriting from `Entity<T>` is only needed for aggregate roots;
    all other entities must be defined as explained in *Chapter 13*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have no `Id` since it is inherited from `Entity<T>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of them might have an `EntityVersion` property decorated with the `[ConcurrencyCheck]`
    attribute. It contains the entity version that is needed to send changes to other
    microservices. The `ConcurrencyCheck` attribute is needed to prevent concurrency
    errors while updating the entity version. This prevents suffering the performance
    penalty implied by a transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More specifically, when saving entity changes, if the value of a field marked
    with the `ConcurrencyCheck` attribute is different from the one that was read
    when the entity was loaded in memory, a concurrency exception is thrown to inform
    the calling method that someone else modified this value after the entity was
    read, but before we attempted to save its changes. This way, the calling method
    can repeat the whole operation with the hope that this time, no one will write
    the same entity in the database during its execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth analyzing an example entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `FullUpdate` method is the only way to update the `IPackage` aggregate.
    When the price changes, it adds a `PackagePriceChangedEvent` to the entity list
    of events.
  prefs: []
  type: TYPE_NORMAL
- en: '`MainDBContext` implements `IUnitOfWork`. The following code shows the implementation
    of all methods that start, rollback, and commit a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, they are rarely used by command classes in a distributed environment.
    In fact, like distributed transactions, local database-blocking transactions are
    also avoided because they might block database resources for too much time, which
    is incompatible with the maximization of traffic typical of microservices-based
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Likely, as already mentioned, all databases support tagging some row fields
    as **concurrency checks**. In Entity Framework Core, this is done by decorating
    the entity property corresponding to the field with the `ConcurrencyCheck` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency checks detect interferences of another transaction, B, on a record
    while performing transaction A. This way, we can perform transaction A without
    blocking any database record or table, and if we detect interference, we abort
    transaction A and retry it till it succeeds without interference. This technique
    works well if transactions are very quick and, consequently, interferences are
    rare.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, if during transaction A, the value of the concurrency checks
    specified by an update operation differs from the one stored in the record being
    updated, the update is aborted, and a concurrency exception is thrown. The rationale
    is that another transaction, B, modified the concurrency check, thus interfering
    with the operation being performed by A.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, the method that passes all changes applied to `DbContext` to the
    database performs a check for concurrency exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding implementation just calls the `SaveChangesAsync DbContext` context
    method, which saves all changes to the database, but then it intercepts all concurrency
    exceptions and detaches all the entities involved in the concurrency error from
    the context. This way, the next time a command retries the whole failed operation,
    their updated versions will be reloaded from the database.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, when the update fails because of the interference of transaction
    B, we allow the interfering transaction B to complete its process. Then, EF automatically
    reloads all entities modified by B that contain the value of the concurrency check
    modified by B. This way, when the operation is retried, if no other transaction
    interferes, there will be no conflict on the concurrency check.
  prefs: []
  type: TYPE_NORMAL
- en: The practical usage of concurrency checks is detailed in the *A frontend microservice*
    example of *Chapter 21*, *Case Study*.
  prefs: []
  type: TYPE_NORMAL
- en: All repository implementations are defined in a `Repositories` folder to ensure
    better maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all repositories are automatically discovered and added to the application
    DI engine, calling the `AddAllRepositories` method, which is defined in the DDD
    tools we added to the domain layer project. More details on how to ensure this
    method is called when the application starts are given in the example detailed
    description in the *A frontend microservice* section of *Chapter 21, Case Study*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the application layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application layer contains the definition of all business operations. These
    business operations use data provided by the user to modify domain layer abstraction
    aggregates, such as touristic packages. When all business operations involved
    in the current user request have been performed, an `IUnitOfWork.SaveEntitiesAsync()`
    operation is performed to save all changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, for simplicity, let’s freeze the application culture to `en-US`
    by adding the following code to the ASP.NET Core pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As a second step, we can create a `Tools` folder to place the `ApplicationLayer`
    code, which you can find in the `ch7` code of the GitHub repository associated
    with this book. With these tools in place, in `Program.cs`, we can add the code
    that automatically discovers and adds all queries, command handlers, and event
    handlers to the DI engine, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must add a `Queries` folder to place all queries and their associated
    interfaces. As an example, let’s have a look at the query that lists all packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The query object is automatically injected into the application DB context.
    The `GetAllPackages` method uses LINQ to project all of the required information
    into `PackageInfosViewModel` and sorts all results in descending order on the
    `EndValidityDate` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Commands` folder contains all commands. As an example, let’s have a look
    at the command used to modify packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Command handlers can be placed in the `Handlers` folder. It is worth analyzing
    the command that updates packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Its constructor has automatically injected the `IPackageRepository` repository
    and an `IEventMediator` instance needed to trigger event handlers. The following
    code also shows the implementation of the standard `HandleAsync` command handler
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Command operations are repeated until no concurrency exception is returned.
    `HandleAsync` uses the repository to get an instance of the entity to modify.
    If the entity is not found (it has been deleted), the commands stop its execution.
    Otherwise, all changes are passed to the retrieved aggregate. Immediately after
    the update, all events contained in the aggregate are triggered. In particular,
    if the price has changed, the event handler associated with the price change is
    executed. The concurrency check declared with the `[ConcurrencyCheck]` attribute
    on the `EntityVersion` property of the `Package` entity ensures that the package
    version is updated properly (by incrementing its previous version number by 1),
    as well as that the price-changed event is passed the right version numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, event handlers are placed in the `Handlers` folder. As an example, let’s
    have a look at the price-changed event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The constructor has automatically injected the `IPackageEventRepository` repository,
    which handles the database table and all the events to send to other applications.
    The `HandleAsync` implementation simply calls the repository method that adds
    a new record to this table.
  prefs: []
  type: TYPE_NORMAL
- en: All records in the table are handled by `IPackageEventRepository`, which can
    be retrieved and sent to all interested microservices by a parallel task defined
    in the DI engine with a call such as `builder.Services.AddHostedService<MyHostedService>();`,
    as detailed in the *Using generic hosts* subsection of *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*. However, this parallel
    task is not implemented in the GitHub code associated with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth recalling that the usage of events promotes code decoupling, and
    when events cross the microservice boundary, they implement efficient asynchronous
    communication between microservices, which improves performance and maximizes
    hardware resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes how to define controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Defining controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each controller interacts with a use case that emerged in the analysis stage
    with its action methods. Action methods do their job by requiring command handlers
    and query interfaces from the dependency injection engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example of how query objects are required and used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Below, instead, is an example of the usage of command handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`ICommandHandler<UpdatePackageCommand>` retrieves the command handler associated
    with the `UpdatePackageCommand` command from DI.'
  prefs: []
  type: TYPE_NORMAL
- en: If `ModelState` is valid, `UpdatePackageCommand` is created, and its associated
    handler is invoked; otherwise, the View is displayed again to the user to enable
    them to correct all the errors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed the peculiarities of front-end microservices and
    the techniques used to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we put together the techniques learned in this chapter and in previous
    chapters in the complete implementation of a front-end microservice.
  prefs: []
  type: TYPE_NORMAL
- en: We used an onion architecture with a data layer and a domain layer abstraction,
    and we implemented each as a separate project. The application layer and the presentation
    layer were implemented together in the same ASP.NET Core MVC project.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice used the CQRS pattern and used a queue implemented with a database
    table to store the events to send to other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter explains how to implement a presentation layer with client-based
    techniques. We will use Blazor as an example client framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a front-end and an API gateway?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should all front-ends and API gateways use a robust web server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should complex blocking database transactions be avoided?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When does the concurrency technique ensure a better performance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of using domain events to implement interactions between
    different aggregates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since this chapter just put into practice concepts explained in other chapters
    (mainly *Chapter 7*, *Understanding the Different Domains in Software Solutions*,
    *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise Application*,
    and *Chapter 13*, *Interacting with Data in C# – Entity Framework Core*), here
    we will include just a few links on how to use API gateways and further information
    on the MediatR library, which was mentioned in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ocelot GitHub repository: [https://github.com/ThreeMammals/Ocelot](https://github.com/ThreeMammals/Ocelot)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to implement your API gateway with Ocelot: [https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-with-ocelot](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-with-ocelot)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure API Management: [https://azure.microsoft.com/en-us/services/api-management/#overview](https://azure.microsoft.com/en-us/services/api-management/#overview
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure App Service: [https://azure.microsoft.com/en-us/services/app-service/](https://azure.microsoft.com/en-us/services/app-service/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on MediatR can be found on MediatR’s GitHub repository: [https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 20% discount code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Leave_a_review_QR.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Limited Offer*'
  prefs: []
  type: TYPE_NORMAL
