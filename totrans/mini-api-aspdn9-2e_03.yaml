- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Anatomy of a Minimal API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how minimal APIs work, it makes sense to learn how they are put
    together in the context of an ASP.NET application. In ASP.NET project types such
    as **Model-View-Controller** ( **MVC** ) and **Web API** , various components
    are tied together to create the overall application, and minimal APIs are no different.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how minimal APIs fit within
    the ASP.NET ecosystem and how the various components are combined to make them
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: The aim here is to ensure you have a deeper understanding of the wider context
    surrounding minimal APIs, which will inform the way you design and implement them
    in future projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a minimal API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components of a minimal API Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API request lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get into the chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a minimal API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When referring to the *anatomy* of a minimal API, what we are really talking
    about is the pieces of the puzzle that fit together to bootstrap the application.
    Before ASP.NET Core, bootstrapping involved two classes: **Program.cs** and **Startup.cs**
    . The former stayed at the high level of the project, setting up an HTTP pipeline
    before calling the startup class to add components and features to the pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core majorly changed this by making it possible to configure the application
    in a single file. This simplified the process, paving the way for native support
    of minimal APIs. So, in the most recent iterations of .NET, we now only need **Program.cs**
    for bootstrapping an ASP.NET application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The minimum that **Program.cs** does to create a minimal API is to build and
    run an instance of **WebApplication** . This **WebApplication** instance is built
    using another class, called **WebApplicationBuilder** . As you can see in the
    upcoming code, **WebApplication** uses a *factory* in the form of the **CreateBuilder**
    method to create an instance of **WebApplication** called **app** . You will have
    seen this code in code examples in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The result of this code is an instance of **WebApplication** on which endpoints
    can be mapped, using functions such as **MapGet** and **MapPost** .
  prefs: []
  type: TYPE_NORMAL
- en: '**WebApplication** embodies the overall API and is created using a builder
    pattern implementation via a **WebApplicationBuilder** object. This object allows
    configuration to be specified while building the **WebApplication** instance.
    For example, services can be registered for dependency injection (we will learn
    about dependency injection in [*Chapter 7*](B20968_07.xhtml#_idTextAnchor119)
    ) while the **WebApplication** is being built via the **WebApplicationBuilder**
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this initial setup of dependencies can be seen in the next code,
    where we use **AddScoped** to register the **PayrollRunner** type for dependency
    injection before the line of code on which the app is finally built using **builder.Build()**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A minimal API does not have its own dedicated project template in Visual Studio.
    Think of a minimal API as an option within an ASP.NET project, rather than its
    own project type. The reason for this is that minimal APIs are more often than
    not a part of another kind of project, although it is certainly common to have
    small ASP.NET projects consisting exclusively of minimal API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: By default, an ASP.NET project creates a set of minimal API endpoints. You can
    see this using the **ASP.NET Core (Empty)** project template in Visual Studio.
    Despite the name, the template’s resulting project generates an example minimal
    API endpoint, as we saw in the *Hello World!* example in [*Chapter 1*](B20968_01.xhtml#_idTextAnchor014)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Components of a minimal API application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several components that go together to create a minimal API project,
    most of which are applicable to any ASP.NET web application.
  prefs: []
  type: TYPE_NORMAL
- en: At the top level, the application is represented by an instance of **WebApplication**
    . This class holds together all the pieces that form the API system. Think of
    it like the application’s body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Components that live inside **WebApplication** include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application Lifecycle** : As the application runs, various events will occur,
    such as application startup and shutdown, and thrown exceptions. **WebApplication**
    contains several **hooks** that can be used to handle these events. For example,
    you could execute specific functions or methods when the application starts up
    or change the way specific exception types are handled when caught.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services** : Your APIs will no doubt have reusable aspects that could be
    used across multiple use cases and different areas of the application. Creating
    *services* allows you to package up these reusable aspects into components that
    can be passed to various parts of your API using dependency injection. For example,
    several of your endpoints may rely on retrieving data from a SQL database, so
    it would not be good practice to write the code to access the database multiple
    times. Instead, a service can be written once and then injected into any classes
    that need to communicate with SQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing** : We talked about routing in the previous chapter. In the context
    of a minimal API’s anatomy, routing is a key component; it is responsible for
    ensuring that traffic is sent to the appropriate destination based on the endpoint
    URL and the HTTP method being used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middleware** : In ASP.NET, middleware is a pipeline that allows developers
    to interrupt the API flow with code that is executed during requests. The middleware
    pipeline is a chain of components executing any required logic. Examples of common
    middleware use cases include handling or modifying requests, authenticating clients,
    caching, and logging. Middleware can be a reusable component that is added to
    the pipeline or custom code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a middleware component has finished running, the next component in the
    pipeline executes, until all components are finished. This is particularly useful
    because it can be applied globally, running on all incoming requests. It’s important
    to note that the pipeline can run both when the request comes in and when the
    response is sent back to the client, the difference being that the order of the
    middleware components in the pipeline is reversed when the response makes its
    way back to the client.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Configuration** : Most applications, including minimal APIs, require configuration
    to be specified, through connection strings for databases, authentication tokens,
    a flag to indicate whether the API is in developer mode, and so on. Think of these
    like environment variables. These variables are stored in an accessible location
    for use throughout the application’s lifecycle. For example, if you have a SQL
    database that several of your API endpoints need to work with data, they will
    need the relevant connection string to initiate the SQL connection. This can be
    stored as a configuration setting for any of these endpoints to obtain when they
    need it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have covered, at a basic level, the various components within an
    ASP.NET web application, including ones set up to host minimal API endpoints.
    To better understand the anatomy of a minimal API, it helps to also understand
    how a request travels through an ASP.NET API.
  prefs: []
  type: TYPE_NORMAL
- en: The API request lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: APIs share one thing in common, irrespective of the underlying technology –
    the conversation between client and server. The lifecycle of this conversation
    is visualized in *Figure 3* *.1* .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: The journey of an HTTP request](img/B20968_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: The journey of an HTTP request'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore this lifecycle in more detail. Specifically, for ASP.NET, and
    therefore minimal APIs, the steps we outline next are taken from the point a client
    makes a request, to the point a response is received:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The request is parsed** – On receipt of the request, ASP.NET takes the incoming
    data and extracts critical information, such as the HTTP method in use (GET, POST,
    PUT, etc.). The URL is extracted, along with the request’s headers and body.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The middleware pipeline is executed** – Middleware sitting in the chain is
    processed, with each middleware component operating on the request as configured.
    For example, authentication middleware could check that the sender of the request
    is authenticated, custom middleware could alter the structure of the request,
    and logging middleware could reference the request in logs that it writes to various
    data sources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Routing** – Now that the application has parsed the request and processed
    it through any relevant middleware, it can match the extracted URL and HTTP method
    against the routes configured in the API. This allows the request’s content to
    be routed to the appropriate endpoint for handling. Routing is just another example
    of a middleware component. As such, its order of execution can be altered within
    the pipeline.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Dependency injection** – Once the request has been routed to the correct
    request, the dependency injection container will resolve any dependencies required
    to process the request and inject them into the components containing the endpoint,
    making them available during processing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Request handling** – The request is effectively now *inside the endpoint*
    , as in, it is being processed by the logic a developer has written inside the
    body of a minimal API endpoint they have written. Parameters passed in can be
    used within the endpoint body to process the required logic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Response generation** – Once the logic defined within the body of the endpoint
    has finished executing (or if an exception is thrown), a response will be generated.
    The response contains any expected data for the HTTP method on the endpoint, such
    as JSON or a simple string. It also has a status code appropriate to the processing
    result, for example, **200 OK** , **400 Bad Request** , or **500 Internal Server
    Error** . Once generated, the response is sent back to the client, and the HTTP
    conversation is over.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have explored the journey of a request, let’s review what we have
    covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapter has detailed the different components that ASP.NET employs to construct
    an application capable of hosting minimal API endpoints. It explained how the
    **WebApplication** instance is configured using the **WebApplicationBuilder**
    . The chapter also described the integration of elements like routing, services,
    dependency injection, and middleware into the application. Additionally, it emphasized
    the importance of the application lifecycle and how lifecycle events can be managed
    through hooks. The journey of an HTTP request from the client to minimal API endpoints
    and back was also discussed. Finally, the chapter outlined the steps involved
    in matching incoming requests with the appropriate logic, and the process of handling
    the request in preparation for a client response.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move away from the conceptual and back to the practical
    with a more advanced guide on handling HTTP requests and routing.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 - Data and Execution Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part delves into the crucial aspects of how data flows through minimal
    APIs. You’ll learn how to handle various HTTP methods, set up routing, customize
    middleware pipelines, and integrate with different data sources. These chapters
    cover everything from dependency injection to working with databases using **Object-Relational
    Mapping** ( **ORM** ) tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B20968_04.xhtml#_idTextAnchor081) , *Handling HTTP Methods and
    Routing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B20968_05.xhtml#_idTextAnchor094) , *The Middleware Pipeline*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B20968_06.xhtml#_idTextAnchor105) , *Parameter Binding*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B20968_07.xhtml#_idTextAnchor119) , *Dependency Injection in
    Minimal APIs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B20968_08.xhtml#_idTextAnchor132) , *Integrating Minimal APIs
    with Data Sources*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B20968_09.xhtml#_idTextAnchor143) , *Object Relational Mapping
    with Entity Framework Core and Dapper*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
