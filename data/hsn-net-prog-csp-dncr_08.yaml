- en: Streams, Threads, and Asynchronous Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流、线程和异步数据
- en: With the resources available to us to start working with sending network requests,
    we need to look at how we can best incorporate those requests into our applications.
    We'll need to work with those resources in a way that won't impact the performance
    of our application's business logic or our user's experience. So, in this chapter,
    we'll look at how we can process data streams in such a way as to be resilient
    and non-blocking to the rest of our application's performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有资源开始发送网络请求的情况下，我们需要考虑如何最好地将这些请求集成到我们的应用程序中。我们需要以一种不会影响应用程序的业务逻辑或用户的体验的方式与这些资源一起工作。因此，在本章中，我们将探讨如何处理数据流，以便对应用程序的其他性能方面具有弹性和非阻塞性。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the nature of I/O streams in C#, and how to write to, read from,
    and manage open streams
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解C#中I/O流的本性，以及如何写入、读取和管理打开的流
- en: How different I/O streams expose access to different types of data, and how
    the parent `Stream` class simplifies the use of those distinct stream types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何不同类型的I/O流暴露对不同类型数据的访问，以及父`Stream`类如何简化这些不同流类型的用法
- en: The potential performance cost of processing large, or poorly performing data
    streams and how to mitigate that cost
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大型或性能不佳的数据流可能带来的潜在性能成本，以及如何减轻这种成本
- en: Leveraging C#'s asynchronous programming feature set to maximize the performance
    and reliability of your software
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用C#的异步编程功能集来最大化软件的性能和可靠性
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will have a number of samples and driver programs to demonstrate
    the concepts discussed, all of which are available at [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter
    6](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%206).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将包含多个示例和驱动程序来展示所讨论的概念，所有这些都可以在[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%206](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%206)找到。
- en: As always, you're encouraged to clone this repository locally and begin playing
    with the source code, or writing your own in order to get comfortable with some
    of the topics in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们鼓励您在本地克隆此存储库并开始尝试源代码，或者编写自己的代码，以便熟悉本章的一些主题。
- en: Check out the following video to see the code in action: [http://bit.ly/2HYmhf7](http://bit.ly/2HYmhf7)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[http://bit.ly/2HYmhf7](http://bit.ly/2HYmhf7)
- en: Going with the flow – data streams in C#
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随着C#中的数据流而行——C#中的数据流
- en: We looked briefly at accessing data streams in the last chapter when we talked
    about the request stream property of the `WebRequest` class. I glossed over that
    subject then, but now we should really understand how our data is prepared for
    transmission as a request payload. We'll look at the common interface for data
    streams in C#, and give special consideration for some of the trickier or less
    obvious aspects of streams that can introduce some difficult-to-find bugs into
    your code. So, let's start with the `Stream` class and go from there.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们讨论`WebRequest`类的请求流属性时，我们简要地提到了访问数据流。当时我略过了这个主题，但现在我们应该真正理解我们的数据是如何作为请求有效载荷准备进行传输的。我们将查看C#中数据流的通用接口，并对流的一些更复杂或不太明显的方面给予特别关注，这些方面可能会在您的代码中引入一些难以发现的错误。因此，让我们从`Stream`类开始，然后继续前进。
- en: Initializing a data stream
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化数据流
- en: Just like with network requests, writing to and reading from data streams is
    a common and straightforward task in software engineering. So much so, in fact,
    that Microsoft provided an extremely well-designed common specification for doing
    this in C#. The methods defined by the base class are the same ones you'll use
    for any kind of data transmission that you would reasonably have to execute, so
    with that as our starting point, let's take a look at what the class provides.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像网络请求一样，向数据流写入和从数据流读取是软件工程中常见且直接的任务。实际上，微软为此提供了非常精心设计的通用规范，用于在C#中执行此操作。基类定义的方法是您将用于任何合理需要执行的数据传输类型，因此以此为起点，让我们看看这个类提供了什么。
- en: The objective of the `Stream` class is, quite simply, to provide direct access
    to an ordered sequence of bytes. There is no additional context around this information,
    so the sequence of bytes could be anything from a file on your local disk storage,
    to the bytes of a packet from an incoming request stream, or to an open communication
    pipe between two co-located application processes and existing entirely in memory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 类的目标非常简单，就是提供对有序字节序列的直接访问。关于这个信息没有额外的上下文，因此字节序列可以是本地磁盘存储上的文件，也可以是来自传入请求流的字节，或者是在两个协同定位的应用程序进程之间打开的通信管道，完全存在于内存中。'
- en: What this simple definition provides is an easy way to define generic environment
    and context-agnostic methods for working with the ordered list of zeros and ones.
    What it doesn't provide, however, is any useful way to parse, process, and convert
    those bytes to and from meaningful in-memory objects that make sense to the rest
    of your application. As a programming task, this can be a bit tedious, but thankfully,
    some of the specific implementations provide some reliable utility methods for
    more common parsing situations. This is especially nice because that's where most
    of the work of streams lie.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的定义提供了一个简单的方法来定义通用的、与环境无关的方法，用于处理有序的零和一列表。然而，它没有提供任何有用的方法来解析、处理和将这些字节转换为和从有意义的内存对象，这些对象对应用程序的其他部分来说是有意义的。作为一个编程任务，这可能有点繁琐，但幸运的是，一些特定的实现提供了一些可靠的实用方法，用于更常见的解析情况。这特别令人愉快，因为流的大部分工作都集中在这里。
- en: 'Once you''ve got your information ready to pass over a binary data stream,
    or ingest bytes from a data stream, there are only three primary operations that
    you''ll care about. The first two are obvious: reading and writing, collecting
    bytes, in order, from the data stream, or pushing your own bytes onto it. The
    third is less obvious but just as important. Because the data stream is an ordered
    array of arbitrary bytes, reading from and writing to it are unidirectional operations.
    They are always processed in order. However, we don''t always need or want the
    information from a data stream in order, so the ability to seek out a specific
    index in the stream is key, and will be the primary mechanism for traversing your
    data stream out of order.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的信息准备好通过二进制数据流传递，或者从数据流中获取字节，你只需要关注三个主要操作。前两个很明显：从数据流中按顺序读取和写入，收集字节，或者将你自己的字节推送到它。第三个不那么明显，但同样重要。因为数据流是有序的任意字节数组，从它读取和写入是单向操作。它们总是按顺序处理。然而，我们并不总是需要或想要按顺序从数据流中获取信息，因此能够查找流中的特定索引是关键，这将是遍历你的数据流的主要机制。
- en: 'So, with that in mind, let''s take a look at it in action. First, create a
    basic application to take advantage of a data stream. To do so, you can use the
    .NET Core CLI, and create a new console app, as shown in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，带着这个想法，让我们看看它是如何付诸实践的。首先，创建一个基本的应用程序来利用数据流。为此，你可以使用 .NET Core CLI，并创建一个新的控制台应用程序，如下面的截图所示：
- en: '![](img/65ea8a27-8d27-4152-a31b-5a38e18d2d35.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/65ea8a27-8d27-4152-a31b-5a38e18d2d35.png)'
- en: Similarly to how we created our sample project in [Chapter 2](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml), *DNS
    and Resource Location,* in the, *The DNS in C#* section*, *we used the `dotnet
    new` command to stand up a basic console application as our test bed. This time
    the difference is that we'll specifically create a new console app with the `dotnet
    new console` command. I'll keep making a note of this as we work with new projects
    to highlight the speed and value of the .NET Core CLI; its speed and utility really
    cannot be overstated.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在第 2 章，*DNS 和资源定位*，在 *C# 中的 DNS* 部分中创建的示例项目，我们使用了 `dotnet new` 命令来创建一个基本的控制台应用程序作为我们的测试平台。这次的不同之处在于，我们将使用
    `dotnet new console` 命令专门创建一个新的控制台应用程序。我会继续在处理新项目时做笔记，以突出 .NET Core CLI 的速度和价值；它的速度和实用性真的无法过分强调。
- en: Now, we want to establish a stream to work with, so we'll start by adding a
    using directive to include the `System.IO` namespace since I/O streams live in
    the I/O namespace. Then, for the sake of demonstration, we'll read from the file,
    and write to a file on disk with `FileStream`. We'll declare our variable to be
    of type `Stream`, so that the compiler's type checking doesn't allow us to use
    the `FileStream` specific methods or properties. The point is to understand how
    to use the abstraction that's provided by the `Stream` class. It doesn't actually
    matter what we're reading from; by the time it gets to our application code, it's
    all just incoming bytes, anyway. Using the local filesystem just gives us more
    direct access to the results of our actions without having to go through the process
    of setting up a local API and posting data to it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要建立一个用于工作的流，所以我们将首先添加一个`using`指令来包含`System.IO`命名空间，因为I/O流位于I/O命名空间中。然后，为了演示的目的，我们将从文件中读取，并将数据写入磁盘上的文件，使用`FileStream`。我们将我们的变量声明为`Stream`类型，这样编译器的类型检查就不会允许我们使用`FileStream`特定的方法或属性。重点是理解如何使用`Stream`类提供的抽象。实际上，我们读取的内容并不重要；在到达我们的应用程序代码之前，它只是一些输入字节。使用本地文件系统只是让我们能够更直接地访问我们的操作结果，而无需通过设置本地API并将其数据发送到该API的过程。
- en: To the extent that you can, it's usually wise to use as generic a type as possible
    when declaring your variables. This allows you a lot more flexibility if you need
    to change your implementation strategy down the line. What might be a locally
    stored filesystem access today could become a remote API call tomorrow. If your
    code is only concerned with the generic concept of a `Stream` class, it's a lot
    easier to change it later for different sources later.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够做到的范围内，通常明智的做法是在声明变量时尽可能使用通用的类型。这样，如果你以后需要更改实现策略，你会拥有更多的灵活性。今天可能只是本地存储的文件系统访问，明天可能就变成了远程API调用。如果你的代码只关注`Stream`类的通用概念，那么在以后对不同来源进行更改会容易得多。
- en: To write this demo, the first thing you'll want to understand is that a Stream
    is an active connection to a data source. That means it needs to be opened before
    it can be used, and it should be closed, and then disposed of before you're done
    with it. Failing to do so can result in memory leaks, thread starvation, and other
    performance or reliability issues with your code. Thankfully, .NET Core provides
    a built-in pattern for each of these life cycle tasks. The constructors for most
    `Stream` classes will return an already-opened instance of the class you're creating,
    so you can start reading from and writing to your streams right away. As for guaranteeing
    the disposal of your streams, we have the eternally useful `using` statement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写这个演示，你首先需要理解的是，流是一个到数据源的活跃连接。这意味着在使用之前需要打开它，完成使用后应该关闭，然后销毁。未能这样做可能会导致内存泄漏、线程饥饿以及其他与代码的性能或可靠性相关的问题。幸运的是，.NET
    Core为每个生命周期任务提供了一个内置的模式。大多数`Stream`类的构造函数将返回一个已经打开的实例，这样你就可以立即开始从流中读取和写入。至于确保流的销毁，我们有永远有用的`using`语句。
- en: 'If you haven''t seen it before, a `using` statement is different from the `using`
    directives at the top of your file that allows you to reference classes and data
    structures outside of your current namespace. In the context of a method, in C#,
    the `using` statement is used to instantiate a disposable class (which is to say,
    any class that implements the `IDisposable` interface), and define the scope within
    which the instance should be kept alive. The syntax for using this is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有见过，`using`语句与文件顶部允许你引用当前命名空间外部的类和数据结构的`using`指令不同。在方法的上下文中，在C#中，`using`语句用于实例化一个可处置的类（也就是说，任何实现了`IDisposable`接口的类），并定义实例应该保持活跃的作用域。使用此语句的语法如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We'll see this in action momentarily. But just like declaring variables within
    the scope of a `for` loop or an `if` statement, the variable you create inside
    the signature of the `using` statement ceases to exist outside of the scope of
    the open and close curly brackets of the code block.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到这个功能的实际应用。但就像在`for`循环或`if`语句的作用域内声明变量一样，你在`using`语句的签名内创建的变量在代码块的开闭花括号之外将不再存在。
- en: 'Alternatively, with C# 8, you can avoid the deep nesting created by the `using`
    statement by choosing instead to leverage the `using` declaration. This functions
    the exact same as the `using` statement, but it declares the variable to the scope
    of the encapsulating method instead of establishing an inner-scope for the lifetime
    of the instance. So, instead of defining the scope with the `using` statement
    and its opening and closing curly braces, you would simply create your variable
    and declare it with the `using` keyword, as seen here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用C# 8，你可以通过选择利用`using`声明来避免由`using`语句创建的深层嵌套。这功能与`using`语句完全相同，但它将变量声明为封装方法的范围，而不是为实例的生命周期建立内部作用域。因此，你不会使用`using`语句及其开闭括号来定义作用域，而是简单地创建变量，并使用`using`关键字声明它，就像这里所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only major distinction between the two is the scope to which the instance
    is bound. With a `using` statement, the scope of the instance is defined by the
    curly braces of the statement block. Meanwhile, with the `using` declaration,
    the scope is defined by the code block in which the disposable instance was declared.
    In most cases, the `using` declaration should be sufficient, and will help reduce
    deep nesting within your methods. However, you should always take care to consider
    how the disposable instance will be used and bind it to the appropriate scope
    for its use case.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 两个实例之间的主要区别在于实例所绑定的作用域。使用`using`语句时，实例的作用域由语句块的括号定义。与此同时，使用`using`声明时，作用域由声明可处置实例的代码块定义。在大多数情况下，`using`声明应该足够，并且有助于减少方法中的深层嵌套。然而，你应该始终注意考虑可处置实例的使用方式，并将其绑定到适当的范围以适应其使用场景。
- en: Once the flow of program control exits the scope to which your instance is bound,
    the .NET runtime will take all the necessary steps to call the `Dispose()` method,
    which is responsible for ensuring that the state of the object is valid for disposal.
    In doing so, the `using` statement implicitly assumes the responsibility of cleaning
    up any unmanaged resources and any connection pools set up for the object it created.
    This well-defined scope means that anytime you step out of the scope of the `using`
    directive, you lose your resource handle and will have to instantiate a new one.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序控制流的流程退出与实例绑定的作用域，.NET 运行时将采取所有必要的步骤来调用`Dispose()`方法，该方法负责确保对象的状态对于处置是有效的。在这个过程中，`using`语句隐式地承担了清理任何未管理资源以及为创建的对象设置的任何连接池的责任。这种明确的作用域意味着每次你离开`using`指令的作用域时，你都会失去资源句柄，并将不得不实例化一个新的句柄。
- en: This well-defined scope means that any time you close your `using` statement,
    you lose your resource handle. This means that accessing the resource later will
    require you to create a new handle for it and then dispose of it accordingly.
    This can incur a performance cost over the lifetime of the application, and so
    you should take care to dispose of a resource handle when you are certain you
    no longer need it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种明确的作用域意味着每次你关闭`using`语句时，你都会失去资源句柄。这意味着稍后访问资源将需要你为它创建一个新的句柄，然后相应地处置它。这可能会在应用程序的生命周期中产生性能成本，因此你应该在确定不再需要资源句柄时小心处置它。
- en: Interestingly, while the object declared within the scope of the `using` statement
    will always be properly disposed of, the `using` statement does notguarantee the
    disposal of any disposable instances that theobject creates. The assumption is
    that if any `A` class creates an instance of a disposable `B` class as a member
    of itself, the owning instance of the `A` class should also be responsible for
    cleaning up the member instance of the `B` class whenever the owning instance
    of the `A` class is, itself, disposed of. The rule is, if you create it, you dispose
    of it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，虽然`using`语句作用域内声明的对象总是会得到适当的处置，但`using`语句并不能保证对象创建的任何可处置实例都会被处置。假设如果任何`A`类将其自身作为成员创建了一个可处置的`B`类实例，那么`A`类的拥有实例也应该负责在`A`类的拥有实例被处置时清理`B`类的成员实例。规则是，如果你创建了它，你就处置它。
- en: Now that we know how to create an instance of `Stream`, let's get our hands
    dirty and start working with one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何创建`Stream`实例，让我们动手实践，开始使用它吧。
- en: Writing to and reading from a data stream
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向数据流写入和读取
- en: 'Now that we know how the life cycle of the `Stream` class is managed, let''s
    use it to write a message to a local file. First, we''ll write a string to the
    stream, and then inspect the destination of the stream to confirm that it was
    written properly:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了`Stream`类的生命周期是如何管理的，让我们用它来向本地文件写入一条消息。首先，我们将字符串写入流，然后检查流的目的地以确认它已被正确写入：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just like in [Chapter 5](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml), *Generating
    Web Requests in C#,* we couldn't write our string directly to the stream. It's
    not the job of a stream of bytes to figure out how more complicated objects should
    be represented as bytes. It's just the road over which they travel. So, we're
    responsible for first getting the byte representation of the string that we want
    to send. For this, we use the `System.Text.Encoding` class to get the byte representation
    for the specific string encoding that we want to use.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[第5章](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml)中提到的*在C#中生成Web请求*一样，我们无法直接将字符串写入流。字节流的任务不是确定更复杂对象应该如何表示为字节。它只是它们通过的路线。因此，我们负责首先获取我们想要发送的字符串的字节表示。为此，我们使用`System.Text.Encoding`类来获取我们想要使用的特定字符串编码的字节表示。
- en: Once we have this, we can write it to the stream. Or, at least, we assume we
    can. It's always wise to check first, though. That's why the `Write` operation
    is wrapped in the conditional block that checks the `CanWrite` property of our
    stream. This is a wonderful convenience provided by the `Stream `class that allows
    you to confirm a valid state in your stream for the operation you're about to
    perform beforeyou try to perform it. This puts error handling and correction in
    our control without having to use clunky `try`/`catch` blocks around everything.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个，我们就可以将其写入流中。或者至少，我们假设我们可以。但首先进行检查总是明智的。这就是为什么`Write`操作被包裹在检查我们流`CanWrite`属性的条件块中。这是`Stream`类提供的一个非常好的便利，它允许你在尝试执行操作之前确认流中操作的有效状态。这样，我们就可以在不需要在所有内容周围使用笨拙的`try`/`catch`块的情况下控制错误处理和纠正。
- en: So, we declared our `Stream` object in our `using` block and initialized it
    to open or create a file called `stream_demo_file.txt` in the root of the application
    executable's directory. Then, once we checked on it, we passed it our byte array
    and instructed the stream to write that array to its destination resource. But
    what were those two additional parameters in the `Write` method? Well, in the
    same way that a stream wouldn't reasonably have any knowledge of what is passing
    over it, it doesn't know what bytes should be read from the byte array when. It
    needs the array of bytes, then instructions on where to start reading from, and
    precisely how many of those bytes it should write. The second parameter in the
    `Write` method signature is your starting index. It starts at zero, just like
    the array does. The third parameter is the total number of bytes you want to send
    in this `Write` operation. There is a runtime error checking on this and if you
    try to send more bytes than there are left in the array (starting from whatever
    index you designate), you'll get an index out-of-bounds error.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在`using`块中声明了我们的`Stream`对象，并将其初始化为打开或创建一个名为`stream_demo_file.txt`的文件，位于应用程序可执行文件目录的根目录下。然后，一旦我们检查了它，我们就传递了我们的字节数组，并指示流将这个数组写入其目标资源。但`Write`方法中的那两个附加参数是什么？嗯，就像流不会合理地了解在其上通过的内容一样，它也不知道何时应该从字节数组中读取哪些字节。它需要字节数组，然后是关于从哪里开始读取的指令，以及它应该精确写入多少字节。`Write`方法签名中的第二个参数是你的起始索引。它从零开始，就像数组一样。第三个参数是你想要在这个`Write`操作中发送的字节总数。这里有一个运行时错误检查，如果你尝试发送比数组中剩余的字节更多的字节（从你指定的任何索引开始），你会得到一个索引越界错误。
- en: So, if you navigate to the folder from which the application was run, you should
    find a new text file. Opening it, you should discover our message; it's as easy
    as that. But what happens if we run the file again? Will the message be concatenated
    to the first message that we wrote? Will it overwrite the existing message?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你导航到应用程序运行的文件夹，你应该找到一个新的文本文件。打开它，你应该会发现我们的消息；就这么简单。但如果我们再次运行该文件会发生什么？消息会被连接到我们之前写入的第一个消息吗？它会覆盖现有的消息吗？
- en: The seek operation
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找操作
- en: Run your application again, and then reload the file in a text editor. Whatever
    you were expecting to happen, you should see no change to the file. However, assuming
    your application ran successfully, and you saw the Done! message on your console
    for 10 seconds instead of our error message, you should have confidence that the
    write operation was executed a second time. So, this should tell you that the
    operation was successful and it did, in fact, overwrite the value of the original
    message. It might not be initially obvious, because we used the same message the
    second time around, but if you want to confirm this behavior, just change the
    `testMessage` variable in your program to read *Testing writing a different string
    to a stream* and run it again. You should see the new message and, hopefully,
    it's a little more obvious what's happening.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行你的应用程序，然后在文本编辑器中重新加载文件。无论你期待发生什么，你应该看到文件没有任何变化。然而，假设你的应用程序运行成功，你在控制台上看到的是持续10秒的“完成！”消息而不是我们的错误消息，你应该有信心写入操作执行了第二次。所以，这应该告诉你操作是成功的，并且实际上它确实覆盖了原始消息的值。这可能一开始并不明显，因为我们第二次使用了相同的信息，但如果你想确认这种行为，只需将程序中的`testMessage`变量更改为读取*测试向流写入不同的字符串*并再次运行。你应该看到新的消息，希望这会使发生的事情更加明显。
- en: Every time we open a stream connected to a data source, we're getting the complete
    ordered list of bytes stored at that source, along with a pointer to the start
    of that array. Every operation we execute on the stream moves our pointer in one
    direction. If we write 10 bytes, we find ourselves 10 positions further down the
    array than when we started. The same happens if we read 10 bytes. So, each of
    our primary operators can only ever move in one direction from whatever point
    along the stream we happen to be at when we start executing them. How, then, do
    we set those operations up to read or write what we want, where we want? The answer
    is, with the `Seek()` method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们打开一个连接到数据源的流时，我们都会得到存储在该源中的完整有序的字节列表，以及该数组的起始指针。我们对流执行的每个操作都会将我们的指针移动一个方向。如果我们写入10个字节，我们会发现自己比开始时在数组中更远10个位置。如果我们读取10个字节，情况也是一样。所以，我们的每个主要操作员只能从我们在开始执行它们时沿流的任何位置向一个方向移动。那么，我们如何设置这些操作来读取或写入我们想要的位置呢？答案是，使用`Seek()`方法。
- en: The `Seek` method gives us arbitrary access to any index in our byte array through
    the specification of a few simple parameters. Simply specify where you want to
    start relative to a designated starting position, and then designate the starting
    position with one of the three values of the `SeekOrigin` enum.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seek`方法通过指定几个简单的参数，让我们能够任意访问字节数组中的任何索引。只需指定相对于一个指定的起始位置你想从哪里开始，然后使用`SeekOrigin`枚举的三个值之一来指定起始位置。'
- en: 'So, if I wanted to start on the last byte of the current array, and append
    my current message onto the end of my last message, that would look like the following
    code block:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我想从当前数组的最后一个字节开始，并将我的当前消息附加到上一个消息的末尾，代码块将如下所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Modify your `using` statement accordingly, and run the program again. Looking
    into your output file, you should see the following message:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 适当地修改你的`using`语句，并再次运行程序。查看你的输出文件，你应该看到以下消息：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We started with our original byte array, navigated to the end of the stream
    of written bytes, and then wrote our message from there; easy as that.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从原始的字节数组开始，导航到已写入字节的流末尾，然后从那里写入我们的消息；就这么简单。
- en: This might seem like a trivial thing, but imagine that you're unpacking a message
    payload whose data is of a variable size. Typically, you'd have a series of headers
    or a map of your byte array designating the starting index and the total length
    of the different components of the payload. Using only those two pieces of information,
    you can navigate directly to the relevant components of the message and read only
    and exactly as much as you need to. Reducing this kind of data manipulation in
    the way that the `Stream` class does is incredibly powerful in its simplicity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一件微不足道的事情，但想象一下你正在解包一个数据大小可变的消息有效负载。通常，你会有一系列头信息或一个映射你的字节数组，指定不同组件的起始索引和总长度。仅使用这两条信息，你可以直接导航到消息的相关组件，并且只读取你需要的确切数量。以`Stream`类的方式减少这种数据操作在简单性上非常强大。
- en: But maybe you don't want to write your data to a request stream. Maybe you've
    written the server code to read from requests and respond to them accordingly.
    Let's take a brief moment to look at how that's done.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许你不想将数据写入请求流。也许你已经编写了服务器代码来读取请求并相应地做出响应。让我们简要地看看这是如何实现的。
- en: Reading from streams
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从流中读取
- en: 'As I said, reading is a one-way operation. Whatever your current index, you
    will always read from the stream one byte at a time, and in doing so, move your
    cursor forward by one in the index. So, your next `Read` operation always starts
    one byte after wherever you last read. The trick here is that every time you want
    to read anything more than a single byte (which you can simply assign to a variable
    of the byte type), you have to read it into a destination array. So, you''ll need
    to declare and assign a target destination array before you can read it. Let''s
    see this in action; first, though, remove the `Seek` operation so that every time
    you run your app, you don''t grow your text file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我说的，读取是一个单向操作。无论你的当前索引是什么，你都将一次读取一个字节，并在读取过程中将光标在索引中向前移动一个位置。所以，你的下一个`Read`操作总是从上次读取的地方开始，再向后移动一个字节。这里的技巧是，每次你想读取超过单个字节的内容（你可以简单地将它分配给一个字节类型的变量），你必须将它读取到一个目标数组中。所以，在读取之前，你需要声明并分配一个目标数组。让我们看看这是如何实现的；不过，首先，让我们移除`Seek`操作，这样每次运行你的应用程序时，你都不会增加你的文本文件的大小：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, like we did before, we check whether it's even valid to try to read from
    our stream. Then, we designate a new byte array into which we'll be reading our
    bytes, and then `Read`, starting at index zero, and reading for 10 bytes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就像我们之前做的那样，我们检查是否从我们的流中读取是有效的。然后，我们指定一个新的字节数组，我们将从我们的数据流中读取字节，然后从索引零开始`Read`，读取10个字节。
- en: I'm sure at this point you're seeing a lot of the issues that this approach
    poses for developers. Even just the use of old-style square-bracket arrays instead
    of the more flexible and easy-to-work with List classes introduces a number of
    pain points for developers. In order to use an old-style array as the target of
    a `Read` operation, you must know the exact size of the array beforehand. This
    means that you'll either need to explicitly set a predetermined length for your
    array (and the subsequent `Read` operation), or you'll need to have an assigned
    variable from which you can determine the initial length of the array (since you
    can't initialize square-bracket arrays without specifying their length).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我确信在这个阶段，你已经看到了这种方法给开发者带来的许多问题。即使只是使用老式的方括号数组而不是更灵活且易于处理的列表类，也会给开发者带来许多痛点。为了将老式数组作为`Read`操作的靶子，你必须事先知道数组的确切大小。这意味着你可能需要明确地为你的数组（以及随后的`Read`操作）设置一个预定的长度，或者你需要有一个变量，你可以从中确定数组的初始长度（因为你不能在不指定长度的情况下初始化方括号数组）。
- en: This is rigid and tedious to use. It makes your deserialization code brittle.
    The alternative is to designate a reasonable maximum length and use that value
    to initialize any byte arrays that will be read to from your data stream. Of course,
    this approach fixes your software to currently known limitations and makes it
    inflexible and difficult to extend in the future. All of these are challenges
    posed by the otherwise elegant simplicity of the `Stream` class definition. Thankfully,
    though, along with the power of the `Stream` class, comes the simplicity of a
    number of utility classes .NET Core provides out of the box.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常僵化和繁琐的。它使得你的反序列化代码变得脆弱。另一种选择是指定一个合理的最大长度，并使用该值来初始化任何将从数据流中读取的字节数组。当然，这种方法将你的软件固定在当前已知的限制上，使其缺乏灵活性，并且在未来难以扩展。所有这些都是`Stream`类定义的优雅简单性所带来的挑战。幸运的是，随着`Stream`类的强大功能，还带来了.NET
    Core提供的许多实用类库的简单性。
- en: The right stream for the job
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适合这项工作的正确流
- en: Working with the lowest-level data streams representing your network connections
    does give you a lot of power and control over exactly how incoming messages are
    parsed and handled. When performance or security is an issue, that byte-level
    control is invaluable in providing a skilled developer the tools they need to
    produce the most optimal solution for the task at hand.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代表你的网络连接的最底层数据流进行工作确实给你提供了很多权力和控制，可以精确地解析和处理传入的消息。当性能或安全性是一个问题时，这种字节级别的控制对于为熟练的开发者提供他们需要的工具以产生最优化解决方案来说是无价的。
- en: However, most of us won't be writing network code with such high demands for
    performance or security. In fact, most of the code we write will all follow the
    same series of simple and straightforward patterns of serialization and message
    generation. That's where the additional `Stream` classes really come in handy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们中的大多数人不会编写对性能或安全性有如此高要求的网络代码。实际上，我们编写的代码大多数都将遵循相同的简单直接的序列化和消息生成模式。这就是额外的
    `Stream` 类真正派上用场的地方。
- en: Stream readers and writers
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流读取器和写入器
- en: While it is immeasurably useful to understand how to work directly with data
    streams and bend their use to your specific purposes when you need to, the simple
    fact is that most of the time, you won't need to. In fact, over my many years
    as a software engineer, I can count on two hands the total number of times I've
    needed to devise my own serialization strategies and implement them with lower-level
    classes for the sake of performance or security. In my professional career, it's
    much more common to use simpler, well-established serialization strategies that
    leverage the utility classes provided by the .NET core library.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在需要直接与数据流工作并弯曲其用途以适应特定目的时，了解如何操作是非常有用的，但简单的事实是，大多数时候你不需要这样做。实际上，在我多年的软件工程师生涯中，我能数得出来的需要自己设计序列化策略并使用低级类来实现以追求性能或安全性的次数屈指可数。在我的职业生涯中，使用更简单、更成熟的序列化策略，这些策略利用了
    .NET 核心库提供的实用类，要常见得多。
- en: On the modern web, the common language for communication is, irrefutably, **Javascript
    Object Notation** (**JSON**). This simple specification for composing and parsing
    hierarchical data translates so elegantly to almost every data structure you could
    possibly devise in almost any language that, at this point, it is the transport
    format of choice for almost every API or web service being written today.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代网络中，通信的通用语言无疑是 **JavaScript 对象表示法**（**JSON**）。这种用于组合和解析层次数据的简单规范，几乎可以优雅地转换成几乎任何语言中你可能会设计的几乎任何数据结构，因此，到目前为止，它已成为几乎所有正在编写的
    API 或网络服务的首选传输格式。
- en: Like everything we've talked about so far, its power comes from its simplicity.
    It's a string representation of data with simple rules for delimiting and nesting
    different objects and their respective properties. And while the hierarchy of
    a JSON object is rigidly defined, the order of properties within that object is
    entirely arbitrary, giving users a high degree of flexibility and reliability.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前讨论的所有内容一样，它的强大之处在于其简单性。它是一种数据字符串表示，具有简单的规则来界定和嵌套不同的对象及其相应的属性。尽管 JSON 对象的层次结构是严格定义的，但该对象内属性的顺序完全是任意的，这为用户提供了高度的灵活性和可靠性。
- en: With such a ubiquitous standard for serialization, it should come as no surprise
    that there are widely supported and easy-to-use tools for working with objects
    in JSON notation. Not only that, but since simple strings account for so much
    of what we read and write between data sources on a network, there are `System.IO`
    classes designed explicitly for working with them over streams.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种普遍的序列化标准下，存在广泛支持且易于使用的工具来处理以 JSON 表示法表示的对象，这并不令人惊讶。不仅如此，由于简单的字符串占据了我们在网络上读取和写入数据源之间的大部分内容，因此存在专门设计用于通过流处理这些字符串的
    `System.IO` 类。
- en: Newtonsoft.Json
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Newtonsoft.Json
- en: Let's familiarize ourselves with a non-Microsoft library that was so reliably
    popular it was ultimately adopted by Microsoft as the official library for parsing
    JSON in C# and .NET. The more you work with network transactions, the more you
    will come to appreciate the powerful simplicity of the `Newtonsoft.Json` library.
    There's not a whole lot to it, so let's take a moment now to take a peek under
    the hood, since we'll be relying on it quite a bit going forward.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们熟悉一下这样一个非微软库，它因其可靠性而广受欢迎，最终被微软采纳为官方的 C# 和 .NET 解析 JSON 的库。随着你与网络事务的更多合作，你将更加欣赏
    `Newtonsoft.Json` 库强大的简单性。它并没有太多内容，所以现在让我们花点时间看看它的内部结构，因为我们将在接下来的工作中大量依赖它。
- en: It's important to know that while `Newtonsoft.Json` remains the library of choice
    for JSON parsing in C#, Microsoft has actually developed an alternative approach
    for .NET Core 3.0\. The new library has been added as the `System.Text.Json` namespace.
    However, where `Netwonsoft.Json` is written for user-friendliness, providing a
    rich set of easy to leverage features, the focus of this new JSON library is on
    performance and fine-grained control over the serialization process. As a result,
    the feature set of the `System.Text.Json` library is severely limited when compared
    to `Newtonsoft.Json`. Since we're more concerned with the fundamental concepts
    behind JSON serialization than with performance, we'll be using `Newtonsoft.Json` as
    our library of choice throughout this book.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，尽管`Newtonsoft.Json`仍然是C#中JSON解析的首选库，但微软实际上已经为.NET Core 3.0开发了一种替代方法。这个新库已经被添加到`System.Text.Json`命名空间中。然而，与`Newtonsoft.Json`为了用户友好性而编写的，提供了一组易于利用的功能相比，这个新的JSON库的重点在于性能和对序列化过程的精细控制。因此，与`Newtonsoft.Json`相比，`System.Text.Json`库的功能集严重受限。由于我们更关注JSON序列化的基本概念，而不是性能，所以在这本书中，我们将使用`Newtonsoft.Json`作为我们的首选库。
- en: 'To get started with it, you''ll need to include the library into your project.
    If you''re using Visual Studio Code, it''s as simple as entering the following
    command into the Terminal window of the editor:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用它，你需要将库包含到你的项目中。如果你使用的是Visual Studio Code，你只需在编辑器的终端窗口中输入以下命令：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you're using Visual Studio, you can simply right click on your project's
    Dependencies in your Solution Explorer, and select Manage NuGet Packages. From
    there, search for `Newtonsoft.Json` and install the package.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Visual Studio，你可以在解决方案资源管理器中右键单击你的项目依赖项，然后选择管理NuGet包。从那里，搜索`Newtonsoft.Json`并安装包。
- en: 'Once you have it available, we''ll want an object with a little bit of complexity
    to it to really show off what `Newtonsoft` can do. So, let''s add a model definition
    to our project by adding a new file named `ComplexModels.cs` and define a few
    classes inside:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了它，我们就会想要一个稍微复杂一些的对象，以真正展示`Newtonsoft`能做什么。所以，让我们通过添加一个名为`ComplexModels.cs`的新文件来向我们的项目中添加一个模型定义，并在其中定义几个类：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have one type with properties that are instances of another type and
    lists of instances of another type. Notice that I'm using the inline property
    initialization feature that was added with C# 6\. This allows us to ensure the
    initialization of each member of our class without having to define the default
    constructor to do so. So, just by adding up an instance of our `ComplexModel`,
    we will have one fully initialized.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个类型，它的属性是另一个类型的实例，以及另一个类型的实例列表。请注意，我正在使用C# 6中添加的内置属性初始化功能。这允许我们确保不定义默认构造函数的情况下初始化我们类的每个成员。因此，只需添加一个`ComplexModel`实例，我们就会有一个完全初始化的对象。
- en: Now, I'm sure you can imagine the pain of trying to traverse that nested structure
    on your own and then parsing it into a well-formed serialized string. And that's
    for an object that we got to define ourselves! Consider the added complexity of
    writing a generic serialization code for any object that you might need to travel
    over your own network stream classes. It would be a mess of recursion or reflection
    and a whole bunch of other tedious and time-consuming tasks that few developers
    enjoy doing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我相信你可以想象自己尝试独立遍历这个嵌套结构，然后再将其解析成格式良好的序列化字符串的痛苦。而且，这还是针对我们需要自己定义的对象！考虑一下，为任何可能需要在你的网络流类中传输的对象编写通用序列化代码所增加的复杂性。这将是一团糟，充满了递归或反射，以及一大堆其他繁琐且耗时的工作，很少有开发者喜欢做这些。
- en: 'Thankfully, we often won''t have to. If we wanted to take an instance of the
    class we just defined and write it to our data stream, it''s as simple as a single
    line of code to generate the output string. Let''s re-work our sample program
    to start with an instance of our new `ComplexModel` class, and then use `Newtonsoft.Json`
    to serialize it into something more stream-friendly:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们通常不必这样做。如果我们想将我们刚刚定义的类的实例写入我们的数据流，这只需要一行代码来生成输出字符串。让我们重新设计我们的示例程序，从一个新的`ComplexModel`类实例开始，然后使用`Newtonsoft.Json`将其序列化为更易于流传输的格式：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In that simple declaration in the second line of our method, we convert our
    model into a complete string representation fit for serialized transport. Run
    the program and then inspect your destination file once again. You should find
    yourself with a nest of double-quote-delimited property names and their values,
    and curly and square braces galore. Going the other direction is as simple as
    passing in your JSON string to the `Deserialize<T>()` method, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们方法的第二行那个简单的声明中，我们将我们的模型转换为一个完整的字符串表示形式，适合序列化传输。运行程序，然后再次检查你的目标文件。你应该会发现一串由双引号分隔的属性名称及其值，以及大量的花括号。相反的方向同样简单，只需将你的JSON字符串传递给`Deserialize<T>()`方法，如下所示：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And just like that, you can cleanly and reliably serialize and deserialize your
    data into a well-understood and widely-used format for network messaging.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你可以干净可靠地将你的数据序列化和反序列化到网络消息中广泛使用的格式。
- en: The specification of the JSON notation isn't outside the scope of this book,
    but it should look pretty familiar to you if you have any experience programming
    JavaScript. Otherwise, I'd recommend checking out the MDN article on the subject
    here: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: JSON记法的规范不在这个书的范围之外，但如果你有任何编程JavaScript的经验，它应该看起来很熟悉。否则，我建议查看MDN关于此主题的文章：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON)。
- en: And if you ever need help organizing a JSON string into something a little more
    well-structured, you can paste it into [http://jsonlint.com](https://jsonlint.com/) to
    validate that the structure is well-formed, and get a prettified version of the
    string.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助组织JSON字符串以使其结构更清晰，你可以将其粘贴到[http://jsonlint.com](https://jsonlint.com/)以验证其结构是否良好，并获得一个格式化的字符串版本。
- en: The StreamReader and StreamWriter classes
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`StreamReader`和`StreamWriter`类'
- en: So, if we can easily and efficiently serialize almost any object we can conceive
    of to a string, surely (you must be thinking) there is an easier way to write
    to and read from streams, directly with strings.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们能够轻松高效地将几乎任何可以想象的对象序列化为字符串，那么（你肯定在想）一定有更简单的方法直接用字符串写入和读取流。
- en: Of course, there is; you knew it when you started this section. Enter the ever-versatile
    `StreamReader` and `StreamWriter` classes. Each of these classes is explicitly
    designed to read/write strings specifically. In fact, they both sub-class the
    `TextReader` class from the `System.IO` namespace, and extend its functionality
    to interface directly with byte streams. They are tailor-made to work with strings,
    and each of them, combined with the simplicity of `Newtonsoft.Json`, can make
    short work of transporting even the most complex data structures over the wire.
    So, let's see how to use them for the purposes of our network streams.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有；当你开始这一节时你就知道了。进入始终多才多艺的`StreamReader`和`StreamWriter`类。这些类都是专门设计用来读取/写入字符串的。实际上，它们都从`System.IO`命名空间中的`TextReader`类派生出来，并扩展了其功能以直接与字节流接口。它们是为处理字符串量身定制的，并且每个类，结合`Newtonsoft.Json`的简单性，都可以轻松处理通过网络传输的最复杂的数据结构。所以，让我们看看如何使用它们来处理我们的网络流。
- en: 'First, we want to get our stream, just as before, with the `using` statement,
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要获取我们的流，就像之前一样，使用`using`语句，如下所示：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, before we do anything else, we also want to initialize our `StreamWriter`
    instance, providing our stream as its initialization parameter:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们做任何事情之前，我们还想初始化我们的`StreamWriter`实例，提供我们的流作为其初始化参数：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are a number of constructors for `StreamReader`/`StreamWriter` that accept
    encoding specifications, byte order mark detection, and buffer size for buffered
    streams. However, for network programming, we'll always be using the constructors
    that accept a `Stream` as their first parameter. The constructors that accept
    strings only ever create `FileStream` instances pointing to a local file path.
    Even though we're using a `FileStream` here for demonstration purposes, for real
    network programming, we'll want to connect directly to a data stream to a remote
    resource. To do so, we'll have to initialize the stream (likely an instance of
    the `NetworkStream` class) first, and then provide that to our writer/reader instances.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamReader`/`StreamWriter` 有多个构造函数，可以接受编码规格、字节顺序标记检测和缓冲区大小等参数。然而，在网络编程中，我们始终会使用接受
    `Stream` 作为第一个参数的构造函数。仅接受字符串的构造函数只会创建指向本地文件路径的 `FileStream` 实例。尽管在这里我们使用 `FileStream`
    进行演示，但在实际的网络编程中，我们希望直接连接到远程资源的数据流。为此，我们首先需要初始化流（可能是 `NetworkStream` 类的实例），然后将它提供给我们的写入器/读取器实例。'
- en: 'Once the `StreamWriter` is initialized, writing is as simple as calling `Write(string)`
    or `WriteLine(string)`. Since the class assumes it will be working with strings,
    our example method is simplified as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化了 `StreamWriter`，写入就变得简单，只需调用 `Write(string)` 或 `WriteLine(string)` 即可。由于该类假设它将处理字符串，我们的示例方法简化如下：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And in only five lines of code, we're successfully serializing a complex, nested
    object instance, and writing it to our output stream.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只需五行代码，我们就成功地序列化了一个复杂的嵌套对象实例，并将其写入输出流。
- en: When working with strings from remote resources, knowing the specific encoding
    with which to translate the incoming bytes is key. If a character is encoded as
    UTF32, and decoded using ASCII, the result wouldn't match the input, rendering
    your output string a garbled mess. If you ever find a message that you've parsed
    to be indecipherable, make sure you're using the right encoding.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理来自远程资源的字符串时，知道用于将传入的字节转换为特定编码的方法是关键。如果一个字符被编码为 UTF32，并使用 ASCII 进行解码，结果将不会匹配输入，导致输出字符串变得混乱不堪。如果你发现解析的消息无法解读，请确保你使用了正确的编码。
- en: Since these classes are designed to work exclusively with string content, they
    even provide useful extensions, such as a `WriteLine(string)` method that will
    terminate the string you've passed in with a line terminator character (in C#,
    this defaults to a carriage-return followed by a line feed, or `\r\n`, though
    you can override this value based on your environment). Meanwhile, the `ReadLine()`
    method will return characters from your current index up to and including the
    next line terminator in the buffer. This isn't terribly useful with a serialized
    object, since you don't want to read a line of a JSON string. However, if you're
    working with a plain-text response, it can make reading and writing that response
    a breeze.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些类旨在专门与字符串内容一起使用，它们甚至提供了有用的扩展，例如 `WriteLine(string)` 方法，它会在你传入的字符串后面添加一个行终止符字符（在
    C# 中，这默认为回车符后跟换行符，即 `\r\n`，尽管你可以根据你的环境覆盖此值）。同时，`ReadLine()` 方法将返回从当前索引到下一个行终止符（包括）的字符。这对于序列化对象来说并不特别有用，因为你不想读取
    JSON 字符串的一行。然而，如果你正在处理纯文本响应，它可以使读取和写入该响应变得容易。
- en: Seek versus Peek
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索与预览
- en: 'One caveat that may not be obvious, however, is the difference in changing
    your current index with a `StreamWriter` or `StreamReader` instance. With the
    `Stream` class and its sub-classes, we simply applied the `Seek` operation to
    move through our byte array by a given number of positions forward from a given
    starting point. However, when you''re working with the writer/reader utility classes,
    you''ll notice that you don''t have that option. The wrapper classes can only
    move forward with their base operations using the current index on the stream.
    If you want to change that index, though, you can do so simply by accessing the
    underlying stream directly. It''s exposed by the wrapper classes through the `BaseStream`
    property. So, if you want to change your position in the stream without performing
    the operations of the wrapper, you''d use the `BaseStream`''s `Seek` operation,
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能不明显的一个注意事项是使用`StreamWriter`或`StreamReader`实例更改当前索引时的差异。对于`Stream`类及其子类，我们只是简单地应用`Seek`操作，通过给定数量的位置从给定的起始点向前移动我们的字节数组。然而，当你使用writer/reader实用程序类工作时，你会注意到你没有那个选项。包装类只能通过在流上的当前索引使用其基本操作向前移动。但是，如果你想更改那个索引，你可以通过直接访问底层流来做到这一点。包装类通过`BaseStream`属性暴露它。因此，如果你想在不执行包装器操作的情况下更改流中的位置，你可以使用`BaseStream`的`Seek`操作，如下所示：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Modifying the `Stream` class that is underlying the wrapper class will directly
    change the position to which the wrapper class can write. After running this code,
    our output file should look like the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 修改包装类底层的`Stream`类将直接更改包装类可以写入的位置。运行此代码后，我们的输出文件应该看起来像以下截图：
- en: '![](img/7cc5e128-8c9b-4c5f-bb7e-bc803f86b255.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/7cc5e128-8c9b-4c5f-bb7e-bc803f86b255.png)'
- en: The first 10 characters of our output are `null` because the underlying `Stream`
    class had its write index shifted forward by 10 characters!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输出文件的前10个字符是`null`，因为底层的`Stream`类将其写入索引向前移动了10个字符！
- en: It's not uncommon to forward search through a string until arriving at a terminating
    character or flag value. Doing so with the `StreamReader.Read()` operation will
    result in moving the index past the terminating character and popping the terminating
    character off the array. If you want to simply read the last character before
    the terminating character, though, you have the `Peek()` operation. `Peek()` will
    return the next character in the array without advancing the current index of
    the `StreamReader`. This little tidbit can provide a fair bit of flexibility when
    you're determining when to stop reading a segment from a string whose length is
    indeterminable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串中向前搜索直到到达终止字符或标志值并不罕见。使用`StreamReader.Read()`操作这样做会导致索引移动到终止字符之后，并将终止字符从数组中移除。然而，如果你想简单地读取终止字符之前的最后一个字符，你可以使用`Peek()`操作。`Peek()`会返回数组中的下一个字符，而不会前进`StreamReader`的当前索引。这个小小的技巧在你确定何时停止读取长度不可知的字符串的某个部分时，可以提供相当大的灵活性。
- en: The NetworkStream class
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`NetworkStream`类'
- en: While we're looking at the right streams for the right job, we should take a
    moment to look at the `NetworkStream` class. Operating much the same as the `FileStream`
    class that we've been using in our sample code thus far, its underlying data source
    is an instance of the `Socket` class connected to an external resource. Other
    than designating the underlying `Socket` connection for the stream to read from
    and write to, however, it functions almost entirely the same as the `FileStream`
    class. The various `Read`, `Write`, and `Seek` methods behave exactly as you've
    seen with our local file samples. And, just as importantly, an instance of `NetworkStream`
    can be used as `BaseStream` of an instance of the `StreamReader` and `StreamWriter`
    classes, so sending raw text messages over the wire is as easy as it is to write
    to a local text file. We'll use this class heavily when we start implementing
    our own socket connections in later chapters, but those will only build on the
    foundations that we've laid out in this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在寻找适合工作的正确流时，我们应该花点时间看看`NetworkStream`类。它的工作方式与我们在迄今为止的示例代码中使用的`FileStream`类非常相似，其底层数据源是连接到外部资源的`Socket`类的一个实例。然而，除了指定底层`Socket`连接以供流读取和写入之外，它几乎与`FileStream`类完全相同。各种`Read`、`Write`和`Seek`方法的行为与我们在本地文件示例中看到的行为完全一致。同样重要的是，`NetworkStream`的实例可以用作`StreamReader`和`StreamWriter`类实例的`BaseStream`，因此通过电线发送原始文本消息与写入本地文本文件一样简单。当我们开始在后面的章节中实现自己的套接字连接时，我们将大量使用这个类，但这些将仅建立在我们在本章中奠定的基础上。
- en: Picking up the pace – multithreading data processing
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高速度 - 多线程数据处理
- en: So far, we've only looked at trivial examples of read and write operations on
    our data streams, and we've only done so with the synchronous `Read()` and `Write()`
    methods. This hasn't been an issue for our 50 or 500 character-long messages and
    single-purpose test applications. However, it isn't hard to imagine scenarios
    where the data stream is large enough to take a considerable amount of time just
    to be read through from start to finish. Imagine requesting a file over FTP that
    is 200 MB large, or imagine requesting 2 million records from a database table
    hosted on a remote server. If the process that had to perform those operations
    was also responsible for responding to user behavior through a graphical interface,
    the long-running data processing task would render the GUI completely unresponsive. Such
    behavior would be absolutely unacceptable. To that end, .NET Core provides programmers
    with the concept of **threads**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了我们数据流上的读写操作的简单示例，而且我们只使用了同步的`Read()`和`Write()`方法。对于我们的50或500个字符长度的消息和单一用途的测试应用来说，这并没有成为问题。然而，不难想象数据流足够大，以至于仅仅从开始到结束读取就需要相当多的时间的情况。想象一下请求一个200MB大的FTP文件，或者想象从远程服务器上托管的数据表请求200万个记录。如果必须执行这些操作的进程还负责通过图形界面响应用户行为，那么长时间运行的数据处理任务将使GUI完全无响应。这种行为绝对是不可接受的。为此，.NET
    Core为程序员提供了**线程**的概念。
- en: With threads, certain operations can be relegated to background tasks that are
    executed as soon as is feasible for the host process to do so, but won't block
    the operations of the main thread of your application. So, with this simple, powerful
    concept, we can assign our potentially long-running, or processor-intensive operations
    to a background thread, and mitigates the impact of that operation on the performance
    of the rest of our application. This performance improvement is the single biggest
    benefit of working with threads.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程，某些操作可以被委派为后台任务，这些任务在主机进程可以执行时立即执行，但不会阻塞应用程序的主线程。因此，通过这个简单而强大的概念，我们可以将可能长时间运行或计算密集型的操作分配给后台线程，从而减轻该操作对应用程序其余性能的影响。这种性能提升是使用线程的最大好处。
- en: This aspect of .NET Core applications is accessed through the `System.Threading`
    namespace, which provides everything from `ThreadPool` classes to **semaphores**
    for protecting resources from concurrent access or mutation, to `Timer` classes
    and `WaitHandles` classes for more granular control over when and how your background
    threads are provisioned.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core应用程序的这个方面可以通过`System.Threading`命名空间访问，该命名空间提供了从`ThreadPool`类到用于保护资源免受并发访问或修改的**信号量**，再到用于更精细控制何时以及如何分配后台线程的`Timer`类和`WaitHandles`类的所有内容。
- en: Because of the volatile nature of network connections and the unreliable availability
    of remote resources, any attempt to access data or services from a remote resource
    should be handled on a background thread. Fortunately, assigning those tasks to
    a background thread for parallel processing is actually fairly simple to do. All
    we have to do is start leveraging those asynchronous methods that we've been glossing
    over until now.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络连接的易变性和远程资源的不可靠可用性，任何尝试从远程资源访问数据或服务的操作都应该在后台线程中处理。幸运的是，将这些任务分配给后台线程进行并行处理实际上相当简单。我们只需要开始利用那些我们之前一直忽略的异步方法。
- en: Asynchronous programming for asynchronous data sources
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程用于异步数据源
- en: If you're not familiar with asynchronous programming then what we're about to
    talk about may seem a little confusing at first, but I promise that in practice,
    it's actually quite simple. All it means is performing individual computational
    tasks out of order, or out of sync. It allows engineers to defer blocking the
    execution of their program to wait for a long-running task until they absolutely
    have to. To make this clear, let's look at an example.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对异步编程不熟悉，那么我们接下来要讨论的内容一开始可能有些令人困惑，但我保证在实践中，它实际上非常简单。它仅仅意味着以不按顺序或不同步的方式执行单个计算任务。它允许工程师将阻塞程序执行的等待长时间任务推迟到他们绝对必须这样做的时候。为了使这一点更清楚，让我们看一个例子。
- en: 'Let''s imagine we have a method that must have step **A** send a request for
    a massive amount of data, with step **B** performing long-running calculations
    locally, and finally, **C** returns the two results as a single response. If we
    were to read the response from our network request synchronously, then the time
    it takes to complete our method would be the total of the time for each step, **A** +
    **B** + **C**. The processing time would look like the following diagram:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们有一个方法，它必须让步骤**A**发送一个请求以获取大量数据，步骤**B**在本地执行长时间计算，最后**C**将两个结果作为单个响应返回。如果我们同步地从我们的网络请求中读取响应，那么我们的方法完成所需的时间将是每个步骤的时间总和，**A**
    + **B** + **C**。处理时间将如下所示：
- en: '![](img/f49cab49-4542-4285-9ef5-1af4af07c091.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f49cab49-4542-4285-9ef5-1af4af07c091.png)'
- en: 'But if we run our web request asynchronously*, *we can let this run in a background
    task simultaneously with our long-running local process. In doing so, we reduce
    the processing time down to only the longer of the two tasks between **A** and
    **B**, plus **C**. Our processing time now looks like the following diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们以异步方式运行我们的网络请求，*我们可以在后台任务中同时运行这个任务，与我们的长时间运行的本地进程同步进行。这样做，我们可以将处理时间减少到仅两个任务中较长的那个，再加上**C**。现在我们的处理时间看起来如下所示：
- en: '![](img/97e1b9d3-6633-4f70-b879-2360978d1adb.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97e1b9d3-6633-4f70-b879-2360978d1adb.png)'
- en: 'Since **C** is the only step that is dependent on **A** to complete processing,
    we can defer blocking our application code on the completion of **A** until we''re
    ready to execute **C**. To see what that looks like in code, let''s first say
    that we have a `ResultObject` class that holds the local and remote information
    that we want to return to our users. Next, let''s assume that the long-running
    work being done in part **B** of this method is done in the private local method
    named (appropriately) `LongRunningSlowMethod()`. So, with those simple assumptions,
    let''s look at an asynchronous method for processing long-running network requests,
    as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**C**是唯一依赖于**A**以完成处理的步骤，我们可以在准备执行**C**之前，将阻塞我们的应用程序代码在**A**完成上推迟。为了在代码中看到这一点，让我们首先说我们有一个`ResultObject`类，它包含我们想要返回给用户的本地和远程信息。接下来，让我们假设这个方法的部分**B**中进行的长时间运行的工作是在名为（恰当地）`LongRunningSlowMethod()`的私有本地方法中完成的。所以，有了这些简单的假设，让我们看看处理长时间运行的网络请求的异步方法，如下所示：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There''s quite a lot going on here, but hopefully, now it''s obvious why we
    approached these last couple chapters the way we did. Let''s look at this a little
    at a time; first, notice the method signature, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，但希望现在很明显，我们为什么以这种方式处理最后几章。让我们一点一点地看；首先，注意方法签名，如下所示：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Any method you write that takes advantage of asynchronous operations must be
    flagged with the `async` keyword in its signature. This tells users of the method
    that the operations in this method may take a while, and will run on background
    threads. And you might have noticed, the return type isn''t simply `ResultObject`,
    even though our return value, `result`, is declared as such at the start of the
    method. This is because there are only three valid return types for an asynchronous
    method: `void`, `Task`, and `Task<T>`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 任何利用异步操作编写的方法都必须在其签名中使用 `async` 关键字进行标记。这告诉方法的用户，这个方法中的操作可能需要一段时间，并且将在后台线程上运行。你可能已经注意到，返回类型并不是简单的
    `ResultObject`，尽管我们的返回值 `result` 在方法开始时被声明为这样的类型。这是因为异步方法只有三种有效的返回类型：`void`、`Task`
    和 `Task<T>`。
- en: If your method returns a result, you must wrap that result's type in `Task<>`
    in your method signature. You do not, however, have to wrap the actual returned
    value in a `Task<>` object. This is done for you by the compiler when you have
    an asynchronous method signature. That's how we're able to declare a return type
    in our method signature that seems to mismatch the declared type of our returned
    value in the body of our method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的方法返回一个结果，你必须在你方法的签名中将该结果的类型包裹在 `Task<>` 中。然而，你不需要将实际返回的值包裹在 `Task<>` 对象中。当你有一个异步方法签名时，编译器会为你完成这个操作。这就是我们能够在方法签名中声明一个看似与我们在方法体中声明的返回值类型不匹配的返回类型的原因。
- en: 'Moving on in our method, we create a `WebRequest` class pointing to our test
    domain, and then use `StreamWriter` to write our data query directly onto the
    `WebRequest`''s request stream. What happens next is where it gets interesting,
    though, that is, we get to call this following line in our code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的方法中继续前进，我们创建一个指向我们的测试域的 `WebRequest` 类，然后使用 `StreamWriter` 将我们的数据查询直接写入
    `WebRequest` 的请求流。接下来发生的事情很有趣，也就是说，我们可以在我们的代码中调用以下行：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The result of the `GetResponseAsync()` method that is assigned to our `responseTask`
    variable is actually notthe `WebResponse` class. Instead, it's a handle to the
    task that is started in a background thread by the `GetResponseAsync()` method.
    So, instead of waiting around for the response to come back from our server, `GetResponseAsync`
    just gives us a handle to the thread that is fetching that response, and then
    immediately returns the flow of control to the next operation in our method. This
    allows us to start our `LongRunningSlowMethod()` almost immediately.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetResponseAsync()` 方法分配给我们的 `responseTask` 变量的结果是实际上并不是 `WebResponse` 类。相反，它是对由
    `GetResponseAsync()` 方法在后台线程中启动的任务的引用。因此，我们不必等待从我们的服务器返回响应，`GetResponseAsync`
    只给我们一个获取该响应的线程的句柄，然后立即将控制权返回到我们方法中的下一个操作。这使得我们几乎可以立即开始执行 `LongRunningSlowMethod()`。'
- en: 'Now, since our `LongRunningSlowMethod()` is not asynchronous, the flow of control
    blocks until it completes executing, and its output is assigned to `result.LocalResult`.
    Once that''s complete, we can''t actually proceed with the function until we''ve
    finished getting the result from our web request. Thus, the next line in our program
    is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们的 `LongRunningSlowMethod()` 不是异步的，控制流会阻塞，直到它完成执行，并且其输出被分配到 `result.LocalResult`。一旦完成，我们实际上不能继续执行函数，直到我们从网络请求中获取完结果。因此，我们程序中的下一行如下：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By calling the `await` keyword, we're telling our program that we cannot meaningfully
    proceed until the awaited operation is complete. So, if the task isn't done yet,
    the program should now block further execution until it is. This is what I meant
    by defer blocking the execution of their program. We were able to proceed with
    executing other, unrelated code while this task was finishing up. It's only when
    there is no more work that can be done without the result of the asynchronous
    task that you must block, and await the result. That's what we're doing here with
    the `await` call.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `await` 关键字，我们告诉我们的程序，只有在等待的操作完成之前，我们才能有意义地继续执行。因此，如果任务尚未完成，程序现在应该阻塞进一步的执行，直到它完成。这就是我所说的延迟阻塞程序执行。当我们无法在没有异步任务的结果的情况下完成更多工作，我们必须阻塞并等待结果时，我们才能继续执行。这就是我们在
    `await` 调用中所做的。
- en: The result of awaiting this `async` task is whatever was wrapped by the `Task<T>`
    return type in the `async` method. So in this case, what gets assigned to the
    `webResponse` variable is the instance of the `WebResponse` class we were expecting
    earlier.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 等待此`async`任务的结果是`async`方法中`Task<T>`返回类型所包装的内容。因此，在这种情况下，分配给`webResponse`变量的是我们之前期望的`WebResponse`类的实例。
- en: 'Now that we have our response, we can read from it. In our next few lines,
    we instantiate `StreamReader`, and provided it the response stream from the `WebResponse`
    instance we got back. Finally, we read from the response stream and assign it
    to our result object:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了响应，我们可以从中读取。在接下来的几行中，我们实例化了`StreamReader`，并提供了从我们得到的`WebResponse`实例中获取的响应流。最后，我们从响应流中读取并将其分配给我们的结果对象：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that even though we have no additional code to execute in this function,
    we still use the `ReadToEndAsync()` method and await the result. The reason for
    this is because while we don't have anything further to execute in our method,
    someone invoking our method may be able to defer processing the result we pass
    back. Using the `await` operator tells the compiler that this is another opportunity
    for deferred execution, and so when this point is reached in our method, control
    may well return to the calling method until the result of our method is awaited
    again. For this reason, it's important to always use async methods wherever available,
    and use them all the way up the call chain. The performance gains will add up
    substantially over time.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使在这个函数中我们没有额外的代码要执行，我们仍然使用`ReadToEndAsync()`方法并等待结果。这样做的原因是，尽管在我们的方法中没有更多的执行内容，但调用我们的方法的人可能能够延迟处理我们返回的结果。使用`await`操作符告诉编译器这是另一个延迟执行的机会，因此当我们的方法达到这一点时，控制权可能会返回到调用方法，直到再次等待我们的方法的结果。因此，在可能的情况下始终使用异步方法，并且在整个调用链中使用它们是非常重要的。随着时间的推移，性能提升将显著增加。
- en: A final note on blocking code
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于阻塞代码的最后一句话
- en: You might notice that there is a `Result` property on the task instance returned
    whenever you call an asynchronous method. While it may seem tempting to simply
    use `GetResponseAsync().Result` to avoid having to await your asynchronous operations,
    as well as avoid having to apply asynchronous patterns all the way up the stack,
    this is a terrible practice.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，每次调用异步方法时，任务实例上都有一个`Result`属性。虽然使用`GetResponseAsync().Result`来避免等待异步操作，以及避免在整个堆栈中应用异步模式，可能看起来很有吸引力，但这是一种糟糕的做法。
- en: Never use `.Result` to access the result of an asynchronous task.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要使用`.Result`来访问异步任务的结果。
- en: It not only blocks your code by forcing synchronous execution, but it also prevents
    anyone who is calling your methods from being able to defer execution either.
    Unfortunately, this is one of the most common mistakes that new developers make
    when they first start working with asynchronous programming. However, you should
    almost never mix async and blocking code together. As a very simple rule, if any of
    your code requires async processing, all of it does.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅通过强制同步执行来阻塞你的代码，而且还阻止了调用你的方法的人能够延迟执行。不幸的是，这是新开发者在开始使用异步编程时犯的最常见的错误之一。然而，你几乎永远不应该混合异步和阻塞代码。一个非常简单的规则是，如果你的任何代码需要异步处理，那么所有代码都应该这样做。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we further built on the foundations from which all network
    programming in C# is supported. We learned about how .NET encapsulates the basic
    physical concept of a physical stream of incoming or outgoing bits into an elegantly
    simple and broadly useful `Stream` class. Then we looked at the best patterns
    for working with `Stream` through the `StreamWriter` and `StreamReader` wrapper
    classes. To facilitate the ease with which we could transmit data through those
    classes, we got our first look at the incredible power of JSON, and the `Newtonsoft.Json`
    library.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们进一步构建了所有C#网络编程的基础。我们学习了.NET如何将基本物理概念——物理流（流入或流出的位流）——封装成一个优雅简单且广泛有用的`Stream`类。然后我们探讨了通过`StreamWriter`和`StreamReader`包装类与`Stream`一起工作的最佳模式。为了便于我们通过这些类传输数据，我们首次了解了JSON的惊人力量以及`Newtonsoft.Json`库。
- en: Once we got data streams firmly under our belt, we looked at how to optimize
    working with them. We talked about the power of multithreading, and what that
    can mean for performance improvements with long-running tasks and operations.
    Finally, we took a crash course in asynchronous programming. Learning about how
    to leverage background tasks and the power of asynchronous method definitions,
    we saw how we could fully leverage multithreading and background tasks to mitigate
    the operation latency of potentially long-running operations. Now that we're more
    comfortably positioned to be working with remote data sources, we'll take the
    next chapter to learn how to respond to errors from remote data sources.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们牢固地掌握了数据流，我们就研究了如何优化与它们的工作。我们讨论了多线程的力量，以及这对长时间运行的任务和操作的性能改进意味着什么。最后，我们快速学习了异步编程。通过了解如何利用后台任务和异步方法定义的力量，我们看到了如何充分利用多线程和后台任务来减轻可能长时间运行的操作的延迟。现在，我们更舒适地定位了与远程数据源一起工作，我们将下一章学习如何响应来自远程数据源的错误。
- en: Questions
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does JSON stand for and why is it useful?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSON代表什么，为什么它很有用？
- en: What are the three primary operations available to you through the `Stream`
    class?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`Stream`类你可以使用哪些三个主要操作？
- en: What is the purpose of a `using` statement?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`using`语句的目的是什么？'
- en: What is the most important factor in working with strings through the `StreamReader`
    and `StreamWriter` classes?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通过`StreamReader`和`StreamWriter`类处理字符串时，最重要的因素是什么？
- en: What is the biggest single benefit of leveraging background threads in your
    programs?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用后台线程在程序中的最大单一好处是什么？
- en: What is the most common mistake programmers make when using asynchronous methods?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序员在使用异步方法时最常见的错误是什么？
- en: What are the only three valid return types of an asynchronous method?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步方法只有三种有效的返回类型，它们是什么？
- en: Further reading
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For more information about these subjects, I'd recommend taking a look at *Multithreading
    with C# Cookbook,* *Eugene Agafonov,* *Packt Publishing,* at [https://www.packtpub.com/application-development/multithreading-c-cookbook-second-edition](https://www.packtpub.com/application-development/multithreading-c-cookbook-second-edition).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些主题的更多信息，我建议查看 *C# 多线程食谱*，由 *Eugene Agafonov* 编著，*Packt Publishing* 出版，你可以在[https://www.packtpub.com/application-development/multithreading-c-cookbook-second-edition](https://www.packtpub.com/application-development/multithreading-c-cookbook-second-edition)找到这本书。
- en: For a deeper dive into modern asynchronous programming practices, you should
    check out *C# 7.1 and .NET Core 2.0 - Modern Cross-Platform Development,* *Mark
    J. Price, Packt Publishing*. You can find this at [https://www.packtpub.com/application-development/c-71-and-net-core-20-modern-cross-platform-development-third-edition](https://www.packtpub.com/application-development/c-71-and-net-core-20-modern-cross-platform-development-third-edition).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解现代异步编程实践，你应该查看 *C# 7.1 和 .NET Core 2.0 - 现代跨平台开发*，由 *Mark J. Price* 编著，*Packt
    Publishing* 出版。你可以在[https://www.packtpub.com/application-development/c-71-and-net-core-20-modern-cross-platform-development-third-edition](https://www.packtpub.com/application-development/c-71-and-net-core-20-modern-cross-platform-development-third-edition)找到这本书。
