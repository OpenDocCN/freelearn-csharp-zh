<html><head></head><body>
        

                            
                    <h1 class="header-title">Generating Network Requests in C#</h1>
                
            
            
                
<p>So, now we've got a deep and complete understanding of the nature of networks. We understand the demands that networks place on the design and implementation of the software and hardware that is meant to be deployed on those networks. But what are we supposed to do with this knowledge? In this chapter, we'll finally explore the most common paradigms for leveraging network resources in .NET Core. We'll be looking at the common interface for implementing the request/response transaction model on the internet (the most ubiquitous network with which you'll work), and examine some of the specific implementations of it. Along the way, we'll take a look at what happens under the hood by taking apart some of the source code for the .NET classes that we'll be using. </p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The basic structure of the <kbd>WebRequest</kbd> class, and what functionality each of its sub-classes is assured to expose through their methods</li>
<li>How to leverage different sub-classes of the <kbd>WebRequest</kbd> class, based on different use cases you may encounter, and understanding the distinct operations that they provide</li>
<li>The internal phases of request execution as implemented by C#</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>All of the code for this chapter is available at the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%205">https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter 5</a>.</p>
<p>As mentioned before, all of the code in this chapter can be read, manipulated, built, and deployed with Visual Studio Code or Visual Studio Community Edition (or Visual Studio for macOS, for those of you on a macOS system). The specific source control editor you use is typically a matter of opinion, but I assure you that whatever you use to work with the code in this chapter will be sufficient for all of the code throughout the rest of this book. I'd encourage you to stick with that decision and take some time to familiarize yourself with it. I expect most of the readers of this book will already have some deeply entrenched opinions about the best environment for .NET Core development. If you don't, however, I encourage you to pick whichever one feels most comfortable for you (either the feature-richness of Visual Studio Community Edition, or the lightweight, multiplatform friendliness of Visual Studio Code). Once you do, make sure you take a significant amount of time to familiarize yourself with the tools of that environment. Learn the keyboard shortcuts and set your auto-formatting options. Make it yours; once you do, you'll be ready to begin.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">One class to rule them all – the WebRequest abstract class</h1>
                
            
            
                
<p>As any software craftsman will tell you, if you want to understand how to leverage a library or toolset provided to you by another developer, just look at the public interface. If the interface is designed well enough, it will be obvious as to how that tool should<em> </em>be used. A good interface design communicates a lot about the limits and original intentions for the use of a piece of library software, and that's what we'll be looking at in this section. The <kbd>WebRequest</kbd> abstract class of the <kbd>System.Net</kbd> namespace is the public interface for creating and working with general-purpose network requests that are meant to be sent over the internet.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The interface or abstract class</h1>
                
            
            
                
<p>I've been describing the abstract <kbd>WebRequest</kbd> base class as providing an interface<em> </em>for how Microsoft intends developers to interact with network operations. However, I must admit that this isn't entirely accurate; <kbd>WebRequest</kbd> is, technically, an abstract<em> </em>class. For those readers who are unfamiliar with the distinction, it's actually quite trivial for our purposes.</p>
<p class="mce-root"/>
<p>Abstract classes do, in fact, define an interface<em> </em>for working with their implementations. The relevant distinction between the two is that, with an abstract class, any given method provided as part of the interface will typically have a default implementation defined within the abstract base class itself. So, the methods provided by an abstract class still define the interface through which you, as a consumer of the concrete classes, will interact with the implementations of the class. It's really just a distinction of where the obligation falls to define the expected behavior for that interface. Since you can't instantiate an abstract class any more than you can instantiate an interface definition, the difference is entirely trivial. Unless, of course, you choose to inherit from the <kbd>WebRequest</kbd> class yourself (which we will do at the end of this chapter). For now, though, let's just review the specification provided by <kbd>WebRequest</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The interface</h1>
                
            
            
                
<p class="mce-root">With any type of abstract class or interface definition, their proper use can best be understood through two distinct lenses. The shape<em> </em>of the abstraction is made clear by the properties of the interface. This gives users a concrete idea of the proper context in which instances of the interface should be used. It should clearly convey the domain around which the abstraction should operate. Meanwhile, the scope of the abstraction is conveyed by the classes' method signatures. This is what tells users how<em> </em>the class operates over the domain, as defined by its shape or properties.</p>
<p class="mce-root">An interface of well-named methods should give clear boundaries to the limits of the usefulness of the class. If an interface is well defined, as with the <kbd>WebRequest</kbd> base class, its properties and method signatures should make it clear exactly when it should, and should not be used. What's more, if it should be used, well-named and well-scoped method signatures will tell users exactly how to use the method.</p>
<p class="mce-root">So, with that perspective in mind, let's take a look at what is in the base definition of the <kbd>WebRequest</kbd> class. This specification will tell us how it is meant to be used and how to extend or implement it for ourselves. And what better place to start than with the constructors?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The constructors</h1>
                
            
            
                
<p><kbd>WebRequest</kbd> defines only two base constructors for its sub-classes. The first is the default  parameter-less constructor. The second allows developers to specify an instance of the <kbd>SerializationInfo</kbd> and <kbd>StreamingContext</kbd> classes to more narrowly define the scope of valid use cases for the newly-created instance of the class. So, our constructor signatures will look like the following code block:</p>
<pre>public WebRequest() {<br/>    ...<br/>}<br/><br/>public WebRequest(SerializationInfo si, StreamingContext sc) {<br/>    ...<br/>}</pre>
<p>So far this is pretty straightforward, but why use the second constructor at all? What is so common about using <kbd>SerializationInfo</kbd> and <kbd>StreamingContext</kbd> in <kbd>WebRequest</kbd> instances that the base class defines a constructor which accepts instances of those classes?</p>
<p>We'll look more closely at streaming contexts in later chapters, but we did briefly discuss the need for reliably serialized data in the previous chapter, and this is a good place to consider the concept more fully. Every request or response payload will need to be serialized<em> </em>prior to transport, and deserialized<em> </em>upon arrival at the destination machine. As we discussed before, this is the process of taking unordered, locally-addressed chunks of data and converting it into ordered strings of zeros and ones. Specifically, it must be ordered in such a way that the same strings can be traversed in order and used to compose locally-addressed in-memory objects by the recipient machine.</p>
<p class="mce-root CDPAlignLeft CDPAlign">So, while our software might store an ordered list of integers as an array of contiguous memory addresses, this is an implementation detail that is fundamentally independent of the data structure it represents. The only key details are that the list is ordered, and that it is a list of integers. It could just as easily be represented as a linked list under the hood, with each node in the list containing the integer stored at that node, as well as the address of the next node in the list, which may or may not be contiguous. In memory, these two data structures are significantly different:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-905 image-border" src="img/1c8afb08-4fb0-4f04-af71-38a5fc678881.png" style="width:25.00em;height:12.50em;"/></p>
<p>However, as long as the proper serialization information is given for how those two lists should be represented, they should look the same to any recipient receiving those lists as the payload to a request or response over the network. They should be nothing more than a well-delimited list of the integers. If your serialization mechanism is in the typical <strong>Javascript Object-Notation</strong> (<strong>JSON</strong>) format, both of those implementations would serialize the same output:</p>
<pre>[<br/>    int,<br/>    int,<br/>    int,<br/>    ...<br/>]</pre>
<p>Often, you'll find that <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> instances are instantiated and leveraged over and over again for the same kinds of messages, and their payloads should be serialized in the same way each and every time. Being able to provide <kbd>SerializationInfo</kbd> as a constructor input gives you the flexibility to define your serialization rules and details once, and then leverage them for a theoretically infinite number of requests.</p>
<p>The same goes for the <kbd>StreamingContext</kbd> parameter. As most network software is written to facilitate the same sorts of operations that are being executed in the same way over the lifespan of the software, it's unlikely that in a given application, your requests will need to leverage different kinds of I/O streams. Later on, we'll look more closely at the different kinds of streams available to you. It's a dense topic; however, for now, just know that this input parameter gives you the same flexibility as the <kbd>SerializationInfo</kbd> parameter. It allows you to define your streaming context once, and use it over and over again.</p>
<p>And with only those two signatures, we've covered the only constructors explicitly defined by the <kbd>WebRequest</kbd> base class. This should give you a pretty clear idea of how the writers of this library anticipated it would likely be used. Of course, if you wanted to, you could write a sub-class that accepted HTTP verbs and default header values, and all sorts of other aspects of a given request that you will likely need to define before you can send the request. But at its most basic, these constructor signatures tell you that this is a class that is meant to provide <strong>reliable serialization</strong> of data over a <strong>reliable data stream</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Class properties</h1>
                
            
            
                
<p>So, your constructors give you a clear idea of the context in which the classes are expected to be used, and your properties define the overall shape of a request. They define the clearest and most unambiguous description of what the class actually<em> </em>is. What can we learn about <kbd>WebRequest</kbd>, based on its properties? Well, let's take a closer look.</p>
<p>According to the base class specification, the public properties of the class are in alphabetical order ( as they're listed in the Microsoft documentation, here: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netcore-3.0">https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netcore-3.0</a>), as follows:</p>
<ul>
<li><kbd>AuthenticationLevel</kbd></li>
<li><kbd>CachePolicy</kbd></li>
<li><kbd>ConnectionGroupName</kbd></li>
<li><kbd>ContentLength</kbd></li>
<li><kbd>ContentType</kbd></li>
<li><kbd>Credentials</kbd></li>
<li><kbd>DefaultCachePolicy</kbd></li>
<li><kbd>DefaultWebProxy</kbd></li>
<li><kbd>Headers</kbd></li>
<li><kbd>ImpersonationLevel</kbd></li>
<li><kbd>Method</kbd></li>
<li><kbd>PreAuthenticate</kbd></li>
<li><kbd>Proxy</kbd></li>
<li><kbd>RequestUri</kbd></li>
<li><kbd>Timeout</kbd></li>
<li><kbd>UseDefaultCredentials</kbd></li>
</ul>
<p>So, what does this tell us about instances derived from this abstract class? Well, the obvious information is that it encapsulates common aspects of requests made over any protocol leveraged on the internet. <kbd>Headers</kbd>, <kbd>Method</kbd> (that is, the specific protocol method, such as a <kbd>GET</kbd>, <kbd>POST</kbd>, or <kbd>PUT</kbd> HTTP method), and <kbd>RequestUri</kbd> are all that you would expect from a utility class. Others, though, such as <kbd>ImpersonationLevel</kbd>, <kbd>AuthenticationLevel</kbd>, and <kbd>CachePolicy</kbd> indicate that more than simply encapsulating a request payload, the <kbd>WebRequest</kbd> class is truly meant to encapsulate an operation.</p>
<p>The actions of authenticating and caching responses fall outside of the responsibility of the simple-request payload and fall more into the segment of your software responsible for brokering requests and responses between your application and external resources. The presence of these methods indicates to us that this class (and its sub-classes) is intended to be the broker of requests and responses network resources. Its definition makes clear that it can handle the nitty-gritty details of connecting to remote hosts, authenticating itself, and, by extension, your application, serializing payloads, deserializing responses, and providing all of this through a clean and simple interface.</p>
<p>With the <kbd>ContentType</kbd> and <kbd>ContentLength</kbd> properties, it provides a clean way to access and set the values for the most commonly required headers for any request with a payload. The specification is telling you to just give me that package, tell me where you want to send it, and let me handle the rest<em>.</em> It even gives you an interface for lumping similar operations together in a connection group through the <kbd>ConnectionGroupName</kbd> property. </p>
<p>Imagine that you have multiple requests to the same external RESTful API living at <kbd>https://financial-details.com/market/api</kbd>, and there are a dozen different endpoints that your application accesses over the course of its runtime. Meanwhile, you also have a handful of requests that need to be routed to <kbd>https://real-estate-details.com/market/api</kbd>. You can simply associate all of the requests made to the financial details API under one connection group name, and the real estate details API requests under another. Doing so allows .NET to more reliably manage connections to a single <kbd>ServicePoint</kbd> instance. This allows multiple requests to a single endpoint to be routed over the same active connection, improving performance and reducing the risk of what's known as connection pool starvation.</p>
<p>Whenever possible, make sure you're using <kbd>ConnectionGroupName</kbd> to associate requests to a single endpoint through a single connection. There is a finite number of active connections that you can hold at a given time in any .NET Core application, and without <kbd>ConnectionGroupName</kbd> tying requests to a single connection, each request will be given its own connection from the .NET Core runtime's pool of available connections. In applications with high network traffic or frequent external requests, this can lead to thread-starvation and unreliable performance.</p>
<p>Implementing this feature is quite trivial, but it can save you a mountain of time in performance tuning and chasing bugs. Simply define a static constant name for each connection group that you want to leverage, as follows:</p>
<pre>namespace WebRequest_Samples<br/>{<br/>    // Service class to encapsulate all external requests.<br/>    public class RequestService {<br/>        private static readonly string FINANCE_CONN_GROUP = "financial_connection";<br/>        private static readonly string REAL_ESTATE_CONN_GROUP = "real_estate_connection";<br/><br/>...</pre>
<p>Then, whenever you need to instantiate a new request for the target endpoint, you can simply specify the connection group name through the assignment, and under the hood, the <kbd>ServicePoint</kbd> instance that is associated with the <kbd>WebRequest</kbd> instance will check for any connections that share the group name, and, if one is discovered, leverage the connection for your new request:</p>
<pre>public static Task SubmitRealEstateRequest() <br/>{<br/>    WebRequest req = WebRequest.Create("https://real-estate-detail.com/market/api");<br/>    req.ConnectionGroupName = REAL_ESTATE_CONN_GROUP;<br/>    ...<br/>}</pre>
<p>And just like that, your request will take advantage of any established connections to that same external resource. If there are no other requests associated with the specified <kbd>ConnectionGroupName</kbd> property, then .NET Core will create a connection in its connection pool, and associate your request as the first in the connection group. This is especially useful if a set of requests are targeting a resource that requires access credentials, as the connection is established with those access credentials once, and then shared with the subsequent requests!</p>
<p class="mce-root"/>
<p>Once the connection is established, we'll need to know what to do with the responses for that request. For that, we have the <kbd>CachePolicy</kbd> property. This specifies how your requests should handle the availability of a cached response from your remote resource. This property gives us granular control over exactly how and when we should rely on a cached response, if at all. So, for example, if we have a dataset that is updated almost constantly, and we always want the most up-to-date response, we could avoid the cache entirely, by setting the policy accordingly:</p>
<pre>using System.Net.Cache;<br/>...<br/><br/>public static Task SubmitRealEstateRequest()<br/>{<br/>    WebRequest req = WebRequest.Create("https://real-estate-detail.com/market/api");<br/>    req.ConnectionGroupName = REAL_ESTATE_CONN_GROUP;<br/>    var noCachePolicy = new RequestCachePolicy(RequestCacheLevel.NoCacheNoStore);<br/>    req.CachePolicy = noCachePolicy;<br/>    ...<br/>}</pre>
<p>And just like that, the request will ignore any available cached responses, and likewise, it won't cache whatever response it receives from the external resource itself. As you can see, the property expects an instance of a <kbd>RequestCachePolicy</kbd> object, which is typically initialized with a value from the <kbd>RequestCacheLevel</kbd> enum definition found in the <kbd>System.Net.Cache</kbd> namespace (as indicated by its inclusion at the top of the code block).</p>
<p>This is another instance where familiarizing yourself with the IntelliSense tools of Visual Studio can give you a clear idea of what values are available in that enum. Of course, if you're using something such as Visual Studio Code or another source code editor, you can always look up the source code or the documentation for it on the manufacture's website. No matter which editor you use, in the case of properties or methods whose use is not easy to infer, make a habit of looking up implementation details and notes on Microsoft's documentation. But with something as obvious and straightforward as an enum defining cache policies, Visual Studio's autocomplete and IntelliSense functionality can save you the time and mental energy of context-switching away from your IDE to look up valid values.</p>
<p>In the same way that you define the behavior around cached or cache-able responses, you can use the public properties of the <kbd>WebRequest</kbd> instance to define and specify the expected behavior for authentication of your application and any expectations you have of the remote resource to authenticate. This is exposed through the <kbd>AuthenticationLevel</kbd> property and behaves much the same way as the <kbd>CachePolicy</kbd> property that we just looked at.</p>
<p>Suppose, for instance, that your software depends on a remote resource that is explicitly configured to work with only your software. The remote server would need to authenticate requests to ensure that they are generated from valid instances of your software. Likewise, you will want to make sure that you are communicating directly with the properly configured server, and not some man-in-the-middle agent looking to swipe your valuable financial and real-estate details. In that case, you would likely want to ensure that every request is mutually authenticated<em>, </em>and I'm sure you can already see where I'm about to go with this.</p>
<p>Since the <kbd>WebRequest</kbd> class is designed to encapsulate the entire operation of interacting with remote resources, we should expect that we can configure our instance of that class with the appropriate authentication policies, and not have to manage it ourselves. And that's exactly what we can do. Building on our earlier example, we can define the <kbd>AuthenticationLevel</kbd> property to enforce the policy we want to use once, and then let the <kbd>WebRequest</kbd> instance take it from there:</p>
<pre>using System.Net.Security;<br/>...<br/>public static Task SubmitRealEstateRequest() <br/>{<br/>    WebRequest req = WebRequest.Create("https://real-estate-detail.com/market/api");<br/>    req.ConnectionGroupName = REAL_ESTATE_CONN_GROUP;<br/>    var noCachePolicy = new RequestCachePolicy(RequestCacheLevel.NoCacheNoStore);<br/>    req.CachePolicy = noCachePolicy;<br/>    req.AuthenticationLevel = AuthenticationLevel.MutualAuthRequired;<br/>    ...<br/>}</pre>
<p>Note the inclusion of the <kbd>System.Net.Security</kbd> namespace in our <kbd>using</kbd> directives. This is where the <kbd>AuthenticationLevel</kbd> enum is defined. This makes sense, as authentication is one-half of the authentication and authorization security components of most network software. But we'll get more into that later.</p>
<p>As you can guess, getting your own software authenticated will likely require some credentials.</p>
<p>Assigning credentials is as easy to do as defining your authentication or caching policies. In the <kbd>WebRequest</kbd> class definition, the <kbd>Credentials</kbd> property is an instance of the <kbd>ICredentials</kbd> interface from the <kbd>System.Net</kbd> namespace, typically implemented as an instance of the <kbd>NetworkCredential</kbd> class. Again, the full scope of implementing reliable security for network requests will be covered later in this book, but for now, let's take look at how we might add some credentials to our mutually- authenticated web requests. It uses the <kbd>System.Net</kbd> namespace, so no additional <kbd>using</kbd> statements are required. Instead, we can simply set the property to a new instance of <kbd>NetworkCredential</kbd> and move on, as follows:</p>
<pre>req.Credentials = new NetworkCredential("test_user", "secure_and_safe_password");</pre>
<p>We should actually be storing the password as <kbd>SecureString</kbd>, but this constructor is valid, and as I said, we'll look closer at security in later chapters.</p>
<p>With this short, straightforward example, we can clearly see how the class properties of <kbd>WebRequest</kbd> define the expected use case for instances of the concrete sub-classes that implement and extend it. Now that we understand the shape and scope of the operations <kbd>WebRequest</kbd> intends to abstract away for us, let's take a look at the actual execution of those operations through the public methods exposed by the class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The class methods</h1>
                
            
            
                
<p>Now that we have a sufficiently complete picture of the shape of the <kbd>WebRequest</kbd> class, let's explore its scope, or proper use. Let's take a look at its public methods. Understanding what's available through the base class will give you everything you need to leverage any concrete implementation in the vast majority of your use cases, with perhaps only minor modifications. So, just as we did with the class properties, let's take look at the following list of public methods and see what we can infer about how the class is meant to be used:</p>
<ul>
<li><kbd>Abort()</kbd></li>
<li><kbd>BeginGetRequestStream(AsyncCallback, Object)</kbd></li>
<li><kbd>BeginGetResponse(AsyncCallback, Object)</kbd></li>
<li><kbd>Create(string)</kbd></li>
<li><kbd>Create(Uri)</kbd></li>
<li><kbd>CreateDefault(Uri)</kbd></li>
<li><kbd>CreateHttp(string)</kbd></li>
<li><kbd>EndGetRequestStream(IAsyncResult)</kbd></li>
</ul>
<ul>
<li><kbd>EndGetResponse(IAsyncResult)</kbd></li>
<li><kbd>GetObjectData(SerializationInfo, StreamingContext)</kbd></li>
<li><kbd>GetRequestStream()</kbd></li>
<li><kbd>GetRequestStreamAsync()</kbd></li>
<li><kbd>GetResponse()</kbd></li>
<li><kbd>GetResponseAsync()</kbd></li>
<li><kbd>GetSystemWebProxy()</kbd></li>
<li><kbd>RegisterPrefix(string, IWebRequestCreate)</kbd></li>
</ul>
<p>I only included the methods specific to the <kbd>WebRequest</kbd> class, and left out the public methods inherited from parent classes, such as <kbd>MarshalByRefObject</kbd> and <kbd>Object</kbd>, since those aren't relevant to our purpose. However, with this basic list of operations, the utility of the class should be pretty obvious.</p>
<p>The first thing that likely stands out is that the class should be used asynchronously. All of the <kbd>Begin</kbd> and <kbd>End</kbd> methods, as well as the <kbd>Async</kbd> suffix on a number of other methods, tell you that the class supports fine-grained control of the lifetime of your requests through the asynchronous features of .NET Core. Now, if you've never done async programming (as I often find to be the case with newer programmers just starting out of school, or programmers new to web development) we'll be covering that mental leap in much greater detail in the next chapter. It's not always intuitively obvious how best to leverage the features of async, or what's going on behind the scenes; so, for now, just think of it as deferring the actual execution of the method until later. Just like all those methods suggest, you <kbd>Begin</kbd> doing a task, and whenever you're ready to, you <kbd>End</kbd> it and look at your result.</p>
<p>The methods in this class can be broken up into two conceptual groups. There are methods for state management and methods for request execution. The state management methods allow you to modify or further define the state of your instance of the <kbd>WebRequest</kbd> utility class. Leveraging them to further configure and define the behavior of your instance is similar to setting any of the public properties on the class as we did in the last section on <em>Class properties</em>. The reason there are methods to do this, instead of simply having more settable properties, is because doing so involves at least some non-trivial logic or circumstance-specific details that are applied with each invocation of the methods. Meanwhile, the request execution functions allow you to define, invoke, and resolve web requests using the behavior of your instance. They're the workhorse methods that make all of the earlier configuration worthwhile. So, let's take a look at each of these sets of methods in turn and fully crystalize our understanding of this class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">State management methods</h1>
                
            
            
                
<p>I'd encourage you to try to sort the methods I've listed into the two categories I'm about to describe for you. And in the future, I'd encourage you to try to categorize interfaces and public class definitions in this way. Doing so will improve your ability to read and internalize new software features quickly, and leverage them efficiently, instead of copying code snippets from <a href="https://stackoverflow.com/">StackOverflow.com</a> until you find something that works. That said, let's take a look at the state management functions.</p>
<p>First, we have the <kbd>Create</kbd> methods. Each of these methods will return a usable instance of a concrete <kbd>WebRequest</kbd> sub-class. They're all static, and so can be invoked from the class definition without first needing to create an instance of it (for obvious reasons; why would you need to create an instance of a class to then create an instance of a class?). Depending on the specific method used, this sets up an instance of the default sub-class for the given scheme specified in the URI supplied to the method. So, if we wanted instances of <kbd>WebRequest</kbd> for accessing data from a RESTful HTTP service, collecting files from a designated FTP server, and reading data from a remote file system, we could do all of this with a simple call to <kbd>Create(uriString)</kbd>:</p>
<pre>var httpRequest = WebRequest.Create("http://test-domain.com");<br/>var ftpRequest = WebRequest.Create("ftp://ftp.test-domain.com");<br/>var fileRequest = WebRequest.Create("file://files.test-domain.com");</pre>
<p>You may recognize this code from the <kbd>SubmitRealEstateRequest</kbd> sample method we wrote in the <em>Class properties</em> section. I didn't explain it until now, but because the class is so clearly and simply defined, I expect you were able to infer its use just fine from my code without this explanation. But in case you were wondering why it seemed like I was creating an instance of an abstract class (a compile-time error in C#), that's why. I was actually requesting an instance of an appropriate sub-class from the abstract base-classes, static definition.</p>
<p>Those three use cases in the preceding code block cover just about everything you can do with <kbd>Create()</kbd> out of the box, but that certainly doesn't mean those are the only use cases <kbd>Create()</kbd> can apply to. The functionality uses common protocol prefixes for URIs to determine default sub-classes to instantiate. So, simply passing <a href="http://test-domain.com">http://test-domain.com</a> to the method is all the default implementation needs to then return an instance of the <kbd>HttpWebRequest</kbd> class. The same logic that allows the <kbd>Uri</kbd> class to parse the preceding string is used to tell <kbd>WebRequest</kbd> which protocol it should be creating a sub-class for.</p>
<p>As I said, though, the default behavior is only defined for a limited set of use cases out of the box. There are four specific protocols whose concrete sub-classes are preregistered with the <kbd>WebRequest</kbd> class at runtime; they are as follows:</p>
<ul>
<li><kbd>http://</kbd></li>
<li><kbd>https://</kbd></li>
<li><kbd>ftp://</kbd></li>
<li><kbd>file://</kbd></li>
</ul>
<p>So, any URI string given to the <kbd>Create</kbd> method with any of these four prefixes as the first characters in the string will be reliably handled by the <kbd>WebRequest</kbd> base class. And since the base class provides a sufficient interface for executing the core operations of its sub-classes, you don't even have to know specifically what sub-class was returned. Thanks to type inheritance, you can just declare your instance as being of type <kbd>WebRequest</kbd>, and use it accordingly, just like I did in the sample method from earlier.</p>
<p>But what if you don't want to work with one of these four preregistered types? What if you wrote your own custom <kbd>WebRequest</kbd> sub-class specifically for working with a <strong>WebSocket</strong> (<strong>WS</strong>) protocol, and you'd like to get the same support from <kbd>WebRequest</kbd> just by passing in a URI with the WebSocket prefix of <kbd>ws://</kbd>? Well, that exact use case leads us to another state management method: <kbd>RegisterPrefix(string, IWebRequestCreate)</kbd>.</p>
<p><kbd>RegisterPrefix</kbd> is a powerful new tool that supports what's known as <strong>pluggable protocols</strong>. It's basically a way for you to incorporate custom implementations and sub-classes of the <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> base classes into the runtime of your application. When done properly, your custom code can be treated as a first-class citizen in the <kbd>System.Net</kbd> namespace, being appropriately delegated to by system types and methods, and having full access to the network stack, just like the native library classes you'll be learning about next.</p>
<p>The scope and depth of fully implementing a custom protocol handler are beyond this chapter, and will be explored in more detail later in this book. For now though, just know that once the work of writing a custom protocol handler is completed, wiring it in is as simple as calling <kbd>RegisterPrefix</kbd>. That's why this falls under the domain of state management methods; because it's about configuring the working conditions of <kbd>WebRequest</kbd> for the duration of your application's runtime.</p>
<p>The method returns a <kbd>bool</kbd> to indicate the success or failure of your attempt to register your custom protocol, and throw or process exceptions accordingly. So, while the process of setting up a pluggable protocol is outside the scope of this chapter, for now just trust that, once the work is done, configuring it as part of the valid state of the <kbd>WebRequest</kbd> class is a straightforward affair:</p>
<pre class="mce-root">if(!WebRequest.RegisterPrefix("cpf://", new CustomRequestCreator())) {<br/>    throw new WebException("Failure to register custom prefix protocol handler.");<br/>}</pre>
<p class="mce-root">And with that, we have every tool we need to properly configure and initialize network requests. State management is complete, and all that's left is to begin submitting requests and processing responses.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Request execution methods</h1>
                
            
            
                
<p>As I said before, most of these methods are designed to be leveraged asynchronously, but at least a few of them have synchronous, or blocking, counterparts. While we'll talk more about async programming later, what's important now is to note that there are two primary operations or tasks around which the <kbd>WebRequest</kbd> class is focused. The first is accessing the actual request data stream, and the second is accessing the response returned by the remote resource.</p>
<p>With a <kbd>WebRequest</kbd> instance, the <kbd>RequestStream</kbd> is .NET's representation of the open connection. Think of it as the wire over which you can transmit your signal. Anytime you want to pass data through a <kbd>WebRequest</kbd> instance, you'll first need to access that wire. Once you have it, you can start passing data through that stream, and trust that the <kbd>WebRequest</kbd> class is going to broker its transmission accordingly.</p>
<p>Bear in mind that writing to a stream typically requires the raw byte array for a given object (this is where serialization comes into play), so once we have our stream, writing to it isn't as simple as passing our objects or messages directly over the wire, although it's not prohibitively complicated either. In practice, however you choose to access the request stream for an active instance of <kbd>WebRequest</kbd>, writing to it will typically look similar to the following code block:</p>
<pre>using System.Text;<br/>...<br/>// convert message to bytes<br/>string message = "My request message";<br/>byte[] messageBytes = Encoding.UTF8.GetBytes(message);<br/><br/>//write bytes to stream<br/>Stream reqStream = req.GetRequestStream();<br/>reqStream.Write(messageBytes, 0, messageBytes.length);</pre>
<p>And that's all there is to it. There are some nuances with this method in some of the common sub-classes of <kbd>WebRequest</kbd>, but the basic principle will always apply.</p>
<p>That, right there, accounts for about half of the request execution methods. The <kbd>BeginGetRequestStream()/EndGetRequestStream()</kbd>, <kbd>GetRequestStream()</kbd>, and <kbd>GetRequestStreamAsync()</kbd> methods are three different ways of accessing the same logical component of your network transaction. They simply provide varying degrees of control over the synchronization of the operation. For example, the <kbd>BeginGetRequestStream()/EndGetRequestStream()</kbd> method provides an opportunity for the user to cancel the request before it has completed transmission by explicitly calling the <kbd>Abort()</kbd> method. Meanwhile, the <kbd>GetRequestStreamAsync()</kbd> method doesn't provide the opportunity to explicitly abort the operation, but it does perform the operation asynchronously. Circumstances will dictate what method or methods you should be using, but if handled correctly and resolved properly by the underlying connection, the result object is the same.</p>
<p class="mce-root">Finally, we can look at the response processing methods, and it should be no surprise to you that in the request/response pattern that is typical of most network transactions, the response handlers match, almost exactly, with the request handler method signatures. So, where the act of retrieving a request stream from the <kbd>WebRequest</kbd> instance was exposed through four different methods with various levels of granular control over the synchronization of the operations, so too is response processing. The methods we have available to us are <kbd>BeginGetResponse()/EndGetResponse()</kbd> (the processing for which cannot be interrupted by <kbd>Abort()</kbd>, however), <kbd>GetResponseAsync()</kbd>, and of course, <kbd>GetResponse()</kbd>.</p>
<p>Understanding the shape of a given response will depend on the specific protocol over which it was received. Just as the <kbd>WebRequest</kbd> class has protocol-specific sub-classes, so too does the <kbd>WebResponse</kbd> base class. We'll explore each of them in their respective chapters, and look at how their responses can be handled more concretely. But for now, it is sufficient to say that the <kbd>WebResponse</kbd> class provides us with a reliable enough interface to meaningfully interact with whatever we get back from our request.</p>
<p>So, by now, you should have an extremely clear understanding of exactly what problem the <kbd>WebRequest</kbd> class was written to solve. You should understand its scope and the limits of its use cases, and hopefully, you will know exactly how to tune it so that you can fully leverage it for any scenario in which it could save you time and effort. With this understanding in mind, let's take a look at some of the most common ways the base class is explicitly leveraged through some of the sub-classes provided as part of the .NET Standard.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The sub-classes of the WebRequest class</h1>
                
            
            
                
<p>For a lot of typical use cases, you can rely on the basic functionality provided by the underlying <kbd>WebRequest</kbd> class. However, you'll never actually be using instances of it directly in your code (you can't... it's abstract, remember?), so now is the time to look at what other functionality or features exist when you're using common concrete instances of it. We'll look at each of the sub-classes for which <kbd>WebRequest</kbd> has a default, preregistered handler.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A note on obsolete sub-classes</h1>
                
            
            
                
<p>Here, it's important to note that the <kbd>WebRequest</kbd> class is primarily a tool for creating lower-level, protocol agnostic request/response transactions with other resources on your network. The .NET Standard provided sub-classes that, while not explicitly deprecated, have been made mostly obsolete by slightly more robust client classes, such as the <kbd>HttpClient</kbd> or <kbd>WebClient</kbd> classes.</p>
<p>As a matter of fact, Microsoft recently released a recommendation for always using the newer client classes over any of the slightly older sub-classes that I'm about to discuss. That's precisely why so little of this chapter is dedicated to the concrete classes. The important aspects of the request/response model are still handled by .NET's <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> classes under the hood of the new <kbd>WebClient</kbd> class. More importantly, those base classes are the most basic building blocks from which you can build your own custom protocol handlers. That's why it's so important to understand, especially for readers new to any sort of web or network programming, how and why the <kbd>WebRequest</kbd> class is written the way it is. However, as is often the case with software, times are changing, and so the extent that this lesson will remain useful as a practical guide for specific implementation of common patterns will only diminish with time.</p>
<p>That being said, it is worth examining what is different about those classes and how they can be used to build up a network request from scratch, so let's take a brief look. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">HttpWebRequest</h1>
                
            
            
                
<p>The <kbd>HttpWebRequest</kbd> class is interesting in that until very recently, it was<em> </em>the workhorse class of network programming in .NET. This is evident in the huge explosion of the class specification when compared to the relative simplicity of the <kbd>WebRequest</kbd> class. There are properties for each standard HTTP header that could be defined for a given payload, as well as a headers property inherited from the base class for specifying custom or non-standard headers. There are properties to specify the transport details, such as the <kbd>TransferEncoding</kbd>, or whether or not to send data in chunked segments. There are properties to specify how to handle exceptional behaviors from the remote host, such as the <kbd>MaximumResponseHeadersLength</kbd> and <kbd>MaximumAutomaticRedirections</kbd> properties. All of these properties allowed you to build a complete and strong payload for an HTTP request from scratch. As you can imagine, though, it was often tedious, error-prone, and verbose to do this for every request to every HTTP resource. Often, developers would hand-roll custom HTTP client classes of their own to isolate that aspect of their application in a write once, use everywhere approach. This degree of granularity is why the engineers at Microsoft decided to write a more robust and easy-to-use client for brokering common HTTP requests.</p>
<p>It is<em> </em>interesting to note, however, that if you look at class specifications side by side, the method signatures exposed by <kbd>HttpWebRequest</kbd> are exactly the same as those exposed by <kbd>WebRequest</kbd>. The only meaningful distinction between the two is the context-specific configurations that <kbd>HttpWebRequest</kbd> provides as class properties. This further highlights the elegance of the design of <kbd>WebRequest</kbd>. By taking a straightforward, generic approach to the problem, it can serve all possible specific use cases using the same patterns.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">FtpWebRequest</h1>
                
            
            
                
<p>The <kbd>FtpWebRequest</kbd> class provides many of the same properties as the <kbd>HttpWebRequest</kbd> class. The distinction comes in the form of a few specific properties for configuring reliable behavior when processing potentially large files over a potentially unreliable or slow connection. To that end, it provides the <kbd>ReadWriteTimeout</kbd> property that specifies the maximum amount of time allowed for processing the file stream. There's also the FTP-specific <kbd>UsePassive</kbd> property that allows a user to specify the use of the passive transfer process, leaving an open listening connection on the server for clients to access files accordingly.</p>
<p>There's also the explicit <kbd>EnableSsl</kbd> parameter, which you might have noticed was not a property of <kbd>HttpWebRequest</kbd>. Interestingly, this is necessary for the <kbd>FtpWebRequest</kbd> class but not the <kbd>HttpWebRequest</kbd> class because the use of <strong>Secure Sockets Layer</strong> (<strong>SSL</strong>) in HTTP is actually specified in the protocol component of the URI (that is, HTTP versus HTTPS); whereas with FTP, that feature must be enabled explicitly.</p>
<p>Once again, the actual use of the <kbd>FtpWebRequest</kbd> class is exactly the same as with the <kbd>WebRequest</kbd> base class. Once the protocol-specific settings are properly configured through the class properties, FTP is ultimately just another request/response protocol for accessing remote resources.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">FileWebRequest</h1>
                
            
            
                
<p>The <kbd>FileWebRequest</kbd> is probably the least commonly used sub-class of them all. Its signature almost perfectly matches that of the <kbd>WebRequest</kbd> base class. Its purpose is to expose the same reliable request/response pattern for accessing resources on the local file system.</p>
<p>At this point, you may be wondering why on earth such a class would ever be useful. Well, like any good engineer, we'll eventually want to be able to do a unit and integration test on our network software. However, that won't always be feasible, since remote resources that we can expect to be available to our production environment might not always be available to our development environment. In that case, you'd want to be able to access your mock resources on your local system. Thanks to the shared parent class of the <kbd>WebRequest</kbd> class, it's a trivial matter to swap out an instance of <kbd>FileWebRequest</kbd> and <kbd>HttpWebRequest</kbd> in your development and production environments, respectively. Since each of these sub-classes is only ever instantiated through the <kbd>Create()</kbd> method on the <kbd>WebRequest</kbd> class, doing so is as easy as changing the URI of the remote resource stored in your application's configuration files.</p>
<p>The power of the <kbd>FileWebRequest</kbd> class comes from the consistency of its interface. So, while there are no special properties or methods associated with this instance of the class, extending the behavior of <kbd>WebRequest</kbd> to local file access is really what makes this class valuable.</p>
<p>And with that, our crash-course on the building blocks of network interactions is complete.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we took a thorough look at the <kbd>WebRequest</kbd> utility class, and how it can be used to handle a wide variety of common network operations within the context of a .NET application. We used the public interface of the class definition to infer the proper use and use cases for the class, as well as identifying the limits of its scope and operations. We considered the proper use and invocation of each of the public properties and methods defined on the base class, and wrote out some broadly applicable examples to demonstrate the simplicity and utility of the class and its children. Then, we considered the three most common concrete sub-classes of <kbd>WebRequest</kbd>. We examined some of the nuances between each of them and looked at how they facilitate the specific details of the protocols they were designed to operate over. Now we're ready to look at how to process the results of those requests in the most optimal way for the .NET runtime. It's time we looked at data stream processing, multi-threading, and asynchronous programming, which we'll explore in the next chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What are the valid values for the <kbd>CachePolicy</kbd> property of the <kbd>WebRequest</kbd> class, and where can they be found?</li>
<li>What is the method used to associate the custom sub-classes of the <kbd>WebRequest</kbd> class with requests to the associated protocol for that custom sub-class?</li>
<li>What property is used to associate multiple requests to the same connection in the .NET connection pool?</li>
<li>What are the four preregistered protocols for which the <kbd>WebRequest</kbd> class is configured to return a valid sub-class from the <kbd>Create(uri)</kbd> method?</li>
<li>What is the difference between <kbd>BeginGetRequestStream()</kbd>, <kbd>GetRequestStreamAsync()</kbd>, and <kbd>GetRequestStream()</kbd>?</li>
<li>Name some of the ways the <kbd>HttpWebRequest</kbd> class differs from the default behavior of the <kbd>WebRequest</kbd> class?</li>
<li>Why is it important to always leverage <kbd>ConnectionGroupName</kbd> whenever possible?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>For additional reading on this subject, or to expand your horizons once you've conquered the realm of network programming, check out <em>Building Microservices with .NET Core</em>,<em> Gaurav Aroraa, Lalit Kale, and Kanwar Manish</em>, available through Packt Publishing at <a href="https://www.packtpub.com/web-development/building-microservices-net-core">https://www.packtpub.com/web-development/building-microservices-net-core</a>.</p>
<p>Additionally, I'd recommend checking out <em>C# 7 and .NET: Designing Modern Cross-platform Applications, Mark J. Price and Ovais Mehboob Ahmed Khan, Packt Publishing,</em> for some solid advice for practical applications of the concepts discussed here. You can find this book at <a href="https://www.packtpub.com/application-development/learning-path-c-7-and-net-designing-modern-cross-platform-applications">https://www.packtpub.com/application-development/learning-path-c-7-and-net-designing-modern-cross-platform-applications</a>.</p>


            

            
        
    </body></html>