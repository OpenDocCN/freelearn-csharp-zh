["```cs\n    using System.Threading;\n    using System.Drawing.Imaging;\n    ```", "```cs\n    // The number of processors or cores available in the computer for this application\n    private int priProcessorCount = Environment.ProcessorCount;\n    // The bitmaps list\n    private List<Bitmap> prloBitmapList;\n    // The long list with the old stars count\n    private List<long> prliOldStarsCount;\n    ```", "```cs\n    private Bitmap CropBitmap(Bitmap proBitmap, Rectangle proRectangle)\n    {\n    // Create a new bitmap copying the portion of the original defined by proRectangle and keeping its PixelFormat\n    Bitmap loCroppedBitmap = proBitmap.Clone(proRectangle,proBitmap.PixelFormat);\n    // Return the cropped bitmap\n    return loCroppedBitmap;\n    }\n    ```", "```cs\n    public bool IsOldStar(Color poPixelColor)\n    {\n    // Hue between 150 and 258\n    // Saturation more than 0.10\n    // Brightness more than 0.90\n    return ((poPixelColor.GetHue() >= 150) && (poPixelColor.GetHue() <= 258) && (poPixelColor.GetSaturation() >= 0.10) &&(poPixelColor.GetBrightness() <= 0.90)); \n    }\n    ```", "```cs\n    private void ThreadOldStarsFinder(object  poThreadParameter)\n    {\n    // Retrieve the thread number received in objectpoThreadParameter\n    int liThreadNumber = (int)poThreadParameter;\n    // The pixel matrix (bitmap) row number (Y)\n    int liRow;\n    // The pixel matrix (bitmap) col number (X)\n    int liCol;\n    // The pixel color\n    Color loPixelColor;\n    // Get my bitmap part from the bitmap list\n    Bitmap loBitmap = prloBitmapList[liThreadNumber];\n\n    // Reset my old stars counter\n    prliOldStarsCount[liThreadNumber] = 0;\n    // Iterate through each pixel matrix (bitmap) row\n    for (liRow = 0; liRow < loBitmap.Height; liRow++)\n    {\n    // Iterate through each pixel matrix (bitmap) cols\n    for (liCol = 0; liCol < loBitmap.Width; liCol++)\n    {\n    // Get the pixel color for liCol and liRow\n    loPixelColor = loBitmap.GetPixel(liCol, liRow);\n    if (IsOldStar(loPixelColor))\n    {\n    // The color range corresponds to an old star\n    // Change its color to a pure blue\n    loBitmap.SetPixel(liCol, liRow, Color.Blue);\n    // Increase the old stars counter\n    prliOldStarsCount[liThreadNumber]++;\n    }\n    }\n    }\n    }\n    ```", "```cs\nreturn ((poPixelColor.GetHue() >= 150)\n     && (poPixelColor.GetHue() <= 258)\n     && (poPixelColor.GetSaturation() >= 0.10)\n     && (poPixelColor.GetBrightness() <= 0.90));\n\n```", "```cs\n        // The threads list\n        private List<Thread> prloThreadList;\n        // The original huge infrared bitmap portrait\n        Bitmap proOriginalBitmap;\n    ```", "```cs\n        private void WaitForThreadsToDie()\n        {\n            // A bool flag\n            bool lbContinue = true;\n            int liDeadThreads = 0;\n            int liThreadNumber;\n            while (lbContinue)\n            {\n                for (liThreadNumber = 0; liThreadNumber< priProcessorCount; liThreadNumber++)\n                {\n                    if (prloThreadList[liThreadNumber].IsAlive)\n                    {\n                        // One of the threads is still alive, \n                        // exit the for loop and sleep 100 \n                        // milliseconds\n                        break;\n                    }\n                    else\n                    {\n                        // Increase the dead threads count\n                        liDeadThreads++;\n                    }\n                }\n                if (liDeadThreads == priProcessorCount)\n                {\n                    // All the threads are dead, exit the while \n                    // loop\n                    break;\n                }\n                Thread.Sleep(100);\n                liDeadThreads = 0;\n            }\n        }\n    ```", "```cs\n        private void ShowBitmapWithOldStars()\n        {\n            int liThreadNumber;\n            // Each bitmap portion\n            Bitmap loBitmap;\n            // The starting row in each iteration\n            int liStartRow = 0;\n\n            // Calculate each bitmap's height\n            int liEachBitmapHeight = ((int)(proOriginalBitmap.Height / priProcessorCount)) + 1;\n\n            // Create a new bitmap with the whole width and \n            // height\n            loBitmap = new Bitmap(proOriginalBitmap.Width,proOriginalBitmap.Height);\n            Graphics g = Graphics.FromImage((Image)loBitmap);\n            g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;\n\n            for (liThreadNumber = 0; liThreadNumber < priProcessorCount; liThreadNumber++)\n            {\n                // Draw each portion in its corresponding \n                // absolute starting row\n                g.DrawImage(prloBitmapList[liThreadNumber], 0,liStartRow);\n                // Increase the starting row\n                liStartRow += liEachBitmapHeight;\n            }\n            // Show the bitmap in the PictureBox picStarsBitmap\n            picStarsBitmap.Image = loBitmap;\n\n            g.Dispose();\n        }\n    ```", "```cs\n        proOriginalBitmap = new Bitmap(picStarsBitmap.Image);\n\n        // Thread number\n        int liThreadNumber;\n        // Create the thread list; the long list and the bitmap list\n        prloThreadList = new List<Thread>(priProcessorCount);\n        prliOldStarsCount = new List<long>(priProcessorCount);\n        prloBitmapList = new List<Bitmap>(priProcessorCount);\n\n        int liStartRow = 0;\n\n        int liEachBitmapHeight = ((int)(proOriginalBitmap.Height / priProcessorCount)) + 1;\n\n        int liHeightToAdd = proOriginalBitmap.Height;\n        Bitmap loBitmap;\n\n        // Initialize the threads\n        for (liThreadNumber = 0; liThreadNumber < priProcessorCount; liThreadNumber++)\n        {\n            // Just to occupy the number\n            prliOldStarsCount.Add(0);\n\n            if (liEachBitmapHeight > liHeightToAdd)\n            {\n                // The last bitmap height perhaps is less than the other bitmaps height\n                liEachBitmapHeight = liHeightToAdd;\n            }\n\n            loBitmap = CropBitmap(proOriginalBitmap, new Rectangle(0, liStartRow, proOriginalBitmap.Width,liEachBitmapHeight));\n            liHeightToAdd -= liEachBitmapHeight;\n            liStartRow += liEachBitmapHeight;\n            prloBitmapList.Add(loBitmap);\n\n            // Add the new thread, with a parameterized start \n            // (to allow parameters)\n            prloThreadList.Add(new Thread(new ParameterizedThreadStart (ThreadOldStarsFinder)));\n        }\n\n        // Now, start the threads\n        for (liThreadNumber = 0; liThreadNumber < priProcessorCount; liThreadNumber++)\n        {\n            prloThreadList[liThreadNumber].Start(liThreadNumber);\n        }\n\n        WaitForThreadsToDie();\n\n        ShowBitmapWithOldStars();\n    ```", "```cs\nproOriginalBitmap = new Bitmap(picStarsBitmap.Image);\n```", "```cs\nprloThreadList = new List<Thread>(priProcessorCount);\nprliOldStarsCount = new List<long>(priProcessorCount);\nprloBitmapList = new List<Bitmap>(priProcessorCount);\n```", "```cs\nint liStartRow = 0;\n```", "```cs\nint liEachBitmapHeight = ((int)(proOriginalBitmap.Height /priProcessorCount)) + 1;\n```", "```cs\nint liHeightToAdd = proOriginalBitmap.Height;\n```", "```cs\nif (liEachBitmapHeight > liHeightToAdd)\n{\n    liEachBitmapHeight = liHeightToAdd;\n}\nloBitmap = CropBitmap(proOriginalBitmap, new Rectangle(0, liStartRow, proOriginalBitmap.Width, liEachBitmapHeight));\nliHeightToAdd -= liEachBitmapHeight;\nliStartRow += liEachBitmapHeight;\nprloBitmapList.Add(loBitmap);\n```", "```cs\nliHeightToAdd -= liEachBitmapHeight;\n```", "```cs\nfor (liThreadNumber = 0; liThreadNumber < priProcessorCount; liThreadNumber++)\n{\n    prloThreadList[liThreadNumber].Start(liThreadNumber);\n}\n```", "```cs\nfor (liThreadNumber = 0; liThreadNumber < priProcessorCount;liThreadNumber++)\n{\n    if (prloThreadList[liThreadNumber].IsAlive)\n    {\n        break;\n    }\n    else\n    {\n        liDeadThreads++;\n    }\n} \n```", "```cs\nif (liDeadThreads == priProcessorCount)\n{\n    break;\n}\n```", "```cs\nThread.Sleep(100);\nliDeadThreads = 0;\n```", "```cs\nloBitmap = new Bitmap(proOriginalBitmap.Width,proOriginalBitmap.Height);\nGraphics g = Graphics.FromImage((Image)loBitmap);\ng.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;\n```", "```cs\nfor (liThreadNumber = 0; liThreadNumber < priProcessorCount;liThreadNumber++)\n{\n    g.DrawImage(prloBitmapList[liThreadNumber], 0, liStartRow);\n    liStartRow += liEachBitmapHeight;\n}\n```", "```cs\npicStarsBitmap.Image = loBitmap;\n```", "```cs\n        [MTAThread]\n    ```", "```cs\n        // The AutoResetEvent instances array\n        private AutoResetEvent[] praoAutoResetEventArray;\n    ```", "```cs\n        // Just wait for the threads to signal that every work \n        // item has finished\n        WaitHandle.WaitAll(praoAutoResetEventArray);\n    ```", "```cs\n        // Create the AutoResetEvent array with the number of \n        // cores available\n      praoAutoResetEventArray = new AutoResetEvent[priProcessorCount];\n    ```", "```cs\n        // Create a new AutoResetEvent instance for that thread with its initial state set to false\n        praoAutoResetEventArray[liThreadNumber] = new AutoResetEvent(false);\n    ```", "```cs\n        // The thread finished its work. Signal that the work \n        // item has finished.\n        praoAutoResetEventArray[liThreadNumber].Set();\n    ```", "```cs\npraoAutoResetEventArray = new AutoResetEvent[priProcessorCount];\n```", "```cs\npraoAutoResetEventArray[liThreadNumber] = new AutoResetEvent(false);\n```", "```cs\npraoAutoResetEventArray[liThreadNumber].Set();\n```", "```cs\nWaitHandle.WaitAll(praoAutoResetEventArray);\n```", "```cs\nprloThreadList[liThreadNumber].Join();\n```", "```cs\n            // Now, start the threads\n            for (liThreadNumber = 0; liThreadNumber < priProcessorCount; liThreadNumber++)\n            {\n                prloThreadList[liThreadNumber].Start(liThreadNumber);\n\n                //Wait here on the Thread you just created to \n                // complete.\n                prloThreadList[liThreadNumber].Join();\n\n            }\n```", "```cs\n                        lock (objVariable)\n                        {\n\n                        }\n```", "```cs\nvar temp = object1;\n\nMonitor.Enter(temp);\n\ntry\n{\n    // body\n}\nfinally\n{\n    Monitor.Exit(temp);\n}\n```", "```cs\nbool locked = false;\nvar temp = object1;\ntry\n{\n    Monitor.Enter(temp, ref locked);\n    // body\n}\nfinally\n{\n    if (locked)\n    {\n        Monitor.Exit(temp); \n    }\n}\n```", "```cs\n    //Old stars count using a lock to protect thread safety.\n            private String prsOldStarsCount = \"0\";\n    ```", "```cs\nlock (prsOldStarsCount)\n            {\n                int i = Convert.ToInt32(prsOldStarsCount);\n                i= i + 1;\n                prsOldStarsCount = i.ToString();\n            }\n```", "```cs\n    using System;\n    using System.Threading;\n\n    public class ProducerConsumer\n    {\n        public static void Main(String[] args)\n        {\n            int result = 0;   // Results output\n            Cell cell = new Cell();\n\n            Producer producer = new Producer(cell, 5);  \n            Consumer consumer = new Consumer(cell, 5);  \n\n            Thread producerThread = new Thread(new ThreadStart(producer.ThreadRun));\n            Thread consumerThread = new Thread(new ThreadStart(consumer.ThreadRun));\n\n            try\n            {\n                producerThread.Start();\n                consumerThread.Start();\n\n                // Join both threads.\n                producerThread.Join();   \n                consumerThread.Join();\n\n            }\n            catch (ThreadStateException e)\n            {\n                System.Diagnostics.Debug.WriteLine(e);  // Output text of exception.\n                result = 1;            // Set result to indicate an error.\n            }\n            catch (ThreadInterruptedException e)\n            {\n                System.Diagnostics.Debug.WriteLine(e);  // Output text noting an interruption.\n                result = 1;            // Set result to indicate an error.\n            }\n\n            Environment.ExitCode = result;\n        }\n    }\n\n    public class Producer\n    {\n        Cell cell;        \n        int quantity = 1;  \n\n        public Producer(Cell box, int request)\n        {\n            cell = box;          \n            quantity = request;  \n        }\n        public void ThreadRun()\n        {\n            for (int looper = 1; looper <= quantity; looper++)\n                cell.Write(looper);  // \"producing\"\n        }\n    }\n\n    public class Consumer\n    {\n        Cell cell;        \n        int quantity = 1;  \n\n        public Consumer(Cell box, int request)\n        {\n            cell = box;         \n            quantity = request;  \n        }\n        public void ThreadRun()\n        {\n            int value;\n            for (int looper = 1; looper <= quantity; looper++)\n                value = cell.Read();    // Consume the result by putting it in value\n        }\n    }\n\n    public class Cell\n    {\n        int cellContents;      \n        bool State = false;  \n        public int Read()\n        {\n            lock (this)   // Synchronizing block of code.\n            {\n                if (!State)\n                {            // Wait until Cell.Write is done producing\n                    try\n                    {\n                        Monitor.Wait(this);     // Waits for the Monitor.Pulse in Write\n                    }\n                    catch (SynchronizationLockException e)\n                    {\n                        System.Diagnostics.Debug.WriteLine(e);\n                    }\n                    catch (ThreadInterruptedException e)\n                    {\n                        System.Diagnostics.Debug.WriteLine(e);\n                    }\n                }\n                System.Diagnostics.Debug.WriteLine(String.Format(\"Consumed cell item {0}\", cellContents));\n                State = false;    // Consumption is done.\n\n                Monitor.Pulse(this);   // Pulse tells Cell.Write that Cell.Read is finished.\n            }   \n\n            return cellContents;\n        }\n\n        public void Write(int n)\n        {\n            lock (this)  // Synchronization block\n            {\n                if (State)\n                {      // Wait until Cell.Read is done consumption.\n                    try\n                    {\n                        Monitor.Wait(this);   // Wait for the Monitor.Pulse in Read.\n                    }\n                    catch (SynchronizationLockException e)\n                    {\n                        System.Diagnostics.Debug.WriteLine(e);\n                    }\n                    catch (ThreadInterruptedException e)\n                    {\n                        System.Diagnostics.Debug.WriteLine(e);\n                    }\n                }\n                cellContents = n;\n                System.Diagnostics.Debug.WriteLine(String.Format(\"Produced cell item {0}\", cellContents));\n                State = true;    // Set State to indicate production is done.\n\n                Monitor.Pulse(this);  // Pulse tells Cell.Read that Cell.Write is finished.\n\n            }   \n        }\n    }\n    ```"]