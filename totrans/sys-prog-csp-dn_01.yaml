- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The One with the Low-Level Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Understanding* *low-level APIs*'
  prefs: []
  type: TYPE_NORMAL
- en: Writing software can be a daunting task. You need to consider many things when
    you try to convert your ideas into something that works on the machine. After
    all, there are so many things you need to tell the computer before it does something
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: But we are in luck. Many of the instructions we need to give the CPU are encapsulated
    in frameworks, tools, packages, and other pieces of software. These building blocks
    allow us to focus on what we want to build instead of how the CPU might interpret
    our instructions. That makes life a lot easier!
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter looks into those building blocks, how they help us, and how we
    can best use them. This chapter also covers how .NET works and where it comes
    from. This is important: most developers take the advantages of .NET for granted.
    That is fine since the framework hides much complexity. However, when writing
    lower-level system software, it is essential to know why things in .NET work the
    way they do and how to use other solutions if needed. Also, it doesn’t hurt to
    be reminded of some basic things occasionally, especially when you might have
    to deviate from the road user-facing software developers take.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are low-level APIs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does the Base Class Library (BCL) help us .NET developers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the Common Language Runtime (CLR)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Win32 APIs and how do we call them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All in all, we are going low here and getting all technical.
  prefs: []
  type: TYPE_NORMAL
- en: But before we dive into the building blocks the .NET ecosystem gives us, we
    need to chat about APIs – to be more precise, the difference between low-level
    and high-level APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can visit the following link to view all the code in this chapter: [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter01](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter01).'
  prefs: []
  type: TYPE_NORMAL
- en: What are low-level APIs, and how do they differ from higher-level abstractions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, maybe we are going a bit too fast. Before we can look at low-level and
    high-level APIs, we need to agree on what an API means.
  prefs: []
  type: TYPE_NORMAL
- en: API is an abbreviation for application programming interface. Although technically
    correct, it doesn’t tell us much. We need a better definition of API.
  prefs: []
  type: TYPE_NORMAL
- en: What are interfaces?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with the term **interface.** That alone can be defined entirely
    differently, depending on whom you ask.
  prefs: []
  type: TYPE_NORMAL
- en: An interface can be a **software interface**, which is the boundary between
    two pieces of software. For instance, a database such as SQL Server allows users
    to access data by accepting SQL queries. That is the main interface for that database
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Another definition of an interface would be a **hardware interface**. The USB
    ports on your computer and the peripherals you connect to your machine using them
    are hardware interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in C#, we also have interfaces. Most object-oriented programming
    languages support interfaces in one way or another. For instance, C++ has the
    concept of pure virtual classes. Python supports abstract base classes, which
    serve the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: An API is the interface between a piece of software and other software meant
    for the programmer. This defines the boundaries of a given code set and how to
    interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: So, it is possible to create a giant library filled with wondrous and highly
    complex code. As the library user, you get a list of methods, classes, interfaces
    (yes, the C# kind), enums, and other means of interacting with that library.
  prefs: []
  type: TYPE_NORMAL
- en: This is awesome since you can use that library without worrying about writing
    code yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Low-level and high-level APIs
  prefs: []
  type: TYPE_NORMAL
- en: The level of an API is an arbitrary distinction to give you an idea of how close
    to the actual hardware an API is.
  prefs: []
  type: TYPE_NORMAL
- en: No metric tells us when something is a lower or higher-level API. It is all
    relative and open for debate. This, however, is something we are not going to
    do here.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, a low-level API gives you more granular control over the hardware
    than a higher-level API. A higher-level API, however, is usually more portable
    and can be used to achieve goals much quicker.
  prefs: []
  type: TYPE_NORMAL
- en: If that all sounds a bit abstract, don’t worry. Let me clarify this with some
    examples. For instance, imagine that you want to send some data across a network.
    Well, when I say network, I mean we send it to IP address `127.0.0.1`. In other
    words, we send it to localhost; we are speaking to ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to call a lot of low-level APIs that the Windows SDK gives
    us. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, many things must happen for such a relatively simple task. I
    have omitted all the code we need to access the APIs and the definition of the
    classes and structs, such as `WSAData`. I also simplified this sample and didn’t
    use much error handling or memory management.
  prefs: []
  type: TYPE_NORMAL
- en: I won’t go through what’s happening in the preceding code as it isn’t part of
    what I’m trying to show you. We will revisit this later in this book when we discuss
    networking. I provided this code to show you what a low-level API looks like.
    Here, I want you to pay attention to the calls to `WSAStartup()`, `WSACleanup()`,
    `socket()`, `connect(`), `send()`, and `closesocket()`. These are APIs that come
    from the Windows SDK. They are the parts of Windows that help us set up connections
    to network interfaces, translate addresses, open and close sockets, and send data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'It is good to remember that the Windows SDK is a wrapper. The code inside the
    SDK, written mainly in C and a bit in C++, does the heavy lifting and calls the
    hardware. We don’t have to worry about this: the people at Microsoft have already
    figured out how to do all this.'
  prefs: []
  type: TYPE_NORMAL
- en: Like I said, low-level and high-level terms depend on how you look at them.
    It is all relative. You can consider Windows SDK APIs high-level APIs when you
    look at them from a C programmer’s perspective, who has to do all the heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we, as .NET developers, see this as rather low-level. This is because,
    as .NET developers, we have even easier tools to use. The preceding code isn’t
    something most developers will write. Instead, they will write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code is much easier and a lot smaller. Most of the preceding code consists
    of catching exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The `TcpClient` class is doing the hard work. We instantiate an instance of
    it, give it the address we want to connect to, get a `NetworkStream` instance
    from it, and then write a bunch of bytes. Simple. It works brilliantly.
  prefs: []
  type: TYPE_NORMAL
- en: So, why would you care about the low-level stuff?
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the low-level code is a lot more work and complicated, it gives you
    one significant advantage: more control.'
  prefs: []
  type: TYPE_NORMAL
- en: We use TCP/IP here. But what if the device you want to communicate with doesn’t
    have TCP? And before you say “Everything is IP-based these days,” I’m pretty sure
    you have computers in your house that communicate over older technology. You might
    use devices that don’t have TCP on board every day. I’m talking about remote controls
    for most television sets. They use infrared. Many devices still use infrared.
    It’s cheap, well-understood, quick to install, and robust in terms of its use
    cases. It is also not supported by .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'But when it comes to low-level APIs, it is pretty simple. There are some differences
    in how to set up the connection: there is no IP address, so you have to use the
    device ID, but the connection itself is not that hard to use. Look at the line
    where we set up the call to `socket()`. We use `2` as the first parameter, which
    stands for `AF_INET`, which means TCP. Change that to `26 (AF_IRDA)`, and the
    underlying libraries switch to infrared devices.'
  prefs: []
  type: TYPE_NORMAL
- en: This can’t be done with the .NET libraries that are available.
  prefs: []
  type: TYPE_NORMAL
- en: The high-level APIs are amazing and help us write code that is easy to understand
    quickly. However, as systems programmers, we have to deal with hardware and other
    low-level systems. That’s when we have to use the low-level APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into how to use these APIs, let’s look at the .NET libraries
    themselves. While we’re at it, we’ll examine the CLR so that you have a clear
    picture of what .NET gives us.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of .NET Core runtime components (CLR, BCL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we examined the difference between low-level and high-level programming
    languages. Like the APIs, lower and higher mean how close to or far away you are
    from the actual machine. Programming in C means you are very close to the hardware;
    programming in C# means you are far away. Of course, being further away means
    you are working in abstractions. The advantage is that many things are simplified,
    as seen earlier in this chapter. Also, with many abstractions, moving your code
    to other platforms is more manageable.
  prefs: []
  type: TYPE_NORMAL
- en: The magic that makes this possible is the .NET runtime. Since the first version,
    the designers have always aimed to shield you from the low-level stuff as much
    as possible. This lets you write your code quickly and focus on functionality
    instead of boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: .NET is a complex topic. But in short, it comes down to a set of tools in many
    different forms that help you achieve your goal.
  prefs: []
  type: TYPE_NORMAL
- en: Fun fact
  prefs: []
  type: TYPE_NORMAL
- en: 'Before its initial launch, the project’s code name was Project 42\. 42 is the
    answer to life, the universe, and everything in the books, TV shows, and the major
    motion picture from science fiction author Douglas Adams: *The Hitchhikers Guide
    to the Galaxy*. Adams wrote that 42 was the answer to everything; hence, the .NET
    designers thought it appropriate to name the solution to all developer problems
    Project 42.'
  prefs: []
  type: TYPE_NORMAL
- en: .NET does not solve all problems, but it makes life much easier. Let’s see how
    it does that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can identify three major areas where .NET helps us:'
  prefs: []
  type: TYPE_NORMAL
- en: Development tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CLR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The BCL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will not be spending time on development tools here. Instead, I want to discuss
    the CLR and the BCL. These two form the backbone of the .NET ecosystem. In later
    chapters, I will cover other essential parts of the .NET ecosystem, such as the
    **Common Type** **System** (**CTS**).
  prefs: []
  type: TYPE_NORMAL
- en: CLR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CLR is the runtime environment in which our code runs.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler (covered later in this book) compiles the code we have written.
    For now, we can imagine that the compiler takes our human-readable text and changes
    it into something a computer can understand and use.
  prefs: []
  type: TYPE_NORMAL
- en: Well, not quite. I need to clarify things a bit here. Although what I wrote
    is technically correct when discussing compilers, this is only true for real compilers,
    such as those found using C or C++. This does not apply to the .NET-based world.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET compilers compile while targeting a common runtime instead of the hardware
    we run on.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler’s output is not native to the hardware. Instead, it outputs something
    called Intermediate Language (IL). This is a sort of “in-between” form. It’s not
    human-readable, but it is too abstract for computers to understand. It is in between
    those two forms.
  prefs: []
  type: TYPE_NORMAL
- en: Let me clarify that with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have written a .NET Console app with no top-level statements. In other words,
    this is the most simple piece of code we can write using .NET. The whole program
    consists of one single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I don’t need to explain what I’m doing here, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use Visual Studio to compile the code, it will take all of our files,
    give them to the compiler, and instruct it to build a binary. That looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit harder to understand but not too hard. First, there’s some code
    to set things up (`.maxstack 8`). We load the string with the call to the `ldstr`
    function and then call the `System.Console::WriteLine(string)` method, and we
    are done.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this is not machine code. That looks a lot harder, and I’m not going
    to show you that. If compiled to something the CPU can understand and execute,
    this code is several pages long.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I will show you part of it to give you a taster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This tiny assembly code segment instructs the CPU to take a pointer to the memory
    where the string is and then calls the first part of the `WriteLine` method.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the complete code would be several pages long.
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope you are beginning to appreciate the brevity and simplicity of the .NET
    system. But I also want you to know what happens behind the scenes. When writing
    system software, we sometimes need to do things that aren’t possible in .NET.
    Then, we have to rely on other ways to achieve our results. We won’t write pure
    assembly in this book: that would be too much. But I do want you to know what’s
    happening as that will benefit you enormously later on.'
  prefs: []
  type: TYPE_NORMAL
- en: Okay. Between the IL code I showed you and the assembly code I showed you is
    the place where the CLR lives.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated in [https://learn.microsoft.com/en-us/dotnet/standard/clr](https://learn.microsoft.com/en-us/dotnet/standard/clr),
    the CLR offers us quite a lot of things:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to easily use components developed in other languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensible types provided by a class library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language features such as inheritance, interfaces, and overloading for object-oriented
    programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for explicit free threading that allows multithreaded and scalable applications
    to be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for structured exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for custom attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This information comes straight out of the documentation from Microsoft, so
    if you want to know more, I urge you to look it up and read more about it. Later
    chapters will discuss some of these items, such as threading, exception handling,
    and garbage collection. For now, it is enough to know that when we compile our
    code, we prepare it for the CLR to use and run it. The CLR will take care of the
    rest and make it work nicely on actual hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that runs on the CLR is what we call managed code. All other code
    (thus code not under the CLR’s control) is unmanaged. You will deal with managed
    code most of the time, but when writing system software, you’ll encounter unmanaged
    code quite frequently. But don’t worry: I will guide you through that!'
  prefs: []
  type: TYPE_NORMAL
- en: BCL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the goals the designers of .NET had in mind was to eliminate something
    developers called DLL Hell.
  prefs: []
  type: TYPE_NORMAL
- en: The idea was that, when writing software, developers quickly realized that writing
    the same code repeatedly would be tiresome and a nightmare to maintain. Instead,
    they created libraries with functions they could reuse. These libraries would
    be loaded on demand and linked to the calling code. That is where the name **Dynamic
    Link Library** (**DLL**) originated.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, developers, being developers, were not content with the DLLs they
    or someone else wrote earlier and made changes to them. These changes weren’t
    always backward compatible. That meant that as a user of a DLL, you had to make
    sure you used the correct version. You couldn’t easily upgrade without testing
    if that particular version of the DLL worked with your code.
  prefs: []
  type: TYPE_NORMAL
- en: There were two types of DLLs. One was proprietary to your code. You placed these
    DLLs in the same directory as your application, so all you needed to do was load
    the DLLs in your app directory. If a new application version came out, it came
    with its own set of DLLs.
  prefs: []
  type: TYPE_NORMAL
- en: Since most of the DLLs didn’t change a lot (if they even changed at all) there
    were many repetitive and duplicate DLLs. So, instead of duplicating code, we were
    now duplicating DLLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, a solution was available: you could place DLLs in a shared space.
    On Windows, that was the `C:\Windows\System32` directory. The runtime knew that
    if it needed to load a DLL and couldn’t locate it in the `applications` directory,
    it could look at the `System32` directory and find it there.'
  prefs: []
  type: TYPE_NORMAL
- en: When doing this, you needed to be sure you maintained backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, things went wrong. Updates would replace DLLs with newer, non-compatible
    versions. Sometimes, applications updated a DLL without realizing something else
    depended on it. Sometimes, an update would delete DLLs and thus break applications.
    In many cases, developers deployed the wrong versions. The list goes on and on.
    This caused many developers many frustrations and resulted in them calling this
    DLL Hell. Project 42 was set up to solve this. And in a way, it did.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few decades ago, a `String` class was the first thing a new C++ programmer
    would write. C and C++ did not have such a thing: strings were not native to the
    language (they still aren’t, but the helper classes containing them are part of
    the standard now). A string can be pretty simple: it is just a pointer to a place
    in memory where all subsequent bytes form one long string. The string ends when
    the system sees a byte with a value of 0 (zero, not the character o). That’s it.
    A `String` class would contain the address of that array of bytes, some helper
    methods that allocate and clear the memory, and additional functions such as `Length()`.
    That’s it.'
  prefs: []
  type: TYPE_NORMAL
- en: Soon, everybody wrote different versions, which would all be slightly different.
    .NET solved that by having a `String` class available. That class was part of
    a DLL that got shipped with the framework. The system registered that DLL, along
    with its version number. So, all developers needed to do was tell the system which
    version of the framework it was using, and by magic, things such as Strings were
    available. I am oversimplifying things here, but that is basically how things
    work.
  prefs: []
  type: TYPE_NORMAL
- en: There is a vast library that you can use as a .NET developer. You can see it
    in `C:\Windows\assembly`. If you use Windows Explorer, you’ll see a filtered view
    of the contents. You can see the actual contents using a terminal or command line.
  prefs: []
  type: TYPE_NORMAL
- en: These DLLs are part of the BCL. The BCL is a set of helper classes, functions,
    methods, and enums that help you do your work. Instead of figuring out all the
    code yourself, it is part of the installation and ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classes and other code constructs in the DLLs that form the BCL are organized
    into namespaces. The BCL contains lots of helpful code some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System` namespace, which contains classes such as O`bject`, `String`, `Array`,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.IO` namespace, for dealing with files, streams, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Net` for dealing with networking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Threading` for dealing with – you guessed it – multithreading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Data` for dealing with data storage in databases and other ways of
    persisting data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Xml` here, which you can use to handle XML files and data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Diagnostics` helps you identify issues in your code. We will be diving
    into this one later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Security` namespace, along with all things related to security and
    encryption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more namespaces, but these are some of the most used ones. We
    will revisit them later.
  prefs: []
  type: TYPE_NORMAL
- en: However, remember that these classes are there to help you. They wrap complicated
    and extensive code in good ways for most developers. However, If you find that
    the BCL code doesn’t get you where you want to be, nothing is stopping you from
    writing the code yourself. As we saw earlier, the BCL code is awesome if you want
    to set up a TCP/IP connection, but if you want to use an infrared connection instead,
    you must do it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that you can mix and match. Use the BCL where you can and low-level
    APIs where you need to.
  prefs: []
  type: TYPE_NORMAL
- en: Using P/Invoke to call low-level APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have established that .NET gives you many tools to develop something quickly.
    It also helps you out by shielding you from the low-level details of the underlying
    operating system. But it also allows you to use low-level APIs if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: But how can we access those APIs? The answer is **Platform Invocation**, or
    (**P/Invoke**). We can use this tool to access the Win32 API directly. P/Invoke
    bridges the gap between the two platforms so that we can mix and match to our
    hearts’ content.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Win32 is the name of the SDK and the APIs made available. There is no such thing
    as a Win64 API. Our code is compiled against 64-bit Windows if you run that platform,
    yet we (and Microsoft) still call it the Win32 API.
  prefs: []
  type: TYPE_NORMAL
- en: How does P/Invoke work?
  prefs: []
  type: TYPE_NORMAL
- en: 'P/Invoke involves a couple of steps. These are the steps you must follow to
    use a Win32 API in a .NET application:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the API you want to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the DLL the API resides in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load that DLL in your assembly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a stub that tells your application how to call that API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the .NET data types into something the Win32 API can understand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Warning!
  prefs: []
  type: TYPE_NORMAL
- en: 'You are out of the loving and caring hands of .NET Framework and the CLR. You
    are no longer protected against mistakes. You are in an unmanaged world now. In
    the old days, they probably would have marked this part of the documentation with
    the warning “Here be dragons.” You are now responsible for many more things than
    you might be used to, such as memory management and error handling. You have more
    power over the system now, but remember: great power comes with great responsibility!'
  prefs: []
  type: TYPE_NORMAL
- en: Let me start with an example. This showcases the power of .NET Framework, but
    it also shows how the aforementioned steps work in practice. We are going to do
    a simple “Hello World.”
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure we’re on the same page, let me show you the .NET version of this
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Console.WriteLine(“Hello,` `System Programmers!”);`'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, this is the same sample we saw earlier. Hey, we have to start somewhere,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: Now, `Console` is a class from the BCL. It has a static method, `WriteLine`,
    that outputs that string to the output. But what if we assume we don’t want to
    use that class? How should we go about this then? To frame this question another
    way, how does `WriteLine` work internally? After all, there has to be a point
    somewhere during execution where the code has to call the Win32 API. That can
    be done by the CLR or by us, but something or someone has to call it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite the code using P/Invoke. I will show you the entire program first,
    then dissect it and explain how it works line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That’s a lot of code, but let’s go through it.
  prefs: []
  type: TYPE_NORMAL
- en: In *line 1*, we import the namespace that allows us to use P/Invoke. .NET uses
    the name `InteropServices` for this, so it makes sense to import that.
  prefs: []
  type: TYPE_NORMAL
- en: In *line 3*, we see the magic happening. Remember the steps we have to take?
    *Step 1* is to “Find the API you want to use.” Since we want to print something
    on the screen, the `WriteConsole` API sounds like a good fit.
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation from Microsoft states that the `WriteConsole` API
    “*Writes a character string to a console screen buffer beginning at the current
    cursor location.*” That sounds good to me.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation then gives us the signature of this API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you’re a .NET developer, this might look weird. A lot is going on that we
    don’t know about or understand. We need to translate those types into something
    the CLR understands. Luckily, somebody has already figured that out for us. To
    make life even easier, they did *Steps 2* (find the DLL) and *4* (declare the
    stub) for us as well. Given the correct parameters, the CLR takes care of *Step
    3* (load the DLL).
  prefs: []
  type: TYPE_NORMAL
- en: That “someone who figured this out” is the people behind [https://pinvoke.net](https://pinvoke.net).
    You can search for APIs and learn how to use them there.
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation has a part called `Kernel32.dll` (`Pinvoke.Net` also
    gives you that information).
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 3* is what tells `InteropServices` to load the DLL. Let’s dive into that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This line tells the CLR to load `kernel32.dll`. It then specifies how to handle
    characters. Characters and strings can be complicated. There are several different
    ways to represent a single character. It can be an ASCII character, it can be
    Unicode, or it can be ANSI. They all have a different representation in memory.
    Here, we say we want to use `Auto`. When doing that, the system looks at the complete
    string we use, finds out which set it can use to represent the complete string,
    and uses the first one it can find. Since it starts by trying to fit it in an
    ASCII string and then “moves up” toward more complicated, slower, and more memory-intensive
    ways, this guarantees we get the best way to represent this string.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can see `SetLastError = true`. This instructs the system to inform
    us whenever something goes wrong. In case of an error, it calls the `GetLastError`
    API to get the error and return it to us. We will use this a lot later. For now,
    I advise you to always set `SetLastError` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our runtime now knows to load `kernel32.dll`. But we must tell it what specific
    API we want to use. That happens in the following line. The function’s signature
    must always follow that `DllImport` directly: they always belong together. If
    you want to load multiple functions from the same Dll, you must still use `DllImport`
    for each.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line is the stub for the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This looks like the code we saw from the official documentation, but now, the
    types have been translated into their .NET equivalents. Again, `Pinvoke.Net` is
    your friend here!
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are more or less self-explanatory, except for the first one.
    Let’s skip that one and look at the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **String lpBuffer** | **The string we want** **to print** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| nNumberOfCharsToWrite | The number of characters we want to print from the
    given string |'
  prefs: []
  type: TYPE_TB
- en: '| lpNumberOfCharsWritten | How many characters were written to the system |'
  prefs: []
  type: TYPE_TB
- en: '| lpReserved | This isn’t used, so it can be ignored |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.1: Parameters for WriteConsole'
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to notice here is that Win32 APIs use the Hungarian notation for
    their parameters. This style says you have to prefix every parameter with an abbreviation
    of the type so that when you read the code later, you know what type this stands
    for. In the days before the current modern and fast IDEs, this helped a lot: you
    couldn’t hover your mouse over a variable to see what type it was; you had to
    scroll through the code to find the declaration. By prefixing it, you could see
    it immediately. These days, we don’t need to do that anymore, but C and C++ developers
    still use this standard.'
  prefs: []
  type: TYPE_NORMAL
- en: So, as you can see, the string to print is a long pointer (lp), and the number
    of characters to write is a number (n).
  prefs: []
  type: TYPE_NORMAL
- en: But let’s have a look at `hConsoleOutput`. It is a handle (it starts with h),
    which translates it into `IntPtr` in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: A pointer is just an address of something in memory. In our case, this memory
    belongs to the place where the console is. But how do we get that? Where is the
    code that controls `Console`, which is located in memory?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we don’t know. There is no fixed place; this can and will
    change every time you restart your program. So, we need to look for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, that isn’t that hard to do as there’s an API we can use to do so.
    This API is called `GetStdHandle` and it lives in `kernel32.dll`. We know how
    to import that, and we can see it in our code on *lines 11* and *12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are no strings, so we don’t need to set `CharSet`. However, we do need
    to set `SetLastError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method to find the address is called `GetStdHandle`, and it takes one parameter:
    `nStdHandle`. This tells this API what type of Console we are looking for. There
    are three types available: `STD_INPUT_HANDLE, STD_OUTPUT_HANDLE`, and `STD_ERROR_HANDLE`.
    These three constants have -10, -11, and -12 as values, respectively. You’re right
    if you think it’s strange that they’re negative values. It’s weird. However, in
    Win32, these values are unsigned. They are the end of the integer range, so they
    don’t get in the way of any other types of console you might define yourself.
    Casting a high value of an unsigned int to a signed int results in a negative
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On *line 14*, we define the `STD_OUTPUT_HANDLE` constant and give it a value
    of `-11`. This sort of thing is common: the Win32 API is a mess with magic numbers
    and constants.'
  prefs: []
  type: TYPE_NORMAL
- en: On *line 16*, we use `GetStdHandle` to get the pointer to `Console` in memory,
    giving it `STD_OUTPUT_HANDLE`. If that goes wrong, we get a 0 (zero) back. But
    since .NET is strongly typed, we cannot use that number. Instead, we have to use
    the `IntPtr.Zero` constant, which is the same thing but in the correct type.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you get a 0 back from a Win32 API, you have an error situation going
    on. We need to deal with that, but that is a topic for later.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming all goes well, we can define our string, and the `out` variable tells
    us how many characters are written (*lines 23* and *24*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, on *line 26*, we call the actual API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This should be clear now. We call the API, give it the correct parameters, and
    check if the result is `0` (`IntPtr.Zero`).
  prefs: []
  type: TYPE_NORMAL
- en: The CLR converts the complex .NET `String` type into a simple array of bytes
    with a 0 at the end. We don’t have to worry about that. We can give this API a
    C# string and everything will work out fine.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it. We have written something to the console using Win32 APIs!
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous examples, we did a little bit of error checking. If we couldn’t
    get the handle, we showed a message. We did the same thing if we couldn’t write
    to the console. I realize it’s funny to write to the console that the system cannot
    write to it (look at *line 33*, for instance), but you get what I mean here.
  prefs: []
  type: TYPE_NORMAL
- en: But this isn’t good enough if you want to know what’s going on for real. We
    need a more thorough way of handling errors.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, we are used to getting exceptions whenever things go wrong. We know
    how to deal with that. In the low-level world, things are different. When something
    goes wrong, we get `0` back, and we’re left to deal with it. We could continue
    with the code without being bothered by the error. We could even ignore the results
    of a call to an API. However, that would lead to disaster. You should always check
    and deal with the results of an API call. How to deal with that is something we
    discuss in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a low-level API called `GetLastError` that can help us out here. The
    signature for P/Invoke is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It seems pretty straightforward. There are no parameters to worry about, and
    we don’t have to set that `SetLastError` value here. Since `SetLastError` ensures
    that any error is saved in the registry so that `GetLastError` can read it, there’s
    no value in having that here. If there would be, and we set it to false, then
    how does `GetLastError` work?
  prefs: []
  type: TYPE_NORMAL
- en: This function returns an unsigned integer. This number corresponds with an error;
    you can look up what that number means in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s an issue: it doesn’t work. Well, it does, but there are no guarantees
    regarding the result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BCL and the `CLR` work with the low-level Win32 APIs constantly. That is
    obvious: the BCL is a wrapper around the Win32 API, and the CLR uses that wrapper
    to call into the core system of the operating system. We can call the APIs ourselves,
    as we have just done, but the CLR also calls it. Sometimes, it does it in the
    same thread. Other times, it calls it on another thread. Things can also go wrong
    during the CLR calls to the APIs. That results in `GetLastError` possibly returning
    no errors or the wrong errors. Well, technically, they aren’t the wrong errors,
    but they might not have to do anything with what we’re doing.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the designers of .NET have thought about that and have added a class
    called `Marshal` to the `System.Runtime.InteropServices` namespace. That class
    is used to marshal between managed and unmanaged code – or, to put it in the context
    of what we are doing here, between Win32 APIs and our C# .NET code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume we made a mistake. I know that’s hard to imagine but bear with
    me here. Instead of assigning `-11` to `STD_OUTPUT_HANDLE`, we set it to `11`.
    We all make mistakes, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'We then call `GetStdHandle` with `11`. That isn’t correct; we know that. The
    documentation says that the function returns `0` (or `IntPtr.Zero` in C#) if anything
    goes wrong. But in our case, it returns something else: `0xffffffffffffffff`.
    This is the unsigned version of the signed value, `-1`. In other words, the call
    to the API returns `-1`, which is not a valid handle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we don’t check that. We only check for the `0` value. This makes sense
    if you think about it. After all, `0` indicates something went wrong when calling
    that function. That didn’t happen: the function worked flawlessly. It just didn’t
    find anything matching the ID we gave it (`11` instead of `-11`). So, as far as
    the API is concerned, there are no errors.'
  prefs: []
  type: TYPE_NORMAL
- en: But then we get to the point where we call `WriteConsole`. We give it the handle
    of the console – or rather, we think we do. Instead, we give it a value of `-1`
    (`0xffffffffffffffff`). That is not a valid handle that `WriteConsole` can work
    with.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET you would get an exception, but that doesn’t happen here. The code continues
    happily without complaining. It just doesn’t output anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'These errors can be a pain to find and solve. In this case, it is quite straightforward,
    but imagine a situation where you try to set up a connection to an infrared receiver
    and something goes wrong. However, we keep going since we don’t check for that
    result. By the time we are ready to send data, nothing happens – or worse, the
    system crashes. We start to look at the code that does the actual sending, but
    nothing is wrong there. It takes much time and careful debugging to see that the
    error happens when we set up the connection. Let me repeat something I said earlier:
    you should always check the results of all API calls. That burden is on you. The
    .NET runtime generates exceptions in these cases, but if you are in unmanaged
    land, you are responsible for doing so.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s improve our code a bit.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll wrap our call to `WriteConsole` in a `try-catch` block and just
    catch `Exception`, although that is generally a bad idea. However, here, this
    is good enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `WriteConsole` returns `IntPtr.Zero`, we have a problem and something goes
    wrong. In an unmanaged environment, you would call `GetLastError` to see what
    happens, but that doesn’t work here. Instead, we use that `Marshal` class I spoke
    about earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When running this with `STD_OUTPUT_HANDLE` set to `11`, the system reports that
    something went wrong. It even tells us that the error code is `6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking this up in the official documentation results in the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: ERROR_INVALID_HANDLE
  prefs: []
  type: TYPE_NORMAL
- en: 6 (0x6)
  prefs: []
  type: TYPE_NORMAL
- en: The handle is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: This is precisely what’s going on.
  prefs: []
  type: TYPE_NORMAL
- en: “Wait a minute,” I can almost hear you say. “I can’t ask my users to look up
    the official documentation to see what an error message means every time something
    goes wrong!”
  prefs: []
  type: TYPE_NORMAL
- en: Well, you’ve got a point there. And the .NET design team agrees. They’ve added
    some ways to get that error message. There are two ways to get it, and you can
    choose which one you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if you want to have that error message, you can get it with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Again, we start by getting the error code. We always have to do this, and we
    should do it as quickly as possible before another error somewhere else messes
    things up.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we call the `Marshal.GetPInvokeErrorMessage` method and give it that `lastError`
    code. It returns a string telling us `The handle` `is invalid.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Nice. But what if this error is so impactful that we cannot continue? .NET
    tells us to use exceptions in those cases. Good practice teaches us never to throw
    an exception but to use a specialized derived exception. We have just the right
    thing for that: `Win32Exception`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could throw that and set the message to the message we got from `GetPInvokeErrorMessage`,
    but since that is such a common scenario, .NET Framework gives us a shortcut to
    do just so. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks a lot better. This code results in a message on our screen stating
    `Error: The handle is invalid`. Okay, since this is just a simple example, I fail
    to properly deal with the issue (a rethrow would be a good idea here). How you
    continue after such an error depends on your coding style, your use case, and
    what you want to achieve.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one other way to get the error message. This one is quite nice but
    not as straightforward as the others we’ve discussed: `FormatMessage`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FormatMessage` function comes from the Win32 API. Its declaration is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have an error code, we can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create `StringBuilder`. The API uses this to build up the string
    with the error message. We give it a size of `256` characters. This size should
    be enough for most, if not all, errors. We need to give this size since in C and
    C++, you need to allocate a buffer beforehand; it cannot expand dynamically (well,
    it could, but you wouldn’t do that if you want high performance). We call `FormatMessage`
    with the 0x00001000 flag. This flag means “use the error code provided.” We can
    use other flags, but this one is used most of the time. We don’t have a message
    we want to format, so the second parameter is `IntPtr.Zero`. Then, we give it
    `lastError`, 0 for the language (that is, the system default, usually English),
    the buffer, the size of the buffer, and another `IntPtr.Zero` parameter. This
    last one means we don’t use arguments. Here, arguments are the same as what we
    have in C# when we want to format a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, `42` is the argument.
  prefs: []
  type: TYPE_NORMAL
- en: We get that same “The handle is invalid” message when we run this.
  prefs: []
  type: TYPE_NORMAL
- en: You might want to use this API because it can do some nice tricks. For instance,
    replace `languageId` code 0 with the code 0x0413\. This `languageId` is the Windows
    language ID for Dutch (please use whatever language you want.)
  prefs: []
  type: TYPE_NORMAL
- en: The result is `De ingang is ongeldig`, which is more or less a good translation
    of the original error.
  prefs: []
  type: TYPE_NORMAL
- en: This way, you can have nicely formatted, translated error messages!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one last thing to cover here: many samples online use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Technically, there’s nothing wrong with this. But this isn’t why exceptions
    are there. Creating one just to get the message is wrong. However, I have seen
    this so many times that I thought I should warn you against it. If you don’t want
    to throw an exception, don’t create one. In that case, call `Marshal.GetPInvokeErrorMessage`
    instead. You will do yourself and those maintaining your code a huge favor.
  prefs: []
  type: TYPE_NORMAL
- en: Issues when debugging code with low-level APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with low-level APIs such as the Win32 API opens up a treasure trove
    of new and powerful tools. However, it comes with a couple of downsides. Debugging
    your code suddenly gets a lot harder, and it also becomes more critical.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of areas you need to be aware of when you want to debug
    your code using low-level APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility and portability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation and community support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these can pose a challenge, requiring you to think about your debugging
    strategy before you start coding. Let’s go through the potential issues.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, you’re responsible for error handling when using low-level
    APIs. You don’t get exceptions from the functions you call when something goes
    wrong. You always have to be careful to check the return code of the calling code
    to see if it is 0\. And even then, there is no guarantee that things work out
    as you expected. For instance, the call to `GetStdHandle` worked fine when we
    gave it an invalid type of `ConsoleId`, but the result was still not what we expected.
    You have to be very careful with these kinds of calls. Ideally, we would have
    caught that problem immediately and informed the system that something went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you catch all the error codes, that doesn’t mean you can identify what
    went wrong. Sometimes, the error messages are so cryptic that you must read the
    documentation to see what’s happening.
  prefs: []
  type: TYPE_NORMAL
- en: There is a method in the API called `CoCreateInstance`. It deals with creating
    COM objects, which you use to connect to other systems, such as Word or Excel.
    To make that connection, give it the ID of the object you want to connect to.
    Those IDs are in the form of GUIDs, and you have to type them in. If there ever
    were a situation where it is easy to get things wrong, this would be it.
  prefs: []
  type: TYPE_NORMAL
- en: Using a non-existing `ClassID` returns an error code of `0x80004005`. If we
    use the methods described previously to get the error message, you would expect
    to read something like `Invalid ClassId` or `COM Object not found`. Unfortunately,
    what you get is `E_FAIL:` `Unspecified error`.
  prefs: []
  type: TYPE_NORMAL
- en: Sigh.
  prefs: []
  type: TYPE_NORMAL
- en: That isn’t helpful at all, is it? It failed. Okay, we got that. But why? What
    failed? We don’t know. The system doesn’t help you here at all. You have to know
    what you’re doing and what the system expects and go through every single line
    of the code to spot the error. That’s not easy.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve discussed, one of the steps you must take when calling Win32 APIs is
    to translate the types used in C# into their Win32 equivalents and vice versa.
    Sometimes, that’s easy; sometimes, it can be pretty challenging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The framework designers did a lot to help us: when the Win32 API expects a
    string, you can usually give it a C# string, and the CLR marshals the type back
    and forth without you even knowing it. But still, there is some marshaling going
    on. A C-style string is a pointer to a place in memory where a character sits.
    The next character is next to it, and so on, until the system finds a value of
    0\. That is the end-of-string marker. This is entirely different from the `String`
    class we have in C# (internally, the `String` class still has that list of characters
    ending with 0 somewhere, but we never see that, so we can pretend it isn’t there
    at all).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most types in C# have a sibling in Win32\. Here’s a list of the most used types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **C# Type** | **Win32 Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | `BYTE` | 8-bit unsigned integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `sbyte` | `CHAR` | 8-bit signed integer, typically used for ASCII characters.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | `SHORT` | 16-bit signed integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `ushort` | `WORD` | 16-bit unsigned integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `INT` or `LONG` | 32-bit signed integer |'
  prefs: []
  type: TYPE_TB
- en: '| `uint` | `UINT` or `DWORD` | 32-bit unsigned integer. Also used for flags
    and enumerations. |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `LONGLONG` | 64-bit signed integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `ulong` | `ULONGLONG` | 64-bit unsigned integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `FLOAT` | 32-bit floating-point number. |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `DOUBLE` | 64-bit floating-point number. |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | `WCHAR` or `TCHAR` | 16-bit Unicode character in C#, whereas `WCHAR`/`TCHAR`
    varies in Win32. |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `BOOL` | Boolean type. `True` or `False` in C#, and typically `TRUE`
    or `FALSE` in Win32\. Here, `FALSE` is defined as `0`, whereas `TRUE` is defined
    as `NOT FALSE`, meaning any other value, but usually, it is `1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `IntPtr` | `HANDLE`, `HINSTANCE`, `HWND`, and so on | Represents a pointer
    or a handle. The type varies on context. |'
  prefs: []
  type: TYPE_TB
- en: '| `UIntPtr` | Rarely used in Win32 | An unsigned pointer or handle. |'
  prefs: []
  type: TYPE_TB
- en: '| `T[]` | `T*` or `SAFEARRAY` | An array of the `T` type. Its representation
    depends on the context in Win32. |'
  prefs: []
  type: TYPE_TB
- en: '| `DateTime` | `FILETIME` or `SYSTEMTIME` | Represents Date and Time. Representation
    varies in Win32. |'
  prefs: []
  type: TYPE_TB
- en: '| `Guid` | `GUID` or `UUID` | GUID. 128-bit number. (GUID is usually tied to
    Windows platforms, while UUID is found on other platforms. They are basically
    the same, though.) |'
  prefs: []
  type: TYPE_TB
- en: '| `TimeSpan` | Typically represented by a combination of `DWORDs` | A time
    interval. This is not available on Win32. |'
  prefs: []
  type: TYPE_TB
- en: 'Table1.2: C# and Win32 types'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, most types can easily be translated between the platforms. When
    we dive into the more complex types, things get a bit more complicated since a
    lot of them are dependent on context or implementation. This makes marshaling
    types between the platforms a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to consider is something called calling convention. A calling
    convention defines how to handle parameters when calling a function. The two most
    common types are `stdcall` and `cdecl`. Win32 APIs usually use `stdcall`, while
    most other C libraries expect `cdecl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I won’t dive too deep into these two calling conventions. However, let’s summarize
    the most important differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stdcall`: The callee cleans the stack. It has a fixed number of arguments
    and it is commonly used in the Windows API. Here, function names usually get decorated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cdecl`: The caller cleans the stack and allows variable-length argument lists.
    It is commonly used in the C standard library. Here, function names aren’t decorated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, knowing how to call a function is essential. The wrong convention
    can mess up the stack, and the arguments are passed to the function or return
    the wrong results. You could even mess up the memory, which is almost unheard
    of when writing managed code.
  prefs: []
  type: TYPE_NORMAL
- en: When you don’t specify the calling convention, `stdcall` is assumed. You should
    give the correct calling convention if you need to call another library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe an example would help here. We used `WriteConsole` to write to the console
    earlier, but there is a much easier way: the `printf` function. This function
    is part of the C runtime in the Microsoft `msvcrt.dll` library. If you want to
    use this function, import it with the now well-known `DllImport` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since this function is not part of the Win32 API but instead resides in a separate
    DLL, you must be careful and specify the correct calling convention. Here, we
    need to use `cdecl`, which we can specify by setting `CallingConvention =` `CallingConvention.Cdecl`.
  prefs: []
  type: TYPE_NORMAL
- en: Other types include `WinAPI`, `StdCall` (they are basically the same), `ThisCall`,
    and `FastCall`. You will hardly ever encounter the last two, but at least you
    have heard of them now.
  prefs: []
  type: TYPE_NORMAL
- en: When you call an API and get weird errors or unexpected behavior, you might
    want to look into how to marshal the types or the calling conventions. The system
    doesn’t help you here by giving you good error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio Debugger is awesome. However, when mixing managed with unmanaged
    code, things might get tricky. If something goes wrong, the system might halt
    and show you a breakpoint. But since the code that’s being called is not C#, the
    debugger might not show you what you need to see. It tries its best, so it will
    probably disassemble the code and show you the assembly code that is at fault.
  prefs: []
  type: TYPE_NORMAL
- en: I showed you some assembly code at the beginning of this chapter. That isn’t
    something you might want to see if you want to find errors in your code. Well,
    I don’t know if that applies to you, but I certainly don’t want to see that.
  prefs: []
  type: TYPE_NORMAL
- en: If that happens, you might want to use other debuggers, such as WinDbg. Later
    in this book, when we cover debugging, we take a closer look at this tool. But
    trust me, debugging mixed code is no walk in the park.
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility and portability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Windows changes. Sometimes, it changes a lot; sometimes, the changes are subtle.
    Although Microsoft is known for trying to keep things backward compatible as much
    as possible, sometimes, APIs change. The signature might change, or the behavior
    might change. And you only find out about that when things go horribly wrong.
    Again, you see very few exceptions or error messages, so you’re left to debug
    the code and step through it.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you start using Win32 APIs, you are tying yourself to a limited set
    of devices and platforms you can use.
  prefs: []
  type: TYPE_NORMAL
- en: And don’t even think about deploying the preceding code to a Linux platform.
    Sure, .NET runs fine on Linux, but not when you start using P/Invoke. And it might
    be that your code runs fine on one edition of Windows but breaks horribly on the
    next one that comes out of Redmond. We could call that “job security” since it
    will require us to update our code now and then, but I wouldn’t go as far as calling
    it fun.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation and community support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary audience for the documentation of the Win32 API is C and C++ developers.
    As a C# developer, it is hard to find the information needed. Sites such as [https://pinvoke.net](https://pinvoke.net)
    help, but only if you know how they work.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation of third-party DLLs you might want to use as a .NET developer
    is even harder to find. Sometimes, you must inspect a DLL, see how it works internally,
    and then translate it into the proper DLL import statement. If you do that, ensure
    you have the correct calling convention and types!
  prefs: []
  type: TYPE_NORMAL
- en: 'Community support when mixing managed and unmanaged code is also a challenge.
    Most developers fall into one of two camps: they work in the unmanaged world or
    they work in the managed world. Doing both is very rare.'
  prefs: []
  type: TYPE_NORMAL
- en: Good developers who can do both are scarce. The good news is that by reading
    this book, you are on the right path to becoming one of that very elite group!
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter looked at the difference between low-level and high-level APIs.
    We dove into the foundations of .NET by examining the BCL and CLR. Then, we examined
    how to call into low-level APIs such as the Win32 API. We did that by reimplementing
    the ubiquitous `Console.WriteLine` into code that the Windows operating system
    can run without using the BCL. That led us to discuss error discovery and error
    handling, and how to best go about them.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the issues you might encounter when you start doing that sort
    of coding. We mentioned the differences in type systems and the issues you might
    have when dealing with debuggers.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this chapter has made you appreciate the .NET Framework and the hard
    work the BCL and CLR do for you as a developer. But I also hope you realize the
    power you get when using the Win32 API or other third-party libraries written
    in C or C++.
  prefs: []
  type: TYPE_NORMAL
- en: System programming relies heavily on these techniques. Although using these
    APIs ties you to the operating system you’re developing for or even a specific
    version of that system, this is often the only way to achieve your results. And
    to be honest, I think working with these APIs is fun. It is all about getting
    back to the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Working with low-level APIs can be challenging. They can lead to a lot of hard-to-solve
    errors. But when used correctly, they can lead to better performance in your code.
    When writing system software, that is very important. As discussed previously,
    system software should not get in the way of the user or the systems the user
    directly interacts with. Instead, it should be as fast as possible. So, using
    the correct APIs might give you just that extra performance you need. I think
    this is so important that I wrote a complete chapter on performance, which happens
    to be the next chapter. We were born to run, so let’s run as fast as possible
    to the next part!
  prefs: []
  type: TYPE_NORMAL
