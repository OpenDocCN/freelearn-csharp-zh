<html><head></head><body>
		<div id="_idContainer018">
			<h1 id="_idParaDest-66" class="chapter-number"><a id="_idTextAnchor095"/>3</h1>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor096"/>Pure Functions and Side Effects</h1>
			<p>Welcome to <a href="B21069_03.xhtml#_idTextAnchor095"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>! Here, we’ll dive deep into the world of pure functions in C#. This chapter is all about helping you understand the concept of pure functions, their practical application, and how to use them effectively in <span class="No-Break">your code.</span></p>
			<p>Here’s a quick breakdown of what <span class="No-Break">to expect:</span></p>
			<ul>
				<li>Understanding <span class="No-Break">pure functions</span></li>
				<li><span class="No-Break">Side effects</span></li>
				<li>Strategies to minimize <span class="No-Break">side effects</span></li>
				<li>Marking pure functions with the <span class="No-Break"><strong class="source-inline">Pure</strong></span><span class="No-Break"> attribute</span></li>
			</ul>
			<p>As you move through the content, keep an eye out for actionable insights and data-driven recommendations. Approach this chapter with an eagerness to learn; by the end, you’ll have a solid foundation to write efficient and clean <span class="No-Break">C# programs.</span></p>
			<p>As I recommended in the previous chapter, I propose that you check your level of knowledge and look at the following three tasks. If you have any doubts about how to solve them, it is better to read this chapter right now. And if you are 100% sure that you can solve them with your eyes closed, maybe it will be more beneficial to proceed with the less familiar topics for now. Let’s jump <span class="No-Break">right in!</span></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor097"/>Task 1 – Refactoring to a pure function</h1>
			<p>Steve’s tower <a id="_idIndexMarker125"/>defense game calculates damage based on a global difficulty modifier. Refactor this function to make <span class="No-Break">it pure:</span></p>
			<pre class="source-code">
public double _difficultyModifier = 1.0;
public double CalculateDamage(Tower tower, Enemy enemy)
{
     return tower.BaseDamage * enemy.DamageMultiplier * _difficultyModifier;
}<a id="_idTextAnchor098"/></pre>			<h1 id="_idParaDest-69"><a id="_idTextAnchor099"/>Task 2 – Isolating side effects</h1>
			<p>The game <a id="_idIndexMarker126"/>loads enemy data from a file, processes it, and updates the game state. Refactor this function to isolate its <span class="No-Break">side effects:</span></p>
			<pre class="source-code">
public void LoadAndProcessEnemyData(string filePath)
{
     string jsonData = File.ReadAllText(filePath);
     List&lt;Enemy&gt; enemies = JsonConvert.DeserializeObject&lt;List&lt;Enemy&gt;&gt;(jsonData);
     foreach (var enemy in enemies)
     {
                  enemy.Health *= GameState.DifficultyLevel;
                  GameState.ActiveEnemies.Add(enemy);
     }
     Console.WriteLine($"Loaded {enemies.Count} enemies");
<a id="_idTextAnchor100"/>}</pre>			<h1 id="_idParaDest-70"><a id="_idTextAnchor101"/>Task 3 – Using a Pure attribute</h1>
			<p>Refactor the <a id="_idIndexMarker127"/>following method by making it a pure function and marking it with the <span class="No-Break"><strong class="source-inline">Pure</strong></span><span class="No-Break"> attribute:</span></p>
			<pre class="source-code">
public string GenerateEnemyCode(string enemyType, int level)
{
     var code = enemyType.Substring(0, 3) + level.ToString();
     return new string(code.OrderBy(c =&gt; c).ToArray());
}</pre>			<p>If these tasks are easy, you might want to consider reading topics that are new to you first. If you have any questions or are not sure about the correct answers, don’t worry – next, we’ll dive into the concept of pure functions and side effects while using the characters from <a id="_idIndexMarker128"/>the previous chapter – Julia <span class="No-Break">and Steve.</span></p>
			<p>A week later, Julia called Steve and said that if he wanted to continue learning functional programming, he needed to understand the logic of pure functions and <span class="No-Break">side effects.</span></p>
			<p>Julia: <em class="italic">Pure functions are functions that have deterministic output and no observable side effects – in other words, no actions happen outside the given scope of a function. This makes them predictable and easy to test, as well as key attributes for efficient software development. In C# code, we do this through the use of immutability and keywords such as </em><strong class="source-inline">readonly</strong><em class="italic">, </em><strong class="source-inline">const</strong><em class="italic">, and </em><strong class="source-inline">static</strong><em class="italic">. Also, there is a special attribute for marking </em><span class="No-Break"><em class="italic">pure functions.</em></span></p>
			<p>Steve: <em class="italic">Wow! This is all very exciting, but I don’t understand any of it. Could you give me something to read </em><span class="No-Break"><em class="italic">about it?</em></span></p>
			<p>Julia gave him articles and Steve began <span class="No-Break">to re<a id="_idTextAnchor102"/>ad.</span></p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor103"/>Understanding pure functions</h1>
			<p>Pure functions <a id="_idIndexMarker129"/>are important in functional programming. They have two <span class="No-Break">main features:</span></p>
			<ul>
				<li><strong class="bold">Deterministic output</strong>: For <a id="_idIndexMarker130"/>any given input, a pure function will always yield the same output, making its behavior extremely predictable. This characteristic simplifies the process of testing and debugging since the output of the function is always consistent given the same set <span class="No-Break">of inputs.</span></li>
				<li><strong class="bold">No observable side effects</strong>: A pure function does not influence or is influenced <a id="_idIndexMarker131"/>by an external state. This means it doesn’t modify any external variables or data structures, or even carry out I/O operations. The function’s sole effect is the computation it performs and the result <span class="No-Break">it delivers.</span></li>
			</ul>
			<p>These two properties make pure functions similar to mathematical functions. A mathematical function, <em class="italic">f(x) = y</em>, produces a result, <em class="italic">y</em>, that relies solely on the input, <em class="italic">x</em>, and doesn’t alter or is altered by anything outside of the function. In programming, a pure function can be seen as a self-contained unit that transforms input into output without any interference from or to the <span class="No-Break">external world.</span></p>
			<p>By adhering to these properties, pure functions facilitate the creation of code that is more robust, maintainable, and less prone to bugs. Let’s examine these benefits and practical examples of pure <span class="No-Break">functions fu<a id="_idTextAnchor104"/>rther.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor105"/>Examples of pure functions</h2>
			<p>Consider <a id="_idIndexMarker132"/>a function that determines how many books need to be printed to reach <span class="No-Break">a target:</span></p>
			<pre class="source-code">
public static int BooksNeededToReachTarget(int currentPrintCount, int targetPrintCount)
{
    return targetPrintCount - currentPrintCount;
}</pre>			<p>This function always gives the same result with the same inputs and doesn’t change anything outside <span class="No-Break">of it.</span></p>
			<p>Another example can be filtering out books of a <span class="No-Break">particular genre:</span></p>
			<pre class="source-code">
public static List&lt;string&gt; GetTitlesOfGenre(List&lt;Book&gt; books, string genre)
{
    return books.Where(b =&gt; b.Genre == genre).Select(b =&gt; b.Title).ToList();
}</pre>			<p>This function <a id="_idIndexMarker133"/>is also pure. If you give it the same list of books, it will always return the same list <span class="No-Break">of<a id="_idTextAnchor106"/> titles.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor107"/>The benefits of pure functions</h2>
			<p>Pure <a id="_idIndexMarker134"/>functions offer several <span class="No-Break">significant advantages:</span></p>
			<ul>
				<li><strong class="bold">Predictability and ease of testing</strong>: Due to their deterministic nature, pure functions are highly predictable, making it easy to write unit tests. You always know what output to expect for a specific input, and there’s no need to mock or set up external dependencies <span class="No-Break">for testing.</span></li>
				<li><strong class="bold">Code reusability and modularity</strong>: Pure functions, when designed to focus on a specific task in line with the single-responsibility principle, become highly reusable. As they don’t depend on external states, you can move these functions without worrying about breaking the code or enhancing <span class="No-Break">its modularity.</span></li>
				<li><strong class="bold">Ease of debugging and maintenance</strong>: Without shared state or side effects, debugging pure functions is just a breeze. If there’s an issue, it’s usually within the function itself, making it easy to spot and fix. The isolation of pure functions also facilitates maintenance and updates as you can change a function without affecting other parts of <span class="No-Break">y<a id="_idTextAnchor108"/>our code.</span></li>
			</ul>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor109"/>Comparisons of pure functions and non-pure functions</h2>
			<p>When <a id="_idIndexMarker135"/>analyzing pure functions alongside non-pure <a id="_idIndexMarker136"/>functions, the strengths and weaknesses of each become evident. To illustrate, let’s examine Konstatos’ tower defense mobile game as an example. In this game, different units take different amounts of damage from towers based on their defense against each type of tower. Each unit class can have a dictionary that contains these <span class="No-Break">damage changes:</span></p>
			<pre class="source-code">
private static Dictionary&lt;TowerType, double&gt; _damageModifiers = new Dictionary&lt;TowerType, double&gt;
{
    {TowerType.Cannon, 0.8},  // Takes 20% less damage from cannon towers
    {TowerType.Laser, 0.9}   // Takes 10% less damage from laser towers
};</pre>			<p>To figure <a id="_idIndexMarker137"/>out the damage a tower does to a unit, the <a id="_idIndexMarker138"/>unit class has a function that looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public double CalculateDamageFromTower(Tower tower)
{
    return tower.BaseDamage * _damageModifiers[tower.Type];
}</pre>			<p>At first, you might think this function is pure. But because it uses the <strong class="source-inline">_damageModifiers</strong> variable, which can change, the output can also change, even if the input stays the same. This means the function depends on something outside of it, which isn’t good for pure functions. This can lead to mistakes and makes testing and fixing <span class="No-Break">problems harder.</span></p>
			<p>Here’s how we can make the <span class="No-Break">function pure:</span></p>
			<pre class="source-code">
public double CalculateDamageFromTower(Tower tower, Dictionary&lt;TowerType, double&gt; damageModifiers)
{
    return tower.BaseDamage * damageModifiers[tower.Type];
}</pre>			<p>Now, by giving <strong class="source-inline">damageModifiers</strong> directly to the function, it doesn’t depend on anything outside of it. This means that if you give it the same input, you’ll always get the <span class="No-Break">same output.</span></p>
			<p>You might be wondering if it makes sense to give a dictionary to a function when the function can already see it. That’s a fair point. But doing it this way means the function doesn’t secretly rely on something other than its parameters, which makes our code cleaner and easier to <span class="No-Break">work with.</span></p>
			<p>Understanding <a id="_idIndexMarker139"/>the distinctions between these <a id="_idIndexMarker140"/>two types of functions and prioritizing the use of pure functions can enhance your code’s quality. As you delve deeper into functional programming in C#, this understanding will prove invaluable. Up next, we’ll discuss side effects in <span class="No-Break">function<a id="_idTextAnchor110"/>al programming.</span></p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor111"/>Side effects</h1>
			<p>While working on his tower defense game, Steve noticed some unexpected behavior. Units were <a id="_idIndexMarker141"/>taking inconsistent damage from towers. After some investigation, he realized the damage calculation function relied on a global variable that could change unpredictably - a classic <span class="No-Break">side effect.</span></p>
			<p>Side effects in programming refer to any application state changes that occur outside the function being executed. These changes could include modifying a global or static variable, changing the original value of function parameters, performing I/O operations, or even throwing an exception. Side effects make the behavior of a function dependent on the context, reducing predictability and potentially <a id="_idTextAnchor112"/><span class="No-Break">increasing bugs.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor113"/>Common sources of side effects</h2>
			<p>When <a id="_idIndexMarker142"/>writing code, it’s good to know where side effects <a id="_idIndexMarker143"/>might come from. Side effects can make code unpredictable. Let’s break down so<a id="_idTextAnchor114"/>me <span class="No-Break">common sources.</span></p>
			<h3>Global variables</h3>
			<p>Problem: Using <a id="_idIndexMarker144"/>global variables can lead <a id="_idIndexMarker145"/>to unexpected changes. If a function changes a global variable, it can affect other parts of <span class="No-Break">your program:</span></p>
			<pre class="source-code">
public static Dictionary&lt;string, int&gt; UserScores = new Dictionary&lt;string, int&gt;();
public static int UpdateUserScore(string userName, int scoreToAdd)
{
    if (UserScores.ContainsKey(userName))
    {
        UserScores[userName] += scoreToAdd;
    }
    else
    {
        UserScores[userName] = scoreToAdd;
    }
    return UserScores[userName];
}</pre>			<p><strong class="source-inline">UpdateUserScore</strong> changes the <strong class="source-inline">UserScores</strong> dictionary. Since this dictionary is accessible <a id="_idIndexMarker146"/>everywhere, other functions might also change it. This makes <a id="_idIndexMarker147"/>our <span class="No-Break">function unpredictable.</span></p>
			<p>Solution: Instead of global variables, it’s better to use function arguments or put the state inside objects. For example, here, as we did before, it is better to pass the dictionary as a parameter to <a id="_idTextAnchor115"/>eliminate <span class="No-Break">the problem.</span></p>
			<h3>The out and ref parameters</h3>
			<p>Problem: Using <strong class="source-inline">out</strong> and <strong class="source-inline">ref</strong> in C# can <a id="_idIndexMarker148"/>change <a id="_idIndexMarker149"/>the original data <a id="_idIndexMarker150"/>that’s <a id="_idIndexMarker151"/>given to <span class="No-Break">a function:</span></p>
			<pre class="source-code">
public static void UpgradeTower(ref Tower tower, int level)
{
    tower = new Tower();
    tower.Damage = level * 10;
    tower.Hitpoints = level * 150;
}</pre>			<p>The <strong class="source-inline">UpgradeTower</strong> method not only updates the <strong class="source-inline">Damage</strong> and <strong class="source-inline">Hitpoints</strong> values but also <a id="_idIndexMarker152"/>changes the reference so that it no longer points to the original <strong class="source-inline">Tower</strong> object. Of course, it is almost impossible to see code like this in real life; usually, it isn’t so straightforward and is hidden inside other methods. This code is a simplified <a id="_idIndexMarker153"/>and slightly ugly version <a id="_idIndexMarker154"/>of real code to show you the idea <a id="_idIndexMarker155"/>behind using <span class="No-Break"><strong class="source-inline">ref</strong></span><span class="No-Break"> parameters.</span></p>
			<p>Solution: Instead <a id="_idIndexMarker156"/>of changing the data, it’s a good idea to return a new value. Here, we could rename the method to <strong class="source-inline">GetLeveledUpTower</strong> <a id="_idTextAnchor116"/>and make it return a <span class="No-Break">new tower.</span></p>
			<h3>I/O operations</h3>
			<p>Problem: Doing <a id="_idIndexMarker157"/>things such as saving <a id="_idIndexMarker158"/>to a file or a database will change data outside <span class="No-Break">your function:</span></p>
			<pre class="source-code">
public void SaveGameProgressToFile(string progressData, string filePath)
{
    File.WriteAllText(filePath, progressData);
}</pre>			<p>The <strong class="source-inline">SaveGameProgressToFile</strong> function saves game progress data to a file. This kind of <a id="_idIndexMarker159"/>action can fail if, for example, there’s no space left on the disk. So, it’s a side effect because it relies on something outside <span class="No-Break">our function.</span></p>
			<p>Solution: It’s helpful to keep logic separate from actions such as saving data. This makes the code<a id="_idTextAnchor117"/> clearer and easier <span class="No-Break">to understand.</span></p>
			<h3>Exception handling</h3>
			<p>Problem: Consider <a id="_idIndexMarker160"/>a function that <a id="_idIndexMarker161"/>calculates the damage dealt by <span class="No-Break">a tower:</span></p>
			<pre class="source-code">
public static double CalculateDamage(Tower tower, Unit unit)
{
    if (tower == null || unit == null)
    {
        throw new ArgumentException("The tower or unit is null.");
    }
    return tower.Damage * unit.DefenseModifier;
}</pre>			<p>The <strong class="source-inline">CalculateDamage</strong> function throws an exception if the tower or unit is <strong class="source-inline">null</strong>. Throwing an exception changes the regular flow of our program. If not handled, it can terminate <a id="_idIndexMarker162"/>the application or lead to <span class="No-Break">unexpected behavior.</span></p>
			<p>Solution: The best way to go here is to use the <strong class="source-inline">Either</strong> monad. However, before we discuss it, you can use a nullable type <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">double?</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public static double? CalculateDamage(Tower tower, Unit unit)
{
    if (tower == null || unit == null)
    {
        return null;
    }
    return  tower.Damage * unit.DefenseModifier;
}</pre>			<p>With this <strong class="source-inline">CalculateDamage</strong> method, if the tower or unit is <strong class="source-inline">null</strong>, the method returns <strong class="source-inline">null</strong>; otherwise, it calculates the damage and returns it. This way, we avoid the side effect <a id="_idIndexMarker163"/>of breaking the flow with exceptions for common scenarios. However, the code that uses this method must be also modified so that it can handle <a id="_idIndexMarker164"/>the situation when <strong class="source-inline">null</strong> <span class="No-Break">is returned.</span></p>
			<p>Knowing how exceptions can be a source of side effects helps in making design choices that keep ou<a id="_idTextAnchor118"/>r C# code clearer and <span class="No-Break">more predictable.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor119"/>Consequences of side effects</h2>
			<p>The presence <a id="_idIndexMarker165"/>of side effects in your code can lead to <span class="No-Break">various issues:</span></p>
			<ul>
				<li><strong class="bold">Decreased predictability</strong>: Functions with side effects are less predictable because their output can change based on the external state. This decreased predictability makes it harder to understand what a function does just by looking <span class="No-Break">at it.</span></li>
				<li><strong class="bold">Increased difficulty in testing and debugging</strong>: Functions with side effects are harder to test since they require the correct external state to produce the expected result. Debugging is also more complex because an issue in the function c<a id="_idTextAnchor120"/>ould be due to an external <span class="No-Break">state change.</span></li>
				<li><strong class="bold">Concurrency issues</strong>: Concurrency problems can arise when multiple threads access and modify shared state simultaneously, leading to <span class="No-Break">unexpected results.</span></li>
			</ul>
			<p>Although it might not look instantly bad, with time, these consequences tend to snowball, making your project <a id="_idTextAnchor121"/>very expensive to develop <span class="No-Break">and support.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor122"/>Strategies to minimize side effects</h1>
			<p>While side <a id="_idIndexMarker166"/>effects in real-world applications are unavoidable, the key is to control and isolate them to make your code more manageable and predictable. This section focuses on strategies to minimize side effects by using <strong class="source-inline">readonl<a id="_idTextAnchor123"/>y</strong>, <strong class="source-inline">const</strong>, <strong class="source-inline">static</strong>, and immutability <span class="No-Break">in C#.</span></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor124"/>Favor immutability</h2>
			<p>Immutability is a powerful way to minimize side effects. Immutable objects are objects whose state <a id="_idIndexMarker167"/>can’t be changed after they’re created. In C#, strings are a prime example of immutability. Every operation on a string results in a new string, and the original string remains unchanged. This principle can be expanded to other <span class="No-Break">data types:</span></p>
			<pre class="source-code">
     Book originalBook = new Book("The Clean Coder", "Uncle Bob");
    /* Create a new book instance with the same title but a different author */
    Book updatedBook = originalBook with { Author = "Robert C. Martin" };
    // We can see that both copies exist
    Console.WriteLine(originalBook);
    Console.WriteLine(updatedBook);</pre>			<p>In this code snippet, <strong class="source-inline">originalBook</strong> is created as an instance of <strong class="source-inline">Book</strong> with a specific title and author and <strong class="source-inline">updatedBook</strong> is a new instance of <strong class="source-inline">Book</strong> that was created using the <strong class="source-inline">with</strong> expression. The <strong class="source-inline">with</strong> expression is used to create a new record with some properties modified from an existing record. Here, it creates a new <strong class="source-inline">Book</strong> value with the same <strong class="source-inline">Title</strong> value as <strong class="source-inline">originalBook</strong> but with <strong class="source-inline">Author</strong> set to <strong class="source-inline">"Robert </strong><span class="No-Break"><strong class="source-inline">C. Martin"</strong></span><span class="No-Break">.</span></p>
			<p>This approach maintains immutability because <strong class="source-inline">originalBook</strong> remains unchanged, and any<a id="_idTextAnchor125"/> “modification” results in a <span class="No-Break">new instance.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor126"/>Use readonly and const</h2>
			<p><strong class="source-inline">readonly</strong> and <strong class="source-inline">const</strong> are two keywords in C# that can make your fields and variables unchangeable, thereby reducing the potential for <span class="No-Break">side effects.</span></p>
			<p><strong class="source-inline">const</strong> variables <a id="_idIndexMarker168"/>are implicitly static and should be <a id="_idIndexMarker169"/>used when the value is known at compile time and will <span class="No-Break">never change:</span></p>
			<pre class="source-code">
public const string PublishingHouseName = "Progressive Publishers";</pre>			<p>On the other hand, <strong class="source-inline">readonly</strong> variables can be either instance-level or static, and their values can be set at runtime (for instance, inside constructors), but not <span class="No-Break">changed afterward:</span></p>
			<pre class="source-code">
p<a id="_idTextAnchor127"/>ublic readonly string Isbn = GenerateIsbn();</pre>			<h2 id="_idParaDest-81"><a id="_idTextAnchor128"/>Use functional programming principles</h2>
			<p>Functional programming principles are designed to help minimize side effects. Besides pure <a id="_idIndexMarker170"/>functions and immutability, principles such as expressions over statements, the use of higher-order functions, and function composition can also aid in this mission. While we are already acquainted with the former, higher-order functions and function composition will be discussed in later chapters. So, let’s just keep moving – applying these principles can greatly enhance the pre<a id="_idTextAnchor129"/>dictability and maintainability of <span class="No-Break">your code.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor130"/>Encapsulate side effects</h2>
			<p>When side <a id="_idIndexMarker171"/>effects are unavoidable, it’s crucial to isolate them. For instance, if a function must write to a file, that should be its sole responsibility. All other logic should be separated into pure functions as much as possible. This way, the side effects are contained, and the rest of your code <span class="No-Break">remains unaffected:</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B21069_03_001.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>The idea here is to isolate side effects, making them predictable, visible, <span class="No-Break">and manageable.</span></p>
			<p>Strategies to <a id="_idIndexMarker172"/>minimize side effects are key to building reliable, efficient, and maintainable software. By implementing these strategies, we inch closer to the functional programming paradigm, harnessing its strengths <span class="No-Break">and benefits.</span></p>
			<p>Next, we’ll discuss how to <a id="_idTextAnchor131"/>use the <strong class="source-inline">Pure</strong> attribute to mark <span class="No-Break">pure functions.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor132"/>Marking pure functions with the Pure attribute</h1>
			<p>Understanding the role of pure functions and side effects in our code is crucial for effective <a id="_idIndexMarker173"/>functional programming in C#. But how <a id="_idIndexMarker174"/>do we communicate our intent that a function should be pure? T<a id="_idTextAnchor133"/>his is where the <strong class="source-inline">Pure</strong> attribute comes <span class="No-Break">into play.</span></p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor134"/>Understanding the Pure attribute in C#</h2>
			<p>In C#, the <strong class="source-inline">Pure</strong> attribute <a id="_idIndexMarker175"/>is defined in the <strong class="source-inline">System.Diagnostics.Contracts</strong> namespace and serves as a declarative tag to indicate that a method is pure. A pure method is one that, given the same inputs, will always return the same output and does not produce any observable <span class="No-Break">side effects.</span></p>
			<p>It’s important to note that the <strong class="source-inline">Pure</strong> attribute is primarily intended for use in code contracts and static checking tools. The runtime and compiler don’t enforce the purity of a method, and this attribute does not change the method’s behavior in <span class="No-Break">any way:</span></p>
			<pre class="source-code">
[Pure]
public static decimal CalculateRoyalty(decimal bookPrice, decimal royaltyPercent)
{
    return bookPrice * royaltyPercent / 100;
}</pre>			<p>In this <a id="_idIndexMarker176"/>example, we have a function that calculates the royalty amount for a book based on its price and the royalty percentage. It’s a pure function since it always returns the same output for the same i<a id="_idTextAnchor135"/>nput and doesn’t have any observable <span class="No-Break">side effects.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor136"/>The benefits of marking functions as pure</h2>
			<p>Marking <a id="_idIndexMarker177"/>functions as pure using the <strong class="source-inline">Pure</strong> attribute brings <span class="No-Break">several benefits:</span></p>
			<ul>
				<li><strong class="bold">Clarity and intention</strong>: By marking a function as pure, you communicate your intention to other developers that this function should <span class="No-Break">remain side-effect-free</span></li>
				<li><strong class="bold">Tooling support</strong>: Some static analysis tools can use the <strong class="source-inline">Pure</strong> attribute to help identify potential issues in <span class="No-Break">your code</span></li>
				<li><strong class="bold">Optimization opportunities</strong>: While the C# compiler doesn’t currently take advantage of this, in some languages and scenarios, knowing that a function i<a id="_idTextAnchor137"/>s pure can enable additional <span class="No-Break">compiler optimizations</span></li>
			</ul>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor138"/>Caveats and considerations when using the Pure attribute</h2>
			<p>When <a id="_idIndexMarker178"/>marking functions as pure, keep the following points <span class="No-Break">in mind:</span></p>
			<ul>
				<li><strong class="bold">It does not enforce purity</strong>: As mentioned previously, the <strong class="source-inline">Pure</strong> attribute does not enforce purity. You can mark a method as pure, and it can still have side effects. The attribute is more of a communication and <span class="No-Break">analysis tool.</span></li>
				<li><strong class="bold">Pure cannot be used with void methods</strong>: Since a pure function should return a result, the <strong class="source-inline">Pure</strong> attribute cannot be used with <span class="No-Break">void methods.</span></li>
				<li><strong class="bold">Pure does not affect runtime behavior</strong>: The <strong class="source-inline">Pure</strong> attribute has no impact on the method’s runtime behavior. It’s mainly used by ce<a id="_idTextAnchor139"/>rtain static analysis tools, such as <span class="No-Break">code contracts.</span></li>
			</ul>
			<p>By marking <a id="_idIndexMarker179"/>your functions with the <strong class="source-inline">Pure</strong> attribute, you make a promise about your function’s behavior, helping others (and tools) understand your code better. However, it’s crucial to remember that the attribute is a tool, not a panacea. The responsibility for ensuring a function’s purity still lies primarily with <span class="No-Break">the developer.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor140"/>Exercises</h1>
			<p>To test Steve’s understanding, Julia presented him with three coding challenges related to pure functions and side effects. “These exercises will help solidify the concepts,” she explained. “Give t<a id="_idTextAnchor141"/>hem a try and let me know if you have <span class="No-Break">any questions.”</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor142"/>Exercise 1</h2>
			<p>Steve’s tower defense game calculates damage based on a global difficulty modifier. Refactor this function to make <span class="No-Break">it pure:</span></p>
			<pre class="source-code">
public static double difficultyModifier = 1.0;
public double CalculateDamage(Tower tower, Enemy enemy)
{
     return tower.BaseDa<a id="_idTextAnchor143"/>mage * enemy.DamageMultiplier * difficultyModifier;
}</pre>			<h2 id="_idParaDest-89"><a id="_idTextAnchor144"/>Exercise 2</h2>
			<p>Steve’s game loads enemy data from a file, processes it, and updates the game state. Refactor this function to isolate its <span class="No-Break">side effects:</span></p>
			<pre class="source-code">
public void LoadAndProcessEnemyData(string filePath)
{
     string jsonData = File.ReadAllText(filePath);
     List&lt;Enemy&gt; enemies = JsonConvert.DeserializeObject&lt;List&lt;Enemy&gt;&gt;(jsonData);
     foreach (var enemy in enemies)
     {
                  enemy.Health *= GameState.DifficultyLevel;
                  GameState.ActiveEnemies.Add(enemy);
     }
     Co<a id="_idTextAnchor145"/>nsole.WriteLine($"Loaded {enemies.Count} enemies");
}</pre>			<h2 id="_idParaDest-90"><a id="_idTextAnchor146"/>Exercise 3</h2>
			<p>Refactor the following method by making it a pure function and marking it with the <span class="No-Break"><strong class="source-inline">Pure</strong></span><span class="No-Break"> attribute:</span></p>
			<pre class="source-code">
public string GenerateEnemyCode(string enemyType, int level)
{
     var code = enemyType.Substring(0, 3) + level.ToString();
     return new string(code.OrderBy(c =&gt; c).ToArray());
}</pre>			<p>These exercises should help solidify your understanding of the concepts we’ve covered. Keep practicing, keep experimenting, and remember – every line of code you write is a step forward on your journey to mastering functional programming <span class="No-Break">in C#.</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor147"/>Solutions</h1>
			<p>Her<a id="_idTextAnchor148"/>e are the solutions to the exercises in <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor149"/>Exercise 1</h2>
			<p>A pure function should not depend on or modify any state outside its scope. So, instead of relying on the global <strong class="source-inline">difficultyModifier</strong> value, we should pass it as <span class="No-Break">a parameter:</span></p>
			<pre class="source-code">
[Pure]
public double CalculateDamage(Tower tower, Enemy enemy, double difficultyModifier)
{
     return tower.BaseDa<a id="_idTextAnchor150"/>mage * enemy.DamageMultiplier * difficultyModifier;
}</pre>			<h2 id="_idParaDest-93"><a id="_idTextAnchor151"/>Exercise 2</h2>
			<p>To isolate side effects, we’ll separate the pure logic from the I/O operations and <span class="No-Break">state mutations:</span></p>
			<pre class="source-code">
public interface IFileReader
{
     string ReadAllText(string filePath);
}
public interface IEnemyRepository
{
     void AddEnemies(IEnumerable&lt;Enemy&gt; enemies);
}
public interface ILogger
{
     void Log(string message);
}
public class EnemyProcessor
{
     private readonly IFileReader _fileReader;
     private readonly IEnemyRepository _enemyRepository;
     private readonly ILogger _logger;
     public EnemyProcessor(IFileReader fileReader, IEnemyRepository enemyRepository, ILogger logger)
     {
              _fileReader = fileReader;
              _enemyRepository = enemyRepository;
              _logger = logger;
     }
     public void LoadAndProcessEnemyData(string filePath, double difficultyLevel)
     {
              string jsonData = _fileReader.ReadAllText(filePath);
              List&lt;Enemy&gt; enemies = DeserializeEnemies(jsonData);
              List&lt;Enemy&gt; processedEnemies = AdjustEnemyHealth(enemies, difficultyLevel);
              _enemyRepository.AddEnemies(processedEnemies);
              _logger.Log($"Loaded {processedEnemies.Count} enemies");
     }
     [Pure]
     private List&lt;Enemy&gt; DeserializeEnemies(string jsonData)
     {
         return JsonConvert.DeserializeObject&lt;List&lt;Enemy&gt;&gt;(jsonData);
     }
     [Pure]
     private List&lt;Enemy&gt; AdjustEnemyHealth(List&lt;Enemy&gt; enemies, double difficultyLevel)
     {
              return enemies.Select(e =&gt; new Enemy
              {
                       Health = e.Health * difficultyLevel,
                  // Copy ot<a id="_idTextAnchor152"/>her properties...
              }).ToList();
     }
}</pre>			<h2 id="_idParaDest-94"><a id="_idTextAnchor153"/>Exercise 3</h2>
			<p>This one is a bit tricky because the function is already pure. All we need to do is add the <strong class="source-inline">Pure</strong> attribute to communicate that intention to other developers and <span class="No-Break">analysis tools:</span></p>
			<pre class="source-code">
[Pure]
public string GenerateEnemyCode(string enemyType, int level)
{
     var code = enemyType.Substring(0, 3) + level.ToString();
     return new string(code.OrderBy(c =&gt; c).ToArray());
}</pre>			<p>These solutions adhere to the principles of functional programming, ensuring<a id="_idTextAnchor154"/> minimized side effects and clarity of <span class="No-Break">code behavior.</span></p>
			<p>With that, let’s cover some dos and don’ts for <a id="_idTextAnchor155"/>utilizing pure functions and minimizing <span class="No-Break">side effects.</span></p>
			<p>These are <span class="No-Break">the dos:</span></p>
			<ul>
				<li>Strive to write more pure functions as they’re predictable and straightforward to understand <span class="No-Break">and test</span></li>
				<li>Isolate side effects – that is, keep them separate from <span class="No-Break">pure code</span></li>
				<li>Use <strong class="source-inline">readonly</strong>, <strong class="source-inline">const</strong>, and <strong class="source-inline">static</strong> modifiers to promote immutability and reduce <span class="No-Break">side effects</span></li>
				<li>Use the <strong class="source-inline">Pure</strong> attribute to communicate intent, aiding in code analysis <span class="No-Break">and maintainability</span></li>
			</ul>
			<p>These are <span class="No-Break">the don’ts:</span></p>
			<ul>
				<li>Overuse global state as it leads to high coupling and increases the risk of <span class="No-Break">side effects.</span></li>
				<li>Modify inputs inside a function. This alteration can lead to <span class="No-Break">unexpected behavior.</span></li>
				<li>Forget that the <strong class="source-inline">Pure</strong> attribute doesn’t enforce purity. It’s a promise that the developer needs <span class="No-Break">to fulfill.</span></li>
				<li>Ignore the context. Sometime<a id="_idTextAnchor156"/>s, a non-pure function can provide a <span class="No-Break">better solution.</span></li>
			</ul>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor157"/>Summary</h1>
			<p>Diving into the world of functional programming in C# has been a stimulating journey, and we’re only just getting started. In this chapter, we explored the pivotal concepts of pure functions and side effects and their respective roles in writing cleaner, more predictable, and maintainable code. Let’s reinforce the knowledge we’ve gained and map out the course <span class="No-Break">moving forward.</span></p>
			<p>Pure functions stand as a beacon of certainty in the unpredictable universe of software. They have a clear-cut contract – the same input always yields the same output, and they remain uninvolved with the state outside their scope. This simplicity makes them predictable, easy to test, and more amenable to parallelization <span class="No-Break">and optimization.</span></p>
			<p>However, the real world is filled with side effects – reading and writing to a database, calling an API, modifying a global variable – the list goes on. Side effects are inevitable, but when uncontrolled, they can unleash chaos, making the code hard to reason about and test. To mitigate this problem in functional programming, we must wrap pure functions with impure code, thus protecting them from having <span class="No-Break">side effects.</span></p>
			<p>In the next chapter, we will talk about a new type of function – honest functions. We’ll talk about what are they, how to use them in C#, and what danger nullable references <span class="No-Break">can bring.</span></p>
		</div>
	</body></html>