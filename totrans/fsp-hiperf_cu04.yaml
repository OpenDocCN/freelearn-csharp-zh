- en: Chapter 4. Introduction to Concurrency in F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance optimizations are not just about understanding the underlying platform,
    profiling, toolings and measurements, and data structures. Now, with the rising
    trend of multicore processors and at the same time, the increasing needs of responsive
    applications to be achieved as and when required, concurrency is not just becoming
    more relevant but also a necessary requirement across all kinds of enterprise
    applications, especially applications across all full stacks of layers of multi-tier
    architecture applications.
  prefs: []
  type: TYPE_NORMAL
- en: It is also evident that concurrency is one of those performance optimizations
    that are often misunderstood. Some common misunderstood samples have already been
    described in [Chapter 1](fsp-hiperf_cu01.html#aid-E9OE2 "Chapter 1. Performing
    Common Optimizations in F#"), *Performing Common Optimizations in F#*. In this
    chapter, we will focus on concurrency features in F# and also get to know the
    basic strategy behind the deciding factor of the actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the background reasoning for the chosen strategy, first we must
    get to know the features of concurrency in F# especially in F# 4.0\. There is
    no noticeable difference between F# 3.0 and F# 4.0 in terms of the existing concurrency
    features. There are F# 4.0 additional features to have interop with .NET Task
    Parallel Library, as these interop features will be explained in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Having a knowledge of measurement tooling, covered in [Chapter 2](fsp-hiperf_cu02.html#aid-K0RQ2
    "Chapter 2. Performance Measurement"), *Performance Measurement*, qualitative
    knowledge of the mechanism of running F# code (the IL, tooling, and the GC), and
    having quantitative measures (the execution durations using timers and unit tests)
    are requirements in order to easily understand the importance of concurrency and
    the decisive factor of choosing the right concurrent model.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will see that there is no silver bullet for all
    kinds of concurrency problems. For example, using only parallel computation to
    handle I/O operations is not recommended because I/O operation is a good sample
    of a blocking thread. However, it is also important to identify which threads
    or processes are blocking threads. Combining this with asynchronous computation
    is recommended. Also, there is not a single concurrency feature that cannot be
    combined with other kinds of concurrency features, as will be introduced in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter gives a gentle overview of the concurrency features of F#, focusing
    on F# 4.0\. We will also provide an overview of the best practices to implement
    and optimize it. Advanced topics of concurrency optimizations in F#, such as combining
    asynchrony and parallelism, the F# message passing agent, `MailboxProcessor`,
    and further interop with .NET TPL, will be described in [Chapter 5](fsp-hiperf_cu05.html#aid-164MG2
    "Chapter 5. Advanced Concurrency Support in F#"), *Advanced Concurrency Support
    in F#*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing concurrency support in F# 4.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying blocking threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing asynchronous workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing concurrency support in F# 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is important to have concurrency support from the programming language perspective,
    especially as built-in language features. In F#, concurrency support in F# was
    available before F# 4.0\. Two of the concurrency features: the asynchronous workflow
    and `MailboxProcessor` have been available since F# 1.9.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a quick overview, F# has the following concurrency features:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous message passing using actor model and an F# special class that
    functions as an agent for message passing, `MailboxProcessor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel programming support for asynchronous workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interop with .NET Task Parallel Library (TPL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous workflow is actually an implementation of a computation expression
    that is escalated as syntactic sugar. It is escalated within a block of asynchronous
    code that has calls to asynchronous functions, marked in the beginning with `async`
    as keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the perspective of conceptual concurrency, it is quite intuitive and easier
    to understand that F# has support for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous concurrency**: in `async` and `MailboxProcessor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel concurrency**: parallel supports in asynchronous workflow and interop
    with .NET TPL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the supports is not a static solution for a single problem; for example,
    `MailboxProcessor` can be combined with parallel concurrency as well. It is also
    quite common to combine `MailboxProcessor` with async workflow, and then execute
    it in parallel as well.
  prefs: []
  type: TYPE_NORMAL
- en: There is no comparable built-in asynchronous message passing support in other
    languages such as C#/VB in the release of Visual Studio 2015\. Even in .NET BCL,
    there is no message passing agent implementation at all. Some known message passing
    agents are available from outside .NET BCL, in the form of message passing combined
    with the actor model. Usually, they come in the form of a NuGet package available
    for download or in the form of a commercialized class library.
  prefs: []
  type: TYPE_NORMAL
- en: The discussion on the best practices and usage of `MailboxProcessor` will be
    discussed in [Chapter 5](fsp-hiperf_cu05.html#aid-164MG2 "Chapter 5. Advanced
    Concurrency Support in F#"), *Advanced Concurrency Support in F#*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a known actor-based library of concurrency that comes from Microsoft
    Research; it is called Orleans. It is open source but it is unfortunately only
    optimized for cloud development and deployment especially in Azure. For more information
    about Orleans, visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/](https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/)'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, F# concurrency can be used and implemented in accordance with the
    other languages as well, as long as it's based on a common version of .NET CLR.
    We could also leverage the async-await model of C#/VB into the F# async workflow.
  prefs: []
  type: TYPE_NORMAL
- en: To use and to have interop with asynchronous methods in the .NET Framework that
    are designed for other asynchronous models with the F# asynchronous programming
    model, you create a function that returns an F# `async` object. The F# library
    has functions that make this easy to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the implementation detail, F# concurrency support has the following building
    blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Control.Async<''T>**: This is a type in the `Microsoft.FSharp.Control` namespace
    to contain asynchronous operation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The Control.Async**: This is a class in the `Microsoft.FSharp.Control` namespace
    that contains all of the supports for asynchronous operations, support for .NET
    TPL, and for executing asynchronous workflow in parallel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Control.AsyncBuilder**: This is a builder class in `Microsoft.FSharp.Control`,
    to construct F# asynchronous workflow, including the implementation of `let!`
    and `use!` for containing the result of asynchronous operations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**F# asynchronous primitives**: These are classes that may extend the existing
    .NET BCL with methods that implement F# asynchronous workflow, such as the `Control.WebExtension`
    and `Control.CommonExtension` modules. Both of them are in the `Microsoft.FSharp.Control`
    namespace.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To further illustrate the relations, all of the asynchronous types, parallel
    types, and builders for asynchronous workflow are concentrated under the `Microsoft.FSharp.Control`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hierarchical illustration is as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing concurrency support in F# 4](img/image00288.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: F# asynchronous primitives are called **asynchronous primitives** because they
    perform a single asynchronous task and return the result.
  prefs: []
  type: TYPE_NORMAL
- en: It is quite common that asynchronous workflow is often used to handle blocking
    threads. Whether we are aware of the existence of blocking threads or not, it
    is very important to know the traits or characteristics the blocking threads have
    and not just to understand the definitions of a blocking thread.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying blocking threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A thread, from the perspective of interactions with other threads, is divided
    into two kinds: *non-blocking thread* and *blocking thread*. A non-blocking thread
    is usually a thread that does not block any other thread.'
  prefs: []
  type: TYPE_NORMAL
- en: A blocking thread means a thread that does operations that often force the execution
    context to wait for other *operations*. By nature, in this context of operations,
    there can be many kinds of operations and interactions with other kinds of subsystem
    components such as I/O and CPU thread counter such as the operation performed
    in `System.Threading.Thread.Sleep`.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the background technical reasons for the blocking nature of I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I/O is never separated from the implementation and usage of our application,
    especially applications that deal with networking and sending commands to an output
    device outside the scope of the subsystem, such as printers. It is often ignored,
    but it is becoming relevant that as a running application is expected to be as
    responsive as possible, the nature of any I/O operation cannot be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: I/O operations have a tendency to force us to wait, although this wait should
    be treated as being placed in a different execution context rather than in the
    current thread. This is why the concept of having asynchronous operations is more
    relevant as the wait should not be synchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Then why are I/O operations really *blocking threads*?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following sample facts/scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: You send I/O commands to a printer (with the data) to print some data (usually,
    any kind of data formats supported by the underlying OS). There is no guarantee
    that the printer is always turned ON or that the printer is not busy. There can
    also be some forms of latency that we cannot control directly, such as network
    latency when transferring commands and data to be printed. Even when you are connecting
    your machine directly to the printer, there is no guarantee that the printer is
    always on and ready to process your commands. For example, your machine might
    have other running background processes that deal with other I/O, such as hard
    disks, especially when performing virus scans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You send HTTP requests on a host that you have tested with a ping before. There
    is no guarantee that at the time of sending the HTTP requests, the destination
    host is still available or that the host is even ready to process your requests
    and return responses. If the host is available and ready to process your requests,
    you cannot control exactly how quickly the destination host would reply with responses
    and how responsive it would be. Again, network latency also plays a huge role
    in dealing with roundtrips of HTTP request-response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple ping to any other host is also an I/O operation in action. Again, there
    is no guarantee that the destination host will respond to your ping (usually in
    ICMP packets).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are performing defragmentation on your local hard disk and expecting to
    do something else. Even with most of the Windows or other modern OSes such as
    Linux's distributions with latest kernel, there is no guarantee that you won't
    have to wait for the defragmentation to finish completely or that you can do other
    operations without interruptions from the defragmentation operations. Normally,
    you should not interrupt or even interfere with the current intentional I/O operations
    such as storage defragmentation. This is often misunderstood by a common computer
    user as bugs, although it is defragmentation that is obviously impacting storage
    as I/O. Therefore, it should not be considered as a bug in our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on the preceding common facts, these I/O operations all have one thing
    in common: *we have to wait*. It also clearly defines that I/O operation is one
    sample of a side-effect because we cannot control it fully and it is out of the
    scope of the current execution thread of our code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The conclusion is obvious and quite clear: any I/O operation must be considered
    as a blocking thread.'
  prefs: []
  type: TYPE_NORMAL
- en: These side effects should not be considered as bugs based on the nature of the
    operations running out of the scope boundary of the execution, but any errors,
    especially exceptions that might have occurred, must be handled. In other terms,
    these side effects must not be ignored and cannot be treated in a normal synchronous
    way because we have to wait for them to complete.
  prefs: []
  type: TYPE_NORMAL
- en: The best practices of exception handling (including the details when dealing
    with concurrency problems) will be discussed in detail in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1
    "Chapter 7. Language Features and Constructs Optimization"), *Language Features
    and Constructs Optimization*.
  prefs: []
  type: TYPE_NORMAL
- en: It is easier to summarize blocking threads as part of operations that are also
    considered as blocking threads, such as I/O operations described previously.
  prefs: []
  type: TYPE_NORMAL
- en: Obvious trait of a blocking thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a simple definition, a blocking thread is part of any operation or function
    that *waits for an event to occur or a time period to elapse*. While a blocking
    call is waiting, the operating system can often remove that thread from the scheduler,
    so it takes no CPU time until the event has occurred or the time has elapsed.
    Once the event has occurred, then the thread is placed back in the scheduler and
    can run when allocated a time slice.
  prefs: []
  type: TYPE_NORMAL
- en: It seems quite difficult to relate with I/O, but all I/O operations again always
    have a waitable behavior and can always be considered as blocking operations.
    This is not just a strong sample of a side effect. The operations that require
    us to wait are also available in other kinds of operations, especially if the
    operations are doing many things either in a definite amount of time or indefinite
    amount of time. We can parallelize this, but there is always a limited amount
    of computations available as opposed to the nature of most applications that usually
    do not care about this.
  prefs: []
  type: TYPE_NORMAL
- en: The context of waitable operations is the source of inspiration for the introduction
    of TPL in .NET 4.0, especially to define any task that is waitable as identified
    by the async-await pattern and the `TaskAwaiter` implementation. All of these
    waitable tasks can be used in asynchronous blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is also in sync with the C# 4 and VB 10 releases: the async models leverage
    these waitable patterns by enforcing all the tasks to be awaitable, wrapped in
    an awaiter of `TaskAwaiter`.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, you cannot always consider that your application will always run
    using the fastest CPU with many cores. Any assumption that your application will
    run successfully in many cores without paying attention to how you treat the concurrent
    running of your application can slow down your application performance.
  prefs: []
  type: TYPE_NORMAL
- en: Any successful enterprise application must be able to scale itself in a sense
    that it must consider that the number of users of the application can grow and
    that the operations they will engage when they use the applications can be arbitrarily
    complex. Therefore, paying attention to how the code will run across many CPU
    cores and also paying attention to the responsiveness of the application, especially
    paying attention to any blocking operations, are requirements, not just recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: It also brings a more interesting fact that it is easier to get used to identifying
    blocking threads by identifying blocking operations first. Identifying blocking
    threads first is also a good practice to have a best practice mindset because
    we often misunderstand blocking threads as non-blocking threads due to common
    assumptions that applications usually running in modern CPUs are always fast by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: The context of *does not block any other thread* is often misunderstood. A thread
    can block other threads even if it was considered a non-blocking thread. For example,
    a very intensive computation that requires CPU-intensive operations, such as complex
    number-related calculations that are targeted for a specific CPU core, can block
    other threads that want to use any available core if the other core might be busy
    processing other calculations or processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this sample illustrated scenario running on the 4th generation of
    Intel core i5 that has two physical cores:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obvious trait of a blocking thread](img/image00289.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The details of the scenario are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The running code runs on a machine that has the 4^(th) generation of Intel core
    i5 processor. This processor has two physical cores and each core has two hyper-threading
    units.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The running code (it acts as a process under the runtime context) asks to run
    on the 1^(st) core explicitly, so it assumes that the remaining core (in this
    case, only one core) should be available for others.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then the other process suddenly runs in the background, and it needs a high
    thread affinity, for example, processes by antivirus software. Most antivirus
    software always try to ask for a higher thread affinity when they are scheduled
    to run a full scan at a scheduled time. Another sample is when a Windows update
    is performing a background installation update after it has finished downloading
    all of the updates available at the time the code runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these other processes, therefore, are cramped into only one core, and
    they can interfere with each other so that one process may take over the entire
    CPU core cycle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on this scenario, a blocking thread can be caused by non I/O operations
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is quite important to know or to keep up with the latest of x86/x64 processors
    as we should never assume that our code runs automatically in parallel, although
    we must not rely on the number of actual physical cores. It is also closely related
    to paying more attention to concurrency because the trends for the last 6 years
    have been leaning toward having more cores instead of having a higher speed of
    CPU clock. The intention here is clear: *the awareness that concurrency is increasingly
    more relevant as the age of multicores outweigh the free increase of higher-speed
    CPUs*.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also a strong evidence that *free lunch is over*, stated by Herb Sutter
    (we first mentioned this article in [Chapter 1](fsp-hiperf_cu01.html#aid-E9OE2
    "Chapter 1. Performing Common Optimizations in F#"), *Performing Common Optimizations
    in F#*), is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, this book is not going to describe the full characteristic details
    of Intel or AMD processors because it is outside the scope of this F# book.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the full specifications of Intel processors, please
    consult [http://ark.intel.com/](http://ark.intel.com/).
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the specifications of AMD, please consult [http://www.amd.com/en-us/products/processors/desktop](http://www.amd.com/en-us/products/processors/desktop).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are other processors supported by .NET, but most processors today are
    dominated by Intel and AMD. A sample of this is ARM, powering some WinRT machines
    for Windows 8 and Windows 8.1 tablets and Microsoft's own tablet, Surface. The
    ARM architecture is different from that of Intel and AMD, although it has multiple
    cores as well, and the market share for these processor-based devices is also
    very small. It can be safely assumed that since the introduction of Visual Studio
    2015, the target processor architecture is for x86 and x64 only, unless you are
    targeting other kind of devices, such as mobile phones.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic knowledge of what a blocking thread is, the next challenge
    is whether we have to wait and not do anything else or whether *we can do other
    things while waiting*. Doing other things while waiting is actually an implementation
    of the asynchronous way. It is conceptually the same as the restaurant waiting
    problem we had visited in [Chapter 1](fsp-hiperf_cu01.html#aid-E9OE2 "Chapter 1. Performing
    Common Optimizations in F#"), *Performing Common Optimizations in F#*.
  prefs: []
  type: TYPE_NORMAL
- en: F# provides support for implementing asynchronous operations using asynchronous
    workflow without any complexity of having callback implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing asynchronous workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous support in F# is implemented nicely using async workflow computations.
  prefs: []
  type: TYPE_NORMAL
- en: The initial release of F# 1.0 did not have it. Asynchronous workflow was introduced
    in F# 1.9.2.9, and it is categorized as a workflow because it is actually an implementation
    of a computation expression (builder) that is escalated as a language block of
    `async`. It is also a good sample of a best practice in implementing function
    compositions and in expressively implementing **Monad**. Monad is one of the functional
    composition implementations, an idea taken from or inspired by the category theory
    knowledge domain.
  prefs: []
  type: TYPE_NORMAL
- en: Function composition is actually a composition of computation operations; they
    can be functions or composite statements such as for loop constructs. It is also
    quite intuitive, and it's also easier to use as the necessary detailed composition
    operations are hidden. Usually, there is a `bind` operator to compose two functions
    (or computations).
  prefs: []
  type: TYPE_NORMAL
- en: 'The foundational theory of this is quite common, back to the world of set theory.
    Set theory is further extended in Category theory where composition is more emphasized
    between functions. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f => f(x)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*g => g(x)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*f o g = f(g(x))*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the *f o g* is read as *f circle g* where *circle* is the composition
    between the functions *f* and *g*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually the composition in a Monad is expressed by the `bind` operator, symbolized
    as *>>=* in many other functional programming languages such as Haskell. This
    composition of a function also implies that the return type of *g* must be the
    same as the type of the parameter of *f*. From the perspective of real-world functional
    programming, type safety is always enforced even though the type is not mentioned.
    Everything will always be inferred based on the type inference of the function's
    return type and the result of the currying functions.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in workflows in F# are not just limited to the asynchronous workflow;
    there are Sequence and LINQ query workflows as well.
  prefs: []
  type: TYPE_NORMAL
- en: In asynchronous workflow, there is a `bind` builder (it is conceptually similar
    to bind in Monad) implemented to compose operations, but the implementation is
    hidden by the syntax of the `let!` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation and optimization of a builder in F# to compose a workflow
    will be further discussed in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language
    Features and Constructs Optimization"), *Language Features and Constructs Optimization*.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of F# computation expressions is also called a workflow because
    it usually defines the compositions of functions as the results of binding (`bind`)
    operations and control flows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goals of F# asynchronous workflow are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Increase responsiveness by not blocking the running thread and get the other
    process done first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ease programming in asynchronous concurrency without worrying about callback
    and explicit continuations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intuitively, the code flows more naturally because the flow is not looking like
    going back and forth between a function that contains an asynchronous call and
    callback since callback is not called explicitly in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compositional nature of asynchronous workflow means that it can be composed
    with other concurrencies such as parallelization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The asynchronous block implies that some basic I/O operations on the web usually
    have their own *begin* and *end* web operations. It is further supported and wrapped
    into F# Async primitives to ease interoperability with asynchronous models such
    as .NET Asynchronous Programming Model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The asynchronous block also provides exception handling in a compositional way
    and also in a safe manner without losing too much referential transparency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Asynchronous workflow is nicely wrapped in the following common syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The term `expression` is not only a single line of expression but can also be
    a compound expression. This means it can contain more than one statement as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know asynchronous workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can start looking at the first sample of `async` from MSDN Library. I have
    added the necessary detail on handling specific exceptions that may occur when
    we are dealing with HTTP request/response operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's visit the details of this sample.
  prefs: []
  type: TYPE_NORMAL
- en: The intention of this sample code is to download the content of a web page from
    a collection of URLs asynchronously while also executing the download of the web
    page of all URLs in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: The `urlList` variable contains all URLs as a collection. F# will infer this
    collection as a list of tuple of *string * string*. Then, this list is passed
    as a parameter to the `fetchAsync` function, which is then continued to be passed
    to the next sequence in the pipeline of the `|>` pipeline operator. The `fetchAsync`
    function returns an `async` block, implying that it returns an `async` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a simplified flow, the entire chain of function compositions is composed
    nicely using the pipelines of `|>` within the `runAll` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `urlList` is passed to the `Seq.map` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Seq.map` function still needs one more parameter: the `map` function.
    The `map` function takes `fetchAsync` as a parameter. The result of `map` returns
    a sequence of functions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sequence of functions is executed in parallel by `Async.Parallel`, which
    then returns an array of `async` functions. The executions are not yet run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `async` block includes exception handlings. The difference from the code
    in MSDN Library is the way the handling of the exceptions. In our sample code,
    exception handling is more specific than the original code in MSDN Library. This
    specific exception handling model is very important, because the exception occurred
    might have resulted as different types of exceptions caused by any errors in HTTP
    request/response operations and the specific exception should be handled differently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The array of functions is then executed immediately by `Async.RunSynchronously`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ignore construct ignores the returning result. It will be inferred further
    as a unit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the code in F# scripting/interactive; then, within the interactive
    window, we will see the types inferred for `urlList`, `fetchAsync`, and `runAll`
    functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting to know asynchronous workflow](img/image00290.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The declaration of let for asynchronous workflow can be written in two ways,
    using `let` and `let!` (pronounced *let bang*).
  prefs: []
  type: TYPE_NORMAL
- en: The sample uses `let!`; it means that the computation is focusing on returning
    a result. It means that the intention of the `async` operation is to execute the
    `download` function, `webClient.AsyncDownloadString(uri)`, and return the result,
    not the operation. Then, the thread on the `fetchAsync` scope is suspended. In
    other words, it is blocked because it waits for an event to be raised to notify
    that the process being waited for is completed. The outer thread (outside the
    `fetchAsync`) is not blocked.
  prefs: []
  type: TYPE_NORMAL
- en: All the code after the line of `webClient.AsyncDownloadString(uri)` is executed
    later, after the download is finished. However, the execution will not have to
    wait for the download to be completed; instead it will go outside the `async`
    block and execute the code after `fetchAsync` is called. In this sample, it will
    execute the code after the call to `fetchAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: After the download is completed, the execution context returns to the code within
    the `async` block; it will point to the execution point of code after the call
    to `webClient.AsyncDownloadString(uri)`. The code at this point will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Because there is `Async.Parallel`, which executes all of the `fetchAsync` in
    parallel, the execution looks sequential, although the execution of the `AsyncDownloadString`
    calls is parallel.
  prefs: []
  type: TYPE_NORMAL
- en: In the sample, the execution is triggered by the call to the `Async.RunSynchronously`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The `let` means that the execution is not performed immediately; it is stored
    in a variable to be executed later. It does not return the result immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following sample of `let` and `let!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`let!` is conceptually equal to await in C# and VB as it awaits the actual
    result of `Task<T>`. It is still semantically different in its implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Using asynchronous with Dispose pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another equivalent declaration to define the result of an asynchronous
    workflow using the `use!` keyword as compared to `let!`. The difference between
    `let!` and `use`/`use!` is in the usage: `use!` is used to handle asynchronous
    calls that will later dispose the object.'
  prefs: []
  type: TYPE_NORMAL
- en: The `use!` keyword is the asynchronous counterpart of F#'s synchronous `use`
    and `using` keywords. In C#/VB, the concept of disposable is equal to the `using`
    keyword in C# and the `Using` keyword in VB, except that there is no comparable
    using model for disposable to be used in an asynchronous way.
  prefs: []
  type: TYPE_NORMAL
- en: The capture of a pattern, which is going to be disposed when not in use anymore
    before going out of scope, is called the Dispose pattern. It is also a sample
    of a coding design pattern. In today's programming language terms, the Dispose
    pattern is often escalated to have syntactic sugar, which is then translated as
    `try...finally` or (something else with similar semantics). Many programming languages
    have leveraged this Disposable pattern, not just C#, VB, and F#. It is also used
    in C++, Java, and other modern programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the requirements for wrapping an object or type for usage
    in `use`/`use!`:'
  prefs: []
  type: TYPE_NORMAL
- en: The result object must implement the `IDisposable` interface; therefore it must
    explicitly implement the `Dispose` method. However, in the real semantic of the
    Disposable pattern, it only looks for the implementation of the `Dispose()` method
    that has a `void Dispose()` signature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An unmanaged resource is highly recommended to implement `IDisposable`. The
    main reason for why it must explicitly implement the `Dispose` method is because
    the object with an explicit `Dispose` method is usually an unmanaged resource
    wrapped as a CLR object, such as `File`, network `Socket`, and database connection
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A managed object, if it is guaranteed to have no side effects, is also welcome
    to implement `IDisposable`.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of implementing the `IDisposable` interface and, at the same
    time, implementing our own `Dispose` method is that it minimizes the garbage collection
    overhead because implementing the `Dispose` method means that we decide the lifetime
    of the object before disposed.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, the `use` and `use!` constructs in F# involve wrapping the `try...finally`
    pattern in the generated IL.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to implement code that has usage of `use!`.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sample, we are going to use the `SqlDataReader` class because
    it implements the `IDisposable` interface. This instance of `SqlDataReader`, the
    `dataReader` object, will be disposed after the execution of the asynchronous
    call is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's dive deeper into the previous sample code.
  prefs: []
  type: TYPE_NORMAL
- en: The code will only refer to `System.Data` and `System.Data.SqlClient`. Any references
    to `System`, `System.Data`, and `System.Data.Common` do not need the external
    reference to the library outside of BCL. Some of the classes (especially .NET
    primitive types) used in the code have namespace prefix of `System` are available
    at `mscorlib.dll` and `System.dll`. The F# compiler will automatically know the
    location of `mscorelib.dll` and `System.dll`. For SQL server-related database
    connections, we have to add reference to `System.Data.SqlCient.dll` in our project.
    This is the same for another library such as `System.Web.dll`. If you want to
    use other libraries such as `System.Web.dll`, you have to add a reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: For normal F# code, you can add reference by adding library references to the
    project reference.
  prefs: []
  type: TYPE_NORMAL
- en: For F# scripting, you have to inform the compiler about the location of the
    DLL that you want to use by registering it manually before using it. It is recommended
    that you register it before any open statement so as to ensure that you have registered
    the necessary DLL at the first section of the script. The registration is done
    by using the compiler directive of `#r`.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the `#r` compiler directive of F#, please visit the
    MSDN Library at [https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/compiler-directives-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/compiler-directives-%5bfsharp%5d).
  prefs: []
  type: TYPE_NORMAL
- en: The `use!` keyword (called *use bang*) will treat the `WebResponse` result from
    `req.AsyncGetResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: We can examine the compiler result of the code sample by copying and pasting
    the code into any `.fs` code, or we can simply put the source code into the F#
    console project of a default file containing the main `EntryPoint`, `Program.fs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile it and open the executable file of the EXE using ILDASM. We will roughly
    see the following layout in the disassembled view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using asynchronous with Dispose pattern](img/image00291.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s dive into the IL of the `async` block, starting from the `UseBangSample`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The method calls `UseBangSample@10` by instantiating it, and then it calls the
    `Invoke` method. It is quite common in the generated IL as the class is treated
    as an executable operation like a delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ignore the cryptic names of the generated type and method of the IL. If you
    compile the code on your own, the resulting type and method might have different
    names. The source code and the related IL from ILDASM for this chapter is already
    set up and available for us to examine the IL assembly code with the related F#
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The common flow is actually the execution of the `Invoke` method. In this context,
    the `Invoke` method of `UseBangSample@10` will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive into the IL of `UseBangSample@10.Invoke`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The line `IL_001d` explains the correlation between the IL and the corresponding
    code, the `use!` declaration. This `use!` will actually call the `FSharpAsyncBuilder.Using`
    builder to do the actual dispose pattern by instantiating `FSharp.AsyncBuilder`
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these complex details are nicely hidden in the implementation detail
    of builders, in the implementations of the following three related Async types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Control.Async` for the `Async.*` methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Control.AsyncBuilder` for the builder implementation of asynchronous workflow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Control.Async<''T>` type to contain the implementation result of asynchronous
    workflow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, never mind the cryptic name of the generated code. As long as the name
    alias of the method and the classes is correct, we can simply deduce the use of
    `AsyncBuilder.Using` to handle the `use!` declaration in order to implement the
    Disposable pattern.
  prefs: []
  type: TYPE_NORMAL
- en: F# also comes with built-in asynchronous support for HTTP requests. This additional
    asynchronous operation is available in the `WebRequest` type, and it has been
    available under the `Microsoft.FSharp.Control.WebExtensions` namespace since F#
    3.0\. In F# version 2.0, it is available under the `Microsoft.FSharp.Control.CommonExtensions`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: There has been a namespace reorganization in F# 3.0 and above as it is more
    aligned to the purpose or intent of the types and operations inside the namespace.
    For example, `WebRequest` related operations, now inside `Microsoft.FSharp.Control.WebExtensions`,
    were previously available under `Microsoft.FSharp.Control.CommonExtensions`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main reason for this reorganization is the stabilization and standardization
    of intents because F#, since F# 2.0 in Visual Studio 2010, is not just a research
    product anymore, it is becoming a commercial product or being productized. Again,
    the reorganization is also a working result of responding to developer feedbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Always consult MSDN Library documentation for F# 4 and above. It is highly recommended
    to focus on F# 4 and the later versions. Further namespace changes are very unlikely
    in the next version, unless the feedback from the F# community is crucial and
    is agreed upon by the F# developer and designer team at Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the starting guide to F# asynchronous workflow as computation
    expressions, please consult MSDN Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/asynchronous-workflows-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/asynchronous-workflows-%5bfsharp%5d)'
  prefs: []
  type: TYPE_NORMAL
- en: The details of computation expressions themselves and optimizing computation
    expressions will be discussed in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language
    Features and Constructs Optimization"), *Language Features and Constructs Optimization*.
  prefs: []
  type: TYPE_NORMAL
- en: Operations in asynchronous workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first sample in this chapter shows `Async.Parallel` and `Async.RunSynchronously`
    in action. These two belong to the F# `Control.Async` class with other functions
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `Control.Async` class is available in the `Microsoft.FSharp.Control` namespace
    as we have witnessed by disassembling the code demonstrated in the *Using asynchronous
    with Dispose pattern* section covered earlier. `Control.Async` cannot function
    alone when used in an asynchronous workflow block; it depends on the builders
    in the `Control.AsyncBuilder` type.
  prefs: []
  type: TYPE_NORMAL
- en: A complete starting point of reference for `Control.Async` as a type is available
    at [https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async%5b't%5d-type-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async%5b't%5d-type-%5bfsharp%5d).
  prefs: []
  type: TYPE_NORMAL
- en: All operations of the async workflow in F# are available at [https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a table of interesting operations (commonly used) in F# `async`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Quick Remark** |'
  prefs: []
  type: TYPE_TB
- en: '| `AsBeginEnd` | Creates three functions that can be used to implement the
    .NET Framework **Asynchronous Programming Model** (**APM**) for the supplied asynchronous
    computation. |'
  prefs: []
  type: TYPE_TB
- en: '| `AwaitEvent` | Creates an asynchronous computation that waits for a single
    invocation of a CLI event by adding a handler to the event. Once the computation
    completes or is cancelled, the handler is removed from the event.`AwaitEvent`
    is the best fit to handle .NET EAP model. |'
  prefs: []
  type: TYPE_TB
- en: '| `AwaitIAsyncResult` | Creates an asynchronous computation that will wait
    on the `IAsyncResult`. It is used for the .NET APM model. |'
  prefs: []
  type: TYPE_TB
- en: '| `AwaitTask` | Returns an asynchronous computation that waits for the given
    task (.NET TPL `Task`) to complete and returns its result. |'
  prefs: []
  type: TYPE_TB
- en: '| `CancellationToken` | Creates an asynchronous computation that returns the
    `System.Threading.CancellationToken` that manages the execution of the computation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DefaultCancellationToken` | Gets the default cancellation token to run asynchronous
    computations. |'
  prefs: []
  type: TYPE_TB
- en: '| `FromBeginEnd` | Creates an asynchronous computation in terms of a Begin/End
    pair of actions in the style used in CLI APIs. |'
  prefs: []
  type: TYPE_TB
- en: '| `FromContinuations` | Creates an asynchronous computation that includes the
    current success, exception, and cancellation continuations. The callback function
    must eventually call exactly one of the given continuations.This exact map of
    one cancellation for one continuation is also the same concept as .NET APM. |'
  prefs: []
  type: TYPE_TB
- en: '| `Ignore` | Creates an asynchronous computation that runs the given computation
    and ignores its result. |'
  prefs: []
  type: TYPE_TB
- en: '| `Parallel` | Creates an asynchronous computation that executes all the given
    asynchronous computations, initially queueing each as work items and using a fork/join
    pattern. |'
  prefs: []
  type: TYPE_TB
- en: '| `RunSynchronously` | Runs the provided asynchronous computation and awaits
    its result.When `RunSynchronously` is used to run an `async` block, it will run
    the code in the `async` block immediately in a separate runtime context as long
    as the code in the `async` block follows the pattern as defined in asynchronous
    workflow. |'
  prefs: []
  type: TYPE_TB
- en: '| `Sleep` | Creates an asynchronous computation that will sleep for the given
    time. This is scheduled using a `System.Threading.Timer` object. The operation
    will not block operating system threads for the waiting duration. |'
  prefs: []
  type: TYPE_TB
- en: '| `Start` | Starts the asynchronous computation in the thread pool but does
    not await its result. |'
  prefs: []
  type: TYPE_TB
- en: '| `StartAsTask` | Executes a computation in the thread pool. Returns a `Task`
    that will be completed in the corresponding state once the computation terminates
    (produces the result, throws an exception, or gets canceled). If no cancellation
    token is provided, then the default cancellation token is used. |'
  prefs: []
  type: TYPE_TB
- en: '| `StartChild` | Starts a child computation within an asynchronous workflow.
    This allows multiple asynchronous computations to be executed simultaneously (in
    parallel). The child computation can be composed to start in parallel with other
    child computations using `Async.Parallel`. |'
  prefs: []
  type: TYPE_TB
- en: '| `StartChildAsTask` | Creates an asynchronous computation that starts the
    given computation as a `Task`. |'
  prefs: []
  type: TYPE_TB
- en: '| `StartImmediately` | Runs an asynchronous computation, starting immediately
    on the current operating system thread. The main difference between `Start` and
    `StartImmediately` is quite subtle but important: `StartImmediately` uses `ThreadPool`.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The operations in `ControlAsync` are not all targeted at working with .NET
    TPL. From the perspective of the available asynchronous model in .NET, the operations
    of `Control.Async` provide supports for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET Asynchronous Programming Model (APM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Event-based Asynchronous Pattern (EAP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Task Parallel Library (TPL), only available for .NET 4 with added asynchrony
    operations or programming support in .NET 4.5 and later. The Task asynchrony is
    called Task-based Asynchrony Pattern or TAP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's dive into the supports.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth assessing that .NET TPL (including TAP) is considered to be a modern
    concurrency model. The legacy .NET asynchronous models are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Programming Model, often abbreviated as APM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-based Asynchronous Programming pattern (EAP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might wonder why they are called **legacy models**. They are legacy models
    in the sense that they are not supposed to be used anymore. Since .NET 4.0, the
    preferred model to be used is the .NET Task Parallel Library (TPL) model.
  prefs: []
  type: TYPE_NORMAL
- en: Using .NET TPL is recommended, not just because it is easier to use and more
    intuitive but also because every operation is wrapped as `Task` or `Task<T>` and
    it is easier to reason about your code. In F#, APM and EAP are usually handled
    using asynchronous-related operation methods but it is quite difficult to do in
    a real APM or EAP way.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that APM and EAP should not be used anymore although they
    are still available in .NET 4.6\. EAP is harder to implement than APM because
    it focuses on event handling, which usually happens on any action or operation
    that has event handling; otherwise, we have to handle the completed event on our
    own by implementing custom completed action's event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Creating child asynchronous workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In F#, it is possible to create a nested asynchronous operation within an `async`
    block as the child or children of the current asynchronous workflow.
  prefs: []
  type: TYPE_NORMAL
- en: These children asynchronous workflows are executed in a sequence at first (based
    on the sequence of creation) but they do not have to finish simultaneously. They
    can run or start in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two operations to create a child asynchronous workflow: `Async.StartChild`
    and `Async.StartChildAsTask`. The `Async.StartChildAsTask` will return the resulting
    asynchronous workflow as `Task<T>` based asynchrony of Task-based Asynchronous
    Pattern or TAP.'
  prefs: []
  type: TYPE_NORMAL
- en: This method is generally used with `let!` because it is supposed to return the
    result of a child asynchronous process, and this is why it is supposed to be bound
    to a process that returns a result, which is then to be observed or used by the
    parent asynchronous block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The returning result of `Async.StartChild` is usually called **completor**
    because it is typed as a computation that has to wait for completion. This is
    also described by the MSDN Library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"When used in this way, each use of StartChild starts an instance of childComputation
    and returns a completor object representing a computation to wait for the completion
    of the operation. When executed, the completor awaits the completion of childComputation."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Putting it simply, the completor is an object to contain the operation of the
    asynchronous process and wait for it to be completed. This is why the returning
    value of `Async.StartChild` is typed as `Async<Async<'T>>` instead of just `Async<'T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'WARNING: The use of `use!` is not allowed to capture an asynchronous child;
    it will yield an unpredictable result. Future releases of F# will not allow this
    to be used. It is required to use `let!` instead. The main reason is that the
    nature of the asynchronous child is not for disposable objects as it is focused
    on the process, not on the object that is part of the result to be awaited, although
    the process contains an asynchronous function that may have a result as denoted
    by the `Async<Async<''T>>` type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple example from MSDN Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that `System.Windows.Forms` is available on the project references to
    run this sample.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `Async.StartChild`, including the sample code, visit
    the MSDN Library at [https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.startchild%5b%27t%5d-method-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.startchild%5b%27t%5d-method-%5bfsharp%5d).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Async.StartChild` is not recommended to be used with the legacy .NET EAP.
    The result of the child asynchronous process can be placed in a different execution
    context and thread because EAP can be implemented during the event-driven nature
    of UI threads such as Windows Forms thread or WPF thread.'
  prefs: []
  type: TYPE_NORMAL
- en: The risk of getting unpredictable results (side effects) may outweigh the comfort
    and ease of creating child asynchronous processes. The side effects of cross threads
    are also very hard to identify and debug. The only way to avoid the risks is by
    simply not using `Async.StartChild` against EAP or against the possibility of
    operating inside a UI thread such as Windows Forms or WPF.
  prefs: []
  type: TYPE_NORMAL
- en: F# asynchronous workflow support for legacy .NET APM and EAP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The F# asynchronous workflow still provides support for legacy .NET APM and
    EAP model, but the support is meant *to consume* the model because it is not intended
    to fully implement our own custom APM and EAP models. It is called *to consume*
    as F# has no support for implementing our own APM and EAP model, so it is not
    recommended to implement a custom APM or EAP in F#.
  prefs: []
  type: TYPE_NORMAL
- en: There is another reason why these APM and EAP models are not recommended anymore,
    especially when implementing your own custom models in F#. The complexity of going
    back and forth of having callbacks with side effects computation such as crossing
    CPU thread and UI thread is also a very strong reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following operations are targeted at any .NET Asynchronous Programming
    Model (APM):'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsBeginEnd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AwaitIAsyncResult`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FromBeginEnd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The .NET APM is one of the legacy asynchronous models in .NET. It has a distinct
    pattern of having an operation prefixed with `Begin`, an operation prefixed with
    `End`, and a callback function to be called. For example, .NET `System.IO.FileStream`
    has `BeginRead` and `EndRead` methods. Each method has a delegate parameter that
    functions as callback.
  prefs: []
  type: TYPE_NORMAL
- en: The preferred way to support .NET APM in F# is by using `Async.FromBeginEnd`
    in order to be as flexible as we can to include the `Begin` operation, the `End`
    operation, and the parameter for the `Begin` and `End` operations. Using `Async.FromBeginEnd`
    is also the easiest way to leverage the existing .NET APM, which is usually available
    when dealing with I/O. For example, `System.IO.FileStream` and `System.Net.Sockets.Socket`
    have the pattern of `BeginXXX` and `EndXXX` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by consulting the documentation for `Async.FromBeginEnd` (that has
    no parameter) in MSDN at [https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.frombeginend%5b%27t%5d-method-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.frombeginend%5b%27t%5d-method-%5bfsharp%5d).
  prefs: []
  type: TYPE_NORMAL
- en: 'The link has the shortest form of `Async.FromBeginEnd` (that does not need
    a parameter and only returns a result) syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need parameters (from 1 to 3 parameters), the syntaxes are as follows
    (the `static` member modifier is the same as the previous; it is omitted for simplicity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Just looking at the signature might be confusing at first; fortunately, a sample
    usage of `Async.FromBeginEnd` is available in the MSDN Library.
  prefs: []
  type: TYPE_NORMAL
- en: The sample leverages `System.Net.Socket` by enhancing it using an implicit extension
    method, added on the existing `Socket` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code definition of the asynchronous operations sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the method that contains an asynchronous call follows common guidelines:
    it has an `Async` suffix. For example, the `this.MyConnectAsync` method contains
    an asynchronous call to `Socket.BeginConnect` that follows the APM naming conventions.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Async.FromBeginEnd` uses the syntax for two parameters. It is also used to
    wrap and simultaneously handle the following pairs of the asynchronous Socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BeginAccept` and `EndAccept` pair'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BeginConnect` and `EndConnect` pair'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BeginSend` and `EndSend` pair'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BeginReceive` and `EndReceive` pair'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The related syntax on the MSDN Library is `Async.FromBeginEnd<'Arg1,'Arg2,'T>`
    because it needs two parameters (or arguments in MSDN Library terms).
  prefs: []
  type: TYPE_NORMAL
- en: 'To test those `Socket` methods in the `async` block, consider the following
    partial sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For the complete documentation of `System.Net.Socket`, consult the MSDN Library
    at [https://msdn.microsoft.com/en-us/library/system.net.sockets.socket(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.net.sockets.socket(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: For more information, consult .NET APM on the MSDN Library at [https://msdn.microsoft.com/en-us/library/ms228963(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms228963(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: The EAP model simply models the implementation of asynchronous event-driven
    programming by using an event as the handler of the completed event. Unfortunately,
    it is not quite clear how the flow of waiting is implemented as the pattern focuses
    on what will happen when the operation is completed. It is also not clear about
    deciding the implementation detail of how the EAP is used to handle the I/O operations
    that are blocking by default.
  prefs: []
  type: TYPE_NORMAL
- en: F# supports EAP by providing one method, the `Async.AwaitEvent` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to APM, EAP focuses more on the completion of the action and the state
    of an object instead of getting the result of an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about the legacy .NET EAP model, consult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/ms228969(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms228969(v=vs.110).aspx)
    To illustrate F# support for EAP, we must understand and focus on the event programming
    model first.'
  prefs: []
  type: TYPE_NORMAL
- en: The event programming model is actually not so different from the event-based
    approach of Windows UI programing, where a UI control has events for any kind
    of event happening to it, such as clicked, mouse over, focus, or lost focus. But
    there are some events that need to be handled with care, such as timer events.
    When a timer is active, it ticks on every period based on how long it takes to
    tick between intervals. Usually, when an interval is set, the timer implicitly
    makes us to wait until some time period has elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of a timer is crucial as sometimes the time elapsed may vary depending
    on what kind of timer we use. Avoid the use of a UI timer as much as possible
    because the resolution (the precision of timing) of a UI timer is lower than `System.Threading.Timer`
    or any other non-UI timer, as highlighted in [Chapter 2](fsp-hiperf_cu02.html#aid-K0RQ2
    "Chapter 2. Performance Measurement"), *Performance Measurement*.
  prefs: []
  type: TYPE_NORMAL
- en: All of the execution is based on the sequence of events; it is also natural
    to call it an event-driven model. Unfortunately, this wait might take some time
    blocking the current thread. It is therefore recommended to handle this asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the documentation for `Async.AwaitEvent` on the online MSDN Library,
    the documentation does not have a good explanation on how we relate this to .NET
    EAP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the sample code from the MSDN Library documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This sample is quite simple, and at the same time, it directly shows the sample
    usage of `Async.AwaitEvent`. The sample `await` construct for any file or folder
    changes in a folder. If any changes occur (as a changed event), it will continue
    to print the file name and do some I/O operations, such as opening the file. The
    file is then read asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `Async.AwaitEvent`, check out [https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.awaitevent%5b%27del%2c%27t%5d-method-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.awaitevent%5b%27del%2c%27t%5d-method-%5bfsharp%5d).
  prefs: []
  type: TYPE_NORMAL
- en: We now have basic knowledge of how F# interops with .NET EAP, although the interoperability
    is not quite as straightforward as using the async-based `Task<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring asynchronous operation asynchronously
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Async.Ignore` is essentially the same as using `ignore`. However, it is semantically
    different as `Async.Ignore` must only be used to ignore asynchronous operations,
    not non-asynchronous operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of `Async.Ignore` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Async.Ignore` implies that it cannot be used independently as it needs an
    `async` operation as its parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Async.Ignore` has its ignore implementation asynchronously; therefore, it
    is guaranteed not to block the current thread synchronously. This means that it
    will not block the current thread of the calling function as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The common place of `Async.Ignore` is generally used to ignore the returning
    result of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All EAP-based asynchronous operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All asynchronous operations that return nothing (`unit` in F#, `void` in C#,
    or the `Sub` procedure/method in VB).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Therefore, we must not use `Async.Ignore` if we want to examine or get the results
    from asynchronous operations. Also, `Async.Ignore` is already optimized for non-returning
    result of any asynchronous workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please do not confuse the non-returning result of asynchronous operations with
    the F# unit. The term non-returning result should be treated as simply intuitive-not
    returning any result-because the main focus here is the on completion of any actions.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you use `Async.Ignore` on F#-specific asynchronous workflows
    (including F# support on EAP) and .NET TPL instead of using it on other kinds
    of asynchronous models, as it is more predictable and more optimized.
  prefs: []
  type: TYPE_NORMAL
- en: Using `Async.Ignore` is also fine when combining with F#'s `MailboxProcessor`
    because `MailboxProcessor` is designed to be compatible; it's also recommended
    to use `MailboxProcessor` in asynchronous workflow blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Delaying asynchronous workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we delay an asynchronous implementation without blocking the outside
    calling thread? We could do this easily by using `Thread.Sleep`, but `Thread.Sleep`
    always blocks the calling thread and not just the current execution thread. Therefore,
    `Thread.Sleep` always enforces us to wait synchronously instead of asynchronously.
    It is also often misunderstood that `Thread.Sleep` would not block as it actually
    blocks the current thread. We can wrap `Thread.Sleep` into an `async` block, but
    then the outside thread still has to wait for `Thread.Sleep` to finish first.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is the `Async.Sleep` method to support delay asynchronously. The syntax
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following sample usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It's still better to assume that any asynchronous delay implementation uses
    `Async.Sleep` instead of `Thread.Sleep` because `Async.Sleep` never blocks the
    current operating system threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to a short description on MSDN Library, `Async.Sleep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creates an asynchronous computation that will sleep for the given time. This
    is scheduled using a System.Threading.Timer object. The operation will not block
    operating system threads for the duration of the wait.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is not the actual implementation detail because it depends on the current
    runtime. Internally, `Async.Sleep` creates an asynchronous operation that inserts
    the delay by calling `Task.Delay` internally if it's run under .NET Core or by
    using the asynchronous timer mechanism utilizing `System.Threading.Timer` for
    non-.NET Core, with the *trampoline* algorithm in place.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term *actual implementation detail* means that the actual internal implementation
    detail will be changed in the next release of F#. We must also include the fact
    that F# core class libraries are open source as part of the Microsoft Visual F#
    open source repo on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, there is a high possibility that the actual source code implementation
    of F# will change by the time this book is published. It could change based on
    the progress of feedbacks from Microsoft and external contributors. It is also
    quite common to always assume that the actual implementation will always be changed,
    based on the nature of open source contributions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting from this chapter, we will sometimes visit the internal implementation
    of F# 4 core class libraries by looking at its source code. This is very important
    because we have to dig deeper than just using the libraries in order to fully
    understand what is happening behind the scenes of calling F# core functions. It
    is also a common best practice to increase our knowledge of the internal workings
    of how F# presents its features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can *peek* at the source code of `Async.Sleep` on the F# GitHub repo (some
    comments have been omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The full source code is available at [https://github.com/Microsoft/visualfsharp/blob/master/src/fsharp/FSharp.Core/control.fs](https://github.com/Microsoft/visualfsharp/blob/master/src/fsharp/FSharp.Core/control.fs).
  prefs: []
  type: TYPE_NORMAL
- en: For more information about `Async.Sleep` visit the MSDN Library, at [https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.sleep-method-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/async.sleep-method-%5bfsharp%5d).
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered how to declare an `async` block and delay it. Now, we
    need to know how to cancel it.
  prefs: []
  type: TYPE_NORMAL
- en: Handling cancellation in asynchronous workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is quite possible that the user may cancel the ongoing asynchronous process
    even in the middle of an asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In F#, the common way to have support for cancellation that can be done in
    the middle of any running asynchronous operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Requesting a token in the form of the `CancellationToken` type structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This `CancellationToken` instance is obtained from `System.Threading.CancellationTokenSource`.
    Internally, `CancellationToken` will always be loaded and pushed onto a stack,
    which is later popped after use when the ongoing asynchronous operation is canceled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CancellationToken` needs to know which one of the asynchronous operations
    to have cancellation support for. This can be done by linking `CancellationToken`
    with the asynchronous function by calling `Async.Start` or `Async.StartImmediate`
    with an override that has `CancellationToken` as a parameter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before using `CancellationToken` and `CancellationTokenSource`, you need to
    ensure that references to the `System.Threading.dll` assembly are available on
    the project reference setting when the code is in an FS file or that you have
    registered the assembly manually when the code is in an FSX file and executed
    in scripting mode (in F# Interactive mode).
  prefs: []
  type: TYPE_NORMAL
- en: To add cancellation support as mentioned in Step 3, the linking of the asynchronous
    operation (usually wrapped as an `async` block) is done by linking the `async`
    function with `CancellationToken`, and this linking must be done carefully. This
    `CancellationToken` instance is a *value typed object, so the instance of this
    CancellationToken must not be derived, and it must not be used and linked to other
    async functions*. It is also implicitly immutable, including the referential transparency
    of the initial design of `CancellationToken`.
  prefs: []
  type: TYPE_NORMAL
- en: This linking of the asynchronous operation is crucial; if the same value is
    linked to more than one `async` block, it will cancel each of the linked functions
    unpredictably because the same object value may interfere with other linked `async`
    blocks as well. This will violate the referential transparency and may therefore
    raise many unwanted side effects. Such multiple function linking is a bad practice
    as it will cause side effects such as unpredictable cancellation.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the nature of `CancellationToken` as a structure (value type), multiple
    instances of different tokens of `CancellationToken` will always be stored and
    pushed into stacks, which is fast to store and retrieve (pop) as well.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, multiple linking to multiple `async` blocks from the same `CancellationToken`
    is not recommended and should not be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: To see the usage sample of `CancellationToken`, we can revisit our existing
    `use!` sample and leverage the overloaded method of `ExecuteReaderAsync` with
    an additional `CancellationToken` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The existing code sample now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding sample code highlights the following steps to add cancellation
    support:'
  prefs: []
  type: TYPE_NORMAL
- en: The `UseBangCancellationSample` function shows that it takes a parameter, `tokenSource`
    typed as `CancellationTokenSource`. Then `CancellationToken` is taken from the
    `CancellationTokenSource.Token` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To cancel the ongoing asynchronous operation, call the `Cancel` method of the
    `CancellationToken` instance, which is passed into the related asynchronous operation
    started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important that the instance of `CancellationToken` knows which asynchronous
    process it needs to cancel. In the preceding sample, `CancellationToken` is linked
    to `ExecuteReaderAsync` by setting it as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now know how to utilize `CancellationToken` and `CancellationTokenSource`
    by leveraging the `System.Threading.Tasks` namespace. This also serves as a warm
    starter to the introduction to interoperability with the Task library and.NET
    TPL.
  prefs: []
  type: TYPE_NORMAL
- en: Common conventions when implementing asynchronous operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen samples of implementing calling asynchronous operations and wrapping
    them in asynchronous blocks. There are some patterns and best practices that we
    must follow in accordance with the F# implementation and .NET standards.
  prefs: []
  type: TYPE_NORMAL
- en: There are certain guidelines or standards that must be followed not only to
    enhance the code's readability but also because it will become easier to understand
    the code and reason about what it will do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some common conventions of implementing asynchronous workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: A method that has an asynchronous call inside it should be suffixed with Async,
    to define that this function or method contains an asynchronous call and must
    be called inside the asynchronous block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any kind of event handling that has an asynchronous call should not be suffixed
    with Async, for example, the `Button1_Click` method to handle the Click event
    that has a call to `DownloadWebAsync`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `async` block that needs to delay some operations should use `Async.Sleep`
    instead of `Thread.Sleep`. Otherwise, the current thread will be blocked; the
    execution will be observed as synchronous and will be executed synchronously instead
    of asynchronously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All I/O operations must be treated asynchronously. This includes I/O operations
    to send commands to other output devices such as printers, not just I/O in network
    or I/O to storage devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we know the basic usage of the `Control.Async` operations in F#, we
    will dive into the basic interop of asynchronous workflow with .NET TPL.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to interop with .NET TPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F# has a high compatibility support for .NET TPL; it can nicely use the .NET
    TPL objects of `Task` and `Task<T>` back and forth. This means that F# can also
    use the `Task`/`Task<T>` results from other languages as well and not just from
    F#.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET TPL, the concurrency support is not just for parallel programming, but
    also for the awaiter of the async-await model that has currently started in C#
    5.0 and VB 11, as related in .NET 4.5 and later.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start from the overview of .NET TPL support in F# in
    terms of leveraging `Task` and `Task<T>`. We will discuss the interop perspective
    from outside of F#, such as interop with F# asynchronous workflow, in [Chapter
    5](fsp-hiperf_cu05.html#aid-164MG2 "Chapter 5. Advanced Concurrency Support in
    F#"), *Advanced Concurrency Support in F#*.
  prefs: []
  type: TYPE_NORMAL
- en: A quick overview of asynchronous programming in .NET TPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For asynchronous operations (or asynchronous programming, as is mostly mentioned
    in C#/VB documentation in MSDN) the async-await model relies heavily on the `Task`
    and `Task<T>` classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `Task` class is for asynchronous operations that have no result; `Task<T>`
    is for asynchronous operations that have results. The generic parameter `T` is
    the type of the result.
  prefs: []
  type: TYPE_NORMAL
- en: '`Task<T>` contains the result in a property called `result`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Task` and `Task<T>` classes are available under the `System.Threading.Tasks`
    namespace. For more information, consult the landing page of `System.Threading.Tasks`
    in .NET 4.6 on the MSDN Library at [https://msdn.microsoft.com/en-us/library/system.threading.tasks(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.threading.tasks(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'In F#, the following are the operations that support `Task`/`Task<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Async.AwaitTask`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Async.StartAsTask`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Async.StartChildAsTask`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these methods have two overrides in common, one for dealing with `Task`
    with no result and the other for dealing with `Task<T>` that will return a `Task`
    with a result typed `T`. Dealing in this context means having interoperability
    with the Task-based Asynchrony Pattern (TAP) of .NET TPL
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to reintroduce the detail of .NET TAP because we are focusing
    on best practices. For more information on .NET TAP in .NET 4.5 and 4.6 on MSDN
    Library, visit [https://msdn.microsoft.com/en-us/library/hh873175(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/hh873175(v=vs.110).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: The documentation for `Async.AwaitTask` and `Async.StartChildAsTask` does not
    provide a sample code for us at all. Only `Async.StartAsTask` has a very simple
    sample code.
  prefs: []
  type: TYPE_NORMAL
- en: Work to address these shortcomings in the Visual F# documentation repository
    is still in progress, and all of us are welcome to participate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the sample code in the `Async.StartAsTask` documentation,
    and we have to modify it to successfully run it under the UI thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous code is running within the UI thread of Windows Forms. Therefore,
    it is advisable that the main method be marked with the `System.STAThread` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `async` block is contained in the `async1` function. It is then executed
    using `Async.StartAsTask` with no result. It will then return a `Task` instead
    of `Task<T>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Async.StartAsTask` is written inside an inline event handler of the Click
    event, `button.Click`, by using addition to the current event handler of event
    Click. It is the same as `AddHandler` in VB or the syntactic sugar of the `+=`
    operator in C#.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The original sample code in the MSDN Library does not have this `STAThread`
    attribute and it will yield an exception because `System.InvalidOperationException`
    has occurred due to the invalid cross thread, although the error message is quite
    confusing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A quick overview of asynchronous programming in .NET TPL](img/image00292.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It literally gives the following as the reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is not the real error. The real error is in the code where we put the code/function
    that calls `Application.Run` marked with `STAThreadAttribute`. It is also quite
    common as it is often demonstrated by C#/VB samples in the default project template
    of Windows Forms.
  prefs: []
  type: TYPE_NORMAL
- en: Not just Windows Forms, the terms of operating under `STAThread` are also valid
    for WPF as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a detailed explanation of `STAThread`, visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/system.stathreadattribute(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.stathreadattribute(v=vs.110).aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: And for more information about the Thread apartment model (including STA and
    MTA with respect to COM), visit the MSDN Library at [https://msdn.microsoft.com/library/ms809971.aspx](https://msdn.microsoft.com/library/ms809971.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, F# and C# use MTA; VB uses STA. For a Windows Forms application,
    the default is using STA. STA and MTA have nothing to do with how you create `System.Threading.Thread`.
    It is a threading apartment model, not a general multithreading model.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the other `Async.AwaitTask` and `Async.StartChildAsTask` samples, let''s
    revisit the sample of `UseBangSample`: (with `Async.AwaitTask` highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code demonstrates how to await a result from an asynchronous operation
    by awaiting `Task<T>`. The `T` in this context is typed as `SqlDataReader`, inferred
    by the return builder of asynchronous workflow. The return builder is coded implicitly
    in the `use!` construct/keyword as nicely captured from the execution of the `ExecuteReaderAsync`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are developing any applications, starting from small mobile applications
    to a large-scale enterprise application, concurrency is becoming very relevant,
    not just because of the trend of multi-core CPUs but also because having optimizations
    on concurrency gives us many advantages as described in this chapter. Although
    there is no single solution for all concurrency problems and optimizations, we
    know that we could leverage concurrency support in F# and .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 5](fsp-hiperf_cu05.html#aid-164MG2 "Chapter 5. Advanced Concurrency
    Support in F#"), *Advanced Concurrency Support in F#*, we will discuss the advanced
    topic of concurrency in F#, including one of F#''s unique features: the message-passing
    agent, `MailboxProcessor`.'
  prefs: []
  type: TYPE_NORMAL
