<html><head></head><body>
		<div id="_idContainer193">
			<h1 id="_idParaDest-318" class="chapter-number"><a id="_idTextAnchor317"/>13</h1>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor318"/>Real-Time Messaging with SignalR</h1>
			<p>Now that we’ve created various tests, added telemetry data, monitored the solution, and scaled our services, starting with this chapter, we’ll continue creating services and using different <span class="No-Break">communication technologies.</span></p>
			<p>In this chapter, we’ll use ASP.NET Core SignalR. SignalR is a technology that allows us to send real-time information from services to clients. The client initiates a connection to the service, which is then kept alive to send messages to the clients as information <span class="No-Break">becomes available.</span></p>
			<p>In this chapter, you’ll learn how to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Create a <span class="No-Break">SignalR service</span></li>
				<li>Send real-time information <span class="No-Break">to clients</span></li>
				<li>Create a <span class="No-Break">SignalR client</span></li>
				<li>Use Azure <span class="No-Break">SignalR Service</span></li>
			</ul>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor319"/>Technical requirements</h1>
			<p>In this chapter, like the previous chapters, you’ll need an Azure subscription and <span class="No-Break">Docker Desktop.</span></p>
			<p>The code for this chapter can be found in this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/"><span class="No-Break">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/</span></a><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">ch13</strong> folder contains this chapter’s projects, as well as their results. To add the functionality from this chapter, you can start with the source code from the <span class="No-Break">previous chapter.</span></p>
			<p>The projects we’ll be considering are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">Codebreaker.AppHost</strong>: The .NET Aspire host project. The app model has been enhanced by an additional project running a SignalR hub and using Azure <span class="No-Break">SignalR Service.</span></li>
				<li><strong class="source-inline">Codebreaker.Live</strong>: This is a new project that hosts minimal APIs invoked by the <strong class="source-inline">game-apis</strong> service and the <span class="No-Break">SignalR hub.</span></li>
				<li><strong class="source-inline">Codebreaker.GameAPIs</strong>: This project has been enhanced and can forward completed games <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">live-service</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">LiveTestClient</strong>: This is a new console application that registers with the SignalR hub to receive <span class="No-Break">completed games.</span></li>
			</ul>
			<h1 id="_idParaDest-321"><a id="_idTextAnchor320"/>Creating a SignalR service</h1>
			<p>In this chapter, we’ll create <a id="_idIndexMarker1034"/>a new service that offers real-time information to return games that are played to every connected client. <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.1</em> shows how the services of the <span class="No-Break">solution collaborate:</span></p>
			<div>
				<div id="_idContainer186" class="IMG---Figure">
					<img src="image/B21217_13_01.jpg" alt="Figure 13.1 – Codebreaker services"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Codebreaker services</p>
			<p>The <strong class="source-inline">game-apis</strong> service has existed since <a href="B21217_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>. The client of <strong class="source-inline">game-apis</strong> invokes the REST API to start games and set moves. What’s new is Codebreaker’s <strong class="source-inline">live-service</strong>. This service offers a simple REST API that’s invoked by the <strong class="source-inline">game-apis</strong> service every time a game completes. The main functionality of this service makes use of ASP.NET Core SignalR to offer real-time information to all connected clients. Clients need to subscribe before they can receive game <span class="No-Break">completion messages.</span></p>
			<p>What’s offered by <a id="_idIndexMarker1035"/>SignalR? As connections can never be started from a server to a client, and this is also true of SignalR, a client needs to connect to the SignalR service and subscribe to receive real-time information. The connection stays open, which allows the service to send information to <span class="No-Break">the clients.</span></p>
			<p>ASP.NET Core SignalR makes <a id="_idIndexMarker1036"/>use of <strong class="bold">WebSockets</strong> if this technology is available – but the programming model with SignalR is a lot easier than using WebSockets directly. Contrary to HTTP, with WebSockets, the connection that’s initiated by the client stays open, which allows the service to send messages when these <span class="No-Break">are available.</span></p>
			<p>WebSockets isn’t always<a id="_idIndexMarker1037"/> available and can be disabled by a proxy or a firewall and are not available everywhere. For example, <strong class="bold">Azure Front Door</strong> doesn’t support WebSockets at <span class="No-Break">this time.</span></p>
			<p>If WebSockets isn’t<a id="_idIndexMarker1038"/> available, SignalR switches to other communication techniques, such as <strong class="bold">server-sent events</strong> (<strong class="bold">SSE</strong>) and <strong class="bold">long polling</strong>. With SSE, the client starts an HTTP request<a id="_idIndexMarker1039"/> where it accepts <strong class="source-inline">text/event-stream</strong> data and asks the server to keep the connection alive (via the <strong class="source-inline">Connection: keep-alive</strong> HTTP header). All modern browsers support SSE nowadays. With polling, the client repeatedly asks the server if new data is available, opening new connections again and again. Long polling is a technique that reduces the number of requests from the client by the server not returning information immediately, stating that nothing new is available. Instead, the server waits for the timeout to nearly end before returning. If some new information is available while waiting, this new information <span class="No-Break">is returned.</span></p>
			<p>Using SignalR, there’s no need to change programming constructs to decide between WebSockets, SSE, and long polling. This is done automatically by SignalR. However, in all these scenarios, compared to simple HTTP requests, the server has more overhead: connections with the clients need to stay alive and thus be kept in memory. To remove this overhead from our services, we’ll use Azure SignalR Service later in <span class="No-Break">this chapter.</span></p>
			<p>To create a SignalR service, we just need to create an empty ASP.NET Core Web project. Because this service also offers a REST API, let’s create a new Web <span class="No-Break">API project:</span></p>
			<pre class="console">
dotnet new webapi --use-minimal-apis -o Codebreaker.Live</pre>
			<p>This creates a minimal API<a id="_idIndexMarker1040"/> project, similar to what we have for the <strong class="source-inline">game-apis</strong> project. This project needs to be configured as a .NET Aspire project. With Visual Studio, use <strong class="bold">Add</strong> | <strong class="bold">.NET Aspire Orchestrator Support</strong>. Alternatively, add a project reference to the AppHost project so that it references the <strong class="source-inline">Codebreaker.Live</strong> project. Then, add a project reference to the <strong class="source-inline">ServiceDefaults</strong> project to the <span class="No-Break">live project.</span></p>
			<p>The <strong class="source-inline">Codebreaker.Live</strong> service project needs to be configured with the .NET Aspire <span class="No-Break">app model:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
// else path using Azure services
<strong class="bold">var live = builder.AddProject&lt;Projects.Codebreaker_Live&gt;("live")</strong>
<strong class="bold">  .WithExternalHttpEndpoints()</strong>
<strong class="bold">  WithReference(appInsights)</strong>
<strong class="bold"> .WithEnvironment("StartupMode", startupMode);</strong>
<strong class="bold">var gameAPIs = builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis")</strong>
  .WithExternalHttpEndpoints()
  .WithReference(cosmos)
  .WithReference(redis)
  .WithReference(appInsights)
<strong class="bold">  .WithReference(live)</strong>
  .WithEnvironment("DataStore", dataStore)
  .WithEnvironment("StartupMode", startupMode);
  // code removed for brevity</pre>
			<p>By doing this, the project is added to the app model and referenced from the <strong class="source-inline">game-apis</strong> service as it needs the<a id="_idIndexMarker1041"/> link from <strong class="source-inline">live-service</strong> to invoke the REST API on <span class="No-Break">game completions.</span></p>
			<p>Next, we’ll add a SignalR hub that can be used by clients <span class="No-Break">to connect.</span></p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor321"/>Creating a SignalR hub</h2>
			<p>SignalR is already part <a id="_idIndexMarker1042"/>of ASP.NET Core, so we don’t need to add another NuGet package. Let’s add the SignalR hub class – that <span class="No-Break">is, </span><span class="No-Break"><strong class="source-inline">LiveHub</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Endpoints/LiveHub.cs</p>
			<pre class="source-code">
public class <strong class="bold">LiveHub</strong>(ILogger&lt;LiveHub&gt; logger) : <strong class="bold">Hub</strong>
{
  public async Task <strong class="bold">SubscribeToGameCompletions</strong>(string gameType)
  {
    logger.ClientSubscribed(Context.ConnectionId, gameType);
    <strong class="bold">await Groups.AddToGroupAsync(Context.ConnectionId, gameType);</strong>
  }
  public async Task <strong class="bold">UnsubscribeFromGameCompletions</strong>(string gameType)
  {
    logger.ClientUnsubscribed(Context.ConnectionId, gameType);
<strong class="bold">    await Groups.RemoveFromGroupAsync(Context.ConnectionId, gameType);</strong>
  }
}</pre>
			<p>A SignalR hub derives from the <strong class="source-inline">Hub</strong> base class (the <strong class="source-inline">Microsoft.AspNetCore.SignalR</strong> namespace). This class defines the <strong class="source-inline">OnConnectedAsync</strong> and <strong class="source-inline">OnDisconnectedAsync</strong> methods, both of which can be overridden to react on client connects and disconnects. Here, we define the <strong class="source-inline">RegisterGameCompletions</strong> method with <strong class="source-inline">gameType</strong> as its parameter. This method is invoked by <span class="No-Break">SignalR clients.</span></p>
			<p>Using SignalR, a hub can send real-time information to all clients, one client, or a group of clients. With this implementation, we allow clients to register with a group. Game types are used to differentiate different groups. The <strong class="source-inline">Hub</strong> class defines a <strong class="source-inline">Groups</strong> property to subscribe and unsubscribe from a group. The <strong class="source-inline">AddToGroupAsync</strong> method adds the client and <strong class="source-inline">RemoveFromGroupAsync</strong> removes the client from the group. A connected client can be identified using <strong class="source-inline">ConnectionId</strong>, which can be accessed using the <span class="No-Break"><strong class="source-inline">Context</strong></span><span class="No-Break"> property.</span></p>
			<p>To send information to connected clients, the <strong class="source-inline">Hub</strong> class offers the <strong class="source-inline">Clients</strong> property, which allows you to send to all clients (<strong class="source-inline">Clients.All.SendAsync</strong>), or a group (<strong class="source-inline">Clients.Group("group-name").SendAsync</strong>). However, in this case, we need to send the information outside of the <strong class="source-inline">LiveHub</strong> class (after receiving a REST invocation) from the <strong class="source-inline">game-apis</strong> service. We’ll do this by implementing the <span class="No-Break"><strong class="source-inline">LiveGamesEndpoints</strong></span><span class="No-Break"> class.</span></p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor322"/>Returning live information to the clients</h2>
			<p>The <strong class="source-inline">LiveGamesEndpoints</strong> class uses<a id="_idIndexMarker1043"/> minimal APIs to implement a REST endpoint. What’s special is that it can send information to <span class="No-Break">connected clients:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Endpoints/LiveGamesEndpoints.cs</p>
			<pre class="source-code">
public static class LiveGamesEndpoints
{
  public static void MapLiveGamesEndpoints(this IEndpointRouteBuilder routes, ILogger logger)
  {
    var group = routes.MapGroup("/live")
      .WithTags("Game Events API");
<strong class="bold">    group.MapPost("/game", async (GameSummary gameSummary, </strong>
<strong class="bold">      IHubContext&lt;LiveHub&gt; hubContext) =&gt;</strong>
    {
      logger.LogInformation("Received game ended {type} {gameid}", 
        gameSummary.GameType, gameSummary.Id);
<strong class="bold">      await hubContext.Clients.Group(gameSummary.GameType).</strong>
        <strong class="bold">SendAsync("GameCompleted", gameSummary);</strong>
      return TypedResults.Ok();
    })
    .WithName("ReportGameEnded")
    .WithSummary("Report game ended to notify connected clients")
    .WithOpenApi();
  }
}</pre>
			<p>The <strong class="source-inline">GameSummary</strong> class that’s received by the <strong class="source-inline">MapPost</strong> method is implemented in the <strong class="source-inline">CNinnovation.Codebreaker.BackendModels</strong> NuGet package. This class contains summary information of a <a id="_idIndexMarker1044"/>completed game. Along with this HTTP POST body parameter, the <strong class="source-inline">MapPost</strong> method receives an <strong class="source-inline">IHubContext&lt;LiveHub&gt;</strong> instance from the DI container. This interface is registered when the DI container is configured for SignalR to retrieve a context to the registered hub to send information to clients. Using the <strong class="source-inline">Clients.Group</strong> method, when <a id="_idIndexMarker1045"/>passing the name of the group, an <strong class="source-inline">IClientProxy</strong> object is returned. This proxy is then used to send the <strong class="source-inline">GameCompleted</strong> method with the <span class="No-Break">game summary.</span></p>
			<p>Now, all we need to do is register SignalR and the hub with the DI container and <span class="No-Break">the middleware.</span></p>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor323"/>Registering SignalR services and the hub</h2>
			<p>To use SignalR, and to make the <a id="_idIndexMarker1046"/>hub available as an endpoint, we <a id="_idIndexMarker1047"/>must implement the <span class="No-Break"><strong class="source-inline">ApplicationServices</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/ApplicationServices.cs</p>
			<pre class="source-code">
public static class ApplicationServices
{
  public static void AddApplicationServices(this IHostApplicationBuilder builder)
  {
<strong class="bold">    builder.Services.AddSignalR();</strong>
    // code removed for brevity
  }
  public static WebApplication MapApplicationEndpoints(this WebApplication app, ILogger logger)
  {
<strong class="bold">    app.MapLiveGamesEndpoints(logger);</strong>
<strong class="bold">    </strong><strong class="bold">app.MapHub&lt;LiveHub&gt;("/livesubscribe");</strong>
    return app;
  }
}</pre>
			<p>The <strong class="source-inline">AddApplicationServices</strong> method extends <strong class="source-inline">IHostApplicationBuilder</strong> to register the<a id="_idIndexMarker1048"/> service classes that are needed for SignalR by invoking the <strong class="source-inline">AddSignalR</strong> method. The <strong class="source-inline">MapApplicationEndpoints</strong> method registers <a id="_idIndexMarker1049"/>the SignalR hub and minimal API endpoint. The SignalR hub is registered with the endpoints by passing the <strong class="source-inline">Hub</strong> class with the generic parameter of the <strong class="source-inline">MapHub</strong> method. <strong class="source-inline">/livesubscribe</strong> is the link that’s used by clients to connect to <span class="No-Break">this service.</span></p>
			<p>The methods of the <strong class="source-inline">ApplicationServices</strong> class are invoked from the top-level statements of the <span class="No-Break">SignalR project:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Program.cs</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
<strong class="bold">builder.AddServiceDefaults();</strong>
<strong class="bold">builder.AddApplicationServices();</strong>
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
var app = <strong class="bold">builder.Build();</strong>
<strong class="bold">app.MapDefaultEndpoints();</strong>
<strong class="bold">app.MapApplicationEndpoints(app.Logger);</strong>
app.Run();</pre>
			<p>The DI container is configured by invoking the <strong class="source-inline">AddServiceDefaults</strong> method, which is defined by the <a id="_idIndexMarker1050"/>common <strong class="source-inline">ServiceDefaults</strong> project. This adds the DI container registration that’s <a id="_idIndexMarker1051"/>needed by all projects of the solution. The <strong class="source-inline">AddApplicationServices</strong> method adds the services that are needed from <strong class="source-inline">live-service</strong>, such as SignalR. Using <strong class="source-inline">builder.Build</strong> concludes the information that’s needed via the DI container. The app instance starts configuring the middleware, which is where <strong class="source-inline">MapDefaultEndpoints</strong> and <strong class="source-inline">MapApplicationEndpoints</strong> are invoked. <strong class="source-inline">MapDefaultEndpoints</strong> registers links such as common health checks (covered in <a href="B21217_12.xhtml#_idTextAnchor294"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>). <strong class="source-inline">MapApplicationEndpoints</strong> registers the endpoints offered by this <span class="No-Break">service project.</span></p>
			<p>Now that <strong class="source-inline">live-service</strong> is ready to go, let’s call the API from the <span class="No-Break"><strong class="source-inline">game-apis</strong></span><span class="No-Break"> service.</span></p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor324"/>Forwarding requests from the game-apis service</h2>
			<p>Recall the sequence<a id="_idIndexMarker1052"/> diagram from earlier. We’ve updated this diagram to show how <strong class="source-inline">game-apis</strong> and <span class="No-Break"><strong class="source-inline">live-service</strong></span><span class="No-Break"> communicate:</span></p>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="image/B21217_13_02.jpg" alt="Figure 13.2 – REST calls to live-service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – REST calls to live-service</p>
			<p>After a game is completed, the <strong class="source-inline">game-apis</strong> service invokes <strong class="source-inline">live-service</strong> with game completion information. To invoke <strong class="source-inline">live-service</strong>, create the <strong class="source-inline">LiveReportClient</strong> class, which<a id="_idIndexMarker1053"/> <span class="No-Break">injects </span><span class="No-Break"><strong class="source-inline">HttpClient</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/LiveReportClient.cs</p>
			<pre class="source-code">
<strong class="bold">public class LiveReportClient(HttpClient httpClient, ILogger&lt;LiveReportClient&gt; logger)</strong> : ILiveReportClient
{
  private readonly static JsonSerializerOptions s_jsonOptions = new()
  {
    PropertyNameCaseInsensitive = true
  };
<strong class="bold">  public async Task ReportGameEndedAsync(GameSummary gameSummary, </strong>
    <strong class="bold">CancellationToken cancellationToken = default)</strong>
<strong class="bold">  {</strong>
    try
    {
<strong class="bold">      await httpClient.PostAsJsonAsync("/live/game", gameSummary, </strong>
        <strong class="bold">options: s_jsonOptions, cancellationToken: cancellationToken);</strong>
    }
    catch (Exception ex) when (ex is HttpRequestException or 
      TaskCanceledException or JsonException)
    {
      logger.ErrorWritingGameCompletedEvent(gameSummary.Id, ex);
    }
  }
}</pre>
			<p>The <strong class="source-inline">ReportGameEndedAsync</strong> method uses the <strong class="source-inline">HttpClient</strong> class to make an HTTP POST request to <strong class="source-inline">/live/game</strong> and send <span class="No-Break"><strong class="source-inline">GameSummary</strong></span><span class="No-Break"> information.</span></p>
			<p>Let’s configure the <strong class="source-inline">HttpClient</strong> class by <a id="_idIndexMarker1054"/>updating the <span class="No-Break"><strong class="source-inline">ApplicationServices</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder builder)
{
  // code removed for brevity
  builder.Services.AddScoped&lt;IGamesService, GamesService&gt;();
<strong class="bold">  builder.Services.AddHttpClient&lt;ILiveReportClient, </strong>
    <strong class="bold">LiveReportClient&gt;(client =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    client.BaseAddress = new Uri("https+http://live");</strong>
<strong class="bold">  });</strong>
  builder.AddRedisDistributedCache("redis");
}</pre>
			<p>Using .NET Aspire<a id="_idIndexMarker1055"/> orchestration, the URL of the live client is retrieved by using service discovery with the <strong class="source-inline">https+http://live</strong> expression. This expression prefers the <strong class="source-inline">https</strong> schema, but if it isn’t available, it uses the <strong class="source-inline">http</strong> schema. The name is resolved with service discovery via the app model, as explained in <a href="B21217_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<p>With that, <strong class="source-inline">game-apis</strong> has been configured to send game summary information. Now, all we need to do is create a client that receives real-time information from the <span class="No-Break">SignalR service.</span></p>
			<h1 id="_idParaDest-326"><a id="_idTextAnchor325"/>Creating a SignalR client</h1>
			<p>As a simple client<a id="_idIndexMarker1056"/> receiving real-time information, all we need is a console application that connects to <strong class="source-inline">live-service</strong>. By doing this, it’s simple to implement this functionality with any <span class="No-Break">other client.</span></p>
			<p>Start by creating a <span class="No-Break">console project:</span></p>
			<pre class="console">
dotnet new console -o LiveTestClient</pre>
			<p>The <strong class="source-inline">Microsoft.AspNetCore.SignalR.Client</strong> NuGet package needs to be added to call a SignalR service. We must also add <strong class="source-inline">Microsoft.Extensions.Hosting</strong> for the DI container and <strong class="source-inline">CNinnovation.Codebreaker.BackendModels</strong> with the <span class="No-Break"><strong class="source-inline">GameSummary</strong></span><span class="No-Break"> type.</span></p>
			<p>Create the <strong class="source-inline">LiveClient</strong> class, which will communicate with the <span class="No-Break">SignalR service:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/LiveClient.cs</p>
			<pre class="source-code">
<strong class="bold">internal class LiveClient(IOptions&lt;LiveClientOptions&gt; options) : IAsyncDisposable</strong>
{
  // code removed for brevity
}
public class LiveClientOptions
{
  public string? LiveUrl { get; set; }
}</pre>
			<p>The <strong class="source-inline">LiveClient</strong> class specifies a constructor with <strong class="source-inline">IOptions&lt;LiveClientOptions&gt;</strong>. This will be configured with the DI container so that it can pass the URL string <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">live-service</strong></span><span class="No-Break">.</span></p>
			<p>Add <strong class="source-inline">appsettings.json</strong> to configure <span class="No-Break">the URL:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/appsettings.json</p>
			<pre class="source-code">
{
  "Codebreaker.Live": {
    "LiveUrl": "http://localhost:5130/livesubscribe"
  }
}</pre>
			<p>For local testing, the port number needs to match the port number that’s specified with <strong class="source-inline">launchSettings.json</strong>. Don’t forget to <a id="_idIndexMarker1057"/>configure so that <strong class="source-inline">appsettings.json</strong> is copied to the <span class="No-Break">output directory.</span></p>
			<p>The connection to the service is initiated by the <span class="No-Break"><strong class="source-inline">StartMonitorAsync</strong></span><span class="No-Break"> method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/LiveClient.cs</p>
			<pre class="source-code">
internal class LiveClient(IOptions&lt;LiveClientOptions&gt; options) : IAsyncDisposable
{
  private HubConnection? _hubConnection;
<strong class="bold">  public async Task StartMonitorAsync(CancellationToken </strong>
    <strong class="bold">cancellationToken = default)</strong>
  {
    string liveUrl = options.Value.LiveUrl ??
      throw new InvalidOperationException("LiveUrl not configured");
<strong class="bold">    _hubConnection = new HubConnectionBuilder()</strong>
<strong class="bold">      .WithUrl(liveUrl)</strong>
<strong class="bold">      .Build();</strong>
<strong class="bold">    _hubConnection.On("GameCompleted", (GameSummary summary) =&gt;</strong>
<strong class="bold">    </strong><strong class="bold">{</strong>
<strong class="bold">      string status = summary.IsVictory ? "won" : "lost";</strong>
<strong class="bold">      Console.WriteLine($"Game {summary.Id} {status} by {summary.</strong>
        <strong class="bold">PlayerName} after " +</strong>
<strong class="bold">        "{summary.Duration:g}  with {summary.NumberMoves} moves");</strong>
<strong class="bold">    });</strong>
<strong class="bold">    await _hubConnection.StartAsync(cancellationToken);</strong>
  }
  // code removed for brevity
  public async ValueTask DisposeAsync()
  {
    if (_hubConnection is not null)
    {
      await _hubConnection.DisposeAsync();
    }
  }
}</pre>
			<p>To connect to the SignalR hub, <strong class="source-inline">HubConnectionBuilder</strong> is used to set up a connection. With this builder, the connection can be configured – for example, logging, server timeout, and <a id="_idIndexMarker1058"/>reconnect behaviors can be set up. The connection is then initiated by invoking the <span class="No-Break"><strong class="source-inline">StartAsync</strong></span><span class="No-Break"> method.</span></p>
			<p>The <strong class="source-inline">On</strong> method of <strong class="source-inline">HubConnection</strong> configures the receiving side: when a <strong class="source-inline">GameCompleted</strong> message is received, the <strong class="source-inline">GameSummary</strong> parameter specifies the data that’s been received and writes a message about the game to the console. The name <strong class="source-inline">GameCompleted</strong> needs to match the name that has been passed with the <strong class="source-inline">SendAsync</strong> method of <span class="No-Break">the service.</span></p>
			<p>To subscribe to the messages from the service, implement the <span class="No-Break"><strong class="source-inline">SubscribeToGame</strong></span><span class="No-Break"> method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/LiveClient.cs</p>
			<pre class="source-code">
public async Task SubscribeToGame(string gameType, CancellationToken cancellationToken = default)
{
  if (_hubConnection is null) throw new InvalidOperationException("Start a connection first");
<strong class="bold">  await _hubConnection.InvokeAsync("SubscribeToGameCompletions", </strong>
    <strong class="bold">gameType, cancellationToken);</strong>
}</pre>
			<p>With this implementation, the <strong class="source-inline">InvokeAsync</strong> method of <strong class="source-inline">HubConnection</strong> is used. <strong class="source-inline">SubscribeToGameCompletions</strong> matches <a id="_idIndexMarker1059"/>the name of the hub method, which uses the <span class="No-Break"><strong class="source-inline">game-type</strong></span><span class="No-Break"> parameter.</span></p>
			<p>The top-level statements of the client application make use of the <span class="No-Break"><strong class="source-inline">LiveClient</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/Program.cs</p>
			<pre class="source-code">
Console.WriteLine("Test client - wait for service, then press return to continue");
Console.ReadLine();
var builder = Host.CreateApplicationBuilder(args);
builder.Services.AddSingleton&lt;LiveClient&gt;();
builder.Services.Configure&lt;LiveClientOptions&gt;(builder.Configuration.GetSection("Codebreaker.Live"));
using var host = builder.Build();
<strong class="bold">var client = host.Services.GetRequiredService&lt;LiveClient&gt;();</strong>
<strong class="bold">await client.StartMonitorAsync();</strong>
<strong class="bold">await client.SubscribeToGame("Game6x4");</strong>
await host.RunAsync();
Console.WriteLine("Bye...");</pre>
			<p>After configuring the <strong class="source-inline">LiveClient</strong> class in the DI container, the <strong class="source-inline">StartMonitorAsync</strong> and <strong class="source-inline">SubscribeToGame</strong> methods <span class="No-Break">are invoked.</span></p>
			<p>With this in place, you can start the AppHost so that it runs all the services and multiple instances of the client application. Use <strong class="source-inline">bot-service</strong> to play multiple games. You’ll see success messages<a id="_idIndexMarker1060"/> from the bot, as shown in <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/B21217_13_03.jpg" alt="Figure 13.3 – Live client receiving game summaries"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Live client receiving game summaries</p>
			<p>Using the bot, multiple games have been started with a think time of 0 and 1 seconds between game moves. These<a id="_idIndexMarker1061"/> results show game wins that occur between 0.27 and <span class="No-Break">4.79 seconds.</span></p>
			<h1 id="_idParaDest-327"><a id="_idTextAnchor326"/>Changing the serialization protocol</h1>
			<p>By default, SignalR <a id="_idIndexMarker1062"/>serializes messages with JSON. Using the <strong class="source-inline">Microsoft.AspNetCore.SignalR.Protocols.MessagePack</strong> NuGet package, a binary serialization format can be used instead. This is an optimization that reduces the data <span class="No-Break">that’s sent.</span></p>
			<p>To support this, all we need to do is update the DI configuration in the service, after adding the <span class="No-Break">NuGet package:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder builder)
{
  builder.Services.AddSignalR()
<strong class="bold">    .AddMessagePackProtocol();</strong>
}
// code removed for brevity</pre>
			<p>The <strong class="source-inline">AddMessagePackProtocol</strong> method adds <strong class="source-inline">MessagePack</strong> as another option for serialization. JSON is <span class="No-Break">still available.</span></p>
			<p>Regarding the client, the same NuGet package is required, but this time with the <span class="No-Break">following configuration:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/LiveClient.cs</p>
			<pre class="source-code">
string liveUrl = options.Value.LiveUrl ?? throw new InvalidOperationException("LiveUrl not configured");
_hubConnection = new HubConnectionBuilder()
  .WithUrl(liveUrl)
<strong class="bold">  .ConfigureLogging(logging =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    logging.AddConsole();</strong>
<strong class="bold">    logging.SetMinimumLevel(LogLevel.Debug);</strong>
<strong class="bold">  })</strong>
<strong class="bold">  .AddMessagePackProtocol()</strong>
  .Build();</pre>
			<p>Like the server, the same NuGet package for the protocol is needed for the client, as well as the <strong class="source-inline">AddMessagePackProtocol</strong> API. With the client, logging is now turned on as well. Logging providers for SignalR can be configured using the <strong class="source-inline">ConfigureLogging</strong> method. Here, the console provider is added, and the minimum logging level is set to <strong class="source-inline">LogLevel.Debug</strong>. With this, we can see all communication between the client and the server, including the message protocols that are used and the ping messages that <a id="_idIndexMarker1063"/><span class="No-Break">are sent.</span></p>
			<p>When using MessagePack, you need to be aware of an important restriction: <strong class="source-inline">DateTime.Kind</strong> is not serialized. Thus, this type should be converted into UTC before <span class="No-Break">being sent.</span></p>
			<p>With this in place, you can <a id="_idIndexMarker1064"/>start the solution again, start the bot to play some games, and start the SignalR client. When you look at the logging information, you’ll see WebSockets and MessagePack <span class="No-Break">in action:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Logging from the client application</p>
			<pre class="source-code">
<strong class="bold">dbug: Microsoft.AspNetCore.SignalR.Client.HubConnection[40]</strong>
<strong class="bold">  Registering handler for client method 'GameCompleted'.</strong>
// some log outputs removed for clarity
<strong class="bold">dbug: Microsoft.AspNetCore.Http.Connections.Client.HttpConnection[8]</strong>
<strong class="bold">  Establishing connection with server at 'http://localhost:5130/livesubscribe'.</strong>
<strong class="bold">dbug: Microsoft.AspNetCore.Http.Connections.Client.HttpConnection[9]</strong>
<strong class="bold">  Established connection '1YXBdJ3Yi7A_86ZqoMKgiA' with the server.</strong>
<strong class="bold">info: Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport[1]</strong>
<strong class="bold">  Starting transport. Transfer mode: Binary. Url: 'ws://localhost:5130/livesubscribe?id=CHpPUMdrJoxV0zLHsskN1Q'.</strong>
<strong class="bold">dbug: Microsoft.AspNetCore.Http.Connections.Client.HttpConnection[18]</strong>
<strong class="bold">      Transport 'WebSockets' started.</strong>
<strong class="bold">info: Microsoft.AspNetCore.SignalR.Client.HubConnection[24]</strong>
<strong class="bold">      Using HubProtocol 'messagepack v1'.</strong>
<strong class="bold">dbug: Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport[13]</strong>
<strong class="bold">      Received message from application. Payload size: 39.</strong></pre>
			<p>Now that we’ve switched the serialization format, let’s reduce the load from the service when a larger number <a id="_idIndexMarker1065"/>of clients is connected by using Azure <span class="No-Break">SignalR Service.</span></p>
			<h1 id="_idParaDest-328"><a id="_idTextAnchor327"/>Using Azure SignalR Service</h1>
			<p>There’s some overhead <a id="_idIndexMarker1066"/>associated with SignalR since the server has open connections with all <span class="No-Break">SignalR clients.</span></p>
			<p>To remove this overhead from our services, we can use <strong class="bold">Azure SignalR Service</strong>. This service acts as an intermediary between clients and the SignalR service, as depicted in <span class="No-Break"><em class="italic">Figure 11</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/B21217_13_04.jpg" alt="Figure 1﻿3.4 – Using Azure SignalR Service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Using Azure SignalR Service</p>
			<p>The preceding figure <a id="_idIndexMarker1067"/>shows multiple monitor clients that each have a connection open to Azure SignalR Service. <strong class="source-inline">live-service</strong> just needs to deal with a single connection. Azure SignalR subscribes to the events and forwards them to a single client, a group of clients, or all clients, as specified <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">live-service</strong></span><span class="No-Break">.</span></p>
			<p>The load for every client connection is handled by Azure SignalR Service, while this service just acts as a single client to the <span class="No-Break">SignalR service.</span></p>
			<p>A free version of this service without SLA that’s limited to 20 connections and 20,000 messages per day can be used for development purposes. Standard and premium SKUs can scale up to 1,000 connections per unit, 100 units, and <span class="No-Break">unlimited messages.</span></p>
			<p>To activate Azure SignalR Service within the app model, we need to update <strong class="source-inline">app-model</strong> within the <span class="No-Break">AppHost project:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = DistributedApplication.CreateBuilder(args);
<strong class="bold">var signalR = builder.AddAzureSignalR("signalr");</strong>
// code removed for brevity
var live = builder.AddProject&lt;Projects.Codebreaker_Live&gt;("live")
  .WithExternalHttpEndpoints()
  .WithReference(appInsights)
<strong class="bold">  .WithReference(signalR);</strong></pre>
			<p>With .NET Aspire provisioning, Azure SignalR Service is created when the application is started. When using the <strong class="source-inline">WithReference</strong> method, the URI is forwarded to the <strong class="source-inline">Codebreaker.Live</strong> service. Here, the <strong class="source-inline">Microsoft.Azure.SignalR</strong> NuGet package is required to <a id="_idIndexMarker1068"/>connect <span class="No-Break">this service:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder builder)
{
  var signalRBuilder = builder.Services.AddSignalR()
    .AddMessagePackProtocol();
  if (Environment.GetEnvironmentVariable("StartupMode") != "OnPremises")
  {
<strong class="bold">      signalRBuilder.AddNamedAzureSignalR("signalr");</strong>
<strong class="bold">  }</strong>
}</pre>
			<p>Using <strong class="source-inline">AddNamedAzureSignalR</strong>, the connection string is retrieved via service discovery, and the SignalR hub is connected to this <span class="No-Break">Azure service.</span></p>
			<p>Now, start the application again and check the Azure portal to see that the service has been created. Use the Aspire dashboard to see the environment variable that’s been assigned to the <strong class="source-inline">Codebreaker.Live</strong> service, and check the logs to see the connections that have been made to Azure SignalR Service. Run the bot so that it plays several games and then start several SignalR client (<span class="No-Break"><strong class="source-inline">LiveTestClient</strong></span><span class="No-Break">) processes.</span></p>
			<p>When you open the Azure portal, open the resource group of the developer environment (<strong class="source-inline">rg-aspire-&lt;yourhost&gt;-codebreaker.apphost</strong>) and select Azure SignalR Service. In <a id="_idIndexMarker1069"/>the <strong class="bold">Monitoring</strong> category in the left bar, select <strong class="bold">Live trace settings</strong>. Click the <strong class="bold">Enable Live Trace</strong> checkbox and choose to collect information for <strong class="bold">ConnectivityLogs</strong>, <strong class="bold">MessagingLogs</strong>, and <strong class="bold">HttpRequestLogs</strong>. Then, click the <strong class="bold">Open Live Trace Tool</strong> button. You’ll receive the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/B21217_13_05.jpg" alt="Figure 13.5 – Azure SignalR Service live trace. This screenshot only intends to show the output result page; text readability is not essential"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Azure SignalR Service live trace. This screenshot only intends to show the output result page; text readability is not essential</p>
			<p>With the Azure SignalR Service live trace, you can see all the messages that have been sent from the Codebreaker <a id="_idIndexMarker1070"/>live service, as well as the messages that have been sent to the <span class="No-Break">subscribing clients.</span></p>
			<p>To see metrics data, go back (or open a new browser window) to the <strong class="bold">Overview</strong> page of Azure SignalR Service. There, you can see the number of connections that have been opened, as shown in <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="image/B21217_13_06.jpg" alt="Figure 13.6 – Azure SignalR Service connection metrics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – Azure SignalR Service connection metrics</p>
			<p><span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.7</em> shows the number <a id="_idIndexMarker1071"/>of messages that have <span class="No-Break">been sent:</span></p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/B21217_13_07.jpg" alt="Figure 13.7 – Azure SignalR Sevice message metrics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – Azure SignalR Sevice message metrics</p>
			<p>Now that everything is up and running, you’ve earned a well-deserved break so that you can play some <a id="_idIndexMarker1072"/>games (which you can monitor <span class="No-Break">as well).</span></p>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor328"/>Summary</h1>
			<p>In this chapter, you learned how to offer real-time data using SignalR. You created a live service containing a SignalR hub that offers real-time information about completed games. Clients can register to a subset – a group – of the information offered. You also created a simple console application that acts as a client. The same functionality can be implemented in other clients. You can check this out in the Blazor client application provided in this book’s GitHub repository, which contains the SignalR <span class="No-Break">client functionality.</span></p>
			<p>Then, you learned how to use Azure SignalR Service, which reduces the load on the service hosting the SignalR hub as the clients directly interact with Azure SignalR Service while this service acts as one client <span class="No-Break">to SignalR.</span></p>
			<p>With the implementation of this chapter, we created a REST API that’s invoked by the <strong class="source-inline">game-apis</strong> service to send completed games. REST is great for easy communication with all clients, but it doesn’t offer the best performance. The only client for the <strong class="source-inline">Codebreaker.Live</strong> service is the <span class="No-Break"><strong class="source-inline">game-apis</strong></span><span class="No-Break"> service.</span></p>
			<p>Regarding service-to-service communication, instead of using REST APIs, less overhead is used when binary serialization is used alongside protocols such as gRPC. This will be covered in the <span class="No-Break">next chapter.</span></p>
			<h1 id="_idParaDest-330"><a id="_idTextAnchor329"/>Further reading</h1>
			<p>To learn more about the topics that were discussed in this chapter, please refer to the <span class="No-Break">following links:</span></p>
			<ul>
				<li><em class="italic">ASP.NET Core </em><span class="No-Break"><em class="italic">SignalR</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction"><span class="No-Break">https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction</span></a></li>
				<li><em class="italic">Message Pack </em><span class="No-Break"><em class="italic">protocol</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol"><span class="No-Break">https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol</span></a></li>
				<li><em class="italic">Azure SignalR </em><span class="No-Break"><em class="italic">Service</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview"><span class="No-Break">https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview</span></a></li>
				<li>.<em class="italic">NET Aspire support for Azure SignalR </em><span class="No-Break"><em class="italic">Service</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/dotnet/aspire/real-time/azure-signalr-scenario"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/aspire/real-time/azure-signalr-scenario</span></a></li>
			</ul>
		</div>
	</body></html>