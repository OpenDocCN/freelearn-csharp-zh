- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Exploring Validation and Mapping
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索验证和映射
- en: In this chapter of the book, we will discuss how to perform data validation
    and mapping with minimal APIs, showing what features we currently have, what is
    missing, and what the most interesting alternatives are. Learning about these
    concepts will help us to develop more robust and maintainable applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的本章中，我们将讨论如何使用最少的API执行数据验证和映射，展示我们目前拥有的功能，缺少什么，以及最有趣的替代方案是什么。了解这些概念将帮助我们开发更健壮和可维护的应用程序。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Handling validation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理验证
- en: Mapping data to and from APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据映射到和从API
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the descriptions in this chapter, you will need to create an ASP.NET
    Core 6.0 Web API application. Refer to the *Technical requirements* section in
    [*Chapter 2*](B17902_02.xhtml#_idTextAnchor023), *Exploring Minimal APIs and Their
    Advantages*, for instructions on how to do so.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的描述，你需要创建一个ASP.NET Core 6.0 Web API应用程序。请参考[*第2章*](B17902_02.xhtml#_idTextAnchor023)中的*技术要求*部分，*探索最小API及其优势*，以获取如何创建的说明。
- en: If you’re using your console, shell, or bash terminal to create the API, remember
    to change your working directory to the current chapter number (`Chapter06`).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用你的控制台、shell或bash终端创建API，请记住将你的工作目录更改为当前章节号（`Chapter06`）。
- en: All the code samples in this chapter can be found in the GitHub repository for
    this book at [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都可以在本书的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06)。
- en: Handling validation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理验证
- en: '`Person` object has both the `FirstName` and `LastName` properties defined,
    an email address is valid, or an appointment date isn’t in the past.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`对象定义了`FirstName`和`LastName`属性，电子邮件地址有效，或者预约日期不是过去的。'
- en: 'In controller-based projects, we can perform these checks, also termed `ApiController`
    attribute that is placed on a controller makes model validation errors automatically
    trigger a `400 Bad Request` response if one or more validation rules fail. Therefore,
    in controller-based projects, we typically don’t need to perform explicit model
    validation at all: if the validation fails, our endpoint will never be invoked.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于控制器的项目中，我们可以执行这些检查，也称为放置在控制器上的`ApiController`属性，如果验证规则失败，将自动触发`400 Bad Request`响应。因此，在基于控制器的项目中，我们通常根本不需要执行显式的模型验证：如果验证失败，我们的端点将永远不会被调用。
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `ApiController` attribute enables the automatic model validation behavior
    using the `ModelStateInvalidFilter` action filter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApiController`属性通过使用`ModelStateInvalidFilter`操作过滤器启用自动模型验证行为。'
- en: Unfortunately, minimal APIs do not provide built-in support for validation.
    The `IModelValidator` interface and all related objects cannot be used. Thus,
    we don’t have a `ModelState`; we can’t prevent the execution of our endpoint if
    there is a validation error and must explicitly return a `400 Bad Request` response.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，最小API没有提供内置的验证支持。`IModelValidator`接口及其所有相关对象都不能使用。因此，我们没有`ModelState`；如果存在验证错误，我们无法阻止端点的执行，必须显式返回`400
    Bad Request`响应。
- en: 'So, for example, let’s see the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看以下代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see, the endpoint will be invoked even if the `Person` argument does
    not respect the validation rules. There is only one exception: if we use `400
    Bad Request` response. As mentioned in [*Chapter 2*](B17902_02.xhtml#_idTextAnchor023),
    *Exploring Minimal APIs and Their Advantages*, nullable reference types are enabled
    by default in .NET 6.0 projects.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，即使`Person`参数不遵守验证规则，端点也会被调用。只有一个例外：如果我们使用`400 Bad Request`响应。如[*第2章*](B17902_02.xhtml#_idTextAnchor023)中所述，*探索最小API及其优势*，在.NET
    6.0项目中默认启用了可空引用类型。
- en: If we want to accept a `null` body (if ever there was a need), we need to declare
    the parameter as `Person?`. But, as long as there is a body, the endpoint will
    always be invoked.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要接受`null`体（如果真的有需要的话），我们需要将参数声明为`Person?`。但是，只要存在体，端点总是会调用。
- en: So, with minimal APIs, it is necessary to perform validation inside each route
    handler and return the appropriate response if some rules fail. We can either
    implement a validation library compatible with the existing attributes so that
    we can perform validation using the classic data annotations approach, as described
    in the next section, or use a third-party solution such as `FluentValidation`,
    as we will see in the *Integrating FluentValidation* section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用最小API时，在路由处理程序内部执行验证并在某些规则失败时返回适当的响应是必要的。我们可以实现一个与现有属性兼容的验证库，以便我们可以使用经典的数据注释方法进行验证，如下一节所述，或者使用第三方解决方案，如我们将在
    *集成 FluentValidation* 节中看到的。
- en: Performing validation with data annotations
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据注释进行验证
- en: If we want to use the common validation pattern based on data annotations, we
    need to rely on `IsValid` methods, which are provided by the `ValidationAttribute`
    base class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用基于数据注释的通用验证模式，我们需要依赖于由 `ValidationAttribute` 基类提供的 `IsValid` 方法。
- en: This behavior is a simplification of what ASP.NET Core actually does to handle
    validations. However, this is the way validation in controller-based projects
    works.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是对 ASP.NET Core 实际处理验证的简化的描述。然而，这是基于控制器项目的验证方式。
- en: While we can also manually implement a solution of this kind with minimal APIs,
    if we decide to use data annotations for validation, we can leverage a small but
    interesting library, `MiniValidation`, which is available on GitHub ([https://github.com/DamianEdwards/MiniValidation](https://github.com/DamianEdwards/MiniValidation))
    and NuGet ([https://www.nuget.org/packages/MiniValidation](https://www.nuget.org/packages/MiniValidation)).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们也可以使用最小API手动实现此类解决方案，但如果我们决定使用数据注释进行验证，我们可以利用一个虽小但有趣的库，`MiniValidation`，它可在
    GitHub ([https://github.com/DamianEdwards/MiniValidation](https://github.com/DamianEdwards/MiniValidation))
    和 NuGet ([https://www.nuget.org/packages/MiniValidation](https://www.nuget.org/packages/MiniValidation))
    上找到。
- en: Important note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: At the time of writing, `MiniValidation` is available on NuGet as a prerelease.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`MiniValidation` 作为预发布版本在 NuGet 上提供。
- en: 'We can add this library to our project in one of the following ways:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式之一将此库添加到我们的项目中：
- en: '`MiniValidation`. Be sure to check the **Include prerelease** option and click
    **Install**.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MiniValidation`。请确保检查**包含预发布版本**选项，然后点击**安装**。'
- en: '**Option 2**: Open the **Package Manager Console** if you’re inside Visual
    Studio 2022, or open your console, shell, or bash terminal, go to your project
    directory, and execute the following command:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项 2**：如果您在 Visual Studio 2022 中，请打开**包管理器控制台**；或者打开您的控制台、shell 或 bash 终端，转到您的项目目录，并执行以下命令：'
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we can validate a `Person` object using the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码验证一个 `Person` 对象：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, the `MiniValidator.TryValidate` static method provided by `MiniValidation`
    takes an object as input and automatically verifies all the validation rules that
    are defined on its properties. If the validation fails, it returns `false` and
    populates the `out` parameter with all the validation errors that have occurred.
    In this case, because it is our responsibility to return the appropriate response
    code, we use `Results.ValidationProblem`, which produces a `400 Bad Request` response
    with a `ProblemDetails` object (as described in [*Chapter 3*](B17902_03.xhtml#_idTextAnchor038),
    *Working with Minimal APIs*) and also contains the validation issues.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`MiniValidation` 提供的 `MiniValidator.TryValidate` 静态方法接受一个对象作为输入，并自动验证其属性上定义的所有验证规则。如果验证失败，它将返回
    `false` 并将所有发生的验证错误填充到 `out` 参数中。在这种情况下，因为返回适当的响应代码是我们的责任，所以我们使用 `Results.ValidationProblem`，它生成一个带有
    `ProblemDetails` 对象的 `400 Bad Request` 响应（如[*第3章*](B17902_03.xhtml#_idTextAnchor038)，*使用最小API*）并包含验证问题。
- en: 'Now, as an example, we can invoke the endpoint using the following invalid
    input:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为一个例子，我们可以使用以下无效输入调用端点：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is the response we will obtain:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将获得的结果：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this way, besides the fact that we need to execute validation manually, we
    can implement the approach of using data annotations on our models in the same
    way we were accustomed to in previous versions of ASP.NET Core. We can also customize
    error messages and define custom rules by creating classes that inherit from `ValidationAttribute`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，除了我们需要手动执行验证之外，我们还可以以与之前版本的 ASP.NET Core 中相同的方式，在我们的模型上实现使用数据注释的方法。我们还可以通过创建继承自
    `ValidationAttribute` 的类来自定义错误消息和定义自定义规则。
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The full list of validation attributes available in ASP.NET Core 6.0 is published
    at [https://docs.microsoft.com/dotnet/api/system.componentmodel.dataannotations](https://docs.microsoft.com/dotnet/api/system.componentmodel.dataannotations).
    If you’re interested in creating custom attributes, you can refer to [https://docs.microsoft.com/aspnet/core/mvc/models/validation#custom-attributes](https://docs.microsoft.com/aspnet/core/mvc/models/validation#custom-attributes).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 6.0 中可用的完整验证属性列表发布在 [https://docs.microsoft.com/dotnet/api/system.componentmodel.dataannotations](https://docs.microsoft.com/dotnet/api/system.componentmodel.dataannotations)。如果您对创建自定义属性感兴趣，可以参考
    [https://docs.microsoft.com/aspnet/core/mvc/models/validation#custom-attributes](https://docs.microsoft.com/aspnet/core/mvc/models/validation#custom-attributes)。
- en: Although data annotations are the most used solution, we can also handle validations
    using a so-called fluent approach, which has the benefit of completely decoupling
    validation rules from the model, as we’ll see in the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数据注解是最常用的解决方案，但我们也可以使用所谓的流畅方法来处理验证，这种方法的好处是完全解耦验证规则与模型，正如我们将在下一节中看到的。
- en: Integrating FluentValidation
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成 FluentValidation
- en: In every application, it is important to correctly organize our code. This is
    also true for validation. While data annotations are a working solution, we should
    think about alternatives that can help us write more maintainable projects. This
    is the purpose of `FluentValidation` – a library, part of the **.NET Foundation**,
    that allows us to build validation rules using a fluent interface with lambda
    expressions. The library is available on GitHub ([https://github.com/FluentValidation/FluentValidation](https://github.com/FluentValidation/FluentValidation))
    and NuGet ([https://www.nuget.org/packages/FluentValidation](https://www.nuget.org/packages/FluentValidation)).
    This library can be used in any kind of project, but when working with ASP.NET
    Core, there is an ad-hoc NuGet package ([https://www.nuget.org/packages/FluentValidation.AspNetCore](https://www.nuget.org/packages/FluentValidation.AspNetCore))
    that contains useful methods that help to integrate it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个应用程序中，正确组织我们的代码都很重要。对于验证来说也是如此。虽然数据注解是一个可行的解决方案，但我们应该考虑其他可以帮助我们编写更易于维护的项目的方法。这就是
    `FluentValidation` 的目的——这是一个库，它是 **.NET 基金会** 的一部分，允许我们使用 lambda 表达式通过流畅接口构建验证规则。该库可在
    GitHub ([https://github.com/FluentValidation/FluentValidation](https://github.com/FluentValidation/FluentValidation))
    和 NuGet ([https://www.nuget.org/packages/FluentValidation](https://www.nuget.org/packages/FluentValidation))
    上找到。该库可用于任何类型的项目，但在使用 ASP.NET Core 时，有一个专门的 NuGet 包 ([https://www.nuget.org/packages/FluentValidation.AspNetCore](https://www.nuget.org/packages/FluentValidation.AspNetCore))，其中包含有助于集成的有用方法。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: .NET Foundation is an independent organization that aims to support open source
    software development and collaboration around the .NET platform. You can learn
    more at [https://dotnetfoundation.org](https://dotnetfoundation.org).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 基金会是一个旨在支持围绕 .NET 平台的开源软件开发和协作的独立组织。您可以在 [https://dotnetfoundation.org](https://dotnetfoundation.org)
    上了解更多信息。
- en: As stated before, with this library, we can decouple validation rules from the
    model to create a more structured application. Moreover, `FluentValidation` allows
    us to define even more complex rules with a fluent syntax without the need to
    create custom classes based on `ValidationAttribute`. The library also natively
    supports the localization of standard error messages.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用此库，我们可以将验证规则从模型中解耦，以创建更结构化的应用程序。此外，`FluentValidation` 允许我们使用流畅语法定义更复杂的规则，而无需基于
    `ValidationAttribute` 创建自定义类。该库还原生支持标准错误消息的本地化。
- en: 'So, let’s see how we can integrate `FluentValidation` into a minimal API project.
    First, we need to add this library to our project in one of the following ways:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看如何将 `FluentValidation` 集成到最小 API 项目中。首先，我们需要以下方式之一将此库添加到我们的项目中：
- en: '`FluentValidation.DependencyInjectionExtensions` and click **Install**.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击 **安装**。
- en: '**Option 2**: Open **Package Manager Console** if you’re inside Visual Studio
    2022, or open your console, shell, or bash terminal, go to your project directory,
    and execute the following command:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项 2**：如果您在 Visual Studio 2022 中，请打开 **包管理器控制台**；否则，打开您的控制台、shell 或 bash
    终端，进入您的项目目录，并执行以下命令：'
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can rewrite the validation rules for the `Person` object and put them
    in a `PersonValidator` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重写 `Person` 对象的验证规则，并将它们放入 `PersonValidator` 类中：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`PersonValidator` inherits from `AbstractValidator<T>`, a base class provided
    by `FluentValidation` that contains all the methods we need to define the validation
    rules. For example, we *fluently* say that we have a rule for the `FirstName`
    property, which is that it must not be empty and it can have a maximum length
    of `30` characters.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersonValidator` 继承自 `AbstractValidator<T>`，这是 `FluentValidation` 提供的一个基类，其中包含我们定义验证规则所需的所有方法。例如，我们
    *流畅地* 声明我们有一个针对 `FirstName` 属性的规则，即它不能为空，并且它的最大长度可以是 `30` 个字符。'
- en: 'The next step is to register the validator in the service provider so that
    we can use it in our route handlers. We can perform this task with a simple instruction:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将验证器注册到服务提供程序中，以便我们可以在我们的路由处理器中使用它。我们可以通过一个简单的指令来完成此任务：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `AddValidatorsFromAssemblyContaining` method automatically registers all
    the validators derived from `AbstractValidator` within the assembly containing
    the specified type. In particular, this method registers the validators and makes
    them accessible through dependency injection via the `IValidator<T>` interface,
    which in turn, is implemented by the `AbstractValidator<T>` class. If we have
    multiple validators, we can register them all with this single instruction. We
    can also easily put our validators in external assemblies.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddValidatorsFromAssemblyContaining` 方法会自动注册指定类型所在的程序集内所有从 `AbstractValidator`
    派生的验证器。特别是，此方法注册了验证器，并通过 `IValidator<T>` 接口使它们可通过依赖注入访问，而 `AbstractValidator<T>`
    类实现了该接口。如果我们有多个验证器，我们可以使用此单一指令将它们全部注册。我们还可以轻松地将我们的验证器放入外部程序集。'
- en: 'Now that everything is in place, remembering that with minimal APIs we don’t
    have automatic model validation, we must update our route handler in this way:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经就绪，记住，由于我们使用的是最小化 API，我们没有自动模型验证，因此我们必须以这种方式更新我们的路由处理器：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have added an `IValidator<Person>` argument in the route handler parameter
    list, so now we can invoke its `ValidateAsync` method to apply the validation
    rules against the input `Person` object. If the validation fails, we extract all
    the error messages and return them to the client with the usual `Results.ValidationProblem`
    method, as described in the previous section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在路由处理器参数列表中添加了一个 `IValidator<Person>` 参数，因此现在我们可以调用它的 `ValidateAsync` 方法来对输入的
    `Person` 对象应用验证规则。如果验证失败，我们将提取所有错误消息，并使用通常的 `Results.ValidationProblem` 方法将它们返回给客户端，如前文所述。
- en: 'In conclusion, let’s see what happens if we try to invoke the endpoint using
    the following input as before:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，让我们看看如果我们尝试使用之前相同的输入调用端点会发生什么：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’ll get the following response:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下响应：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As mentioned earlier, `FluentValidation` provides translations for standard
    error messages, so this is the response you get when running on an Italian system.
    Of course, we can completely customize the messages with the typical fluent approach,
    using the `WithMessage` method chained to the validation methods defined in the
    validator. For example, see the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`FluentValidation` 为标准错误消息提供翻译，因此这是在意大利系统上运行时得到的响应。当然，我们可以使用典型的流畅方法完全自定义消息，使用
    `WithMessage` 方法将消息链式连接到验证器中定义的验证方法。例如，请参见以下内容：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ll talk about localization in further detail in [*Chapter 9*](B17902_09.xhtml#_idTextAnchor125),
    *Leveraging Globalization and Localization*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 9 章*](B17902_09.xhtml#_idTextAnchor125) *利用全球化和本地化* 中更详细地讨论本地化问题。
- en: This is just a quick example of how to define validation rules with `FluentValidation`
    and use them with minimal APIs. This library allows many more complex scenarios
    that are comprehensively described in the official documentation available at
    [https://fluentvalidation.net](https://fluentvalidation.net).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个快速示例，说明如何使用 `FluentValidation` 定义验证规则，并使用最小化 API 来使用它们。这个库允许许多更复杂的场景，这些场景在官方文档中有详细描述，官方文档可在
    [https://fluentvalidation.net](https://fluentvalidation.net) 找到。
- en: Now that we have seen how to add validation to our route handlers, it is important
    to understand how we can update the documentation created by **Swagger** with
    this information.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何向我们的路由处理器添加验证，了解我们如何使用这些信息更新由 **Swagger** 创建的文档是很重要的。
- en: Adding validation information to Swagger
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Swagger 中添加验证信息
- en: 'Regardless of the solution that has been chosen to handle validation, it is
    important to update the OpenAPI definition with the indication that a handler
    can produce a validation problem response, calling the `ProducesValidationProblem`
    method after the endpoint declaration:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 无论选择哪种解决方案来处理验证，重要的是要更新OpenAPI定义，以表明处理程序可以生成验证问题响应，在端点声明后调用`ProducesValidationProblem`方法：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this way, a new response type for the `400 Bad Request` status code will
    be added to Swagger, as we can see in *Figure 6.1*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，将为`400 Bad Request`状态码添加一个新的响应类型到Swagger，正如我们在*图6.1*中可以看到的那样：
- en: '![Figure 6.1 – The validation problem response added to Swagger ](img/Figure_6.1_B17902.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 添加到Swagger中的验证问题响应](img/Figure_6.1_B17902.jpg)'
- en: Figure 6.1 – The validation problem response added to Swagger
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 添加到Swagger中的验证问题响应
- en: 'Moreover, the **JSON schemas** that are shown at the bottom of the Swagger
    UI can show the rules of the corresponding models. One of the benefits of defining
    validation rules using data annotations is that they are automatically reflected
    in these schemas:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Swagger UI底部显示的**JSON模式**可以显示相应模型的规则。使用数据注释定义验证规则的一个好处是它们会自动反映在这些模式中：
- en: '![Figure 6.2 – The validation rules for the Person object in Swagger ](img/Figure_6.2_B17902.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – Swagger中Person对象的验证规则](img/Figure_6.2_B17902.jpg)'
- en: Figure 6.2 – The validation rules for the Person object in Swagger
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – Swagger中Person对象的验证规则
- en: 'Unfortunately, validation rules defined with `FluentValidation` aren’t automatically
    shown in the JSON schema of Swagger. We can overcome this limitation by using
    `MicroElements.Swashbuckle.FluentValidation`, a small library that, as usual,
    is available on GitHub ([https://github.com/micro-elements/MicroElements.Swashbuckle.FluentValidation](https://github.com/micro-elements/MicroElements.Swashbuckle.FluentValidation))
    and NuGet ([https://www.nuget.org/packages/MicroElements.Swashbuckle.FluentValidation](https://www.nuget.org/packages/MicroElements.Swashbuckle.FluentValidation)).
    After adding it to our project, following the same steps described before for
    the other NuGet packages we have introduced, we just need to call the `AddFluentValidationRulesToSwagger`
    extension method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用`FluentValidation`定义的验证规则在Swagger的JSON模式中不会自动显示。我们可以通过使用`MicroElements.Swashbuckle.FluentValidation`这个小型库来克服这一限制，这个库通常可以在GitHub（[https://github.com/micro-elements/MicroElements.Swashbuckle.FluentValidation](https://github.com/micro-elements/MicroElements.Swashbuckle.FluentValidation)）和NuGet（[https://www.nuget.org/packages/MicroElements.Swashbuckle.FluentValidation](https://www.nuget.org/packages/MicroElements.Swashbuckle.FluentValidation)）上找到。将其添加到我们的项目中后，按照之前为其他NuGet包所描述的相同步骤，我们只需要调用`AddFluentValidationRulesToSwagger`扩展方法：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this way, the JSON schema shown in Swagger will reflect the validation rules,
    as with the data annotations. However, it’s worth remembering that, at the time
    of writing, this library does not support all the validators available in `FluentValidation`.
    For more information, we can refer to the GitHub page of the library.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，Swagger中显示的JSON模式将反映验证规则，就像数据注释一样。然而，值得注意的是，在撰写本文时，这个库并不支持`FluentValidation`中所有可用的验证器。更多信息，我们可以参考库的GitHub页面。
- en: 'This ends our overview of validation in minimal APIs. In the next section,
    we’ll analyze another important theme of every API: how to correctly handle the
    mapping of data to and from our services.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对最小API中验证的概述。在下一节中，我们将分析每个API的一个重要主题：如何正确处理数据到和从我们的服务映射。
- en: Mapping data to and from APIs
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据到和从API映射
- en: 'When dealing with APIs that can be called by any system, there is one golden
    rule: *we should never expose our internal objects to the callers*. If we don’t
    follow this decoupling idea and, for some reason, need to change our internal
    data structures, we could end up breaking all the clients that interact with us.
    Both the internal data structures and the objects that are used to dialog with
    the clients must be able to evolve independently from one another.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理任何系统都可以调用的API时，有一条黄金法则：*我们绝不应该向调用者暴露我们的内部对象*。如果我们不遵循这种解耦思想，并且出于某种原因需要更改我们的内部数据结构，我们可能会破坏所有与我们交互的客户端。内部数据结构和用于与客户端对话的对象必须能够独立于彼此进化。
- en: 'This requirement for dialog is the reason why **mapping** is so important.
    We need to transform input objects of one type into output objects of a different
    type and vice versa. In this way, we can achieve two objectives:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对话需求是**映射**之所以如此重要的原因。我们需要将一种类型的输入对象转换为另一种类型的输出对象，反之亦然。这样，我们可以实现两个目标：
- en: Evolve our internal data structures without introducing breaking changes with
    the contracts that are exposed to the callers
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不引入对调用者暴露的合约的破坏性更改的情况下，改进我们的内部数据结构
- en: Modify the format of the objects used to communicate with the clients without
    the need to change the way these objects are handled internally
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改用于与客户端通信的对象的格式，而无需更改这些对象内部处理的方式
- en: In other words, mapping means transforming one object into another, literally,
    by copying and converting an object’s properties from a source to a destination.
    However, mapping code is boring, and testing mapping code is even more boring.
    Nevertheless, we need to fully understand that the process is crucial and strive
    to adopt it in all scenarios.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，映射意味着通过复制和转换对象属性从源到目的地来将一个对象转换为另一个对象。然而，映射代码很无聊，测试映射代码更是无聊。尽管如此，我们需要完全理解这个过程的重要性，并努力在所有场景中采用它。
- en: 'So, let’s consider the following object, which could represent a person saved
    in a database using Entity Framework Core:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们考虑以下对象，它可能代表使用Entity Framework Core保存到数据库中的人员：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have set endpoints for getting a list of people or retrieving a specific
    person.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了获取人员列表或检索特定人员的端点。
- en: 'The first thought could be to directly return `PersonEntity` to the caller.
    The following code is highly simplified, enough for us to understand the scenario:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个想法可能是直接将`PersonEntity`返回给调用者。以下代码高度简化，足以让我们理解这个场景：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What happens if we need to modify the schema of the database, adding, for example,
    the creation date of the entity? In this case, we need to change `PersonEntity`
    with a new property that maps the relevant date. However, the callers also get
    this information now, which we probably don’t want to be exposed. Instead, if
    we use a so-called **data transformation object** (**DTO**) to expose the person,
    this problem will be redundant:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要修改数据库的架构，例如添加实体的创建日期，会发生什么？在这种情况下，我们需要将`PersonEntity`更改为具有映射相关日期的新属性。然而，调用者现在也获得了这些信息，而我们可能不想公开这些信息。相反，如果我们使用所谓的**数据转换对象**（DTO）来公开人员，这个问题将变得多余：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This means that our API should return an object of the `PersonDto` type instead
    of `PersonEntity`, performing a conversion between the two objects. At first sight,
    the exercise appears to be a useless duplication of code, as the two classes contain
    the same properties. However, if we consider the fact that `PersonEntity` could
    evolve with new properties that are necessary for the database, or change structure
    with a new semantic that the caller shouldn’t know, the importance of mapping
    becomes clear. An example is storing the city in a separate table and exposing
    it through an `Address` property. Or suppose that, for security reasons, we don’t
    want to expose the exact birth date anymore, only the age of the person. Using
    an ad-hoc DTO, we can easily change the schema and update the mapping without
    touching our entity, having a better separation of concerns.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的API应该返回`PersonDto`类型的对象而不是`PersonEntity`，在两个对象之间执行转换。乍一看，这个练习似乎是无用的代码重复，因为这两个类包含相同的属性。然而，如果我们考虑到`PersonEntity`可能会随着数据库所需的新属性而演变，或者改变结构以适应调用者不应了解的新语义，映射的重要性就变得明显了。例如，将城市存储在单独的表中并通过`Address`属性公开。或者假设出于安全原因，我们不再想公开确切的出生日期，而只公开人的年龄。使用专门的DTO，我们可以轻松地更改架构并更新映射，而无需触及我们的实体，从而实现更好的关注点分离。
- en: Of course, mapping can be bidirectional. In our example, we need to convert
    `PersonEntity` to `PersonDto` before returning it to the client. However, we could
    also do the opposite – that is, convert the `PersonDto` type that comes from a
    client into `PersonEntity` to save it to a database. All the solutions we’re talking
    about are valid for both scenarios.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，映射可以是双向的。在我们的例子中，我们需要在将数据返回给客户端之前将`PersonEntity`转换为`PersonDto`。然而，我们也可以做相反的操作——即将来自客户端的`PersonDto`类型转换为`PersonEntity`以将其保存到数据库中。我们讨论的所有解决方案都适用于这两种情况。
- en: We can either perform mapping manually or adopt a third-party library that provides
    us with this feature. In the following sections, we’ll analyze both approaches,
    understanding the pros and cons of the available solutions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择手动执行映射，或者采用提供此功能的第三方库。在接下来的章节中，我们将分析这两种方法，了解现有解决方案的优缺点。
- en: Performing manual mapping
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行手动映射
- en: In the previous section, we said that mapping essentially means copying the
    properties of a source object into the properties of a destination and applying
    some sort of conversion. The easiest and most effective way to perform this task
    is to do it manually.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们提到映射本质上意味着将源对象的属性复制到目标对象的属性中，并应用某种类型的转换。执行此任务最简单、最有效的方法是手动进行。
- en: With this approach, we need to take care of all the mapping code by ourselves.
    From this point of view, there is nothing much more to say; we need a method that
    takes an object as input and transforms it into another as output, remembering
    to apply mapping recursively if a class contains a complex property that must
    be mapped in turn. The only suggestion is to use an extension method so that we
    can easily call it everywhere we need.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们需要自己处理所有的映射代码。从这个角度来看，没有太多可说的；我们需要一个方法，它接受一个对象作为输入并将其转换为输出，同时记得如果类包含一个必须依次映射的复杂属性，则应用递归映射。唯一的建议是使用扩展方法，这样我们就可以在需要的地方轻松调用它。
- en: 'A full example of this mapping process is available in the GitHub repository:
    [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此映射过程的完整示例可在GitHub仓库中找到：[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter06)。
- en: 'This solution guarantees the best performance because we explicitly write all
    mapping instructions without relying on an automatic system (such as reflection).
    However, the manual method has a drawback: every time we add a property in the
    entity that must be mapped to a DTO, we need to change the mapping code. On the
    other hand, some approaches can simplify mapping, but at the cost of performance
    overhead. In the next section, we look at one such approach using `AutoMapper`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案保证了最佳性能，因为我们明确编写了所有映射指令，而不依赖于自动系统（如反射）。然而，手动方法有一个缺点：每次我们在实体中添加一个必须映射到DTO的属性时，都需要更改映射代码。另一方面，一些方法可以简化映射，但会以性能开销为代价。在下一节中，我们将探讨一种使用`AutoMapper`的方法。
- en: Mapping with AutoMapper
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AutoMapper进行映射
- en: '`AutoMapper` is probably one the most famous mapping framework for .NET. It
    uses a fluent configuration API that works with a convention-based matching algorithm
    to match source values to destination values. As with `FluentValidation`, the
    framework is part of the .NET Foundation and is available either on GitHub ([https://github.com/AutoMapper/AutoMapper](https://github.com/AutoMapper/AutoMapper))
    or NuGet ([https://www.nuget.org/packages/AutoMapper](https://www.nuget.org/packages/AutoMapper)).
    Again, in this case, we have a specific NuGet package, [https://www.nuget.org/packages/AutoMapper.Extensions.Microsoft.DependencyInjection](https://www.nuget.org/packages/AutoMapper.Extensions.Microsoft.DependencyInjection),
    that simplifies its integration into ASP.NET Core projects.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoMapper`可能是.NET中最著名的映射框架之一。它使用基于约定的匹配算法的流畅配置API，将源值匹配到目标值。与`FluentValidation`一样，该框架是.NET基金会的组成部分，可在GitHub
    ([https://github.com/AutoMapper/AutoMapper](https://github.com/AutoMapper/AutoMapper))
    或NuGet ([https://www.nuget.org/packages/AutoMapper](https://www.nuget.org/packages/AutoMapper))
    上获得。同样，在这种情况下，我们有一个特定的NuGet包，[https://www.nuget.org/packages/AutoMapper.Extensions.Microsoft.DependencyInjection](https://www.nuget.org/packages/AutoMapper.Extensions.Microsoft.DependencyInjection)，它简化了其集成到ASP.NET
    Core项目中的过程。'
- en: Let’s take a quick look at how to integrate `AutoMapper` in a minimal API project,
    showing its main features. The full documentation of the library is available
    at [https://docs.automapper.org](https://docs.automapper.org).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下如何在最小API项目中集成`AutoMapper`，展示其主要功能。该库的完整文档可在[https://docs.automapper.org](https://docs.automapper.org)找到。
- en: 'As usual, the first thing to do is to add the library to our project, following
    the same instructions we used in the previous sections. Then, we need to configure
    `AutoMapper`, telling it how to perform mapping. There are several ways to perform
    this task, but the recommended approach is to create classes that are inherited
    from the `Profile` base class provided by the library and put the configuration
    into the constructor:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，首先要做的是将库添加到我们的项目中，遵循我们在前几节中使用的相同指令。然后，我们需要配置 `AutoMapper`，告诉它如何执行映射。有几种方法可以完成这项任务，但推荐的方法是创建继承自库提供的
    `Profile` 基类的新类，并将配置放入构造函数中：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That’s all we need to start: a single instruction to indicate that we want
    to map `PersonEntity` to `PersonDto`, without any other details. We have said
    that `AutoMapper` is convention-based. This means that, by default, it maps properties
    with the same name from the source to the destination, while also performing automatic
    conversions into compatible types, if necessary. For example, an `int` property
    on the source can be automatically mapped to a `double` property with the same
    name on the destination. In other words, if source and destination objects have
    the same property, there is no need for any explicit mapping instruction. However,
    in our case, we need to perform some transformations, so we can add them fluently
    after `CreateMap`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们开始所需的所有内容：一条指令，表示我们想要将 `PersonEntity` 映射到 `PersonDto`，而不需要其他任何细节。我们说过 `AutoMapper`
    是基于约定的。这意味着默认情况下，它会将源和目标中具有相同名称的属性进行映射，并在必要时执行自动类型转换。例如，源上的 `int` 属性可以自动映射到目标上具有相同名称的
    `double` 属性。换句话说，如果源和目标对象具有相同的属性，则不需要任何显式的映射指令。然而，在我们的情况下，我们需要执行一些转换，因此我们可以在 `CreateMap`
    之后流畅地添加它们：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the `ForMember` method, we can specify how to map destination properties,
    `dst.Age` and `dst.City`, using conversion expressions. We still don’t need to
    explicitly map the `Id`, `FirstName`, or `LastName` properties because they exist
    with these names at both the source and destination.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ForMember` 方法，我们可以指定如何使用转换表达式映射目标属性，例如 `dst.Age` 和 `dst.City`。我们仍然不需要显式映射
    `Id`、`FirstName` 或 `LastName` 属性，因为它们在源和目标中都存在这些名称。
- en: 'Now that we have defined the mapping profile, we need to register it at startup
    so that ASP.NET Core can use it. As with `FluentValidation`, we can invoke an
    extension method on `IServiceCollection`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了映射配置文件，我们需要在启动时注册它，以便 ASP.NET Core 可以使用它。与 `FluentValidation` 类似，我们可以在
    `IServiceCollection` 上调用扩展方法：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With this line of code, we automatically register all the profiles that are
    contained in the specified assembly. If we add more profiles to our project, such
    as a separate `Profile` class for every entity to map, we don’t need to change
    the registration instructions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这一行代码，我们自动注册了指定程序集中包含的所有配置文件。如果我们向项目中添加更多配置文件，例如为每个要映射的实体创建一个单独的 `Profile`
    类，我们不需要更改注册指令。
- en: 'In this way, we can now use the `IMapper` interface through dependency injection:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们现在可以通过依赖注入使用 `IMapper` 接口：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After retrieving `PersonEntity`, for example, from a database using Entity Framework
    Core, we call the `Map` method on the `IMapper` interface, specifying the type
    of the resulting object and the input class. With this line of code, `AutoMapper`
    will use the corresponding profile to convert `PersonEntity` into a `PersonDto`
    instance.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在从数据库中检索 `PersonEntity` 后，我们可以调用 `IMapper` 接口上的 `Map` 方法，指定结果对象的类型和输入类。使用这一行代码，`AutoMapper`
    将使用相应的配置文件将 `PersonEntity` 转换为 `PersonDto` 实例。
- en: With this solution in place, mapping is now much easier to maintain because,
    as long as we add properties with the same name on the source and destination,
    we don’t need to change the profile at all. Moreover, `AutoMapper` supports list
    mapping and recursive mapping too. So, if we have an entity that must be mapped,
    such as a property of the `AddressEntity` type on the `PersonEntity` class, and
    the corresponding profile is available, the conversion is again performed automatically.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种解决方案后，映射现在更容易维护，因为只要我们在源和目标上添加具有相同名称的属性，我们就不需要更改配置文件。此外，`AutoMapper` 还支持列表映射和递归映射。因此，如果我们有一个必须映射的实体，例如
    `PersonEntity` 类上的 `AddressEntity` 类型的属性，并且相应的配置文件可用，转换将再次自动执行。
- en: The drawback of this approach is a performance overhead. `AutoMapper` works
    by dynamically executing mapping code at runtime, so it uses reflection under
    the hood. Profiles are created the first time they are used and then they are
    cached to speed up subsequent mappings. However, profiles are always applied dynamically,
    so there is a cost for the operation that is dependent on the complexity of the
    mapping code itself. We have only seen a basic example of `AutoMapper`. The library
    is very powerful and can manage quite complex mappings. However, we need to be
    careful not to abuse it – otherwise, we can negatively impact the performance
    of our application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是性能开销。`AutoMapper`通过在运行时动态执行映射代码来工作，因此它在底层使用反射。配置文件在第一次使用时创建，然后被缓存以加快后续映射的速度。然而，配置文件始终是动态应用的，因此操作成本取决于映射代码本身的复杂性。我们只看到了`AutoMapper`的一个基本示例。这个库非常强大，可以管理相当复杂的映射。然而，我们需要小心不要滥用它——否则，我们可能会对我们的应用程序的性能产生负面影响。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Validation and mapping are two important features that we need to take into
    account when developing APIs to build more robust and maintainable applications.
    Minimal APIs do not provide any built-in way to perform these tasks, so it is
    important to know how we can add support for this kind of feature. We have seen
    that we can perform validations with data annotations or using `FluentValidation`
    and how to add validation information to Swagger. We have also talked about the
    significance of data mapping and shown how to either leverage manual mapping or
    the `AutoMapper` library, describing the pros and cons of each approach.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 验证和数据映射是在开发API时需要考虑的两个重要特性，以构建更健壮和可维护的应用程序。最小化API不提供任何内置的方式来执行这些任务，因此了解我们如何添加对这类特性的支持是很重要的。我们已经看到，我们可以使用数据注释或`FluentValidation`来执行验证，以及如何将验证信息添加到Swagger中。我们还讨论了数据映射的重要性，并展示了如何利用手动映射或`AutoMapper`库，描述了每种方法的优缺点。
- en: In the next chapter, we will talk about how to integrate minimal APIs with a
    **data access layer**, showing, for example, how to access a database using Entity
    Framework Core.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何将最小化API与**数据访问层**集成，例如展示如何使用Entity Framework Core访问数据库。
