- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Creating a Roslyn Analyzer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Roslyn分析器
- en: In the previous chapter, we covered the use of code analyzers to detect issues
    in code. But what happens when your team has common issues that aren’t detected
    by any existing analysis rules?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了使用代码分析器来检测代码中的问题。但是，当你的团队存在任何现有分析规则都无法检测到的常见问题时，会发生什么呢？
- en: It turns out that modern C# provides a means for building custom analyzers through
    something called **Roslyn Analyzers**. In this chapter, we’ll see how Roslyn Analyzers
    work in action by building an analyzer of our own.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，现代C#提供了一种通过称为**Roslyn分析器**的方式来构建自定义分析器的方法。在本章中，我们将通过构建自己的分析器来了解Roslyn分析器是如何实际工作的。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Understanding Roslyn Analyzers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Roslyn分析器
- en: Creating a Roslyn Analyzer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Roslyn分析器
- en: Testing Roslyn Analyzers with `RoslynTestKit`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RoslynTestKit`测试Roslyn分析器
- en: Sharing analyzers as Visual Studio extensions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分析器作为Visual Studio扩展共享
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Unlike other chapters, we won’t be starting with sample code. Instead, we’ll
    be starting with a blank solution and gradually adding new projects to that solution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他章节不同，我们不会从示例代码开始。相反，我们将从一个空白解决方案开始，并逐渐向该解决方案中添加新的项目。
- en: The starting empty solution and final code for this chapter are available from
    GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter13` folder.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起始空解决方案和最终代码可在GitHub的[https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)的`Chapter13`文件夹中找到。
- en: Understanding Roslyn Analyzers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Roslyn分析器
- en: Before we can go into what a Roslyn Analyzer is, let’s talk about Roslyn.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨Roslyn分析器是什么之前，让我们先谈谈Roslyn。
- en: '**Roslyn** is the codename for the reimagined **.NET Compiler Platform** that
    was released alongside Visual Studio 2015\. Since “.NET Compiler Platform” is
    a lot to say, most people refer to this as the Roslyn compiler or simply Roslyn
    for short.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Roslyn**是重新构想后的**.NET编译平台**的代号，该平台与Visual Studio 2015一同发布。由于“.NET编译平台”这个名字太长，大多数人将其称为Roslyn编译器或简称Roslyn。'
- en: Before Roslyn, if a tool wanted to understand C#, VB, or F# source code, developers
    needed to write their own language parser for these code files. This involved
    a significant amount of time and complexity, and this effort needed to be repeated
    every time these programming languages changed. This led to tools being slower
    to support new language features, lost productivity, and bugs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Roslyn之前，如果某个工具想要理解C#、VB或F#源代码，开发者需要为这些代码文件编写自己的语言解析器。这需要大量的时间和复杂性，并且每次这些编程语言发生变化时，都需要重复这项工作。这导致工具支持新语言特性的速度较慢，生产力下降，并出现错误。
- en: One of the explicit goals of the Rosyln compiler was to provide visibility into
    the structure of code in a standardized way. This way, plugins could work with
    the Roslyn APIs to get live information about code without having to write their
    own parser.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn编译器的一个明确目标是以标准化的方式提供代码结构的可见性。这样，插件就可以使用Roslyn API与代码工作，获取有关代码的实时信息，而无需编写自己的解析器。
- en: 'To do this, projects can create **Roslyn Analyzers**, which integrate into
    the code analysis and compilation process. This lets you do the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，项目可以创建**Roslyn分析器**，这些分析器集成到代码分析和编译过程中。这让你可以做以下事情：
- en: Provide warnings and errors when anti-patterns in code are present
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当代码中存在反模式时提供警告和错误
- en: Integrate into the **Quick Actions** menu, allowing developers to automatically
    fix known issues using established solutions
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成到**快速操作**菜单中，允许开发者使用既定解决方案自动修复已知问题
- en: Provide refactoring capabilities, thereby improving developer productivity
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供重构功能，从而提高开发者的生产力
- en: You’ve been working with Roslyn Analyzers this whole time with the various code
    warnings, suggestions, and **Quick Action** refactorings you’ve seen in Visual
    Studio.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你一直都在使用Roslyn分析器，通过各种在Visual Studio中看到的代码警告、建议和**快速操作**重构。
- en: 'You can explore the built-in analyzers in your projects by going to **Solution
    Explorer** and then expanding a project’s **Dependencies** node, followed by its
    **Analyzers** node and specific analyzer assemblies, as shown in *Figure 13**.1*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问**解决方案资源管理器**，然后展开一个项目的**依赖项**节点，接着展开其**分析器**节点和特定的分析器程序集，来探索项目中的内置分析器，如图*13.1*所示：
- en: '![Figure 13.1 – Code analyzers in Solutions Explorer](img/B21324_13_1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 解决方案资源管理器中的代码分析器](img/B21324_13_1.jpg)'
- en: Figure 13.1 – Code analyzers in Solutions Explorer
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 解决方案资源管理器中的代码分析器
- en: Through the rest of this chapter, we’ll create a Roslyn Analyzer of our own,
    but before we do, let’s talk about how Roslyn sees C# code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将创建我们自己的Roslyn分析器，但在我们这样做之前，让我们谈谈Roslyn是如何看待C#代码的。
- en: Installing the extension development workload and DGML editor
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装扩展开发工作负载和DGML编辑器
- en: When you’re developing with Roslyn Analyzers, two additions to Visual Studio
    will help you create and debug your own analyzers. Let’s install these by launching
    **Visual Studio Installer** from the Windows start menu. Next, select your installation
    of Visual Studio and click **Modify**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Roslyn分析器进行开发时，Visual Studio的两个新增功能将帮助您创建和调试自己的分析器。让我们通过从Windows开始菜单启动**Visual
    Studio安装程序**来安装这些功能。接下来，选择您的Visual Studio安装并点击**修改**。
- en: 'This will bring up a list of workloads and features that are available. These
    change over time, but you’ll want to make sure that the **Visual Studio extension
    development** workload is checked in the **Workloads** tab, as shown in *Figure
    13**.2*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将弹出一个包含可用工作负载和功能的列表。这些功能会随时间变化，但您需要确保在**工作负载**选项卡中勾选了**Visual Studio扩展开发**工作负载，如图*图13.2*所示：
- en: '![Figure 13.2 – Installing Visual Studio extension development and DGML editor](img/B21324_13_2.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 安装Visual Studio扩展开发和工作负载DGML编辑器](img/B21324_13_2.jpg)'
- en: Figure 13.2 – Installing Visual Studio extension development and DGML editor
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 安装Visual Studio扩展开发和工作负载DGML编辑器
- en: Next, find **DGML editor** in the **Individual components** tab and check it
    as well before clicking **Modify** to install the additional components.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在**单个组件**选项卡中找到**DGML编辑器**，并在点击**修改**以安装附加组件之前也勾选它。
- en: The Visual Studio extension development workload is useful when you are trying
    to create a VSIX extension project for Visual Studio. This type of project allows
    you to add custom user interface elements, analyzers, and new features to Visual
    Studio. We’ll talk more about VSIX extensions periodically throughout the rest
    of this chapter and the next.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试为Visual Studio创建VSIX扩展项目时，Visual Studio扩展开发工作负载非常有用。此类项目允许您向Visual Studio添加自定义用户界面元素、分析器和新功能。我们将在本章的其余部分和下一章中定期讨论VSIX扩展。
- en: 'The DGML editor works with **Directed Graph Markup Language** (**DGML**) to
    show interactive visualizations in Visual Studio. It also happens to install a
    very useful view that will help us understand Rosyln more: **Syntax Visualizer**.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: DGML编辑器使用**有向图标记语言**（**DGML**）与Visual Studio一起显示交互式可视化。它还安装了一个非常有用的视图，将帮助我们更好地理解Roslyn：**语法可视化器**。
- en: Introducing Syntax Visualizer
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍语法可视化器
- en: '**Syntax Visualizer** is a view in Visual Studio that allows you to see the
    structure of source code from the Roslyn API’s point of view.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法可视化器**是Visual Studio中的一个视图，它允许您从Roslyn API的角度查看源代码的结构。'
- en: To see this in action, open a C# file in your editor and then open **Syntax
    Visualizer** by clicking the **View** menu, followed by **Other Windows** and
    then **Syntax Visualizer**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此功能，请在您的编辑器中打开一个C#文件，然后通过点击**视图**菜单，接着是**其他窗口**，然后是**语法可视化器**来打开**语法可视化器**。
- en: 'This should show you a hierarchy of various nodes corresponding to the code
    in your editor, as shown in *Figure 13**.3*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示与您编辑器中的代码相对应的各种节点层次结构，如图*图13.3*所示：
- en: '![Figure 13.3 – Syntax Visualizer synchronizing with the current code selection](img/B21324_13_3.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 语法可视化器与当前代码选择同步](img/B21324_13_3.jpg)'
- en: Figure 13.3 – Syntax Visualizer synchronizing with the current code selection
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 语法可视化器与当前代码选择同步
- en: Click on various keywords, variables, methods, and values in your code and watch
    **Syntax Visualizer** change to reflect what you’ve selected.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中点击各种关键字、变量、方法和值，并观察**语法可视化器**如何根据您的选择进行更改。
- en: This is a very good way of understanding how code is structured in Roslyn’s
    APIs, but the tool can also be helpful when you’re not sure what class inside
    of the Roslyn API refers to the type of code element you want to work with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常好的理解Roslyn API中代码结构的方式，但该工具在您不确定Roslyn API中的哪个类引用了您想要与之工作的代码元素类型时也非常有用。
- en: Now that we have a slightly greater understanding of what the Roslyn API is,
    let’s create our first Roslyn Analyzer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Roslyn API有了一定的了解，让我们创建我们的第一个Roslyn分析器。
- en: Creating a Roslyn Analyzer
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Roslyn分析器
- en: People create custom Roslyn Analyzers when they experience common issues in
    their code that no existing analyzer addresses. These custom analyzers help enforce
    rules that specific organizations or teams find to be useful. However, these organization-specific
    rules tend to be less relevant to the larger .NET community.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们遇到现有分析器无法解决的代码中的常见问题时，他们会创建自定义的 Roslyn 分析器。这些自定义分析器有助于强制执行特定组织或团队认为有用的规则。然而，这些特定组织的规则通常对更大的
    .NET 社区来说不太相关。
- en: 'Here are a few examples of when you might want to build a custom analyzer:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子，说明你可能想要构建自定义分析器的情况：
- en: Your team has been having issues with too many `FormatException` errors from
    things such as `int.Parse` and wants to make `int.TryParse` their standard
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的团队遇到了太多来自 `int.Parse` 等操作导致的 `FormatException` 错误，并希望将 `int.TryParse` 作为他们的标准。
- en: Due to large files and limited memory, your team wants to avoid the `File.ReadAllText`
    method and use stream-based approaches instead
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于文件很大且内存有限，你的团队希望避免使用 `File.ReadAllText` 方法，而改用基于流的方案。
- en: Your team mandates that all classes must override the `ToString` method to improve
    the debugging and logging experience
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的团队要求所有类都必须重写 `ToString` 方法，以改善调试和日志记录体验。
- en: Note that none of these approaches relate to styling or syntax. Instead, these
    analyzers deal with team-specific decisions about how to best use .NET. We’ll
    explore ways of enforcing styling and syntax choices in [*Chapter 16*](B21324_16.xhtml#_idTextAnchor341),
    *Adopting* *Code Standards*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些方法都与样式或语法无关。相反，这些分析器处理的是团队特定的关于如何最佳使用 .NET 的决策。我们将在 [*第 16 章*](B21324_16.xhtml#_idTextAnchor341)
    *采用* *代码标准* 中探讨强制执行样式和语法选择的方法。
- en: Let’s say that Cloudy Skies Airlines is spending a lot of time debugging and
    troubleshooting code and suspects that overriding `ToString` in more places would
    lead to a better developer experience for their team.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Cloudy Skies Airlines 在调试和代码故障排除上花费了大量的时间，并怀疑在更多地方重写 `ToString` 将会为他们的团队带来更好的开发者体验。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s not an established best practice to override `ToString` in all classes.
    There are likely some performance drawbacks to doing so, but for this chapter,
    we’ll assume this rule makes sense for the Cloudy Skies team.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有类中重写 `ToString` 并非一个既定的最佳实践。这样做可能存在一些性能上的缺点，但在这个章节中，我们将假设这个规则对 Cloudy Skies
    团队来说是合理的。
- en: Throughout the rest of this chapter, we’ll create this analyzer, starting from
    a blank solution.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将从空白解决方案开始创建这个分析器。
- en: Adding the analyzer project to our solution
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将分析器项目添加到我们的解决方案中
- en: While there are templates for creating Roslyn Analyzers built into Visual Studio,
    these are older templates and they hide some of the implementation details. Instead,
    we’re going to walk through the steps of creating and deploying a Roslyn Analyzer
    from an empty solution.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Visual Studio 中内置了创建 Roslyn 分析器的模板，但这些模板比较老旧，并且隐藏了一些实现细节。相反，我们将通过从空白解决方案开始创建和部署
    Roslyn 分析器的步骤进行讲解。
- en: We’ll start by adding a class library that will contain our analyzer. Class
    libraries are a special type of project that provides code to other projects but
    cannot run on their own.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加一个包含我们的分析器的类库。类库是一种特殊的项目类型，它为其他项目提供代码，但不能独立运行。
- en: Starting with the `Chapter13BeginningCode` solution, we’ll right-click on the
    solution in **Solution Explorer** and then choose **Add** and then **New Project…**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Chapter13BeginningCode` 解决方案开始，我们在 **解决方案资源管理器** 中右键单击解决方案，然后选择 **添加**，接着选择
    **新建项目…**。
- en: 'From there, we’ll select the type of project we want to create, select a **Class
    Library** project using the C# language, as shown in *Figure 13**.4*, and click
    **Next**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们将选择我们想要创建的项目类型，选择使用 C# 语言创建的 **类库** 项目，如图 *图 13**.4* 所示，然后点击 **下一步**：
- en: '![Figure 13.4 – Adding a C# Class Library project to our solution](img/B21324_13_4.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – 将 C# 类库项目添加到我们的解决方案中](img/B21324_13_4.jpg)'
- en: Figure 13.4 – Adding a C# Class Library project to our solution
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 将 C# 类库项目添加到我们的解决方案中
- en: Warning
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: There are multiple projects with the name Class Library in different languages.
    Look for the green C# icon and the C# label in the list.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个不同语言的类库项目，名称都为 Class Library。在列表中寻找绿色的 C# 图标和 C# 标签。
- en: Next, we’ll need to provide a name for our class library. This is the library
    that will hold the code analyzer we’re creating this chapter, so let’s call it
    `Packt.Analyzers` since the name of the project will become the default namespace
    of the project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的类库提供一个名称。这个库将包含我们本章创建的代码分析器，所以让我们称它为 `Packt.Analyzers`，因为项目的名称将成为项目的默认命名空间。
- en: After this, you’ll be asked to select the framework the project should use.
    Select **.NET Standard 2.0** and click **Create**. The new project will be added
    to your solution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你将被要求选择项目应使用的框架。选择 **.NET Standard 2.0** 并点击 **创建**。新项目将被添加到你的解决方案中。
- en: Why .NET Standard?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择 .NET Standard？
- en: Unlike other projects in this book, we’re using .NET Standard here. This is
    a special version of .NET that was designed to run on a variety of different .NET
    runtimes. This makes .NET Standard a great choice for when you don’t know which
    version of .NET your code will be running in. See the *Further reading* section
    for more information.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他项目不同，我们在这里使用 .NET Standard。这是一个专为在多种不同的 .NET 运行时上运行而设计的 .NET 特殊版本。这使得
    .NET Standard 成为当你不知道你的代码将在哪个版本的 .NET 上运行时的一个很好的选择。更多信息请参阅 *进一步阅读* 部分。
- en: To create a Roslyn Analyzer, we’ll need to add a few NuGet packages to our class
    library. To do this, right-click on the class library in **Solution Explorer**
    and then choose **Manage** **NuGet Packages…**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Roslyn 分析器，我们需要向我们的类库添加几个 NuGet 包。为此，在 **解决方案资源管理器** 中右键单击类库，然后选择 **管理**
    **NuGet 包…**。
- en: 'Once you’re in `Microsoft.CodeAnalysis` package, as shown in *Figure 13**.5*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入 `Microsoft.CodeAnalysis` 包，如图 *图 13.5* 所示：
- en: '![Figure 13.5 – Installing version 4.0.1 of Microsoft.CodeAnalysis](img/B21324_13_5.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 安装 Microsoft.CodeAnalysis 的 4.0.1 版本](img/B21324_13_5.jpg)'
- en: Figure 13.5 – Installing version 4.0.1 of Microsoft.CodeAnalysis
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 安装 Microsoft.CodeAnalysis 的 4.0.1 版本
- en: Note that version 4.0.1 is not the most recent version of this package. This
    specific version was chosen to avoid a conflict with the testing library we’ll
    use later.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，版本 4.0.1 并不是这个包的最新版本。这个特定版本是为了避免与我们将要使用的测试库发生冲突而选择的。
- en: Now that the package has been installed, we’re ready to start creating our Roslyn
    Analyzer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在包已经安装，我们就可以开始创建我们的 Roslyn 分析器了。
- en: Defining a code analysis rule
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义代码分析规则
- en: 'Let’s start by renaming the `Class1.cs` file to `ToStringAnalyzer.cs` and replacing
    its contents with the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先将 `Class1.cs` 文件重命名为 `ToStringAnalyzer.cs` 并用以下内容替换其内容：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the minimum we need to have a compiling analyzer. Let’s explore what’s
    here.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要的最基本的编译分析器。让我们来看看这里有什么。
- en: First of all, the `ToStringAnalyzer` class inherits from `DiagnosticAnalyzer`,
    which is a base class for all Roslyn Analyzers that provide warnings to the user.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`ToStringAnalyzer` 类从 `DiagnosticAnalyzer` 继承，这是所有提供警告给用户的 Roslyn 分析器的基类。
- en: The class has a `DiagnosticAnalyzer` attribute that says the analyzer applies
    to code written in C#.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有一个 `DiagnosticAnalyzer` 属性，表示分析器适用于用 C# 编写的代码。
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s possible to write analyzers that apply to C#, F#, Visual Basic, or some
    combination of these languages.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编写适用于 C#、F#、Visual Basic 或这些语言的组合的分析器。
- en: 'Inheriting from the abstract `DiagnosticAnalyzers` class forces us to override
    the `SupportedDiagnostics` property and the `Initialize` method. Let’s do that
    now in the simplest way possible:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从抽象的 `DiagnosticAnalyzers` 类继承强制我们重写 `SupportedDiagnostics` 属性和 `Initialize`
    方法。现在让我们以最简单的方式来做这件事：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `SupportedDiagnostics` property returns `ImmutableArray`, which contains
    all diagnostic rules the analyzer provides to the editor. In our case, we’ll want
    it to return the warning the user might see if the rule is violated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`SupportedDiagnostics` 属性返回 `ImmutableArray`，它包含分析器提供给编辑器的所有诊断规则。在我们的情况下，我们希望它返回用户可能会看到的警告，如果规则被违反。'
- en: 'Let’s add a new property and update our `SupportedDiagnostics` property, as
    shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个新属性并更新我们的 `SupportedDiagnostics` 属性，如图所示：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we’ve added a static `Rule` property that defines the `DiagnosticDescriptor`
    object that’s defining our rule. This rule is then included in the `SupportedDiagnostics`
    property.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个静态的 `Rule` 属性，它定义了定义我们规则的 `DiagnosticDescriptor` 对象。然后这个规则被包含在 `SupportedDiagnostics`
    属性中。
- en: Localization note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化说明
- en: '`DiagnosticDescriptor` objects can be created with either raw strings, as we’re
    using here, or by using `LocalizableString` parameters. `LocalizableString` works
    better in different languages, so you’ll want to use it if you are trying to create
    a Roslyn Analyzer intended to be used throughout the globe.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`DiagnosticDescriptor`对象可以使用原始字符串创建，就像我们在这里使用的那样，或者通过使用`LocalizableString`参数。`LocalizableString`在不同语言中表现更好，所以如果你试图创建一个打算在全球范围内使用的Roslyn分析器，你将想要使用它。'
- en: 'The `DiagnosticDescriptor` object that this code defines will show up in the
    **Error List** pane and build output if the rule is ever violated. The rule needs
    the following parts:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果规则被违反，此代码定义的`DiagnosticDescriptor`对象将显示在**错误列表**窗格和构建输出中。规则需要以下部分：
- en: '`CSA` for Cloudy Skies Airlines.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSA`代表Cloudy Skies Airlines。'
- en: '**Title**: The short name of the code analysis warning. This is what will appear
    in tooltips when the rule is violated.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**：代码分析警告的简称。这是当规则被违反时在工具提示中显示的内容。'
- en: '**Message format**: A formattable string that will appear in the Visual Studio
    tooltip.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息格式**：一个可格式化的字符串，它将在Visual Studio工具提示中显示。'
- en: '`Naming`, `Performance`, `Maintainability`, `Security`, `Reliability`, `Design`,
    and `Usage`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`命名`、`性能`、`可维护性`、`安全性`、`可靠性`、`设计`和`使用`。'
- en: '`Hidden`, `Info`, `Warning`, or `Error`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`隐藏`、`信息`、`警告`或`错误`。'
- en: '**Enabled by default**: Whether the rule starts as enabled.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认启用**：规则是否以启用状态开始。'
- en: '**Description**: A detailed description of the rule and why it’s important.
    This shows up in the **Error List** pane when a rule violation is expanded.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：规则的详细描述以及为什么它很重要。当规则违反被展开时，这将在**错误列表**窗格中显示。'
- en: Defining your rule as a separate property is helpful when other code needs to
    refer to your exact rule definition.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他代码需要引用你的确切规则定义时，将你的规则定义为单独的属性是有帮助的。
- en: Now that our rule has been defined, let’s write the code that detects when the
    rule is violated.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了规则，让我们编写检测规则被违反的代码。
- en: Analyzing symbols with our Roslyn Analyzer
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用我们的Roslyn分析器分析符号
- en: 'Let’s start by building out our `Initialize` method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从构建我们的`Initialize`方法开始：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This method now does a few additional things:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法现在还增加了几个额外的功能：
- en: First, we configure the analyzer to ignore any auto-generated code for analysis
    purposes. These are files that the user didn’t write but various tools generate
    and so it doesn’t make sense to analyze them.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们配置分析器在分析目的上忽略任何自动生成的代码。这些是用户没有编写的文件，而是由各种工具生成的，因此分析它们没有意义。
- en: Secondly, we tell Roslyn that it’s fine to evaluate multiple pieces of code
    with this rule at the same time. This is always the preferred option from a performance
    standpoint.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们告诉Roslyn，同时评估多个代码片段使用这个规则是可以的。从性能的角度来看，这始终是首选选项。
- en: Finally, we tell the analyzer that whenever it encounters a named `Type` during
    code analysis, we want to know about it. Specifically, the code should call a
    new `Analyze` method for each `Type` that is detected.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们告诉分析器，在代码分析过程中遇到任何命名的`Type`时，我们都希望了解它。具体来说，代码应该为检测到的每个`Type`调用一个新的`Analyze`方法。
- en: 'We haven’t written that `Analyze` method yet, so let’s do so now:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有编写那个`Analyze`方法，所以现在让我们来编写它：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code is not easy to write or read, so let’s go over it before discussing
    *how* to write analyzer code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不易编写或阅读，所以在讨论如何编写分析器代码之前，我们先来了解一下。
- en: First, since we know this method is called on named types, we can cast the symbol
    Roslyn gives us to `INamedTypeSymbol`, which lets us query further.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，因为我们知道这个方法是在命名类型上被调用的，所以我们可以将Roslyn给出的符号强制转换为`INamedTypeSymbol`，这让我们可以进一步查询。
- en: Using this symbol, we can ask for all members such as properties and methods
    using `GetMembers`. Next, we can use LINQ to filter these down to just ones that
    are methods. Once we have these, we can use `FirstOrDefault` to see if we have
    a method named `ToString` that takes in zero parameters and is an override.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个符号，我们可以使用`GetMembers`请求所有成员，例如属性和方法。接下来，我们可以使用LINQ将这些过滤到仅包含方法的那些。一旦我们有了这些，我们可以使用`FirstOrDefault`来查看是否有名为`ToString`的方法，它接受零个参数并且是重写的。
- en: Why not check the return type?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不检查返回类型？
- en: We could check if the return type was a string, but the C# compiler doesn’t
    allow multiple methods with the same parameters and different return types. We
    also know all objects have `string ToString()`, so the return type will be `string`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查返回类型是否为字符串，但C#编译器不允许有相同参数但返回类型不同的多个方法。我们还知道所有对象都有`string ToString()`，所以返回类型将是`string`。
- en: If we didn’t find a `ToString` override, our analyzer should flag this as a
    violation of the rule. It does so by creating a `Diagnostic` object referencing
    the `Rule` property we defined earlier, as well as the name and location of the
    symbol that violated the rule. Here, the symbol will be a `Type` definition that
    does not override `ToString`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有找到`ToString`的重写，我们的分析器应该将其标记为违反规则。它通过创建一个引用我们之前定义的`Rule`属性、符号的名称和位置的`Diagnostic`对象来实现。在这里，符号将是一个没有重写`ToString`的`Type`定义。
- en: Before we go into verifying our analyzer works, let’s talk about writing analyzer
    code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始验证分析器是否工作之前，让我们谈谈编写分析器代码。
- en: Tips for writing Roslyn Analyzers
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Roslyn Analyzers的技巧
- en: In my experience, Roslyn Analyzers are one of the tougher pieces of code to
    write. With Roslyn, you’re looking at your C# code in a completely different light.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，Roslyn Analyzers是编写代码中较为困难的部分。使用Roslyn，您将以完全不同的方式看待您的C#代码。
- en: Each analyzer you write will likely be analyzing something completely different
    than the last one, making discussing the breadth of options available in Roslyn
    difficult.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您编写的每个分析器都可能分析的内容与上一个完全不同，这使得讨论Roslyn中可用的选项范围变得困难。
- en: 'I’ve found two key things helpful for writing Roslyn Analyzers:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现两个关键点对于编写Roslyn Analyzers非常有帮助：
- en: '**Looking at other Roslyn Analyzers**: There are a lot of other Roslyn Analyzers
    out there (including the ones built into .NET) and most are open source. This
    means you can find an existing analyzer similar to what you’re interested in and
    then look at its source code and do something similar.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看其他Roslyn Analyzers**：有很多其他的Roslyn Analyzers（包括内置在.NET中的），大多数都是开源的。这意味着您可以找到一个与您感兴趣的内容相似的现有分析器，然后查看其源代码并做类似的事情。'
- en: See the *Further reading* section of this chapter for a few popular collections
    of Roslyn Analyzers.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章的*进一步阅读*部分，您可以找到一些流行的Roslyn Analyzers集合。
- en: '`Analyze` method, you can give Copilot a prompt such as “I want to find all
    methods contained in this type” or “How would I check if this type is marked as
    public?”'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Analyze`方法，您可以给Copilot一个提示，例如“我想找到这个类型中包含的所有方法”或“我如何检查这个类型是否被标记为公共的？”
- en: You still need to provide high-level guidance, but in my experience, Copilot
    can be extremely effective at helping you write complex and unfamiliar analyzer
    code.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您仍然需要提供高级指导，但根据我的经验，Copilot在帮助您编写复杂和不熟悉的分析器代码方面可以非常有效。
- en: Now that we’ve built our Roslyn Analyzer, let’s look at how we can make sure
    it works.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了我们的Roslyn Analyzer，让我们看看如何确保它能够正常工作。
- en: Testing Roslyn Analyzers with RoslynTestKit
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RoslynTestKit测试Roslyn Analyzers
- en: We’ll show how to use your Roslyn Analyzers in projects of your own at the end
    of this chapter, but we’ll start by writing unit tests around our existing analyzer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的末尾，我们将展示如何在您的项目中使用Roslyn Analyzers，但我们将首先围绕现有的分析器编写单元测试。
- en: 'At a high level, we want to test two things with our analyzer:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，我们希望使用我们的分析器测试两件事：
- en: The analyzer doesn’t trigger for code that doesn’t violate its rule.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析器不会对违反其规则的代码进行触发。
- en: The analyzer correctly flags code that it should.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析器正确地标记了它应该标记的代码。
- en: We’ll do this with two unit tests in a new unit test project.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在新的单元测试项目中进行的两个单元测试来完成这项工作。
- en: Adding a Roslyn Analyzer test project
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Roslyn Analyzer测试项目
- en: Our tests can be written in **MSTest**, **xUnit**, or **NUnit**. We’ll use xUnit
    for consistency.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试可以使用**MSTest**、**xUnit**或**NUnit**编写。我们将使用xUnit以确保一致性。
- en: We’ll start by adding a new xUnit project to the solution by right-clicking
    on the solution and then choosing **Add** and then **New Project…**, as we’ve
    done before.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过右键点击解决方案并选择**添加**然后**新建项目…**来向解决方案中添加一个新的xUnit项目，就像我们之前做的那样。
- en: After this, select the C# version of `Packt.Analyzers.Tests` and click **Next**.
    When prompted with the framework, select **.NET 8.0** and click **Create**.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择`Packt.Analyzers.Tests`的C#版本并点击**下一步**。当提示框架时，选择**.NET 8.0**并点击**创建**。
- en: 'Once the project has been created, add a project reference to `Packt.Analyzers`
    by right-clicking on the `Packt.Analyzers.Tests` project and then selecting **Add
    Project Reference…**, as shown in *Figure 13**.6*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，通过右键点击`Packt.Analyzers.Tests`项目并选择**添加项目引用…**来添加对`Packt.Analyzers`的引用，如图*图13.6*所示。6*：
- en: '![Figure 13.6 – Add Project Reference…](img/B21324_13_6.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6 – 添加项目引用…](img/B21324_13_6.jpg)'
- en: Figure 13.6 – Add Project Reference…
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – 添加项目引用…
- en: Check the box next to `Packt.Analyzers` and click **OK**. This will allow you
    to reference your analyzers from the test project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Packt.Analyzers`旁边勾选复选框，然后点击**确定**。这将允许您从测试项目中引用您的分析器。
- en: Next, we’ll need to add a reference to the **RoslynTestKit** NuGet package.
    This is a testing framework-agnostic library that lets us unit-test Roslyn Analyzers
    by extending from certain test fixture classes, as we’ll see in a moment.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加对**RoslynTestKit** NuGet包的引用。这是一个测试框架无关的库，它允许我们通过扩展某些测试固定类来对Roslyn分析器进行单元测试，正如我们稍后将会看到的。
- en: Right-click `Packt.Analyzers.Tests` and click `SmartAnalyzers.RoslynTestKit`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`Packt.Analyzers.Tests`并点击`SmartAnalyzers.RoslynTestKit`。
- en: Troubleshooting installation issues
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除安装问题
- en: You may encounter a conflict between the latest versions of `Microsoft.CodeAnalysis`
    and `SmartAnalyzers.RoslynTestKit`. See this chapter’s final code on GitHub for
    recommended versions of NuGet packages to resolve this issue.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到`Microsoft.CodeAnalysis`和`SmartAnalyzers.RoslynTestKit`最新版本之间的冲突。请参阅本章节GitHub上的最终代码，以获取解决此问题的推荐NuGet包版本。
- en: With the project setup out of the way, let’s create our test fixture.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目设置完成后，让我们创建我们的测试固定器。
- en: Creating AnalyzerTestFixture
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建AnalyzerTestFixture
- en: 'We’ll start by renaming `UnitTest1.cs` to `ToStringAnalyzerTests.cs` and replacing
    its contents with the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`UnitTest1.cs`重命名为`ToStringAnalyzerTests.cs`，并用以下代码替换其内容：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This class inherits from `AnalyzerTestFixture` in `RoslynTestKit`. This forces
    the class to provide the language it works with and a method to create the analyzer
    we want to test. Since we’re working with C#, we return `LanguageNames.CSharp`
    for the language. In `CreateAnalyzer`, we instantiate and return an instance of
    our `ToStringAnalyzer` from the `Packt.Analyzers` project.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类从`RoslynTestKit`中的`AnalyzerTestFixture`继承。这迫使类提供它所使用的语言以及创建我们想要测试的分析器的方法。由于我们使用C#，我们返回`LanguageNames.CSharp`作为语言。在`CreateAnalyzer`中，我们从`Packt.Analyzers`项目实例化并返回我们的`ToStringAnalyzer`实例。
- en: This lets `RoslynTestKit` know how to create our analyzer and what languages
    we’re working with, but we haven’t defined a test yet. Let’s write our first test
    now.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这让`RoslynTestKit`知道如何创建我们的分析器以及我们正在使用的语言，但我们还没有定义一个测试。现在让我们编写我们的第一个测试。
- en: Verifying that our Roslyn Analyzer doesn’t flag good code
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证我们的Roslyn分析器不会标记好的代码
- en: Our first test will be to ensure that code that doesn’t violate our analyzer
    won’t get flagged as a rule violation. We’ll test this by defining a string containing
    valid code and then verifying that the analyzer didn’t find any issues with it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项测试将是确保不违反我们的分析器的代码不会被标记为规则违规。我们将通过定义一个包含有效代码的字符串来测试这一点，并验证分析器没有发现任何问题。
- en: 'We declare the “good” code as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下声明“好的”代码：
- en: '[PRE6]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This multi-line string defines C# for a simple class declaration of a `Flight`
    class, which includes an override of the `ToString` method. Because `ToString`
    is overridden, our rule should not find issues with this class definition.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个多行字符串定义了C#的一个简单类声明，其中包含对`ToString`方法的覆盖。因为`ToString`被覆盖，我们的规则不应该在这个类定义中找到问题。
- en: 'We can verify this with the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码来验证这一点：
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we use the `NoDiagnostic` method from the `RoslynTestKit's AnalyzerTestFixture`
    class to check that the code doesn’t violate our rule.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`RoslynTestKit's AnalyzerTestFixture`类中的`NoDiagnostic`方法来检查代码没有违反我们的规则。
- en: '`RoslynTestKit` needs to know the ID of the rule we’re checking for, so we
    use the `Rule` property we defined on `ToStringAnalyzer` earlier to provide its
    `id` value.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoslynTestKit`需要知道我们正在检查的规则的ID，因此我们使用我们在`ToStringAnalyzer`上之前定义的`Rule`属性来提供其`id`值。'
- en: Now that our test passes without issues, let’s move on to the second test.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试没有问题通过，让我们继续进行第二个测试。
- en: Verifying that our Roslyn Analyzer flags bad code
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证我们的Roslyn分析器会标记坏代码
- en: 'To verify that bad code triggers the analyzer rule, we’ll use a similar approach:
    we’ll pass in known bad code and ensure that the rule is triggered.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证不良代码会触发分析器规则，我们将使用类似的方法：我们将传递已知的坏代码并确保规则被触发。
- en: 'This is slightly more complicated because we want to make sure the rule is
    triggered for the right symbol in the code. So, when we define our bad code, we
    need to add `[|` and `|]` markers to denote which symbol should be flagged, as
    shown here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这稍微复杂一些，因为我们想确保规则在代码中的正确符号上被触发。因此，当我们定义我们的坏代码时，我们需要添加`[|`和`|]`标记来表示应该标记哪个符号，如下所示：
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code doesn’t have a `ToString` override, so the `Flight` class should
    be flagged as a rule violation. We can verify this with the `HasDiagnostic` method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有重写 `ToString` 方法，所以 `Flight` 类应该被标记为规则违规。我们可以使用 `HasDiagnostic` 方法来验证这一点：
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code is very similar to our approach to validating good code and will fail
    if the rule was not triggered or was not triggered explicitly for the `Flight`
    symbol.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们验证良好代码的方法非常相似，如果规则没有被触发或者没有明确为 `Flight` 符号触发，它将会失败。
- en: We could continue to expand our tests with additional examples and counter-examples,
    but let’s move on to talking briefly about debugging our Roslyn Analyzers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续通过添加额外的示例和反例来扩展我们的测试，但让我们简要地谈谈调试我们的 Roslyn 分析器。
- en: Debugging Roslyn Analyzers
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试 Roslyn 分析器
- en: When you write a Roslyn Analyzer, it’s unlikely that you’ll get it right the
    first time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写 Roslyn 分析器时，你很可能不会第一次就写对。
- en: Unit tests help detect failures in your analyzer, but let’s talk about how you
    would debug a Roslyn Analyzer.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试有助于检测分析器中的失败，但让我们谈谈如何调试 Roslyn 分析器。
- en: 'My recommended approach with Roslyn Analyzers is to follow the approach of
    this chapter: *create a class library containing your analyzer and a test project
    that* *tests it*.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐的 Roslyn 分析器方法是遵循本章的方法：*创建一个包含你的分析器和测试项目的类库*。
- en: 'If your analyzer isn’t properly triggering for certain code, you can put breakpoints
    in your analyzer code and step through the code for a specific instance by right-clicking
    on a specific test and selecting **Debug**, as shown in *Figure 13**.7*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的分析器没有正确触发某些代码，你可以在分析器代码中设置断点，并通过右键单击特定测试用例并选择 **调试** 来逐步执行特定实例，如图 *图 13**.7*
    所示：
- en: '![Figure 13.7 – Debugging a specific test case](img/B21324_13_7.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – 调试特定测试用例](img/B21324_13_7.jpg)'
- en: Figure 13.7 – Debugging a specific test case
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – 调试特定测试用例
- en: I’ve found this approach to be generally very helpful when analyzing specific
    test cases. In these scenarios, I can see the exact objects the analyzer encounters
    from the test scenario. From there, I wrote enough code to get the analyzer to
    handle that scenario. Once the analyzer has handled that test case, I’m usually
    at a point where I’m ready to try the analyzer on a wider range of code, which
    we’ll discuss next.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现这种方法在分析特定测试用例时非常有帮助。在这些情况下，我可以看到分析器从测试场景中遇到的精确对象。从那里，我编写了足够的代码，使分析器能够处理该场景。一旦分析器处理了该测试用例，我通常就准备好在更广泛的代码范围内尝试分析器了，我们将在下一节讨论。
- en: Sharing analyzers as Visual Studio extensions
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将分析器作为 Visual Studio 扩展共享
- en: 'Once you’re ready to try an analyzer on more code or share it with your peers,
    there are a few options available:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好在更多代码上尝试分析器或与你的同事共享它，就有几种选项可供选择：
- en: Deploy the analyzer as a NuGet package, as we’ll discuss in the next chapter
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分析器作为 NuGet 包部署，我们将在下一章讨论
- en: Create a **Visual Studio Installer** (**VSIX**) to install the analyzers locally
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Visual Studio 安装程序** (**VSIX**) 来本地安装分析器
- en: 'Create a new project and add an explicit reference to the analyzers by editing
    the `.csproj` file and adding an `Analyzer` node, as shown here:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的项目，并通过编辑 `.csproj` 文件并添加一个 `Analyzer` 节来显式引用分析器，如图所示：
- en: '[PRE10]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This last approach is one you might consider if you had a large solution and
    wanted your analyzer to only apply to other projects in that solution. However,
    I’ve found this approach to be buggy and require frequent reloads of Visual Studio
    for changes in the analyzers to take hold, so we’ll use the VSIX approach as we
    close out this chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个大型解决方案并且希望你的分析器只应用于该解决方案中的其他项目，你可能考虑采用这种方法。然而，我发现这种方法存在错误，并且需要频繁重新加载 Visual
    Studio 以使分析器更改生效，所以我们将在本章结束时使用 VSIX 方法。
- en: Creating a Visual Studio extension (VSIX) for your Roslyn Analyzer
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为你的 Roslyn 分析器创建一个 Visual Studio 扩展 (VSIX)
- en: Visual Studio extension projects (VSIX projects) allow you to bundle a diverse
    set of capabilities into an extension that can then be installed into Visual Studio.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 扩展项目 (VSIX 项目) 允许你将各种功能打包成一个扩展，然后可以将其安装到 Visual Studio 中。
- en: Let’s create a new VSIX project, add our analyzer to it, and then use it in
    a new instance of Visual Studio.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 VSIX 项目，将我们的分析器添加到其中，然后在 Visual Studio 的新实例中使用它。
- en: 'We’ll start as we usually do: by right-clicking on the solution in **Solution
    Explorer**, choosing **Add**, and then **New Project…**.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像往常一样开始：在 **解决方案资源管理器** 中右键单击解决方案，选择 **添加**，然后选择 **新建项目…**。
- en: Next, select the `Packt.Analyzers.Installer` and click **Create**.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择 `Packt.Analyzers.Installer` 并点击 **创建**。
- en: 'This empty project consists of a single `source.extension.vsixmanifest` file,
    which we’ll refer to as the manifest. This manifest is the only file we’ll need.
    Double-click on it to open the designer, as shown in *Figure 13**.8*:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个空项目包含一个单独的 `source.extension.vsixmanifest` 文件，我们将称之为清单。这是我们需要唯一的一个文件。双击它以打开设计器，如图
    13.8* 所示：
- en: '![Figure 13.8 – The manifest in the design view](img/B21324_13_8.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – 设计视图中的清单](img/B21324_13_8.jpg)'
- en: Figure 13.8 – The manifest in the design view
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 设计视图中的清单
- en: This opens the metadata view, which contains different settings you can configure.
    We’ll ignore those and click on the **Assets** blade on the left sidebar.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开元数据视图，其中包含你可以配置的不同设置。我们将忽略这些设置，并点击左侧侧边栏上的 **资产** 选项卡。
- en: The **Assets** blade specifies the different components that are included in
    the extension. We want to include our analyzer, so click **New** to open the **Add
    New** **Asset** dialogue.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**资产** 选项卡指定了扩展中包含的不同组件。我们希望包含我们的分析器，因此点击 **新建** 以打开 **添加新资产** 对话框。'
- en: 'Next, specify the `Packt.Analyzers` project, as shown in *Figure 13**.9*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，指定 `Packt.Analyzers` 项目，如图 13.9* 所示：
- en: '![Figure 13.9 – Adding the Roslyn Analyzer to your VSIX project as an asset](img/B21324_13_9.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.9 – 将 Roslyn 分析器作为资产添加到你的 VSIX 项目中](img/B21324_13_9.jpg)'
- en: Figure 13.9 – Adding the Roslyn Analyzer to your VSIX project as an asset
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – 将 Roslyn 分析器作为资产添加到你的 VSIX 项目中
- en: Click **OK**; your analyzer should now appear in the list of assets.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **确定**；你的分析器现在应该出现在资产列表中。
- en: With that change, our VSIX project is now ready for us to use. To test this
    project, right-click on the `Packt.Analyzers.Installer` project and choose **Set
    as Startup Project**. Next, run your project – a new experimental instance of
    Visual Studio will open.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，我们的 VSIX 项目现在已准备好使用。要测试此项目，请右键单击 `Packt.Analyzers.Installer` 项目并选择 **设置为启动项目**。接下来，运行你的项目
    – 将打开一个新的实验性 Visual Studio 实例。
- en: Note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It can take a few minutes for Visual Studio to open after you run the project.
    The version of Visual Studio that opens is built specifically for developing extensions
    and needs additional time to launch. It is not recommended to use this version
    of Visual Studio for actual development. Instead, use it to test your extensions
    and then close it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行项目后，Visual Studio 打开可能需要几分钟时间。打开的 Visual Studio 版本是专门为开发扩展而构建的，需要额外的时间来启动。不建议使用此版本的
    Visual Studio 进行实际开发。相反，使用它来测试你的扩展，然后关闭它。
- en: After a few minutes, a new instance of Visual Studio will open with your VSIX
    project installed. Using this instance of Visual Studio, you can open any other
    project and the Roslyn Analyzer you built in this chapter will be active.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，将打开一个新的 Visual Studio 实例，其中已安装你的 VSIX 项目。使用此实例的 Visual Studio，你可以打开任何其他项目，本章中构建的
    Roslyn 分析器将处于活动状态。
- en: 'Specifically, our analyzer will show up as a suggestion on classes that don’t
    override `ToString`, such as the `SkillController` class in *Figure 13**.10*:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们的分析器将在没有重写 `ToString` 的类上显示建议，例如图 13.10* 中的 `SkillController` 类：
- en: '![Figure 13.10 – Our Roslyn Analyzer suggests overriding ToString](img/B21324_13_10.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.10 – 我们的 Roslyn 分析器建议重写 ToString](img/B21324_13_10.jpg)'
- en: Figure 13.10 – Our Roslyn Analyzer suggests overriding ToString
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10 – 我们的 Roslyn 分析器建议重写 ToString
- en: Warnings for your analyzer will also show up in the error list, though if you
    marked them as having a severity, as we did in the chapter, you’ll need to make
    sure that messages are displayed in those results. See the highlighted button
    in *Figure 13**.10* for the message filter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你的分析器的警告也会显示在错误列表中，尽管如果你已经将它们标记为具有严重性，如我们在本章中所做的那样，你需要确保消息显示在这些结果中。请参阅图 13.10*
    中突出显示的消息过滤器按钮。
- en: DebuggerDisplay attributes versus ToString overrides
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: DebuggerDisplay 属性与 ToString 重写之间的比较
- en: This chapter uses `ToString` as an example, and overriding `ToString` can help
    with the debugger experience. An alternative to this would be to add a `[DebuggerDisplay]`
    attribute above your class definition to describe how it appears in the debugger
    without needing to override `ToString`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以 `ToString` 为例，重写 `ToString` 方法可以帮助改善调试器的体验。另一种方法是，在你的类定义上方添加 `[DebuggerDisplay]`
    属性来描述它在调试器中的显示方式，而无需重写 `ToString`。
- en: Once you are satisfied with your test, close the new instance of Visual Studio.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对测试结果满意，请关闭 Visual Studio 的新实例。
- en: Building and testing your installer will have created a `Packt.Analyzers.Installer.vsix`
    file in the `bin/Debug` folder within your extension project. This `.vsix` file
    will let other people install your custom extension and use your analyzers in
    their projects.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和测试您的安装程序将在您的扩展项目 `bin/Debug` 文件夹中创建一个 `Packt.Analyzers.Installer.vsix` 文件。这个
    `.vsix` 文件将允许其他人安装您的自定义扩展并在他们的项目中使用您的分析器。
- en: Note
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You could also distribute your installer on the Visual Studio marketplace. This
    would make the extension publicly available and easier for others to locate and
    download.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在 Visual Studio 市场中分发您的安装程序。这将使扩展公开可用，并使其他人更容易找到和下载。
- en: Any time you update your analyzer, you’ll need to share a new version of the
    extension and your team will need to upgrade. This makes managing Roslyn Analyzers
    via `.vsix` files challenging.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您更新您的分析器时，您都需要分享扩展的新版本，并且您的团队需要升级。这使得通过 `.vsix` 文件管理 Roslyn 分析器具有挑战性。
- en: Fortunately, NuGet packages offer a better way of sharing Roslyn Analyzers,
    as we’ll see in the next chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，NuGet 包提供了一种更好的方式来共享 Roslyn 分析器，我们将在下一章中看到。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created our first Roslyn Analyzer, tested it with `RoslynTestKit`,
    and built a VSIX extension to integrate it into Visual Studio.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了我们的第一个 Roslyn 分析器，使用 `RoslynTestKit` 进行测试，并构建了一个 VSIX 扩展以将其集成到 Visual
    Studio 中。
- en: We saw how Roslyn Analyzers power all the warnings we interact with in Visual
    Studio and how you and your team can create new Roslyn Analyzers to detect and
    flag issues that are unique to your team and its codebase.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了 Roslyn 分析器如何驱动我们在 Visual Studio 中交互的所有警告，以及您和您的团队如何创建新的 Roslyn 分析器来检测和标记对您的团队及其代码库独特的问题。
- en: In the next chapter, we’ll see how Roslyn Analyzers can be used to fix the issues
    they find and help safely refactor your code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用 Roslyn 分析器来修复它们发现的问题，并帮助安全地重构您的代码。
- en: Questions
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do Roslyn Analyzers work?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Roslyn 分析器是如何工作的？
- en: When would you want to create your own Roslyn Analyzer?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您何时想创建自己的 Roslyn 分析器？
- en: How can you verify that Roslyn Analyzers work correctly?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何验证 Roslyn 分析器是否正确工作？
- en: Further reading
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find more information about the topics that were covered in this chapter
    at these URLs:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网址找到关于本章所涵盖主题的更多信息：
- en: '*Roslyn* *Analyzers*: [https://learn.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview](https://learn.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Roslyn* *分析器*: [https://learn.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview](https://learn.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview)'
- en: '*Install third-party* *analyzers*: [https://learn.microsoft.com/en-us/visualstudio/code-quality/install-roslyn-analyzers](https://learn.microsoft.com/en-us/visualstudio/code-quality/install-roslyn-analyzers)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安装第三方* *分析器*: [https://learn.microsoft.com/en-us/visualstudio/code-quality/install-roslyn-analyzers](https://learn.microsoft.com/en-us/visualstudio/code-quality/install-roslyn-analyzers)'
- en: '*Awesome* *Roslyn*: [https://github.com/ironcev/awesome-roslyn](https://github.com/ironcev/awesome-roslyn)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Awesome* *Roslyn*: [https://github.com/ironcev/awesome-roslyn](https://github.com/ironcev/awesome-roslyn)'
- en: '.*NET* *Standard*: [https://learn.microsoft.com/en-us/dotnet/standard/net-standard](https://learn.microsoft.com/en-us/dotnet/standard/net-standard)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '.*NET* *标准*: [https://learn.microsoft.com/en-us/dotnet/standard/net-standard](https://learn.microsoft.com/en-us/dotnet/standard/net-standard)'
- en: 'Here are some popular open-source Roslyn Analyzers on GitHub:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些在 GitHub 上流行的开源 Roslyn 分析器：
- en: '*Roslyn* *Analyzers*: *https://github.com/dotnet/roslyn-analyzers*'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Roslyn* *分析器*: *https://github.com/dotnet/roslyn-analyzers*'
- en: '*StyleCop*: [https://github.com/DotNetAnalyzers/StyleCopAnalyzers](https://github.com/DotNetAnalyzers/StyleCopAnalyzers)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*StyleCop*: [https://github.com/DotNetAnalyzers/StyleCopAnalyzers](https://github.com/DotNetAnalyzers/StyleCopAnalyzers)'
