<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div id="_idContainer229" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-117"><a id="_idTextAnchor147" class="pcalibre pcalibre1 calibre6"/>8</h1>
<h1 id="_idParaDest-118" class="calibre5"><a id="_idTextAnchor148" class="pcalibre pcalibre1 calibre6"/>The Event System and Programming for UI</h1>
<p class="calibre3">One of the key features of the Unity UI system is the ability to easily program how the UI elements receive interactions from the player<a id="_idIndexMarker320" class="pcalibre pcalibre1 calibre6"/> via events. The <strong class="bold">Event System</strong> is a robust system that allows you to create and <span>manage events.</span></p>
<p class="calibre3">Once you learn how to take advantage of the Event System, you will be able to create interactable UI as well as UI that responds to events in <span>your game.</span></p>
<p class="calibre3">In this chapter, we will discuss the <span>following topics:</span></p>
<ul class="calibre16">
<li class="calibre14">How to access UI elements and their properties <span>via code</span></li>
<li class="calibre14">What the Event System is and how to work <span>with it</span></li>
<li class="calibre14">How to customize input axes with the <span>Input Manager</span></li>
<li class="calibre14">What an Input Module is, and which ones are provided <span>by Unity</span></li>
<li class="calibre14">How to use the Event Trigger component to receive events on <span>UI objects</span></li>
<li class="calibre14">What Raycasters are and what types of Raycasters are provided <span>by Unity</span></li>
<li class="calibre14">How to show and hide pop-up Panels using <span>keyboard inputs</span></li>
<li class="calibre14">How to pause <span>the game</span></li>
<li class="calibre14">How to create a drag and drop <span>inventory system</span></li>
<li class="calibre14">How to use mouse or multi-touch input to pan and zoom <span>the camera</span></li>
</ul>
<h1 id="_idParaDest-119" class="calibre5"><a id="_idTextAnchor149" class="pcalibre pcalibre1 calibre6"/>Technical requirements</h1>
<p class="calibre3">You can find the relevant codes and asset files of this chapter <span>here: </span><a href="https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2008" class="pcalibre pcalibre1 calibre6"><span>https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2008</span></a></p>
<h1 id="_idParaDest-120" class="calibre5"><a id="_idTextAnchor151" class="pcalibre pcalibre1 calibre6"/>Accessing UI elements in code</h1>
<p class="calibre3">All the UI elements <a id="_idIndexMarker321" class="pcalibre pcalibre1 calibre6"/>can be accessed and manipulated in code like other GameObjects. To access a UI element in code, you must include the <strong class="source-inline">UnityEngine.UI</strong> namespace and the correct variable type. Let’s look at the <span><strong class="source-inline">UnityEngine.UI</strong></span><span> namespace.</span><a id="_idTextAnchor152" class="pcalibre pcalibre1 calibre6"/></p>
<h2 id="_idParaDest-121" class="calibre7"><a id="_idTextAnchor153" class="pcalibre pcalibre1 calibre6"/>UnityEngine.UI namespace</h2>
<p class="calibre3">A <strong class="bold">namespace</strong> is a <a id="_idIndexMarker322" class="pcalibre pcalibre1 calibre6"/>collection of classes. When you include a namespace in your class, you are stating that you want to access all the <a id="_idIndexMarker323" class="pcalibre pcalibre1 calibre6"/>variables and methods (functions) in your class. Namespaces are accessed at the top of a script with the <span><strong class="source-inline">using</strong></span><span> keyword.</span></p>
<p class="calibre3">By default, all new C# scripts include the <strong class="source-inline">System.Collections</strong>, <strong class="source-inline">System.Collections.Generic</strong> and <strong class="source-inline">UnityEngine</strong> namespaces. To access the properties of UI elements via code, you must first use the <span><strong class="source-inline">UnityEngine.UI</strong></span><span> namespace.</span></p>
<p class="calibre3">Therefore, at the top of your C# script, you will need to include the following line to signify that you want to use the <span><strong class="source-inline">UnityEngine.UI</strong></span><span> namespace:</span></p>
<pre class="source-code">
using UnityEngine.UI;</pre> <p class="calibre3">Without using the namespace, any variable type related to UI elements will be colored red in your code editor, and you will be given a compiler error. Once you include the namespace, the variable type will change to the blue-colored text, signifying that it is an available variable type, and the compiler error <span>will disappe<a id="_idTextAnchor154" class="pcalibre pcalibre1 calibre6"/>ar.</span></p>
<h2 id="_idParaDest-122" class="calibre7"><a id="_idTextAnchor155" class="pcalibre pcalibre1 calibre6"/>UI variable types</h2>
<p class="calibre3">Each variable type is a <a id="_idIndexMarker324" class="pcalibre pcalibre1 calibre6"/>class within the <strong class="source-inline">UnityEngine.UI</strong> namespace. Therefore, each of these variable types, in turn, has its own set of variables and functions that can be accessed. We’ll discuss each variable type more thoroughly in future sections and chapters, but for now, let’s just look at the standard template for accessing a property of a UI element <span>in code.</span></p>
<p class="calibre3">You can find within the source files a Unity package named <span><strong class="source-inline">Chapter 08</strong></span><strong class="source-inline">.unitypackage</strong>. Importing it will bring in a scene named <strong class="source-inline">Chapter8.unity</strong> and various code files. Import the items from the package and open the scene. In the <strong class="source-inline">Chapter8</strong> scene, you will see a UI Image named <strong class="source-inline">UI Variables Example</strong>. It does not have a sprite assigned to it and appears as a white square. The following script, <strong class="source-inline">AddSprite.cs</strong>, is attached <a id="_idIndexMarker325" class="pcalibre pcalibre1 calibre6"/>to the <span>UI Image:</span></p>
<pre class="source-code">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
<strong class="bold">using UnityEngine.UI;</strong>
public class AddSprite : MonoBehaviour {
     <strong class="bold">Image theImage;</strong>
     public Sprite theSprite;
     void Awake(){
          <strong class="bold">theImage = GetComponent&lt;Image&gt;();</strong>
     }
     void Start () {
          <strong class="bold">theImage.sprite = theSprite;</strong>
          <strong class="bold">theImage.preserveAspect = true;</strong>
     }
}</pre> <p class="calibre3">The UI-specific pieces of code are highlighted in the preceding code. Note that the <strong class="source-inline">UnityEngine.UI</strong> namespace is included at the top of <span>the class.</span></p>
<p class="calibre3">There are two public variables defined in the class: <strong class="source-inline">theImage</strong>, which is an <strong class="source-inline">Image</strong> type, and <strong class="source-inline">theSprite</strong>, which is a <strong class="source-inline">Sprite</strong> type. The <strong class="source-inline">theImage</strong> variable is referencing the UI Image in the scene and the <strong class="source-inline">theSprite</strong> variable is referencing the sprite that will become the source image of the <span>UI Image.</span></p>
<p class="calibre3">The <strong class="source-inline">Image</strong> variable type is within the <strong class="source-inline">UnityEngine.UI</strong> namespace and represents UI Image GameObject. The <strong class="source-inline">Sprite</strong> variable type is not a UI element and is included in the <span><strong class="source-inline">UnityEngine</strong></span><span> namespace.</span></p>
<p class="calibre3">Within the <strong class="source-inline">Start()</strong> function, the properties of the <strong class="source-inline">Image</strong> component on <strong class="source-inline">theImage</strong> are referenced by typing a period and then the property after the variable name. You can access<a id="_idIndexMarker326" class="pcalibre pcalibre1 calibre6"/> any property that appears in a UI element’s corresponding component in this way. You can also access properties that are not listed in the component <span>this way.</span></p>
<p class="calibre3">The <strong class="source-inline">AddSprite</strong> script attached to <strong class="source-inline">UI Variables Example (Image)</strong> appears in the inspector, as shown in the <span>following screenshot:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer183">
<img alt="Figure 8.1: The AddSprite script and its properties" src="image/B18327_08_01.jpg" class="calibre182"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.1: The AddSprite script and its properties</p>
<p class="calibre3">Now, when the scene is played, the sprite will change from a blank white square to an image of a banana with its aspect <span>ratio preserved.</span></p>
<p class="calibre3">Let’s explore the Event System, which will allow us to interact with <span>ou<a id="_idTextAnchor156" class="pcalibre pcalibre1 calibre6"/>r UI.</span></p>
<h1 id="_idParaDest-123" class="calibre5"><a id="_idTextAnchor157" class="pcalibre pcalibre1 calibre6"/>The Event System</h1>
<p class="calibre3">In <a href="B18327_06.xhtml#_idTextAnchor085" class="pcalibre pcalibre1 calibre6"><span><em class="italic">Chapter 6</em></span></a>, we<a id="_idIndexMarker327" class="pcalibre pcalibre1 calibre6"/> learned that when the first Canvas is added to a scene, a GameObject named <strong class="source-inline">EventSystem</strong> is automatically added to the Hierarchy. The Event System allows you to easily receive player interactions and send those interactions to objects in your scene through events. Note that I said, <em class="italic">objects in your scene</em> and not <em class="italic">UI objects</em>. The Event System allows you to send events to non-UI <span>items, too!</span></p>
<p class="calibre3">Before we proceed, I’d like to note my use of <strong class="source-inline">EventSystem</strong> (one word) and Event System (two words), because I will be switching back and forth between the two. I want you to know that I am doing it deliberately and am not just randomly deciding that sometimes I hate <span>the spacebar.</span></p>
<p class="calibre3">I will use <strong class="source-inline">EventSystem</strong> (one word) to reference the actual GameObject that appears in the Hierarchy of your scene and Event System (two words) to reference the system that <span>handles events.</span></p>
<p class="calibre3">The Event System <a id="_idIndexMarker328" class="pcalibre pcalibre1 calibre6"/>does quite a few things for you other than just sending events to objects. It also keeps track of the currently selected GameObject, the Input Modules, <span>and Raycasting.</span></p>
<p class="calibre3">The EventSystem GameObject initializes, by default, with three components: the <strong class="bold">Transform</strong>, <strong class="bold">Event System</strong> Manager, and <strong class="bold">Standalone Input Module</strong>, as shown in the <span>following screenshot:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer184">
<img alt="Figure 8.2: The EventSystem GameObject and its components" src="image/B18327_08_02.jpg" class="calibre183"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.2: The EventSystem GameObject and its components</p>
<p class="calibre3">Since <strong class="source-inline">EventSystem</strong> is a GameObject, it physically exists within the scene (even though it has no renderable <a id="_idIndexMarker329" class="pcalibre pcalibre1 calibre6"/>component making it visible) and therefore has a <strong class="bold">Transform</strong> component like all other GameObjects. You should be familiar with the <strong class="bold">Transform</strong> component by now, so we won’t discuss it further. However, the other two components do merit further discussion. Let’s look at the <strong class="bold">Event System</strong> component more closely now. We’ll also discuss the <strong class="bold">Standalone Input Module</strong> component in the <em class="italic">Input Modules</em> section of <span>this chapter.</span></p>
<p class="calibre3">You cannot have more than that one <strong class="source-inline">EventSystem</strong> GameObject in your scene. If you try to add a new one in the scene via <strong class="bold">+</strong> | <strong class="bold">UI</strong> | <strong class="bold">Event System</strong>, a new one will not be added, and the one currently in the scene will be selected <span>for you.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">If you manage to add a second <strong class="source-inline1">EventSystem</strong> to your scene (by perhaps using <em class="italic">Ctrl</em> + <em class="italic">D</em> to duplicate the existing one), you will see a warning message on <span>your </span><span><strong class="bold">Console</strong></span><span>.</span></p>
<p class="callout">If you have more than one <strong class="source-inline1">EventSystem</strong> GameObject in your scene, only the first one added will actually do anything. Any additional <strong class="source-inline1">EventSystems</strong> will <span>be non-functional.</span></p>
<p class="calibre3">Let’s look at the <strong class="bold">Event System</strong> <span>Manage<a id="_idTextAnchor158" class="pcalibre pcalibre1 calibre6"/>r next.</span></p>
<h2 id="_idParaDest-124" class="calibre7"><a id="_idTextAnchor159" class="pcalibre pcalibre1 calibre6"/>Event System Manager</h2>
<p class="calibre3"><strong class="bold">Event System </strong>Manager<a id="_idIndexMarker330" class="pcalibre pcalibre1 calibre6"/> is the component that actually does all the tracking and managing of the various <strong class="bold">Event </strong><span><strong class="bold">System</strong></span><span> elements.</span></p>
<p class="calibre3">If you want to work with the <strong class="bold">Event System</strong> without using UI, the <strong class="source-inline">EventSystem</strong> GameObject will not be automatically created for you. You can add an <strong class="bold">Event System</strong> Manager to a GameObject by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Event System</strong> on the object’s Inspector. Let’s talk about the properties under the <strong class="bold">Event </strong><span><strong class="bold">System</strong></span><span> M<a id="_idTextAnchor160" class="pcalibre pcalibre1 calibre6"/>anager.</span></p>
<h3 class="calibre9">First Selected</h3>
<p class="calibre3">You know <a id="_idIndexMarker331" class="pcalibre pcalibre1 calibre6"/>when you start up a game and the <strong class="bold">Start Game</strong> button is highlighted for you so that hitting <em class="italic">Enter</em> will start the game without you having to use your mouse? That’s what the <strong class="bold">First Selected</strong> property does for you. It selects a UI element in the scene for you<a id="_idIndexMarker332" class="pcalibre pcalibre1 calibre6"/> automatically when it <span>starts up.</span></p>
<p class="calibre3">You can drag and drop any intractable UI element into this slot to make it the first selected UI item in your scene. This is particularly helpful for games that do not use a mouse or touchscreen but rely solely on a gamepad, joystick, <span>or<a id="_idTextAnchor161" class="pcalibre pcalibre1 calibre6"/> keyboard.</span></p>
<h3 class="calibre9">Send Navigation Events</h3>
<p class="calibre3">The <strong class="bold">Send Navigation Events</strong> property can be toggled on and off. When this property is enabled, you<a id="_idIndexMarker333" class="pcalibre pcalibre1 calibre6"/> can navigate between UI elements via a gamepad, joystick, or keyboard. The following navigation events can <span>be used:</span></p>
<ul class="calibre16">
<li class="calibre14"><strong class="bold">Move</strong>: You can select the various UI elements via arrow keys on the keyboard or the control stick on a gamepad (or whichever keys/buttons you have designated as the movement keys). Movement will start at the UI item designated <strong class="bold">First Selected</strong>. We will discuss how to specify the order in which UI items are selected using movement in <a href="B18327_10.xhtml#_idTextAnchor236" class="pcalibre pcalibre1 calibre6"><span><em class="italic">Chapter 10</em></span></a><span>.</span></li>
<li class="calibre14"><strong class="bold">Submit</strong>: Commit to the UI <span>item selected.</span></li>
<li class="calibre14"><strong class="bold">Cancel</strong>: Cancel <span>the<a id="_idTextAnchor162" class="pcalibre pcalibre1 calibre6"/> selection.</span></li>
</ul>
<h3 class="calibre9">Drag Threshold</h3>
<p class="calibre3">The <strong class="bold">Drag Threshold</strong> property represents the number of pixels a UI object can be moved <a id="_idIndexMarker334" class="pcalibre pcalibre1 calibre6"/>before it is considered being <em class="italic">dragged</em>. People don’t have perfectly steady hands, so when they are trying to click or tap a UI item, their mouse or finger may move slightly. This <strong class="bold">Drag Threshold</strong> allows the player to move their input slightly (or a lot if you make this number high) before the item they are selecting is <em class="italic">dragged</em> rather <span>t<a id="_idTextAnchor163" class="pcalibre pcalibre1 calibre6"/>han </span><span><em class="italic">clicked</em></span><span>.</span></p>
<h1 id="_idParaDest-125" class="calibre5"><a id="_idTextAnchor164" class="pcalibre pcalibre1 calibre6"/>Input Manager</h1>
<p class="calibre3">Before <a id="_idIndexMarker335" class="pcalibre pcalibre1 calibre6"/>we discuss the next component of the <strong class="bold">Event System</strong> Manager, I want to discuss the Input Manager. The Input Manager is where you define the axes in your game by assigning them to the buttons on your mouse, keyboard, or joystick (gamepad). This also allows you to use the axis name when coding to easily reference all inputs that you want to perform in <span>an action.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">Remember, as we discussed in <a href="B18327_05.xhtml#_idTextAnchor072" class="pcalibre pcalibre1 calibre6"><span><em class="italic">Chapter 5</em></span></a>, there are actually two systems that will allow you to handle input in your game: the Input Manager and the new Input System. This chapter will focus on the Input Manager. We will discuss the new Input System in a <span>future chapter.</span></p>
<p class="calibre3">To open the <strong class="bold">Input Manager</strong>, select <strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> | <span><strong class="bold">Input Manager</strong></span><span>.</span></p>
<p class="calibre3">If you<a id="_idIndexMarker336" class="pcalibre pcalibre1 calibre6"/> select the arrow next to <strong class="bold">Axes</strong>, you will see the default list <span>of axes:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer185">
<img alt="Figure 8.3: The Input Manager and all its pre-defined axes" src="image/B18327_08_03.jpg" class="calibre184"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.3: The Input Manager and all its pre-defined axes</p>
<p class="calibre3">There are 30 total axes by default. Changing the number next to <strong class="bold">Size</strong> will give you more or less axes. Expanding the individual axes will reveal <span>the following:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer186">
<img alt="Figure 8.4: The first Horizontal input axis" src="image/B18327_08_04.jpg" class="calibre185"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.4: The first Horizontal input axis</p>
<p class="calibre3">The word <a id="_idIndexMarker337" class="pcalibre pcalibre1 calibre6"/>entered in the <strong class="bold">Name</strong> slot is what will appear next to the expandable arrow. In the preceding screenshot, all the keys that allow for horizontal movement have <span>been defined.</span></p>
<p class="calibre3">Note that the left and right arrows, along with the <em class="italic">A</em> and <em class="italic">D</em> keys of a keyboard, are defaulted to the <span><strong class="bold">Horizontal</strong></span><span> movement.</span></p>
<p class="calibre3">There is also a second <strong class="bold">Horizontal</strong> axis further down the list. It is configured to work with a joystick or <span>a gamepad.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer187">
<img alt="Figure 8.5: The second Horizontal input axis" src="image/B18327_08_05.jpg" class="calibre186"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.5: The second Horizontal input axis</p>
<p class="calibre3">As there<a id="_idIndexMarker338" class="pcalibre pcalibre1 calibre6"/> are two <strong class="bold">Axes</strong> labeled <strong class="bold">Horizontal</strong>, they can both be easily referenced in code with the <strong class="source-inline">"</strong><span><strong class="source-inline">Horizontal"</strong></span><span> label.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">To view a list of <a id="_idIndexMarker339" class="pcalibre pcalibre1 calibre6"/>the keywords for each keyboard key as well as a description for each of the properties of an axis input, <span>visit </span><a href="https://docs.unity3d.com/Manual/class-InputManager.xhtml" class="pcalibre pcalibre1 calibre6"><span>https://docs.unity3d.com/Manual/class-InputManager.xhtml</span></a><span>.</span></p>
<p class="calibre3">This will allow you to reference all these buttons and joysticks together as a group. This is much simpler than having to write code that gets each of the individual keyboard keys along the <span>individual joysticks.</span></p>
<p class="calibre3">You can delete any of these 30 default axes you want by right-clicking on them and selecting <strong class="bold">Delete </strong><span><strong class="bold">Array Element</strong></span><span>.</span></p>
<p class="calibre3">However, be careful when you delete them. You need at least one <strong class="bold">Submit</strong> axis and one <strong class="bold">Cancel</strong> axis to be able to use the <strong class="bold">Standalone Input Manager</strong> (unless you change the <strong class="bold">Submit Button</strong> and <strong class="bold">Cancel Button</strong> in the <strong class="bold">Standalone Input Manager</strong>). For more information, refer to the <em class="italic">Standalone Input Manager</em> section of <span>this chapter.</span></p>
<p class="calibre3">Now that we have explored the Input Manager, we can review the various input functions for buttons an<a id="_idTextAnchor165" class="pcalibre pcalibre1 calibre6"/>d <span>key presses.</span></p>
<h1 id="_idParaDest-126" class="calibre5"><a id="_idTextAnchor166" class="pcalibre pcalibre1 calibre6"/>Input functions for buttons and key presses</h1>
<p class="calibre3">There <a id="_idIndexMarker340" class="pcalibre pcalibre1 calibre6"/>are quite a few ways to access key and button presses via code. How you do this depends on whether you have the key specified as an axis in the <strong class="bold">Input Manager</strong> and whether you want the key to register once or continuously. I’ll discuss a few in this text, but you can find a full list of the functions <span>at </span><a href="https://docs.unity3d.com/ScriptReference/Input.xhtml" class="pcalibre pcalibre1 calibre6"><span>https://docs.unity3d.com/ScriptReference/Input.xhtml</span></a><span>.</span></p>
<p class="calibre3">A script named <strong class="source-inline">KeyPresses.cs</strong> is attached to the <strong class="source-inline">Main Camera</strong> in the <strong class="source-inline">Chapter8</strong> example scene we were reviewing earlier in this chapter. The <strong class="source-inline">KeyPresses.cs</strong> script contains all the code demonstrated in this section if you’d like to play around wi<a id="_idTextAnchor167" class="pcalibre pcalibre1 calibre6"/>th <span>key presses.</span></p>
<h2 id="_idParaDest-127" class="calibre7"><a id="_idTextAnchor168" class="pcalibre pcalibre1 calibre6"/>GetButton</h2>
<p class="calibre3">If you <a id="_idIndexMarker341" class="pcalibre pcalibre1 calibre6"/>have a button defined as an axis in the <strong class="bold">Input Manager</strong>, you <a id="_idIndexMarker342" class="pcalibre pcalibre1 calibre6"/>can use <strong class="source-inline">GetButton()</strong>, <strong class="source-inline">GetButtonDown()</strong>, and <strong class="source-inline">GetButtonUp()</strong> to determine when a button has <span>been pressed.</span></p>
<p class="calibre3"><strong class="source-inline">GetButton()</strong> returns <strong class="source-inline">true</strong> while the button is being held, <strong class="source-inline">GetButtonDown()</strong> returns <strong class="source-inline">true</strong> only once, on the frame that the button is initially pressed, and <strong class="source-inline">GetButtonUp()</strong> returns <strong class="source-inline">true</strong> only once, on the frame that the button <span>is released.</span></p>
<p class="calibre3">Within each of the functions, you place the axis name from the <strong class="bold">Input Manager</strong> within the parentheses within quotes. Generally, these functions should be called within the <strong class="source-inline">Update()</strong> function of a script so that they can be triggered at <span>any time.</span></p>
<p class="calibre3">So, for example, if you wanted to check whether the <em class="italic">Enter</em> key is being pressed, since it is assigned to a <strong class="bold">Positive Button</strong> for the <strong class="bold">Submit</strong> axis, you can write the following code to trigger when the <em class="italic">Enter</em> key is <span>pressed down:</span></p>
<pre class="source-code">
void Update () {
     if (Input.GetButtonDown("Submit")){
          Debug.Log("You pressed a submit key/button!");
     }
}</pre> <p class="calibre3">Keep in mind <a id="_idIndexMarker343" class="pcalibre pcalibre1 calibre6"/>that this will not just trigger with the <em class="italic">Enter</em> key, as the <strong class="bold">Submit</strong> axis has a few keys<a id="_idIndexMarker344" class="pcalibre pcalibre1 calibre6"/> assigned to the <strong class="bold">Positive Button</strong> and <strong class="bold">Alt </strong><span><strong class="bold">Positive Button</strong></span><span>.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">It’s important to note that if you play the <strong class="source-inline1">Chapter8</strong> scene and want to watch these button and key presses fire the console log messages, you must first click within the <strong class="bold">Game View</strong> so that the inputs will re<a id="_idTextAnchor169" class="pcalibre pcalibre1 calibre6"/>gister in <span>the game.</span></p>
<h2 id="_idParaDest-128" class="calibre7"><a id="_idTextAnchor170" class="pcalibre pcalibre1 calibre6"/>GetAxis</h2>
<p class="calibre3">If you’re <a id="_idIndexMarker345" class="pcalibre pcalibre1 calibre6"/>looking for a function that will trigger continuously <a id="_idIndexMarker346" class="pcalibre pcalibre1 calibre6"/>without any breaks between firing, you want to use <strong class="source-inline">GetAxis()</strong> rather than <strong class="source-inline">GetButton()</strong>. <strong class="source-inline">GetButton()</strong> is good for buttons you want to hold down but want a slight pause between events firing (think of holding down a fire button, and the gun shoots bullets with breaks in between them). <strong class="source-inline">GetAxis()</strong> works better for events involving movement because of this continuous frame-rate <span>independent execution.</span></p>
<p class="calibre3"><strong class="source-inline">GetAxis()</strong> works a bit differently, as it returns a <strong class="source-inline">float</strong> value rather than a <strong class="source-inline">bool</strong>, such as <strong class="source-inline">GetButton()</strong>. It is also best suited within an <strong class="source-inline">Update()</strong> function. So, for example, you can check whether the horizontal movement is occurring <span>as follows:</span></p>
<pre class="source-code">
void Update () {
     float horizontalValue = Input.GetAxis("Horizontal");
     if (horizontalValue != 0){
          Debug.Log("You're holding down a horizontal button!");
     }
}</pre> <h2 id="_idParaDest-129" class="calibre7"><a id="_idTextAnchor171" class="pcalibre pcalibre1 calibre6"/>GetKey</h2>
<p class="calibre3">If you want to<a id="_idIndexMarker347" class="pcalibre pcalibre1 calibre6"/> get a keyboard key press that is not assigned <a id="_idIndexMarker348" class="pcalibre pcalibre1 calibre6"/>to an axis, you can use <strong class="source-inline">GetKey()</strong>, <strong class="source-inline">GetKeyDown()</strong>, or <strong class="source-inline">GetKeyUp()</strong> to reference keyboard keys via <span>their </span><span><strong class="source-inline">KeyCode</strong></span><span>.</span></p>
<p class="calibre3">The <strong class="source-inline">GetKey()</strong> functions work pretty similar to the <strong class="source-inline">GetButton()</strong> functions. <strong class="source-inline">GetKey()</strong> returns <strong class="source-inline">true</strong> while the key is being held down; <strong class="source-inline">GetKeyDown()</strong> returns <strong class="source-inline">true</strong> only once, on the frame that the key is initially pressed; and <strong class="source-inline">GetKeyUp()</strong> returns <strong class="source-inline">true</strong> only once, on the frame that the key <span>is released.</span></p>
<p class="calibre3">Each key has its own <strong class="source-inline">KeyCode</strong> that needs to be referenced in the parentheses of the <strong class="source-inline">GetKey()</strong> functions. You can find a list of all the keyboard <strong class="source-inline">KeyCode</strong> values <span>at </span><a href="https://docs.unity3d.com/ScriptReference/KeyCode.xhtml" class="pcalibre pcalibre1 calibre6"><span>https://docs.unity3d.com/ScriptReference/KeyCode.xhtml</span></a><span>.</span></p>
<p class="calibre3">So, for example, if you wanted to check whether the <em class="italic">8</em> key from the alphanumeric keyboard is being pressed, you could write the following code to trigger when the <em class="italic">8</em> key is <span>pressed down:</span></p>
<pre class="source-code">
void Update () {
     if (Input.GetKeyDown(KeyCode.Alpha8)){
          Debug.Log("You pressed the 8 key for some reason!");
     }
}</pre> <h2 id="_idParaDest-130" class="calibre7"><a id="_idTextAnchor172" class="pcalibre pcalibre1 calibre6"/>GetMouseButton</h2>
<p class="calibre3">Just as<a id="_idIndexMarker349" class="pcalibre pcalibre1 calibre6"/> with <strong class="source-inline">GetButton()</strong> and <strong class="source-inline">GetKey()</strong>, there are<a id="_idIndexMarker350" class="pcalibre pcalibre1 calibre6"/> three functions for checking when a mouse button has been pressed: <strong class="source-inline">GetMouseButton()</strong>, <strong class="source-inline">GetMouseButtonDown()</strong>, and <strong class="source-inline">GetMouseButtonUp()</strong>. They return <strong class="source-inline">true</strong> in the same way that the <strong class="source-inline">GetButton()</strong> and <strong class="source-inline">GetKey()</strong> <span>functions do.</span></p>
<p class="calibre3">You’d place these functions within the <strong class="source-inline">Update()</strong> function as well. Within the parentheses, you check to see which button is being pressed; <strong class="source-inline">0</strong> represents a left-click, <strong class="source-inline">1</strong> represents a right-click, and <strong class="source-inline">2</strong> represents <span>a middle-click.</span></p>
<p class="calibre3">So, for example, if <a id="_idIndexMarker351" class="pcalibre pcalibre1 calibre6"/>you wanted to check that the middle mouse button was clicked, you could write the following code to trigger when the middle mouse button is <span>pressed down:</span></p>
<pre class="source-code">
void Update () {
     if (Input.GetMouseButtonDown(2)){
          Debug.Log("You pressed the middle mouse button!");
     }
}</pre> <p class="calibre3">Now that <a id="_idIndexMarker352" class="pcalibre pcalibre1 calibre6"/>we’ve reviewed the input function for buttons and key presses, let’s review the <span>Input Modules.</span></p>
<h1 id="_idParaDest-131" class="calibre5"><a id="_idTextAnchor173" class="pcalibre pcalibre1 calibre6"/>Input Modules</h1>
<p class="calibre3">Input Modules <a id="_idIndexMarker353" class="pcalibre pcalibre1 calibre6"/>describe how the Event System will handle the inputs to the game via the mouse, keyboard, touchscreen, gamepad, and so on. You can think of them as the bridge between the hardware <span>and events.</span></p>
<p class="calibre3">There are three input modules provided <span>by Unity:</span></p>
<ul class="calibre16">
<li class="calibre14">Standalone <span>Input Module</span></li>
<li class="calibre14">Base <span>Input Module</span></li>
<li class="calibre14">Pointer <span>Input Module</span></li>
</ul>
<p class="calibre3">To utilize these input modules, you attach them as components to your <span><strong class="source-inline">EventSystem</strong></span><span> GameObject.</span></p>
<p class="calibre3">You are not restricted to using these three input modules and can create your own, so if you have an input device that is not covered by one of those three, you’d create your own input module script and then attach it to the <span>Event System.</span></p>
<p class="calibre3">There is another input module called Touch Input Module, which used to be necessary for touchscreen inputs. However, this module has been deprecated and its functionality is now lumped<a id="_idIndexMarker354" class="pcalibre pcalibre1 calibre6"/> into the Standalone Input Module. Since this input module has been deprecated, it will not be discussed in <span>this text.</span></p>
<p class="calibre3">Let’s look at the three input module<a id="_idTextAnchor174" class="pcalibre pcalibre1 calibre6"/>s provided by Unity <span>in depth.</span></p>
<h2 id="_idParaDest-132" class="calibre7"><a id="_idTextAnchor175" class="pcalibre pcalibre1 calibre6"/>Standalone Input Module</h2>
<p class="calibre3">The <strong class="bold">Standalone Input Module</strong> is a pretty robust input module that will work with most of <a id="_idIndexMarker355" class="pcalibre pcalibre1 calibre6"/>your<a id="_idIndexMarker356" class="pcalibre pcalibre1 calibre6"/> input devices. It works with a mouse, keyboard, touchscreen, <span>and gamepad.</span></p>
<p class="calibre3">The <strong class="bold">Standalone Input Module</strong> is automatically added to your <strong class="source-inline">EventSystem</strong> GameObject when it is created. However, you can attach the <strong class="bold">Standalone Input Module</strong> as a component using <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Standalone Input Module</strong> on the object’s <strong class="bold">Inspector</strong>. You could do this if you wanted to add a second one, previously deleted it, and want to re-attach it, or want to add the <strong class="bold">Standalone Input Module</strong> to <span>another GameObject.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer188">
<img alt="Figure 8.6: The Standalone Input Module component" src="image/B18327_08_06.jpg" class="calibre187"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.6: The Standalone Input Module component</p>
<p class="calibre3">You’ll see that the first four properties of the <strong class="bold">Standalone Input Module</strong> are <strong class="bold">Horizontal Axis</strong>, <strong class="bold">Vertical Axis</strong>, <strong class="bold">Submit Button</strong>, and <strong class="bold">Cancel Button</strong>. These properties are the reason I wanted to discuss the Input Manager before discussing the Input Modules. The default properties assigned to these slots are <strong class="bold">Horizontal</strong>, <strong class="bold">Vertical</strong>, <strong class="bold">Submit</strong>, and <strong class="bold">Cancel</strong>. These assignments are referencing the axes assignments from the <span>Input Manager.</span></p>
<p class="calibre3">The <strong class="bold">Input Actions Per Second</strong> property defines how many inputs are allowed per second. This is in relation to the keyboard and the gamepad inputs. The default value is <strong class="source-inline">10</strong>. This <a id="_idIndexMarker357" class="pcalibre pcalibre1 calibre6"/>means<a id="_idIndexMarker358" class="pcalibre pcalibre1 calibre6"/> that there will be a tenth of a second delay after an input action before the next input action is registered. The <strong class="bold">Repeat Delay</strong> property is the amount of time, in seconds, before <strong class="bold">Input Actions Per </strong><span><strong class="bold">Second</strong></span><span> occurs.</span></p>
<p class="calibre3">Setting the <strong class="bold">Force Module Active</strong> property to true will make this <strong class="bold">Standalone Input </strong><span><strong class="bold">Module</strong></span><span> active.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">You can learn more about the Standalone Input Module at the <span>following locations:</span></p>
<p class="callout"><a href="mailto:https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/script-StandaloneInputModule.xhtml" class="pcalibre pcalibre1 calibre6"><span>https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/script-StandaloneInputModule.xhtml</span></a></p>
<p class="callout"><a href="https://docs.unity3d.com/2019.1/Documentation/ScriptReference/EventSystems.StandaloneInputModule.xhtml" class="pcalibre pcalibre1 calibre6"><span>https://docs.unity3d.com/2019.1/Documentation/ScriptReference/EventSy<span id="_idTextAnchor176"/>stems.StandaloneInputModule.xhtml</span></a></p>
<h2 id="_idParaDest-133" class="calibre7"><a id="_idTextAnchor177" class="pcalibre pcalibre1 calibre6"/>BaseInputModule/PointerInputModule</h2>
<p class="calibre3">The <strong class="source-inline">BaseInputModule</strong> and <strong class="source-inline">PointerInputModule</strong> are modules that are only accessible <span>via code.</span></p>
<p class="calibre3">If you <a id="_idIndexMarker359" class="pcalibre pcalibre1 calibre6"/>need to<a id="_idIndexMarker360" class="pcalibre pcalibre1 calibre6"/> create your<a id="_idIndexMarker361" class="pcalibre pcalibre1 calibre6"/> own Input Module, you will create it by <a id="_idIndexMarker362" class="pcalibre pcalibre1 calibre6"/>extending from the <strong class="source-inline">BaseInputModule</strong>. You can view a full list of the variables, functions, and messages that can be utilized by extending the <strong class="source-inline">BaseInputModule</strong> <span>at </span><a href="https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.BaseInputModule.xhtml" class="pcalibre pcalibre1 calibre6"><span>https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.BaseInputModule.xhtml</span></a><span>.</span></p>
<p class="calibre3">The <strong class="source-inline">PointerInputModule</strong> is a <strong class="source-inline">BaseInputModule</strong> that is used by the Standalone Input Module described earlier. It can also be used to write custom Input Modules. You can view a full list of the variables, functions, and messages that can be utilized by extending the <strong class="source-inline">PointerInputModule</strong> <span>at </span><a href="https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.PointerInputModule.xhtml" class="pcalibre pcalibre1 calibre6"><span>https://docs.unity3d.com/Packages/com.unity.ugui@1.0/api/UnityEngine.EventSystems.PointerInputModule.xhtml</span></a><span>.</span></p>
<p class="calibre3">Now, let’s look at how we can access multi-touch inpu<a id="_idTextAnchor178" class="pcalibre pcalibre1 calibre6"/>t on mobile and <span>touchscreen devices.</span></p>
<h1 id="_idParaDest-134" class="calibre5"><a id="_idTextAnchor179" class="pcalibre pcalibre1 calibre6"/>Input for multi-touch</h1>
<p class="calibre3">Accessing <a id="_idIndexMarker363" class="pcalibre pcalibre1 calibre6"/>multi-touch is pretty easy. You access touches with <strong class="source-inline">Input.GetTouch(index)</strong>, where the index represents the index of the touch, with the first touch occurring at index <strong class="source-inline">0</strong>. From there, you can access information pretty much in the same way <a id="_idIndexMarker364" class="pcalibre pcalibre1 calibre6"/>as accessing information about a mouse. You can also find out how many total touches are occurring with <strong class="source-inline">Input.touchCount</strong>. See the <em class="italic">Examples</em> section of this chapter for an example of how to access <span>multi-touch input.</span></p>
<p class="calibre3">Mobile devices also have accelerometers and gyroscopes providing input to the device. Let’s look at how you can access <span>those inputs.</span></p>
<h1 id="_idParaDest-135" class="calibre5"><a id="_idTextAnchor180" class="pcalibre pcalibre1 calibre6"/>Input for accelerometer and gyroscope</h1>
<p class="calibre3">You can access <a id="_idIndexMarker365" class="pcalibre pcalibre1 calibre6"/>data from the device’s accelerometer using the <strong class="source-inline">Vector3 Input.acceleration</strong> property. The coordinates of <strong class="source-inline">Input.acceleration</strong> line up with the scene based on the rotation of the device, <span>as shown:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer189">
<img alt="Figure 8.7: The world axes based on screen rotation" src="image/B18327_08_07.jpg" class="calibre188"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.7: The world axes based on screen rotation</p>
<p class="calibre3">Simple examples <a id="_idIndexMarker366" class="pcalibre pcalibre1 calibre6"/>of this involve moving an object around a scene when the device is moved, using something like the following within an <strong class="source-inline">Update()</strong> function on <span>the object:</span></p>
<pre class="source-code">
transform.Translate(Input.acceleration.x, 0, -Input.acceleration.y);</pre> <p class="calibre3">The gyroscope uses more complicated mathematics to get a more precise movement of the screen using the <strong class="source-inline">Gyroscope</strong> class. Remember, the gyroscope is not supported on many devices, so it’s best to use the accelerometer <span>when possible.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">An example of how to use the gyroscope on an iOS device can be found <span>here: </span><a href="https://docs.unity3d.com/ScriptReference/Gyroscope.xhtml" class="pcalibre pcalibre1 calibre6"><span>https://docs.unity3d.com/ScriptReference/Gyroscope.xhtml</span></a><span>.</span></p>
<p class="calibre3">Now that we’ve reviewed the various input modules, let’s review <span>Event Triggers.</span></p>
<h1 id="_idParaDest-136" class="calibre5"><a id="_idTextAnchor181" class="pcalibre pcalibre1 calibre6"/>Event Trigger</h1>
<p class="calibre3">The <strong class="bold">Event Trigger</strong> component can <a id="_idIndexMarker367" class="pcalibre pcalibre1 calibre6"/>be attached to any UI (or non-UI) element to allow the object to receive events. Some of the UI elements are preconfigured to intercept specific events. For example, buttons have the <strong class="source-inline">onClick</strong> event. However, if you’d like to add an event to an object that either isn’t already set up to receive events or you want it to receive different events, you can attach an <strong class="bold">Event Trigger</strong> component to <span>the GameObject.</span></p>
<p class="calibre3">You can attach an <strong class="bold">Event Trigger</strong> component by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <span><strong class="bold">Event Trigger</strong></span><span>.</span></p>
<p class="calibre3">One caveat of using the <strong class="bold">Event Trigger</strong> component is that the object it is attached to receives all the events, not just the ones you added. So, even if you don’t tell the object what to do with the specified event, it will receive that event and acknowledge that the event occurred—it just won’t do anything in response. This can slow the performance of your game. If you are worried about performance, you will want to write your own script that attaches only the events you want to use to your component. The next section, <em class="italic">Event Inputs</em>, discusses how to <span>achieve this.</span></p>
<p class="calibre3">If you use an <strong class="bold">Event Trigger</strong> component on an object other than a UI element, the object must also have a collider component, and you must include a raycaster on the camera within <span>the scene.</span></p>
<p class="calibre3">Which collider and raycaster you use depends on whether you are working in 2D <span>or 3D.</span></p>
<p class="calibre3">If you are working in 2D, you can add a 2D collider to the object with <strong class="bold">Add Component</strong> | <strong class="bold">Physics 2D</strong> and then select the appropriate 2D collider from within the object’s <strong class="bold">Inspector</strong>. You can then add a raycaster to the camera by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Physics 2D Raycaster</strong> from within the <span>camera’s </span><span><strong class="bold">Inspector</strong></span><span>.</span></p>
<p class="calibre3">If you are working in 3D, you can add a 3D collider to the object with <strong class="bold">Add Component</strong> | <strong class="bold">Physics</strong> and then select the appropriate 3D collider from within the object’s <strong class="bold">Inspector</strong>. You can then add a raycaster to the camera by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Physics Raycaster</strong> from within the <span>camera’s </span><span><strong class="bold">Inspector</strong></span><span>.</span></p>
<p class="calibre3">Let’s look at the various event t<a id="_idTextAnchor182" class="pcalibre pcalibre1 calibre6"/>ypes that the Event Trigger <span>can receive.</span></p>
<h2 id="_idParaDest-137" class="calibre7"><a id="_idTextAnchor183" class="pcalibre pcalibre1 calibre6"/>Event types</h2>
<p class="calibre3">You can tell the <a id="_idIndexMarker368" class="pcalibre pcalibre1 calibre6"/>object which type of input event you want to receive by selecting <strong class="bold">Add New </strong><span><strong class="bold">Event Type</strong></span><span>.</span></p>
<p class="calibre3">Many of<a id="_idIndexMarker369" class="pcalibre pcalibre1 calibre6"/> these events are tied to the bounding region of the object. The bounding region of a UI object is represented by the area of the Rect Transform. For a non-UI object, the bounding reg<a id="_idTextAnchor184" class="pcalibre pcalibre1 calibre6"/>ion is represented by a 2D or <span>3D collider.</span></p>
<h3 class="calibre9">Pointer events</h3>
<p class="calibre3">Pointer events<a id="_idIndexMarker370" class="pcalibre pcalibre1 calibre6"/> can be called by the pointer in a <strong class="bold">Standalone Input Module</strong>. Remember that a pointer is not exclusively a mouse. The pointer in a <strong class="bold">Standalone Input Module</strong> can be a mouse, finger touch, or a reticle tied to <span>gamepad movement.</span></p>
<p class="calibre3">Two of the event types are related to the position of the pointer in relation to the object’s bounding box region. The <strong class="bold">PointerEnter</strong> event is called when the pointer enters the bounding box of the object and <strong class="bold">PointerExit</strong> is called when the pointer exits the bound <span>box area.</span></p>
<p class="calibre3">There are three events related to clicking on the object. The <strong class="bold">PointerDown</strong> event is called when the pointer is pressed down within the bounding region of the object, and <strong class="bold">PointerUp</strong> is called when the pointer is released within the bounding region of the object. It’s important to note that with <strong class="bold">PointerUp</strong>, the pointer can be pressed outside of the object, held down, and then released inside the object for the <strong class="bold">PointerUp</strong> event to trigger. The <strong class="bold">PointerClick</strong> event is called when the pointer is pressed and then release<a id="_idTextAnchor185" class="pcalibre pcalibre1 calibre6"/>d within the bounding region of <span>the object.</span></p>
<h3 class="calibre9">Drag and Drop events</h3>
<p class="calibre3">When working <a id="_idIndexMarker371" class="pcalibre pcalibre1 calibre6"/>with the various drag and drop events, it’s important to differentiate between the object being dragged and the object on which the dragged object <span>is dropped.</span></p>
<p class="calibre3">The <strong class="bold">InitializePotentialDrag</strong> event is called whenever a drag object is found, but before an object is actually <span>being dragged.</span></p>
<p class="calibre3">The <strong class="bold">Drag</strong> event is called on the object being dragged when it is being dragged. A <strong class="bold">Drag</strong> event occurs when a pointer is pressed within the bounding box of an object and then moved without releasing. It’s ended by releasing the pointer. The <strong class="bold">BeginDrag</strong> event is called from the object being dragged when its drag begins, and the <strong class="bold">EndDrag</strong> event is called when its <span>drag ends.</span></p>
<p class="calibre3">The <strong class="bold">Drop</strong> event<a id="_idIndexMarker372" class="pcalibre pcalibre1 calibre6"/> is different from the <strong class="bold">EndDrag</strong> event. The <strong class="bold">EndDrag</strong> event is called on the object that was just being dragged. The <strong class="bold">Drop</strong> event is called by the object on which the dragged object was dropped. Therefore, the <strong class="bold">Drop</strong> event is called by the object touching the dragged object when the dragged object stops dragging. So, if you were making a drag and drop menu, you’d add the <strong class="bold">Drag</strong> event to the objects you want to drag and the <strong class="bold">Drop</strong> <a id="_idTextAnchor186" class="pcalibre pcalibre1 calibre6"/>event to the slots they will be <span>dropped into.</span></p>
<h3 class="calibre9">Selection events</h3>
<p class="calibre3">The <strong class="bold">Select</strong> event is <a id="_idIndexMarker373" class="pcalibre pcalibre1 calibre6"/>called when the object is considered the selected object and <strong class="bold">Deselect</strong> is called when the object is no longer considered selected. Each of these events only fires once—the moment the object is considered selected or deselected. If you want an event that will trigger continuously while the object is selected, you can use the <strong class="bold">UpdateSelected</strong> event. T<a id="_idTextAnchor187" class="pcalibre pcalibre1 calibre6"/>he <strong class="bold">UpdateSelected</strong> event is called <span>every frame.</span></p>
<h3 class="calibre9">Other events</h3>
<p class="calibre3">Other events <a id="_idIndexMarker374" class="pcalibre pcalibre1 calibre6"/>are called based on assignments in the Input Manager. Remember that you can assign buttons, keys, and such to axes that define movement, submit, and cancel. Let’s talk about a few of <span>these events.</span></p>
<p class="calibre3">The <strong class="bold">Scroll</strong> event is called when the mouse wheel scrolls and the <strong class="bold">Move</strong> event is called when a movement happens. When the button assigned to the <strong class="bold">Submit</strong> axis is pressed, the <strong class="bold">Submit</strong> event is called and when the button assigned to the <strong class="bold">Canc<a id="_idTextAnchor188" class="pcalibre pcalibre1 calibre6"/>el</strong> axis is pressed, the <strong class="bold">Cancel</strong> event <span>is called.</span></p>
<h2 id="_idParaDest-138" class="calibre7"><a id="_idTextAnchor189" class="pcalibre pcalibre1 calibre6"/>Adding an action to the event</h2>
<p class="calibre3">Once you have actually<a id="_idIndexMarker375" class="pcalibre pcalibre1 calibre6"/> selected an event type, you must specify what will happen when that event type triggers. The following screenshot shows the results of selecting <strong class="bold">Pointer Enter</strong> as an <span>event type:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer190">
<img alt="Figure 8.8: The Event Trigger component" src="image/B18327_08_08.jpg" class="calibre189"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.8: The Event Trigger component</p>
<p class="calibre3">The<a id="_idIndexMarker376" class="pcalibre pcalibre1 calibre6"/> preceding screenshot shows that an event type of <strong class="bold">Pointer Enter</strong> has been selected, but what happens when the pointer enters the object’s bounding area is yet to be defined. To define what happens when the event triggers, you must select the <strong class="bold">+</strong> sign at the bottom-right corner of the event’s box. You can add multiple actions when the event triggers by selecting the <strong class="bold">+</strong> sign <span>multiple times.</span></p>
<p class="calibre3">Once an event type has been added to the <strong class="bold">Event Trigger</strong> component, it cannot be added a second time and will be grayed out in the <strong class="bold">Add New Event </strong><span><strong class="bold">Type</strong></span><span> list.</span></p>
<p class="calibre3">To remove an event type from the <strong class="bold">Event Trigger</strong> component, select the <strong class="bold">–</strong> sign at the top-right corner of the event <span>type’s box.</span></p>
<p class="calibre3">Once the plus sign is selected, the event type should look <span>as follows:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer191">
<img alt="Figure 8.9: The Event Trigger component with a Pointer Enter event" src="image/B18327_08_09.jpg" class="calibre190"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.9: The Event Trigger component with a Pointer Enter event</p>
<p class="calibre3">The first setting on this event is a dropdown menu with the <strong class="bold">Runtime Only</strong> (by default), <strong class="bold">Editor and Runtime</strong>, and <strong class="bold">Off</strong> options. This is where we specify when the event can be triggered. Setting this to <strong class="bold">Off</strong> will make the event never trigger. Setting this to <strong class="bold">Runtime Only</strong> will have the event trigger when the game is being played. Setting this to <strong class="bold">Editor and Runtime</strong> will make events trigger when the game is being played, but it also accepts the triggers in the Editor when the game is not in play mode. Most of the time, <strong class="bold">Runtime Only</strong> is sufficient for what you will be doing and hence it is <span>the default.</span></p>
<p class="calibre3">Below that <a id="_idIndexMarker377" class="pcalibre pcalibre1 calibre6"/>dropdown menu is a slot with <strong class="bold">None (Object)</strong> in it. You are to drag from the Hierarchy whichever item the function you want to run is attached to into this slot. Once that is assigned, a list of all the available components and scripts attached to that object will display in the second dropdown menu. You can drag and drop the object the <strong class="bold">Event Trigger</strong> is attached to in this slot and are not restricted to only using <span>other objects.</span></p>
<p class="calibre3">The following screenshot shows an <strong class="source-inline">Image</strong> GameObject with an <strong class="bold">Event Trigger</strong> added to it and the <strong class="bold">Pointer Enter</strong> event type. The same image is added to the slot, signifying to look at the components on itself. The image component’s sprite property is to change to the <strong class="source-inline">foodSpriteSheet_1</strong> sprite when the pointer enters its <span><strong class="bold">Rect Transform</strong></span><span>.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer192">
<img alt="Figure 8.10: The Event Trigger component with a Pointer Enter event that swaps a sprite" src="image/B18327_08_10.jpg" class="calibre191"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.10: The Event Trigger component with a Pointer Enter event that swaps a sprite</p>
<p class="calibre3">To see this <strong class="bold">Event Trigger</strong> in action, play the <strong class="source-inline">Chapter8</strong> scene. Hover your mouse over the image. It will initially look like a potion bottle but will change to a triangle when your mouse hovers <span>over it.</span></p>
<p class="calibre3">You can also run functions within scripts attached to objects. For example, the next screenshot shows the same image but now with a <strong class="bold">Pointer Click</strong> event as well. <strong class="source-inline">Main Camera</strong> has a script attached to it called <strong class="source-inline">HelloWorld.cs</strong> with a function <span>called </span><span><strong class="source-inline">HeyThere()</strong></span><span>.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer193">
<img alt="Figure 8.11: The Event Trigger component with Pointer Click event that triggers a method" src="image/B18327_08_11.jpg" class="calibre192"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.11: The Event Trigger component with Pointer Click event that triggers a method</p>
<p class="calibre3">The <strong class="source-inline">HeyThere()</strong> function<a id="_idIndexMarker378" class="pcalibre pcalibre1 calibre6"/> simply prints <strong class="source-inline">Hello world! This is main camera speaking!</strong> in the <strong class="bold">Console</strong> whenever the image to the right <span>is clicked.</span></p>
<p class="calibre3">To run a function from the <strong class="bold">Event Trigger</strong> component, it must be public, have a return type of void, and have no more than <span>one parameter.</span></p>
<p class="calibre3">Now, let’s review how we can write code that performs similarly to the Event Tri<a id="_idTextAnchor190" class="pcalibre pcalibre1 calibre6"/>gger component through the use of <span>event inputs.</span></p>
<h1 id="_idParaDest-139" class="calibre5"><a id="_idTextAnchor191" class="pcalibre pcalibre1 calibre6"/>Event inputs</h1>
<p class="calibre3">As stated in the <em class="italic">Event Trigger</em> section, you may not want to use an <strong class="bold">Event Trigger</strong> component because the <strong class="bold">Event Trigger</strong> component causes the object on which it is attached<a id="_idIndexMarker379" class="pcalibre pcalibre1 calibre6"/> to receive all the events listed in the <em class="italic">Event Trigger</em> section. So, if you are worried about performance issues, you will want an alternate way to receive events on <span>an object.</span></p>
<p class="calibre3">All event types that were available to add in the <em class="italic">Event Trigger</em> section can also be added to an object via code without using the <strong class="bold">Event Trigger</strong> component. To use an event without the <strong class="bold">Event Trigger</strong> component, you must derive your script from the appropriate interface and know the type of event data class that the <span>event uses.</span></p>
<p class="calibre3">An <strong class="bold">interface</strong> is a<a id="_idIndexMarker380" class="pcalibre pcalibre1 calibre6"/> template that defines all the required functionality that a class can implement. So, by using an interface, you can then use any of the methods or functions that have been defined within that interface. I’ll show you some examples of how to do this, but first, let’s look at the available events and their <span>required interfaces.</span></p>
<p class="calibre3">There are three classes that the event data can be derived from, which are <strong class="source-inline">PointerEventData</strong>, <strong class="source-inline">AxisEventData</strong>, <span>and </span><span><strong class="source-inline">BaseEventData</strong></span><span>:</span></p>
<ul class="calibre16">
<li class="calibre14"><strong class="source-inline">PointerEventData</strong> is the class that contains events associated with <span>the pointer</span></li>
<li class="calibre14"> <strong class="source-inline">AxisEventData</strong> contains events associated with the keyboard <span>and gamepad</span></li>
<li class="calibre14"><strong class="source-inline">BaseEventData</strong> contains events that are used by all <span>event types</span></li>
</ul>
<p class="calibre3">There is a<a id="_idIndexMarker381" class="pcalibre pcalibre1 calibre6"/> fourth event data class, <strong class="source-inline">AbstractEventData</strong>. It is the class from which the other <span>three inherit.</span></p>
<p class="calibre3">The list of events available for a <strong class="source-inline">StandaloneInputModule</strong> along with their required interfaces and event data class are provided in the following chart. The events are listed in the same order they are listed within the Event Trigger component for <span>continuity purposes:</span></p>
<table class="no-table-style" id="table001-2">
<colgroup class="calibre10">
<col class="calibre11"/>
<col class="calibre11"/>
<col class="calibre11"/>
</colgroup>
<thead class="calibre193">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold">Event</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold">Interface</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Event </strong><span><strong class="bold">Data Type</strong></span></p>
</td>
</tr>
</thead>
<tbody class="calibre12">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnPointerEnter</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IPointerEnterHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">PointerEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnPointerExit</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IPointerExitHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">PointerEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnPointerDown</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IPointerDownHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">PointerEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnPointerUp</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IPointerUpHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">PointerEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnPointerClick</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IPointerClickHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">PointerEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnDrag</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IdragHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">PointerEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnDrop</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IdropHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">PointerEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnScroll</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IscrollHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">PointerEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnUpdateSelected</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IUpdateSelectedHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">BaseEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnSelect</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IselectHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">BaseEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnDeselect</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IdeselectHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">BaseEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnMove</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IMoveHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">AxisEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnInitializePotentialDrag</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IInitializePotentialDragHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">PointerEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnBeginDrag</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IbeginDragHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">PointerEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnEndDrag</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">IEndDragHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">PointerEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnSubmit</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">ISubmitHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">BaseEventData</strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">OnCancel</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">ICancelHandler</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="source-inline">BaseEventData</strong></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 8.1: Interfaces and event data types for the various events</p>
<p class="calibre3">To write a<a id="_idIndexMarker382" class="pcalibre pcalibre1 calibre6"/> class with one of these events, you will use the <span>following template:</span></p>
<pre class="source-code">
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
public class ClassName : MonoBehaviour, <strong class="bold">InterfaceName</strong>{
     public void <strong class="bold">EventName</strong>(<strong class="bold">EventDataTypeName</strong> eventData){
          //what happens after event triggers
     }
}</pre> <p class="calibre3">The items highlighted in the preceding code will be replaced by the items within the <span>preceding table.</span></p>
<p class="calibre3">For example, if you wanted to implement an <strong class="source-inline">OnPointerEnter</strong> event, the code would look as follows after the highlighted code has been replaced with an appropriate event, interface, and event <span>data type:</span></p>
<pre class="source-code">
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
public class ClassName : MonoBehaviour, <strong class="bold">IPointerEnterHandler</strong>
     public void <strong class="bold">OnePointerEnter</strong>(<strong class="bold">PointerEventData</strong> eventData){
         //what happens after the event triggers
     }
}</pre> <p class="calibre3">You must<a id="_idIndexMarker383" class="pcalibre pcalibre1 calibre6"/> include the <strong class="source-inline">UnityEngine.EventSystems</strong> namespace to write code with event data. The <strong class="source-inline">UnityEngine.UI</strong> namespace is optional and is only required if you will also be writing your events for <span>UI objects.</span></p>
<p class="calibre3">Now that we’ve reviewed various ways to send and receive events, let’s look <span>at raycasters<a id="_idTextAnchor192" class="pcalibre pcalibre1 calibre6"/>.</span></p>
<h1 id="_idParaDest-140" class="calibre5"><a id="_idTextAnchor193" class="pcalibre pcalibre1 calibre6"/>Raycasters</h1>
<p class="calibre3">Remember that <a id="_idIndexMarker384" class="pcalibre pcalibre1 calibre6"/>the Event System keeps track of raycasting along with all the other<a id="_idIndexMarker385" class="pcalibre pcalibre1 calibre6"/> things we have discussed. Raycasting is used to determine which UI elements are being interacted with by projecting a ray from the user’s pointer into the scene. This ray is considered to originate at the camera’s plane and then proceed forward through the scene. Whatever this ray hits receives an interaction. You can have the ray continue through the first UI element it hits or stop at the first UI element it hits. To get a ray to stop at the first UI element it hits, the object must block raycasting. This will stop items behind it from being interacted with. Next, we’ll discuss the types <span>of raycaster<a id="_idTextAnchor194" class="pcalibre pcalibre1 calibre6"/>s.</span></p>
<h2 id="_idParaDest-141" class="calibre7"><a id="_idTextAnchor195" class="pcalibre pcalibre1 calibre6"/>Graphic Raycaster</h2>
<p class="calibre3">When a<a id="_idIndexMarker386" class="pcalibre pcalibre1 calibre6"/> Canvas is added to the scene, it is automatically <a id="_idIndexMarker387" class="pcalibre pcalibre1 calibre6"/>given a <strong class="bold">Graphic </strong><span><strong class="bold">Raycaster</strong></span><span> component.</span></p>
<p class="calibre3">This is the raycasting system that will allow you to interact with all UI objects that are children of that Canvas. It has three properties: <strong class="bold">Ignore Reversed Graphics</strong>, <strong class="bold">Blocking Objects</strong>, and <span><strong class="bold">Blocking Mask</strong></span><span>.</span></p>
<p class="calibre3">The <strong class="bold">Ignore Reversed Graphics</strong> toggle determines whether or not graphical objects within the Canvas can be interacted with if they are facing backward (in relation to the raycaster). The <strong class="bold">Blocking Objects</strong> and <strong class="bold">Blocking Mask</strong> properties allow you to assign the types <a id="_idIndexMarker388" class="pcalibre pcalibre1 calibre6"/>of <a id="_idIndexMarker389" class="pcalibre pcalibre1 calibre6"/>objects that are in front of the Canvas (between the camera and the Canvas) that can block raycasting to <span>the <a id="_idTextAnchor196" class="pcalibre pcalibre1 calibre6"/>Canvas.</span></p>
<h2 id="_idParaDest-142" class="calibre7"><a id="_idTextAnchor197" class="pcalibre pcalibre1 calibre6"/>Other Raycasters</h2>
<p class="calibre3">As stated earlier, if <a id="_idIndexMarker390" class="pcalibre pcalibre1 calibre6"/>you want to use the Event System with a <a id="_idIndexMarker391" class="pcalibre pcalibre1 calibre6"/>non-UI object, you must attach a Raycaster component to a camera within the scene. You can add either a <strong class="bold">Physics 2D Raycaster</strong> or a <strong class="bold">Physics Raycaster</strong> (or both) to your camera based on whether you are using 2D <span>or 3D.</span></p>
<p class="calibre3">From within the camera’s inspector, you can add the <strong class="bold">Physics 2D Raycaster</strong> by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Physics 2D Raycaster</strong> and the <strong class="bold">Physics Raycaster</strong> by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <span><strong class="bold">Physics Raycaster</strong></span><span>.</span></p>
<p class="calibre3">The two components appear <span>as follows:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer194">
<img alt="Figure 8.12: The two types of Physics Raycasters" src="image/B18327_08_12.jpg" class="calibre194"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.12: The two types of Physics Raycasters</p>
<p class="calibre3">The <strong class="bold">Event Mask</strong> property determines which types of objects can <span>receive raycasting.</span></p>
<p class="calibre3">If you attempt to add either of these components to a non-camera GameObject, a <strong class="bold">Camera</strong> component will automatically be attached to the GameObject <span>as well.</span></p>
<p class="calibre3">Now that we’ve reviewed the various systems that we can use to program interactions for our UI, let’s look at <span>some e<a id="_idTextAnchor198" class="pcalibre pcalibre1 calibre6"/>xamples.</span></p>
<h1 id="_idParaDest-143" class="calibre5"><a id="_idTextAnchor199" class="pcalibre pcalibre1 calibre6"/>Examples</h1>
<p class="calibre3">We will continue to work on the UI we have been building for the last two chapters. To help organize the project, duplicate the <strong class="source-inline">Chapter7</strong> scene that you created in the last chapter; it will automatically be <span>named </span><span><strong class="source-inline">Chapter8</strong></span><span>.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">If you did not work through the examples for <a href="B18327_06.xhtml#_idTextAnchor085" class="pcalibre pcalibre1 calibre6"><span><em class="italic">Chapter 6</em></span></a>, and <a href="B18327_07.xhtml#_idTextAnchor106" class="pcalibre pcalibre1 calibre6"><span><em class="italic">Chapter 7</em></span></a>, but would like to work through the examples in this chapter, you can import the package labeled <span><strong class="source-inline1">Chapter 08</strong></span><strong class="source-inline1"> – Examples 1 - Start</strong>. You can also view the completed examples in the <span><strong class="source-inline1">Chapter 08</strong></span><strong class="source-inline1"> – Examples 1 – </strong><span><strong class="source-inline1">End</strong></span><span> <a id="_idTextAnchor200" class="pcalibre pcalibre1 calibre6"/>package.</span></p>
<h2 id="_idParaDest-144" class="calibre7"><a id="_idTextAnchor201" class="pcalibre pcalibre1 calibre6"/>Showing and hiding pop-up menus with keypress</h2>
<p class="calibre3">So far, we have made<a id="_idIndexMarker392" class="pcalibre pcalibre1 calibre6"/> two Panels that we plan on turning into popups: the <strong class="source-inline">Pause Panel</strong> from <a href="B18327_06.xhtml#_idTextAnchor085" class="pcalibre pcalibre1 calibre6"><span><em class="italic">Chapter 6</em></span></a>, and the <strong class="source-inline">Inventory Panel</strong> from <a href="B18327_07.xhtml#_idTextAnchor106" class="pcalibre pcalibre1 calibre6"><span><em class="italic">Chapter 7</em></span></a>. Right now, they are both visible in the scene (even though <strong class="source-inline">Pause Panel</strong> is hidden behind the <strong class="source-inline">Inventory Panel</strong>). We want them to pop up when we press <em class="italic">P</em> and <em class="italic">I</em> on the<a id="_idIndexMarker393" class="pcalibre pcalibre1 calibre6"/> keyboard. For demonstration purposes, we’ll access the keyboard keys differently for <span>each Panel.</span></p>
<p class="calibre3">Remember that both of these Panels have Canvas Group components on them. These components will allow us to easily access the Panels’ alpha, intractable, and blocks <span>raycasts p<a id="_idTextAnchor202" class="pcalibre pcalibre1 calibre6"/>roperties.</span></p>
<h3 class="calibre9">Using KeyCode with the Inventory Panel</h3>
<p class="calibre3">Let’s<a id="_idIndexMarker394" class="pcalibre pcalibre1 calibre6"/> begin with the <strong class="source-inline">Inventory Panel</strong>. We want <a id="_idIndexMarker395" class="pcalibre pcalibre1 calibre6"/>the Panel to pop up and close when the <em class="italic">I</em> key is pressed on the keyboard. To make the <strong class="source-inline">Inventory Panel</strong> appear and disappear with the <em class="italic">I</em> key, complete the <span>following steps:</span></p>
<ol class="calibre13">
<li class="calibre14">Create a new C# script in the <strong class="source-inline">Assets/Scripts</strong> folder by right-clicking within the <strong class="bold">Project</strong> view of the folder and selecting <strong class="bold">Create</strong> | <strong class="bold">C# Script</strong> from the <span>pop-up Panel.</span></li>
<li class="calibre14">Name the script <strong class="source-inline">ShowHidePanels.cs</strong>, and then double-click on it <span>to open.</span></li>
<li class="calibre14">Now, let’s use a <strong class="source-inline">public CanvasGroup</strong> variable called <strong class="source-inline">inventoryPanel</strong> to represent <a id="_idIndexMarker396" class="pcalibre pcalibre1 calibre6"/>the Panel. We use a <strong class="source-inline">CanvasGroup</strong> variable type to reference the Panel since<a id="_idIndexMarker397" class="pcalibre pcalibre1 calibre6"/> we want to access the properties of the <strong class="bold">Canvas Group</strong> component. Update your <strong class="source-inline">ShowHidePanels</strong> script to include the following highlighted line <span>of code:</span><pre class="source-code">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class ShowHidePanels : MonoBehaviour {
    <strong class="bold">public CanvasGroup inventoryPanel;</strong>
}</pre><p class="calibre3">The <strong class="source-inline">CanvasGroup</strong> variable type, even though it is used with UI elements, is not in the <strong class="source-inline">UnityEngine.UI</strong> namespace, but the <strong class="source-inline">UnityEngine</strong> namespace, so we do not need to include the <strong class="source-inline">UnityEngine.UI</strong> namespace in our script at <span>the moment.</span></p></li> <li class="calibre14">Let’s create another variable that will keep track of whether or not the <strong class="source-inline">Inventory Panel</strong> is visible. Add the following code to the next line of the script to initialize <span>the variable:</span><pre class="source-code">
bool inventoryUp = false;</pre></li> <li class="calibre14">We will be toggling the Panels on and off by adjusting their <strong class="source-inline">alpha</strong>, <strong class="source-inline">interactable</strong>, and <strong class="source-inline">blocksRaycasts</strong> properties. When the Panel is hidden, it should also not accept interactions or block raycasts. So, let’s create a method that we can call to perform the toggle. Add the following namespace to <span>your script:</span><pre class="source-code">
using System;</pre><p class="calibre3">Add the following method to <span>your script:</span></p><pre class="source-code">public void TogglePanel(CanvasGroup Panel, bool show)
{
    Panel.alpha = Convert.ToInt32(show);
    Panel.interactable = show;
    Panel.blocksRaycasts = show;
}</pre><p class="calibre3">As you can see, the<a id="_idIndexMarker398" class="pcalibre pcalibre1 calibre6"/> method has two parameters. The first parameter is a <strong class="source-inline">CanvasGroup</strong> called <strong class="source-inline">Panel</strong> and the second parameter is a Boolean called <strong class="source-inline">show</strong>. It will set the <strong class="source-inline">alpha</strong> property to <strong class="source-inline">0</strong> when <strong class="source-inline">show</strong> is <strong class="source-inline">false</strong> and <strong class="source-inline">1</strong> when <strong class="source-inline">show</strong> is <strong class="source-inline">true</strong>. It will also set the <strong class="source-inline">interactable</strong> and <strong class="source-inline">blocksRaycasts</strong> properties to <strong class="source-inline">false</strong> when <strong class="source-inline">show</strong> is <strong class="source-inline">false</strong> and <strong class="source-inline">true</strong> when <strong class="source-inline">show</strong> <span>is </span><span><strong class="source-inline">true</strong></span><span>.</span></p></li> <li class="calibre14">We<a id="_idIndexMarker399" class="pcalibre pcalibre1 calibre6"/> want <strong class="source-inline">Inventory Panel</strong> to be hidden when the scene starts playing. So, update the <strong class="source-inline">Start()</strong> function to include the <span>following code:</span><pre class="source-code">
void Start () {
    TogglePanel(inventoryPanel, inventoryUp);
}</pre></li> <li class="calibre14">Now, we need to write code that triggers whenever the <em class="italic">I</em> key on the keyboard is pressed down. We will use the <strong class="source-inline">Input.GetKeyDown()</strong> function in a way that the function is called the moment the key is pressed down. We will also use <strong class="source-inline">KeyCode.I</strong> to reference the <em class="italic">I</em> key on the keyboard. Add the following code to your <strong class="source-inline">Update</strong> function to check whether the <em class="italic">I</em> key is <span>pressed down:</span><pre class="source-code">
void Update () {
    //inventory Panel
    if(Input.GetKeyDown(KeyCode.I)){
    }
}</pre></li> <li class="calibre14">We want this <a id="_idIndexMarker400" class="pcalibre pcalibre1 calibre6"/>key to disable and enable the Panel, so we will change the value of <strong class="source-inline">inventoryUp</strong> to whatever the opposite <a id="_idIndexMarker401" class="pcalibre pcalibre1 calibre6"/>of its current value is. That is, if it is <strong class="source-inline">true</strong>, we will set it to <strong class="source-inline">false</strong>, if it is <strong class="source-inline">false</strong>, we will set it to <strong class="source-inline">true</strong>. Then, we will call the <span><strong class="source-inline">TogglePanel()</strong></span><span> method.</span><p class="calibre3">Add the following highlighted code to your <span><strong class="source-inline">Update()</strong></span><span> function:</span></p><pre class="source-code">
void Update()
{
    // Inventory Panel
    if (Input.GetKeyDown(KeyCode.I))
    {
        inventoryUp = !inventoryUp;
        TogglePanel(inventoryPanel, inventoryUp);
    }
}</pre></li> <li class="calibre14">Now, for this code to work, we need to attach it to a GameObject within our scene. It really doesn’t matter what GameObject we attach it to, since we used a public variable to access our <strong class="source-inline">Inventory Panel</strong>, we can assign that via the Inspector. However, since we are planning on using this script to affect both Panels, I want to add it to <strong class="source-inline">Main Camera</strong>. Drag and drop the <strong class="source-inline">ShowHidePanels</strong> script into the <strong class="bold">Inspector</strong> of <strong class="source-inline">Main Camera</strong>. You should now see the following as a component on your <span><strong class="source-inline">Main Camera</strong></span><span>:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer195">
<img alt="Figure 8.13: The ShowHidePanel.cs script component" src="image/B18327_08_13.jpg" class="calibre195"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.13: The ShowHidePanel.cs script component</p>
<ol class="calibre13">
<li value="10" class="calibre14">Now, we need to assign the <strong class="source-inline">Inventory Panel</strong> GameObject to the slot labeled <strong class="bold">Inventory Panel</strong>. Drag and drop the <strong class="bold">Inventory Panel</strong> from the Hierarchy into <span>this slot:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer196">
<img alt="Figure 8.14: Adding the Inventory Panel ShowHidePanel.cs script component" src="image/B18327_08_14.jpg" class="calibre196"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.14: Adding the Inventory Panel ShowHidePanel.cs script component</p>
<ol class="calibre13">
<li value="11" class="calibre14">Play the<a id="_idIndexMarker402" class="pcalibre pcalibre1 calibre6"/> game to ensure that the code is working<a id="_idIndexMarker403" class="pcalibre pcalibre1 calibre6"/> correctly. You should see the inventory Panel start out invisible and then turn on and off as you press the <em class="italic">I</em> key on <span>the keyboard.</span></li>
</ol>
<p class="calibre3">Now that we’ve completed the work needed to show and hide the <strong class="source-inline">Inventory Panel</strong>, we can move on to<a id="_idTextAnchor203" class="pcalibre pcalibre1 calibre6"/> the <span><strong class="source-inline">Pause Panel</strong></span><span>.</span></p>
<h3 class="calibre9">Using Input Manager with the Pause Panel</h3>
<p class="calibre3">Now, let’s do<a id="_idIndexMarker404" class="pcalibre pcalibre1 calibre6"/> the same thing for the <strong class="source-inline">Pause Panel</strong>. We’ll do this slightly differently than the <strong class="source-inline">Inventory Panel</strong>. To make <a id="_idIndexMarker405" class="pcalibre pcalibre1 calibre6"/>sure that you can see how to access a key with the Input Manager, we’ll use the Input Manager instead of a <strong class="source-inline">KeyCode</strong>. We also need to actually pause <span>the game.</span></p>
<p class="calibre3">To display the <strong class="source-inline">Pause Panel</strong> using the <em class="italic">P</em> key and pause the game, complete the <span>following steps:</span></p>
<ol class="calibre13">
<li class="calibre14">First, we need to set up the Input Manager to include a <strong class="source-inline">Pause</strong> axis. Open the Input Manager with <strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> | <strong class="bold">Input Manager</strong> and expand the axes by selecting the arrow next to the <span>word </span><span><strong class="bold">Axes</strong></span><span>.</span></li>
<li class="calibre14">By default, your project has 30 axes. You can replace one of these with the new <strong class="source-inline">Pause</strong> axis if you aren’t planning on using them, but we might as well just go ahead and make a new one. Definitely don’t delete the <strong class="bold">Submit</strong> and <strong class="bold">Cancel</strong> axes, as we have<a id="_idIndexMarker406" class="pcalibre pcalibre1 calibre6"/> them being referenced in our <strong class="bold">Standalone Input Manager</strong>. To add a new axis, change the size to <strong class="source-inline">31</strong>. This will duplicate the last axis in the list, <strong class="bold">Debug Horizontal</strong>, as shown in the <span>following screenshot:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer197">
<img alt="Figure 8.15: The Input Manager with an extra axis" src="image/B18327_08_15.jpg" class="calibre197"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.15: The Input Manager with an extra axis</p>
<ol class="calibre13">
<li value="3" class="calibre14">Change the<a id="_idIndexMarker407" class="pcalibre pcalibre1 calibre6"/> second <strong class="source-inline">Debug Horizontal</strong> axis to a <strong class="source-inline">Pause</strong> axis by changing the <strong class="bold">Name</strong> to <strong class="source-inline">Pause</strong>, the <strong class="bold">Positive Button</strong> to <strong class="source-inline">p</strong>, and changing the rest of the properties to <span>the following:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer198">
<img alt="Figure 8.16: The Pause axis added to the Input Manager" src="image/B18327_08_16.jpg" class="calibre198"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.16: The Pause axis added to the Input Manager</p>
<ol class="calibre13">
<li value="4" class="calibre14">Now that <a id="_idIndexMarker408" class="pcalibre pcalibre1 calibre6"/>we have our <strong class="source-inline">Pause</strong> axis set up, we can start writing our code. Let’s define some variables to use with the <strong class="source-inline">Pause Panel</strong> similar to the way we defined variables for <strong class="source-inline">Inventory Panel</strong>. Add the following variable definitions at the top of your class under your previous <span>variable definitions:</span><pre class="source-code">
public CanvasGroup pausePanel;bool pauseUp = false;</pre></li> <li class="calibre14">Add the <a id="_idIndexMarker409" class="pcalibre pcalibre1 calibre6"/>following to the <strong class="source-inline">Start()</strong> function and make the <strong class="source-inline">Pause Panel</strong> invisible <span>at start:</span><pre class="source-code">
TogglePanel(pausePanel, pauseUp);</pre></li> <li class="calibre14">Since we added the <strong class="source-inline">Pause</strong> axis to our Input Manager, we can use <strong class="source-inline">Input.GetButtonDown()</strong> instead of <strong class="source-inline">Input.GetKeyDown()</strong>, like we did with <strong class="source-inline">Inventory Panel</strong>. We want to use <strong class="source-inline">GetButtonDown()</strong> rather than <strong class="source-inline">GetAxis()</strong> because we want a function that will return <strong class="source-inline">true</strong> once, not continuously. If it returned continuously (using <strong class="source-inline">GetAxis()</strong>), the Panel would flicker in and out while the <em class="italic">P</em> key was being pressed. Add the following code at the end of your <strong class="source-inline">Update()</strong> function. Note that it’s very similar to the code we used for <span>Inventory Panel:</span><pre class="source-code">
// pause Panel
if(Input.GetButtonDown("Pause")){
     pauseUp = !pauseUp;
     TogglePanel(pausePanel, pauseUp);
}</pre></li> <li class="calibre14">Now <a id="_idIndexMarker410" class="pcalibre pcalibre1 calibre6"/>that we’ve added new public variables to our script, it should be showing up in the <strong class="bold">Inspector</strong> of <strong class="source-inline">Main Camera</strong>. Drag and drop the <strong class="source-inline">Pause Panel</strong> from the Hierarchy to the <strong class="bold">Pause </strong><span><strong class="bold">Panel</strong></span><span> slot.</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer199">
<img alt="Figure 8.17: The ShowHidePanel.cs script component with the Pause Panel added" src="image/B18327_08_17.jpg" class="calibre199"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.17: The ShowHidePanel.cs script component with the Pause Panel added</p>
<ol class="calibre13">
<li value="8" class="calibre14">Now, play the game and watch the <strong class="source-inline">Pause Panel</strong> become visible and invisible when you<a id="_idIndexMarker411" class="pcalibre pcalibre1 calibre6"/> press the <em class="italic">P</em> key on <span>the keyboard.</span></li>
</ol>
<p class="calibre3">Next, we’ll learn <a id="_idTextAnchor204" class="pcalibre pcalibre1 calibre6"/>about pausing <span>the game.</span></p>
<h2 id="_idParaDest-145" class="calibre7"><a id="_idTextAnchor205" class="pcalibre pcalibre1 calibre6"/>Pausing the game</h2>
<p class="calibre3">The <a id="_idIndexMarker412" class="pcalibre pcalibre1 calibre6"/>game doesn’t actually pause right now. If we had animations or events running in the scene, they would continue to run even with the <strong class="source-inline">Pause Panel</strong> up. A really easy way to pause a game is to manipulate the time scale of the game. If the time scale is set to <strong class="source-inline">1</strong>, time will run as it normally does. If the time scale is set to <strong class="source-inline">0</strong>, the time within the game <span>will pause.</span></p>
<p class="calibre3">Also, our current setup doesn’t quite work as a pause menu would be expected to. <strong class="source-inline">Inventory Panel</strong> and <strong class="source-inline">Pause Panel</strong> can be displayed at the same time. If <strong class="source-inline">Inventory Panel</strong> is up, the <strong class="source-inline">Pause Panel</strong> is covered up by it since it is rendering behind it. Also, the <strong class="source-inline">Inventory Panel</strong> can be activated when the game <span>is </span><span><em class="italic">paused</em></span><span>.</span></p>
<p class="calibre3">We’ll need to<a id="_idIndexMarker413" class="pcalibre pcalibre1 calibre6"/> pause the time scale of our game, change the order that our Panels render, and disable functionality when the game is paused to have a <strong class="source-inline">Pause Panel</strong> that functions properly. To create a properly functioning <strong class="source-inline">Pause Panel</strong>, complete the <span>following steps:</span></p>
<ol class="calibre13">
<li class="calibre14">Add the following to the <strong class="source-inline">Update()</strong> function to the <strong class="source-inline">ShowHidePanels</strong> script to pause the time in <span>the game:</span><pre class="source-code">
// pause Panel
if(Input.GetButtonDown("Pause")){
     pauseUp = !pauseUp;
     TogglePanel(pausePanel, pauseUp);
     <strong class="bold">Time.timeScale = Convert.ToInt32(pauseUp);</strong>
}</pre></li> <li class="calibre14">Now, let’s deal with the fact that <strong class="source-inline">Pause Panel</strong> is behind the <strong class="source-inline">Inventory Panel</strong>. This is an easy fix. Simply change their order in the Hierarchy by dragging the <strong class="source-inline">Pause Panel</strong> below the <strong class="source-inline">Inventory Panel</strong>. The items that are listed lower in the Hierarchy render on top of the ones listed above it within the scene. Now, the <strong class="source-inline">Pause Panel</strong> will be above the <strong class="source-inline">Inventory Panel</strong> in <span>the scene:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer200">
<img alt="Figure 8.18: The children of the Popup Canvas" src="image/B18327_08_18.jpg" class="calibre200"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.18: The children of the Popup Canvas</p>
<ol class="calibre13">
<li value="3" class="calibre14">The only thing left to do is to disable the ability of the <strong class="source-inline">Inventory Panel</strong> to appear and disappear if the <strong class="source-inline">Pause Panel</strong> is up. Adjust the <strong class="source-inline">if</strong> statement that checks for the <em class="italic">I</em> key being pressed to also check whether <strong class="source-inline">pauseUp</strong> is false, <span>like so:</span><pre class="source-code">
if(Input.GetKeyDown(KeyCode.I) <strong class="bold">&amp;&amp; !pauseUp</strong>){</pre></li> <li class="calibre14">Play the game now and see that when the game is paused, <strong class="source-inline">Inventory Panel</strong> cannot be activated or deactivated. If the <strong class="source-inline">Inventory Panel</strong> is activated when the <strong class="source-inline">Pause Panel</strong> is already up, it cannot be deactivated until after the game <span>is unpaused.</span></li>
</ol>
<p class="calibre3">It’s important to<a id="_idIndexMarker414" class="pcalibre pcalibre1 calibre6"/> remember that when you have a <strong class="source-inline">Pause Panel</strong>, other events need to be turned off. Setting the timescale to <strong class="source-inline">0</strong> does not stop the ability for other events to occur; it only really stops animations and any clocks you may have displayed that use the time scale. So, we will need to ensure that any other event we program is turned off<a id="_idTextAnchor206" class="pcalibre pcalibre1 calibre6"/> when the game <span>is paused.</span></p>
<h2 id="_idParaDest-146" class="calibre7"><a id="_idTextAnchor207" class="pcalibre pcalibre1 calibre6"/>Dragging and dropping inventory items</h2>
<p class="calibre3">We have an <strong class="source-inline">Inventory Panel</strong> that can be displayed and hidden and a HUD inventory. I <a id="_idIndexMarker415" class="pcalibre pcalibre1 calibre6"/>want to be able to drag objects from my larger <strong class="source-inline">Inventory Panel</strong> to my smaller HUD inventory called <strong class="source-inline">Bottom Right Panel</strong> that we created in the <span>previous chapter.</span></p>
<p class="calibre3">To make things a little easier for ourselves, let’s disable the <strong class="source-inline">ShowHidePanels</strong> script that we added to the <strong class="source-inline">Main Camera</strong> earlier in this chapter. You can do this by deselecting the checkbox next to the script’s component on the <span><strong class="source-inline">Main Camera</strong></span><span>:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer201">
<img alt="Figure 8.19: Disabling the ShowHidePanel.cs script component" src="image/B18327_08_19.jpg" class="calibre201"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.19: Disabling the ShowHidePanel.cs script component</p>
<p class="calibre3">Let’s also disable <strong class="source-inline">Pause Panel</strong> so that it will not be in our way. Do this by deselecting the checkbox next to the name of the <strong class="source-inline">Pause Panel</strong> in <span>its Inspector.</span></p>
<p class="calibre3">Now, our Panel will stay visible, making it easier for us to debug the code we’re about <span>to write.</span></p>
<p class="calibre3">There are <a id="_idIndexMarker416" class="pcalibre pcalibre1 calibre6"/>quite a few different ways to make a drag and drop mechanic. To ensure that this chapter provides an example of how to use the <strong class="bold">Event Trigger</strong> component, we will write a drag and drop mechanic utilizing it. To create a drag and drop mechanic for the <strong class="source-inline">Inventory Panel</strong> and <strong class="source-inline">Bottom Right Panel</strong>, complete the <span>following steps:</span></p>
<ol class="calibre13">
<li class="calibre14">Create a new C# script in the <strong class="source-inline">Assets/Scripts</strong> folder called <strong class="source-inline">DragAndDrop.cs</strong> and <span>open it.</span></li>
<li class="calibre14">We will be referencing UI elements in this script, so add the <strong class="source-inline">UnityEngine.UI</strong> namespace to the top of the script <span>with this:</span><pre class="source-code">
using UnityEngine.UI;</pre></li> <li class="calibre14">We only need to add two variables to this script: one will represent the GameObject being dragged, and the other represents the Canvas that the items will be dragged on. Add the following public variables to the top of <span>the class:</span><pre class="source-code">
public GameObject dragItem;¶public Canvas dragCanvas;</pre></li> <li class="calibre14">Before we write any more code, let’s go back to the Editor and do a bit more prep work. Drag the <strong class="source-inline">DragAndDrop.cs</strong> script to the <strong class="bold">Inspector</strong> of the <strong class="source-inline">Main Camera</strong> to attach it as <span>a component:</span>
<div class="calibre2">
<div class="img---figure" id="_idContainer202">
<img alt="Figure 8.20: The components of the Main Camera" src="image/B18327_08_20.jpg" class="calibre202"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.20: The components of the Main Camera</p>
<p class="calibre3">I’ve chosen to create a script that attaches to the <strong class="source-inline">Main Camera</strong> rather than the individual inventory items to reduce the need to duplicate <span>this script.</span></p></li></ol>
<ol class="calibre13">
<li value="5" class="calibre14">Now, create<a id="_idIndexMarker417" class="pcalibre pcalibre1 calibre6"/> a new UI Canvas by selecting <strong class="bold">+</strong> | <strong class="bold">UI</strong> | <strong class="bold">Canvas</strong> from the Hierarchy menu. Name the new Canvas <span><strong class="source-inline">Drag Canvas</strong></span><span>.</span></li>
<li class="calibre14">Select <strong class="source-inline">HUD Canvas</strong> and copy its <strong class="bold">Canvas Scalar</strong> component by selecting the settings three dots (aka “the kabob”) in its top-right corner and selecting <span><strong class="bold">Copy</strong></span><span> </span><span><strong class="bold">Component</strong></span><span>.</span></li>
<li class="calibre14">Reselect <strong class="source-inline">Drag Canvas</strong> and paste the copied <strong class="bold">Canvas Scaler</strong> properties to its <strong class="bold">Canvas Scalar</strong> component by selecting the three dots in its top-right corner and selecting <strong class="bold">Paste </strong><span><strong class="bold">Component Values</strong></span><span>.</span><p class="calibre3">Once that is done, it should have the <span>following values:</span></p></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer203">
<img alt="Figure 8.21: The Canvas Scaler component on the Drag Canvas" src="image/B18327_08_21.jpg" class="calibre203"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.21: The Canvas Scaler component on the Drag Canvas</p>
<ol class="calibre13">
<li value="8" class="calibre14">Set the <strong class="bold">Sort Order</strong> property on the <strong class="source-inline">Drag Canvas</strong>’ Canvas component to <strong class="source-inline">1</strong>. This will<a id="_idIndexMarker418" class="pcalibre pcalibre1 calibre6"/> cause anything that is on the <strong class="source-inline">Drag Canvas</strong> to render in front of all other Canvases since the other Canvases have a <strong class="bold">Sort Order</strong> <span>of </span><span><strong class="source-inline">0</strong></span><span>:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer204">
<img alt="Figure 8.22: Updating the Sort Order on the Drag Canvas’ Canvas component" src="image/B18327_08_22.jpg" class="calibre204"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.22: Updating the Sort Order on the Drag Canvas’ Canvas component</p>
<ol class="calibre13">
<li value="9" class="calibre14">Drag and drop the <strong class="source-inline">Drag Canvas</strong> from the Hierarchy into the <strong class="bold">Drag Canvas</strong> slot on the <strong class="source-inline">DragAndDrop</strong> script component on the <span><strong class="source-inline">Main Camera</strong></span><span>:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer205">
<img alt="Figure 8.23: The Drag and Drop component" src="image/B18327_08_23.jpg" class="calibre205"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.23: The Drag and Drop component</p>
<ol class="calibre13">
<li value="10" class="calibre14">Reopen the <strong class="source-inline">DragAndDrop</strong> script. Create a new function called <strong class="source-inline">StartDrag()</strong>, <span>as follows:</span><pre class="source-code">
public void StartDrag(GameObject selectedObject){
    dragItem = Instantiate(selectedObject, Input.mousePosition, selectedObject.transform.rotation) as GameObject;
    dragItem.transform.SetParent(dragCanvas.transform);
    dragIt<a id="_idTextAnchor208" class="pcalibre pcalibre1 calibre6"/>em.GetComponent&lt;Image&gt;().SetNativeSize();
    dragItem.transform.localScale = 1.1f * dragItem.transform.localScale;
}</pre><p class="calibre3">This function<a id="_idIndexMarker419" class="pcalibre pcalibre1 calibre6"/> will be called when a drag begins. It accepts a GameObject as a parameter and then creates a new instance of it at the position of the mouse. It then moves it so that it is a child of <strong class="source-inline">dragCanvas</strong>. Lastly, it sets the size of the sprite on the Image component to native size. This resets the scale of the Image’s Rect Transform to its sprite’s original pixel size. (Refer to <a href="B18327_12.xhtml#_idTextAnchor328" class="pcalibre pcalibre1 calibre6"><span><em class="italic">Chapter 12</em></span></a> for more on <strong class="bold">Set Native Size</strong>). The last line makes the image 10% bigger than its <span>native size.</span></p></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">After we hook up our <strong class="source-inline1">BeginDrag</strong> and <strong class="source-inline1">Drag</strong> events, if you comment out the line of code that sets the size to native, you›ll see that the Image does not actually render in the scene, because its scale is «wacky» from the original GameObject being within a <span><strong class="bold">Layout Group</strong></span><span>.</span></p>
<ol class="calibre13">
<li value="11" class="calibre14">Now, create a new function called <strong class="source-inline">Drag()</strong>, <span>as follows:</span><pre class="source-code">
public void Drag(){
     dragItem.transform.position = Input.mousePosition;
}</pre><p class="calibre3">This function will be called when an object is being dragged. While the object is dragged, it will keep position with <span>the mouse.</span></p></li> <li class="calibre14">Return to the<a id="_idIndexMarker420" class="pcalibre pcalibre1 calibre6"/> Editor. We will just hook the events to the first object in the <strong class="source-inline">Inventory Panel</strong> for now. Select the first <strong class="source-inline">Food</strong> image in the <span><strong class="source-inline">Inventory Panel</strong></span><span>:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer206">
<img alt="Figure 8.24: Selecting the Food GameObject" src="image/B18327_08_24.jpg" class="calibre206"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.24: Selecting the Food GameObject</p>
<ol class="calibre13">
<li value="13" class="calibre14">Add a new Event Trigger component to the <strong class="source-inline">Food</strong> Image by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Event Trigger</strong> within <span>its </span><span><strong class="bold">Inspector</strong></span><span>:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer207">
<img alt="Figure 8.25: The Food GameObject with the Event Trigger component" src="image/B18327_08_25.jpg" class="calibre207"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.25: The Food GameObject with the Event Trigger component</p>
<ol class="calibre13">
<li value="14" class="calibre14">Now, add a <strong class="bold">Begin Drag</strong> event<a id="_idIndexMarker421" class="pcalibre pcalibre1 calibre6"/> type and a <strong class="bold">Drag</strong> event type to the <strong class="bold">Event Trigger</strong> list by selecting <strong class="bold">Add New Event Type</strong> | <strong class="bold">BeginDrag</strong> and <strong class="bold">Add New Event Type</strong> | <span><strong class="bold">Drag</strong></span><span>:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer208">
<img alt="Figure 8.26: The Event Trigger component with two events" src="image/B18327_08_26.jpg" class="calibre208"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.26: The Event Trigger component with two events</p>
<ol class="calibre13">
<li value="15" class="calibre14">Now, we<a id="_idIndexMarker422" class="pcalibre pcalibre1 calibre6"/> will add an action to the <strong class="bold">Begin Drag</strong> list by selecting the plus sign at the bottom-right corner of the <strong class="bold">Begin </strong><span><strong class="bold">Drag</strong></span><span> area:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer209">
<img alt="Figure 8.27: Adding a Begin Drag event" src="image/B18327_08_27.jpg" class="calibre209"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.27: Adding a Begin Drag event</p>
<ol class="calibre13">
<li value="16" class="calibre14">Drag the <strong class="source-inline">Main Camera</strong> into the <span>object slot:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer210">
<img alt="Figure 8.28: Updating the Begin Drag event with the camera" src="image/B18327_08_28.jpg" class="calibre210"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.28: Updating the Begin Drag event with the camera</p>
<ol class="calibre13">
<li value="17" class="calibre14">The function dropdown list is now intractable. Expand the function dropdown list to see the<a id="_idIndexMarker423" class="pcalibre pcalibre1 calibre6"/> list of functions, components, and such attached to the <strong class="source-inline">Main Camera</strong>. Find the <strong class="bold">DragAndDrop</strong> script and then the <strong class="bold">StartDrag (</strong><span><strong class="bold">GameObject)</strong></span><span> function:</span>
<div class="calibre2">
<div class="img---figure" id="_idContainer211">
<img alt="Figure 8.29: Adding the StartDrag method" src="image/B18327_08_29.jpg" class="calibre211"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.29: Adding the StartDrag method</p>
<p class="calibre3">Once you have done so, you should see <span>the following:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer212">
<img alt="Figure 8.30: Adding the StartDrag method" src="image/B18327_08_30.jpg" class="calibre212"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.30: Adding the StartDrag method</p></li>
</ol>
<ol class="calibre13">
<li value="18" class="calibre14">Now, we<a id="_idIndexMarker424" class="pcalibre pcalibre1 calibre6"/> need to assign the GameObject parameter. Drag and drop the <strong class="source-inline">Food</strong> Image that this <strong class="bold">Event Trigger</strong> component is attached to into the <span>parameter slot.</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer213">
<img alt="Figure 8.31: Updating the StartDrag method" src="image/B18327_08_31.jpg" class="calibre213"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.31: Updating the StartDrag method</p>
<ol class="calibre13">
<li value="19" class="calibre14">Now, set up the <strong class="bold">Drag</strong> event list similarly so that it looks <span>like this:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer214">
<img alt="Figure 8.32: Adding the Drag method" src="image/B18327_08_32.jpg" class="calibre214"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.32: Adding the Drag method</p>
<ol class="calibre13">
<li value="20" class="calibre14">If you play the game, you should now be able to drag the orange in the first slot out of <span>its slot.</span>
<div class="calibre2">
<div class="img---figure" id="_idContainer215">
<img alt="Figure 8.33: Dragging the orange from the inventory" src="image/B18327_08_33.jpg" class="calibre215"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.33: Dragging the orange from the inventory</p>
<p class="calibre3">You’ll see, in<a id="_idIndexMarker425" class="pcalibre pcalibre1 calibre6"/> the Hierarchy, there is a new GameObject called <strong class="source-inline">Food(Clone)</strong> that is a child of the <strong class="source-inline">Drag Canvas</strong>. This is the orange that gets created when you <span>begin dragging.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer216">
<img alt="Figure 8.34: The item being dragged in the Drag Canvas" src="image/B18327_08_34.jpg" class="calibre216"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.34: The item being dragged in the Drag Canvas</p>
<p class="calibre3">At this point, you can actually make as many of these clones as you want. In a moment, however, we will make it so that there is only one clone in the <strong class="source-inline">Drag Canvas</strong> at <span>a time.</span></p></li>
</ol>
<ol class="calibre13">
<li value="21" class="calibre14">Go back to the <strong class="source-inline">DragAndDrop</strong> script and create a new function called <strong class="source-inline">StopDrag()</strong>, <span>as follows:</span><pre class="source-code">
public void StopDrag(){
     Destroy(dragItem);
}</pre><p class="calibre3">This code will destroy the <strong class="source-inline">Food(Clone)</strong> GameObject once it is no longer <span>being dragged.</span></p></li> <li class="calibre14">Go back to the<a id="_idIndexMarker426" class="pcalibre pcalibre1 calibre6"/> Editor and reselect the <strong class="source-inline">Food</strong> Image in <strong class="source-inline">Inventory Panel</strong>. Give its <strong class="bold">Event Trigger</strong> component an <strong class="source-inline">EndDrag</strong> event type by selecting <strong class="bold">Add New Event Type</strong> | <strong class="bold">EndDrag</strong>. It will automatically assign the <strong class="source-inline">Drag()</strong> function from the <strong class="source-inline">DragAndDrop</strong> script to this event since that was the last <span>selected function:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer217">
<img alt="Figure 8.35: The End Drag event with the Drag method" src="image/B18327_08_35.jpg" class="calibre217"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.35: The End Drag event with the Drag method</p>
<ol class="calibre13">
<li value="23" class="calibre14">Replace the <strong class="source-inline">Drag()</strong> function in the function dropdown with the <span><strong class="source-inline">StopDrag()</strong></span><span> function:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer218">
<img alt="Figure 8.36: The End Drag event with the StopDrag method" src="image/B18327_08_36.jpg" class="calibre218"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.36: The End Drag event with the StopDrag method</p>
<ol class="calibre13">
<li value="24" class="calibre14">Play the game, and you will see that the orange can now be dragged out of its slot, and when you release the mouse, it is destroyed. This stops you from being able to drag a bunch of oranges from <span>this slot.</span></li>
<li class="calibre14">Go back to the <strong class="source-inline">DragAndDrop</strong> script and create a new function called <strong class="source-inline">Drop()</strong>, as shown in <span>the following:</span><pre class="source-code">
public void Drop(Image dropSlot){
     GameObject droppedItem = dragCanvas.transform.GetChild(0).gameObject;
     dropSlot.sprite = droppedItem.GetComponent&lt;Image&gt;().sprite;
}</pre><p class="calibre3">This<a id="_idIndexMarker427" class="pcalibre pcalibre1 calibre6"/> function accepts an <strong class="source-inline">Image</strong> as a parameter. This Image will be the Image component of the slot that will receive a drop. The first line of the function finds the first child of the <strong class="source-inline">dragCanvas</strong> (at position <strong class="source-inline">0</strong>) and then assigns its Image’s sprite to the sprite of the <strong class="source-inline">dropSlot</strong>. Since we have set up the <strong class="source-inline">StopDrag()</strong> function to destroy the object being dragged once it stops dragging, we don’t have to worry about there being more than one child of the <strong class="source-inline">Drag Canvas </strong>GameObject, making this the easiest way to find the object <span>being dragged.</span></p></li> <li class="calibre14">Go back to the Editor and select the second <strong class="source-inline">Food</strong> Image in the <strong class="source-inline">Bottom </strong><span><strong class="source-inline">Right Panel</strong></span><span>:</span>
<div class="calibre2">
<div class="img---figure" id="_idContainer219">
<img alt="Figure 8.37: Selecting the correct Food item" src="image/B18327_08_37.jpg" class="calibre219"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.37: Selecting the correct Food item</p>
<p class="calibre3">We’re using the second <strong class="source-inline">Food</strong> Image, rather than the first, because the first already has an orange in it, and it will be hard to tell that our script worked in <span>that slot.</span></p></li>
</ol>
<ol class="calibre13">
<li value="27" class="calibre14">Add a new <strong class="bold">Event Trigger</strong> component to the <strong class="source-inline">Food</strong> Image by selecting <strong class="bold">Add Component</strong> | <strong class="bold">Event</strong> | <strong class="bold">Event Trigger</strong> within <span>its Inspector.</span></li>
<li class="calibre14">Add a <strong class="source-inline">Drop</strong> event type to the <strong class="bold">Event Trigger</strong> component by selecting <strong class="bold">Add New Event Type</strong> | <span><strong class="bold">Drop</strong></span><span>:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer220">
<img alt="Figure 8.38: The Drop event" src="image/B18327_08_38.jpg" class="calibre220"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.38: The Drop event</p>
<ol class="calibre13">
<li value="29" class="calibre14">Add a new <a id="_idIndexMarker428" class="pcalibre pcalibre1 calibre6"/>action to the list with the <strong class="bold">+</strong> <span>sign.</span></li>
<li class="calibre14">Drag <strong class="source-inline">Main Camera</strong> to the object slot and select the <strong class="source-inline">Drop()</strong> function from the <span><strong class="source-inline">DragAndDrop</strong></span><span> script:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer221">
<img alt="Figure 8.39: The Drop event with its method populated" src="image/B18327_08_39.jpg" class="calibre221"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.39: The Drop event with its method populated</p>
<ol class="calibre13">
<li value="31" class="calibre14">Now, drag the <strong class="source-inline">Food</strong> Image that this <strong class="bold">Event Trigger</strong> component is attached to into the <span>parameter slot:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer222">
<img alt="Figure 8.40: The Drop event with the correct parameter" src="image/B18327_08_40.jpg" class="calibre222"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.40: The Drop event with the correct parameter</p>
<ol class="calibre13">
<li value="32" class="calibre14">Play the game and when you drag the orange into the slot over the banana, the <strong class="source-inline">Drop()</strong> function doesn’t appear to trigger. This is because the orange being dragged is blocking the raycasting from reaching the banana, so the banana never thinks anything is dropped on it. This is an easy fix. Add the following line of code to the end of the <strong class="source-inline">StartDrag()</strong> function in the <strong class="source-inline">DragAndDrop</strong> script so that the raycast won’t be blocked by the <span>orange anymore:</span><pre class="source-code">
dragItem.GetComponent&lt;Image&gt;().raycastTarget = false;</pre></li> <li class="calibre14">Play the<a id="_idIndexMarker429" class="pcalibre pcalibre1 calibre6"/> game, and you should now be able to drag the orange from the first slot of the <strong class="source-inline">Inventory Panel</strong> to the second slot of <strong class="source-inline">Bottom </strong><span><strong class="source-inline">Right Panel</strong></span><span>.</span></li>
<li class="calibre14">The functionality of drag and drop is now complete; we just need to add the functionality to the other slots. Let’s add the drag events to the other <strong class="source-inline">Inventory Panel</strong> <span>items first.</span><p class="calibre3">Copy the <strong class="bold">Event Trigger</strong> component of the <strong class="source-inline">Food</strong> Item in the <strong class="source-inline">Inventory Panel</strong> that we hook the events up to, using the three dots in the component’s <span>top-right corner.</span></p></li>
<li class="calibre14">Select all the other <strong class="source-inline">Food</strong> Images in the <strong class="source-inline">Inventory Panel</strong> by clicking on them while <span>holding </span><span><em class="italic">Ctrl</em></span><span>.</span></li>
<li class="calibre14">Now, with all eight <strong class="source-inline">Food</strong> Images still selected, click on the three dots on the <strong class="bold">Image</strong> component and select <strong class="bold">Paste Component as New</strong>. Each of the <strong class="source-inline">Food</strong> Images should now have the <strong class="bold">Event Trigger</strong> component with all the <span>appropriate events.</span></li>
<li class="calibre14">We’re not done with these other inventory items yet. We need to select each one and drag it into the parameter of the <strong class="source-inline">BeginDrag</strong> event type for its component. Otherwise, each of these other eight <strong class="source-inline">Food</strong> items will drag out oranges instead of the appropriate <strong class="source-inline">Food</strong> item, because the original orange is assigned to that slot. Do <span>so now.</span></li>
<li class="calibre14">Before continuing, play the game and ensure that each inventory item in <strong class="source-inline">Inventory Panel</strong> drags out the <span>appropriate image.</span></li>
<li class="calibre14">Now, we will copy the drop events from the second <strong class="source-inline">Food</strong> Image image in the <strong class="source-inline">Bottom Right Panel</strong> to all the other <strong class="source-inline">Food</strong> Images within the Panel. Copy the <strong class="bold">Event Trigger</strong> component from the second <strong class="source-inline">Food</strong> Image in the <strong class="source-inline">Bottom </strong><span><strong class="source-inline">Right Panel</strong></span><span>.</span></li>
<li class="calibre14">Select<a id="_idIndexMarker430" class="pcalibre pcalibre1 calibre6"/> the other four <strong class="source-inline">Food</strong> Images in the <strong class="source-inline">Bottom Right Panel</strong> while holding <span>down </span><span><em class="italic">Ctrl</em></span><span>.</span></li>
<li class="calibre14">With each of the <strong class="source-inline">Food</strong> Images shown in the preceding screenshot still selected, paste the component as new in <span>the Inspector.</span></li>
<li class="calibre14">Now, select each of the new <strong class="source-inline">Food</strong> Images and assign each to the parameter slot within their <strong class="bold">Event </strong><span><strong class="bold">Trigger</strong></span><span> component.</span></li>
<li class="calibre14">Play the game and ensure that the correct image slot is changed when a food item is dropped <span>into it.</span></li>
<li class="calibre14">Now that the drag and drop code is done, re-enable the <strong class="source-inline">ShowHidePanels</strong> script on the <strong class="source-inline">Main Camera</strong> and re-enable the <span><strong class="source-inline">Pause Panel</strong></span><span>.</span></li>
</ol>
<p class="calibre3">That’s it for the drag and drop code. Currently, the <strong class="source-inline">Pause Panel</strong> blocks the raycast on the items within the <strong class="source-inline">Inventory Panel</strong>, so you don’t have to worry about disabling these events when the game is paused. However, if you end up changing the layout, you will want to do so by checking whether the <strong class="source-inline">pauseUp</strong> variable in <strong class="source-inline">ShowHidePanels</strong> is <strong class="source-inline">false</strong> before performing <span>the tasks.</span></p>
<p class="calibre3">If you want to allow the objects to go back and forth (drag from both Panels and drop in both Panels), all you have to do is copy the appropriate component to the <span>opposite Panels!</span></p>
<p class="calibre3">You might also want to make the repeated UI elements prefabs so that you can save yourself some time during development or instantiate <span>them programmatically.</span></p>
<p class="calibre3">There are so many more examples I would love to cover in this chapter, but I can’t make this chapter take up the entire page count of the book! You’ll see more examples of how to use the Event System in the upcoming chapters, so don’t worry; this isn’t the last code example you <span>will see<a id="_idTextAnchor209" class="pcalibre pcalibre1 calibre6"/>.</span></p>
<h2 id="_idParaDest-147" class="calibre7"><a id="_idTextAnchor210" class="pcalibre pcalibre1 calibre6"/>Pan and zoom with mouse and multi-touch input</h2>
<p class="calibre3">The last <a id="_idIndexMarker431" class="pcalibre pcalibre1 calibre6"/>example I want to cover in this chapter is how to pan the camera with a two-finger touch and pinch to zoom. We will also implement a left-click pan and scroll wheel zoom so that you can easily test it on your computer (when you don’t have multi-touch input). The following image shows what we will <span>be implementing.</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer223">
<img alt="Figure 8.41: Demonstration of the pan and zoom code working" src="image/B18327_08_41.jpg" class="calibre223"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.41: Demonstration of the pan and zoom code working</p>
<p class="calibre3">To implement a pan and zoom on the camera, complete the <span>following steps:</span></p>
<ol class="calibre13">
<li class="calibre14">So that I can actually see the effects of the pan and zoom, I want to populate some items in the scene. Let’s start by creating a prefab that we will place multiple times in the background. Create a <strong class="source-inline">Prefabs</strong> folder in your project by right-clicking on the <strong class="source-inline">Assets</strong> folder and selecting <strong class="bold">Create</strong> | <strong class="bold">Folder</strong>. Name the new <span>folder </span><span><strong class="source-inline">Prefabs</strong></span><span>.</span></li>
<li class="calibre14">Drag a sprite to the scene. I chose the first gem in the <strong class="source-inline">foodSpriteSheet</strong> <span>called </span><span><strong class="source-inline">foodSpriteSheet_1</strong></span><span>.</span></li>
<li class="calibre14">Ensure that the <strong class="bold">Transform</strong> component of the sprite is positioned at the origin. If it is not, select the three dots in the top-right corner of the component and then <span>select </span><span><strong class="bold">Reset</strong></span><span>.</span></li>
<li class="calibre14">Rename the <span>sprite </span><span><strong class="source-inline">Tile</strong></span><span>.</span></li>
<li class="calibre14">Now, drag the sprite from the Hierarchy into your <strong class="source-inline">Prefabs</strong> folder. This will create a prefab <span>called </span><span><strong class="source-inline">Tile</strong></span><span>.</span></li>
<li class="calibre14">We no longer need the prefab in the scene so go ahead and <span>delete it.</span></li>
<li class="calibre14">Create an empty GameObject by selecting <strong class="bold">+</strong> | <strong class="bold">Create Empty</strong> in the Hierarchy. We will use this to hold the code that instantiates <span>our tiles.</span></li>
<li class="calibre14">Rename<a id="_idIndexMarker432" class="pcalibre pcalibre1 calibre6"/> this empty GameObject to <span><strong class="source-inline">Tile Maker</strong></span><span>.</span></li>
<li class="calibre14">In the book’s source files, you will find three scripts called <strong class="source-inline">Tile.cs</strong>, <strong class="source-inline">TileMaker.cs</strong>, and <strong class="source-inline">CameraHandle.cs</strong>. Import them into the <strong class="source-inline">Scripts</strong> folder of <span>your project.</span></li>
<li class="calibre14">Attach the <strong class="source-inline">Tile.cs</strong> script to the <strong class="source-inline">Tile</strong> prefab. This script will be used to make any instantiated <strong class="source-inline">Tile</strong> prefab have a <span>random sprite.</span></li>
<li class="calibre14">Since the <strong class="source-inline">Tile.cs</strong> script is not really essential to the example, I won’t review the code, but I will point out that the <strong class="source-inline">possibleSprites</strong> list contains all the sprites that the tile can change to. Add all the sprites that look like gems to this list. You should see something like <span>the following</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer224">
<img alt="Figure 8.42: The possible sprites for the tile" src="image/B18327_08_42.jpg" class="calibre224"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.42: The possible sprites for the tile</p>
<ol class="calibre13">
<li value="12" class="calibre14">Now <a id="_idIndexMarker433" class="pcalibre pcalibre1 calibre6"/>attach the <strong class="source-inline">TileMaker.cs</strong> script to the <strong class="source-inline">Tile </strong><span><strong class="source-inline">Maker</strong></span><span> GameObject.</span></li>
<li class="calibre14">Drag the <strong class="source-inline">Tile</strong> prefab into the <strong class="bold">Tile Prefab</strong> slot and set the other values <span>as follows:</span>
<div class="calibre2">
<div class="img---figure" id="_idContainer225">
<img alt="Figure 8.43: The TileMaker.cs script component" src="image/B18327_08_43.jpg" class="calibre225"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.43: The TileMaker.cs script component</p>
<p class="calibre3">This will make a total of <strong class="source-inline">500</strong> tiles instantiate in <strong class="source-inline">25</strong> columns and <span><strong class="source-inline">20</strong></span><span> rows.</span></p></li>
</ol>
<ol class="calibre13">
<li value="14" class="calibre14">Play the game and you should see a bunch of random gems appear in <span>your scene.</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer226">
<img alt="Figure 8.44: The gems in the scene" src="image/B18327_08_44.jpg" class="calibre226"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.44: The gems in the scene</p>
<ol class="calibre13">
<li value="15" class="calibre14">Now, let’s <a id="_idIndexMarker434" class="pcalibre pcalibre1 calibre6"/>hook up the pan and zoom script. Attach the <strong class="source-inline">CameraHandler.cs</strong> script to the <span><strong class="source-inline">Main Camera</strong></span><span>.</span></li>
<li class="calibre14">Before we review the code, let’s add the correct variables to the component. Adjust the values to <span>the following:</span>
<div class="calibre2">
<div class="img---figure" id="_idContainer227">
<img alt="Figure 8.45: The CameraHandler.cs script component" src="image/B18327_08_45.jpg" class="calibre227"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.45: The CameraHandler.cs script component</p>
<p class="calibre3">The<a id="_idIndexMarker435" class="pcalibre pcalibre1 calibre6"/> various properties add bounds to how far the camera can pan, how much it can zoom, and how quickly it pans <span>and zooms.</span></p></li>
</ol>
<ol class="calibre13">
<li value="17" class="calibre14">Now, let’s review the code. The code handles pan and zoom in two ways: one is with mouse input and the other with touch input. You’ll see that it also has special conditions for when a touch device is being played remotely via the <span>Unity Editor.</span><p class="calibre3">A large portion of this code is vector math, and I will leave that for you to review on your own. The parts of this code I want to focus on are the parts relative to this chapter, specifically the parts involving <strong class="source-inline">Input</strong> and <strong class="source-inline">Touch</strong>. First, let’s look at the <strong class="source-inline">HandleMouse()</strong> method. I’ve highlighted the <span>relevant parts:</span></p><pre class="source-code">
void HandleMouse() {
     if (<strong class="bold">Input.GetMouseButtonDown(0)</strong>) {
          lastPanPosition = <strong class="bold">Input.mousePosition</strong>;
     } else if (<strong class="bold">Input.GetMouseButton(0)</strong>) {
          PanCamera(Input.mousePosition);
     }
     float scroll = <strong class="bold">Input.GetAxis("Mouse ScrollWheel")</strong>;
     ZoomCamera(scroll, zoomSpeedMouse);
}</pre><p class="calibre3">Notice<a id="_idIndexMarker436" class="pcalibre pcalibre1 calibre6"/> that it uses <strong class="source-inline">Input.GetMouseButtonDown(0)</strong> to see if the left mouse button is currently held down, <strong class="source-inline">Input.GetMouseButton(0)</strong> to see if the mouse button has been clicked, and <strong class="source-inline">Input.mousePosition</strong> to find where the mouse <span>is located.</span></p></li> <li class="calibre14">Now, let’s look at how input is handled with touch in the <strong class="source-inline">HandleTouch()</strong> method. First, it looks to see how many fingers are touching the screen with the following <span><strong class="source-inline">switch</strong></span><span> statement:</span><pre class="source-code">
switch(<strong class="bold">Input.touchCount</strong>) {</pre><p class="calibre3"><strong class="source-inline">Input.touchCount</strong> returns how many <em class="italic">fingers</em> are currently touching <span>the screen.</span></p></li> <li class="calibre14">When a single finger is touching the screen, the camera can pan. It first must get the position of the finger. It does so with the <span>following code:</span><pre class="source-code">
<strong class="bold">Touch touch = Input.GetTouch(0);</strong>
if (<strong class="bold">touch.phase == TouchPhase.Began</strong>) {
     lastPanPosition = <strong class="bold">touch.position;</strong>
     panFingerId = <strong class="bold">touch.fingerId;</strong>
} else if (<strong class="bold">touch.fingerId</strong> == panFingerId &amp;&amp; <strong class="bold">touch.phase == TouchPhase.Moved</strong>) {
     PanCamera(<strong class="bold">touch.position</strong>);
}</pre><p class="calibre3">Once again, I have highlighted the <span>relevant code.</span></p></li> <li class="calibre14">When <a id="_idIndexMarker437" class="pcalibre pcalibre1 calibre6"/>two fingers are touching the screen, it will get the position of the fingers with <span>the following:</span><pre class="source-code">
Vector2[] newPositions = new Vector2[]{<strong class="bold">Input.GetTouch(0).position,</strong> <strong class="bold">Input.GetTouch(1).position};</strong></pre><p class="calibre3">It stores the position of the first finger and the second finger in a <strong class="source-inline">Vector2</strong> array. It then uses some fancy vector math to see whether the fingers are getting closer to each other or further away from each other, creating a <span>pinch-to-zoom effect.</span></p></li> <li class="calibre14">The next piece of code that I want to focus on is the following line within the <span><strong class="source-inline">PanCamera()</strong></span><span> method:</span><pre class="source-code">
Vector3 offset = theCamera.<strong class="bold">ScreenToViewportPoint</strong>(lastPanPosition - newPanPosition);</pre><p class="calibre3">This line of code is crucial as it converts the screen coordinates of your mouse or finger to that of <span>the viewport.</span></p></li> <li class="calibre14">If you try playing the game, the camera won’t actually pan! We need to call the <strong class="source-inline">DragCamera()</strong> and <strong class="source-inline">StopCameraDrag()</strong> methods, so it will know when to get the inputs. We’ll do this with Event Triggers on the <strong class="source-inline">Background Canvas</strong>. Add an <strong class="bold">Event Trigger</strong> component to the <strong class="source-inline">Background Canvas</strong> with the <span>following events:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer228">
<img alt="Figure 8.46: The Event Trigger on the Background Canvas" src="image/B18327_08_46.jpg" class="calibre228"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.46: The Event Trigger on the Background Canvas</p>
<ol class="calibre13">
<li value="23" class="calibre14">Now<a id="_idIndexMarker438" class="pcalibre pcalibre1 calibre6"/> that you’ve reviewed the code, play the game again to see the pan and zoom functions in action. If you can, I recommend also plugging a mobile device into your computer and running the game via Unity Remote. You can view information about how to use Unity Remote <span>here: </span><a href="https://docs.unity3d.com/Manual/UnityRemote5.xhtml" class="pcalibre pcalibre1 calibre6"><span>https://docs.unity3d.com/Manual/UnityRemote5.xhtml</span></a><span>.</span></li>
<li class="calibre14">We don’t want the game to pan and zoom when it’s paused and the inventory Panel is up! So, let’s update the <strong class="source-inline">ShowHidePanels.cs</strong> script to call the <strong class="source-inline">TurnOffPanAndZoom()</strong> and <strong class="source-inline">TurnOnPanAndZoom()</strong> methods, which toggle the <strong class="source-inline">canPan</strong> and <strong class="source-inline">canZoom</strong> <span>Boolean variables.</span><p class="calibre3">Add the following variable to the <span><strong class="source-inline">ShowHidePanels.cs</strong></span><span> class:</span></p><pre class="source-code">
CameraHandler cameraHandler;</pre></li> <li class="calibre14">Now, we need to initialize the <strong class="source-inline">cameraHandler</strong> variable. Add an <strong class="source-inline">Awake()</strong> method with the <span>following code:</span><pre class="source-code">
void Awake() {¶    cameraHandler = GetComponent&lt;CameraHandler&gt;();¶}</pre></li> <li class="calibre14">Now, add the following to the <strong class="source-inline">TogglePanel()</strong> method. This will call the <strong class="source-inline">TurnOffPanAndZoom()</strong> method whenever the game is paused or showing the inventory and call <strong class="source-inline">TurnOnPanAndZoom()</strong> whenever neither of the Panels <span>is visible:</span><pre class="source-code">
if (inventoryUp || pauseUp)
{
    cameraHandler.TurnOffPanAndZoom();
}
else
{
    cameraHandler.TurnOnPanAndZoom();
}</pre></li> </ol>
<p class="calibre3">You should <a id="_idIndexMarker439" class="pcalibre pcalibre1 calibre6"/>now have a fully functional pan and zoom that are disabled when menus <span>are visible!</span></p>
<p class="calibre3">This is almost the exact code I used in my game Barkeology, which you can find on the iOS app store: <a href="https://apps.apple.com/kn/app/barkeology/id1500348850" class="pcalibre pcalibre1 calibre6">https://apps.apple.com/kn/app/barkeology/id1500348850</a> So, if you do not have the ability to test your code on your mobile device, but would like to see it in action, you can view <span>it there.</span></p>
<p class="calibre3">While this marks the end of the chapter, we will continue to work in the Event System throughout this text, so you will see plenty <span>more examples.</span></p>
<h1 id="_idParaDest-148" class="calibre5"><a id="_idTextAnchor211" class="pcalibre pcalibre1 calibre6"/>Summary</h1>
<p class="calibre3">Now that we know how to utilize the Event System and program for UI elements, we can start making interactive and visual UI elements. We can also create UI that has its various properties change when <span>events occur.</span></p>
<p class="calibre3">We covered a lot in this chapter! We discussed how to access the properties of UI elements and how to work with the Event System. We also discussed how to use the Input Module. Now, you can create UI that responds to user inputs as well as UI that responds to events within <span>your game.</span></p>
<p class="calibre3"> In the next chapter, we will look at the other input system provided by Unity: the New Input System (yeah, that’s its <span>actual name).</span></p>
</div>
</div></body></html>