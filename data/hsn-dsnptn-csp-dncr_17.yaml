- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1 – Overview of OOP in .NET Core and C#
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 – .NET Core和C#中面向对象编程概述
- en: '**What do the terms late and early binding refer to?**'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**晚期和早期绑定这两个术语指的是什么？**'
- en: Early binding is established when the source code is compiled while late binding
    is established while the component is running.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码编译时建立早期绑定，而在组件运行时建立晚期绑定。
- en: '**Does C# support multiple inheritance?**'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**C#支持多重继承吗？**'
- en: No. The reasoning is that multiple inheritance leads to more complex source
    code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不。理由是多重继承会导致源代码更加复杂。
- en: '**In C#, what level of encapsulation could be used to prevent access to a class
    from outside of the library?**'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在C#中，可以使用什么级别的封装来防止从库外部访问类？**'
- en: The `internal` access modifier can be used to limit the visibility of a class
    to only within the library.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`internal` 访问修饰符可以用来限制类只对库内部可见。'
- en: '**What is the difference between aggregation and composition?**'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**聚合和组合有什么区别？**'
- en: Both are types of association and the easiest way to differentiate the two is
    by whether or not the classes involved can exist without being associated. In
    a composition association, the classes involved have a tight life cycle dependency.
    This implies that, when one class is deleted, the associated classes are also
    deleted.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种都是关联类型，区分这两种类型的最简单方法是看涉及的类是否可以在不关联的情况下存在。在组合关联中，涉及的类具有紧密的生命周期依赖性。这意味着，当一个类被删除时，相关的类也会被删除。
- en: '**Can interfaces contain properties? (This is a bit of a tricky question)**'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接口可以包含属性吗？（这是一个有点棘手的问题）**'
- en: It is possible for an interface to define properties, but as an interface does
    have a body...
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以定义属性，但作为一个接口，它确实有一个主体...
- en: '**Do dogs eat fish?**'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**狗吃鱼吗？**'
- en: Dogs are lovely but they eat most things they can get in their mouth.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 狗很可爱，但它们会吃掉它们嘴里能吃到的大部分东西。
- en: Chapter 2 – Modern Software Design Patterns and Principles
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 – 现代软件开发模式和原则
- en: '**In SOLID, what does the S stand for? What is meant by a responsibility?**'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在SOLID原则中，S代表什么？责任是什么意思？**'
- en: Single Responsibility Principle. Responsibility can be viewed as a reason for
    a change.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则。责任可以被视为改变的理由。
- en: '**What SDLC method is built around cycles: Waterfall or Agile?**'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**围绕周期构建的SDLC方法：瀑布还是敏捷？**'
- en: Agile is built around the concept of the development process being conducted
    in a collection of cycles.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷开发是基于开发过程以一系列周期进行的这一概念构建的。
- en: '**Is the decorator pattern a creational or structural pattern?**'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**装饰者模式是创建型模式还是结构型模式？**'
- en: The decorator pattern is a structural pattern that allows functionality to be
    divided between classes and is particularly useful to enhance classes at runtime.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式是一种结构模式，它允许将功能在类之间划分，并且特别适用于在运行时增强类。
- en: '**What does pub-sub integration stand for?**'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**pub-sub集成代表什么？**'
- en: Publish-Subscribe is a useful pattern where processes publish messages and other
    processes subscribe to receive the messages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅是一种有用的模式，其中进程发布消息，其他进程订阅以接收这些消息。
- en: Chapter 3 – Implementing Design Patterns – Basics Part 1
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章 – 实现设计模式 – 基础部分1
- en: '**In developing software for an organization, why is it sometimes difficult
    to determine requirements?**'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在为组织开发软件时，为什么有时很难确定需求？**'
- en: There are many challenges to developing software for an organization. An example
    would be that changes in the organization's industry could cause the current requirements
    to need to be altered.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为一个组织开发软件有许多挑战。一个例子是组织行业的变化可能导致当前需求需要改变。
- en: '**What are two advantages and disadvantages of waterfall software development
    versus agile software development?**'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**瀑布软件开发与敏捷软件开发相比，有哪些优点和缺点？**'
- en: Waterfall software development provides an advantage over agile software development
    as it is simpler to understand and implement. In some situations, where the complexity
    and size of the project is smaller, Waterfall Software Development could be a
    better option over Agile Software Development. Waterfall Software Development,
    though, does not handle change well and, by having a larger scope, has more chance
    of requirements changing before the project is completed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 水晶瀑布软件开发相对于敏捷软件开发具有优势，因为它更容易理解和实施。在某些情况下，如果项目的复杂性和规模较小，瀑布软件开发可能比敏捷软件开发更好。然而，瀑布软件开发处理变更的能力较差，并且由于范围较大，在项目完成之前，需求变更的可能性也更大。
- en: '**How does dependency injection help when writing unit tests?**'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**依赖注入在编写单元测试时是如何帮助的？**'
- en: By injecting dependencies into a class, a class becomes easier to test as the
    dependencies are clearly known and more easily accessible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将依赖项注入到类中，类变得更容易测试，因为依赖项是明确且易于访问的。
- en: '**Why is the following statement false? With TDD, you no longer need people
    to test a new software deployment.**'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么以下陈述是错误的？使用TDD后，你不再需要人们测试新的软件部署。**'
- en: Test-Driven Development helps to improve the quality of a solution by building
    a clear testing strategy into the software development life cycle. The tests defined,
    though, might not be complete, so there is still the need for additional resources
    to validate the delivered software.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发通过将清晰的测试策略构建到软件开发生命周期中，有助于提高解决方案的质量。然而，定义的测试可能并不完整，因此仍然需要额外的资源来验证交付的软件。
- en: Chapter 4 – Implementing Design Patterns – Basics Part 2
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 – 实现设计模式 – 基础部分2
- en: '**Provide an example to show why using a singleton would not be a good mechanism
    for limiting access to a shared resource?**'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提供一个示例来展示为什么使用单例不是限制对共享资源访问的好机制？**'
- en: A singleton intentionally creates a bottleneck in an application. It is also
    one of the first patterns developers learn to use and, because of this, it is
    often used in situations where limiting access to the shared resource is not required.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式故意在应用程序中创建瓶颈。它也是开发者最初学习的第一个模式之一，因此，它通常用于不需要限制对共享资源访问的情况。
- en: '**Is the following statement true? Why or why not? `ConcurrentDictionary` prevents
    items in the collection from being updated by more than one thread at a time.**'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以下陈述是否正确？为什么或为什么不正确？`ConcurrentDictionary`防止集合中的项目被一次更新多个线程。**'
- en: For many C# developers, realizing that `ConcurrentDictionary` does not prevent
    items in the collection from being updated by more than one thread at a time is
    a painful lesson. `ConcurrentDictionary` protects a shared dictionary from being
    accessed and modified concurrently.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多C#开发者来说，意识到`ConcurrentDictionary`不能防止一次更新多个线程是痛苦的一课。`ConcurrentDictionary`保护共享字典免受并发访问和修改。
- en: '**What is a race condition and why should it be avoided?**'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是竞态条件以及为什么应该避免它？**'
- en: A race condition is when the order of processing of multiple threads can culminate
    in different results.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件是指多个线程处理顺序的不同可能导致不同的结果。
- en: '**How does the factory pattern help simplify code?**'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工厂模式是如何帮助简化代码的？**'
- en: The factory pattern is an effective way to decouple the creation of objects
    within an application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是解耦应用程序内对象创建的有效方式。
- en: '**Do .NET Core applications require third-party IoC containers?**'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**.NET Core应用程序需要第三方IoC容器吗？**'
- en: .NET Core has a powerful Inversion of Control built into the framework. It can
    be enhanced when required by other IoC containers, but is not required.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core内置了强大的控制反转。当需要时，它可以由其他IoC容器增强，但不是必需的。
- en: Chapter 5 – Implementing Design Patterns – .NET Core
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 – 实现设计模式 – .NET Core
- en: '**If you are not sure what type of service lifetime to use, what type is it
    best to register a class as? Why?**'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果你不确定要使用哪种服务生命周期，最好将类注册为哪种类型？为什么？**'
- en: Transient lifetime services are created each time they are requested. The majority
    of classes should be lightweight, stateless services, so this is the best service
    lifetime to use.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 临时生命周期服务每次请求时都会创建。大多数类应该是轻量级、无状态的服务，因此这是最佳的服务生命周期。
- en: '**In .NET Core ASP .NET solutions, a scope is defined per web request or per
    session?**'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在.NET Core ASP .NET解决方案中，范围是针对每个Web请求还是每个会话定义的？**'
- en: A scope is per web request (connection).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 范围是针对每个Web请求（连接）的。
- en: '**Does registering a class as a Singleton in the .NET Core DI framework make
    it thread-safe?**'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在.NET Core DI框架中将类注册为Singleton会使它线程安全吗？**'
- en: No, the framework will provide the same instance for subsequent requests, but
    does not make a class thread-safe.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不，框架将为后续请求提供相同的实例，但不会使类成为线程安全的。
- en: '**Is it true that the .NET Core DI framework can only be replaced with other
    Microsoft-supplied DI frameworks?**'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**.NET Core DI框架是否只能用其他Microsoft提供的DI框架替换？**'
- en: Yes, there are many DI frameworks that can be used instead of the native DI
    framework.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，有许多可以替代原生DI框架的DI框架。
- en: Chapter 6 – Implementing Design Patterns for Web Applications – Part 1
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章 – 实现Web应用程序的设计模式 – 第一部分
- en: '**What is a web application?**'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是Web应用程序？**'
- en: It's a program that uses a web browser and can be accessible from anywhere if
    available over public network. This works on a client/server architecture and
    serves the client by taking an HTTP request and providing an HTTP response.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用Web浏览器并可以在公共网络上可用的情况下从任何地方访问的程序。它基于客户端/服务器架构，通过接收HTTP请求并提供HTTP响应来服务客户端。
- en: '**Craft a web application of your choice and depict a pictorial view of the
    working of web application.**'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**制作一个你选择的Web应用程序，并描绘Web应用程序的工作图景。**'
- en: Refer to the FlixOne application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 参考FlixOne应用程序。
- en: '**What is Inversion of Control?**'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是控制反转？**'
- en: '**Inversion of Control** (**IoC**) is a container to invert or delegate the
    control. It is based on the DI framework. .NET Core has a built-in IoC container.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制反转**（**IoC**）是一个用于反转或委派控制的容器。它基于DI框架。.NET Core内置了一个IoC容器。'
- en: '**What is the UI/Architectural pattern? Which pattern you would like to use
    and why?**'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是UI/架构模式？你希望使用哪种模式以及为什么？**'
- en: The UI Architectural pattern is designed to make a robust user interface to
    give user a better experience of the application. From the developer's point of
    view of point, MVC, MVP, and MVVM are the popular patterns.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: UI架构模式旨在设计一个健壮的用户界面，以提供更好的应用程序用户体验。从开发者的角度来看，MVC、MVP和MVVM是流行的模式。
- en: Chapter 7 – Implementing Design Patterns for Web Applications – Part 2
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 - 实现Web应用程序的设计模式 - 第2部分
- en: '**What are authentication and authorization?**'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是身份验证和授权？**'
- en: Authentication is a process in which a system verifies or identifies the incoming
    requests through credentials (generally a user ID and password). If the system
    finds that the provided credentials are wrong, then it notifies the user (generally
    via a message on the GUI screen) and terminates the authorization process.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证是一个系统通过凭证（通常是一个用户ID和密码）验证或识别传入请求的过程。如果系统发现提供的凭证是错误的，那么它会通知用户（通常通过GUI屏幕上的消息），并终止授权过程。
- en: Authorization always comes after authentication. This is a process that allows
    the authenticated user who raised the request to access resources or data after
    verifying that they have access to the specific resources or data
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 授权总是在身份验证之后。这是一个允许经过验证的用户在验证他们有权访问特定资源或数据后访问资源或数据的过程。
- en: '**Is it safe to use authentication at the first level of a request and then
    allow incoming requests for restricted areas?**'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在请求的第一级使用身份验证然后允许对受限区域的请求是否安全？**'
- en: This is not always safe. As developers, we should take all necessary steps to
    make our application more secure. After first a level request, the authentication,
    the system should also check resource-level permissions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不总是安全的。作为开发者，我们应该采取所有必要的步骤来使我们的应用程序更加安全。在一级请求之后，身份验证之后，系统还应检查资源级别的权限。
- en: '**How you will prove that authorization always comes after authentication?**'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你将如何证明授权总是在身份验证之后？**'
- en: In a simple scenario of a web application, it first validates the user by asking
    for login credentials and then authorizes the user as per role to access specific
    resource.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单的Web应用程序场景中，它首先通过要求登录凭证来验证用户，然后根据角色授权用户访问特定资源。
- en: '**What is Test-Driven Development and why do developers care about it?**'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是测试驱动开发以及为什么开发者关心它？**'
- en: Test-Driven Development is a way to make sure that code is tested; it is like
    testing code by writing code. TDD is also known as Red/Blue/Green concepts. Developers
    should follow it to make their code/program work without any error.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是一种确保代码被测试的方法；它就像通过编写代码来测试代码。TDD也被称为红/蓝/绿概念。开发者应该遵循它来确保他们的代码/程序在没有错误的情况下工作。
- en: '**Define TDD Katas. How does it help us to improve our TDD approach?**'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义TDD Katas。它是如何帮助我们改进我们的TDD方法的？**'
- en: 'TDD Katas are small scenarios or problems that help to learn to code by practice.
    You can take the example of Fizz Buzz Kata, where developers should apply coding
    to learn and practice TDD. If you want to practice TDD Katas, refer to this repository:
    [https://github.com/garora/TDD-Katas.](https://github.com/garora/TDD-Katas)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: TDD Katas是帮助通过实践学习编码的小场景或问题。你可以以Fizz Buzz Katas为例，开发者应该应用编码来学习和实践TDD。如果你想练习TDD
    Katas，请参考这个仓库：[https://github.com/garora/TDD-Katas.](https://github.com/garora/TDD-Katas)
- en: Chapter 8 – Concurrent Programming in .NET Core
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 - .NET Core中的并发编程
- en: '**What is concurrent programming?**'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是并发编程？**'
- en: Whenever things/tasks are happening at the same time, we say that tasks are
    happening concurrently. In our programming language, whenever any parts of our
    program run at the same time, it is concurrent programming.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当事物/任务同时发生时，我们说任务是在并发发生的。在我们的编程语言中，当我们的程序的任何部分同时运行时，这就是并发编程。
- en: '**How does true parallelism happen?**'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**真正的并行性是如何发生的？**'
- en: True parallelism is not possible on a single CPU machine because tasks are not
    switchable, as it has a single core. It only happens on a machine with multiple
    CPUs (multiple cores).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在单CPU机器上不可能实现真正的并行性，因为任务是不可切换的，因为它有一个单核。这只有在具有多个CPU（多个核心）的机器上才会发生。
- en: '**What is a race condition?**'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是竞争条件？**'
- en: The potential for more than one thread to access the same shared data and update
    it with unpredictable results can be referred to as a race condition.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程可能访问同一共享数据并更新它，导致不可预测的结果，这种情况可以称为竞争条件。
- en: '**Why should we use `ConcurrentDictionary`?**'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么我们应该使用`ConcurrentDictionary`？**'
- en: A concurrent dictionary is a thread-safe collection class and stores key-value
    pairs. This class has implementation for a lock statement and provides a thread-safe
    class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 并发字典是一个线程安全的集合类，存储键值对。这个类有锁语句的实现，并提供了一个线程安全的类。
- en: Chapter 9 – Functional Programming Practices – an Approach
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 – 函数式编程实践 – 一种方法
- en: '**What is functional programming?**'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是函数式编程？**'
- en: 'Functional programming is an approach to symbolic computation in the same way
    as we solve mathematical problems. Any functional programming is based on mathematical
    functions. Any functional programming style language works on solutions with two
    terms: what to solve and how to solve?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种符号计算的方法，就像我们解决数学问题一样。任何函数式编程都基于数学函数。任何函数式编程风格的语言都是通过两个术语来工作的：要解决的问题和如何解决问题？
- en: '**What is referential transparency in functional programming?**'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**函数式编程中的引用透明性是什么？**'
- en: In functional programs, once we define the variables, they do not change their
    value throughout the program. As functional programs do not have assignment statements,
    if we need to store value, there is no alternative; instead, we define new variables.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式程序中，一旦我们定义了变量，它们在整个程序中不会改变它们的值。由于函数式程序没有赋值语句，如果我们需要存储值，就没有替代方案；相反，我们定义新的变量。
- en: '**What is `Pure` function?**'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是`Pure`函数？**'
- en: 'The `Pure` functions are the ones that strengthen functional programming by
    saying that they are pure. These functions work on two conditions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pure` 函数通过声明它们是纯的来加强函数式编程。这些函数满足两个条件：'
- en: The end result/output will always remain the same for the provided parameters.
  id: totrans-89
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于提供的参数，最终结果/输出始终是相同的。
- en: These will not impact the behavior of the program or the execution path of the
    application, even if they are being called a hundred times.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些不会影响程序的行为或应用的执行路径，即使它们被调用了一百次。
- en: Chapter 10 – Reactive Programming Patterns and Techniques
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 – 反应式编程模式和技巧
- en: '**What is a stream?**'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是流？**'
- en: 'A sequence of events is called a stream. A stream can emit three things: a
    value, an error, and a signal for completion.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 事件序列被称为流。一个流可以发出三个东西：一个值、一个错误和一个完成信号。
- en: '**What are reactive properties?**'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是反应式属性？**'
- en: Reactive properties are binding properties that react when an event triggers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式属性是当事件触发时做出反应的绑定属性。
- en: '**What is a reactive system?**'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是反应式系统？**'
- en: 'On the basis of the Reactive Manifesto, we can conclude that reactive systems
    are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 基于反应式宣言，我们可以得出结论，反应式系统如下：
- en: '**Responsive**: Reactive systems are event-based design systems because of
    this design approach; these systems are quick to respond to any request in a short
    time.'
  id: totrans-98
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：由于这种设计方法，反应式系统是事件驱动的设计系统；这些系统能够快速响应任何请求。'
- en: '**Scalable**: Reactive systems are reactive in nature. These systems can react
    to change the scalability rate by expanding or reducing the allocated resources.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：反应式系统在本质上具有反应性。这些系统可以通过扩展或减少分配的资源来改变可扩展性速率。'
- en: '**Resilient**: A resilient system is one that would not stop, even if there
    is any failure/exception. Reactive systems are designed in such a way that, despite
    any exception or failure, the system will never die; it remains working.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：一个弹性的系统是指即使在出现任何故障/异常的情况下也不会停止的系统。反应式系统被设计成这样，即尽管有任何异常或故障，系统也不会死亡；它仍然在运行。'
- en: '**Message-based**: Any data of an item represents a message and can be sent
    to a specific destination. When a message or data has arrived at a given state,
    an event that is a signal is emitted to notify that the message has been received.
    Reactive systems rely on this message-passing.'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于消息的**：任何项目的数据都代表一个消息，并且可以被发送到特定的目的地。当一个消息或数据到达给定的状态时，一个作为信号的事件被发出以通知消息已被接收。响应式系统依赖于这种消息传递。'
- en: '**What is meant by merging two reactive streams?**'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并两个响应式流是什么意思？**'
- en: Merging two reactive steams is actually combining elements of two similar or
    different reactive streams into a new reactive stream. For example, if you have
    `stream1`, and `stream2` then `stream3 = stream1.merge(stream2)`, but the sequence
    of `stream3` would not be in order.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 合并两个响应式流实际上是将两个相似或不同的响应式流的元素组合成一个新的响应式流。例如，如果你有`stream1`和`stream2`，那么`stream3
    = stream1.merge(stream2)`，但`stream3`的序列将不会有序。
- en: '**What is the MVVM pattern?**'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是MVVM模式？**'
- en: '**Model-View-ViewModel** (**MVVM**) is one of the variations of **Model-View-Controller**
    (**MVC**) to meet the modern UI development approach, where UI development is
    the core responsibility of designer/UI-developers, rather than application developers.
    In this approach of development, a designer who is more of a graphical enthusiast
    and is focused on making the user interface more attractive may or may not bother
    about the development part of the application. Generally, designers (UI persons)
    use various tools to make the user interface more attractive. The MVVM is defined
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-视图模型（MVVM**）是**模型-视图-控制器（MVC**）的变体之一，以满足现代UI开发方法，其中UI开发是设计师/UI开发者的核心责任，而不是应用程序开发者的责任。在这种开发方法中，一个更多的是图形爱好者并且专注于使用户界面更吸引人的设计师可能或可能不会关心应用程序的开发部分。通常，设计师（UI人员）使用各种工具来使用户界面更吸引人。MVVM被定义为如下：'
- en: '**Model**: This is also called as a domain object and it holds data only; there
    is no business logic, validations, and so on.'
  id: totrans-106
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这也被称为领域对象，它只持有数据；没有业务逻辑、验证等。'
- en: '**View**: This is a representation of data for the end user.'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这是为最终用户表示数据的方式。'
- en: '**View Model**: This separates View and Model; its main responsibility is to
    serve end users better stuff.'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**：它将视图和模型分开；其主要责任是更好地服务最终用户。'
- en: Chapter 11 – Advanced Database Design and Application Techniques
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 - 高级数据库设计和应用技术
- en: '**What is a ledger-style database?**'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是账本式数据库？**'
- en: This database is meant to insert operations only; there are no updates. Then,
    you create a view that aggregates the inserts together.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据库旨在仅进行插入操作；没有更新。然后，你创建一个视图来聚合这些插入操作。
- en: '**What is CQRS?**'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CQRS是什么？**'
- en: Command Query Responsibility Segregation is a pattern that segregates the responsibilities
    between Query (to inserts) and Commands (to updates).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 命令查询责任分离（Command Query Responsibility Segregation）是一种模式，它将查询（用于插入）和命令（用于更新）之间的责任进行分离。
- en: '**When should you use CQRS?**'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**何时应该使用CQRS？**'
- en: CQRS can be a good pattern to apply for task-based or event-driven systems,
    especially when the solution is composed of multiple applications and not a single
    monolithic website or application. It is **a pattern and not an architecture**,
    so it should be applied in specific cases and not in all business scenarios
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS可以是一个适用于基于任务或事件驱动系统的良好模式，特别是当解决方案由多个应用程序组成而不是一个单一的单体网站或应用程序时。它是一个**模式而不是架构**，因此应该根据具体情况应用，而不是在所有业务场景中应用。
- en: Chapter 12 – Coding for the Cloud
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 - 云端编码
- en: '**Is this a true statement? Most patterns have been developed recently and
    only apply to cloud-based applications.**'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这是一个正确的陈述吗？大多数模式都是最近开发的，并且仅适用于基于云的应用程序。**'
- en: No, this is not true. Patterns have been evolving as software development changes
    but many of the core patterns have existed for decades.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这不是真的。随着软件开发的变化，模式一直在演变，但许多核心模式已经存在了几十年。
- en: '**What does an ESB stand for? What type of architecture can it be used in:
    EDA, SOA, or monolithic?**'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ESB代表什么？它可以用在哪种架构中：事件驱动架构（EDA）、面向服务的架构（SOA）还是单体架构？**'
- en: It stands for Enterprise Service Bus. It can be used effectively in event-driven
    architecture and service-oriented architecture.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它代表企业服务总线。它可以在事件驱动架构和面向服务的架构中有效地使用。
- en: '**Is queue-based load leveling is primarily used for DevOps, scalability, or
    availability?**'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于队列的负载均衡主要用于DevOps、可扩展性还是可用性？**'
- en: Availability. Queue-based load leveling primarily used to handle large fluctuations
    in load by acting as a buffer to reduce the chance of an application becoming
    unavailable.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性。基于队列的负载均衡主要用于通过充当缓冲区来处理负载的大幅波动，以减少应用程序不可用的可能性。
- en: '**What are the benefits of CI/CD? Would it be more beneficial in a large number
    of globally dispersed teams or a single small team of collocated developers?**'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CI/CD的好处是什么？它对大量全球分散的团队或单个小型本地化开发团队更有益吗？**'
- en: In general, CI/CD helps to identify issues early in the development life cycle
    by frequently performing merges and deployments. Larger, more complex solutions,
    tend to show the benefits more than smaller, simpler solutions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，CI/CD通过频繁执行合并和部署来帮助在开发生命周期的早期识别问题。较大的、更复杂的解决方案往往比较小的、更简单的解决方案显示出更多的优势。
- en: '**In a website following static content hosting, does a browser retrieve images
    and static content directly through a CDN or does the web application retrieve
    the information on behalf of the browser?**'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在遵循静态内容托管的网站上，浏览器是否直接通过CDN检索图像和静态内容，还是Web应用程序代表浏览器检索信息？**'
- en: A content delivery network can be used to improve performance and availability
    by caching static resources in multiple data centers, allowing for a browser to
    retrieve content directly from the closest data center.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 内容分发网络可以通过在多个数据中心缓存静态资源来提高性能和可用性，允许浏览器直接从最近的数据中心检索内容。
- en: Appendix A – Miscellaneous Best Practices
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A – 其他最佳实践
- en: '**What is a practice? Give a few examples from our routine/daily life.**'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是实践？请从我们的日常/日常生活中举几个例子。**'
- en: 'A practice may be one or more routine activities. To learn to drive, we should
    practice our driving. A practice is an activity that is not required to be memorized.
    There are a lot of examples of practice from our daily life: eating while watching
    TV shows, and so on. It does not break your rhythm to eat anything while you''re
    watching your favorite TV show.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实践可能是一到多个常规活动。为了学习驾驶，我们应该练习驾驶。实践是一种不需要记忆的活动。我们的日常生活中有很多实践例子：边看电视节目边吃饭，等等。在你观看你最喜欢的电视节目时吃任何东西都不会打破你的节奏。
- en: '**We can achieve a specific coding skill with practice. Explain this.**'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们可以通过练习获得特定的编码技能。请解释这一点。**'
- en: Yes, we can achieve a specific coding skill with practice. The practice needs
    attention and consistency. For example, you want to learn Test-Driven Development.
    To do so, you need to learn it first. You can learn it by practicing TDD-Katas.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以通过练习获得特定的编码技能。这种练习需要关注和一致性。例如，你想学习测试驱动开发。为此，你需要先学习它。你可以通过练习TDD-Katas来学习。
- en: '**What is Test-Driven Development and how does it help developers to practice?**'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是测试驱动开发以及它如何帮助开发者进行实践？**'
- en: Test-Driven Development is a way to make sure that code is tested; it is like
    we are testing code by writing code. TDD is also known as Red/Blue/Green concepts.
    Developers should follow it to make their code/program work without any error.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是一种确保代码被测试的方法；它就像我们通过编写代码来测试代码一样。TDD也被称为红/蓝/绿概念。开发者应该遵循它，以确保他们的代码/程序在没有错误的情况下工作。
