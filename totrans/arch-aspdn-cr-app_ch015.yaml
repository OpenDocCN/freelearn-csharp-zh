- en: 14 Layering and Clean Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 分层与清洁架构
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的 Discord 书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到“EARLY
    ACCESS SUBSCRIPTION”）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file74.png)In this chapter,
    we explore the inherent concepts behind layering. Layering is a popular way of
    organizing computer systems by encapsulating major concerns into layers. Those
    concerns are related to a computer vocation, such as data access, instead of a
    business concern, such as inventory. Understanding the concepts behind layering
    is essential, as other concepts were born from layers and are very common.We start
    this chapter by exploring the initial ideas behind layering. Then, we explore
    alternatives that can help us solve different problems. We use anemic and rich
    models and expose their pros ** and cons. Finally, we quickly explore **Clean
    Architecture**, an evolution of layering, and a way to organize layers.This chapter
    lays out the evolution of layering, starting with basic, restrictive, and even
    flawed techniques, then we gradually move toward more modern patterns. This journey
    should help you understand the concepts and practices behind layering, giving
    you a stronger understanding than just learning one way of doing things. The key
    is to understand.In this chapter, we cover the following topics:**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![二维码描述自动生成](img/file74.png)'
- en: '***   Introducing layering'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '***   介绍分层'
- en: Responsibilities of the common layers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见层的职责
- en: Abstract layers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象层
- en: Sharing a model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享模型
- en: Clean Architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁架构
- en: Implementing layering in real life
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实生活中实现分层
- en: Let’s get started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Introducing layering
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍分层
- en: Now that we’ve explored a few design patterns and played with ASP.NET Core,
    it is time to jump into layering. In most computer systems, there are layers.
    Why? Because it is an efficient way to partition and organize units of logic together.
    We could conceptually represent layers as horizontal software segments, each encapsulating
    a concern.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了一些设计模式并玩转了 ASP.NET Core，是时候深入分层了。在大多数计算机系统中，都存在分层。为什么？因为它是一种高效地将逻辑单元组织在一起的方法。我们可以从概念上将分层表示为水平软件段，每个段封装一个关注点。
- en: Classic layering model
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经典分层模型
- en: 'Let’s start by examining a classic three-layer application design:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查一个经典的三层应用设计开始：
- en: '![Figure 14.1: A classic three-layer application design](img/file75.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1：经典的分层应用设计](img/file75.png)'
- en: 'Figure 14.1: A classic three-layer application design'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：经典的分层应用设计
- en: 'The **presentation layer** represents any user interface that a user can interact
    with to reach the **domain**. It could be an ASP.NET Core web application. Anything
    from WPF to WinForms to Android could be a valid non-web presentation layer alternative.The
    **domain layer** represents the core logic driven by the business rules; this
    solves the application’s problem. The domain layer is also called the **business
    logic layer** (**BLL**).The **data layer** represents the bridge between the data
    and the application. The layer can store the data in a SQL Server database, a
    NoSQL database hosted in the cloud, a mix of many data sources, or anything else
    that fits the business needs. The data layer is also called the **data access
    layer** (**DAL**) and the **persistence layer**.Let’s jump to an example. Given
    that a user has been authenticated and authorized, here is what happens when they
    want to create a book in a bookstore application built using those three layers:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示层**代表用户可以与之交互以到达**领域**的任何用户界面。它可能是一个ASP.NET Core Web应用程序。从WPF到WinForms到Android，任何东西都可以是一个有效的非Web表示层替代方案。**领域层**代表由业务规则驱动的核心逻辑；这解决了应用程序的问题。领域层也被称为**业务逻辑层**（**BLL**）。**数据层**代表数据与应用程序之间的桥梁。该层可以将数据存储在SQL
    Server数据库中、托管在云中的NoSQL数据库中、多个数据源混合或任何适合业务需求的东西。数据层也被称为**数据访问层**（**DAL**）和**持久层**。让我们跳到一个例子。假设用户已经通过认证和授权，当他们在使用这些三层构建的书店应用程序中创建一本书时，会发生以下情况：'
- en: The user requests the page by sending a `GET` request to the server.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户通过向服务器发送`GET`请求来请求页面。
- en: The server handles that `GET` request (**presentation layer**) and then returns
    the page to the user.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器处理那个`GET`请求（**表示层**），然后将其返回给用户。
- en: The user fills out the form and sends a `POST` request to the server.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户填写表单并向服务器发送`POST`请求。
- en: The server handles the `POST` request (**presentation layer**) and then sends
    it to the **domain layer** for processing.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器处理`POST`请求（**表示层**），然后将其发送到**领域层**进行处理。
- en: The **domain layer** executes the logic required to create a book, then tells
    the **data layer** to persist that data.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**领域层**执行创建书籍所需的逻辑，然后告诉**数据层**持久化这些数据。'
- en: After unrolling to the presentation layer, the server returns the appropriate
    response to the user, most likely a page containing a list of books and a message
    saying the operation was successful.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开到表示层后，服务器将返回适当的响应给用户，这很可能是包含书籍列表和表示操作成功的消息的页面。
- en: 'Following a classic layering architecture, a layer can only talk to the next
    layer in the stack—**presentation** talks to **domain**, which talks to **data**,
    and so on. The important part is that **each layer must be independent and isolated
    to limit tight coupling**.In this classic layering model, each layer should own
    its **model**. For example, the presentation layer should not send its **view
    models** to the **domain** layer; only **domain objects** should be used there.
    The opposite is also true: since the **domain** returns its own objects to the
    **presentation layer**, the **presentation layer** should not leak them to its
    consumers but organize the required information into **view models** or **DTO**
    instead.Here is a visual example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 按照经典分层架构，一个层只能与堆栈中的下一层通信——**表示层**与**领域层**通信，而**领域层**与**数据层**通信，依此类推。重要的是**每一层都必须是独立和隔离的，以限制紧密耦合**。在这个经典分层模型中，每一层应该拥有自己的**模型**。例如，表示层不应该将其**视图模型**发送到**领域层**；那里应该只使用**领域对象**。反之亦然：由于**领域层**将其自己的对象返回给**表示层**，因此**表示层**不应该将其泄露给消费者，而应该将所需的信息组织成**视图模型**或**DTO**。以下是一个视觉示例：
- en: '![Figure 14.2: Diagram representing how the layers interact with one another](img/file76.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2：表示层之间相互作用的图示](img/file76.png)'
- en: 'Figure 14.2: Diagram representing how the layers interact with one another'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2：表示层之间相互作用的图示
- en: 'Even if three is probably the most popular number of layers, we can create
    as many as we need; we are not limited to three layers.Let’s examine the advantages
    and disadvantages of classic layering, starting with the advantages:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使三层可能是最受欢迎的层数，我们也可以创建我们需要的任何数量的层；我们并不局限于三层。让我们从优点开始，考察经典分层结构的优缺点：
- en: Knowing the purpose of a layer makes it easy to understand. For example, guessing
    that the data layer components read or write some data somewhere is easy.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解层的目的是很容易理解的。例如，猜测数据层组件在某个地方读取或写入数据是很容易的。
- en: It creates a cohesive unit built around a single concern. For example, our **data
    layer** should not render any user interface but stick to accessing data.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个围绕单一关注点构建的统一单元。例如，我们的**数据层**不应该渲染任何用户界面，而应坚持访问数据。
- en: It allows us to decouple the layer from the rest of the system (the other layers).
    You can isolate and work within a layer with limited to no knowledge of the others.
    For example, suppose you are tasked with optimizing a query in a data access layer.
    In that case, you don’t need to know about the user interface that eventually
    displays that data to a user. You only need to focus on that element, optimize
    it, test it in isolation, and then ship the layer or redeploy the application.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许我们将层与系统其余部分（其他层）解耦。你可以在对其他层知之甚少的情况下隔离并在该层内工作。例如，假设你被分配优化数据访问层中的查询任务。在这种情况下，你不需要了解最终将数据显示给用户的用户界面。你只需要专注于该元素，优化它，单独测试它，然后发布该层或重新部署应用程序。
- en: Like any other isolated unit, it should be possible to reuse a layer. For example,
    we could reuse our **data access layer** in another application that needs to
    query the same database for a different purpose (a different **domain layer**).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像任何其他隔离单元一样，应该能够重用层。例如，我们可以在需要查询相同数据库但用于不同目的的另一个应用程序中重用我们的**数据访问层**（一个不同的**领域层**）。
- en: '**TIP**'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some layers are theoretically easier to reuse than others, and reusability could
    add more or less value, depending on the software you are building. I have never
    seen a layer being integrally reused in practice, and I’ve rarely heard or read
    about such a situation—each time rather ends in a not-so-reusable-after-all situation.
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些层在理论上比其他层更容易重用，可重用性可能增加或减少价值，具体取决于你正在构建的软件。我在实践中从未见过一个层被完整重用，我也很少听说或读到这样的情况——每次通常都以最终不太可重用的情况告终。
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Based on my experience, I would strongly suggest not over-aiming at reusability
    when it is not a precise specification that adds value to your application. Limiting
    your overengineering endeavors could save you and your employers a lot of time
    and money. We must not forget that our job is to deliver value.
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 根据我的经验，我强烈建议不要在不是精确规范且能为你的应用程序增加价值的情况下过度追求可重用性。限制你的过度工程化努力可以为你和你的雇主节省大量时间和金钱。我们不应忘记，我们的工作是交付价值。
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As a rule of thumb, do what needs to be done, not more, but do it well.
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为一项经验法则，做你需要做的事情，不要多做，但要做好。
- en: 'OK, now, let’s look at the drawbacks:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在，让我们看看其缺点：
- en: By splitting your software horizontally into layers, each feature crosses all
    of the layers. This often leads to cascading changes between layers. For example,
    if we decide to add a field to our bookstore database, we would need to update
    the database, the code that accesses it (**data layer**), the business logic (**domain
    layer**), and the user interface (**presentation layer**). With volatile specs
    or low-budget projects, this can become painful!
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将软件水平拆分为层，每个功能都会跨越所有层。这通常会导致层之间的级联更改。例如，如果我们决定向我们的书店数据库添加一个字段，我们就需要更新数据库、访问它的代码（**数据层**）、业务逻辑（**领域层**）和用户界面（**表示层**）。在规格不稳定或预算有限的项目中，这可能会变得痛苦！
- en: Implementing a full-stack feature is more challenging for newcomers because
    it crosses all layers.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于新手来说，实现全栈功能更具挑战性，因为它跨越了所有层。
- en: Using layering often leads to or is caused by a separation of responsibilities
    between the staff. For example, DBAs manage the data layer, backend devs manage
    the domain layer, and frontend devs manage the presentation layer, leading to
    coordination and knowledge-sharing issues.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分层通常会导致或是由人员之间的职责分离引起的。例如，数据库管理员管理数据层，后端开发者管理领域层，前端开发者管理表示层，导致协调和知识共享问题。
- en: Since a layer directly depends on the layer under it, dependency injection is
    impossible without introducing an **abstraction layer** or referencing lower layers
    from the **presentation layer**. For example, if the **domain layer** depends
    on the **data layer**, changing the data layer would require rewriting all of
    that coupling from the **domain** to the **data**.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于层直接依赖于其下的层，没有引入**抽象层**或从**表示层**引用较低层，依赖注入是不可能的。例如，如果**领域层**依赖于**数据层**，修改数据层将需要重写从**领域**到**数据**的所有耦合。
- en: Since each layer owns its entities, the more layers you add, the more copies
    there are of the entities, leading to minor performance loss and a higher maintenance
    cost. For example, the **presentation layer** copies a **DTO** to a **domain object**.
    Then, the **domain layer** copies it to a **data object**. Finally, the **data
    layer** translates it into SQL to persist it into a **database** (SQL Server,
    for example). The opposite is also true when reading from the database.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个层都拥有自己的实体，你添加的层越多，实体的副本就越多，导致轻微的性能损失和更高的维护成本。例如，**表示层**将一个**DTO**复制到一个**领域对象**。然后，**领域层**将其复制到一个**数据对象**。最后，**数据层**将其转换为SQL以将其持久化到**数据库**（例如SQL
    Server）。当从数据库读取时，情况也是相反的。
- en: We explore ways to combat some of those drawbacks later.I strongly recommend
    that you don’t do what we just explored. It is an old, more basic way of doing
    layering. We are looking at multiple improvements to this layering system in this
    chapter, so keep reading before jumping to a conclusion. I decided to explore
    layering from the beginning in case you have to work with that kind of application.
    Furthermore, studying its chronological evolution, fixing some flaws, and adding
    options should help you understand the concepts instead of just knowing a single
    way of doing things. Understanding the patterns is the key to software architecture,
    not just learning how to apply them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面探讨一些克服这些缺点的方法。我强烈建议你不要做我们刚刚探讨的事情。这是一种过时、更基本的分层方式。我们在本章中正在探讨对这个分层系统的多个改进，所以请在得出结论之前继续阅读。我决定从分层开始探索，以防你不得不与那种类型的应用程序一起工作。此外，研究其时间顺序演变、修复一些缺陷和添加选项应该有助于你理解概念，而不仅仅是知道做事的一种方式。理解模式是软件架构的关键，而不仅仅是学习如何应用它们。
- en: Splitting the layers
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分割层
- en: 'Now that we’ve discussed layers and seen them as big horizontal slices of responsibilities,
    we can organize our applications more granularly by splitting those big slices
    vertically, creating multiple smaller layers. This can help us organize applications
    by features or by bounding context, and it could also allow us to compose various
    user interfaces using the same building blocks, which would be easier than reusing
    colossal-size layers.Here is a conceptual representation of this idea:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了层，并将它们视为职责的大块水平切片，我们可以通过垂直分割这些大块来更细致地组织我们的应用程序，创建多个较小的层。这可以帮助我们按功能或边界上下文组织应用程序，也可能使我们能够使用相同的构建块组合各种用户界面，这将比重用巨大尺寸的层更容易。以下是这个想法的概念表示：
- en: '![Figure 14.3: Organizing multiple applications using smaller partially shared
    layers](img/file77.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3：使用较小的部分共享层组织多个应用程序](img/file77.png)'
- en: 'Figure 14.3: Organizing multiple applications using smaller partially shared
    layers'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3：使用较小的部分共享层组织多个应用程序
- en: 'We can split an application into multiple features (vertically) and divide
    each into layers (horizontally). Based on the previous diagram, we named those
    features as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个应用程序分割成多个功能（垂直分割）并将每个分割成层（水平分割）。根据之前的图，我们这样命名这些功能：
- en: Inventory management
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存管理
- en: Online shopping
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线购物
- en: Others
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他
- en: 'So, we can bring in the online shopping domain and data layers to our Shopping
    web API without bringing everything else with it. Moreover, we can bring the online
    shopping domain layer to the mobile app and swap its data layer for another that
    talks to the web API.We could also use our web API as a plain and simple data
    access application with different logic attached to it while keeping the shopping
    data layer underneath.We could end up with the following recomposed applications
    (this is just one possible outcome):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在不带来其他一切的情况下，将在线购物领域和数据层引入我们的购物Web API。此外，我们还可以将在线购物领域层引入移动应用，并用另一个与Web
    API通信的数据层来替换它。我们还可以将我们的Web API作为一个简单的数据访问应用程序使用，同时在其上附加不同的逻辑，而保持购物数据层在下面。我们最终可能会得到以下重新组合的应用程序（这只是可能的结果之一）：
- en: '![Figure 14.4: Organizing multiple applications using smaller partially shared
    layers](img/file78.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4：使用较小的部分共享层组织多个应用程序](img/file78.png)'
- en: 'Figure 14.4: Organizing multiple applications using smaller partially shared
    layers'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：使用较小的部分共享层组织多个应用程序
- en: These are just examples of what we can conceptually do with layers. However,
    the most important thing to remember is not how the diagrams are laid out but
    the specifications of the applications you are building. Only those specs and
    good analyses can help you create the best possible design for that exact problem.
    I used a hypothetical shopping example here, but it could have been anything.Splitting
    huge horizontal slices vertically makes each piece easier to reuse and share.
    This improvement can yield interesting results, especially if you have multiple
    frontend apps or plan to migrate away from a monolith.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '这些只是我们可以在概念上用层做的事情的例子。然而，最重要的不是图是如何布局的，而是你正在构建的应用程序的规范。只有那些规范和良好的分析才能帮助你为那个特定问题创建最佳可能的设计。我在这里使用了一个假设的购物例子，但它可以是任何东西。将巨大的水平切片垂直分割使得每个部分更容易重用和共享。这种改进可以产生有趣的结果，特别是如果你有多个前端应用程序或计划迁移离开单体。 '
- en: A **monolithic application** (or monolith) is a program deployed as a single
    integrated piece with low modularity. A monolith can leverage layers or not. People
    often compare monolithic applications to microservices applications because they
    are antipodes. We explore microservices in *Chapter 19*, *Introduction to Microservices
    Architecture*, and monoliths in *Chapter 20*, *Modular Monoliths*.
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**单体应用**（或单体）是一个以单个集成块部署的程序，具有低模块化。单体可以采用层或不需要层。人们经常将单体应用与微服务应用进行比较，因为它们是相反的。我们在第19章“微服务架构简介”中探讨了微服务，在第20章“模块化单体”中探讨了单体。'
- en: Layers versus tiers versus assemblies
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层与层与组件
- en: 'So far in this chapter, we have been talking about layers without talking about
    making them into code. Before jumping into that subject, I’d like to discuss **tiers**.
    You may have seen the term **3-tier architecture** somewhere before or heard people
    talking about **tiers** and **layers**, possibly interchanging them in the same
    context as synonyms. However, they are not the same.In a nutshell:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们一直在谈论层，而没有谈论将它们转化为代码。在深入这个主题之前，我想讨论一下**层**。你可能之前在某个地方见过**三层架构**这个术语，或者听到人们谈论**层**和**层**，可能在同一语境中将它们作为同义词互换。然而，它们并不相同。简而言之：
- en: '**Tiers** are **physical**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层**是**物理的**'
- en: '**Layers** are **logical**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层**是**逻辑的**'
- en: What is a Tier?
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 什么是层级？
- en: We can deploy each **tier** on its own machine. For example, you could have
    a database server, a server hosting your web API that contains the business logic
    (the **domain**), and another server that serves an Angular application (**presentation**);
    these are three tiers (three distinct machines), and each **tier** can scale independently.We
    look at layers next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将每个**层**部署在其自己的机器上。例如，你可以有一个数据库服务器，一个托管你的Web API的服务器，其中包含业务逻辑（**领域**），以及另一个服务器，它托管一个Angular应用程序（**表示**）；这些是三个层（三个不同的机器），每个**层**都可以独立扩展。我们接下来看看层。
- en: What is a Layer?
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 什么是层？
- en: 'On the other hand, each **layer** is only the logical organization of code,
    with concerns organized and divided in a layered fashion. For example, you may
    create one or more projects in Visual Studio and organize your code into three
    layers. For example, a Razor Pages application depends on a business logic layer
    that depends on a data access layer. When you deploy that application, all these
    layers, including the database, are deployed together on the same server. This
    would be one tier and three layers. Of course, nowadays, chances are you have
    a cloud database somewhere, which adds a second tier to that architecture: the
    application tier (which still has three layers) and database tier.Now that we’ve
    discussed **layers** and **tiers**, let’s look at a **layer** versus an **assembly**.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，每个**层**只是代码的逻辑组织，关注点以分层的方式组织和划分。例如，你可以在Visual Studio中创建一个或多个项目，并将你的代码组织成三层。例如，一个Razor
    Pages应用程序依赖于一个业务逻辑层，该层依赖于一个数据访问层。当你部署该应用程序时，所有这些层，包括数据库，都部署在同一台服务器上。这将是一个层级和三个层。当然，如今，你可能在某个地方有一个云数据库，这将为该架构增加第二个层级：应用程序层（其中仍然有三个层）和数据库层。现在我们已经讨论了**层**和**层**，让我们看看**层**与**组件**之间的区别。
- en: What is an assembly?
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 什么是组件？
- en: '**Assemblies** are commonly compiled into `.dll` or `.exe` files; you can compile
    and consume them directly. In most cases, each project of a Visual Studio solution
    gets compiled into an assembly. You can also deploy them as NuGet packages and
    consume them from [nuget.org](https://www.nuget.org) or a custom NuGet repository
    of your choosing. But there is no one-to-one relationship between a layer and
    an assembly or a tier and an assembly; assemblies are only consumable units of
    compiled code: a library or a program.Moreover, you do not need to split your
    layers into different assemblies; you can have your three layers residing in the
    same assembly. It can be easier to create undesirable coupling this way, with
    all of the code being in the same project, but it is a viable option with some
    rigor, rules, and conventions. Moving each layer to an assembly does not necessarily
    improve the application; the code inside each layer or assembly can become mixed
    up and coupled with other system parts.Don’t get me wrong: you can create an assembly
    per layer; I even encourage you to do so in most cases, but doing so does not
    mean the layers are not tightly coupled. A layer is simply a logical unit of organization,
    so each contributor’s responsibility is to ensure the layer’s code stays healthy.Furthermore,
    having multiple assemblies let us deploy them to one or more machines, potentially
    different machines, leading to multiple tiers.Let’s now look at the responsibilities
    of the most common layers.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**通常被编译成`.dll`或`.exe`文件；你可以直接编译和消费它们。在大多数情况下，Visual Studio解决方案中的每个项目都会被编译成一个组件。你还可以将它们作为NuGet包部署，并从[nuget.org](https://www.nuget.org)或你选择的自定义NuGet仓库中消费。但是，层与组件或层与层之间没有一对一的关系；组件只是可消费的编译代码单元：一个库或一个程序。此外，你不需要将你的层分割成不同的组件；你可以让三个层都驻留在同一个组件中。这样可能会更容易产生不希望的耦合，因为所有代码都在同一个项目中，但只要有一些严谨性、规则和约定，这也是一个可行的选项。将每个层移动到组件中并不一定能够提高应用程序；每个层或组件内部的代码可能会变得混乱，并与系统的其他部分耦合。请别误会我的意思：你可以为每个层创建一个组件；我甚至在大多数情况下鼓励你这样做，但这并不意味着层之间没有紧密耦合。层只是一个逻辑组织单元，因此每个贡献者的责任是确保层的代码保持健康。此外，拥有多个组件让我们可以将它们部署到一台或多台机器上，可能是不同的机器，从而形成多个层。现在，让我们看看最常见层的职责。'
- en: Responsibilities of the common layers
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见层的职责
- en: In this section, we explore the most commonly used layers in more depth. We
    do not dig too deep into each one, but the overview should help you understand
    the essential ideas behind layering.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地探讨最常用的层。我们不会对每一层都进行深入挖掘，但概述应该能帮助你理解分层背后的基本思想。
- en: Presentation
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展示
- en: 'The **presentation layer** is probably the easiest layer to understand because
    it is the only one we can see: the user interface. However, the presentation layer
    can also be the data contracts in case of a REST, OData, GraphQL, or other types
    of web service. The presentation layer is what the user uses to access your program.
    As another example, a CLI program can be a presentation layer. You write commands
    in a terminal, and the CLI dispatches them to its domain layer, executing the
    required business logic.The key to a maintainable presentation layer is to keep
    it as focused on displaying the user interface as possible with as little business
    logic as possible.Next, we look at the **domain layer** to see where these calls
    go.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**展示层**可能是最容易理解的一层，因为它是我们唯一能看到的部分：用户界面。然而，在REST、OData、GraphQL或其他类型的网络服务的情况下，展示层也可以是数据合约。展示层是用户用来访问你的程序的部分。例如，一个命令行界面（CLI）程序也可以是一个展示层。你可以在终端中输入命令，CLI会将它们分发给其领域层，执行所需的企业逻辑。保持展示层可维护的关键是尽可能地将它集中在显示用户界面，尽可能少地包含业务逻辑。接下来，我们将查看**领域层**，看看这些调用会去哪里。'
- en: Domain
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 域
- en: 'The **domain layer** is where the software’s value resides and where most of
    the complexity lies. The **domain layer** is the home of your business logic rules.It
    is easier to sell a **user interface** than a **domain layer** since users connect
    to the domain through the presentation. However, it is important to remember that
    the domain is responsible for solving the problems and automating the solutions;
    the **presentation layer** only links users’ actions to the **domain**.We usually
    build the domain layer around a domain model. There are two macro points of view
    on this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域层**是软件价值所在之处，也是大部分复杂性的集中地。**领域层**是业务逻辑规则的家。相比于**用户界面**，**领域层**更容易销售，因为用户通过表现层连接到领域。然而，重要的是要记住，领域负责解决问题和自动化解决方案；**表现层**仅将用户的操作链接到**领域**。我们通常围绕领域模型构建领域层。对此有两种宏观观点：'
- en: Using a **rich model**.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**丰富模型**。
- en: Using an **anemic model**.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**贫血模型**。
- en: You can leverage **Domain-Driven Design** (**DDD**) to build that model and
    the program around it. DDD goes hand in hand with rich models, and a well-crafted
    model should simplify the maintenance of the program. Doing DDD is not mandatory,
    and you can achieve the required level of correctness without it.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以利用**领域驱动设计**（**DDD**）来构建该模型及其周围的程序。DDD与丰富模型相辅相成，一个精心设计的模型应该简化程序的维护。进行DDD不是强制性的，即使没有它，你也可以达到所需的正确性水平。
- en: Another dilemma is persisting the domain model directly into the database or
    using an intermediate data model. We talk about that in more detail in the *Data*
    section.Meanwhile, we look at the two primary ways to think about the domain model,
    starting with the rich domain model.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个困境是将领域模型直接持久化到数据库或使用中间数据模型。我们将在*数据*部分更详细地讨论这一点。同时，我们来看看思考领域模型的两种主要方式，从丰富的领域模型开始。
- en: Rich domain model
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 丰富的领域模型
- en: 'A rich domain model is more object-oriented, in the “purest” sense of the term,
    and encapsulates the domain logic as part of the model inside methods. For example,
    the following class represents the rich version of a minimal `Product` class that
    contains only a few properties:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个丰富的领域模型在“最纯粹”的意义上更面向对象，并将领域逻辑封装为模型内部方法的一部分。例如，以下类代表了一个只包含几个属性的“Product”类的丰富版本：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `AddStock` and `RemoveStock` methods represent the domain logic of adding
    and removing stock for the product inventory. Of course, we only increment and
    decrement a property’s value in this case, but the concept would be the same in
    a more complex model.The biggest advantage of this approach is that most of the
    logic is built into the model, making this very domain-centric with operations
    programmed on model entities as methods. Moreover, it reaches the basic ideas
    behind object-oriented design, where behaviors should be part of the objects,
    making them a virtual representation of their real-life counterparts.The biggest
    drawback is the accumulation of responsibilities by a single class. Even if object-oriented
    design tells us to put logic into the objects, this does not mean it is always
    a good idea. If flexibility is important for your system, hardcoding logic into
    the domain model may hinder your ability to evolve business rules without changing
    the code itself (it can still be done). A rich model might be a good choice for
    your project if the domain is fixed and predefined.A relative drawback of this
    approach is that injecting dependencies into the domain model is harder than other
    objects, such as services. This drawback reduces flexibility and increases the
    complexity of creating the models.A rich domain model can be useful if you are
    building a stateful application where the domain model can live in memory longer
    than the time of an HTTP request. Other patterns can help you with that, such
    as **Model-View-View-Model** (**MVVM**), Model-View-Presenter (MVP), and **Model-View-Update**
    (**MVU**).If you believe your application would benefit from keeping the data
    and the logic together, then a rich domain model is most likely a good idea for
    your project. If you are practicing DDD, I probably don’t have to tell you that
    a rich model is the way to go. Without DDD notions, achieving a maintainable and
    flexible rich model is challenging.A rich model can be a good option if your program
    is built around a complex domain model and persists those classes directly to
    your database using an **object-relational mapper** (**ORM**). Using Cosmos DB,
    Firebase, MongoDB, or any other document database can make storing complex models
    as a single document easier than a collection of tables (this applies to anemic
    models too).As you may have noticed, there are a lot of “ifs” in this section
    because I don’t think there is an absolute answer to whether a rich model is better
    or not, and it is more a question of whether it is better for your specific case
    than better overall. You also need to take your personal preferences and skills
    into account.Experience is most likely your best ally here, so I’d recommend coding,
    coding, and coding more applications to acquire that experience.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddStock` 和 `RemoveStock` 方法代表了产品库存中添加和移除库存的领域逻辑。当然，在这种情况下，我们只增加和减少属性值，但在更复杂的模型中，概念是相同的。这种方法的最大的优点是大多数逻辑都内置到模型中，使得模型非常以领域为中心，操作通过模型实体作为方法来实现。此外，它触及了面向对象设计的基本思想，即行为应该是对象的一部分，使它们成为现实生活对应物的虚拟表示。最大的缺点是单个类承担了过多的责任。即使面向对象设计告诉我们将逻辑放入对象中，这并不意味着这总是好主意。如果你的系统对灵活性很重要，将逻辑硬编码到领域模型中可能会阻碍你在不更改代码本身的情况下（尽管仍然可以做到）演变业务规则的能力。如果你的领域是固定和预定义的，丰富的模型可能是你项目的良好选择。这种方法的相对缺点是，将依赖注入到领域模型比其他对象（如服务）更困难。这种缺点减少了灵活性，并增加了创建模型的复杂性。如果你正在构建一个状态型应用程序，其中领域模型可以在内存中比HTTP请求的时间更长地存在，丰富的领域模型可能是有用的。其他模式可以帮助你做到这一点，例如**模型-视图-视图-模型**（**MVVM**）、模型-视图-演示者（MVP）和**模型-视图-更新**（**MVU**）。如果你认为你的应用程序从保持数据和逻辑在一起中受益，那么丰富的领域模型可能是你项目的最佳选择。如果你在实践领域驱动设计（DDD），我可能不需要告诉你丰富的模型是正确的方向。如果没有DDD的概念，实现可维护和灵活的丰富模型是具有挑战性的。如果你的程序围绕复杂的领域模型构建，并直接使用**对象关系映射器**（**ORM**）将这些类持久化到数据库中，丰富的模型可能是一个好的选择。使用Cosmos
    DB、Firebase、MongoDB或任何其他文档数据库可以使将复杂模型作为单个文档存储比作为表集合更容易（这也适用于贫血型模型）。正如你可能已经注意到的，本节中有许多“如果”，因为我认为没有绝对的答案来决定丰富的模型是否更好，这更多是一个问题，即它是否比整体更好，是否更适合你的具体情况。你还需要考虑你个人的偏好和技能。经验很可能是你最好的盟友，所以我建议编写、编写和编写更多的应用程序来获得那种经验。'
- en: Anemic domain model
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 贫血型领域模型
- en: 'An anemic domain model usually does not contain methods but only getters and
    setters. Such models must not contain business logic rules. The `Product` class
    we had previously would look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个贫血的领域模型通常不包含方法，而只有获取器和设置器。这样的模型不应包含业务逻辑规则。我们之前提到的`Product`类将看起来像这样：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, there is no method in the class anymore, only the three
    properties with public setters. We can also leverage a record class to add immutability
    to the mix. As for the logic, we must move it elsewhere, in other classes. One
    such pattern would be to move the logic to a **service layer**.A **service layer**
    in front of such an **anemic model** would take the input, mutate the domain object,
    and update the database. The difference is that the service owns the logic instead
    of the rich model.With the anemic model, separating the operations from the data
    can help us add flexibility to a system. However, enforcing the model’s state
    at any given time can be challenging since external actors (services) are modifying
    the model instead of the model managing itself.Encapsulating logic into smaller
    units makes it easier to manage each of them, and it is easier to inject those
    dependencies into the service classes than injecting them into the entities themselves.
    Having more smaller units of code can make a system more dreadful for a newcomer
    as it can be more complex to understand since it has more moving parts. On the
    other hand, if the system is built around well-defined abstractions, it can be
    easier to test each unit in isolation.However, the tests can be quite different.
    In the case of our rich model, we test the rules and the persistence separately.
    We call this **persistence ignorance**, which allows us to test business rules
    in isolation. Then we could create integration tests to cover the persistence
    aspect of the service layer and more unit and integration tests on the data and
    domain levels. With an anemic model, we test both the business rules and the persistence
    simultaneously with integration tests at the service layer level or test only
    the business rules in unit tests that mock the persistence part away. Since the
    model is just a data bag without logic, there is nothing to test there.All in
    all, if the same rigorous domain analysis process is followed, the business rules
    of an anemic model backed by a service layer should be as complex as a rich domain
    model. The biggest difference should be in which classes the methods are located.An
    anemic model is a good option for stateless systems, such as RESTful APIs. Since
    you have to recreate the model’s state for every request, an anemic model can
    offer you a way to independently recreate a smaller portion of the model with
    smaller classes optimized for each use case. Stateless systems require a more
    procedural type of thinking than a purely object-oriented approach, leaving the
    anemic models as excellent candidates for that.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，类中不再有任何方法，只剩下三个具有公共设置器的属性。我们还可以利用记录类来为组合添加不可变性。至于逻辑，我们必须将其移动到其他类中。一种模式是将逻辑移动到**服务层**。在这样一个**贫血模型**之前的服务层将接受输入，修改领域对象，并更新数据库。区别在于服务拥有逻辑而不是丰富的模型。使用贫血模型，将操作与数据分离可以帮助我们为系统增加灵活性。然而，由于外部参与者（服务）正在修改模型而不是模型自我管理，因此强制执行模型在任何给定时间的状态可能具有挑战性。将逻辑封装到更小的单元中使得管理每个单元更容易，并且将那些依赖项注入服务类比注入实体本身更容易。拥有更多更小的代码单元可以使系统对新手来说更加可怕，因为它有更多的移动部件。另一方面，如果系统是围绕良好定义的抽象构建的，那么单独测试每个单元可能更容易。然而，测试可能相当不同。在我们的丰富模型的情况下，我们分别测试规则和持久性。我们称之为**持久性无知**，这允许我们单独测试业务规则。然后我们可以创建集成测试来覆盖服务层的持久性方面，以及更多针对数据和领域级别的单元和集成测试。使用贫血模型，我们使用服务层级别的集成测试同时测试业务规则和持久性，或者在单元测试中仅测试业务规则，同时模拟持久性部分。由于模型只是一个没有逻辑的数据包，因此那里没有什么可以测试的。总的来说，如果遵循相同的严格领域分析过程，由服务层支持的贫血模型的业务规则应该与丰富的领域模型一样复杂。最大的区别应该在于方法位于哪个类中。贫血模型是适用于无状态系统，如RESTful
    API的好选择。由于你必须为每个请求重新创建模型的状态，因此贫血模型可以为你提供一种独立地重新创建模型较小部分的方法，这些较小的类针对每个用例进行了优化。无状态系统需要比纯面向对象方法更程序化的思维方式，这使得贫血模型成为该领域的绝佳候选者。
- en: I personally love anemic models behind a service layer, but some people would
    not agree with me. I recommend choosing what you think is best for the system
    you are building instead of doing something based on what someone else did in
    another system.
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我个人非常喜欢服务层背后的贫血模型，但有些人可能不同意我的看法。我建议选择你认为最适合你正在构建的系统的方法，而不是基于别人在另一个系统中做的事情来做某事。
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another good tip is to let the refactoring flow *top-down* to the right location.
    For example, if you feel that a method is bound to an entity, nothing stops you
    from moving that piece of logic into that entity instead of a service class. If
    a service is more appropriate, move the logic to a service class.
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个不错的建议是让重构流程从上到下流动到正确的位置。例如，如果你觉得一个方法绑定到一个实体上，没有什么阻止你将那部分逻辑移动到该实体而不是服务类中。如果服务更合适，就将逻辑移动到服务类中。
- en: Next, let’s go back to the **domain layer** and explore a pattern that emerged
    over the years to shield the **domain model** using a **service layer**, splitting
    the **domain layer** into two distinct pieces.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回到**领域层**，并探讨多年来出现的一种模式，即使用**服务层**来保护**领域模型**，将**领域层**分为两个不同的部分。
- en: Service layer
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务层
- en: 'The **service layer** shields the domain model and encapsulates domain logic.
    The service layer orchestrates the complexity of interacting with the model or
    external resources such as databases. Multiple components can then use the service
    layer while having limited knowledge of the model:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务层**保护领域模型并封装领域逻辑。服务层协调与模型或外部资源（如数据库）交互的复杂性。然后，多个组件可以使用服务层，同时对其模型了解有限：'
- en: '![Figure 14.5: Service layer relationships with other layers](img/file79.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5：服务层与其他层的关系](img/file79.png)'
- en: 'Figure 14.5: Service layer relationships with other layers'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：服务层与其他层的关系
- en: 'The preceding diagram shows that the presentation layer talks to the service
    layer, which manages the domain model and implements the business logic.The **service
    layer** contains services, which are classes that interact with other **domain
    objects**, such as the **domain model** and the **data layer**.We can further
    divide services into two categories, **domain services**, and **application services**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示，表示层与服务层进行通信，服务层负责管理领域模型并实现业务逻辑。**服务层**包含服务，这些是与其他**领域对象**（如**领域模型**和**数据层**）交互的类。我们可以进一步将服务分为两类，**领域服务**和**应用服务**：
- en: '**Domain services** are those services we are talking about so far. They contain
    domain logic and allow consumers from the presentation layer to read or write
    data. They access and mutate the domain model.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域服务**是我们之前所讨论的服务。它们包含领域逻辑，并允许表示层的消费者读取或写入数据。它们访问和修改领域模型。'
- en: '**Application services** like email services are unrelated to the domain and
    should live elsewhere, like in a shared (why rewrite an email service for every
    project, right?).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用服务**，如邮件服务，与领域无关，应该放在其他地方，比如在共享的（为什么要在每个项目中重写邮件服务，对吧？）。'
- en: 'As with other layers, your service layer could expose its own model, shielding
    its consumers from domain model (internal) changes. In other words, the service
    layer should only expose its contracts and interfaces (keyword: shield). **A service
    layer is a form of façade.**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他层一样，你的服务层可以公开其自己的模型，保护其消费者免受领域模型（内部）变化的影响。换句话说，服务层应该只公开其契约和接口（关键词：保护）。**服务层是一种外观模式**。
- en: We further explore ways to keep copying anemic classes into other anemic classes
    to a minimum.
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将进一步探讨将贫血类复制到其他贫血类中的最小化方法。
- en: 'There are many ways to interpret this layer, and I’ll try to illustrate as
    many as possible in a condensed manner (from simpler to more complex ones):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方式可以解释这一层，我将尝试以浓缩的方式尽可能多地展示（从简单到复杂）：
- en: The classes and interfaces of the service layer could be part of the domain
    layer’s assembly, created in a *Services* directory, for example. This is less
    reusable, but it paves the way to sharing services in the future without managing
    multiple projects at first. It needs rigor to not depend on what you should not.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层的类和接口可以是领域层组件的一部分，例如在*Services*目录中创建。这不太可重用，但它为未来共享服务铺平了道路，而无需最初管理多个项目。它需要严谨，不要依赖于你不应该依赖的东西。
- en: The service layer could be an assembly containing interfaces and implementation.
    This is a great compromise between reusability and maintenance time. Chances are
    you will never need two implementations (see the next point) because the services
    are tied to the logic; they are the domain. You could even hide the implementation,
    as we did with the **opaque façade** in *Chapter 11*, *Structural Patterns*.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层可以是一个包含接口和实现的组件。这在可重用性和维护时间之间是一个很好的折衷方案。很可能你永远不会需要两个实现（参见下一点），因为服务与逻辑相关联；它们是领域。你甚至可以隐藏实现，就像我们在第11章的*结构模式*中做的**不透明外观**一样。
- en: The service layer could be divided into two assemblies -- one containing abstractions
    (referenced by consumers) and one containing implementations.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层可以被分为两个组件——一个包含抽象（由消费者引用）和一个包含实现。
- en: The service layer could be an actual web service tier (such as a web API).
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层可以是实际的Web服务层（例如Web API）。
- en: 'When writing services code, by convention, people usually suffix a service
    class with `Service`, such as `ProductService` and `InventoryService`; the same
    goes for interfaces (`IProductService` and `IInventoryService`).No matter which
    technique you choose, remember that the service layer contains the domain logic
    and shields the domain model from direct access.The service layer is an amazing
    addition that shields and encapsulates the logic for manipulating an anemic domain
    model. It can defeat the purpose of a rich domain model if it’s just a pass-through
    but can be very useful to handle complex, non-atomic business rules that affect
    multiple domain objects.The primary decider of whether or not to add a service
    layer is tied to the complexity of your project’s domain. The more complex, the
    more it makes sense. The more trivial, the less it makes sense. Here are a few
    tips:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写服务代码时，按照惯例，人们通常在服务类后缀加上`Service`，例如`ProductService`和`InventoryService`；接口也是如此（`IProductService`和`IInventoryService`）。无论你选择哪种技术，记住服务层包含领域逻辑，并保护领域模型免受直接访问。服务层是一个惊人的补充，它保护并封装了操作贫血领域模型的逻辑。如果它只是一个传递，那么它可能会违背丰富领域模型的目的，但它可以非常有助于处理影响多个领域对象的复杂、非原子业务规则。是否添加服务层的主要决定因素与您项目领域的复杂性相关。越复杂，就越有意义。越简单，就越没有意义。以下是一些建议：
- en: Add a service layer when using an anemic model.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用贫血模型时，添加一个服务层。
- en: Add a service layer for very complex domains.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为非常复杂的领域添加服务层。
- en: Do not add a service layer for low-complexity domains or *façade over database*
    applications.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要为低复杂度领域或*数据库外观*应用添加服务层。
- en: Now, let’s look at the data layer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看数据层。
- en: Data
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据
- en: The **data layer** is where the persistence code goes. In most programs, we
    need some kind of persistence to store our application data, which is often a
    database. Several patterns come to mind when discussing the data layer, including
    the **Unit of Work** and **Repository patterns**, which are very common. We cover
    these two patterns very briefly at the end of this subsection.We can persist our
    **domain model** as is or create a **data model** that is more suited to be stored.
    For example, a many-to-many relationship is not a thing in the object-oriented
    world, while it is from a relational database standpoint.You can view a **data
    model** like a **DTO** for the data. The **data model** is how the data is stored
    in your data store; that is, how you modeled your data or what you have to live
    with.In a classic layering project, you have no choice but to have a data model.
    However, we explore better solutions as we continue to explore additional options.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据层**是持久化代码所在的地方。在大多数程序中，我们需要某种持久化来存储我们的应用程序数据，这通常是数据库。在讨论数据层时，会想到几种模式，包括**工作单元**和**存储库模式**，这些模式非常常见。我们在本小节的末尾简要介绍了这两个模式。我们可以直接持久化我们的**领域模型**，或者创建一个更适合存储的**数据模型**。例如，多对多关系在面向对象的世界中不是一件事情，而从关系数据库的角度来看则是。你可以将**数据模型**看作是数据的**DTO**。**数据模型**是数据在您的数据存储中的存储方式；也就是说，您如何建模数据或您必须忍受什么。在一个经典的分层项目中，您别无选择，只能有一个数据模型。然而，随着我们继续探索更多选项，我们将探索更好的解决方案。'
- en: An **ORM** is a piece of software that translates objects into a database language
    such as SQL. It allows mutating data, querying data, loading that data into objects,
    and more.
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ORM** 是一种将对象转换为数据库语言（如SQL）的软件。它允许修改数据、查询数据、将数据加载到对象中，等等。'
- en: Modern data layers usually leverage an **ORM** such as **Entity Framework Core**
    (**EF Core**), which does a big part of our job, making our lives easier. In the
    case of **EF Core**, it allows us to choose between multiple providers, from SQL
    Server to Cosmos DB, passing by the in-memory provider. The great thing about
    EF Core is that it already implements the **Unit of Work** and the **Repository**
    patterns for us, among other things. In the book, we use the in-memory provider
    to cut down setup time and run integration tests.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现代数据层通常利用一个 **ORM**（对象关系映射）如 **Entity Framework Core**（**EF Core**），它为我们做了大部分工作，使我们的生活变得更简单。在
    **EF Core** 的情况下，它允许我们在多个提供者之间进行选择，从 SQL Server 到 Cosmos DB，再到内存提供者。EF Core 的好处在于它已经为我们实现了
    **工作单元** 和 **仓储** 模式，以及其他一些功能。在书中，我们使用内存提供者来减少设置时间并运行集成测试。
- en: If you’ve used EF6 before and dread Entity Framework, know that EF Core is lighter,
    faster, and easier to test. Feel free to give it a second shot. EF Core’s performance
    is very high now too. However, if you want complete control over your SQL code,
    look for Dapper (not to be confused with **Dapr**).
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你之前使用过 EF6 并且对 Entity Framework 感到恐惧，要知道 EF Core 更轻量级、更快，并且更容易测试。不妨再试一次。EF
    Core 的性能现在也非常高。然而，如果你想要完全控制你的 SQL 代码，可以寻找 Dapper（不要与 **Dapr** 混淆）。
- en: I don’t want to go into too much detail about these patterns, but they are important
    enough to deserve an overview. As mentioned, EF Core already implements these
    patterns, so we don’t have to deal with them. Moreover, using such patterns is
    not always desirable, can be hard to implement right, and can lead to bloated
    data access layers, but they can also be very useful when used well.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想对这些模式进行过多细节的介绍，但它们的重要性足以值得一个概述。正如所提到的，EF Core 已经实现了这些模式，所以我们不必处理它们。此外，使用这些模式并不总是可取的，可能难以正确实现，并且可能导致数据访问层臃肿，但使用得当的话，它们也可以非常有用。
- en: I’ve written a multi-part article series about the Repository pattern. See the
    *Further reading* section.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我已经写了一系列关于仓储模式的文章。请参阅 *进一步阅读* 部分。
- en: In the meantime, let’s at least study their goals to know what they are for,
    and if the situation arises where you need to write such components, you know
    where to look.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，让我们至少研究一下它们的目标，以便了解它们的作用，如果出现需要编写此类组件的情况，你知道该往哪里寻找。
- en: Repository pattern
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仓储模式
- en: 'The goal of the Repository pattern is to allow consumers to query the database
    in an object-oriented way. Usually, this implies caching objects and filtering
    data dynamically. EF Core represents this concept with a `DbSet<T>` and provides
    dynamic filtering using LINQ and the `IQueryable<T>` interface.People also use
    the term **repository** to represent the **Table Data Gateway pattern**, which
    is another pattern that models a class that gives us access to a single table
    in a database and provides access to operations such as creating, updating, deleting,
    and fetching entities from that database table. Both patterns are from the *Patterns
    of Enterprise Application Architecture* and are extensively used.Homegrown custom
    implementations usually follow the Table Data Gateway pattern more than the Repository
    pattern. They are based on an interface that looks like the following code and
    contains methods to create, update, delete, and read entities. They can have a
    base entity or not, in this case, `IEntity<TId>`. The `Id` property can also be
    generic or not:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 仓储模式的目标是允许消费者以面向对象的方式查询数据库。通常，这意味着缓存对象和动态过滤数据。EF Core 通过 `DbSet<T>` 来表示这个概念，并使用
    LINQ 和 `IQueryable<T>` 接口提供动态过滤。人们也使用术语 **repository** 来表示 **表数据网关模式**，这是另一种模式，它模拟一个类，为我们提供访问数据库中单个表的方法，并提供对创建、更新、删除和从该数据库表获取实体的操作。这两种模式都来自
    *企业应用架构模式*，并且被广泛使用。自制的自定义实现通常比仓储模式更多地遵循表数据网关模式。它们基于一个看起来像以下代码的接口，并包含创建、更新、删除和读取实体的方法。它们可以有一个基类实体或没有，在这种情况下，`IEntity<TId>`。`Id`
    属性也可以是泛型或非泛型：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'One thing that often happens with those table data gateways is that people
    add a save method to the interface. As long as you update a single entity, it
    should be fine. However, that makes transactions that cross multiple repositories
    harder to manage or dependent on the underlying implementation (breaking abstraction).
    To commit or revert such transactions, we can leverage the Unit of Work pattern,
    moving the save method from the table data gateway there.For example, when using
    EF Core, we can use `DbSet<Product>` (the `db.Products` property) to add new products
    to the database, like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与那些表数据网关相关的一个常见问题是，人们会在接口中添加一个保存方法。只要更新单个实体，这应该没问题。然而，这使得跨多个仓库的事务管理更加困难或依赖于底层实现（破坏抽象）。为了提交或回滚这样的事务，我们可以利用工作单元模式，将保存方法从表数据网关移动到那里。例如，当使用EF
    Core时，我们可以使用`DbSet<Product>`（`db.Products`属性）将新产品添加到数据库，如下所示：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the querying part, the easiest way to find a single product is to use it
    like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于查询部分，找到单个产品最简单的方法是像这样使用它：
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, we could use LINQ instead:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用LINQ来代替：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These are some of the querying capabilities that a **repository** should provide.
    EF Core seamlessly translates LINQ into the configured provider expectations like
    SQL, adding extended filtering capabilities.Of course, with EF Core, we can query
    collections of items, fetching all products and projecting them as domain objects
    like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一个**仓库**应该提供的一些查询功能。EF Core无缝地将LINQ转换为配置的提供者期望的SQL，增加了扩展的过滤能力。当然，使用EF Core，我们可以查询项目集合，获取所有产品并将它们投影为域对象，如下所示：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also filter further using LINQ here; for example, by querying all the
    products that are out of stock:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里也可以使用LINQ进行进一步筛选；例如，通过查询所有缺货的产品：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We could also allow a margin for error, like so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以允许一定的错误范围，如下所示：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We now have briefly explored how to use the EF Core implementation of the Repository
    pattern, `DbSet<T>`. These few examples might seem trivial, but it would require
    considerable effort to implement custom repositories on par with EF Core’s features.EF
    Core’s unit of work, the `DbContext` class, contains the *save* methods to persist
    the modifications done to all its `DbSet<T>` properties (the repositories). Homebrewed
    implementations often feature such methods on the repository itself, making cross-repository
    transactions harder to handle and leading to bloated repositories containing tons
    of operation-specific methods to handle such cases.Now that we understand the
    concept behind the **Repository pattern**, let’s jump into an overview of the
    **Unit of Work pattern** before going back to layering.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在简要探讨了如何使用EF Core的Repository模式实现，`DbSet<T>`。这些例子可能看起来微不足道，但要实现与EF Core功能相媲美的自定义仓库需要相当大的努力。EF
    Core的工作单元，`DbContext`类，包含了*保存*方法来持久化对其所有`DbSet<T>`属性（仓库）所做的修改。自制的实现通常在仓库本身上具有这样的方法，这使得跨仓库事务的处理更加困难，并导致仓库膨胀，包含大量针对特定操作的方法来处理这些情况。现在我们理解了**Repository模式**背后的概念，让我们在回到分层之前，先概述一下**工作单元模式**。
- en: Unit of Work pattern
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工作单元模式
- en: 'A **unit of work** keeps track of the object representation of a transaction.
    In other words, it manages a registry of what objects should be created, updated,
    and deleted. It allows us to combine multiple changes in a single transaction
    (one database call), offering multiple advantages over calling the database every
    time we make a change.Assuming we are using a relational database, here are two
    advantages:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作单元**跟踪事务的对象表示。换句话说，它管理一个注册表，记录应该创建、更新和删除的对象。它允许我们在单个事务中组合多个更改（一个数据库调用），相对于每次更改都调用数据库，提供了多个优势。假设我们使用的是关系数据库，这里有两个优势：'
- en: First, it can speed up data access; calling a database is slow, so limiting
    the number of calls and connections can improve performance.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它可以加快数据访问速度；调用数据库是慢的，所以限制调用和连接的数量可以提高性能。
- en: Second, running a transaction instead of individual operations allows us to
    roll back all operations if one fails or commit the transaction as a whole if
    everything succeeds.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，运行事务而不是单个操作允许我们在一个操作失败时回滚所有操作，或者在所有操作都成功时提交整个事务。
- en: 'EF Core implements this pattern with the `DbContext` class and its underlying
    types, such as the `DatabaseFacade` and `ChangeTracker` classes.Our small applications
    don’t need transactions, but the concept remains the same. Here is an example
    of what happens using EF Core:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core使用`DbContext`类及其底层类型（如`DatabaseFacade`和`ChangeTracker`类）实现此模式。我们的小型应用程序不需要事务，但概念是相同的。以下是一个使用EF
    Core发生的情况的示例：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code does the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: Queries the database for a single entity.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询数据库以获取单个实体。
- en: Changes the value of the `QuantityInStock` property.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改了`QuantityInStock`属性的值。
- en: Persists the changes back into the database.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改持久回数据库。
- en: 'In reality, what happened is closer to the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上发生的情况更接近以下内容：
- en: 'We ask EF Core for a single entity through the `ProductContext` (a unit of
    work), which exposes the `DbSet<Product>` property (the product repository). Under
    the hood, EF Core does the following:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过`ProductContext`（一个单位工作）请求EF Core的单个实体，它公开了`DbSet<Product>`属性（产品仓库）。在底层，EF
    Core执行以下操作：
- en: Queries the database.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询数据库。
- en: Caches the entity.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓存实体。
- en: Tracks changes for that entity.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪该实体的更改。
- en: Returns it to us.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其返回给我们。
- en: We change the value of the `QuantityInStock` property; EF Core detects the change
    and marks the object as *dirty*.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更改了`QuantityInStock`属性的值；EF Core检测到变化并将对象标记为*脏的*。
- en: We tell the unit of work to persist the changes that it tracked, saving the
    *dirty product* back to the database.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们告诉单位工作持久化它跟踪的更改，将*脏产品*保存回数据库。
- en: 'In a more complex scenario, we could have written the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的场景中，我们可能会编写以下代码：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, the `SaveChanges()` method triggers saving the three operations instead
    of sending them individually. You can control database transactions using the
    `Database` property of `DbContext` (see the *Further reading* section for more
    information).Now that we’ve explored the **unit of work** pattern, we could implement
    one by ourselves. Would that add value to our application? Probably not. If you
    want to build a custom **unit of work** or a wrapper over EF Core, there are plenty
    of existing resources to guide you. Unless you want to experiment or need a custom
    **unit of work** and **repository** (which is possible), I recommend staying away
    from doing that. Remember: **do only what needs to be done for your program to
    be correct**.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`SaveChanges()`方法触发保存三个操作，而不是单独发送它们。你可以使用`DbContext`的`Database`属性来控制数据库事务（有关更多信息，请参阅*进一步阅读*部分）。现在我们已经探讨了**单位工作**模式，我们可以自己实现它。这会给我们的应用程序增加价值吗？可能不会。如果你想构建自定义的**单位工作**或EF
    Core的包装器，有许多现有资源可以指导你。除非你想进行实验或需要自定义的**单位工作**和**仓库**（这是可能的），否则我建议远离这样做。记住：**只做程序正确运行所需的事情**。
- en: Don’t get me wrong when I say *do only what needs to be done*; wild engineering
    endeavors and experimentations are a great way to explore, and I encourage you
    to do so. However, I recommend doing so in parallel so that you can innovate,
    learn, and possibly even migrate that knowledge to your application later instead
    of wasting time and breaking things. If you are using Git, creating an experimental
    branch is a good way of doing this. You can then delete it when your experimentation
    does not work, merge the branch if it yields positive results, or leave it there
    as a reference (depending on the team’s policies in place).
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我说*只做需要做的事情*时，请不要误解；无序的工程尝试和实验是探索的好方法，我鼓励你这样做。然而，我建议并行进行，这样你就可以创新，学习，甚至可能将知识迁移到你的应用程序中，而不是浪费时间并破坏事物。如果你使用Git，创建一个实验分支是一个很好的方法。然后，如果你的实验没有成功，你可以删除它，如果它产生了积极的结果，你可以合并分支，或者根据团队的现有政策将其保留为参考。
- en: Now that we explored a high-level view of the Repository and Unit of Work patterns,
    and what those common layers are for, we can continue our journey of using layers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了仓库和单位工作模式的高级视图以及这些常见层的作用，我们可以继续我们的分层使用之旅。
- en: Abstract layers
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象层
- en: 'This section looks at abstract layers using an abstract data layer implementation.
    This type of abstraction can be very useful and is another step closer to **Clean
    Architecture**. Moreover, you can abstract almost anything this way, which is
    nothing more than applying the **Dependency Inversion Principle** (**DIP**).Let’s
    start with some context and the problem:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本节通过使用抽象数据层实现来探讨抽象层。这种抽象方式非常有用，并且是向**整洁架构**迈进的一步。此外，你几乎可以用这种方式抽象任何事物，这不过是应用**依赖倒置原则**（**DIP**）。让我们从一些背景信息和问题开始：
- en: The **domain layer** is where the logic lies.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域层**是逻辑所在的地方。'
- en: The **UI** links the user to the **domain**, exposing the features built into
    that **domain**.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI**将用户链接到**领域**，暴露了该**领域**中内置的功能。'
- en: The **data layer** should be an implementation detail that the **domain** blindly
    uses.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据层**应该是**领域**盲目使用的实现细节。'
- en: The **data layer** contains the code that knows where the data is stored, which
    should be irrelevant to the **domain**, but the **domain** directly depends on
    it.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据层**包含知道数据存储位置的代码，这应该与**领域**无关，但**领域**直接依赖于它。'
- en: 'The solution to **break the tight coupling** between the **domain** and the
    **data** persistence implementations is to create an additional abstract layer,
    as shown in the following diagram:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 解决**领域**和**数据持久化实现**之间紧密耦合的方案是创建一个额外的抽象层，如下面的图中所示：
- en: '![Figure 14.6: Replacing the data (persistence) layer with a data abstraction
    layer](img/file80.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6：用数据（持久化）抽象层替换数据层](img/file80.png)'
- en: 'Figure 14.6: Replacing the data (persistence) layer with a data abstraction
    layer'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：用数据（持久化）抽象层替换数据层
- en: 'New rule: **only interfaces and data model classes go into the data abstractions
    layer**. This new layer now defines our data access API and does nothing but expose
    a set of interfaces—the contract.Then, **we can create one or more data implementations**
    based on that abstract layer contract, like using EF Core. The link between the
    abstractions and implementations is done with dependency injection. The bindings
    defined in the **composition root** explain the indirect connection between the
    presentation and the data implementation.The new dependency tree looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 新规则：**只有接口和数据模型类进入数据抽象层**。这个新层现在定义了我们的数据访问API，除了暴露一系列接口——合同。然后，**我们可以根据这个抽象层合同创建一个或多个数据实现**，例如使用EF
    Core。抽象和实现之间的链接是通过依赖注入完成的。在**组合根**中定义的绑定解释了表示层和数据实现之间的间接连接。新的依赖树看起来像这样：
- en: '![Figure 14.7: The relationships between layers](img/file81.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图14.7：层之间的关系](img/file81.png)'
- en: 'Figure 14.7: The relationships between layers'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7：层之间的关系
- en: The **presentation layer** references a **data implementation layer** for the
    sole purpose of creating the DI bindings. We need those bindings to inject the
    correct implementation when creating **domain** classes. Besides, **the presentation
    layer must not use the data layer’s abstractions or implementations**.I created
    a sample project that showcases the relationships between the projects and the
    classes. However, that project would have added pages of code, so I decided not
    to include it in the book. The most important thing about abstract layers is the
    dependency flow between the layers, not the code itself.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示层**引用**数据实现层**的唯一目的是创建DI绑定。我们需要这些绑定来在创建**领域**类时注入正确的实现。此外，**表示层不得使用数据层的抽象或实现**。我创建了一个示例项目，展示了项目与类之间的关系。然而，那个项目会增加许多代码页面，所以我决定不在书中包含它。关于抽象层最重要的东西是层之间的依赖流，而不是代码本身。'
- en: The project is available on GitHub ([https://adpg.link/s9HX](https://adpg.link/s9HX)).
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 项目可在GitHub上找到（[https://adpg.link/s9HX](https://adpg.link/s9HX)）。
- en: 'In that project, the program injects an instance of the `EF.ProductRepository`
    class when a consumer asks for an object that implements the `IProductRepository`
    interface. In that case, the consuming class is `ProductService` and only depends
    on the `IProductRepository` interface. The `ProductService` class is unaware of
    the implementation itself: it leverages only the interface. The same goes for
    the program that loads a `ProductService` class but knows only about the `IProductService`
    interface. Here is a visual representation of that dependency tree:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个项目中，当消费者请求实现`IProductRepository`接口的对象时，程序会注入`EF.ProductRepository`类的实例。在这种情况下，消费类是`ProductService`，并且只依赖于`IProductRepository`接口。`ProductService`类本身并不知道实现细节：它只利用接口。对于只知道`IProductService`接口的程序加载`ProductService`类的情况也是一样。以下是该依赖树的视觉表示：
- en: '![Figure 14.8: The dependency flow between layers, classes, and interfaces](img/file82.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8：层、类和接口之间的依赖流](img/file82.png)'
- en: 'Figure 14.8: The dependency flow between layers, classes, and interfaces'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8：层、类和接口之间的依赖流
- en: In the preceding diagram, look at how dependencies converge on the `Data.Abstract`
    layer. The dependency tree ends up on that abstract data layer.With this applied
    piece of architectural theory, we are inverting the flow of dependencies on the
    data layer by following the **DIP**. We also cut out the direct dependency on
    EF Core, allowing us to implement a new data layer and swap it without impacting
    the rest of the application or update the implementation without affecting the
    domain. As I mentioned previously, swapping layers should not happen very often,
    if ever. Nonetheless, this is an important part of the evolution of layering,
    and more importantly, we can apply this technique to any layer or project, not
    just the data layer, so it is imperative to understand how to invert the dependency
    flow.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，看看依赖是如何汇聚到`Data.Abstract`层的。依赖树最终结束在那个抽象数据层。应用这一块架构理论，我们通过遵循**DIP**（依赖倒置原则）来反转数据层的依赖流。我们还切断了直接对EF
    Core的依赖，这使得我们可以实现新的数据层并替换它，而不会影响应用程序的其他部分或更新实现而不影响领域。正如我之前提到的，层之间的替换不应该经常发生，如果可能的话。尽管如此，这是分层演变的一个重要部分，更重要的是，我们可以将这项技术应用于任何层或项目，而不仅仅是数据层，因此理解如何反转依赖流是至关重要的。
- en: To test the APIs, you can use the Postman collection that comes with the book;
    visit [https://adpg.link/postman8](https://adpg.link/postman8) or GitHub ([https://adpg.link/net8](https://adpg.link/net8))
    for more info.
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要测试API，您可以使用书中提供的Postman集合；访问[https://adpg.link/postman8](https://adpg.link/postman8)或GitHub
    ([https://adpg.link/net8](https://adpg.link/net8)) 获取更多信息。
- en: Next, let’s explore sharing and persisting a rich domain model.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索共享和持久化丰富的领域模型。
- en: Sharing the model
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享模型
- en: 'We have explored strict layering and how to apply the DIP, but we still have
    multiple models. An alternative to copying models from one layer to another is
    to share a model between multiple layers, generally as an assembly. Visually,
    it looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了严格的分层以及如何应用DIP，但我们仍然有多个模型。从一层复制模型到另一层的替代方案是在多个层之间共享一个模型，通常作为一个组件。从视觉上看，它看起来像这样：
- en: '![Figure 14.9: Sharing a model between all three layers](img/file83.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图14.9：在所有三层之间共享模型](img/file83.png)'
- en: 'Figure 14.9: Sharing a model between all three layers'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9：在所有三层之间共享模型
- en: 'Everything has pros and cons, so no matter how much time this can save you
    at first, it will come back to haunt you and become a pain point later as the
    project advances and becomes more complex.Suppose you feel that sharing a model
    is worth it for your application. In that case, I recommend using **view models**
    or **DTOs** at the presentation level to control and keep the input and output
    of your application loosely coupled from your model. This way of shielding your
    lower layers can be represented as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 任何事物都有利弊，所以无论这能为您节省多少时间，随着项目的推进和复杂化，它最终会回来困扰您，并成为痛点。假设您认为共享模型对您的应用程序来说是值得的，那么我建议在表示层使用**视图模型**或**DTOs**（数据传输对象）来控制并保持应用程序的输入和输出与模型松散耦合。这种方式保护底层的方式可以表示如下：
- en: '![Figure 14.10: Sharing a model between the domain and data layers](img/file84.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图14.10：在领域和数据层之间共享模型](img/file84.png)'
- en: 'Figure 14.10: Sharing a model between the domain and data layers'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10：在领域和数据层之间共享模型
- en: By doing that, you will save some time initially by sharing your model between
    your domain and data layers. By hiding that shared model under the presentation
    layer, you should dodge many problems in the long run, making this a good compromise
    between quality and development time. Moreover, since your presentation layer
    shields your application from the outside world, you can refactor your other layers
    without impacting your consumers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，你最初可以通过在领域和数据层之间共享模型来节省一些时间。通过将共享模型隐藏在表示层之下，你可以在长期运行中避免许多问题，这使得在质量和开发时间之间达到一个良好的折衷。此外，由于你的表示层保护了你的应用程序免受外部世界的影响，你可以重构其他层而不会影响消费者。
- en: This is pretty much how Clean Architecture does it but represented differently.
    Using that, the model is at the center of the application and is manipulated and
    persisted. While the layers have different names, the concept remains very similar.
    More on that later.
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这基本上是Clean Architecture所做的方式，但表示不同。使用它，模型位于应用程序的中心，并被操作和持久化。虽然层的名称不同，但概念仍然非常相似。关于这一点，稍后还会详细介绍。
- en: '**View models** and **DTOs** are key elements to successful programs and developers’
    sanity; they should save you many headaches for long-running projects. We revisit
    and explore the concepts of controlling the input and output later in *Chapter
    16*, *Mediator and CQRS Design Patterns*, where inputs become **commands** and
    **queries**.Meanwhile, let’s merge that concept with an abstraction layer. In
    the previous project, the **data abstraction layer** owned the **data model**,
    and the **domain layer** owned the **domain model**.In this architectural alternative,
    we are sharing the model between the two layers. The presentation layer can indirectly
    use that shared model to dialog with the domain layer without exposing it externally.
    The objective is to directly persist the **domain model** and skip the copy from
    the **domain** to the **data layer** while having that data abstraction layer
    that breaks the tight coupling between the domain logic and the persistence.Here
    is a visual representation of that:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图模型**和**DTOs**是成功程序和开发者理智的关键元素；它们应该为长期项目节省许多麻烦。我们将在*第16章*，*中介者和CQRS设计模式*中重新审视并探讨控制输入和输出的概念，其中输入成为**命令**和**查询**。同时，让我们将这个概念与抽象层合并。在前一个项目中，**数据抽象层**拥有**数据模型**，而**领域层**拥有**领域模型**。在这个架构替代方案中，我们在两个层之间共享模型。表示层可以间接使用这个共享模型与领域层进行对话，而不将其暴露在外部。目标是直接持久化**领域模型**，并跳过从**领域**到**数据层**的复制，同时拥有那个打破领域逻辑和持久性之间紧密耦合的数据抽象层。以下是这种表示的视觉表示：'
- en: '![Figure 14.11: Diagram representing a shared rich model](img/file85.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图14.11：表示共享丰富模型的图](img/file85.png)'
- en: 'Figure 14.11: Diagram representing a shared rich model'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11：表示共享丰富模型的图
- en: 'It is well suited for **rich models,** but we can also do this for anemic models.
    With a **rich domain model**, you delegate the job of reconstructing the model
    to the ORM and immediately start calling its methods.The ORM also recreates the
    anemic model, but those classes just contain data, so you need to call other pieces
    of the software that contain the logic to manipulate those objects.In the code
    sample, the **data abstraction layer** now contains only the data access abstractions,
    such as the repositories, and it references the new `Model` project that is now
    the persisted model.Conceptually, it cleans up a few things:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常适合**丰富模型**，但我们也可以为贫血模型做这件事。在**丰富领域模型**中，你将重建模型的工作委托给ORM，并立即开始调用其方法。ORM也会重建贫血模型，但这些类仅包含数据，因此你需要调用其他包含操作这些对象的逻辑的软件部分。在代码示例中，**数据抽象层**现在只包含数据访问抽象，如存储库，并引用现在作为持久化模型的新的`Model`项目。从概念上讲，它清理了一些事情：
- en: The data abstraction layer’s only responsibility is to contain data access abstractions.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据抽象层的唯一责任是包含数据访问抽象。
- en: The domain layer’s only responsibility is implementing the domain services and
    the logic that is not part of that rich model.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域层的唯一责任是实现领域服务和不属于该丰富模型的逻辑。
- en: In the case of an anemic model, the domain layer’s responsibility would be to
    encapsulate all the domain logic.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在贫血模型的情况下，领域层的责任将是封装所有的领域逻辑。
- en: The `Model` project contains the entities.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Model`项目包含实体。'
- en: 'Once again, I skip publishing most of the code here as it is irrelevant to
    the overall concept. If you think reading the code would help, you can consult
    and explore the sample on GitHub ([https://adpg.link/9F5C](https://adpg.link/9F5C)).
    Using an IDE to browse the code should help you understand the flow, and as with
    the abstract layer, the dependencies between the projects, classes, and interfaces
    are the key to this.Nevertheless, here is the `StockService` class that uses that
    shared model so you can peek at some code that directly relates to the explanations:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我这里省略了大部分代码，因为它与整体概念无关。如果您认为阅读代码会有帮助，可以查阅并探索 GitHub 上的示例（[https://adpg.link/9F5C](https://adpg.link/9F5C)）。使用
    IDE 浏览代码应该有助于您理解流程，并且与抽象层一样，项目、类和接口之间的依赖关系是关键。尽管如此，这里还是展示了使用该共享模型的 `StockService`
    类，以便您可以查看一些与解释直接相关的代码：
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we are injecting an implementation of the `IProductRepository`
    interface we use in the next two methods. Next, we look at the `AddStockAsync`
    method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们注入了我们在接下来的两个方法中使用的 `IProductRepository` 接口的实现。接下来，我们看看 `AddStockAsync`
    方法：
- en: '[PRE12]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The fun starts in the preceding code, which does the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中开始变得有趣，它执行以下操作：
- en: The repository recreates the product (model) that contains the logic.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库重新创建了包含逻辑的产品（模型）。
- en: It validates that the product exists.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它验证产品是否存在。
- en: It uses that model and calls the `AddStock` method (encapsulated domain logic).
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用该模型并调用 `AddStock` 方法（封装的领域逻辑）。
- en: It tells the repository to update the product.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它告诉仓库更新产品。
- en: It returns the updated product’s `QuantityInStock` to the consumer of the service.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将更新后的产品的 `QuantityInStock` 返回给服务的消费者。
- en: 'Next, we explore the `RemoveStockAsync` method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探索 `RemoveStockAsync` 方法：
- en: '[PRE13]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We applied the same logic as the `AddStock` method to the `RemoveStock` method,
    but it calls the `Product.RemoveStock` method instead. From the `StockService`
    class, we can see the service gating the access to the domain model (the product),
    fetching and updating the model through the abstract data layer, manipulating
    the model by calling its methods, and returning domain data (an `int` in this
    case, but could be an object).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `AddStock` 方法的相同逻辑应用于 `RemoveStock` 方法，但它调用 `Product.RemoveStock` 方法。从 `StockService`
    类中，我们可以看到服务控制对领域模型（产品）的访问，通过抽象数据层获取和更新模型，通过调用其方法来操作模型，并返回领域数据（在这种情况下是一个 `int`，但可能是一个对象）。
- en: This type of design can be either very helpful or undesirable. Too many projects
    depending on and exposing a shared model can lead to leaking part of that model
    to consumers, for example exposing properties that shouldn’t be, exposing the
    whole domain model as output, or the very worst, exposing it as an input and opening
    exploitable holes and unexpected bugs.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种设计可以是非常有帮助的，也可以是不受欢迎的。过多的项目依赖于并暴露共享模型可能会导致模型的一部分泄露给消费者，例如暴露不应暴露的属性，暴露整个领域模型作为输出，或者最糟糕的是，将其作为输入并打开可利用的漏洞和意外的错误。
- en: ''
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Be careful not to expose your shared model to the presentation layer consumers.
  id: totrans-210
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，不要将共享模型暴露给表示层消费者。
- en: 'Pushing logic into the model is not always possible or desirable, which is
    why we are exploring multiple types of domain models and ways to share them. Making
    a good design is often about options and deciding what option to use for each
    scenario. There are also tradeoffs to make between flexibility and robustness.The
    rest of the code is similar to the abstract layer project. Feel free to explore
    the source code ([https://adpg.link/9F5C](https://adpg.link/9F5C)) and compare
    it with the other projects. The best way to learn is to practice, so play with
    the samples, add features, update the current features, remove stuff, or even
    build your own project. Understanding these concepts will help you apply them
    to different scenarios, sometimes creating unexpected but efficient constructs.Now,
    let’s look at the final evolution of layering: Clean Architecture.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 将逻辑推入模型并不总是可能或理想的，这就是为什么我们要探索多种类型的领域模型和共享它们的方式。做出良好的设计通常关于选择和决定每个场景使用哪种选项。在灵活性和健壮性之间也需要做出权衡。其余的代码与抽象层项目类似。您可以自由地探索源代码（[https://adpg.link/9F5C](https://adpg.link/9F5C)）并将其与其他项目进行比较。最好的学习方法是实践，所以请玩转这些示例，添加功能，更新当前功能，删除内容，甚至构建您自己的项目。理解这些概念将帮助您将它们应用于不同的场景，有时会创建出人意料的但效率很高的结构。现在，让我们看看分层结构的最终演变：清洁架构。
- en: Clean Architecture
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清洁架构
- en: 'Now that we’ve covered many layering approaches, it is time to combine them
    into **Clean Architecture**, also known as Hexagonal Architecture, Onion Architecture,
    Ports and Adapters, and more. Clean Architecture is an evolution of the layers,
    a way of organizing the relationships between the layers, yet very similar to
    what we just built. Instead of presentation, domain, and data (or persistence),
    Clean Architecture suggests **UI**, **Core**, and **Infrastructure**.As we saw
    previously, we can design a layer containing abstractions or implementations.
    When implementations depend only on abstractions, that inverts dependency flow.
    Clean Architecture emphasizes such layers but with its own guidance about organizing
    them.We also explored the theoretical concept of breaking layers into smaller
    ones (or multiple projects), thus creating “fractured layers” that are easier
    to port and reuse. Clean Architecture leverages that concept at the infrastructure
    layer level.There are probably as many points of view and variants of this as
    there are names for it, so I’ll try to be as general as possible while keeping
    the essence. By doing this, if you are interested in this type of architecture,
    you can pick a resource and dig deeper into it, following the style you prefer.Let’s
    take a look at a diagram that resembles what we can find online:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了许多分层方法，是时候将它们结合成**清洁架构**，也称为六边形架构、洋葱架构、端口和适配器等。清洁架构是层的一个进化，是组织层之间关系的一种方式，但与我们刚刚构建的非常相似。清洁架构建议用**UI**、**核心**和**基础设施**来代替展示、领域和数据（或持久化）。正如我们之前看到的，我们可以设计一个包含抽象或实现的层。当实现只依赖于抽象时，这就反转了依赖流。清洁架构强调这样的层，但有自己的组织指导。我们还探讨了将层分割成更小层（或多个项目）的理论概念，从而创建了更容易移植和重用的“破碎层”。清洁架构在基础设施层级别利用了这一概念。关于它的观点和变体可能和它的名称一样多，所以我会尽量保持普遍性，同时保留其本质。通过这样做，如果你对这种架构感兴趣，你可以选择一个资源，按照你喜欢的风格深入挖掘。让我们看看一个类似于我们在网上可以找到的图：
- en: '![Figure 14.12: A diagram representing the most basic Clean Architecture layout](img/file86.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12：表示最基本清洁架构布局的图](img/file86.png)'
- en: 'Figure 14.12: A diagram representing the most basic Clean Architecture layout'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12：表示最基本清洁架构布局的图
- en: 'From a layering diagram-like standpoint, the preceding diagram could look like
    this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从类似分层图的视角来看，前面的图可能看起来是这样的：
- en: '![Figure 14.13: A two-layer view of the previous Clean Architecture diagram](img/file87.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.13：先前清洁架构图的两层视图](img/file87.png)'
- en: 'Figure 14.13: A two-layer view of the previous Clean Architecture diagram'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13：先前清洁架构图的两层视图
- en: 'Depending on your chosen method, you can split those layers into multiple other
    sublayers. One thing that we often see is dividing the **Core** layer into **Entities**
    and **Use cases**, like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你选择的方法，你可以将这些层分割成多个其他子层。我们经常看到的一种做法是将**核心**层分割成**实体**和**用例**，如下所示：
- en: '![Figure 14.14: Widespread Clean Architecture layout diagram](img/file88.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.14：广泛应用的清洁架构布局图](img/file88.png)'
- en: 'Figure 14.14: Widespread Clean Architecture layout diagram'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14：广泛应用的清洁架构布局图
- en: 'Since people in the tech industry are creative, there are many names for many
    things, but the concepts remain the same. From a layering diagram-like standpoint,
    that diagram could look like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于科技行业的人富有创造力，许多事物都有很多名称，但概念保持不变。从类似分层图的视角来看，那个图可能看起来是这样的：
- en: '![Figure 14.15: A layer-like view of the previous Clean Architecture diagram](img/file89.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.15：先前清洁架构图的类似层视图](img/file89.png)'
- en: 'Figure 14.15: A layer-like view of the previous Clean Architecture diagram'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.15：先前清洁架构图的类似层视图
- en: 'The infrastructure layer is conceptual and can represent multiple projects,
    such as an infrastructure assembly containing EF Core implementations and a website
    project representing the web UI. We could also add more projects to the infrastructure
    layer.The dependency rule of Clean Architecture states that dependencies can only
    point inward, from the outer layers to the inner layers. This means that abstractions
    lie inside, and concretions lie outside. Based on the preceding layer-like diagram,
    inside translates to downward. That means a layer can use any direct or transitive
    dependencies, which means that infrastructure can depend on use cases and entities.Clean
    Architecture follows all the principles that we’ve been discussing since the beginning
    of this book, such as decoupling our implementations using abstractions, dependency
    inversion, and separation of concerns. These implementations are glued over abstractions
    using dependency injection (this is not mandatory, but it helps).I’ve always found
    those circle diagrams a bit confusing, so here is my take on an updated, more
    linear diagram:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施层是概念性的，可以代表多个项目，例如包含 EF Core 实现的基础设施组件和一个代表 Web UI 的网站项目。我们还可以将更多项目添加到基础设施层。Clean
    Architecture 的依赖规则指出，依赖只能指向内层，即从外层到内层。这意味着抽象位于内部，具体实现位于外部。根据前面的层状图，内部对应向下。这意味着一个层可以使用任何直接或间接的依赖，这意味着基础设施可以依赖于用例和实体。Clean
    Architecture 遵循自本书开始以来我们一直在讨论的所有原则，例如使用抽象解耦我们的实现、依赖反转和关注点分离。这些实现通过依赖注入粘合在抽象之上（这不是强制性的，但有助于）。我总是觉得那些圆形图有点令人困惑，所以这里是我对更新后的、更线性的图示的看法：
- en: '![Figure 14.16: A two-layer view of Clean Architecture’s common elements](img/file90.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.16：Clean Architecture 常见元素的两层视图](img/file90.png)'
- en: 'Figure 14.16: A two-layer view of Clean Architecture’s common elements'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.16：Clean Architecture 常见元素的两层视图
- en: 'Now, let’s revisit our layered application using Clean Architecture, starting
    with the **core layer**. The core project contains the domain model, the use cases
    (services), and the interfaces needed to fulfill those use cases. We must not
    access external resources in this layer: no database calls, disk access, or HTTP
    requests. This layer contains the interfaces that expose such interaction, but
    the implementations live in the **infrastructure layer**.The presentation layer
    was renamed `Web` and lives in the outer layer with the EF Core implementation.
    The `Web` project depends only on the `Core` project. Once again, since the composition
    root is in this project, it must load the EF Core implementation project to configure
    the IoC container.Here is a diagram representing the relation between the shared
    model and the new Clean Architecture project structure:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Clean Architecture 重新审视我们的分层应用程序，从**核心层**开始。核心项目包含领域模型、用例（服务）以及满足这些用例所需的接口。我们在这个层中不能访问外部资源：没有数据库调用、磁盘访问或
    HTTP 请求。这个层包含暴露此类交互的接口，但实现部分位于**基础设施层**。表示层被重命名为 `Web` 并位于外层，与 EF Core 实现一起。`Web`
    项目只依赖于 `Core` 项目。由于组合根位于此项目，它必须加载 EF Core 实现项目以配置 IoC 容器。以下是表示共享模型与新的 Clean Architecture
    项目结构之间关系的图示：
- en: '![Figure 14.17: From shared project to the Clean Architecture project structure](img/file91.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.17：从共享项目到 Clean Architecture 项目结构](img/file91.png)'
- en: 'Figure 14.17: From shared project to the Clean Architecture project structure'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.17：从共享项目到 Clean Architecture 项目结构
- en: In the preceding diagram, we took the center of the classic layered solution
    and merged the layers into a single `Core` project.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们将经典分层解决方案的中心合并为一个单独的 `Core` 项目。
- en: 'Here’s the link to this project on GitHub: [https://adpg.link/rT1P](https://adpg.link/rT1P).'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是 GitHub 上此项目的链接：[https://adpg.link/rT1P](https://adpg.link/rT1P)。
- en: 'Most of the code is not that relevant since, once again, the most significant
    aspect is the dependency flow and relationships between projects. Nonetheless,
    here is a list of changes that I made aside from moving the pieces to different
    projects:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码并不那么相关，因为，再次强调，最重要的方面是项目之间的依赖流和关系。尽管如此，以下是我除了将组件移动到不同的项目之外所做的更改列表：
- en: 'I removed the `ProductService` class and `IProductService` interface and used
    the `IProductRepository` interface directly from the `StockService` class (`Core`
    project) and the `/products` endpoint (`Web` project: `Program.cs`).'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我移除了`ProductService`类和`IProductService`接口，并直接从`StockService`类（`Core`项目）和`/products`端点（`Web`项目：`Program.cs`）使用了`IProductRepository`接口。
- en: 'I removed the `IStockService` interface, and now both the add and remove stocks
    endpoints (`Web` project: `Program.cs`) depend directly on the `StockService`
    class.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我移除了`IStockService`接口，现在添加和删除股票的端点（`Web`项目：`Program.cs`）都直接依赖于`StockService`类。
- en: 'Why use the `IProductRepository` interface directly, you might wonder? Since
    the `Web` project (**infrastructure layer**) depends on the **core layer**, we
    can leverage the inward dependency flow. It is acceptable to use a repository
    directly as long as the feature has no business logic. Programming empty shells
    and pass-through services adds useless complexity. However, when business logic
    starts to be involved, create a service or any other domain entity you deem necessary
    for that scenario. Don’t pack business logic into your controllers or minimal
    API delegates.I removed the `IStockService` interface since the `StockService`
    class contains concrete business rules that can be consumed as is from the infrastructure
    layer. I know we have emphasized using interfaces since the beginning of the book,
    but I also often said that principles are not laws. All in all, there is nothing
    to abstract away: if the business rules change, the old ones won’t be needed anymore.
    On the other hand, we could have kept the interface.To wrap this up, Clean Architecture
    is a proven pattern for building applications that is fundamentally an evolution
    of layering. Many variants can help you manage use cases, entities, and infrastructure;
    however, we will not cover those here. There are many open-source projects to
    start with Clean Architecture if you seek organizational guidance.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，为什么直接使用`IProductRepository`接口？由于`Web`项目（**基础设施层**）依赖于**核心层**，我们可以利用内向依赖流。只要功能没有业务逻辑，直接使用存储库是可以接受的。编写空壳和透明服务只会增加无用的复杂性。然而，当业务逻辑开始涉及时，为该场景创建一个服务或任何其他必要的领域实体。不要将业务逻辑打包到你的控制器或最小API代表中。我移除了`IStockService`接口，因为`StockService`类包含可以原样从基础设施层消费的具体业务规则。我知道我们从本书开始就强调了使用接口，但我经常说原则不是法律。总的来说，没有什么可以抽象的：如果业务规则发生变化，旧规则将不再需要。另一方面，我们本可以保留接口。
- en: I left a few links in the *Further reading* section.
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在*进一步阅读*部分留下了一些链接。
- en: If you think this is a great fit for you, your team, your project, or your organization,
    feel free to dig deeper and adopt this pattern. In subsequent chapters, we explore
    some patterns, such as CQRS, Publish-Subscribe, and feature-based design, which
    we can combine with Clean Architecture to add flexibility and robustness. These
    become particularly useful as your system grows in size and complexity.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这非常适合你、你的团队、你的项目或你的组织，请随意深入了解并采用这种模式。在随后的章节中，我们将探讨一些模式，例如CQRS、发布-订阅和基于特性的设计，这些模式我们可以与Clean
    Architecture结合使用，以增加灵活性和健壮性。当你的系统规模和复杂性增长时，这些尤其有用。
- en: Implementing layering in real life
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结来说，Clean Architecture是一个经过验证的应用程序构建模式，其本质上是分层的一个演变。许多变体可以帮助你管理用例、实体和基础设施；然而，我们在这里不会涉及这些。如果你寻求组织指导，有许多开源项目可以从Clean
    Architecture开始。
- en: Now that we covered all of this, it is important to note that on the one hand,
    there is the theory, and on the other, life is hitting you in the face. Suppose
    you are working in a big enterprise. In that case, chances are your employer can
    pour hundreds of thousands or even millions of dollars into a feature to run experiments,
    spend months designing every little piece, and ensure everything is perfect. Even
    then, is achieving perfection even possible? Probably not.For companies that don’t
    have that type of capital, you must build entire products for a few thousand dollars
    sometimes because they are not trying to resell them but just need that tool built.
    That is where your architectural skills come in handy. How do you design the least-worst
    product in a maintainable fashion while meeting stakeholders' expectations? The
    most important part of the answer is to set expectations upfront. Moreover, never
    forget that someone needs to maintain and change the software over time; no software
    does not evolve; there’s always something.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了所有这些，重要的是要注意，一方面，有理论，另一方面，生活正在向你脸上打。假设你在一家大企业工作。那么，你的雇主可能会投入数十万甚至数百万美元来运行实验，花几个月时间设计每一个小细节，并确保一切完美。即使如此，实现完美甚至可能吗？可能不可能。对于没有那种资本的公司，有时你必须用几千美元构建整个产品，因为它们不是试图转售它们，只是需要构建那个工具。这就是你的架构技能派上用场的时候。你如何以可维护的方式设计最不差的产品，同时满足利益相关者的期望？答案最重要的部分是提前设定期望。此外，永远不要忘记，随着时间的推移，有人需要维护和更改软件；没有软件不会发展；总有东西。
- en: If you are in a position where you must evaluate the feasibility of products
    and features in this context, setting expectations lower can be a good way to
    plan for the unplannable. It is easier to overdeliver than justify why you underdelivered.
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你处于必须评估在此背景下产品特性可行性的位置，降低期望可以是一个为不可预见的事情做计划的好方法。超预期比解释为什么你未能达到预期要容易。
- en: Let’s dig deeper into this and look at a few tricks to help you out. Even if
    you are working for a larger enterprise, you should get something out of it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这个问题，并看看一些可以帮助你的技巧。即使你在一个大型企业工作，你也应该从中得到一些收获。
- en: To be or not to be a purist?
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 要成为纯粹主义者，还是不要成为纯粹主义者？
- en: 'In your day-to-day work, you may not always need the rigidity of a **domain
    layer** to create a wall in front of your data. Maybe you just don’t have the
    time or the money, or it’s just not worth doing.Taking and presenting the data
    can often work well enough, especially for simple data-driven applications that
    are only a user interface over a database, as is the case for many internal tools.The
    answer to the *“To be or not to be a purist?”* question is: it depends!'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的日常工作中，你可能并不总是需要**领域层**的刚性来在你的数据前建立一堵墙。也许你没有时间或金钱，或者这根本不值得做。获取并展示数据通常已经足够好，特别是对于只是数据库上的用户界面的简单数据驱动应用程序，就像许多内部工具那样。对*“要成为纯粹主义者，还是不要成为纯粹主义者？”*这个问题的答案是：这取决于！
- en: This section covers layering, but we explore other patterns that are feature-oriented,
    so I suggest you continue reading and explore using the techniques from *Chapter
    17*, *Vertical Slice Architecture*, *Chapter 18*, *Request-EndPoint-Response (REPR)*,
    and *Chapter 20*, *Modular Monolith*, to improve your design while keeping the
    design overhead low.
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本节涵盖了分层，但我们还探讨了其他面向特性的模式，因此我建议你继续阅读并探索使用第17章的技巧，即*垂直切片架构*，第18章的*请求-端点-响应（REPR）*，以及第20章的*模块化单体*，以在保持设计开销低的同时改进你的设计。
- en: 'Here are a few examples of things that the answer depends on, to help you out:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子，这些例子的答案取决于什么，以帮助你：
- en: 'The project; for example:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目；例如：
- en: '**Domain-heavy or logic-intensive projects** will benefit from a domain layer,
    helping you centralize parts for an augmented level of reusability and maintainability.'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域密集型或逻辑密集型项目**将从领域层中受益，帮助你集中部分以实现更高程度的可重用性和可维护性。'
- en: '**Data management projects** tend to have less or no logic in them. We can
    often build them without adding a domain layer as the **domain** is often only
    a tunnel from the **presentation** to the **data**; a pass-through layer. We can
    often simplify those systems by dividing them into two layers: **data** and **presentation**.'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据管理项目**往往逻辑较少或没有逻辑。我们通常可以不添加领域层来构建它们，因为**领域**通常只是从**表示层**到**数据**的一个隧道；一个透传层。我们通常可以通过将它们分为两层来简化这些系统：**数据**和**表示**。'
- en: Your team; for example, a highly skilled team may tend to use advanced concepts
    and patterns more efficiently, and the learning curve for newcomers should be
    easier due to the number of seasoned engineers that can support them on the team.
    This does not mean that less skilled teams should aim lower; on the contrary,
    it may just be harder or take longer to start. Analyze each project individually
    and find the best patterns to drive them accordingly.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的团队；例如，一个技术能力很强的团队可能会更有效地使用高级概念和模式，并且由于团队中有经验丰富的工程师可以支持他们，新来者的学习曲线应该更容易。这并不意味着技术能力较弱的团队应该降低目标；相反，这可能只是更难或需要更长的时间才能开始。分析每个项目，并找到相应的最佳模式。
- en: Your boss; if the company you work for puts pressure on you and your team to
    deliver complex applications in record time and nobody tells your boss that it
    is impossible, you may need to cut corners a lot and enjoy many maintenance headaches
    with crashing systems, painful deployments, and more. That being said, if it is
    inevitable for these types of projects, I’d go with a very simple design that
    does not aim at reusability—aim at low-to-average testability and code stuff that
    just works.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的老板；如果你的公司给你和你的团队施加压力，要求在创纪录的时间内交付复杂的应用程序，而没有人告诉你的老板这是不可能的，你可能需要大量削减边缘，并享受许多维护头痛，包括崩溃的系统、痛苦的部署等等。话虽如此，如果这些类型的项目不可避免，我会选择一个非常简单的设计，不追求可重用性——追求低到平均的可测试性和仅能正常工作的代码。
- en: Your budget; once again, this often depends on the people selling the application
    and the features. I saw promises that were impossible to keep but delivered anyway
    with a lot of effort, extra hours, and corner-cutting. The thing to remember when
    going down that path is that at some point, there is no return from the accumulated
    **technical debt**, and it will just get worse (this applies to all budgets).
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的预算；再次强调，这通常取决于销售应用和功能的人。我看到了一些不可能实现的承诺，但仍然通过大量的努力、额外的时间和削减边缘实现了。当你走这条路时，要记住的是，在某个时候，累积的技术债务将无法偿还，并且只会变得更糟（这适用于所有预算）。
- en: 'The audience; the people who use the software can make a big difference to
    how you build it: ask them. For example, suppose you are building a tool for your
    fellow developers. In that case, you can cut corners that you would not for less
    technically skilled users (like delivering a CLI tool instead of a full-blown
    user interface). On the other hand, if you’re aiming your application at multiple
    clients (web, mobile, and so on), isolating your application’s components and
    focusing on reusability could be a winning design.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标受众；使用该软件的人会对你的构建方式产生重大影响：询问他们。例如，假设你正在为你的同行开发者构建一个工具。在这种情况下，你可以削减你不会为技术能力较低的用户（如提供命令行工具而不是完整的用户界面）所采取的边缘。另一方面，如果你将你的应用针对多个客户端（网页、移动设备等），隔离你的应用组件并专注于可重用性可能是一个获胜的设计。
- en: The expected quality; you should not tackle the problem in the same way for
    building a prototype and a SaaS application. It is acceptable, even encouraged,
    for a prototype to have no tests and not follow best practices, but I’d recommend
    the opposite for a production-quality application.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期的质量；在构建原型和SaaS应用时，你不应该以相同的方式处理问题。对于原型来说，没有测试和不遵循最佳实践是可以接受的，甚至是鼓励的，但我建议对于生产质量的应用则相反。
- en: 'Any other things that life throws at you; yes, life is unpredictable, and no
    one can cover every possible scenario in a book, so just keep the following in
    mind when building your next piece of software:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生活中抛给你的其他事情；是的，生活是不可预测的，没有人能在书中涵盖所有可能的场景，所以当你构建下一个软件时，请记住以下几点：
- en: Do not over-engineer your applications.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要过度设计你的应用。
- en: Only implement features that you need, not more, as per the **you aren’t gonna
    need it** (**YAGNI**) **principle.**
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅实现你需要的功能，不要更多，按照**你不是真的需要它**（**YAGNI**）原则。
- en: '***   Use your judgment and take the less-worst options; there is no perfect
    solution.**'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '***   使用你的判断力，选择最不糟糕的选项；没有完美的解决方案。**'
- en: '**I hope you found this guidance helpful and that it will serve you in your
    career.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**我希望你发现这些指导有帮助，并且它将在你的职业生涯中为你服务。**'
- en: Building a façade over a database
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在数据库之上构建一个外观
- en: 'Data-driven programs are a type of software that I often see in smaller enterprises.
    Those companies need to support their day-to-day operations with computers, not
    the other way around. Every company needs internal tools, and many needed them
    yesterday.The reason is simple; every company is unique. Because it’s unique,
    due to its business model, leadership, or employees, it also needs unique tools
    to help with its day-to-day operations. Those small tools are often simple user
    interfaces over a database, controlling access to that data. In these cases, you
    don’t need over-engineered solutions, as long as everyone is informed that the
    tool will not evolve beyond what it is: a small tool.In real life, this one is
    tough to explain to non-programmers because they tend to see complex use cases
    as easy to implement and simple use cases as hard to implement. It’s normal; they
    just don’t know, and we all don’t know something. In these scenarios, a big part
    of our job is also to educate people. Advising decision-makers about the differences
    in quality between a small tool and a large business application. Educating and
    working with stakeholders makes them aware of the situation and make decisions
    with you, leading to higher project quality that meets everyone’s expectations.
    This can also reduce the “*it’s not my fault*” syndrome from both sides.I’ve found
    that immersing customers and decision-makers in the decision process and having
    them follow the development cycle helps them understand the reality behind the
    programs and helps both sides stay happy and grow more satisfied. Stakeholders
    not getting what they want is no better than you being super stressed over unreachable
    deadlines.That said, our educational role does not end with decision-makers. Teaching
    new tools and techniques to your peers is also a major way to improve your team,
    peers, and yourself. Explaining concepts is not always as easy as it sounds.Nevertheless,
    data-driven programs may be hard to avoid, especially if you are working for SMEs,
    so try to get the best out of it. Nowadays, with low-code and no-code solutions
    and all the open-source libraries, you might be able to save yourself a lot of
    this kind of trouble, but maybe not all.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 数据驱动型程序是我经常在小型企业中看到的一种软件类型。那些公司需要用计算机来支持他们的日常运营，而不是反过来。每个公司都需要内部工具，许多公司昨天就需要它们。原因很简单；每个公司都是独特的。正因为如此，由于它的商业模式、领导层或员工，它也需要独特的工具来帮助其日常运营。这些小型工具通常是数据库上的简单用户界面，控制对数据的访问。在这些情况下，你不需要过度设计的解决方案，只要每个人都清楚这个工具不会发展到它所不是的东西：一个简单的工具。在现实生活中，这个概念对非程序员来说很难解释，因为他们往往认为复杂的使用案例容易实现，而简单的使用案例难以实现。这是正常的；他们只是不知道，我们也都不知道某些事情。在这些情况下，我们工作的很大一部分也是教育人们。向决策者建议小型工具和大型商业应用之间的质量差异。教育和与利益相关者合作使他们意识到情况，并与你一起做出决策，从而提高项目质量，满足每个人的期望。这也可以减少双方的“*这不是我的错*”综合症。我发现，让客户和决策者沉浸在决策过程中，并让他们跟随开发周期，有助于他们了解程序背后的现实，并使双方保持愉快并更加满意。利益相关者得不到他们想要的东西，并不比你因为无法达到的截止日期而极度紧张更好。话虽如此，我们的教育角色并不局限于决策者。向你的同事传授新工具和技术也是提高你的团队、同事和自己的主要方式之一。解释概念并不总是像听起来那么容易。尽管如此，数据驱动型程序可能难以避免，尤其是如果你在为中小企业工作，所以尽量从中获得最佳效果。如今，随着低代码和无代码解决方案以及所有开源库的出现，你可能会节省很多这种麻烦，但也许不是全部。
- en: Remember that someday, someone must maintain those small tools. Think of that
    person as you, and think about how you’d like some guidelines or documentation
    to help you. I’m not saying to over-document projects, as documentation often
    gets out of sync with the code and becomes more of a problem than a solution.
    However, a simple `README.md` file at the project's root explaining how to build
    and run the program and some general guidelines could be beneficial. Always think
    about documentation as if you were the one reading it. Most people don’t like
    to spend hours reading documentation to understand something simple, so keep it
    simple.
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住，总有一天，有人必须维护那些小型工具。想象一下那个人就是你自己，并思考你希望有一些指南或文档来帮助你。我并不是说过度文档化项目，因为文档往往与代码不同步，反而变成了问题而不是解决方案。然而，在项目根目录下有一个简单的
    `README.md` 文件，解释如何构建和运行程序以及一些一般性指南，这可能会很有帮助。始终以你自己在阅读文档时的角度来考虑文档。大多数人不喜欢花几个小时阅读文档来理解一些简单的东西，所以请尽量保持简单。
- en: When building a *façade over a database*, you want to keep it simple. Also,
    you should make it clear that it should not evolve past that role. One way to
    build this would be to use EF Core as your data layer and scaffold an MVC application
    as your presentation layer, shielding your database. You can use the built-in
    ASP.NET Core authentication and authorization mechanism if you need access control.
    You can then choose role-based or policy-based access control or any other way
    that makes sense for your tool and allows you to control access to the data the
    way you need to.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当在数据库上构建一个*门面*时，你希望保持其简单性。此外，你应该明确指出它不应超出那个角色。构建这种结构的一种方法是将 EF Core 作为你的数据层，并搭建一个
    MVC 应用程序作为你的展示层，以保护你的数据库。如果你需要访问控制，可以使用内置的 ASP.NET Core 身份验证和授权机制。然后你可以选择基于角色的或基于策略的访问控制，或者任何对你工具有意义的其他方式，允许你以你需要的方式控制对数据的访问。
- en: Keeping it simple should help you build more tools in less time, making everyone
    happy.
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 保持简单可以帮助你在更短的时间内构建更多工具，让每个人都满意。
- en: 'From a layering standpoint, using my previous example, you will end up having
    two layers sharing the data model:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从分层角度来看，使用我之前的例子，你最终会拥有两个共享数据模型层：
- en: '![Figure 14.18: A façade-like presentation layer over a database application’s
    design](img/file92.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.18：数据库应用程序设计上的门面式展示层](img/file92.png)'
- en: 'Figure 14.18: A façade-like presentation layer over a database application’s
    design'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.18：数据库应用程序设计上的门面式展示层
- en: Nothing stops you from creating a **view model** here and there for more complex
    views, but the key is to keep the logic’s complexity to a minimum. Otherwise,
    you may discover the hard way that sometimes, rewriting a program from scratch
    takes less time than trying to fix it. Moreover, nothing stops you from using
    any other presentation tools and components available to you.Using this data-driven
    architecture as a temporary application while the main application is in development
    is also a good solution. It takes a fraction of the time to build, and the users
    have access to it immediately. You can even get feedback from it, which allows
    you to fix any mistakes before they are implemented in the real (future) application,
    working like a living prototype.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里到处创建一个**视图模型**来处理更复杂的视图，但关键是要将逻辑的复杂性降到最低。否则，你可能会发现，从头开始重写一个程序有时比试图修复它要快。此外，你也可以使用你拥有的任何其他展示工具和组件。在主应用程序开发期间，使用这个数据驱动架构作为临时应用程序也是一个好办法。它构建所需的时间非常少，用户可以立即访问它。你甚至可以从它那里获得反馈，这让你有机会在它们被实际（未来）应用程序实现之前修复任何错误，就像一个活生生的原型一样。
- en: A good database design in these sorts of applications can go a long way.
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这类应用程序中，良好的数据库设计可以走得很远。
- en: Not all projects are that simple, but still, many are; the key is to make the
    program good enough while ensuring you cut the right corners. The presentation
    layer in these types of applications could leverage a low-code solution such as
    Power Apps, for example.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有项目都那么简单，但仍然，许多是；关键是确保程序足够好，同时确保你切对了角。在这些类型的应用程序中，展示层可以利用低代码解决方案，例如 Power
    Apps。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Layering is one of the most used architectural techniques when it comes to
    designing applications. An application is often split into multiple different
    layers, each managing a single responsibility. The three most popular layers are
    **presentation**, **domain**, and **data**. You are not limited to three layers;
    you can split each into smaller layers (or smaller pieces inside the same conceptual
    layer), leading to composable, manageable, and maintainable applications.Moreover,
    you can create abstraction layers to invert the flow of dependency and separate
    interfaces from implementations, as we saw in the *Abstract layers* section. You
    can persist the domain entities directly or create an independent model for the
    data layer. You can also use an anemic model (no logic or method) or a rich model
    (packed with entity-related logic). You can share that model between multiple
    layers or have each layer possess its own.Out of layering was born Clean Architecture,
    which guides organizing your application into concentric layers, often dividing
    the application into use cases.Let’s see how this approach can help us move toward
    the **SOLID** principles at app scale:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 分层是设计应用程序时最常用的架构技术之一。应用程序通常被分割成多个不同的层，每个层管理单一的责任。最流行的三个层是**表示层**、**领域层**和**数据层**。你不必局限于三个层；你可以将每个层分割成更小的层（或同一概念层内的更小块），从而得到可组合、可管理和可维护的应用程序。此外，你可以创建抽象层来反转依赖流，并将接口与实现分离，正如我们在*抽象层*部分所看到的。你可以直接持久化领域实体或为数据层创建一个独立的模型。你也可以使用贫血模型（没有逻辑或方法）或丰富的模型（包含与实体相关的逻辑）。你可以将此模型在多个层之间共享，或者让每个层拥有自己的模型。从分层中诞生了Clean
    Architecture，它指导我们将应用程序组织成同心层，通常将应用程序分割成用例。让我们看看这种方法如何帮助我们朝着**SOLID**原则在应用规模上前进：
- en: '**S**: Layering leads us toward splitting responsibilities horizontally, with
    each layer oriented around a single macro-concern. The main goal of layering is
    responsibility segregation.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：分层引导我们水平分割责任，每个层围绕一个单一宏观关注点。分层的主要目标是责任分割。'
- en: '**O**: Abstract layers enable consumers to act differently (change behaviors)
    based on the provided implementation (concrete layer).'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：抽象层使消费者能够根据提供的实现（具体层）采取不同的行动（改变行为）。'
- en: '**L**: N/A'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：N/A'
- en: '**I**: Splitting layers based on features (or cohesive groups of features)
    is a way of segregating a system into smaller blocks (interfaces).'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：根据特征（或特征的一致组）分割层是一种将系统分割成更小块（接口）的方法。'
- en: '**D**: Abstraction layers lead directly to the dependency flow’s inversion,
    while classic layering leads in the opposite direction.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：抽象层直接导致依赖流反转，而经典分层则朝相反方向进行。'
- en: In the next chapter, we learn how to centralize the logic of copying objects
    (models) using object mappers and an open-source tool to help us skip the implementation,
    also known as productive laziness.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用对象映射器和开源工具集中化复制对象（模型）的逻辑，以帮助我们跳过实现，也称为生产性懒惰。
- en: Questions
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习题：
- en: When creating a layered application, is it true that we must have presentation,
    domain, and data layers?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当创建分层应用程序时，我们是否必须拥有表示层、领域层和数据层？
- en: Is a rich domain model better than an anemic domain model?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 丰富的领域模型是否比贫血领域模型更好？
- en: Does EF Core implement the Repository and Unit of Work patterns?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: EF Core是否实现了仓储和单元工作模式？
- en: Do we need to use an ORM in the data layer?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否需要在数据层使用ORM？
- en: Can a layer in Clean Architecture access any inward layers?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Clean Architecture中的层能否访问任何内部层？
- en: Further reading
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are a few links to help you build on what we learned in this chapter:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接可以帮助你巩固本章所学的内容：
- en: '**Dapper** is a simple yet powerful ORM for .NET, made by the people of Stack
    Overflow. If you like writing SQL, but don’t like mapping data to objects, this
    ORM might be for you: [https://adpg.link/pTYs](https://adpg.link/pTYs).'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dapper** 是由Stack Overflow的人制作的.NET的一个简单而强大的ORM，如果你喜欢写SQL，但不喜欢将数据映射到对象，这个ORM可能适合你：[https://adpg.link/pTYs](https://adpg.link/pTYs)。'
- en: 'An article that I wrote in 2017, talking about the Repository pattern; that
    is, « Design Patterns: ASP.NET Core Web API, services, and repositories | Part
    5: Repositories, the ClanRepository, and integration testing »: [https://adpg.link/D53Z](https://adpg.link/D53Z).'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我在2017年写的一篇文章，讨论了仓储模式；即「设计模式：ASP.NET Core Web API、服务和仓储 | 第5部分：仓储、ClanRepository和集成测试」：[https://adpg.link/D53Z](https://adpg.link/D53Z)。
- en: 'Entity Framework Core – Using Transactions: [https://adpg.link/gxwD](https://adpg.link/gxwD).'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Entity Framework Core – 使用事务: [https://adpg.link/gxwD](https://adpg.link/gxwD).'
- en: 'Here are resources about Clean Architecture:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一些关于 Clean Architecture 的资源：
- en: 'Common web application architectures (Microsoft Learn): [https://adpg.link/Pnpn](https://adpg.link/Pnpn)'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '常见网络应用架构（Microsoft Learn）: [https://adpg.link/Pnpn](https://adpg.link/Pnpn)'
- en: 'Microsoft eShopOnWeb ASP.NET Core Reference Application: [https://adpg.link/dsw1](https://adpg.link/dsw1)'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Microsoft eShopOnWeb ASP.NET Core 参考应用: [https://adpg.link/dsw1](https://adpg.link/dsw1)'
- en: 'GitHub—Clean Architecture (Ardalis/Steve Smith)—Solution templates: [https://adpg.link/tpPi](https://adpg.link/tpPi)'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GitHub—Clean Architecture (Ardalis/Steve Smith)—解决方案模板: [https://adpg.link/tpPi](https://adpg.link/tpPi)'
- en: 'GitHub—Clean Architecture (Jason Taylor)—Solution templates: [https://adpg.link/jxX2](https://adpg.link/jxX2)'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GitHub—Clean Architecture (Jason Taylor)—解决方案模板: [https://adpg.link/jxX2](https://adpg.link/jxX2)'
- en: Answers
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: No, you can have as many layers as you need and name and organize them as you
    want.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，你可以根据需要拥有任意多的层，并且可以按自己的意愿命名和组织它们。
- en: No, both have their place, their pros, and their cons.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，两者都有其位置、优点和缺点。
- en: Yes. A `DbContext` is an implementation of the Unit of Work pattern. `DbSet<T>`
    is an implementation of the Repository pattern.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的。`DbContext` 是工作单元模式的实现。`DbSet<T>` 是仓储模式的实现。
- en: No, you can query any system in any way you want. For example, you could use
    ADO.NET to query a relational database, manually create the objects using a `DataReader`,
    track changes using a `DataSet`, or do anything else that fits your needs. Nonetheless,
    ORMs can be very convenient.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不，你可以以任何你想要的方式查询任何系统。例如，你可以使用 ADO.NET 查询关系数据库，手动使用 `DataReader` 创建对象，使用 `DataSet`
    跟踪更改，或者做任何满足你需求的事情。尽管如此，ORMs 可以非常方便。
- en: Yes. A layer can never access outward layers, only inward ones.****
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的。一层永远不能访问外层，只能访问内层。****
