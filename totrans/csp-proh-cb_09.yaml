- en: Chapter 9. Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Regular Expressions** (**regex**) are somewhat of a mystery for many developers.
    We admit that they are something that we use often enough to warrant a deeper
    understanding of how they work. On the flip side, there are so many tried and
    tested regex patterns on the Internet that just reusing one that already exists
    is most times easier than trying to create one yourself. The subject of regex
    is much larger than what can be explained in a single chapter in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in this chapter, we will merely introduce some of the concepts of
    regex. For a deeper understanding of regex, further study is needed. For the purpose
    of this book, however, we will take a closer look at how regex are created and
    how they can be applied to some common programming problems. In this chapter,
    we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with regex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching a valid date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanitizing input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic regex matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A regex is a pattern that describes a string through the use of special characters
    that denote a specific bit of text to match. The use of regex is not a new concept
    in programming. For regex to work, they need to use a regex engine that does all
    the heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: In the .NET Framework, Microsoft has provided for the use of regex. To use regex,
    you will need to import the `System.Text.RegularExpressions` assembly to your
    project. This will allow the compiler to use your regex pattern and apply it to
    the specific text you need to match.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, regex have a specific set of metacharacters that hold special meaning
    to the Regex engine. These characters are `[ ]`, `{ }`, `( )`, `*`, `+`, `\`,
    `?`, `|`, `$`, `.` and, `^`.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the curly brackets `{ }`, for example, enables developers to specify
    the number of times a specific set of characters need to occur. Using square brackets,
    on the other hand, defines exactly what needs to be matched.
  prefs: []
  type: TYPE_NORMAL
- en: If we, for example, specified `[abc]`, the pattern would look for lowercase
    As, Bs, and Cs. Regex, therefore, also allows you to define a range, for example,
    `[a-c]`, which is interpreted in exactly the same way as the `[abc]` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Regex then also allow you to define characters to exclude by using the `^` character.
    Therefore, typing `[^a-c]` would find lowercase D through Z because the pattern
    is telling the regex engine to exclude lowercase As, Bs, and Cs.
  prefs: []
  type: TYPE_NORMAL
- en: Regex also define `\d` and `\D` as types of shortcut for `[0-9]` and `[^0-9]`,
    respectively. Therefore, `\d` matches all numeric values, and `\D` matches all
    non-numeric values. Another shortcut is `\w` and `\W`, which match any character
    from lowercase A to Z, irrespective of the case, all numeric values from 0 to
    9, and the underscore character. Therefore, `\w` is `[a-zA-Z0-9_]`, while `\W`
    is `[^a-zA-Z0-9_]`.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of regex are rather easy to understand, but there is a lot more that
    you can do with regex.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with regex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be create a new class in C# called `Chapter9`. Here, we will create
    various methods to illustrate the use of regex.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the purpose of this book, we will create a simple console application to
    illustrate the use of regex. In reality, you would probably not have this logic
    mixed in with your production code, because this would result in code being rewritten.
    The best place to add something like regex is in a helper class within an extension
    method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start by right-clicking the solution, going to **Add**, and then to **New Project**
    from the context menu:![How to do it…](img/B05391_09_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Add New Project** window opens up. Select the **Class Library** project
    type and call the project `Chapter9`:![How to do it…](img/B05391_09_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the new class file has been added, your **Solution Explorer** should look
    like this:![How to do it…](img/B05391_09_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `Class1.cs` file and select **Rename** from the context menu:![How
    to do it…](img/B05391_09_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `Class1.cs` file to `Recipes.cs` and select **Yes** from the confirmation
    dialog:![How to do it…](img/B05391_09_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the console application, click on the **References** section and select **Add
    Reference** from the context menu:![How to do it…](img/B05391_09_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Reference** **Manager** for the console application, select `Chapter9`
    and click on **OK** to add it as a reference to the console application:![How
    to do it…](img/B05391_09_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Recipes` class, add the following `using` statement so that we can
    use the regex assembly in .NET:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After you have done all this, your `Chapter9` class should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have added a basic class file that will be used to validate regex patterns,
    which is called from our console application.
  prefs: []
  type: TYPE_NORMAL
- en: Matching a valid date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a regex to validate a date pattern of yyyy-mm-dd, yyyy/mm/dd,
    or yyyy.mm.dd. At first, the regex will look daunting, but bear with me. When
    you have completed the code and run the application, we will dissect the regex.
    Hopefully, the expression logic will become clear.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ensure that you have added the correct assembly to your class. At the top of
    your code file, add the following line of code if you haven''t already done so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new method called `ValidDate()` that takes a string as the parameter.
    This string will be the date pattern we want to validate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following regex pattern to your method, to a variable in the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the regex to match the supplied string parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you have done this, your method should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Going back to your console application, add the following code and debug your
    application by clicking on Start:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You will notice that `Read()` is used in the preceding code example instead
    of `Console.Read()`. This is because `using static System.Console`; is added to
    the console application's `using` statements. Doing this will allow you to omit
    the `Console` keyword.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The date strings are passed to the regex, and the pattern is matched against
    the date string in the parameter. The output is displayed in the console application:![How
    to do it…](img/B05391_09_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you look at the output carefully, you will notice that there is a mistake.
    We are validating the date string in the format yyyy-mm-dd, yyyy/mm/dd, and yyyy.mm.dd.
    If we use this logic, our regex has incorrectly flagged a valid date as invalid.
    This is the date `2016.4.10`, which is 10 April, 2016, and is in fact quite valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We will explain shortly why the date `1800-01-21` is invalid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go back to your `ValidDate()` method and change the regular expression to read
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the console application again and look at the output:![How to do it…](img/B05391_09_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time the regex worked for all the given date strings. But what exactly
    did we do? This is how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the two expressions used in the previous code
    example. Comparing them with each other, you can see the change we made in yellow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B05391_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we get to what that change means, let''s break up the expression and
    view the individual components. Our regex is basically saying that we must match
    all string dates that start with 19 or 20 and have the following separators:'
  prefs: []
  type: TYPE_NORMAL
- en: Dash (`-`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimal (`.`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward slash (`/`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand the expression better, we need to understand the following format
    of the expression *<Valid Years><Valid Separators><Valid Months><Valid Separators><Valid
    Days>*.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to be able to tell the regex engine to consider one OR another
    pattern. The word OR is symbolised by the `|` metacharacter. To make the regex
    engine consider the word OR without splitting up the whole expression, we wrap
    it in parenthesis `()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the symbols used in the regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '| The conditional OR |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | This denotes the OR metacharacter. |'
  prefs: []
  type: TYPE_TB
- en: '| **The year portion** |'
  prefs: []
  type: TYPE_TB
- en: '| `(19&#124;20)` | Only allow 19 or 20. |'
  prefs: []
  type: TYPE_TB
- en: '| `\d\d` | Match two single digits between 0 and 9\. To match only one digit
    between 0 and 9, you would use `\d`. |'
  prefs: []
  type: TYPE_TB
- en: '| **The valid separator character set** |'
  prefs: []
  type: TYPE_TB
- en: '| `[-./]` | Match any of the following characters in the character set. These
    are our valid separators. To match a space date separator, you would change this
    to `[- ./]`, where you add a space anywhere in the character set. We added the
    space between the dash and the decimal. |'
  prefs: []
  type: TYPE_TB
- en: '| **Valid digits for months and days** |'
  prefs: []
  type: TYPE_TB
- en: '| `0[1-9]` | Match any part starting with zero followed by any digit between
    1 and 9\. This will match 01, 02, 03, 04, 05, 06, 07, 08, and 09. |'
  prefs: []
  type: TYPE_TB
- en: '| `1[0-2]` | Match any part starting with 1 followed by any digit between 0
    and 2\. This will match 10, 11, or 12. |'
  prefs: []
  type: TYPE_TB
- en: '| `[1-9]` | Match any digit between 1 and 9. |'
  prefs: []
  type: TYPE_TB
- en: '| `[12][0-9]` | Match any part starting with 1 or 2, followed by any digit
    between 0 and 9\. This will match all number strings between 10 and 29. |'
  prefs: []
  type: TYPE_TB
- en: '| `3[01]` | Match any part starting with 3 and followed by 0 or 1\. This will
    match 30 or 31. |'
  prefs: []
  type: TYPE_TB
- en: '| **Start and end of string** |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Tells the regex engine to start at the beginning of the given string
    to match. |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | Tells the regex engine to stop at the end of the given string to match.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The first regex we created, interprets as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^`: Start at the beginning of the string to match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(19|20)`: Check whether the string starts with 19 or 20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\d\d`: After the check, follows two single digits between 0 and 9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-./]`: The year portion ends followed by a date separator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(0[1-9]|1[0-2])`: Find the month logic by looking for digits starting with
    0, followed by any digit between 1 and 9, or digits starting with 1, followed
    by any digit between 0 and 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-./]`: The month logic ends, followed by a date separator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(0[1-9]|[12][0-9]|3[01])`: Then, find the day logic by looking for digits
    starting with 0, followed by a digit between 1 and 9, or digits starting with
    1 or 2, followed by any digit between 0 and 9, or a digit matching 3, followed
    by any digit between 0 and 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`: Do this until the end of the string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our first regex was incorrect because our month logic was incorrect. Our month
    logic dictates to find the month logic by looking for digits starting with a 0
    followed by any digit between 1 and 9, or digits starting with a 1 followed by
    any digit between 0 and 2 `(0[1-9]|1[0-2])`.
  prefs: []
  type: TYPE_NORMAL
- en: This will then find 01, 02, 03, 04, 05, 06, 07, 08, 09 or 10, 11, 12\. The date
    that it didn't match was `2016.4.10` (the date separators don't make a difference
    here). This is because our month came through as a single digit, and we were looking
    for months where the single digits started with a zero. To fix this, we had to
    modify the expression of the month logic to include single digits between 1 and
    9\. We did this by adding `[1-9]` to the expression at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modified regex then reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^`: Start at the beginning of the string to match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(19|20)`: Check whether the string starts with 19 or 20.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\d\d`: After the check, follows two single digits between 0 and 9.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-./]`: The year portion ends, followed by a date separator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(0[1-9]|1[0-2])`: Find the month logic by looking for digits starting with
    0, followed by any digit between 1 and 9, or digits starting with 1, followed
    by any digit between 0 and 2, or any single digits between 1 and 9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-./]`: The month logic ends, followed by a date separator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(0[1-9]|[12][0-9]|3[01])`: Then, find the day logic by looking for digits
    starting with 0, followed by a digit between 1 and 9, or digits starting with
    1 or 2, followed by any digit between 0 and 9, or a digit matching 3, followed
    by any digit between 0 and 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`: Do this until the end of the string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a basic regex, and we say basic because there is a lot more we can do
    to make the expression better. We can include logic to consider alternative date
    formats such as mm-dd-yyyy or dd-mm-yyyy. We can add logic to check February and
    validate that it contains only 28 days, unless it is a leap year, in which case
    we need to allow the twenty-ninth day of February. Furthermore, we can also extend
    the regex to check that January, March, May, July, August, October, and December
    have 31 days while April, June, September, and November contain only 30 days.
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you will need to sanitize input. This could be to prevent SQL injections
    or ensure that an entered URL is valid. In this recipe, we will look at replacing
    the bad words in a string with asterisks. We are sure that there are more elegant
    and code-efficient methods of writing sanitation logic using regex (especially
    when we have a large collection of blacklist words), but we want to illustrate
    a concept here.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ensure that you have added the correct assembly to your class. At the top of
    your code file, add the following line of code if you haven''t done so already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new method in your `Recipes.cs` class called `SanitizeInput()` and
    let it accept a string parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a list of type `List<string>` to the method that contains the bad words
    we want to remove from the input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In reality, you might make use of a database call to read the blacklisted words
    from a table in the database. You would usually not hardcode them in a list like
    this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start constructing the regex that we will use to look for the blacklisted words.
    Concatenate the words with the `|` (OR) metacharacter so that the regex will match
    any of the words. When the list is complete, you can append the `\b` expression
    to either side of the regex. This denotes a word boundary and, therefore, will
    only match whole words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will add the `Regex.Replace()` method that takes the input and
    looks for the occurrence of the words defined in the pattern, while ignoring case
    and replacing the bad words with `*****`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you have completed this, your `SanitizeInput()` method will look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the console application, add the following code to call the `SanitizeInput()`
    method and run your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run your application, you will see the following in the console window:![How
    to do it…](img/B05391_09_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's take a closer look at the regular expression generated.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s step through the code to understand what is happening. We need to get
    a regex that looks like this: `\b(wordToMatch1|wordToMatch2|wordToMatch3)\b`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What this basically says is find me any of the words and only whole words that
    are denoted by `\b`. When we look at the list we created, we will see the words
    we want to remove from the input string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B05391_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We then created a simple loop that will create the list of words to match using
    the OR metacharacter. We ended up with a `BadWord1|BadWord2|BadWord3` pattern
    after the `foreach` loop has completed. However, this is still not a valid regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B05391_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To complete the pattern resulting in the valid regex, we need to add the `\b`
    expression on either side of the pattern to tell the regex engine to only match
    whole words. As you can see, we are using string interpolation. String interpolation
    is covered in detail in [Chapter 1](ch01.html "Chapter 1. New Features in C# 6.0"),
    *New Features in C#6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is here, however, that we need to be very careful. Start off by writing
    the code to complete the pattern without the `@` sign, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run your console application, you will see that the bad words are not
    matched and filtered out. This is because we have not escaped the `\` character
    before `b`. The compiler, therefore, interprets this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B05391_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The generated expression `[](BadWord1| BadWord2| BadWord3)[]` is not a valid
    expression and will therefore not sanitize the input string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To correct this, we need to add the `@` symbol before the string to tell the
    compiler to treat the string as a literal. This means any escape sequences are
    ignored. The correctly formatted line of code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you do this, the string for the pattern is interpreted literally by the
    compiler, and the correct regex pattern generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B05391_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With our correct regex pattern, we called the `Regex.Replace()` method. It
    takes the input to check, the regex to match, the text to replace the matched
    words with, and optionally allows for the ignoring of case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B05391_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the string returns to the calling code in the console application, the
    string will be sanitized properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B05391_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Regex can become quite complex and can be used to perform a multitude of tasks
    to format and validate input and other text.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic regex matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does dynamic regex matching even mean? Well, it isn't an official term,
    but it is a term we use to explain a Regex that uses variables at runtime to generate
    a specific expression. Assume for a minute that you are working on a document-management
    system that needs to implement versioning of documents for a company called Acme
    Corporation. To do this, the system validates that the document has a valid file
    name.
  prefs: []
  type: TYPE_NORMAL
- en: A business rule states that the file name of any file uploaded on a specific
    day must be prefixed with `acm` (for Acme) and today's date in the yyyy-mm-dd
    format. There can be only text files, Word documents (only `.docx`), and Excel
    documents (only `.xlsx`). Any documents not conforming to this file format are
    processed by another method that takes care of archive and invalid documents.
  prefs: []
  type: TYPE_NORMAL
- en: The only task that your method needs to perform is to process fresh documents
    as version one documents.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a production system, further logic will probably be needed to determine whether
    the same document has been uploaded previously on the same day. This, however,
    is beyond the scope of this chapter. We are just trying to set the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ensure that you have added the correct assembly to your class. At the top of
    your code file, add the following line of code if you haven''t already done so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A really nice way to do this is to use an extension method. This way, you can
    call the extension method directly on the file name variable and have it validated.
    In your `Recipes.cs` file, start off by adding a new class called `CustomRegexHelper`
    with the `public static` modifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the usual extension method code to the `CustomRegexHelper` class and call
    the `ValidAcmeCompanyFilename` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside your `ValidAcmeCompanyFilename` method, add the following regex. We
    will explain the makeup of this regex in the *How it works…* section of this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you have completed this, your extension method should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in the `Recipes` class, create a method with the `void` return type called
    `DemoExtendionMethod()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add some output text to show the current date and the valid file name types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the file name checking code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will notice that the `if` statement contains the call to the extension
    method on the variable that contains the file name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have completed this, your method should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Going back to the console application, add the following code that simply just
    calls the `void` method. This is just to simulate the versioning method talked
    about earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you are done, run your console application:![How to do it…](img/B05391_09_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s have a closer look at the regex generated. The line of code we are looking
    at is the `return` statement in the extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To appreciate what is happening, we need to break this expression up into the
    different components:'
  prefs: []
  type: TYPE_NORMAL
- en: '| The conditional OR |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | This denotes the OR metacharacter. |'
  prefs: []
  type: TYPE_TB
- en: '| **The file prefix and separator** |'
  prefs: []
  type: TYPE_TB
- en: '| `acm` | The file must begin with the text `acm`. |'
  prefs: []
  type: TYPE_TB
- en: '| `[_]` | The only valid separator between the date components and the prefix
    in the file name is an underscore. |'
  prefs: []
  type: TYPE_TB
- en: '| **The date parts** |'
  prefs: []
  type: TYPE_TB
- en: '| `{DateTime.Now.Year}` | The interpolated year part of the date for the file
    name. |'
  prefs: []
  type: TYPE_TB
- en: '| `{DateTime.Now.Month}` | The interpolated month part of the date for the
    file name. |'
  prefs: []
  type: TYPE_TB
- en: '| `0[{DateTime.Now.Month}]` | The interpolated month part of the date with
    a leading zero for the file name. |'
  prefs: []
  type: TYPE_TB
- en: '| `{DateTime.Now.Day}` | The interpolated day part of the date for the file
    name. |'
  prefs: []
  type: TYPE_TB
- en: '| `0[{DateTime.Now.Day}]` | The interpolated day part of the date with a leading
    zero for the file name. |'
  prefs: []
  type: TYPE_TB
- en: '| **Valid file formats** |'
  prefs: []
  type: TYPE_TB
- en: '| `(.txt&#124;.docx&#124;.xlsx)` | Match any of these file extensions for text
    documents, Word documents, or Excel documents. |'
  prefs: []
  type: TYPE_TB
- en: '| **Start and end of string** |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Tells the regex engine to start at the beginning of the given string
    to match. |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | Tells the regex engine to stop at the end of the given string to match.
    |'
  prefs: []
  type: TYPE_TB
- en: Creating the regex in this manner allows us to always have it stay up to date.
    As we have to always match the current date to the file being validated, this
    creates a unique challenge that is easily overcome using string interpolation,
    `DateTime`, and regex OR statements.
  prefs: []
  type: TYPE_NORMAL
- en: Having a look at some of the more useful bits of regex, you will see that this
    chapter has not even begun to scratch the surface of what can be accomplished.
    There is a whole lot more to explore and learn. There are many resources on the
    Internet, as well as some free (some online) and commercial tools that will assist
    you in creating regex.
  prefs: []
  type: TYPE_NORMAL
