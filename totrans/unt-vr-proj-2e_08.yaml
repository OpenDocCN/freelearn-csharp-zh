- en: Playing with Physics and Fire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will use physics and other Unity features to build variations
    of an interactive ball game. Along the way, we explore managing objects, Rigidbody
    physics, and adding more interactivity to the virtual experience. You will see
    how properties and materials based on physics can be added to objects, as well
    as more on C# scripting, particle effects, and music.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Unity physics engine, the Unity Rigidbody component, and Physic Materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using velocity and gravity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing object lifetime and object pooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with objects in VR using your head and hands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a fireball using particle effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing with music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the projects in this chapter are separate and are not directly required
    by the other chapters in this book. If you decided to skip any of it or not save
    your work, that's OK.
  prefs: []
  type: TYPE_NORMAL
- en: Unity physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Unity, the behavior of an object that is based on physics is defined separately
    from its mesh (shape), materials (UV texture), and the renderer properties. The
    items that play into physics include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rigidbody**: Enables the object to act under the control of the physics engine,
    receive forces and torque to move in a realistic way'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collider**: Defines a simplified, approximated shape of the object used for
    calculating collisions with other objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physic Material**: Defines friction and bounce effects of colliding objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physics Manager**: Applies global settings for 3D physics for your project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, physics (in this context) is defined by the positional and rotational
    forces that affect the transform of an object, such as gravity, friction, momentum,
    and collisions with other objects. It is not necessarily a perfect simulation
    of physics in the real world because it's optimized for performance and separation
    of concerns to facilitate animation. Besides, virtual worlds might just need their
    own laws of physics that aren't found in our God-given universe!
  prefs: []
  type: TYPE_NORMAL
- en: Unity integrates the **NVIDIA PhysX** engine, a real-time physics calculation
    middleware, which implements classical Newtonian mechanics for games and 3D applications.
    This multiplatform software is optimized to utilize fast hardware processors when
    present. It is accessible via the Unity scripting API.
  prefs: []
  type: TYPE_NORMAL
- en: A key to physics is the Rigidbody component that you add to objects. Rigidbodies
    have parameters for gravity, mass, and drag, among others. Rigidbodies can automatically
    react to gravity and collisions with other objects. No extra scripting is needed
    for this. During gameplay, the engine calculates each rigid object's momentum
    and updates its transform position and rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Details on Rigidbodies can be found at [http://docs.unity3d.com/ScriptReference/Rigidbody.html](http://docs.unity3d.com/ScriptReference/Rigidbody.html).
  prefs: []
  type: TYPE_NORMAL
- en: Unity projects have a global gravity setting, found in the project's Physics
    Manager by navigating to Edit | Project Settings | Physics. As you might expect,
    the default gravity setting is a Vector3 with values (`0`, `-9.81`, `0`) that
    apply a downward force to all Rigidbodies. Gravity is in meters per second squared.
  prefs: []
  type: TYPE_NORMAL
- en: Rigidbodies can automatically react to gravity and collisions with other objects.
    Extra scripting is not needed for this.
  prefs: []
  type: TYPE_NORMAL
- en: In order to detect a collision, both the colliding objects must have a `Collider`
    component. There are built-in colliders with basic geometric shapes such as a
    cube, sphere, cylinder, and a capsule. A mesh collider can assume an arbitrary
    shape. If you can, it's best to use one or more basic collider shapes that approximately
    fit the actual object, rather than a mesh collider to reduce the expense of calculating
    the actual collisions during gameplay. Unity requires that if your object will
    be used in physics and has a Rigidbody, then its mesh collider must be marked
    as convex and be limited to 255 triangles.
  prefs: []
  type: TYPE_NORMAL
- en: When rigid objects collide, the forces pertinent to each object in the collision
    are applied to the others. The values of the resulting forces are calculated based
    on the objects' current velocity and body mass. Other factors are also taken into
    consideration, such as gravity and drag (that is, resistance). Furthermore, you
    have options to add constraints to freeze the position or rotation of a given
    object in any of its *x*, *y*, and *z* axes.
  prefs: []
  type: TYPE_NORMAL
- en: The calculations can be further affected when a Physic Material is assigned
    to the object's collider, which adjusts the friction and the bounciness effects
    of the colliding objects. These properties will be applied only to the object
    that owns the Physic Material. (Note that it's really spelled *Physic Material*
    rather than *Physics Material* for historical reasons.)
  prefs: []
  type: TYPE_NORMAL
- en: So, let's say that Object A (Ball) hits Object B (Brick). If Object A has bounciness
    and Object B does not, Object A will have an impulse applied in the collision,
    but Object B will not. However, you have options to determine how their friction
    and bounciness combine, as we'll see next. It's not necessarily an accurate simulation
    of real-world physics. It's a game engine, not a computer-aided engineering modeler.
  prefs: []
  type: TYPE_NORMAL
- en: From a scripting point of view, Unity will trigger events when objects collide
    (`OnTriggerEnter`), each frame while objects are colliding (`OnTriggerStay`),
    and when they've stopped colliding (`OnTriggerExit`).
  prefs: []
  type: TYPE_NORMAL
- en: If this sounds daunting, read on. The rest of this chapter breaks it down into
    understandable bits and pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Bouncy balls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The feature we'll implement here is, when a ball drops from mid-air and hits
    the ground, it bounces back up and down, and up again, diminished over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start simply with a new scene that consists of a ground plane
    and a sphere. Then, we''ll add physics to it, a bit at a time, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene by navigating to File | New Scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, navigate to File | Save Scene As... and name it `BallsFromHeaven`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new plane by navigating to GameObject | 3D Object | Plane and reset
    its transform using the `Transform` component's *gear* icon | Reset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new sphere by navigating to GameObject | 3D Object | Sphere and rename
    it `BouncyBall`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to (`0.5`, `0.5`, `0.5`) and Position to (`0`, `5`,`0`) so that
    it's above the center of the plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Red material from Project Assets (created in [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml),
    *Content, Objects and Scale*) onto it so that it looks like a bouncy ball.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new Unity scene defaults come with Directional Light and Main Camera. It's
    OK to use this Main Camera for the time being.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the *Play* button. Nothing happens. The ball just sits in mid-air and
    doesn't move.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s give it a Rigidbody, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: With `BouncyBall` selected, in Inspector, navigate to Add Component | Physics
    | Rigidbody.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the *Play* button. It drops like a lead balloon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s make it bounce, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Project panel, select the top-level Assets folder, navigate to Create
    | Folder, and rename it to `Physics`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `Physics` folder selected, create a material by navigating to Assets
    | Create | Physic Material (or right-click within the folder)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `Bouncy`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Bounciness value to `1`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `BouncyBall` sphere selected in Hierarchy, drag the `Bouncy` asset
    from Project onto the sphere's Collider material field in Inspector
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the *Play* button. It bounces, but it does not go very high. We used
    the maximum value for Bounciness as `1.0`. What''s slowing it down? It''s not
    the Friction settings. Rather, the Bounce Combine is set to Average, which determines
    how much of the bounciness of the ball (1) is mixed with that of the plane (0).
    So, it diminishes rapidly over time. We want the ball to retain all its bounciness.
    We will accomplish this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the `Bouncy` object's Bounce Combine to Maximum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the *Play* button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Much better. Actually, too much better. The ball keeps bouncing back up to its
    original height, ignoring gravity. Now, change the Bounciness to `0.8`. The bounces
    diminish, and the ball will eventually come to a stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check it out in VR, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the default Main Camera from the Hierarchy root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `MeMyselfEye` prefab from Project Assets into the scene. Set its Position
    to (`0`, `0`, `-4`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run it in VR. Pretty neat! Even the simplest things look impressive in VR.
  prefs: []
  type: TYPE_NORMAL
- en: Unity's Standard Assets package includes a handful of example physic materials,
    including Bouncy, Ice, Meta, Rubber, and Wood.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, let''s have some fun. Make it rain bouncy balls! To do this, we''ll make
    the ball a prefab and write a script that instantiates new balls, dropping them
    from random positions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `BouncyBall` object from Hierarchy into the `Project Assets/Prefabs`
    folder, making it a prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `BouncyBall` object from the Hierarchy, since we'll be instantiating
    it with a script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty game controller object to attach the script to by navigating
    to GameObject | Create Empty. Rename it `GameController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Inspector, navigate to Add Component | New Script, name it `BallsFromHeaven`,
    and open the script for editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the script so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The script drops a new ball from `startHeight` at the rate of every `interval`
    seconds (an interval of 0.5 means that a new ball is dropped every half second).
    The new ball position is at a random X-Z coordinate between `-4` and `4`. The
    `Instantiate()` function adds a new ball into the scene Hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script. We now need to populate the Ball field with the `BouncyBall`
    prefab, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: With `GameController` selected in Hierarchy, drag the `BouncyBall` prefab from
    the `Project Assets/Prefabs` folder onto the Ball Prefab slot in the Balls From
    Heaven (Script) panel in Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure to use the `BouncyBall` prefab from Project Assets so that can be instantiated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene. Run it in VR. Fun!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is what I get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7f360b3-958d-4b64-9112-97115152fc74.png)'
  prefs: []
  type: TYPE_IMG
- en: In summary, we created a sphere with a Rigidbody and added a Physic Material
    with a Bounciness property of `0.8` and Bounce Combine to Maximum. Then, we saved
    the `BouncyBall` as a prefab and wrote a script to instantiate new balls that
    drop from above.
  prefs: []
  type: TYPE_NORMAL
- en: Managing game objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you have a script that instantiates objects, you must be aware of the
    life cycle of the object and possibly arrange to destroy it when it is no longer
    needed. You can destroy game objects, for example, after it is no longer visible
    in the scene, or after a specific life duration, or limit the scene to a maximum
    number of balls.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying fallen objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our scene, we have a limited size ground plane and as balls hit one another,
    some will fall off the plane into oblivion. At that point, we can remove the fallen
    ball from the scene. Watch the Hierarchy panel as new balls are instantiated.
    Note that some balls end up bouncing off the plane platform but remain in the
    Hierarchy panel. We need to clean this up by adding a script that destroys the
    balls that are out of play, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `BouncyBall` prefab in `Project Assets/Prefabs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to Add Component | New Script and name it `DestroyBall`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a `DestroyBall.cs` script, which will destroy the object if its Y position
    is well below the ground plane (Y = `0`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Setting a limited lifetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another strategy for managing object life cycle is to limit their duration.
    This is especially effective for things like projectiles (bullets, arrows, bouncyballs)
    or other objects that the player cares about most when its instantiated and then
    isn't paying attention to as gameplay moves on.
  prefs: []
  type: TYPE_NORMAL
- en: To implement, you could put a timer on the object prefab itself to destroy itself
    when time runs out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `DestroyBall.cs` script to destroy the object after `delay` seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you play, notice that the ground plane remains substantially less crowded
    than before. Each BouncyBall will be destroyed after 15 seconds or when it has
    fallen off the plane, whichever comes first.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an object pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your `GameController` Interval is 0.5 seconds and the destroy timer is 15,
    then (do the math) there will be at most 30 balls in play at a time. Or less,
    if some have fallen over the edge. In that case, we do not need to make our app
    continuously allocate new memory for a new instance of BouncyBall, only to delete
    that object up to 15 seconds later. Too much instantiation and destroying of objects
    results in fragmented memory. Unity will periodically go through and clean this
    up, a computationally expensive process called **garbage collection** (**GC**)
    that is best to be avoided whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Object pooling is when you create a list of reusable objects to be used in your
    game, rather than continuously instantiating new ones. You will activate/deactivate
    the objects instead of instantiate/destroy.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this, we will write a generic object pooler and add it to the `GameController`
    in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we are also introducing you to the concept of lists in C#. As the
    name indicates, a list is an ordered collection of objects, like an array. Lists
    can be searched, sorted, and otherwise manipulated (see the documentation here: [https://msdn.microsoft.com/en-us/library/6sh2ey19.aspx](https://msdn.microsoft.com/en-us/library/6sh2ey19.aspx)).
    We will use them simply to hold our pre-instantiated objects. Let''s name the
    script `ObjectPooler`:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `GameController` in Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to Add Component | New Script and name it `ObjectPooler`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open for editing. Let''s start by declaring several variables at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The public `prefab` will get the prefab object we want to instantiate, namely `BouncyBall`.
    And `pooledAmount` says how many objects to initially instantiate. The actual
    list is held in `pooledObjects`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when the scene starts, we initialize the list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We allocate a new list and populate it in the `for` loop, by instantiating our
    prefab, initially making it inactive, and adding it to the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we want a new object, we''ll call `GetPooledObject`, which looks for
    one in the list that is presently not active. If all of them are active and none
    is available for reuse, we return `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That's it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also enhance the script to optionally grow the list so it never returns
    null. Add the option at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And add the following statements to `GetPooledObject` after the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Save the script, attach it to `GameController`, and drag the `BouncyBall` prefab
    onto the Prefab slot for the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to modify our `BallsFromHeaven` script to call `GetPooledObject`
    from `ObjectPooler` instead of `Instantiate`. The updated `BallsFromHeaven` script
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that we added a directive, `[RequireComponent(typeof(ObjectPooler)]`, to
    ensure the object has an `ObjectPooler` component (and we also double-check in
    the `Start` function).
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that since we're not instantiating new objects but reusing
    them, you may need to reset any object properties to their starting values. In
    this case, we reset not just the transform but the RigidBody's velocity to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is we modify `DestroyBall` to just disable (deactivate) the object
    rather than literally destroying it. Initially, handle the *fallen off the ground
    plane* case as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Instead of calling `Destroy`, we changed `Update` to call a new function, `DisableMe`,
    which simply deactivates the object, returning it to the pool of available objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the timed destroy, there''s a number of different ways to implement this.
    Earlier, we called `Destroy(gameObject, timer)` from `Start()`. We can do something
    similar, using `OnEnable` instead of `Start`, since that''s when this instance
    starts. And it calls  `Invoke()`, instead of destroy directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We also provide an `OnDisable` to cancel the `Invoke`, since the object could
    be disabled should the ball fall over the edge before the timer is done and potentially
    re-enabled, we should make sure it's not being invoked twice at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when you press Play, you can see in Inspector that new BouncyBalls are
    instantiated at the start to initialize the list, and then as it plays the objects
    are disabled and reactivated as they are returned to the pool and reused, as shown
    here (deactivated BouncyBall(Clone) objects are dimmer than the activated ones):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d35d2d7-88a8-45a7-baa1-6506d9bd3ac9.png)'
  prefs: []
  type: TYPE_IMG
- en: Headshot game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wouldn't it be fun to actually play with these bouncy balls? Let's make a game
    where you aim the ball at a target using headshots. For this game, balls drop
    one at a time from above and bounce off your forehead (face), aiming for a target.
  prefs: []
  type: TYPE_NORMAL
- en: The feature we'll implement here is, when a ball drops from above your head,
    you bounce it off your face and aim for a target.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this, create a cube as a child of the camera object (much like
    we did for the reticle cursor in [Chapter 6](36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml),
    *World Space UI*).  This provides a collider parented by the VR camera, so our
    head pose will move the face of the cube. I decided a cube-shaped collider will
    be better for this game than a sphere or capsule because it provides a flat face
    that will make the bounce direction more predictable. Balls will drop out of the
    sky. For a target, we'll use a flattened cylinder. We'll add audio cues to indicate
    when a new ball has been released and when a ball hits the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new scene or, more simple, start here by doing a Save As, and implement
    the head as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to File | Save Scene As and name it `BallGame`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `BallsFromHeaven` script component attached to `GameController` using
    the *gear* icon Remove Component. We won't need it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Hierarchy, unfold `MeMyselfEye`, drilling down to the `Camera` object and
    selecting it (for OpenVR that might be  `[CameraRig]/Camera (head)`; for Daydream,
    it may be  `Player/Main Camera/`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new 3D Object | Cube
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `GameController` selected, navigate to Add Component | Audio | Audio Source
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the small *circle-shaped* icon on the far right of the AudioClip field
    of Audio Source to open the Select AudioClip dialog box and choose the clip named
    `Jump`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `GameController` selected, navigate to Add Component | New Script, name
    it `BallGame`, and open it for editing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can decide to disable the cube's Mesh Renderer, but I think it's cool to
    watch it in the Scene window as you play. Since the camera is inside the cube,
    the player will not see it (since only the outward facing surfaces are rendered
    in the game view).
  prefs: []
  type: TYPE_NORMAL
- en: We'll play the `Jump` sound clip (provided with the `Characters` package of
    Unity's Standard Assets) to indicate when a new ball is dropped. You might try
    another, perhaps more interesting, effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `BallGame.cs` script. It looks a lot like the `BallsFromHeaven`
    one with just a few differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We instantiate a new ball every 3 seconds ( `interval` ) from a `startHeight`
    position above the current head position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The drop point defaults to directly above the player''s head position, as defined
    by the VR camera. That may feel uncomfortable on your neck, so let''s extent it
    in front a little, 0.2 units:'
  prefs: []
  type: TYPE_NORMAL
- en: As a child of `MeMyselfEye` (or as a child of your head or main camera object),
    create an empty game object and name it `Drop Point`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Position to (`0`, `0`, `0.2`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag this `Drop Point` onto the `GameController`'s Ball Game Drop Point slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On positionally tracked VR rigs, if your drop point is relative to the camera,
    it will follow the player around. If it's relative to `MeMyselfEye`, it will be
    relative to your play space while the player can move around.
  prefs: []
  type: TYPE_NORMAL
- en: Try it in VR.
  prefs: []
  type: TYPE_NORMAL
- en: When you hear the ball, look up and aim the angle of your face to direct the
    bounce of the ball. *COOOL!*
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need the target. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a flat cylinder for the target, navigate to Game Object | 3D Object |
    Cylinder, and name it `Target`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to (`3`, `0.1`, `3`) and Position to (`1`, `0.2`, `2.5`) so that
    it's out in front of you on the ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Blue` material from the `Project Assets/Materials` folder (created
    in [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml), *Content, Objects
    and Scale*) onto it, or make a new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that its default Capsule Collider is domed, and it really won't do. On
    the Capsule Collider, select its *gear* icon | Remove Component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, navigate to Add Component | Physics | Mesh Collider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new Mesh Collider, enable the Convex checkbox and the Is Trigger checkbox
    too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an audio source by navigating to Add Component | Audio | Audio Source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `Target` selected, click on the small *circle* icon on the far right
    of the AudioClip field to open the Select AudioClip dialog box, and choose the
    clip named `Land` (found in Standard Assets).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the Play On Awake checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And a new script, navigate to Add Component | New Script, name it `TriggerSound`,
    and open it in MonoDevelop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we enabled Is Trigger, when something hits the collider, the `OnTriggerEnter`
    and other event handlers will get a call when present on the target object. The
    following `TriggerSound.cs` script will play a sound clip when you hit the target
    with a ball:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The ball enters the target's collider and the physics engine invokes a trigger
    enter event. The script uses the `OnTriggerEnter()` handler to play the audio
    clip.
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of the collider properties and trigger events, including `OnTrggerEnter`
    and `OnTriggerExit`, see the documentation at [https://docs.unity3d.com/ScriptReference/Collider.html](https://docs.unity3d.com/ScriptReference/Collider.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it in VR. It''s a VR game! The following image shows the scene with the
    first person''s colliders and a ball bouncing off the cube collider towards the
    target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/491546fa-fc3c-4d53-a7f8-179256fdd125.png)**Extra challenge**: Keep
    score. Provide an aiming reticle. Add a backboard. Add other features to make
    the game more challenging. For instance, you can vary the fire interval or increase
    the initial ball velocity.'
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we assigned Bounciness through a Physic Material attached
    to a sphere object. When the ball collides with another object, the Unity physics
    engine considers this bounciness to determine the ball's new velocity and direction.
    In the following section, we'll look at how one can transfer a bounce force from
    one object to another.
  prefs: []
  type: TYPE_NORMAL
- en: Paddle ball game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we'll add hand controlled paddles to hit the ball. To keep things somewhat
    generic, our game paddles will be simple objects parented by the hand controllers
    in your camera rig. We'll move the target to be on a wall instead of the floor,
    and serve the balls a little further out in front of you so they're reachable
  prefs: []
  type: TYPE_NORMAL
- en: To set up the scene, you can Save As a new name and we'll work from here. I'll
    name my `PaddleBallGame`.
  prefs: []
  type: TYPE_NORMAL
- en: Select File | Save Scene As and name it `PaddleBallGame`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the head Cube we previously added as child of the camera, if present
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, let's create a paddle. We'll construct a very simple model using cylinders.
    You can find better ones, shaped and textured, online.
  prefs: []
  type: TYPE_NORMAL
- en: In the Hierarchy root, Create | Create Empty, name it `Paddle`, and reset its
    Transform
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a child cylinder object (Create | 3D Object | Cylinder) and name it `Handle`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Handle's Scale to (`0.02`, `0.1`, `0.02`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another Cylinder as a sibling of Handle and name it `Pad`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the pad's Scale to (`0.2`, `0.005`, `0.2`), Rotation (`90`, `0`, `0`), and
    Position (`0`, `0.2`, `0`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your Project Materials folder, create a new material (Create | Material)
    and name it `Paddle` `Material`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the material Albedo a wooden color, such as (`107`, `79`, `54`, `255`),
    then drag the material onto the Handle and Pad objects
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, modify the colliders:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Handle, and delete its Capsule Collider
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Pad, and delete its Capsule Collider
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Pad selected, add a Mesh Collider (Add Component | Physics | Mesh Collider)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the Convex checkbox
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the paddle as a prefab:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the Paddle into your Project Prefabs folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the Paddle from your Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to parent the Paddle to your hands. This is platform-specific. If you
    are using OpenVR, for example, that may be `MeMyselfEye / [CameraRig] / Controller`
    *(right)*. On Daydream, that might be `MeMyselfEye / Player / GvrControllerPointer.`
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, select the hand controller within `MeMyselfEye` (such as Controller
    (right). or `GvrControllerPointer`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create Empty child game object and name it `Hand` (reset its Transform if needed)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another Empty child beneath Hand and name it `Attach Point` (and reset
    its Transform if needed)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Paddle prefab from Project into Hierarchy as a child of Attach Point
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can adjust the paddle''s relative position and rotation so its grip
    feels natural within your hand. The follow values seem to work for me:'
  prefs: []
  type: TYPE_NORMAL
- en: In OpenVR, use the attach point Rotation (`20`, `90`, `90`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Daydream, use Position (`0`,  `0`,  `0`, `05)` and Rotation (`0`, `90`, `90`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On Daydream, the `GvrControllerPointer` includes a `GvrArmModel` component
    that can be configured for simulating arm, elbow, and wrist movement with the
    simple 3DOF controller. Setting this up yourself can be confusing. Fortunately,
    a bunch of examples are provided in the ArmModelDemo scene the Daydream Elements
    package (in the `DaydreamElements/Elements/ArmModels/D*emo/*` folder) including
    prefabs with some preconfigured arm models. Let''s add one. If you are on Daydream:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the `Elements/ArmModels/Prefabs` folder in Project Assets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `SwingArm` prefab into `MeMyselfEye / Player` as a sibling of `GvrControllerPointer`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move `GvrControllerPointer` as a child of SwingArm
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will give more arm extension for using the paddle. You can further adjust
    the settings as needed, including try moving the SwingArm transform Position further
    in front (`0`, `0`, `0.3`).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you might want to extend the ball drop location a little further out
    in front of you so it's more readily within hand reach. In the earlier version
    of the project, we defined a Drop Point; modify its position as desired (for example,
    z = `0.6`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The paddle in play using HTC Vive is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6906466-5459-4ca2-8771-c2f6d179bedf.png)'
  prefs: []
  type: TYPE_IMG
- en: Deflector versus paddle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As implemented, our paddle acts more like a deflector shield than a paddle.
    The ball will bounce off the paddle''s Pad in a direction based on the Pad''s
    surface normal orientation. But if you whack the ball, that doesn''t transfer
    any physics. We can change this by adding a RigidBody to the Pad, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Pad of your Paddle
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Component | Physics | RigidBody
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck Use Gravity checkbox
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the Is Kinematic checkbox
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Apply button at top of Inspector to save your changes in the prefab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By making it kinematic, our Pad will apply physics to objects colliding with
    it, but will not react to collisions itself. This is good, otherwise, the paddle
    would shatter when hit by a ball.
  prefs: []
  type: TYPE_NORMAL
- en: One important lesson in this project is the use of attach points for defining
    relative positions for specific behaviors. We used a Drop Point to mark the X,
    Z position where balls are dropped from. We used an Attach Point to mark the relative
    position and rotation of the paddle in your hand. We could have added a Grip Point
    to the paddle itself to specify its relative origin. And so on.
  prefs: []
  type: TYPE_NORMAL
- en: Shooter ball game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the next iteration of this project, we'll shoot balls at the player and
    you have to hit them at a target on a wall. There's not a lot of innovation in
    this version, but it shows how you can take an existing mechanic and turn it on
    its side (both literally and figuratively).
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, lets make a wall and put the target on it:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Hierarchy root, create an Empty game object named `TargetWall` and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position it at (`0`, `0`, `5`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a child Cube and name it `Wall`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Wall Scale to (`10`, `5`, `0.1`) and Position (`0`, `2.5`, `0`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Material named `Wall Material`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Rendering Mode to Transparent, and its Albedo color to (`85`, `60`,
    `20`, `75`) so it's a translucent glassy color
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the Target to a child of `TargetWall`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the Target Transform Scale to (`1.5`, `0.1`, `1.5`), Rotation (`90`,
    `0`, `0`), and Position (`0`, `2.5`, `-0.25`) so it's smaller and just in front
    of the wall itself
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, instead of serving balls by dropping them out of the sky and relying
    on gravity, we''ll shoot balls at you from a source on the wall:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Sphere game object as a child of `TargetWall`, named `Shooter`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to (`0.5`, `0.5`, `0.5`) and Position (`4`, `2.5`, `-0.25`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable or remove its Sphere Collider component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Material named `Shooter Material`, with Albedo color (`45`, `22`,
    `12`, `255`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll add a gun barrel to the shooter:'
  prefs: []
  type: TYPE_NORMAL
- en: Create another Sphere object as a child of Shooter, named `Barrel`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale (`0.1`, `0.1`, `0.1`), Rotation (`90`, `0`, `0`), and Position
    (`0`, `0`, `-0.25`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Duplicate the Shooter and set the second one''s Position to (`-4`, `2.5`, `-0.25`)
    so there''s one on either side of the Target. Here is a capture of the Scene view
    of the `TargetWall` with its sexy shooters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e290e704-61dc-4e23-8b3d-5290aa045ee6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The game controller script is similar to the BallGame one we have, but sufficiently
    different we should create a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, select `GameController` and disable or remove the `BallGame` component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C# script named `ShooterBallGame` and open it for editing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the `ShooterBallGame` script as follows. We give it two shooters and
    the script alternates between them to shoot balls in the direction of a `shootAt`
    location. We play a sound effect each time a ball is shot. First, let''s define
    the public and private variable we will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Start` function initializes the variable we get at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `Update` function shoots the balls at specified intervals, alternating
    between the two shooter locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here''s the `ShootBall()` code we extracted into its own function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`ShootBall` grabs a new ball from the object pool and initializes its position
    based on the shooter position. It then rotates the shooter to be pointing at the
    `shootAt` position (using `transform.LookAt`) and uses its forward vector to define
    the ball''s RigidBody velocity vector.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in Unity, we need to populate the public variable slots:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `Shooter` object (child of `TargetWall`) on to the Shooter 0 slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the other `Shooter` object on to the Shooter 1 slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the Shoot At slot empty for now, so it will default to the player's live
    head position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press Play. *Not bad*. The balls are too big and heavy. Let''s create new ball
    prefabs with different properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `BouncyBall` prefab from `Project` folder into the Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it `ShooterBall`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Scale to (`0.25`, `0.25`, `0.25`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the Use Gravity checkbox (alternatively, you could play with its RigidBody
    Mass property)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the ShooterBall from Hierarchy into your `Prefabs` folder, creating a new
    prefab for it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the ShooterBall from the Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `GameController` in Hierarchy, and drag the ShooterBall onto its Object
    Pooler Prefab slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the object pool will instantiate a collection of the new prefab objects.
  prefs: []
  type: TYPE_NORMAL
- en: Press Play. *Oh yeah!* The game is now much more challenging. Also, try modifying
    the Interval and Speed settings.
  prefs: []
  type: TYPE_NORMAL
- en: It may be awkward that the ball is always shooting towards your head, especially
    on Daydream where you have limited hand control. You can adjust the scene, for
    example, positioning the ShootAt empty game object, as child of `MeMyselfEye`,
    at Position (`0`, `0.9`, `0.6`), and setting it into the `GameController`'s ShootAt
    slot.
  prefs: []
  type: TYPE_NORMAL
- en: Some obvious gameplay improvement ideas should come to mind. You could make
    a moving target, perhaps in a predictable oscillating motion, or completely random.
    You could introduce some random variation in the ball velocity direction and speed
    or the intervals between shots. You could keep score, using `OnTriggerEnter` on
    the Target. You could disqualify bank shots that bounce first on the floor (using
    `OnTriggerEnter` on the ground plane).
  prefs: []
  type: TYPE_NORMAL
- en: Juicing the scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the basic mechanics implemented, we can now *juice it*! One of my favorite
    VR games is the popular Audio Shield ([http://audio-shield.com/](http://audio-shield.com/)).
    We're almost there building our own, we just need to add fireballs, a compelling
    environment scene, and synchronizing the fireball shots with music!
  prefs: []
  type: TYPE_NORMAL
- en: The term *juice it* for game design was popularized by Jonasson and Purho in
    their presentation talk from 2012,  *Juice it or lose it - a talk by Martin Jonasson
    & Petri Purho* ([https://www.youtube.com/watch?v=Fy0aCDmgnxg](https://www.youtube.com/watch?v=Fy0aCDmgnxg)). <q
    class="calibre65">A juicy game feels alive and responds to everything you do,
    tons of cascading action and response for minimal user input.</q>
  prefs: []
  type: TYPE_NORMAL
- en: Great balls of fire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we disabled Use Gravity on the shooting balls. We did
    this in anticipation of changing the balls from being bouncy balls to balls of
    fire. Let's make that magic happen now. We will use the Particle System to render
    it instead of mesh geometry.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of ways to get particle effects into your Unity project. If
    you recall, in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based
    Control*, we added a water hose, spark emitter, and explosion effects from the
    `Unity Standard Assets` package. Here, we'll build our own, but use one of the
    materials, `ParticleFireCloud`, provided with the package. In the Unity Asset
    Store, you can find many offerings of particle effects and system enhancements
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make a new prefab derived from ShooterBall, named `FireBall`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag a copy of `ShooterBall` prefab from the `Project` folder into Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it FireBall
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag FireBall into the `Project` *Prefabs* folder to create a new prefab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `GameController` from Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `FireBall` prefab from `Project` *Prefabs* folder onto the Object Pooler
    Prefab slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OK, now we can add the particle system:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the FireBall from Hierarchy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable its Mesh Renderer, as we will render it with particles instead
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click FireBall and select Create | Effects | Particle System
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it Fireball Particle System
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a lot of details in working with particles, many options and configuration
    parameters. As we step through this quick implementation of fireballs, observe
    the effects of each change as we make them one at a time. Note that you can preview
    the particle effects in the Scene window. Feel free to experiment on your own.
  prefs: []
  type: TYPE_NORMAL
- en: First, at the bottom of the Particle System Inspector, find the Renderer panel.
    In its Material slot, click the doughnut icon and choose the ParticleFireCloud material
    (located in `Standard Assets/Particle Systems/Materials`. If not present, you
    may need to import it using Assets | Import Package | ParticleSystems).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Near the top of the Particle System inspector, find the Shape panel. Select
    Shape: Sphere, and set its Radius to `0.1`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the Emission panel, and set Rate of Time to `15`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the inspector, set Duration: `2.00`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start Lifetime: `1`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start Speed: `0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start Size: `0.5`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Start Rotation, click the selector icon on the right and choose Random
    Between Two Curves. Then click the slot and scroll to the Curve Editor at the
    bottom of the Inspector. If you''re not familiar, the editor can take some getting
    used to. Choose a full range of values from `180` (at top of graph) to `-180`
    (bottom of graph), as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fe543e26-4c2e-4f6f-9d52-b08c61e2317c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enable Color Over Lifetime and click the slot to open its Gradient Editor.
    We want to adjust the Alpha curve so it starts at Alpha `0` at Location `0%`,
    then becomes Alpha `255` at `10%`, then fades out over time back to Alpha `0`
    at `100%`. The editor is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c43d9d6a-184a-4caf-8fed-69ba777f9a68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Set the Start Color, as Gradient (right-side selector) and then pick a range
    of colors such as yellow to red, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c67f1214-4127-43fd-9b2f-6c17a6d9b4f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, set the Velocity Over Lifetime, using Random Between Two Curves. For each
    X, Y, Z, use the Curve Editor to set max and min values of `0.05` and `-0.05`
    respectively. (You can modify the vertical axis of the graph by clicking the axis
    label and typing a number; you can copy curves, for example, by right-clicking
    the Z slot, choosing Copy, then right-clicking the Y slot and choosing Paste.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we should adjust the fireball so it''s about the same size as
    our original BouncyBall. To check:'
  prefs: []
  type: TYPE_NORMAL
- en: Re-enable the FireBall's Mesh Renderer. Adjust the particle system by changing
    the Renderer's Max Particle Size to `0.1`, or using the Transform Scale
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your work by selecting Apply at the top of Inspector, to update your prefab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now when you press Play, the Shooters will fire FireBalls. *Oh wow!*
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''d like to add some sparkle effect to the fireball, we can do that with
    the Trail panel:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable the Trail panel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A warning may pop up tell you to add a trails material to the Renderer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Renderer panel, select the doughnut icon on the Trail Material slot,
    and choose ParticleFireCloud as we use for the main fireball
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Speaking of trails, if you''d like to also implement trail effects on the fireball,
    there are several ways to do this too.  A quick solution is to duplicate our fireball
    particle system and modify it to use a Cone shape instead of Sphere, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Fireball Particle System in Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click to Duplicate, move the duplicate as a child of Fireball Particle
    System and name it Trail Particle System.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change its Shape to Cone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change its Velocity Over Lifetime. The Z curve needs a higher value range, such
    as `0.75` to `0.25`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The X and Y velocity curves should be smaller for some variation, such as `0.2`
    to `-0.2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Size Over Lifetime range to `1.0` to `0.5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Transform, set Position to (`0`, `0`, `0.5`) to give it an extra tail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here is a screenshot of the gameplay window paddling an incoming fireball!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c52a7b5d-8b8d-4cc0-88ca-fe7b40ea2df9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Special thanks to Tyler Wissler for his instructional video *How To: Basic
    Fireballs in Unity* (June 2014), which was very helpful is developing this topic
    ([https://www.youtube.com/watch?v=OWShSR6Tr50](https://www.youtube.com/watch?v=OWShSR6Tr50)).'
  prefs: []
  type: TYPE_NORMAL
- en: Skull environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To spice up our game, even more, we should find an exciting environment and
    scene. Searching the Asset Store, I found the *Skull Platform* free asset ([https://assetstore.unity.com/packages/3d/props/skull-platform-105664](https://assetstore.unity.com/packages/3d/props/skull-platform-105664)).
    You can use it too, or find something different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you''ve found and installed the Skull Platform asset, we''ll add it
    to our scene. First, let''s render our target as a skull:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag Platform_Skull_o1 as a child of Target (under `TargetWall`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Transform Rotation (`0`, `0`, `180`) and Scale (`0.3`, `0.3`, `0.3`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Target and disable its Mesh Renderer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, create a new Spotlight (Create | Light | Spotlight) to shine on the skull.
    As a child of Target, I used the following settings: Position (`-1`, `-30`, `-0.6`),
    Rotation (`-60`, `60`, `0`), Range: `10`, Spot Angle: `30`, Color: `#FFE5D4FF`,
    Intensity: `3`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let''s add the big platform as a backdrop behind the wall. The quickest
    way is to merge in the Demoscene they provide:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an Empty game object in the Hierarchy root, name it SkullPlatform, reset
    its transform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of the Skull Platform's demo scene named Platform (`Assets/Skull
    Platform/Demo/` folder) into the Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Demo's Scene, Lighting, and Particles objects and drag them as children
    of SkullPlatform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have the assets we want, right-click the Platform scene in Hierarchy
    and choose Remove Scene. When prompted, choose Don't Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the SkullPlatform Position to (`0`, `-1.5`, `0`) so it's just below the
    ground plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the GroundPlane and disable its Mesh Renderer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''ll set up the scene environment lighting:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the Directional Light from the scene Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Lighting window. If its not already a tab in your editor, use Window
    | Lighting | Settings and dock it next to the Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its Skybox Material to Sky (provided in the Skull Platform package).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Environmental Lighting section, set Source: Color to `#141415`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the Fog checkbox (in Other Settings), Color to `#8194A1FF`, Mode: Exponential,
    and Density to 0.`03`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here is a screen capture of the scene with the skull platform environment and
    lighting. *Sweet!*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaf4de82-7717-4dd4-995f-811d6347dab9.png)'
  prefs: []
  type: TYPE_IMG
- en: Audio synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're almost there building our own version of Audio Shield, we just need to
    add synchronizing the fireball shots with music!
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides an API for sampling audio source data, including `AudioSource.GetSpectrumData`
    and `GetOutputData`. Extracting actual beats in the music from this data is not
    trivial and requires a lot of math and some understanding of how music encoding
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we found an open source script that does this for us, called Unity-Beat-Detection
    ([https://github.com/allanpichardo/Unity-Beat-Detection](https://github.com/allanpichardo/Unity-Beat-Detection)).
    It conveniently provides Unity Events for `onBeat`, which we'll use. (It also
    provides  `onSpectrum` events, with music frequency bands per frame, which you
    could use too, for example, to change the color of the fireball or other things
    based on frequency bands.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the `AudioProcessor.cs` script from GitHub (we've provided a copy with
    the files for this book for your convenience)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the file into your `Scripts` folder (or use Assets | Import New Asset)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For your music, find any MP3 or WAV file that has a nice beat, and import it
    into your project. We looked on SoundCloud NoCopyrightSounds track ([https://soundcloud.com/nocopyrightsounds/tracks](https://soundcloud.com/nocopyrightsounds/tracks))
    to find one named *Third Prototype - Dancefloor* ([http://ncs.io/DancefloorNS](http://ncs.io/DancefloorNS)).
  prefs: []
  type: TYPE_NORMAL
- en: In Project window, create a folder named Audio
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your music file into the Audio folder (or use Assets | Import New Asset)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To implement this feature, we''ll make a MusicController and then modify the
    `ShooterBallGame` script to use its beats to fireballs. In Unity, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In Hierarchy, create an Empty game object and name it MusicController
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the AudioProcessor script as a component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that it automatically adds an Audio Source component too
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your imported music file onto AudioClip slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag MusicController itself onto Audio Source slot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the G Threshold parameter on Audio Process. You can use this to adjust
    the sensitivity of the beat recognition algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, update the `ShooterBallGame` script on `GameController` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It's very similar to the previous version, but instead of calling `ShootBall`
    from `Update`, based on the time interval, we call it from `onBeatDetected`. In
    `Start`, we add `onBeatDetected` as an `onBeat` event listener.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we've decided to randomly decide which shooter to use rather than just
    alternating back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press Play and go at it! *Whoohoo,* we have our own version of Audio Shield!
    A screenshot of active gameplay is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c0c2270-17b5-46db-bebf-6ec52f55ca40.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a game that uses Unity's Physics Engine and a number
    of other features. First, we explained in layman's terms the relationship between
    Rigidbody, Colliders, and Physic Materials, and explored how the physics engine
    uses these to determine the velocity and collision of objects in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we considered the life cycle of game objects and implemented an object
    pooler that helps avoid memory fragmentation and garbage collection, which can
    lead to performance problems and VR discomfort.
  prefs: []
  type: TYPE_NORMAL
- en: Using what we learned, we implemented several variations of a ball game, first
    aiming for a target with your head, then using hand paddles. We modified the game
    so that, instead of serving balls from above-using gravity, we shoot them from
    in front and apply a velocity vector. Lastly, we juiced up our game, changing
    the bouncy balls into fireballs, adding a cool level environment, and synchronizing
    the fireballs to music beats. In the end, we have a good start to making our own
    version of the Audio Shield VR game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see another more practical example of a virtual
    interactive space. We are going to build an interactive art gallery space that
    you can move through and query the artwork for information and details.
  prefs: []
  type: TYPE_NORMAL
