<html><head></head><body>
		<div><h1 id="_idParaDest-202" class="chapter-number"><a id="_idTextAnchor270"/>6</h1>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor271"/>Higher-Order Functions and Delegates</h1>
			<p>In this chapter, we’ll dive into higher-order functions and delegates in C#. These concepts are crucial in functional programming and will help you write more flexible and maintainable code.</p>
			<p>Higher-order functions are simply functions that can take other functions as arguments or return a function. This might sound complex, but don’t worry; we’ll break it down with clear examples and explanations. Higher-order functions are a key part of functional programming, allowing you to write code that’s both more concise and more expressive.</p>
			<p>Delegates in C# are closely related to higher-order functions. They are like variables for methods, allowing you to pass methods as arguments or store them as values. This chapter will help you understand how to use delegates to implement higher-order functions in the following sections:</p>
			<ul>
				<li>Understanding higher-order functions</li>
				<li>Delegates, actions, funcs, and predicates</li>
				<li>Callbacks, events, and anonymous methods</li>
				<li>Harnessing LINQ methods as higher-order functions</li>
				<li>Case study – putting it all together</li>
				<li>Best practices and common pitfalls</li>
			</ul>
			<p>In keeping with the tradition of our previous chapters, we’ll start this one with a brief self-evaluation. Below are three tasks designed to test your understanding of the concepts that will be discussed in this chapter. If you hesitate or struggle with these tasks, I recommend that you pay close attention to this chapter. However, if you find them easy, it might be a good opportunity to focus on areas where your knowledge isn’t as strong. So, let’s look at the tasks now.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor272"/>Task 1 – Sorting function</h1>
			<p>Write a program <a id="_idIndexMarker341"/>that uses a higher-order function to sort a list of towers in Steve’s game based on their damage output. The sorting function should be passed as a delegate.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor273"/>Task 2 – Customized calculations</h1>
			<p>Create a method that takes an <code>Action</code> and a list of enemies. The <code>Action</code> should perform a <a id="_idIndexMarker342"/>calculation on each enemy’s health and print the result. Test your method using several different <code>Action</code>s, such as calculating damage taken from different tower types.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor274"/>Task 3 – Comparison</h1>
			<p>Implement <a id="_idIndexMarker343"/>a method that uses a <code>Func</code> delegate to compare two towers based on their range. The method should return the tower with the longer rang<a id="_idTextAnchor275"/>e.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor276"/>Understanding higher-order functions</h1>
			<p>In functional <a id="_idIndexMarker344"/>programming, a higher-order function is simply a function that does at least one of the following:</p>
			<ul>
				<li>Takes one or more functions as parameters</li>
				<li>Returns a function as a result</li>
			</ul>
			<p>Yes, you heard it right! Higher-order functions treat functions as data, to be passed around like any other value. This leads to an unprecedented level of abstraction and code reuse.</p>
			<p>Consider a video management system in a YouTube-like platform, where efficiently handling a large collection of videos is crucial. Instead of writing separate functions for each type of video filtering, we can utilize higher-order functions for a more elegant and reusable solution. A higher-order function can abstract the filtering logic, making the code more <a id="_idIndexMarker345"/>modular and maintainable. Here’s a simplified example:</p>
			<pre class="source-code">
public Func&lt;Func&lt;Video, bool&gt;, IEnumerable&lt;Video&gt;&gt; FilterVideos(IEnumerable&lt;Video&gt; videos)
{
    return filter =&gt;
    {
        Console.WriteLine("Filtering videos...");
        var filteredVideos = videos.Where(filter).ToList();
        Console.WriteLine($"Filtered {filteredVideos.Count} videos.");
        return filteredVideos;
    };
}
// Usage
var allVideos = new List&lt;Video&gt; { /* Collection of videos */ };
var filterFunc = FilterVideos(allVideos);
var publicVideos = filterFunc(v =&gt; v.IsPublic);</pre>			<p>In this system, we have a collection of <code>Video</code> objects. We want to filter these videos based on different criteria such as visibility, length, or genre. To achieve this, we create a higher-order function called <code>FilterVideos</code>. This function takes a collection of videos and returns another function. The returned function is capable of filtering the videos based on a provided predicate – a function that defines the filtering criteria. This design allows us to easily create various filters without duplicating the filtering logic, thereby enhancing code reuse and readabil<a id="_idTextAnchor277"/>ity.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor278"/>The power of higher-order functions in functional programming</h2>
			<p>Higher-order functions are a cornerstone of functional programming, offering robustness <a id="_idIndexMarker346"/>and flexibility. Their ability to treat functions as data, and the resulting abstraction and versatility, can be seen in various facets of programming.</p>
			<p>The ability of higher-order functions to abstract and encapsulate behaviors is unparalleled, leading to significant code reuse. For instance, consider a scenario in a mobile tower defense game where we need various types of unit transformations. Instead of repeating transformation logic, we can abstract this through a higher-order function. Here’s an illustrative example:</p>
			<pre class="source-code">
public Func&lt;Unit, Unit&gt; CreateTransformation&lt;T&gt;(Func&lt;Unit, T, Unit&gt; transform, T parameter)
{
    return unit =&gt; transform(unit, parameter);
}
// Usage
Func&lt;Unit, Unit&gt; upgradeArmor = CreateTransformation((unit, bonus) =&gt; unit.UpgradeArmor(bonus), 10);
Unit myUnit = new Unit();
Unit upgradedUnit = upgradeArmor(myUnit);</pre>			<p>In this example, <code>CreateTransformation</code> is a higher-order function that returns a new function, encapsulating the transformation behavior. It promotes code reuse and abstraction by providing a flexible way to apply different transformations to game units.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor279"/>Creating versatile code with fewer errors</h2>
			<p>Higher-order functions also contribute to writing generic and versatile code, leading to fewer <a id="_idIndexMarker347"/>errors. By encapsulating a generic behavior, these functions reduce the amount of code written, which is then more frequently tested and less prone to bugs.</p>
			<p>Consider a function for applying effects to units in a tower defense game. Using a higher-order function, we can pass different effects as parameters:</p>
			<pre class="source-code">
public Func&lt;Unit, Unit&gt; ApplyEffect(Func&lt;Unit, Unit&gt; effect)
{
    return unit =&gt;
    {
        return effect(unit);
    };
}
// Usage
Func&lt;Unit, Unit&gt; applyFreeze = ApplyEffect(u =&gt; u.Freeze());
Unit enemyUnit = new Unit();
Unit affectedUnit = applyFreeze(enemyUnit);</pre>			<p>Here, <code>ApplyEffect</code> allows for various effects to be applied to game units, simplifying the code base and reducing potential errors.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor280"/>Supporting a more declarative coding style</h2>
			<p>Higher-order <a id="_idIndexMarker348"/>functions foster a declarative style of coding. You describe what you want to achieve rather than how to achieve it, making code more readable and maintainable.</p>
			<p>In the game effect example, we declaratively specify that we want to apply an effect to a unit. The specifics <a id="_idIndexMarker349"/>of how the effect is applied are abstracted within the <code>ApplyEffect</code> function.</p>
			<p>In conclusion, higher-order functions in functional programming are invaluable. They enable <a id="_idIndexMarker350"/>code reuse, reduce errors, and support a declarative coding style, making them a powerful tool in any programmer’s<a id="_idTextAnchor281"/> toolkit.</p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor282"/>Delegates, actions, funcs, and predicates</h1>
			<p>Delegates are essentially type-safe function pointers, holding references to functions. This type of safety is crucial as it ensures that the function’s signature aligns with the delegate’s defined signature. Delegates enable methods to be passed as parameters, returned from functions, and stored in data structures, making them indispensable for event handling and other dynamic functionalities.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor283"/>Delegates</h2>
			<p>Let’s apply <a id="_idIndexMarker351"/>the concept of delegates to a book publishing system. Imagine we need to notify different departments when a new book is published.</p>
			<p>First, define a delegate matching the notification function’s signature:</p>
			<pre class="source-code">
public delegate void BookPublishedNotification(string bookTitle);</pre>			<p>Next, create a class to manage book publishing that accepts a delegate in its method:</p>
			<pre class="source-code">
public class BookPublishingManager
{
    public void PublishBook(string bookTitle, BookPublishedNotification notifyDepartments)
    {
        // Publishing logic here
        notifyDepartments(bookTitle);
    }
}</pre>			<p>Now, any function <a id="_idIndexMarker352"/>that matches the delegate’s signature can be passed into <code>PublishBook</code> and will be called when a new book is published:</p>
			<pre class="source-code">
public void NotifyMarketingDepartment(string bookTitle)
{
    Console.WriteLine($"Marketing notified for the book: {bookTitle}");
}
// Usage
BookPublishingManager publishingManager = new BookPublishingManager();
publishingManager.PublishBook("Functional Programming in C# 12", NotifyMarketingDepartment);</pre>			<p>In this example, any function that matches the <code>BookPublishedNotification</code> delegate’s signature can be passed to <code>PublishBook</code> and will be invoked when a book is published. This demonstrates the flexibility and dynamism of delegates in a practica<a id="_idTextAnchor284"/>l scenario.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor285"/>Actions</h2>
			<p>In functional <a id="_idIndexMarker353"/>programming, <code>Actions</code> are a type of delegate that does not return a value. They are ideal for executing methods that perform actions but do not need to return a result. This simplicity makes <code>Actions</code> a versatile tool in various programming scenarios.</p>
			<p>Consider a mobile tower defense game where certain events, such as spawning enemies and triggering effects, do not require a return value. We can use an <code>Action</code> delegate to handle these scenarios:</p>
			<pre class="source-code">
public class TowerDefenseGame
{
    public event Action&lt;string&gt; OnEnemySpawned;
    public void SpawnEnemy(string enemyType)
    {
        // Enemy spawning logic here
        OnEnemySpawned?.Invoke(enemyType);
    }
}
// Usage
TowerDefenseGame game = new TowerDefenseGame();
game.OnEnemySpawned += enemyType =&gt; Console.WriteLine($"Spawned {enemyType}");
game.SpawnEnemy("Goblin");</pre>			<p>In this <a id="_idIndexMarker354"/>example, <code>OnEnemySpawned</code> is an <code>Action</code> delegate used to notify when an enemy is spawned. The simplicity of <code>Action</code> delegates allows for clean and clear event handling in the <a id="_idTextAnchor286"/>game’s logic.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor287"/>Funcs</h2>
			<p><code>Funcs</code>, another <a id="_idIndexMarker355"/>kind of built-in delegate, are used when a return value is needed. They can have between 0 and 16 input parameters, with the last parameter type always being the return type.</p>
			<p>In the context of the same tower defense game, imagine we need a function to calculate the score based on various game parameters. This is where <code>Funcs</code> become useful:</p>
			<pre class="source-code">
public class TowerDefenseGame
{
    public Func&lt;int, int, double&gt; CalculateScore;
    public double GetScore(int enemiesDefeated, int towersBuilt)
    {
        return CalculateScore?.Invoke(enemiesDefeated, towersBuilt) ?? 0;
    }
}
// Usage
TowerDefenseGame game = new TowerDefenseGame();
game.CalculateScore = (enemiesDefeated, towersBuilt) =&gt; enemiesDefeated * 10 + towersBuilt * 5;
double score = game.GetScore(50, 10);</pre>			<p>Here, <code>CalculateScore</code> is a <code>Func</code> delegate, allowing for a flexible and customizable way to calculate <a id="_idIndexMarker356"/>the game’s score based on dynamic gameplay factors. <code>Funcs</code> provide a powerful way to define operations with return values, enhancing the flexibility and reusabili<a id="_idTextAnchor288"/>ty of the code.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor289"/>Predicates</h2>
			<p><code>Predicate&lt;T&gt;</code> is a delegate <a id="_idIndexMarker357"/>that represents a method containing a set of criteria and checks whether the passed parameter meets those criteria. A predicate delegate method must take one input parameter and return a <code>bool</code> value.</p>
			<p>In a YouTube-like video management system, we might use <code>Predicate&lt;Video&gt;</code> to filter videos based on certain criteria:</p>
			<pre class="source-code">
public class VideoManager
{
    IEnumerable&lt;Video&gt; _videos; // We assume it will be filled later
    public IEnumerable&lt;Video&gt; GetVideosMatching(Predicate&lt;Video&gt; criteria)
    {
        foreach (var video in _videos)
        {
            if (criteria(video))
            {
                yield return video;
            }
        }
    }
}
// Usage
VideoManager videoManager = new();
Predicate&lt;Video&gt; isPopular = video =&gt; video.Views &gt; 100000;
List&lt;Video&gt; popularVideos = videoManager.GetVideosMatching(isPopular);</pre>			<p>In this example, <code>GetVideosMatching</code> takes a <code>Predicate&lt;Video&gt;</code> delegate to filter videos. The <a id="_idIndexMarker358"/>method iterates through the list of videos and adds those meeting the criteria defined by the predicate to the result list. It could be written as a one-liner using <code>Where</code>, but using <code>yield return</code> makes it more expressive.</p>
			<p>So, summarizing all we’ve learned about delegates, actions, funcs, and predicates, we can see the following:</p>
			<ul>
				<li><strong class="bold">Delegates</strong>: The foundational elements, allowing methods to be referenced and passed around, vital to creating higher-order functions</li>
				<li><strong class="bold">Actions</strong>: Specialized delegates for methods that perform actions but don’t return values, simplifying task encapsulation</li>
				<li><strong class="bold">Funcs</strong>: Delegates that return a result, useful for computations and transformations</li>
				<li><strong class="bold">Predicates</strong>: A form of func always returning a Boolean, standardizing condition checks</li>
			</ul>
			<p>These constructs collectively can enhance our programming, enabling code reuse, higher abstraction, and a flexible, functional style.</p>
			<p>Let’s continue with even more exciting<a id="_idTextAnchor290"/> constructs next.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor291"/>Callbacks, events, and anonymous methods</h1>
			<p>Callbacks are a pivotal concept in asynchronous and event-driven programming. They are essentially <a id="_idIndexMarker359"/>delegates that point to a method, allowing it to be called at a later time. This facilitates non-blocking code execution, crucial for responsive applications.</p>
			<p>Imagine a <a id="_idIndexMarker360"/>book publishing system where we need to perform actions such as sending notifications after a book is published. Here, a callback can notify other <a id="_idIndexMarker361"/>parts of the system once the publishing process is completed:</p>
			<pre class="source-code">
public delegate void BookPublishedCallback(string bookTitle);
public class BookPublishingManager
{
    public void PublishBook(string bookTitle, BookPublishedCallback callback)
    {
        // Book publishing logic here...
        callback(bookTitle);
    }
}
// Usage
BookPublishingManager manager = new BookPublishingManager();
manager.PublishBook("C# in Depth", title =&gt; Console.WriteLine($"{title} has been published!"));</pre>			<p>In this <a id="_idIndexMarker362"/>scenario, the callback is invoked after a book is published, providing <a id="_idIndexMarker363"/>a flexible and decoupled way of handling <a id="_idIndexMarker364"/>pos<a id="_idTextAnchor292"/>t-publishing processes.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor293"/>The role of delegates in events</h2>
			<p>Events, built on <a id="_idIndexMarker365"/>the publisher-subscriber model, are another <a id="_idIndexMarker366"/>powerful application of delegates. They allow objects to notify others about occurrences of interest.</p>
			<p>The book publishing system can be further enhanced by using events, providing a more robust and flexible mechanism for notifications:</p>
			<pre class="source-code">
public class BookPublishingManager
{
    public event Action&lt;string&gt; OnBookPublished;
    public void PublishBook(string bookTitle)
    {
        // Book publishing logic here...
        OnBookPublished?.Invoke(bookTitle);
    }
}
// Usage
BookPublishingManager manager = new BookPublishingManager();
manager.OnBookPublished += title =&gt; Console.WriteLine($"{title} has been published!");
manager.PublishBook("Advanced C# Programming");</pre>			<p>In this version, <code>OnBookPublished</code> is an event that subscribers can listen to. When a book is <a id="_idIndexMarker367"/>published, the event is raised, and all subscribed <a id="_idIndexMarker368"/>methods are invoked. This model enhances modularity and reduces coupling between the publishing logic <a id="_idTextAnchor294"/>and its subsequent actions.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor295"/>Delegates and anonymous methods</h2>
			<p>Anonymous methods are methods that are not bound to a specific name. They are defined <a id="_idIndexMarker369"/>using the <code>delegate</code> keyword and can be used to create instances of a delegate. Anonymous methods provide a way to define methods in place where they are called, making your code more concise and readable.</p>
			<p>Let’s create <a id="_idIndexMarker370"/>a simple anonymous method that filters a list of video objects based on a specific criterion, such as videos that are longer than a certain duration. We’ll use an anonymous method with the <code>FindAll</code> method to accomplish this:</p>
			<pre class="source-code">
public class Video
{
    public string Title { get; set; }
    public int DurationInSeconds { get; set; }
}
List&lt;Video&gt; videos = new List&lt;Video&gt;
{
    new Video { Title = "Introduction to C#", DurationInSeconds = 300 },
    new Video { Title = "Advanced C# Techniques", DurationInSeconds = 540 },
    new Video { Title = "C# Functional Programming", DurationInSeconds = 420 }
};
List&lt;Video&gt; longVideos = videos.FindAll(delegate(Video video)
{
    return video.DurationInSeconds &gt; 450; // Filtering videos longer than 450 seconds
});
foreach (Video video in longVideos)
{
    Console.WriteLine(video.Title);  // Outputs titles of videos longer than 450 seconds
}</pre>			<p>In this example, <code>delegate(Video video) {...}</code> is an anonymous method used to define <a id="_idIndexMarker371"/>the criteria for the <code>FindAll</code> method, filtering videos based <a id="_idIndexMarker372"/>on their duration. This demonstrates how anonymous methods can be employed in practical scenarios such as filtering data in a video management system.</p>
			<p>By leveraging delegates to create callbacks, handle events, and define anonymous methods, we gain a powerful set of tools that allow us to write more <a id="_idTextAnchor296"/>flexible and maintainable code.</p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor297"/>Harnessing LINQ methods as higher-order functions</h1>
			<p><strong class="bold">Language Integrated Query</strong> (<strong class="bold">LINQ</strong>) in C# integrates query capabilities into the language, functioning <a id="_idIndexMarker373"/>primarily through extension <a id="_idIndexMarker374"/>methods. These methods, adhering to functional programming principles, allow for concise and expressive data manipulation. We’ll explore how LINQ can be effectively used in different systems for data filtering,<a id="_idTextAnchor298"/> transformation, and aggregation.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor299"/>Filtering</h2>
			<p>In a video <a id="_idIndexMarker375"/>management system, we might need to filter videos based on their view count. Using the <code>Where</code> method, we can easily achieve this:</p>
			<pre class="source-code">
List&lt;Video&gt; videos = GetAllVideos();
 IEnumerable&lt;Video&gt; popularVideos = videos.Where(video =&gt; video.Views &gt; 100000);
foreach(var video in popularVideos)
{
    Console.WriteLine(video.Title);
}</pre>			<h2 id="_idParaDest-221"><a id="_idTextAnchor300"/>Data transformation</h2>
			<p>In a <a id="_idIndexMarker376"/>publishing system, converting book titles to uppercase for a uniform catalog display can be done using the <code>Select</code> method:</p>
			<pre class="source-code">
List&lt;Book&gt; books = GetBooks();
var upperCaseTitles = books.Select(book =&gt; book.Title.ToUpper());
foreach(var title in upperCaseTitles<a id="_idTextAnchor301"/>)
{
    Console.WriteLine(title);
}</pre>			<h2 id="_idParaDest-222"><a id="_idTextAnchor302"/>Data aggregation</h2>
			<p>For a mobile <a id="_idIndexMarker377"/>tower defense game, calculating the average damage of all towers can be efficiently done using the <code>Average</code> method:</p>
			<pre class="source-code">
double averageGrade = students.Average(student =&gt; student.Grade);
Console.WriteLine($"Average Grade: {averageGrade}");</pre>			<p>These examples showcase the power of LINQ as higher-order functions, demonstrating how they can be used to handle complex data operations in various real-world applications, making code more re<a id="_idTextAnchor303"/>adable, maintainable, and enjoyable.</p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor304"/>Case study – putting it all together</h1>
			<p>Here, we’ll bring together all the elements we’ve discussed so far: higher-order functions, delegates, actions, funcs, predicates, and LINQ methods. We’ll provide a comprehensive, real-world example and analyze the code, step by step.</p>
			<p>Imagine we are developing a mobile tower defense game. This game involves managing towers, handling enemy waves, and upgrading tower capabilities.</p>
			<p>Here’s an outline of the classes we’ll use:</p>
			<pre class="source-code">
public class Tower
{
    public string Type { get; set; }
    public int Damage { get; set; }
    public bool IsUpgraded { get; set; }
}
public class Game
{
    private List&lt;Tower&gt; _towers { get; set; }
    public IEnumerable&lt;Tower&gt; FilterTowers(Func&lt;Tower, bool&gt; predicate) { /* … */ }
    public event Action&lt;Tower&gt; TowerUpgraded;
    public void UpgradeTower(Tower tower) { /* … */ }
}</pre>			<p>The <code>Tower</code> class here <a id="_idIndexMarker378"/>represents the basic building block of the game – the towers. Each tower has a type, a damage level, and a status indicating whether it has been upgraded. This class is a cornerstone for the game’s mechanics, as different towers might have various effects and strategies associated with them.</p>
			<p>The <code>Game</code> class acts <a id="_idIndexMarker379"/>as a central hub for managing the game’s logic. It contains a list of all towers in the game. The class demonstrates advanced functional programming techniques:</p>
			<ul>
				<li>The <code>FilterTowers</code> method is a <a id="_idIndexMarker380"/>quintessential example of using higher-order functions in a real-world application. By accepting a <code>Func&lt;Tower, bool&gt;</code> as a predicate, it provides a flexible way to filter towers based on dynamic criteria, such as damage level, range, or upgrade status. This method makes use of LINQ, showcasing its power in simplifying data manipulation tasks.</li>
				<li>The <code>TowerUpgraded</code> event, coupled with the <code>UpgradeTower</code> method, demonstrates <a id="_idIndexMarker381"/>the use of actions and delegates. This event-driven approach allows for reactive programming, where different parts of the game can respond to changes in tower states, such as triggering animations, sounds, or game<a id="_idTextAnchor305"/> logic updates when a tower is upgraded.</li>
			</ul>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor306"/>Step-by-step walk-through and analysis of the code</h2>
			<p>Now, let’s add some logic to our me<a id="_idTextAnchor307"/>thods and write the code that uses them:</p>
			<ol>
				<li><code>FilterTowers</code> method uses a predicate (a <code>Func</code> that returns a <code>bool</code>) to select towers based on specific criteria, illustrating <a id="_idIndexMarker382"/>higher-order functions and LINQ:<pre class="source-code">
public IEnumerable&lt;Tower&gt; FilterTowers(Func&lt;Tower, bool&gt; predicate)
{
    return _towers.Where(predicate);
}</pre><p class="list-inset">This approach allows for dynamic tower filtering, adapting to vari<a id="_idTextAnchor308"/>ous game scenarios and player strategies.</p></li>				<li><code>TowerUpgraded</code> event demonstrates how delegates <a id="_idIndexMarker383"/>facilitate event handling in the game:<pre class="source-code">
public void UpgradeTower(Tower tower)
{
    if (!tower.IsUpgraded)
    {
        tower.IsUpgraded = true;
        TowerUpgraded?.Invoke(tower);
    }
}</pre><p class="list-inset">This mechanism is crucial for notifying different parts of the game about tower upgrad<a id="_idTextAnchor309"/>es and maintaining game state consistency.</p></li>				<li><strong class="bold">Interacting with the game</strong>: Finally, let’s see how a user might interact with the library:<pre class="source-code">
Game game = new Game();
// Filtering towers using a Predicate
var highDamageTowers = game.FilterTowers(tower =&gt; tower.Damage &gt; 50);
// Subscribing to events with anonymous methods
game.TowerUpgraded += tower =&gt; Console.WriteLine($"{tower.Type} was upgraded.");
// Upgrading a tower
var cannonTower = highDamageTowers.First();
game.UpgradeTower(cannonTower);</pre><p class="list-inset">In this snippet, we see the practical application of the game’s functional programming features. From filtering towers based on damage to handling tower upgrades, the code is concise, expressive, and effective.</p></li>			</ol>
			<p>This case study demonstrates the use of predicates, events, delegates, and higher-order functions in a practical scenario. It showcases how functional programming principles can enhance the development and operation of a complex mobile game, leading to more efficient, expressive, and powerful programming. The integration of these concepts provides a solid foundation for bu<a id="_idTextAnchor310"/>ilding engaging and robust game mechanics.</p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor311"/>Best practices and common pitfalls</h1>
			<p>This section takes a closer look at best practices when working with higher-order functions, delegates, actions, funcs, predicates, and LINQ. We’ll also discuss common mistakes that developers make and offer<a id="_idTextAnchor312"/> solutions on how to avoid these pitfalls.</p>
			<p>Here are <a id="_idIndexMarker384"/>some best practices to use while working with higher-order functions:</p>
			<ul>
				<li><strong class="bold">Aim for stateless functions</strong>: For consistency and predictability, strive to ensure that the functions you pass as arguments are stateless, meaning they don’t rely on or change the state of anything outside themselves. This makes them more predictable and less prone to side effects.</li>
				<li><strong class="bold">Embrace immutability</strong>: One of the core principles of functional programming is immutability. When passing objects to your higher-order functions, consider whether they can be made immutable to ensure that the function doesn’t alter their state.</li>
				<li><strong class="bold">Use descriptive names</strong>: As you are passing around functions, it’s easy to lose track of what each one does. Therefore, use descriptive names for your funct<a id="_idTextAnchor313"/>ions and parameters to improve readability.</li>
			</ul>
			<p>Some of <a id="_idIndexMarker385"/>the common pitfalls are as follows:</p>
			<ul>
				<li><code>OrderBy</code>, <code>Reverse</code>, and <code>Count</code>, may be costly. Always measure the performance of your queries and consider alternative approaches if necessary.</li>
				<li><strong class="bold">Ignoring type safety with delegates</strong>: While delegates are powerful, they can also bypass type safety if not used with care. Always ensure the delegate signature matches the method it points to avoid runtime errors.</li>
				<li><code>NullReferenceException</code>:<pre class="source-code">
myDelegate?.Invoke();</pre></li>				<li><strong class="bold">Misuse of anonymous functions</strong>: Anonymous functions can lead to cleaner code, but they can also hide complexity and make code harder to test. If an anonymous <a id="_idIndexMarker386"/>function is more than a few lines long, or if it’s complex enough to require testing on its own, it should probably be a named function instead.</li>
			</ul>
			<p>By following these best practices and avoiding common mistakes, you can write clean, efficient, and maintainable code, harnessing the power of func<a id="_idTextAnchor314"/>tional programming constructs to the fullest.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor315"/>Exercises</h1>
			<p>The theory and concepts are only half the learning journey. Now, it’s time to get your hands dirty with some practical exercises. This chapter provides a series of challenging problems to test your understanding of the concepts learned and to reinforce them. Following each problem, you’ll find a <a id="_idTextAnchor316"/>proposed solution with detailed explanations.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor317"/>Exercise 1</h2>
			<p>Write a program that uses a higher-order function to sort a list of towers in Steve’s game based on their damage output. The sor<a id="_idTextAnchor318"/>ting function should be passed as a delegate.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor319"/>Exercise 2</h2>
			<p>Create a method that takes an <code>Action</code> and a list of enemies. The <code>Action</code> should perform a calculation on each enemy’s health and print the result. Test your method using several different <code>Action</code>s, such as calcula<a id="_idTextAnchor320"/>ting damage taken from different tower types.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor321"/>Exercise 3</h2>
			<p>Implement a method that uses a <code>Func</code> delegate to compare two towers based on their range. The method s<a id="_idTextAnchor322"/>hould retu<a id="_idTextAnchor323"/>rn the tower with the longer range.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor324"/>Solutions</h1>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor325"/>Exercise 1</h2>
			<p>Steve implemented a sorting function for towers using a delegate:</p>
			<pre class="source-code">
public class Tower
{
     public string Name { get; set; }
     public int Damage { get; set; }
}
public delegate int CompareTowers(Tower a, Tower b);
public static void SortTowers(List&lt;Tower&gt; towers, CompareTowers compare)
{
     towers.Sort((x, y) =&gt; compare(x, y));
}
// Usage:
List&lt;Tower&gt; towers = new List&lt;Tower&gt;
{
     new Tower { Name = "Archer", Damage = 10 },
     new Tower { Name = "Cannon", Damage = 20 },
     new Tower { Name = "Mage", Damage = 15 }
};
SortTowers(towers, (a, b) =&gt; b.Damage.CompareTo(a.Damage)); // Sort descending
foreach (var tower in towers)
{
     Console.WriteLine($"{tower.Name}: {tower.Damage} damage");
}</pre>			<p>This solution creates a <code>CompareTowers</code> delegate that takes two <code>Tower</code> objects and returns an <code>int</code>. The <code>SortTowers</code> method then u<a id="_idTextAnchor326"/>ses this delegate to sort the list of towers.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor327"/>Exercise 2</h2>
			<p>For enemy health calculations, Steve created this method:</p>
			<pre class="source-code">
public class Enemy
{
     public string Name { get; set; }
     public int Health { get; set; }
}
public static void ProcessEnemies(List&lt;Enemy&gt; enemies, Action&lt;Enemy&gt; action)
{
     foreach (var enemy in enemies)
     {
                  action(enemy);
     }
}
// Usage:
List&lt;Enemy&gt; enemies = new List&lt;Enemy&gt;
{
     new Enemy { Name = "Goblin", Health = 50 },
     new Enemy { Name = "Orc", Health = 100 },
     new Enemy { Name = "Troll", Health = 200 }
};
// Calculate damage from arrow tower
ProcessEnemies(enemies, (e) =&gt; Console.WriteLine($"{e.Name} takes {e.Health * 0.1} damage from arrow tower"));
// Calculate damage from fire tower
ProcessEnemies(enemies, (e) =&gt; Console.WriteLine($"{e.Name} takes {e.Health * 0.2} damage from fire tower"));</pre>			<p>This solution iterates over a list of e<a id="_idTextAnchor328"/>nemies and applies the passed action to each.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor329"/>Exercise 3</h2>
			<p>Here’s a solution to the third problem:</p>
			<pre class="source-code">
public class Tower
{
     public string Name { get; set; }
     public int Range { get; set; }
}
public static Tower GetLongerRangeTower(Tower t1, Tower t2, Func&lt;Tower, Tower, Tower&gt; compare)
{
     return compare(t1, t2);
}
// Usage:
Tower archer = new Tower { Name = "Archer", Range = 50 };
Tower cannon = new Tower { Name = "Cannon", Range = 30 };
Tower longerRange = GetLongerRangeTower(archer, cannon, (a, b) =&gt; a.Range &gt; b.Range ? a : b);
Console.WriteLine($"{longerRange.Name} has the longer range of {longerRange.Range}");</pre>			<p>This solution uses a <code>Func</code> delegate to compare the ranges of<a id="_idTextAnchor330"/> two towers and returns the longer-range one.</p>
			<p>Remember, while these solutions work, there may be other equally valid approaches. These exercises are about reinforcing the concepts learned and exploring different ways to apply them.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor331"/>Summary</h1>
			<p>As we conclude this chapter on higher-order functions and delegates in the context of functional programming in C#, let’s pause to reflect on the key concepts we’ve delved into and anticipate what’s next on our journey:</p>
			<ul>
				<li><strong class="bold">Higher-order functions</strong>: These functions, capable of receiving other functions as parameters or returning them, are foundational in promoting code reusability, abstraction, and a more declarative coding style. Their versatility enhances the expressiveness of our code, allowing us to write more with less.</li>
				<li><strong class="bold">Delegates, actions, funcs, and predicates</strong>: Our exploration of these pivotal functional programming constructs revealed their unique roles and differences. We saw how they contribute to crafting versatile and reliable code, each playing a specific part in the broader functional paradigm.</li>
				<li><strong class="bold">Delegates for callbacks, events, and anonymous methods</strong>: Delegates are the backbone of creating callbacks, managing events, and defining anonymous methods. They enable flexible, event-driven programming structures, crucial for responsive and interactive applications.</li>
				<li><strong class="bold">LINQ as higher-order functions</strong>: We uncovered the immense power of the LINQ library in processing data collections. The emphasis was on how LINQ methods exemplify higher-order functions, offering elegant solutions for complex data manipulation and querying.</li>
				<li><strong class="bold">Best practices and pitfalls</strong>: We rounded off with vital best practices for employing these concepts effectively and avoiding common mistakes. These insights are crucial for writing clean, efficient, and maintainable code.</li>
			</ul>
			<p>In essence, this chapter has illuminated how the principles of functional programming can be effectively harnessed in C#. We’ve seen that by embracing these concepts, developers can achieve greater readability, maintainability, and robustness in their code.</p>
			<p>As we turn the page to the next chapter, our journey into the depths of functional programming continues. We will delve into the intriguing world of functors and monads. These advanced concepts will unlock new levels of abstraction and composability for you. Stay tuned; it will be interesting!</p>
		</div>
	</body></html>