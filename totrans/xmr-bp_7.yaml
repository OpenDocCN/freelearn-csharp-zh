- en: Chapter 7.  Building a File Storage Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：构建文件存储应用程序
- en: 'In this chapter, we will walk through advanced development with `Xamarin.Forms`.
    We take a look at the use of Behaviors on UI elements. Then we will build a custom
    layout using the `Layout <View>` framework. We will also build our first SQLite
    database for storing text files. The following topics will be covered in this
    chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过 `Xamarin.Forms` 的高级开发进行讲解。我们将探讨在 UI 元素上使用 Behaviors 的用法。然后我们将使用 `Layout
    <View>` 框架构建一个自定义布局。我们还将构建我们的第一个 SQLite 数据库来存储文本文件。本章将涵盖以下主题：
- en: 'Expected knowledge:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 预期知识：
- en: Basic Xamarin.Forms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础 Xamarin.Forms
- en: XAML
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAML
- en: MVVM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM
- en: SQL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL
- en: C# threading
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 线程
- en: 'In this chapter, you will learn the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Project structure setup
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目结构设置
- en: Building a data access layer using SQLite
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLite 构建数据访问层
- en: Building the ISQLiteStorage interface
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 ISQLiteStorage 接口
- en: Additional threading techniques
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他线程技术
- en: Creating the AsyncSemaphore
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 AsyncSemaphore
- en: Creating the AsyncLock
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 AsyncLock
- en: Implementing native setup requirements for SQLite
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现SQLite的本地设置要求
- en: Implementing the IoC container and modules
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现IoC容器和模块
- en: Implementing cross-platform logging
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现跨平台日志记录
- en: Implementing the SQLiteStorage class
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 SQLiteStorage 类
- en: Introduction to C# 6.0 syntax
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 6.0 语法简介
- en: Handling alerts in view-models
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视图模型中处理警报
- en: Building the IMethods interface
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 IMethods 接口
- en: Building the ExtendedContentPage
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 ExtendedContentPage
- en: Building a CarouselView using custom layouts
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义布局构建 CarouselView
- en: Adding scroll control to the CarouselView
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 CarouselView 添加滚动控制
- en: Building a CustomRenderer for native gestures
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建用于原生手势的自定义渲染器
- en: Building the user interface
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 UI
- en: Using a SynchronizationContext
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SynchronizationContext
- en: Building the EditFilePage
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 EditFilePage
- en: Challenge
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挑战
- en: Building the Windows Phone version
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Windows Phone 版本
- en: Project structure setup
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构设置
- en: Let's begin by creating a new `Xamarin.Forms` project. Select **File** | **New**
    | **Solution** and create a new **Forms App**, as shown in the following screenshot**:**
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的 `Xamarin.Forms` 项目开始。选择 **文件** | **新建** | **解决方案**，创建一个新的 **Forms
    App**，如图所示：**
- en: '![Project structure setup](img/B05293_07_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![项目结构设置](img/B05293_07_01.jpg)'
- en: 'Call the project `FileStorage`. Once the project is created, create another
    portable class library called `FileStorage.Portable`, as shown in the following
    screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目命名为“FileStorage”。一旦项目创建，创建另一个名为“FileStorage.Portable”的可移植类库，如图所示：
- en: '![Project structure setup](img/B05293_07_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![项目结构设置](img/B05293_07_02.jpg)'
- en: We are going to start at the lower level and work upwards to native projects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从底层开始，逐步构建到原生项目。
- en: Building a data access layer using SQLite
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SQLite 构建数据访问层
- en: In the previous chapter, we focused on project architecture and we discussed
    the concepts one layer for data access this is where our database layer sits.
    Our data access layer is where we will be storing local text files.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们关注了项目架构，并讨论了数据访问层这一层，这是我们的数据库层所在的位置。我们的数据访问层是我们将存储本地文本文件的地方。
- en: SQLite is the most commonly used database framework for mobiles. It is an in-process
    library that implements a self-contained, serverless, zero-configuration, transactional
    SQL database engine, and is free to use.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 是移动设备上最常用的数据库框架。它是一个进程内库，实现了一个自包含、无服务器、零配置、事务性的 SQL 数据库引擎，并且免费使用。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are other frameworks that Xamarin supports such as ADO.NET and Realm,
    but it has been proven that SQLite is the most efficient database layer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin 还支持其他框架，如 ADO.NET 和 Realm，但已经证明 SQLite 是最有效的数据库层。
- en: 'The first step in the setup process is to add the following SQLite NuGet packages
    in our `FileStorage.Portable` project:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 设置过程的第一个步骤是在我们的 `FileStorage.Portable` 项目中添加以下 SQLite NuGet 包：
- en: '`SQLite.Net.Async-PCL`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite.Net.Async-PCL`'
- en: '`SQLite.Net.Core-PCL`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite.Net.Core-PCL`'
- en: '`SQLite.Net-PCL`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite.Net-PCL`'
- en: 'Once you add these in your packages, they should look like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在你的包中添加了这些，它们应该看起来像以下这样：
- en: '![Building a data access layer using SQLite](img/B05293_07_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![使用 SQLite 构建数据访问层](img/B05293_07_03.jpg)'
- en: 'The next step is to add a new folder called `DataAccess`. Inside this folder,
    create two subfolders called `Storable` and `Storage`. Inside the `Storable` folder,
    add a new file called `IStorable.cs` and implement the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个步骤是在此文件夹内创建一个名为 `DataAccess` 的新文件夹。在此文件夹内，创建两个名为 `Storable` 和 `Storage` 的子文件夹。在
    `Storable` 文件夹内，添加一个名为 `IStorable.cs` 的新文件并实现以下内容：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will be the interface for every object type stored in the database. In
    the preceding example, we are only going to have one storable, and each storable
    must have a string property called `Key`. This property will be used as the primary
    key for each database table.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是数据库中存储的每个对象类型的接口。在先前的例子中，我们只会有一个可存储的对象，并且每个可存储对象都必须有一个名为`Key`的字符串属性。这个属性将用作每个数据库表的主键。
- en: 'Create another file in the `Storable` folder called `FileStorable.cs` and implement
    the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Storable`文件夹中创建另一个名为`FileStorable.cs`的文件，并实现以下内容：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `FileStorable` object will be used as the data model for the file storable
    table in the database. In SQLite, during the setup of the database, tables are
    created from objects using the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStorable`对象将用作数据库中文件存储表的数据模型。在SQLite中，在数据库设置期间，表是通过以下方式从对象创建的：'
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `FileStorable` object we pass as the type to the `CreateTable` function
    is used to map columns in the table.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`FileStorable`对象作为类型传递给`CreateTable`函数，用于映射表中的列。
- en: Building the ISQLiteStorage interface
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建ISQLiteStorage接口
- en: 'Now we must set up another class, which  will be used to control the queries
    performed on the database. Add a new file called `ISQLiteStorage.cs` into the
    `Storage` folder and implement the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须设置另一个类，该类将用于控制对数据库执行的查询。在`Storage`文件夹中添加一个名为`ISQLiteStorage.cs`的新文件，并实现以下内容：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding interface defines all the functions that will be executed on the
    database. The advantage of using SQLite is that it performs all processing asynchronously,
    so every function that executes an SQL query returns a task. If you look closely
    at the `InsertObject` and `DeleteObjectByKey` functions, these require a type,
    meaning that we can execute queries to specific tables using types.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的接口定义了将在数据库上执行的所有函数。使用SQLite的优势在于它执行所有处理都是异步的，所以每个执行SQL查询的函数都返回一个任务。如果你仔细查看`InsertObject`和`DeleteObjectByKey`函数，你会发现它们需要一个类型，这意味着我们可以使用类型执行对特定表的查询。
- en: Adding additional threading techniques
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加额外的线程技术
- en: This is where we will add some finesse with a common threading approach known
    as **asynchronous locking**. Since there will only be one instance of the **SQLiteStorage**
    object, this means we have the possibility of a race condition as multiple threads
    can make changes to the same database connection at the same time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将添加一些技巧的地方，使用一种常见的线程方法，称为**异步锁定**。由于将只有一个**SQLiteStorage**对象实例，这意味着我们有可能出现竞态条件，因为多个线程可以同时更改相同的数据库连接。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Race conditions are a common threading issue where multiple threads try to perform
    operations at the same time on shared data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件是常见的线程问题，其中多个线程试图同时在对共享数据进行操作。
- en: How do we solve this problem?
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？
- en: 'Locking is the most common C# approach for restricting shared resources between
    multiple threads. In order to avoid this situation, we create an object for locking
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定是C#中最常见的用于在多个线程之间限制共享资源的做法。为了避免这种情况，我们创建一个对象用于锁定，如下所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, to restrict code blocks to one thread at any one time, we do the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了限制代码块在任何时候只由一个线程访问，我们执行以下操作：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the perfect approach when our code is synchronous. The problem we have
    is our SQLite implementation is asynchronous, and the restriction with basic locking
    is we cannot execute asynchronous code inside a lock statement. This is where
    we have to implement the async-lock pattern.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码是同步的时候，这是一个完美的方法。我们面临的问题是我们的SQLite实现是异步的，而基本锁定的限制是我们不能在锁语句中执行异步代码。这就是我们必须实现async-lock模式的地方。
- en: Creating the AsyncSemaphore
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建AsyncSemaphore
- en: 'Let''s add a new folder called `Threading` to the `FileStorage.Portable` project.
    Inside this folder, we are going to add a new file called `AsyncSemaphore.cs`
    and implement the first part as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`FileStorage.Portable`项目中添加一个名为`Threading`的新文件夹。在这个文件夹中，我们将添加一个名为`AsyncSemaphore.cs`的新文件，并按照以下方式实现第一部分：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A `SemaphoreSlim` object is used to limit the number of threads that can access
    a resource.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`SemaphoreSlim`对象用于限制可以访问资源的线程数量。'
- en: The `AsyncSemaphore` keeps a count (the `m_count` property), which is the number
    of open *slots* it has available to satisfy waiters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncSemaphore`保持一个计数（`m_count`属性），这是它可用于满足等待者的开放槽位数量。'
- en: The `Task` returned from the `WaitAsync` function (the static `s_completed`
    property) will enter the completed state when the `AsyncSemaphore` has given it
    an available slot. That same `Task` will enter the `Canceled` state if the `CancellationToken`
    is signaled before the wait is satisfied; in that case, the `AsyncSemaphore` does
    not lose a slot.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从`WaitAsync`函数（静态`s_completed`属性）返回的`Task`，当`AsyncSemaphore`给它提供一个可用槽位时，将进入完成状态。如果在等待得到满足之前`CancellationToken`被触发，则相同的`Task`将进入`Canceled`状态；在这种情况下，`AsyncSemaphore`不会丢失一个槽位。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A waiter is simply a `TaskCompletionSource` of type bool. It contains a `Task`,
    which is the operation to be performed by a single thread.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 等待者只是一个布尔类型的`TaskCompletionSource`。它包含一个`Task`，这是单个线程要执行的操作。
- en: Creating the AsyncLock
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建AsyncLock
- en: 'Now that we have built the `AsyncSemaphore` class, we will use this object
    inside the `AsyncLock` object. Let''s add a new file called `AsyncLock.cs` into
    the `Threading` folder and implement the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了`AsyncSemaphore`类，我们将在`AsyncLock`对象中使用这个对象。让我们在`Threading`文件夹中添加一个名为`AsyncLock.cs`的新文件，并实现以下内容：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `AsyncLock` class uses the `AsyncSemaphore` to ensure that only one thread
    at any one time has access to the bounded code block after the `LockAsync` function.
    The lock can be acquired asynchronously by calling `LockAsync`, and it is released
    by disposing the result of that task. The `AsyncLock` takes an optional `CancellationToken`,
    which can be used to cancel the acquiring of the lock.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncLock`类使用`AsyncSemaphore`确保在任何时候只有一个线程可以访问`LockAsync`函数之后的代码块。可以通过调用`LockAsync`异步获取锁，并通过处理该任务的输出释放锁。`AsyncLock`接受一个可选的`CancellationToken`，可以用来取消获取锁。'
- en: The `Task` returned from the `LockAsync` function will enter the `Completed`
    state when it has acquired the `AsyncLock`. That same `Task` will enter the Canceled
    state if the `CancellationToken` is signaled before the wait is satisfied; in
    that case, the `AsyncLock` is not taken by that task.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从`LockAsync`函数返回的`Task`，在它获取了`AsyncLock`时将进入`Completed`状态。如果在等待得到满足之前`CancellationToken`被触发，则相同的`Task`将进入取消状态；在这种情况下，`AsyncLock`不会被该任务获取。
- en: Now let's get back to implementing the `SQLiteStorage` class; this is where
    we are going to implement the async-lock pattern.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到实现`SQLiteStorage`类；这是我们将要实现异步锁模式的地方。
- en: Implementing native setup requirements for SQLite
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现SQLite的本地设置要求
- en: Our next step is to add the final setup requirements. Each device platform has
    a specific framework that it must use when setting up the connection to the local
    database. This means we are going to add another dependency-injected interface
    to set these native side requirements.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是添加最终的设置要求。每个设备平台在设置本地数据库连接时都必须使用特定的框架。这意味着我们将添加另一个依赖注入接口来设置这些本地要求。
- en: 'Add a new file called `ISqliteSetup.cs` to the `Storage` folder and implement
    the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Storage`文件夹中添加一个名为`ISqliteSetup.cs`的新文件，并实现以下内容：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Before we implement this class in the platform projects, we need to add the
    following SQLite NuGet packages for all platform projects:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在平台项目中实现这个类之前，我们需要为所有平台项目添加以下SQLite NuGet包：
- en: '`SQLite.Net.Async-PCL`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite.Net.Async-PCL`'
- en: '`SQLite.Net.Core-PCL`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite.Net.Core-PCL`'
- en: '`SQLite.Net-PCL`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite.Net-PCL`'
- en: 'Now let''s turn our attention to the iOS project. Add a new folder called `DataAccess`,
    add in a new file called `SQLiteSetup.cs`, and implement the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将注意力转向iOS项目。添加一个名为`DataAccess`的新文件夹，添加一个名为`SQLiteSetup.cs`的新文件，并实现以下内容：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The main property that we need to focus on is `ISQLitePlatform`. This comes
    from the `SQLite.Net.Interop` library. We will be registering this item inside
    an IoC container as we will need this instance down in the portable project when
    we create a connection to the database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关注的主要属性是`ISQLitePlatform`。这来自`SQLite.Net.Interop`库。我们将在这个IoC容器中注册这个项目，因为我们将在便携式项目中创建数据库连接时需要这个实例。
- en: Before we go any further, we need to set up the IoC container with Autofac.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要使用Autofac设置IoC容器。
- en: Implementing the IoC container and modules
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现IoC容器和模块
- en: Just like our last projects, we are going to set up another IoC container using
    Autofac. Let's first add the Autofac nuget packages to all projects in the solution.
    We can then copy the `IoC` folder from the `Stocklist.Portable` project in [Chapter
    5](ch05.html "Chapter 5. Building a Stocklist Application"), *Building a Stocklist
    Application*. Make sure you include both the `IoC.cs` and `IModule.cs` files.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的工程一样，我们将使用Autofac设置另一个IoC容器。首先，让我们将Autofac nuget包添加到解决方案中的所有项目中。然后，我们可以从[第5章](ch05.html
    "第5章。构建股票列表应用程序")，*构建股票列表应用程序*中的`Stocklist.Portable`项目复制`IoC`文件夹。确保包括`IoC.cs`和`IModule.cs`文件。
- en: 'Now let''s hop over to the native projects, add the `Modules` folder in the
    iOS and Android projects, and implement `IOSModule.cs` and `DroidModule.cs`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳转到原生项目，在iOS和Android项目中添加`Modules`文件夹，并实现`IOSModule.cs`和`DroidModule.cs`：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: and the DroidModule,
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以及DroidModule，
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Notice how quick we are piecing things together?**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意我们如何快速拼凑事物？**'
- en: When you have the right direction in building cross-platform applications, the
    complexity of multiple platform support should not be an issue.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在构建跨平台应用程序的方向上正确时，多个平台支持带来的复杂性不应该是一个问题。
- en: Inside both of the aforementioned modules we are registering the `SQLiteSetup`
    and `SQLitePlatformIOS/Droid` objects so the `SQLiteStorage` implementation can
    use these items inside the `FileStorage.Portable` project.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述两个模块内部，我们正在注册`SQLiteSetup`和`SQLitePlatformIOS/Droid`对象，以便`SQLiteStorage`实现可以在`FileStorage.Portable`项目中使用这些项。
- en: Before we get back to finishing off the `SQLiteStorage` implementation, we are
    going to set up a useful logging approach that can be used in all cross-platform
    applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回到完成`SQLiteStorage`实现之前，我们将设置一个有用的日志方法，该方法可用于所有跨平台应用程序。
- en: Implementing cross-platform logging
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现跨平台日志
- en: 'Now that we have our IoC container, we are going to use dependency injection
    for logging. Adding customized logging features in cross-platform applications
    is very useful for tracking operations between all of the different projects.
    The first step is to add a new folder called `Logging`, add a new file called
    `ILogger.cs`, and implement the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的IoC容器，我们将使用依赖注入来进行日志记录。在跨平台应用程序中添加自定义日志功能对于跟踪所有不同项目之间的操作非常有用。第一步是添加一个名为`Logging`的新文件夹，添加一个名为`ILogger.cs`的新文件，并实现以下内容：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For this example, our logger is going to use the standard `Debug` console from
    `System.Diagnostics` with iOS, but in Android we are going to use the extensive
    logging functionality provided by Android.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们的日志记录器将使用iOS的`System.Diagnostics`中的标准`Debug`控制台，但在Android中我们将使用Android提供的广泛日志功能。
- en: 'Now let''s add the `Logging` folder in both iOS and Android and implement the
    following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在iOS和Android中添加`Logging`文件夹，并实现以下内容：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Nothing too flash with iOS logging, but we have an extra output line for logging
    statements with current time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: iOS的日志记录并不太花哨，但我们有一个额外的输出行来记录带有当前时间的日志语句。
- en: 'Now, for the Android implementation, we are going to use native logging from
    the `Android.Util` library:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于Android实现，我们将使用`Android.Util`库的本地日志：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the `Log` object from the `Android.Util` library, we have the option to specify
    priorities (`info`, `debug`, `error`). The more we can dig into the specifics
    of what we want the application to spit out, the better we can track exactly what
    is happening under the hood.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Android.Util`库的`Log`对象中，我们有指定优先级（`info`、`debug`、`error`）的选项。我们越能深入了解我们希望应用程序输出的具体内容，我们就能更好地跟踪底层发生的确切情况。
- en: Excellent! Now let's get back to building the `SQLiteStorage` implementation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在让我们回到构建`SQLiteStorage`实现。
- en: Implementing the SQLiteStorage class
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现SQLiteStorage类
- en: 'Now back to the `FileStorage.Portable` project. Let''s add another file into
    the `Storage` folder called `SQLiteStorage.cs` and implement the `private` variables:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到`FileStorage.Portable`项目。让我们在`Storage`文件夹中添加另一个名为`SQLiteStorage.cs`的文件，并实现`private`变量：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have a private `AsyncLock` object as we will be doing synchronous and asynchronous
    locking implementations. We then have two SQLite objects for creating the connection
    to our local database. The `_dbPath` variable is used to hold the local database
    path; this will be used for setting up the connection. We also have our dependency
    service interface `ILogger` and another string for tagging the current object.
    Tagging is useful with logging as it tells the logger what class is logging.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个私有的 `AsyncLock` 对象，因为我们将会进行同步和异步锁定实现。然后我们有两个 SQLite 对象用于创建到本地数据库的连接。`_dbPath`
    变量用于保存本地数据库路径；这将用于设置连接。我们还有我们的依赖服务接口 `ILogger` 和另一个用于标记当前对象的字符串。标记在日志记录中很有用，因为它告诉记录器哪个类正在记录。
- en: Introduction to C# 6.0 syntax
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 6.0语法简介
- en: 'Now let''s add in the constructor as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下方式添加构造函数：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here we can see some C# 6.0 syntax. Using the question mark (`?`) after the
    constructor parameter `sqliteSetup` means that, if the object is not null, we
    can access the property. This avoids having to create an `if` statement such as
    the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一些C# 6.0的语法。在构造函数参数 `sqliteSetup` 后使用问号 (`?`) 表示，如果对象不为空，我们可以访问其属性。这避免了需要创建如下所示的
    `if` 语句：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is also some more C# 6.0 syntax with the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些C# 6.0的语法，如下所示：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The dollar sign (`$`) character is used for interpolated strings. Interpolated
    string expressions create a string by replacing the contained expressions with
    the `ToString` representations of the expressions' results.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 美元符号 (`$`) 用于插值字符串。插值字符串表达式通过将包含的表达式替换为表达式的 `ToString` 表示形式来创建字符串。
- en: Look more closely at the items we are assigning. We are using the `SQLiteSetup`
    object to set the database path and SQLite platform properties.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 更仔细地看看我们正在分配的项目。我们正在使用 `SQLiteSetup` 对象来设置数据库路径和 SQLite 平台属性。
- en: 'Let''s add our first two methods:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们的前两个方法：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `CreateSQLiteAsyncConnection` function creates a new `Func` of type `SQLiteConnectionWithLock`,
    we use this `Func` to instantiate a new `SQLiteAsyncConnection`. The `Func` checks
    if we have already created a connection to the database. If we haven't yet established
    this connection, it will create a new instance of the `SQLiteConnectionWithLock`
    object and pass in the database path and platform we retrieved from the `SQLSetup
    object`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateSQLiteAsyncConnection` 函数创建一个新的 `Func` 类型为 `SQLiteConnectionWithLock`，我们使用这个
    `Func` 来实例化一个新的 `SQLiteAsyncConnection`。`Func` 检查我们是否已经创建了数据库的连接。如果我们还没有建立这个连接，它将创建一个新的
    `SQLiteConnectionWithLock` 对象，并传入从 `SQLSetup` 对象获取的数据库路径和平台。'
- en: In the `CreateTable` function, we will take our first look at the async-lock
    pattern. The great thing about the `AsyncLock` object is that we can contain the
    await inside a `using` statement. When one thread is creating a table on the one
    instance of the `SQLiteAsyncConnection`, another thread will have to wait at the
    using line until the previous thread has finished creating the table.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CreateTable` 函数中，我们将首次了解异步锁模式。`AsyncLock` 对象的伟大之处在于我们可以在 `using` 语句内包含 `await`。当一个线程在
    `SQLiteAsyncConnection` 的一个实例上创建表时，另一个线程将不得不在 `using` 行处等待，直到前一个线程完成表的创建。
- en: 'Our next function is `GetTable`. This will use the async-lock pattern again
    to make sure that only one thread is querying the database at any one time. This
    function will perform a standard SQL query for selecting all the items of a table:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个函数是 `GetTable`。这个函数将再次使用异步锁模式，以确保在任何时候只有一个线程正在查询数据库。这个函数将执行一个标准的 SQL 查询，用于选择表的所有项：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The table will be determined by the type `T` passed, and the result received
    from the database will be all the table''s items as an `IEnumerable` of type `T`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 表将由传递的类型 `T` 决定，从数据库接收到的结果将是所有表项的 `IEnumerable<T>` 类型：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice how we are catching any exception that may occur in this query?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何捕获在此查询中可能发生的任何异常的？
- en: We are building a location string to pinpoint the exact location in our application
    where the exception is coming from. Then we use our `ILogger` implementation to
    route the custom-built exception string to the specific native output console.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个位置字符串，以确定异常发生的确切位置。然后我们使用我们的 `ILogger` 实现将自定义的异常字符串路由到特定的原生输出控制台。
- en: 'Next we have the `InsertObject` function. This will be responsible for adding
    a new item to the correct table in the database. We will also make use of the
    async-lock pattern to lock the connection from being accessed while an insertion
    is taking place:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`InsertObject`函数。这个函数将负责将新条目添加到数据库的正确表中。我们还将使用async-lock模式来锁定连接，以防止在插入操作进行时访问连接：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice the `CreateInsertOrReplaceQuery` function?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`CreateInsertOrReplaceQuery`函数吗？
- en: 'We are going to add an extension class to the `IStorable` interface. Add a
    new file called `StorableExtensions.cs` to the location **DataAccess****| Storable**
    in the `FileStorage.Portable` project and implement the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向`IStorable`接口添加一个扩展类。在`FileStorage.Portable`项目中，在**DataAccess**| **Storable**位置添加一个名为`StorableExtensions.cs`的新文件，并实现以下内容：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding function is clever enough to build an insert and replace query
    out of any item that inherits the `IStorable` interface. It uses the `System.Reflection`
    library to retrieve all properties of an `IStorable` object using the `GetRuntimeProperties`
    function. We then iterate through all properties and build a query according to
    the following syntax:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数足够聪明，可以从继承自`IStorable`接口的任何条目中构建插入和替换查询。它使用`System.Reflection`库通过`GetRuntimeProperties`函数检索`IStorable`对象的全部属性。然后我们遍历所有属性，根据以下语法构建查询：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If we didn't have the `PrimaryKey` attribute set on the `Key` property in the
    `FileStorable` class, the update would not work and a new item would be added
    every time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在`FileStorable`类的`Key`属性上设置`PrimaryKey`属性，更新将不会工作，并且每次都会添加一个新的条目。
- en: 'Now for the `DeleteObjectByKey` function. This will be used to delete an item
    from a table using the `Key` property from the `IStorable` interface:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`DeleteObjectByKey`函数。这个函数将用于通过`IStorable`接口的`Key`属性从表中删除一个条目：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Fantastic! SQLite has been set up and integrated with the async-lock pattern
    to make it thread-safe. Our final step is to add the `PortableModule` for the
    IoC container and register the `SqliteStorage` class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！SQLite已经设置并集成了async-lock模式以使其线程安全。我们的最后一步是为IoC容器添加`PortableModule`并注册`SqliteStorage`类。
- en: 'Inside the `FireStorable.Portable` project, create a new folder called `Modules`,
    add in a new file called `PortableModule.cs`, and implement the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FireStorable.Portable`项目中，创建一个名为`Modules`的新文件夹，添加一个名为`PortableModule.cs`的新文件，并实现以下内容：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now we can start with the user interface layer and begin building some custom
    UI objects.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始构建用户界面层，并开始构建一些自定义UI对象。
- en: Handling alerts in view-models
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在视图模型中处理警报
- en: 'Handling alerts via view-models is important as we handle many errors via `try/catch`
    statements. To respond to these errors, we want to display an alert dialog showing
    the error message to the user. There are two ways we are going to do this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过视图模型处理警报很重要，因为我们通过`try/catch`语句处理许多错误。为了响应这些错误，我们希望显示一个警报对话框，向用户显示错误消息。我们将有两种方法来完成这项工作：
- en: Using an `EventHandler` for pushing events to the current page so that we can
    call the `DisplayAlert` function with different messages
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`EventHandler`将事件推送到当前页面，以便我们可以使用不同的消息调用`DisplayAlert`函数
- en: Using an interface for dependency injection where we will implement native alerts
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口进行依赖注入，我们将实现原生警报
- en: Our first step is to add the `ViewModelBase` class; this is where alerts will
    be fired from.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是添加`ViewModelBase`类；这是触发警报的地方。
- en: 'Create a new folder in the `FileStorage.Portable` project called `ViewModels`,
    add a new file called `ViewModelBase.cs`, and implement the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FileStorage.Portable`项目中创建一个名为`ViewModels`的新文件夹，添加一个名为`ViewModelBase.cs`的新文件，并实现以下内容：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are using the same `ViewModelBase` implementation we used in [Chapter 5](ch05.html
    "Chapter 5. Building a Stocklist Application"), *Building a Stocklist Application*,
    except we are adding an extra `IMethods` interface in the constructor (we will
    implement this later), which is used to show native alerts.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与[第5章](ch05.html "第5章。构建股票列表应用程序")中相同的`ViewModelBase`实现，即*构建股票列表应用程序*，但我们将在构造函数中添加一个额外的`IMethods`接口（我们稍后将实现它），该接口用于显示原生警报。
- en: 'Next, add the protected methods `OnPropertyChanged` and `LoadAsync` as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加受保护的`OnPropertyChanged`和`LoadAsync`方法，如下所示：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And the public methods as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以及以下公共方法：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even though we are working in the portable project, this is still part of the
    presentation layer when it comes to architecture.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们正在便携式项目中工作，但这仍然是架构中的表示层的一部分。
- en: The `NotifyAlert` function is used to display alerts via the `Xamarin.Forms`
    function `DisplayAlert` on a `ContentPage`. The `ShowEntryAlert` function is used
    to display alerts via the `IMethod` interface.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotifyAlert`函数用于通过`Xamarin.Forms`函数`DisplayAlert`在`ContentPage`上显示警报。`ShowEntryAlert`函数用于通过`IMethod`接口显示警报。'
- en: Notice the use of the TaskCompletionSource?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`TaskCompletionSource`的使用吗？
- en: This means we can await the `ShowEntryAlert` function. When the user responds
    to the alert, the `Task` will enter the completed state. This ensures that the
    code is executed only once a response is received.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以等待`ShowEntryAlert`函数。当用户对警报做出响应时，`Task`将进入完成状态。这确保了代码仅在收到响应后执行一次。
- en: Building the IMethods interface
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建IMethods接口
- en: 'Let''s start by creating a new folder in the `FileStorage.Portable` project,
    adding a new file called `IMethods.cs`, and implementing the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`FileStorage.Portable`项目中创建一个新的文件夹，添加一个名为`IMethods.cs`的新文件，并实现以下内容：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For all native projects, add a new folder called `Extras`. Let''s start with
    the iOS project. add a new file called `IOSMethods.cs`, and implement the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有原生项目，添加一个名为`Extras`的新文件夹。让我们从iOS项目开始。添加一个名为`IOSMethods.cs`的新文件，并实现以下内容：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We should recognize the `Exit` function from previous chapters. The `DisplayEntryAlert`
    function creates a `PlainTextInputUIAlertView`. This alert will ask for text input
    via a textbox and we can retrieve this text value using the `GetTextField` function.
    The alert will also display a `Yes` and `No` button, so when the user enters text
    and presses `Yes`, a new file will be created with the text input set as the filename.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该识别前几章中的`Exit`函数。`DisplayEntryAlert`函数创建一个`PlainTextInputUIAlertView`。此警报将通过文本框请求文本输入，我们可以使用`GetTextField`函数检索此文本值。警报还将显示一个`是`和`否`按钮，因此当用户输入文本并点击`是`时，将创建一个新文件，其文件名设置为输入的文本。
- en: 'Now let''s replicate the same procedure for Android. Add a new file called
    `DroidMethods.cs` and implement the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为Android复制相同的程序。添加一个名为`DroidMethods.cs`的新文件，并实现以下内容：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This time for Android, we are using the `AlertDialog.Builder` framework. We
    use the `Forms.Context` property to retrieve the current context, which we use
    to create a new `AlertDialog.Builder`. We have to use the `SetView` function in
    this framework to assign a custom view for text input. This custom view is created
    using a new XML layout.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这次为Android，我们使用`AlertDialog.Builder`框架。我们使用`Forms.Context`属性来检索当前上下文，我们使用它来创建一个新的`AlertDialog.Builder`。我们必须在这个框架中使用`SetView`函数来分配一个自定义视图用于文本输入。这个自定义视图是使用一个新的XML布局创建的。
- en: 'Add a new file called `EntryAlertView.xml` to the **Resources** | **layout**
    folder and implement the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在**资源** | **布局**文件夹中添加一个名为`EntryAlertView.xml`的新文件，并实现以下内容：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: All we have is an `EditText` object to retrieve the filename from the user in
    the alert dialog. Using `FindViewById` in the `DroidMethods` class, we can reference
    this `EditText` item to retrieve the text value entered by the user.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所拥有的只是一个`EditText`对象，用于在警报对话框中从用户那里检索文件名。在`DroidMethods`类中使用`FindViewById`，我们可以引用此`EditText`项以检索用户输入的文本值。
- en: That's everything. Our next step is a customized `ContentPage` to handle the
    `Alert` events from each view-model.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了。我们的下一步是创建一个定制的`ContentPage`来处理每个视图模型的`Alert`事件。
- en: Building the ExtendedContentPage
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建扩展内容页面
- en: 'Add a new folder called `UI` inside the `FileStorage` project, add in a new
    file called `ExtendedContentPage.cs`, and implement the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FileStorage`项目中添加一个名为`UI`的新文件夹，添加一个名为`ExtendedContentPage.cs`的新文件，并实现以下内容：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `_model` property is used to reference the view-model of each page as every
    view-model inherits the `ViewModelBase` class. When the page is created, we register
    the `HandleAlert` function to the view-model `Alert` event. Every time this function
    is called, it will call the `DisplayAlert` function from `Xamarin.Forms`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`_model`属性用于引用每个页面的视图模型，因为每个视图模型都继承自`ViewModelBase`类。当页面创建时，我们将`HandleAlert`函数注册到视图模型的`Alert`事件。每次此函数被调用时，它将调用`Xamarin.Forms`中的`DisplayAlert`函数。'
- en: Why are we implementing two different techniques for showing alerts?
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们要实现两种不同的显示警报的技术？
- en: The cross-platform feature for displaying alerts does not allow us to use the
    text input addition that we built natively.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 显示警报的跨平台功能不允许我们使用我们本地构建的文本输入添加功能。
- en: Great! We now have a nice solution for multiple types of alert in out cross-platform
    projects. Our next step is to implement our first custom layout known as a `CarouselView`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在为我们的跨平台项目找到了一个很好的多种类型警报的解决方案。我们的下一步是实现我们第一个自定义布局，称为 `CarouselView`。
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`Xamarin.Forms` has its own `CarouselView`, but it has been removed until the
    UI object is more stable.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Xamarin.Forms` 有自己的 `CarouselView`，但它已被移除，直到 UI 对象更加稳定。'
- en: Building a CarouselView using custom layouts
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义布局构建 CarouselView
- en: '`Xamarin.Forms` is a very young layout system, meaning that the number of layouts
    is quite limited. There are times when we will need to implement our own custom
    layouts to give us control over exactly where and how our views and controls appear
    on screen. The requirement will come from situations where you need to improve
    performance on screens that display a lot of views and controls, and sometimes
    the standard layouts are not good enough. We want to implement our custom layouts
    to carry out the absolute minimum amount of work required to produce the required
    layout.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Xamarin.Forms` 是一个非常年轻的布局系统，这意味着布局的种类相当有限。有时候，我们需要实现自己的自定义布局来控制我们的视图和控制元素在屏幕上的确切位置和方式。这种需求可能来自于需要提高显示大量视图和控制元素的屏幕性能的情况，有时标准布局不足以满足需求。我们希望实现自定义布局以执行产生所需布局所需的最小工作量。'
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All layouts derive from the `Xamarin.Forms.Layout` class, which provides the
    required mechanisms for adding and removing children internally as well as some
    key utilities for writing a layout.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所有布局都派生自 `Xamarin.Forms.Layout` 类，它提供了添加和移除子项所需的机制，以及一些编写布局时的一些关键实用工具。
- en: 'Let''s start by adding a new folder called `Controls` in the `FireStorable`
    project. Add a new file called `CarouselLayout.cs` and implement the first part
    as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `FireStorable` 项目中添加一个名为 `Controls` 的新文件夹。添加一个名为 `CarouselLayout.cs` 的新文件，并按照以下方式实现第一部分：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All layouts must inherit the `Layout` framework. `Xamarin.Forms.Layout<T>` provides
    a publicly exposed `IList<T>` Children that end users can access. We want all
    children of this collection to be of type `View`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所有布局都必须继承 `Layout` 框架。`Xamarin.Forms.Layout<T>` 提供了一个公开的 `IList<T>` Children，最终用户可以访问。我们希望这个集合的所有子项都是
    `View` 类型。
- en: We have two `private` properties, one for the layout width and an `IDisposable`
    for handling data change subscriptions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个 `private` 属性，一个用于布局宽度，一个 `IDisposable` 用于处理数据更改订阅。
- en: 'Let''s add in some more properties:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些更多属性：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We have an indexing reference that will return an array element from the **`ItemsSource
    IEnumerable`** , and the `ItemTemplate` property, which is used to render a view
    layout for every child in `ItemsSource`. We have to use the `Linq` function `ToList`
    to allow us to access an `IEnumerable` via an index value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个索引引用，它将从 **`ItemsSource IEnumerable`** 返回一个数组元素，以及 `ItemTemplate` 属性，它用于为
    `ItemsSource` 中的每个子项渲染视图布局。我们必须使用 `Linq` 函数 `ToList` 来允许我们通过索引值访问 `IEnumerable`。
- en: 'Now we are going to add some overrides to the `Layout` framework. Every custom
    layout must override the `LayoutChildren` method. This is responsible for positioning
    children on screen:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加一些对 `Layout` 框架的重写。每个自定义布局都必须重写 `LayoutChildren` 方法。这负责在屏幕上定位子项：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding function will call another method, `ComputeLayout`, which will
    return an `IEnumerable` of **Rectangles** (also known as **regions**). We then
    iterate through the `IEnumerable` and call `LayoutChildIntoBoundingRegion` for
    each region. This method will handle positioning the element relative to the bounding
    region.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将调用另一个方法 `ComputeLayout`，该方法将返回一个 **`Rectangles`**（也称为 **`regions`**）的
    `IEnumerable`。然后我们遍历 `IEnumerable` 并为每个区域调用 `LayoutChildIntoBoundingRegion`。此方法将处理元素相对于边界区域的位置。
- en: 'Our layout must also implement the `OnMeasure` function. This is required to
    make sure the new layout is sized correctly when placed inside other layouts.
    During layout cycles, this method may be called many times depending on the layout
    above it and how many layout exceptions are required to resolve the current layout
    hierarchy. Add the following below the `LayoutChildren` function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的布局还必须实现 `OnMeasure` 函数。这是为了确保新布局在放置在其他布局内部时尺寸正确。在布局周期中，这个方法可能会根据其上方的布局和解决当前布局层次结构所需的布局异常数量多次被调用。在
    `LayoutChildren` 函数下方添加以下内容：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Tip
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is therefore important to consider speed when implementing this function.
    Failure to implement this function will not always break your layout, particularly
    if it's always inside parents, which fix the child size anyway.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在实现此函数时考虑速度很重要。未能实现此函数并不总是会破坏你的布局，尤其是如果它始终在父元素内部，因为父元素无论如何都会固定子项的大小。
- en: The `ComputeNiaveLayout` will return a list of **rows**. We then retrieve the
    last row from this list and use this for the max x-value and max y-value to determine
    the total width and height by calculating the difference between the first and
    last element on both the x-axis and y-axis. Finally, we return a new `SizeRequest`
    object with the calculated width and height, which will be used to resize the
    layout.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComputeNiaveLayout` 将返回一个 **行** 列表。然后我们从该列表中检索最后一行，并使用它来确定最大 x 值和最大 y 值，通过计算
    x 轴和 y 轴上第一个和最后一个元素之间的差异来计算总宽度和高度。最后，我们返回一个新的 `SizeRequest` 对象，包含计算出的宽度和高度，这将用于调整布局的大小。'
- en: 'Let''s add the missing functions `ComputeNiaveLayout` and `ComputeLayout` as
    follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加缺失的函数 `ComputeNiaveLayout` 和 `ComputeLayout`，如下所示：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This function is used simply to perform the `SelectMany` query. The `ComputeNiaveLayout`
    layout is where all the work is done. This will iterate through all children;
    it will create one **row**, and one rectangle inside this row that will size to
    the height of the layout and the width will equal the total of all children widths.
    All children will be positioned horizontally next to one another to the right
    of the screen, as shown in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅用于执行 `SelectMany` 查询。`ComputeNiaveLayout` 布局是所有工作完成的地方。这将遍历所有子项；它将创建一个 **行**，并在该行内创建一个矩形，该矩形的大小将等于布局的高度，宽度将等于所有子项宽度的总和。所有子项将水平并排放置在屏幕右侧，如下面的截图所示：
- en: '![Building a CarouselView using custom layouts](img/B05293_07_04-1.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义布局构建 CarouselView](img/B05293_07_04-1.jpg)'
- en: 'But only one child will be visible on screen at any one time as each child
    is sized to the full height and width of the layout:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但在任何时候屏幕上只能看到一个子项，因为每个子项的大小被设置为布局的完整高度和宽度：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Hold on! What if I have a lot of children? This means that they will be stacked
    horizontally past the width of the screen. What do we do now?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！如果我有很多子项呢？这意味着它们将水平堆叠超过屏幕宽度。我们现在该怎么办？
- en: 'The idea of a carousel view is to only show one view at a time, when the user
    swipes left and right; the view on the left/right side of the current view will
    come onto screen while the current view will move out of view, as shown in the
    following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: CarouselView 的理念是每次只显示一个视图，当用户左右滑动时；当前视图左侧/右侧的视图将出现在屏幕上，而当前视图将移出视图，如下面的截图所示：
- en: '![Building a CarouselView using custom layouts](img/B05293_07_05.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义布局构建 CarouselView](img/B05293_07_05.jpg)'
- en: Even though we have a custom layout that presents children horizontally, how
    are we going to handle the swipe events and scroll control?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有一个水平展示子项的自定义布局，但我们如何处理滑动事件和滚动控制？
- en: We will achieve scroll control via a `ScrollView` and create a custom renderer
    for handling swipe events.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 `ScrollView` 实现滚动控制，并为处理滑动事件创建一个自定义渲染器。
- en: Adding scroll control to the CarouselView
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 CarouselView 添加滚动控制
- en: 'Add a new file into the `Controls` folder called `CarouselScroll.cs` and implement
    the first part as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Controls` 文件夹中添加一个名为 `CarouselScroll.cs` 的新文件，并按照以下方式实现第一部分：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `CarouselScroll` will inherit the `ScrollView` object as this will be the
    bounding view for the `CarouselLayout`. We are also going to create a `DataTemplate`
    variable for setting the `DataTemplate` object inside the `CarouselLayout`. Then,
    in the constructor, we instantiate a new `CarouselLayout` object as the `Content`
    of the `ScrollView`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarouselScroll` 将继承 `ScrollView` 对象，因为这将作为 `CarouselLayout` 的边界视图。我们还将创建一个
    `DataTemplate` 变量，用于在 `CarouselLayout` 中设置 `DataTemplate` 对象。然后，在构造函数中，我们实例化一个新的
    `CarouselLayout` 对象，作为 `ScrollView` 的 `Content`。'
- en: 'Now let''s add a custom binding object for the `ItemsSource`. Like a `ListView`,
    we will bind an `ObserableCollection` of items to this property:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为 `ItemsSource` 添加一个自定义绑定对象。就像 `ListView` 一样，我们将绑定一个 `ObserableCollection`
    项到这个属性：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Take note of the `propertyChanged` event; when the binding changes, we will
    update the `ItemsSource` property of the `CarouselLayout.` Remember that the `CarouselLayout`
    is in charge of laying out a child for every item in the `IEnumerable`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `propertyChanged` 事件；当绑定发生变化时，我们将更新 `CarouselLayout` 的 `ItemsSource` 属性。记住，`CarouselLayout`
    负责为 `IEnumerable` 中的每个项目布局子项。
- en: 'We also need another bindable property for data changes. This will be an `IObservable`
    object that will listen for any `DataChange` events. If an event occurs, the `CarouselLayout`
    will layout the children:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要另一个可绑定属性来处理数据变化。这将是一个`IObservable`对象，它将监听任何`DataChange`事件。如果发生事件，`CarouselLayout`将布局子项：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then we need to override the `LayoutChildren` function; so when the `ScrollView`
    updates its children, we want to update the height and width properties of the
    `CarouselLayout`, thus updating the layout of the children:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要重写`LayoutChildren`函数；因此当`ScrollView`更新其子项时，我们希望更新`CarouselLayout`的高度和宽度属性，从而更新子项的布局：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We also have one more function, `GetSelectedItem`, which simply returns a child
    from the `CarouselLayout` using an index:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个额外的函数，`GetSelectedItem`，它简单地使用索引从`CarouselLayout`返回一个子项：
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our next stage into the `CarouselView` is creating a `CustomRenderer` that will
    allow swipe gestures.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入`CarouselView`的下一阶段是创建一个允许滑动手势的`CustomRenderer`。
- en: Building a CustomRenderer for native gestures
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用于原生手势的CustomRenderer
- en: 'Now we need to handle swipe left and right gestures for each mobile platform.
    Unfortunately, `Xamarin.Forms` doesn''t offer a cross-platform feature for swipe
    gestures, so we need to implement this ourselves. In order to do this, we are
    going to build a `CustomRenderer`. Start by adding a new file to the `Controls`
    folder called `GestureView.cs` and implement the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为每个移动平台处理左右滑动手势。不幸的是，`Xamarin.Forms`没有提供跨平台的滑动手势功能，因此我们需要自己实现这个功能。为了做到这一点，我们将构建一个`CustomRenderer`。首先，在`Controls`文件夹中添加一个名为`GestureView.cs`的新文件并实现以下内容：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This view has an `EventHandler` for each gesture, we also require a gesture
    for tap events. Even though `Xamarin.Forms` offers this feature when we render
    over the top of the `CarouselView` at runtime, the `Xamarin.Forms` gesture will
    no longer work.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图为每个手势都有一个`EventHandler`，我们还需要一个用于点击事件的手势。尽管`Xamarin.Forms`在运行时渲染在`CarouselView`之上时提供了这个功能，但`Xamarin.Forms`的手势将不再工作。
- en: 'Now, inside the `FileStorage.iOS` project, let''s add a new folder called `Renderers`
    and another folder inside this called `GestureView`. Then, inside the `GestureView`
    folder, add in a new file called `GestureViewiOS.cs` and implement the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`FileStorage.iOS`项目中，让我们添加一个名为`Renderers`的新文件夹，并在其中添加一个名为`GestureView`的子文件夹。然后，在`GestureView`文件夹中，添加一个名为`GestureViewiOS.cs`的新文件并实现以下内容：
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This view has an `EventHandler` for each gesture, we also require a gesture
    for tap events. Even though `Xamarin.Forms` offers these features when we render
    over the top of the `CarouselView` at runtime, the Xamarin.Forms gesture will
    no longer work.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图为每个手势都有一个`EventHandler`，我们还需要一个用于点击事件的手势。尽管`Xamarin.Forms`在运行时渲染在`CarouselView`之上时提供了这些功能，但`Xamarin.Forms`的手势将不再工作。
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This function will only be called once from the `OnElementChanged` function
    of the `GestureViewRenderer`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将只从`GestureViewRenderer`的`OnElementChanged`函数中调用一次。
- en: 'Now let''s add the renderer class. Add another file called `GestureViewRenderer.cs`
    and implement the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加渲染器类。添加一个名为`GestureViewRenderer.cs`的新文件并实现以下内容：
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Whenever a property from the `UI` object changes, the `OnElementChanged` function
    will be called. We only call the `SetNativeControl` once if the `Control` property
    of the renderer is null. The `Element` property of a renderer is usually the UI
    object from the `Xamarin.Forms` project (in our case the `FileStorage` project,
    `GestureView`). When we receive a reference to the `GestureView` object (inside
    the `OnElementChanged` function), we pass this into the `InitGestures` function
    in order to use the `EventHandlers` on the `GestureView` object. Now, when we
    swipe left and right or tap on the native `mainView` object, it will call the
    `NotifySwipeLeft`, `NotifySwipeLeft`, and `NotifyTouch` functions for the `GestureView`
    object.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`UI`对象的属性发生变化时，`OnElementChanged`函数将被调用。如果渲染器的`Control`属性为null，我们只调用一次`SetNativeControl`。渲染器的`Element`属性通常是`Xamarin.Forms`项目中的UI对象（在我们的案例中是`FileStorage`项目的`GestureView`）。当我们收到`GestureView`对象的引用（在`OnElementChanged`函数内部）时，我们将此传递给`InitGestures`函数，以便在`GestureView`对象上使用`EventHandlers`。现在，当我们左右滑动或点击原生`mainView`对象时，它将调用`GestureView`对象的`NotifySwipeLeft`、`NotifySwipeRight`和`NotifyTouch`函数。
- en: 'Don''t forget to add the following line above the namespace declaration:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在命名空间声明上方添加以下行：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We must always add the `ExportRenderer` attribute to a custom renderer class
    to specify that it will be used to render the `Xamarin.Forms` control.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须始终向自定义渲染器类添加`ExportRenderer`属性，以指定它将用于渲染`Xamarin.Forms`控件。
- en: The `GestureViewiOS` object will be the view displayed on top of the `GestureView`
    object in our `FileStorage` project. Wherever a new `GestureView` object is placed
    in our `ContentPage`, the `GestureViewRenderer` will render a new `GestreViewiOS`view
    in its place.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement the same for Android. Add a new folder inside the `FileStorage.Droid`
    project called `Renderers` and another folder inside this called `GestureView`.
    Then, inside the `GestureView` folder, add in a new file called `GestureListener.cs`
    and implement the first part:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: A `GestureDetector` is used to respond to multiple types of press event for
    a particular view. We also pass the `Xamarin.Forms GestureView` object into this
    class so that we can fire the `NotifySwipeLeft`, `NotifySwipeLeft`, and `NotifyTouch`
    functions when a particular event occurs. The threshold values are used as a minimum
    swipe distance and touch pressure. When a user performs a swipe on this view,
    a certain amount of pressure and movement must be applied for an event to be fired.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `SimpleOnGestureListener` extension is a convenience class when you only
    want to listen for a subset of all the gestures.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we must override the following functions (we aren''t going to be doing
    anything with these but they must be overridden):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now for the functions that we are going to use. The `OnSingleTapUp` function
    will be responsible for handling touch events, called when a user applies a single
    tap gesture to the view:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `OnFling` function is responsible for handling swipe events. The two `MotionEvent`
    items are the start and end points (*x*, *y*) when a user starts to swipe and
    when the finger is removed. We calculate the drag distance and make sure that
    the absolute value of `diffX` is greater than the absolute value of `diffY`. This
    ensures that we are dragging horizontally. We then make sure that the absolute
    value of `diffX` is greater than the `Swipe_Threshold`, and the `VelocityX` is
    greater than the `Swipe_Velocity_Threshold`. If all this is met, we then fire
    a swipe right if the `diffX` is positive; otherwise, it will fire a swipe left:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s now build the `GestureViewRenderer` and integrate is with the `GestureDetector`.
    Add a new file into the `Gesture` folder called `GestureViewRenderer.cs` and implement
    the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We are now going to create an empty `LinearLayout`to use for the `Control`.
    This is the blank view that will receive the touch events. We then instantiate
    a new `GestureListener` from above and pass this into a new `GestureDetector`.
    The GestureDetector''s `OnTouchEvent` function is called for all touch and motion
    events, and within this class we break down the events in more detail to determine
    the exact event that took place:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Notice the null checks on the `OldElemenet` and `NewElement` properties of the
    arguments?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: If the `OldElemenet` is null, we must deregister touch events, and if the `NewElement`
    is null, we register the `GenericMotion` and `Touch` events.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `GestureView` and `GestureViewRenderers` ready, it''s
    time to create the final control and add a new **Forms ContentView Xaml** file
    called `CarouselView.xaml`, as shown in the following screenshot:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`GestureView`和`GestureViewRenderers`，是时候创建最终控件并添加一个名为`CarouselView.xaml`的新**Forms
    ContentView Xaml**文件，如下面的截图所示：
- en: '![Building a CustomRenderer for native gestures](img/B05293_07_06.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![构建用于原生手势的自定义渲染器](img/B05293_07_06.jpg)'
- en: 'We also implement the following in `CarouselView.xaml`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`CarouselView.xaml`中实现了以下内容：
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The preceding code will create a `Grid` to overlay the `GestureView` on top
    of the `CarouselScroll`. This means that the `GestureView` will detect the swipe
    and touch events and pass these down to the `CarouselScroll`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建一个`Grid`，将其覆盖在`GestureView`之上，位于`CarouselScroll`之上。这意味着`GestureView`将检测滑动和触摸事件，并将这些事件传递给`CarouselScroll`。
- en: 'Now let''s implement `CarouselView.xaml.cs` as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下内容实现`CarouselView.xaml.cs`：
- en: '[PRE58]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The first part shows the event registration to the `GestureView`. We also have
    a custom binding for a `Command`, which will be invoked when a `Touch` event occurs.
    Let''s add the `EventHandler` functions as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分显示了事件注册到`GestureView`。我们还有一个自定义的`Command`绑定，当发生`Touch`事件时将被调用。让我们添加以下`EventHandler`函数：
- en: '[PRE59]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `HandleTouch` function will simply call the `GetSelectedItem` function from
    the `CarouselScroll.` This means we get the bound object from the view and we
    use this as a parameter that is passed into the execution of the `SelectCommand`.
    The `HandleSwipeLeft` function will increase the selected index by 1 and scroll
    to the left by the entire width amount of the view. Remember, each child takes
    up the entire width and height of the view, so in order to move to the next child,
    we have to scroll horizontally by the width.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandleTouch`函数将简单地调用`CarouselScroll`中的`GetSelectedItem`函数。这意味着我们从视图中获取绑定对象，并将其用作传递给`SelectCommand`执行参数。`HandleSwipeLeft`函数将增加所选索引的值1，并滚动视图的整个宽度。记住，每个子项占据视图的整个宽度和高度，因此为了移动到下一个子项，我们必须水平滚动宽度。'
- en: Then we have the `HandleSwipeRight` function, which will perform the opposite
    to `HandleSwipeLeft` and scroll in the opposite direction. In each swipe function,
    we also perform a check to see if we are on the starting child or the last child.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有`HandleSwipeRight`函数，它将执行与`HandleSwipeLeft`相反的操作，并沿相反方向滚动。在每个滑动函数中，我们也执行一个检查，看看我们是否在起始子项或最后一个子项上。
- en: Congratulations, you have just built your first custom layout. Now let's build
    the rest of the user interface and see how we can use it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你刚刚构建了你的第一个自定义布局。现在让我们构建用户界面的其余部分，看看我们如何使用它。
- en: Building the user interface
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: 'It''s now time to build the user interface screens; we are going to start by building
    the view-models. Inside the `FileStorage.Portable` project, add a new folder called
    `ViewModels`, add a new file called `MainPageViewModel.cs`, and implement the
    following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候构建用户界面屏幕了；我们将从构建视图模型开始。在`FileStorage.Portable`项目中，添加一个名为`ViewModels`的新文件夹，添加一个名为`MainPageViewModel.cs`的新文件，并实现以下内容：
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We include the `ISQLiteStorage` object in this view-model because we will be
    creating the database tables when this view-model is created. Don''t forget we
    need to implement the public properties for all `private` properties; the following
    are two properties to get you started:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个视图模型中包含了`ISQLiteStorage`对象，因为当这个视图模型被创建时，我们将创建数据库表。别忘了我们需要为所有`private`属性实现公共属性；以下是有助于你开始的两个属性：
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then we add the remaining properties. We call the `SetupSQLite` function from
    the constructor to set up the database as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加剩余的属性。我们在构造函数中调用`SetupSQLite`函数来设置数据库，如下所示：
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `SetupSQLite` function is responsible for creating the asynchronous connection
    to the local database and building the one table from the `FileStorable` object.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupSQLite`函数负责创建到本地数据库的异步连接，并从`FileStorable`对象构建一个表。'
- en: 'Now let''s build the page for this view-model. Add a new folder called `Pages`
    inside the `FileStorage` project, add in a new file called `MainPage.xaml`, and
    implement the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为这个视图模型构建页面。在`FileStorage`项目中添加一个名为`Pages`的新文件夹，添加一个名为`MainPage.xaml`的新文件，并实现以下内容：
- en: '[PRE63]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Remember our custom control `ExtendedContentPage`?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们的自定义控件`ExtendedContentPage`吗？
- en: 'We are going to use this for all pages so that every page has alert functionality
    connected with its view-model. The following line gives the reference to our custom
    control:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 'We are going to use this for all pages so that every page has alert functionality
    connected with its view-model. The following line gives the reference to our custom
    control:'
- en: '[PRE64]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: <ui:ExtendedContentPage
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: <ui:ExtendedContentPage
- en: '[PRE65]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'public partial class MainPage : ExtendedContentPage, INavigableXamarinFormsPage'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 'public partial class MainPage : ExtendedContentPage, INavigableXamarinFormsPage'
- en: '{'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '#region Constructors'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#region Constructors'
- en: 'public MainPage (MainPageViewModel model) : base(model)'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'public MainPage (MainPageViewModel model) : base(model)'
- en: '{'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: BindingContext = model;
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: BindingContext = model;
- en: InitializeComponent ();
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: InitializeComponent ();
- en: '}'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '#endregion'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#endregion'
- en: '#region INavigableXamarinFormsPage interface'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#region INavigableXamarinFormsPage interface'
- en: public void OnNavigatedTo(IDictionary<string, object> navigationParameters)
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public void OnNavigatedTo(IDictionary<string, object> navigationParameters)
- en: '{'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: this.Show (navigationParameters);
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: this.Show (navigationParameters);
- en: '}'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '#endregion'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#endregion'
- en: '}'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE66]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'public class FileItemViewModel : ViewModelBase'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 'public class FileItemViewModel : ViewModelBase'
- en: '{'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '#region Private Properties'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#region Private Properties'
- en: private string _fileName;
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private string _fileName;
- en: private string _contents;
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private string _contents;
- en: '#endregion'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#endregion'
- en: '#region Public Properties'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#region Public Properties'
- en: public string FileName
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public string FileName
- en: '{'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: get
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: get
- en: '{'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: return _fileName;
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return _fileName;
- en: '}'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: set
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: set
- en: '{'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: if (value.Equals(_fileName))
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (value.Equals(_fileName))
- en: '{'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: return;
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return;
- en: '}'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: _fileName = value; OnPropertyChanged("FileName");
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: _fileName = value; OnPropertyChanged("FileName");
- en: '}'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: public string Contents
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public string Contents
- en: '{'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: get
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: get
- en: '{'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: return _contents;
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return _contents;
- en: '}'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: set
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: set
- en: '{'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: if (value.Equals(_contents))
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (value.Equals(_contents))
- en: '{'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: return;
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return;
- en: '}'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: _contents = value; OnPropertyChanged("Contents");
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: _contents = value; OnPropertyChanged("Contents");
- en: '}'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '#endregion'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#endregion'
- en: '#region Public Methods'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#region Public Methods'
- en: public void Apply(FileStorable file)
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public void Apply(FileStorable file)
- en: '{'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: FileName = file.Key ?? string.Empty;
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: FileName = file.Key ?? string.Empty;
- en: Contents = file.Contents ?? string.Empty;
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Contents = file.Contents ?? string.Empty;
- en: '}'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '#endregion'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#endregion'
- en: '#region Constructors'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#region Constructors'
- en: 'public FileItemViewModel(INavigationService navigation, IMethods methods) :'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'public FileItemViewModel(INavigationService navigation, IMethods methods) :'
- en: base(navigation, methods) { }
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: base(navigation, methods) { }
- en: '#endregion'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#endregion'
- en: '}'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE67]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'public class FilesPageViewModel : ViewModelBase'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 'public class FilesPageViewModel : ViewModelBase'
- en: '{'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '#region Private Properties'
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#region Private Properties'
- en: private readonly Func<FileItemViewModel> _fileFactory;
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: private readonly Func<FileItemViewModel> _fileFactory;
- en: private readonly ISQLiteStorage _storage;
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: private readonly ISQLiteStorage _storage;
- en: private readonly SynchronizationContext _context;
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: private readonly SynchronizationContext _context;
- en: private ICommand _editFileCommand;
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: private ICommand _editFileCommand;
- en: private ICommand _createFileCommand;
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: private ICommand _createFileCommand;
- en: private bool _noFiles;
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: private bool _noFiles;
- en: '#endregion'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#endregion'
- en: '}'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE68]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '#region Public Properties'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '#region Public Properties'
- en: public Subject<DataChange> DataChanges { get; private set; }
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: public Subject<DataChange> DataChanges { get; private set; }
- en: public ICommand EditFileCommand
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: public ICommand EditFileCommand
- en: '{'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: get
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: get
- en: '{'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: return _editFileCommand;
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return _editFileCommand;
- en: '}'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: set
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set
- en: '{'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: if (value.Equals(_editFileCommand))
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (value.Equals(_editFileCommand))
- en: '{'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: return;
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return;
- en: '}'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: _editFileCommand = value;
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _editFileCommand = value;
- en: OnPropertyChanged("EditFileCommand");
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: OnPropertyChanged("EditFileCommand");
- en: '}'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public ICommand CreateFileCommand
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: public ICommand CreateFileCommand
- en: '{'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: get
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: get
- en: '{'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: return _createFileCommand;
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return _createFileCommand;
- en: '}'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: set
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set
- en: '{'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: if (value.Equals(_createFileCommand))
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (value.Equals(_createFileCommand))
- en: '{'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: return;
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return;
- en: '}'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: _createFileCommand = value;
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _createFileCommand = value;
- en: OnPropertyChanged("CreateFileCommand");
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: OnPropertyChanged("CreateFileCommand");
- en: '}'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public bool AnyFiles
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: public bool AnyFiles
- en: '{'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: get
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: get
- en: '{'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: return _noFiles;
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return _noFiles;
- en: '}'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: set
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set
- en: '{'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: if (value.Equals(_noFiles))
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (value.Equals(_noFiles))
- en: '{'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: return;
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return;
- en: '}'
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: _noFiles = value;
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: _noFiles = value;
- en: OnPropertyChanged("AnyFiles");
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: OnPropertyChanged("AnyFiles");
- en: '}'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: public ObservableCollection<FileItemViewModel> Cells { get; set; }
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: public ObservableCollection<FileItemViewModel> Cells { get; set; }
- en: '#endregion'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '#endregion'
- en: '[PRE69]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '#region Constructors'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '#region Constructors'
- en: public FilesPageViewModel(INavigationService navigation, Func<Action<object>,
    ICommand> commandFactory,
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: public FilesPageViewModel(INavigationService navigation, Func<Action<object>,
    ICommand> commandFactory,
- en: IMethods methods, ISQLiteStorage storage, Func<FileItemViewModel>
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IMethods methods, ISQLiteStorage storage, Func<FileItemViewModel>
- en: 'fileFactory) : base(navigation, methods)'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'fileFactory) : base(navigation, methods)'
- en: '{'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: DataChanges = new Subject<DataChange>();
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: DataChanges = new Subject<DataChange>();
- en: // retrieve main thread context _context =
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: // retrieve main thread context _context =
- en: SynchronizationContext.Current;
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: SynchronizationContext.Current;
- en: _storage = storage;
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: _storage = storage;
- en: _fileFactory = fileFactory;
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: _fileFactory = fileFactory;
- en: Cells = new ObservableCollection<FileItemViewModel>();
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Cells = new ObservableCollection<FileItemViewModel>();
- en: _editFileCommand = commandFactory(async (file) =>
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: _editFileCommand = commandFactory(async (file) =>
- en: '{'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: await Navigation.Navigate(PageNames.EditFilePage,
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await Navigation.Navigate(PageNames.EditFilePage,
- en: new Dictionary<string, object>()
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: new Dictionary<string, object>()
- en: '{'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '{'
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"filename", (file as FileItemViewModel).FileName},'
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"filename", (file as FileItemViewModel).FileName},'
- en: '{'
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"contents", (file as FileItemViewModel).Contents} });'
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"contents", (file as FileItemViewModel).Contents} });'
- en: '});'
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: _createFileCommand = commandFactory(async (obj) =>
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: _createFileCommand = commandFactory(async (obj) =>
- en: '{'
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: var fileName = await ShowEntryAlert("Enter file name:");
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: var fileName = await ShowEntryAlert("输入文件名：");
- en: if (!string.IsNullOrEmpty(fileName))
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (!string.IsNullOrEmpty(fileName))
- en: '{'
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: await Navigation.Navigate(PageNames.EditFilePage,
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await Navigation.Navigate(PageNames.EditFilePage,
- en: new Dictionary<string, object>()
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: new Dictionary<string, object>()
- en: '{'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '{'
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"filename", fileName'
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"filename", fileName'
- en: '}'
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: '}'
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '});'
- en: '}'
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '#endregion'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '#endregion'
- en: '[PRE70]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Using a SynchronizationContext
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SynchronizationContext
- en: In all `Xamarin.Forms` applications, when we update view-model properties that
    are bound to a view, they must be changed on the main UI thread.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有`Xamarin.Forms`应用程序中，当我们更新绑定到视图的视图模型属性时，它们必须在主UI线程上更改。
- en: Tip
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This rule applies to any application. UI changes must happen on the main UI
    thread.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则适用于任何应用程序。UI更改必须在主UI线程上发生。
- en: The `SynchronizationContext.Current` property is used to retrieve the current
    sync context of any thread.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`SynchronizationContext.Current`属性用于检索任何线程的当前同步上下文。'
- en: How do we know this context is from the main UI thread?
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何知道这个上下文来自主UI线程？
- en: We store a reference to this context in the constructor because all view-models
    are created on the main UI thread. This means we have the current sync context
    of the main thread.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造函数中存储对这个上下文的引用，因为所有视图模型都是在主UI线程上创建的。这意味着我们拥有主线程的当前同步上下文。
- en: 'Let''s have a look at how we are going to use this sync context reference:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将如何使用这个同步上下文引用：
- en: '[PRE71]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `UpdateFiles` function is called every time the page appears. When we call
    `Post` on the context object, we have to pass an action that will be propagated
    to the main UI thread when it becomes available. Inside this action, we will use
    the `GetTable` function to retrieve all files from the table. Then, for every
    `FileStorable` object, we instantiate a new `FileItemViewModel` from the factory
    and add this to the `ObservableCollection`. After we do this for all files, we
    publish a new event to the `DataChanges` sequence.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 每当页面出现时，都会调用`UpdateFiles`函数。当我们对上下文对象调用`Post`时，我们必须传递一个动作，当它可用时，该动作将被传播到主UI线程。在这个动作内部，我们将使用`GetTable`函数从表中检索所有文件。然后，对于每个`FileStorable`对象，我们从工厂实例化一个新的`FileItemViewModel`并将其添加到`ObservableCollection`中。完成所有文件的处理后，我们向`DataChanges`序列发布一个新的事件。
- en: 'Finally, we have to add the `OnAppear` function, which will be called every
    time the page appears; it doesn''t matter if we push or pop to this page, this
    function will be called every time. This means that we will update the current
    files, every time the page appears, so the `CarouselView` will have the most current
    list of files in the database at all times:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须添加`OnAppear`函数，它将在每次页面出现时被调用；无论我们是推入还是弹出此页面，这个函数都会被调用。这意味着每次页面出现时，我们都会更新当前文件，这样`CarouselView`将始终显示数据库中最新的文件列表：
- en: '[PRE72]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now let''s build the page for this view-model. To do so, inside the `Pages`
    folder, add in `FilesPage.xaml` and implement the following:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为这个视图模型构建页面。为此，在`Pages`文件夹内，添加`FilesPage.xaml`并实现以下内容：
- en: '[PRE73]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Since we are including the `CarouselView` in this page, we have to add a new
    reference namespace at the top of the page as follows:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在页面上包含了`CarouselView`，我们必须在页面的顶部添加一个新的命名空间引用，如下所示：
- en: '[PRE74]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Building the EditFilePage
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建EditFilePage
- en: 'Now we move to the last page of the application. Add a new file called `EditFilePage.xaml`
    to the `Pages` folder and implement the following:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将转向应用程序的最后一页。将一个名为`EditFilePage.xaml`的新文件添加到`Pages`文件夹，并实现以下内容：
- en: '[PRE75]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We have an `Entry` property at the very top for editing the filename and we
    have an `Editor` for filling in the text contents of the file. We also have two
    buttons: one for saving the file and one for deleting it.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在最顶部有一个`Entry`属性用于编辑文件名，我们还有一个`Editor`用于填写文件的文本内容。我们还有两个按钮：一个用于保存文件，一个用于删除它。
- en: Now, turn our attention to the `Entry` item; we are going to introduce a new
    `Xamarin.Forms` feature called `Behaviours`.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注`Entry`项；我们将介绍一个新的`Xamarin.Forms`特性，称为`Behaviours`。
- en: Behaviours
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Behaviours
- en: Behaviours enable you to implement objects which can be concisely attached to
     events and behaviours of any control type. This means we can package and reuse
    behaviours between similar controls without having to write repetitive code behind
    our XAML sheets.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 行为使您能够实现可以简洁地附加到任何控件类型的事件和行为的对象。这意味着我们可以在类似的控件之间打包和重用行为，而无需在我们的XAML表单后面编写重复的代码。
- en: 'Let''s create a new folder called `Behaviours`, add in a new file called `LowercaseEntryBehaviour.cs`,
    and implement the following:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Behaviours`的新文件夹，添加一个名为`LowercaseEntryBehaviour.cs`的新文件，并实现以下内容：
- en: '[PRE76]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `OnAttachedTo` and `OnDetachingFrom` methods get invoked when the behavior
    is attached/detached from parent UI element; so we subscribe to the `TextChanged`
    event, and when it triggers, we update the `Text` property by calling the `ToLower`
    function. This means that irrespective of the case of the text when it is entered
    into the `Entry` object, it will always be lowercase.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 当行为附加到/从父UI元素分离时，将调用`OnAttachedTo`和`OnDetachingFrom`方法；因此我们订阅了`TextChanged`事件，当它触发时，我们通过调用`ToLower`函数来更新`Text`属性。这意味着无论文本在输入到`Entry`对象时的字母大小写如何，它始终将是小写。
- en: 'Now let''s add the view-model for the `EditFilePage`. Inside the `ViewModels`
    folder, add another file called `EditFilePageViewModel.cs` and implement the `private`
    properties first as follows:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加`EditFilePage`的视图模型。在`ViewModels`文件夹中，添加另一个名为`EditFilePageViewModel.cs`的文件，并首先实现`private`属性，如下所示：
- en: '[PRE77]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We have to use the `ISQLiteStorage` object for saving and deleting files on
    the local database. We then have another two properties to record the contents
    of the file and filename. The two commands are used to invoke the SQLite functions
    for saving and deleting.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`ISQLiteStorage`对象在本地数据库中保存和删除文件。然后我们有另外两个属性来记录文件内容和文件名。这两个命令用于调用SQLite的保存和删除函数。
- en: 'Let''s go ahead and add the public properties as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续添加公共属性，如下所示：
- en: '[PRE78]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Tip
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that we only want to publicize the variables that are going to be bound
    through the XAML.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们只想公开那些将通过XAML绑定的变量。
- en: 'Now we add the constructor as follows:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加构造函数，如下所示：
- en: '[PRE79]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then, finally, we add the remaining functions; we have the `OnDisppear` function,
    which will be used for clearing the filename and contents whenever the page disappears.
    Then we have the `LoadAsync` override, which is going to set the filename and
    contents from the navigation parameters that are passed in from the previous page.
    From the `FilesPage`, when a user selects a file from the carousel, the `FileItemViewModel`
    object details are passed into a dictionary for the navigation parameters that
    are passed into the `EditFilePage`:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后，我们添加剩余的函数；我们有`OnDisppear`函数，该函数将在页面消失时用于清除文件名和内容。然后我们有`LoadAsync`重写，它将设置文件名和内容，这些是从前一页传递的导航参数。从`FilesPage`，当用户从轮播图中选择一个文件时，`FileItemViewModel`对象的详细信息将传递到一个字典中，作为传递给`EditFilePage`的导航参数：
- en: '[PRE80]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Fantastic! We have finished implementing the user interface.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经完成了用户界面的实现。
- en: Challenge
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: We have built everything in the `FileStorage.Portable` and `FileStorage` projects,
    but there are still pieces missing. Here is your challenge; fill in the missing
    pieces of the solution and compile it. The remaining files are exactly the same
    from all our other `Xamarin.Forms` solutions, but now it is your turn to finish
    off the project.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`FileStorage.Portable`和`FileStorage`项目中构建了一切，但仍然缺少一些部分。这是你的挑战；填写解决方案中缺失的部分并编译它。剩余的文件与我们的所有其他`Xamarin.Forms`解决方案完全相同，但现在轮到你来完成项目。
- en: Building the Windows Phone version
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Windows Phone版本
- en: 'If you are looking for an even bigger challenge, then try adding on the Windows
    Phone version. Don''t be intimidated by this exercise, most of the code is shared
    for you. On the Windows Phone version, you will have to implement the following:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找更大的挑战，那么尝试添加Windows Phone版本。不要被这个练习吓倒，大部分代码都是为你共享的。在Windows Phone版本中，你必须实现以下内容：
- en: '`WinPhoneMethods`'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WinPhoneMethods`'
- en: '`GestureViewRenderer`'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GestureViewRenderer`'
- en: '`SQLiteSetup`'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLiteSetup`'
- en: '`LoggerWinPhone`'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoggerWinPhone`'
- en: You will also need to download a Visual Studio extension for SQLite from the
    following link [http://sqlite.org/download.html](http://sqlite.org/download.html).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要从以下链接下载一个SQLite的Visual Studio扩展程序 [http://sqlite.org/download.html](http://sqlite.org/download.html)。
- en: 'Download the **sqlite-wp81-winrt-3130000.vsix** file:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 下载**sqlite-wp81-winrt-3130000.vsix**文件：
- en: '![Building the Windows Phone version](img/B05293_07_07.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![构建Windows Phone版本](img/B05293_07_07.jpg)'
- en: 'Install the extensions and then reopen Visual Studio. Then, in your Windows
    Phone project, right-click on **References** and select **Add Reference....**
    Then select **Windows Phone 8.1** | **Extensions** from the left-hand side and
    select **SQLite for Windows Phone 8.1**, as shown in the following screenshot:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 安装扩展程序后，重新打开 Visual Studio。然后，在您的 Windows Phone 项目中，右键单击**引用**并选择**添加引用....**然后从左侧选择**Windows
    Phone 8.1** | **扩展**，并选择**SQLite for Windows Phone 8.1**，如图所示：
- en: '![Building the Windows Phone version](img/B05293_07_08.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![构建 Windows Phone 版本](img/B05293_07_08.jpg)'
- en: 'When you run this project, you must make sure that the **x86** configuration
    is set:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此项目时，必须确保已设置**x86**配置：
- en: '![Building the Windows Phone version](img/B05293_07_09.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![构建 Windows Phone 版本](img/B05293_07_09.jpg)'
- en: 'To help you get started, the implementation for the `SQLiteSetup` class is
    as follows:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您开始，`SQLiteSetup` 类的实现如下：
- en: '[PRE81]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Tip
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To see the finished version, visit the following link: [https://github.com/flusharcade/chapter7-filestorage](https://github.com/flusharcade/chapter7-filestorage).'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完成版本，请访问以下链接：[https://github.com/flusharcade/chapter7-filestorage](https://github.com/flusharcade/chapter7-filestorage)。
- en: Summary
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored a walkthrough for integrating SQLite in a `Xamarin.Forms`
    application. We addressed the async-lock pattern and how to implement it with
    SQLite to make database connections thread-safe. In the final chapter, we will
    build a cross-platform camera application that will implement native control over
    camera hardware. We will also present camera video outlets via a `CustomRenderer`
    and build events to handle camera events in our portable library.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在 `Xamarin.Forms` 应用程序中集成 SQLite 的教程。我们讨论了 async-lock 模式以及如何使用 SQLite
    实现线程安全的数据库连接。在最后一章中，我们将构建一个跨平台相机应用程序，该应用程序将实现原生控制相机硬件。我们还将通过 `CustomRenderer`
    展示相机视频输出，并在我们的可移植库中构建处理相机事件的事件。
