- en: '*Chapter 8*: Writing Custom Middleware'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 8 章*：编写自定义中间件'
- en: Wow, we are already onto the eighth chapter of this book! In this chapter, we
    will learn about **middleware** and how you can use it to customize your app a
    little more. We will quickly go over the basics of middleware and then we'll explore
    some special things you can do with it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们这本书已经进入了第八章！在本章中，我们将学习关于 **中间件** 的知识以及如何使用它来进一步定制你的应用程序。我们将快速浏览中间件的基础知识，然后我们会探索一些你可以用它做的特别事情。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing middleware
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍中间件
- en: Writing custom middleware
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义中间件
- en: Exploring the potential of middleware
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索中间件的潜力
- en: Using middleware on ASP.NET Core 3.0 and later
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 3.0 及更高版本中使用中间件
- en: 'The topics covered in this chapter relate to the middleware layer of the ASP.NET
    Core architecture:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及的内容与 ASP.NET Core 架构的中间件层相关：
- en: '![Figure 8.1 – The ASP.NET Core architecture](img/Figure_8.1_B17996.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – ASP.NET Core 架构](img/Figure_8.1_B17996.jpg)'
- en: Figure 8.1 – The ASP.NET Core architecture
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – ASP.NET Core 架构
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the descriptions in this chapter, you will need to create an ASP.NET
    Core MVC application. To do this, open your console, shell, or Bash terminal,
    and change to your working directory. Then, use the following command to create
    a new MVC application:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的描述，你需要创建一个 ASP.NET Core MVC 应用程序。为此，打开你的控制台、shell 或 Bash 终端，切换到你的工作目录。然后，使用以下命令创建一个新的
    MVC 应用程序：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, open the project in Visual Studio by double-clicking the project file,
    or in Visual Studio Code by typing the following command in the already-open console:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过双击项目文件在 Visual Studio 中打开项目，或者在 Visual Studio Code 中，在已经打开的控制台中输入以下命令：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The simple `web` project template changed in .NET 6.0\. In version 6.0, Microsoft
    introduced **minimal APIs** and changed the project template to use the minimal
    API approach. This is a simpler way to bootstrap and to get started with a web
    application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6.0 中的简单 `web` 项目模板发生了变化。在 6.0 版本中，Microsoft 引入了 **最小 API** 并将项目模板更改为使用最小
    API 方法。这是一种更简单的方式来引导和开始一个 Web 应用程序。
- en: All of the code samples in this chapter can be found in the **GitHub** repository
    for this book at [https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter08).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码示例都可以在本书的 **GitHub** 仓库中找到，网址为 [https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter08)。
- en: Introducing middleware
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍中间件
- en: The majority of you probably already know what middleware is, but some of you
    might not. Even if you have already been using ASP.NET Core for a while, you don't
    really need to know about middleware instances in detail, as they are mostly hidden
    behind nicely named extension methods such as `UseMvc()`, `UseAuthentication()`,
    `UseDeveloperExceptionPage()`, and so on. Every time you call a `Use` method in
    the `Startup.cs` file, in the `Configure` method, you'll implicitly use at least
    one – or maybe more – middleware components.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人可能已经知道什么是中间件，但有些人可能不知道。即使你已经使用 ASP.NET Core 有一段时间了，你也不必详细了解中间件实例，因为它们大多隐藏在诸如
    `UseMvc()`、`UseAuthentication()`、`UseDeveloperExceptionPage()` 等命名良好的扩展方法之后。每次你在
    `Startup.cs` 文件中的 `Configure` 方法中调用 `Use` 方法时，你都会隐式地使用至少一个——或者可能更多——中间件组件。
- en: A middleware component is a piece of code that handles the request pipeline.
    Imagine the request pipeline as a huge tube where you can call something and then
    an echo comes back. The middleware is responsible for the creation of this echo
    – it manipulates the sound to enrich the information, handling the source sound,
    or handling the echo.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件组件是一段处理请求管道的代码。想象一下请求管道就像一个巨大的管子，你可以在里面调用某个东西，然后会有回声。中间件负责产生这个回声——它操纵声音以丰富信息，处理原始声音，或者处理回声。
- en: Middleware components are executed in the order in which they are configured.
    The first middleware component configured is the first that gets executed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件组件按照它们配置的顺序执行。首先配置的中间件组件是第一个被执行的。
- en: In an ASP.NET Core web application, if the client requests an image or any other
    static file, `StaticFileMiddleware` searches for that resource and returns that
    resource if it finds it. If not, this middleware component does nothing except
    call the next one. If there is no final piece of middleware that handles the request
    pipeline, the request returns nothing. The `MvcMiddleware` component also checks
    the requested resource, tries to map it to a configured route, executes the controller,
    creates a view, and returns an HTML or web API result. If `MvcMiddleware` does
    not find a matching controller, it will return a result anyway – in this case,
    it is a `404` status result. So, in any case, it returns an echo. This is why
    `MvcMiddleware` is the last piece of middleware configured.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core Web应用程序中，如果客户端请求一个图像或任何其他静态文件，`StaticFileMiddleware`会搜索该资源，如果找到，则返回该资源。如果没有找到，这个中间件组件除了调用下一个中间件外，不做任何事情。如果没有处理请求管道的最终中间件，请求将返回空。`MvcMiddleware`组件也会检查请求的资源，尝试将其映射到配置的路由，执行控制器，创建视图，并返回HTML或Web
    API结果。如果`MvcMiddleware`找不到匹配的控制器，它仍然会返回一个结果——在这种情况下，是一个`404`状态结果。所以，在任何情况下，它都会返回一个回声。这就是为什么`MvcMiddleware`是配置的最后一个中间件组件。
- en: '![Figure 8.2 – A middleware workflow diagram](img/Figure_8.2_B17996.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 中间件工作流程图](img/Figure_8.2_B17996.jpg)'
- en: Figure 8.2 – A middleware workflow diagram
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 中间件工作流程图
- en: '`500` status:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`500`状态：'
- en: You are able to see how the pipeline is executed if you create an empty ASP.NET
    Core application, as described in the *Technical requirements* section.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你创建一个空的ASP.NET Core应用程序，如*技术要求*部分所述，你将能够看到管道是如何执行的。
- en: 'Open `Program.cs` with your favorite editor. This should be pretty small compared
    to a regular ASP.NET Core application. In ASP.NET Core 6.0, Microsoft introduced
    the minimal API approach, which simplifies the application configuration and hides
    a lot of default configuration from the developers. Microsoft is also implementing
    default `using` statements in ASP.NET Core. Because of this, you don''t see any
    `using` statements initially. This is how `Program.cs` looks in ASP.NET Core 6.0:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器打开`Program.cs`。与常规ASP.NET Core应用程序相比，这应该相当小。在ASP.NET Core 6.0中，Microsoft引入了最小API方法，它简化了应用程序配置，并隐藏了大量的默认配置，不让开发者看到。Microsoft还在ASP.NET
    Core中实现了默认的`using`语句。正因为如此，你最初看不到任何`using`语句。这是ASP.NET Core 6.0中`Program.cs`的样貌：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, special lambda middleware is bound to the default route and only writes
    `"Hello World!"` to the response stream. The response stream is the echo we learned
    about previously. This special middleware stops the pipeline and returns something
    like an echo. So, it is the last middleware to run.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，特殊的lambda中间件绑定到默认路由，并且只将`"Hello World!"`写入响应流。响应流是我们之前学过的回声。这个特殊的中间件停止了管道，并返回类似回声的东西。因此，它是最后运行的中间件。
- en: 'Replace the line with the call of `app.MapGet()` with the following lines of
    code, right before the `app.Run()` function:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将调用`app.MapGet()`的行替换为以下代码，在`app.Run()`函数之前：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These two calls of `app.Use()` also create two lambda middlewares, but this
    time, in addition to dealing with specific requests, the middleware components
    are calling their successors: each middleware component knows which middleware
    component should follow it, and so calls it. The call of `app.Run()` replaces
    the call of `app.MapGet()`, but it does basically the same thing, except that
    `app.Run()` directly writes to the response stream. The lambda middlewares created
    with `app.Use()` write to the response stream before and after the next middleware
    is called. Before the next middleware is called, the actual request is handled,
    and after the next middleware is called, the response (echo) is handled. This
    should demonstrate how the pipeline works.'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个`app.Use()`调用也创建了两个lambda中间件，但这次，除了处理特定请求外，中间件组件还会调用它们的后续者：每个中间件组件都知道应该跟随哪个中间件组件，因此会调用它。`app.Run()`的调用替换了`app.MapGet()`的调用，但它们基本上做的是同一件事，只是`app.Run()`直接写入响应流。使用`app.Use()`创建的lambda中间件在调用下一个中间件之前和之后写入响应流。在调用下一个中间件之前，实际请求被处理，在调用下一个中间件之后，响应（回声）被处理。这应该展示了管道是如何工作的。
- en: 'If you now run the application (using `dotnet run`) and open the displayed
    URL in the browser, you should see a plain text result like this:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序（使用`dotnet run`），并在浏览器中打开显示的URL，你应该看到如下所示的纯文本结果：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Does this make sense to you? If yes, let's move on and see how to use this concept
    to add some additional functionality to the request pipeline.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你来说有道理吗？如果有，让我们继续看看如何使用这个概念为请求管道添加一些额外的功能。
- en: Writing custom middleware
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义中间件
- en: 'ASP.NET Core is based on middleware. All the logic that gets executed during
    a request is based on middleware. So, we can use this to add custom functionality
    to the web. In the following process, we want to find out the execution time of
    every request that goes through the request pipeline:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core基于中间件。在请求过程中执行的所有逻辑都基于中间件。因此，我们可以使用它来向Web添加自定义功能。在以下过程中，我们想要找出每个通过请求管道的请求的执行时间：
- en: 'We can do this by creating and starting a stopwatch before the next middleware
    is called, and stop measuring the execution time after the next middleware is
    called, like so:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在调用下一个中间件之前创建并启动一个计时器，并在调用下一个中间件之后停止测量执行时间来实现这一点，如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You might need to add a `using` statement for `System.Diagnostics`.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能需要添加一个`using`语句来引用`System.Diagnostics`。
- en: After that, we return the elapsed milliseconds to the response stream.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后，我们将经过的毫秒数返回到响应流中。
- en: 'If you write some more middleware components, the configuration in `Program.cs`
    gets pretty messy. This is why most middleware components are written as separate
    classes. This could look like this:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你编写了更多的中间件组件，`Program.cs`中的配置会变得相当混乱。这就是为什么大多数中间件组件都是作为单独的类编写的。这可能看起来像这样：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This way, we get the next middleware component to execute via the constructor
    and the current context in the `Invoke()` method.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，我们通过构造函数和`Invoke()`方法中的当前上下文来获取下一个中间件组件执行。
- en: Note
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The middleware is initialized at the start of the application and the constructor
    runs only once during the application lifetime. On the other hand, the `Invoke()`
    method is called once per request.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 中间件在应用程序启动时初始化，构造函数在整个应用程序生命周期中只运行一次。另一方面，`Invoke()`方法对每个请求只调用一次。
- en: 'To use this middleware, there is a generic `UseMiddleware()` method available
    that you can use:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用此中间件，有一个通用的`UseMiddleware()`方法可用，你可以使用它：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, the more elegant way is to create an `extension` method that encapsulates
    this call:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，更优雅的方法是创建一个`extension`方法来封装这个调用：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, you can simply call it like this:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以简单地这样调用它：
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This way, you can provide additional functionality to an ASP.NET Core application
    through the request pipeline. You have the entire `HttpContext` available in your
    middleware. With this, you can manipulate the request or even the response using
    middleware.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就可以通过请求管道为ASP.NET Core应用程序提供额外的功能。在你的中间件中，你可以使用整个`HttpContext`来操作请求或甚至响应。
- en: For example, `AuthenticationMiddleware` tries to collect user information from
    the request. If it doesn't find any, it will ask for the information by sending
    a specific response back to the client. If it finds some information, it will
    add it to the request context and make it available to the entire application
    this way.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`AuthenticationMiddleware`试图从请求中收集用户信息。如果没有找到任何信息，它将通过发送特定的响应回客户端来请求信息。如果找到了一些信息，它将通过这种方式将其添加到请求上下文中，并使其对整个应用程序可用。
- en: Exploring the potential of middleware
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索中间件的潜力
- en: There are many other things you can do with middleware. For example, did you
    know that you can split the request pipeline into two or more pipelines? We'll
    look at how to do that and several other things in this section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用中间件做很多事情。例如，你知道你可以将请求管道分成两个或更多管道吗？在本节中，我们将探讨如何做到这一点以及其他几个方面。
- en: Branching the pipeline with /map
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`/map`分支管道
- en: 'The next code snippet shows how to create branches of the request pipeline
    based on specific paths:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了如何根据特定的路径创建请求管道的分支：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `/map1` path is a specific branch that continues the request pipeline inside
    – this is the same with the `/map2` path. Both maps have their own middleware
    configurations inside. All other unspecified paths will follow the main branch.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`/map1`路径是一个特定的分支，它继续在内部扩展请求管道——这与`/map2`路径相同。两个映射都有自己的中间件配置在内。所有其他未指定的路径都将遵循主分支。'
- en: Branching the pipeline with MapWhen()
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`MapWhen()`分支管道
- en: 'There is also a `MapWhen()` method to branch the pipeline based on a condition,
    instead of a branch based on a path:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个`MapWhen()`方法可以根据条件分支管道，而不是基于路径的分支：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we'll look at using middleware to create conditions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何使用中间件来创建条件。
- en: Creating conditions with middleware
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用中间件创建条件
- en: You can create conditions based on configuration values or, as shown here, based
    on properties of the request context. In the previous example, a query string
    property was used. You can use HTTP headers, form properties, or any other property
    of the request context.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据配置值创建条件，或者，如这里所示，根据请求上下文属性创建条件。在之前的示例中，使用了查询字符串属性。您可以使用 HTTP 头、表单属性或请求上下文的任何其他属性。
- en: You are also able to nest the maps to create child and grandchild branches if
    needed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以嵌套映射以创建所需的子分支和孙分支。
- en: 'We can use `Map()` or `MapWhen()` to provide a special API or resource based
    on a specific path or a specific condition, respectively. The ASP.NET Core `HealthCheck`
    API works like this: first, it uses `MapWhen()` to specify the port to use, and
    then, it uses `Map()` to set the path for the `HealthCheck` API (or, it uses `Map()`
    if no port is specified). In the end, `HealthCheckMiddleware` is used. The following
    code is just an example to show what this looks like:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Map()` 或 `MapWhen()` 分别提供基于特定路径或特定条件的特殊 API 或资源。ASP.NET Core 的 `HealthCheck`
    API 就是这样的：首先，它使用 `MapWhen()` 来指定要使用的端口，然后，它使用 `Map()` 来设置 `HealthCheck` API 的路径（或者，如果没有指定端口，则使用
    `Map()`）。最后，使用 `HealthCheckMiddleware`。以下代码只是一个示例，以展示其外观：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, let's see how you should use terminating middleware components in newer
    versions of ASP.NET Core.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何在 ASP.NET Core 更新版本中使用终止中间件组件。
- en: Using middleware in ASP.NET Core 3.0 and later
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 3.0 及以后的版本中使用中间件
- en: 'In ASP.NET Core 3.0 and later, there are two new kinds of middleware element,
    and they are called `UseRouting` and `UseEndpoints`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 3.0 及以后的版本中，有两种新的中间件元素，它们被称为 `UseRouting` 和 `UseEndpoints`：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first one is a middleware component that uses routing and the other one
    uses endpoints. So, what exactly are we looking at?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个使用路由的中间件组件，另一个使用端点。那么，我们到底在关注什么呢？
- en: This is the new **endpoint routing**. Previously, routing was part of MVC, and
    it only worked with MVC, web APIs, and frameworks that are based on the MVC framework.
    In ASP.NET Core 3.0 and later, however, routing is no longer in the MVC framework.
    Now, MVC and the other frameworks are mapped to a specific route or endpoint.
    There are different kinds of endpoint definitions available.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是新的 **端点路由**。之前，路由是 MVC 的一部分，并且它只与 MVC、Web API 和基于 MVC 框架的框架一起工作。然而，在 ASP.NET
    Core 3.0 及以后的版本中，路由不再在 MVC 框架中。现在，MVC 和其他框架被映射到特定的路由或端点。有不同类型的端点定义可用。
- en: 'In the preceding code snippet, a `GET` request is mapped to the page root URL.
    In the next code snippet, MVC is mapped to a route pattern, and **Razor Pages**
    are mapped to the Razor Pages-specific file structure-based routes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，将 `GET` 请求映射到页面根 URL。在下一个代码片段中，MVC 被映射到路由模式，而 **Razor Pages** 被映射到基于
    Razor Pages 特定文件结构的路由：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is no `UseMvc()` method anymore, even if it still exists and works on
    the `IApplicationBuilder` object level, to prevent the existing code from breaking.
    Now, there are new methods to activate ASP.NET Core features more granularly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 已经没有 `UseMvc()` 方法了，即使它仍然存在于 `IApplicationBuilder` 对象级别并且仍然可以工作，以防止现有代码损坏。现在，有新的方法可以更细致地激活
    ASP.NET Core 功能。
- en: 'These are the most commonly used new `Map` methods for ASP.NET Core 5.0 or
    later:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 ASP.NET Core 5.0 或更高版本中最常用的 `Map` 方法：
- en: '`endpoints.MapAreaControllerRoute(...);`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoints.MapAreaControllerRoute(...);`'
- en: '`endpoints.MapControllerRoute(...);`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoints.MapControllerRoute(...);`'
- en: '`endpoints.MapBlazorHub(...);`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoints.MapBlazorHub(...);`'
- en: '`endpoints.MapHub(...);`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoints.MapHub(...);`'
- en: '`endpoints.MapRazorPages(...);`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoints.MapRazorPages(...);`'
- en: '`endpoints.MapHealthChecks(...);`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoints.MapHealthChecks(...);`'
- en: There are many more methods to define fallback endpoints, to map routes and
    HTTP methods to delegates, and for middleware components.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多更多方法来定义回退端点、将路由和 HTTP 方法映射到委托，以及用于中间件组件。
- en: If you want to create middleware that works on all requests, such as `StopWatchMiddleware`,
    this will work as before on `IApplicationBuilder`. If you would like to write
    middleware to work on a specific path or route, you will need to create a `Map`
    method for it to map it to that route.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建适用于所有请求的中间件，例如 `StopWatchMiddleware`，它将在 `IApplicationBuilder` 上像以前一样工作。如果您想编写适用于特定路径或路由的中间件，您需要为它创建一个
    `Map` 方法来将其映射到该路由。
- en: Important Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is no longer recommended to handle the route inside the middleware. Instead,
    you should use the new endpoint routing. With this approach, the middleware is
    a lot more generic, and it will work on multiple routes with a single configuration.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不再建议在中间件内部处理路由。相反，你应该使用新的端点路由。这种方法使得中间件更加通用，并且它将使用单个配置在多个路由上工作。
- en: I recently wrote middleware to provide a **GraphQL** endpoint in an ASP.NET
    Core application. However, I had to rewrite it to follow the new ASP.NET Core
    routing. The old way would still have worked, but it would have handled the paths
    and routes separately from the new ASP.NET Core routing. Let's look at how to
    deal with those situations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我最近编写了一个中间件，在 ASP.NET Core 应用程序中提供 **GraphQL** 端点。然而，我不得不重写它以遵循新的 ASP.NET Core
    路由。旧的方法仍然可以工作，但它将路径和路由与新的 ASP.NET Core 路由分开处理。让我们看看如何处理这些情况。
- en: Rewriting terminating middleware to meet the current standards
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写终止中间件以满足当前标准
- en: 'If you have existing middleware that provides a different endpoint, you should
    change it to use the new endpoint routing:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个提供不同端点的现有中间件，你应该将其更改为使用新的端点路由：
- en: 'As an example, let''s create small, dummy middleware that writes an application
    status to a specific route. In this example, there is no custom route handling:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个小型的、模拟的中间件，它将应用程序状态写入特定的路由。在这个例子中，没有自定义路由处理：
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first thing we need to do is write an `extension` method on the `IEndpointRouteBuilder`
    object. This method has a route pattern as an optional argument and returns an
    `IEndpointConventionBuilder` object to enable **cross-origin resource sharing**
    (**CORS**), authentication, or other conditions to the route.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在 `IEndpointRouteBuilder` 对象上编写一个 `extension` 方法。这个方法有一个作为可选参数的路由模式，并返回一个
    `IEndpointConventionBuilder` 对象，以便为路由启用 **跨源资源共享**（**CORS**）、身份验证或其他条件。
- en: 'Now, we should add an extension method to make it easier to use the middleware:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该添加一个扩展方法来简化中间件的使用：
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once that is complete, we can use the `MapAppStatus` method to map it to a
    specific route:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成之后，我们可以使用 `MapAppStatus` 方法将其映射到特定的路由：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now call the route in the browser by entering the following address:
    `http://localhost:5000/status`.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在浏览器中通过输入以下地址来调用该路由：`http://localhost:5000/status`。
- en: We will learn more about endpoint routing and how to customize it in [*Chapter
    9*](B17996_09_ePub.xhtml#_idTextAnchor143), *Working with Endpoint Routing*. For
    now, let's recap what we've learned about middleware.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 9 章*](B17996_09_ePub.xhtml#_idTextAnchor143) 中学习更多关于端点路由以及如何自定义它，*与端点路由一起工作*。现在，让我们回顾一下关于中间件我们已经学到了什么。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Most of the ASP.NET Core features are based on middleware and in this chapter,
    you learned how middleware works and how to create your own middleware components
    to extend the ASP.NET framework. You also learned how to use the new routing to
    add routes to your own custom terminating middleware components.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 ASP.NET Core 功能都是基于中间件的，在本章中，你学习了中间件的工作原理以及如何创建自己的中间件组件以扩展 ASP.NET 框架。你还学习了如何使用新的路由向自己的自定义终止中间件组件添加路由。
- en: In the next chapter, we will have a look at the new endpoint routing in ASP.NET
    Core, which allows you to create your own hosted endpoints in an easy and flexible
    way.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 ASP.NET Core 中的新端点路由，它允许你以简单灵活的方式创建自己的托管端点。
