<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-126"><a id="_idTextAnchor130" class="pcalibre1 pcalibre calibre6"/>7</h1>
<h1 id="_idParaDest-127" class="calibre5"><a id="_idTextAnchor131" class="pcalibre1 pcalibre calibre6"/>Polishing the Player’s Actions and Enemy Behavior</h1>
<p class="calibre3">In <a href="B18347_06.xhtml#_idTextAnchor116" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, we added a ranged weapon shooting mechanic in an optimized way using Unity’s <a id="_idIndexMarker658" class="pcalibre1 pcalibre calibre6"/>new <strong class="bold">object </strong><strong class="bold">pooling</strong><strong class="bold"> API</strong>.</p>
<p class="calibre3">In this chapter, we will continue to add some much-needed polish to the player character with visual effects! We’ll also create some enemy <strong class="bold">non-player character</strong> (<strong class="bold">NPC</strong>) variants<a id="_idIndexMarker659" class="pcalibre1 pcalibre calibre6"/> and finish up the chapter by introducing enemy behavior through a state pattern.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre17">
<li class="calibre15">Polishing with <strong class="bold">Shader Graph</strong> and <strong class="bold">Trail Renderer</strong></li>
<li class="calibre15">Enemy Prefabs and variants – Configuring with <strong class="bold">Scriptable </strong><strong class="bold">Objects</strong> (<strong class="bold">SOs</strong>)</li>
<li class="calibre15">Implementing basic enemy behavior using a <strong class="bold">finite state </strong><strong class="bold">machine </strong>(<strong class="bold">FSM</strong>)</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to quickly add some visual effect polish to the game’s sprites using a custom shader and make several enemy variants configured with varying properties and simple state-based behavior.</p>
<h1 id="_idParaDest-128" class="calibre5"><a id="_idTextAnchor132" class="pcalibre1 pcalibre calibre6"/>Technical requirements</h1>
<p class="calibre3">Download the assets from the following GitHub link to follow along in this chapter with the same artwork created for the project in the book.</p>
<p class="calibre3">To follow along with your own artwork, you’ll need to create similar artwork using Adobe Photoshop or a graphics program that can export layered Photoshop PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and Affinity Photo).</p>
<p class="calibre3">You can download the complete project on GitHub at <a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example</a>.</p>
<h1 id="_idParaDest-129" class="calibre5"><a id="_idTextAnchor133" class="pcalibre1 pcalibre calibre6"/>Polishing with Shader Graph and Trail Renderer</h1>
<p class="calibre3">To really sell the <a id="_idIndexMarker660" class="pcalibre1 pcalibre calibre6"/>game experience to the <a id="_idIndexMarker661" class="pcalibre1 pcalibre calibre6"/>player, we can <a id="_idIndexMarker662" class="pcalibre1 pcalibre calibre6"/>employ some easy-to-execute visual polish. Thankfully, Unity provides visual effect features through some built-in components and includes relevant features as part of its render pipeline.</p>
<p class="calibre3">Here, we’ll look at adding a few simple effects to the player, bullet projectile, and the overall visual look.</p>
<h2 id="_idParaDest-130" class="calibre8"><a id="_idTextAnchor134" class="pcalibre1 pcalibre calibre6"/>Enabling post-processing</h2>
<p class="calibre3">To take advantage <a id="_idIndexMarker663" class="pcalibre1 pcalibre calibre6"/>of any of the effects <a id="_idIndexMarker664" class="pcalibre1 pcalibre calibre6"/>we’ll be implementing in this section, we’ll first want to enable <strong class="bold">post-processing</strong> as it applies<a id="_idIndexMarker665" class="pcalibre1 pcalibre calibre6"/> to the <strong class="bold">Universal RP</strong> (<strong class="bold">URP</strong>) (reminder: this is the render pipeline we are working with).</p>
<p class="calibre3">Specifically, the effects we’ll be making <a id="_idIndexMarker666" class="pcalibre1 pcalibre calibre6"/>will use <strong class="bold">high dynamic range</strong> (<strong class="bold">HDR</strong>) color values that will work with a post-processing bloom effect to make our 2D lights and parts of our sprite assets glow.</p>
<p class="callout-heading">HDR color | Unity documentation</p>
<p class="callout">HDR color values offer a wider range of luminosity than standard colors, resulting in more accurate depictions of color and brightness, more vibrant colors, improved support for bloom and glow effects, and reduced banding.</p>
<p class="callout">High dynamic range: <a href="https://docs.unity3d.com/Manual/HDR.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Manual/HDR.xhtml</a></p>
<p class="calibre3">For a look at what’s to come in the following sections, as seen in <em class="italic">Figure 7</em><em class="italic">.1</em>, we’ll apply <strong class="bold">Vignette</strong> to the screen and add <strong class="bold">Bloom</strong> to make the white parts of the bullet sprite glow (exaggerated for clarity).</p>
<p class="calibre3">Note that we can’t make the bullet glow with <strong class="bold">Bloom</strong> alone, so we’ll cover how to accomplish this, plus <strong class="bold">Vignette</strong>, in the following sections:</p>
<div><div><img alt="Figure 7.1 – Post-processing effects applied to the scene" src="img/B18347_07_1.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Post-processing effects applied to the scene</p>
<p class="callout-heading">A word of caution</p>
<p class="callout">Some post-processing effects are performance-heavy and are not suitable for all distribution platforms (mobile in particular), so pay attention to your <strong class="bold">frames per second</strong> (<strong class="bold">FPS</strong>) stats <a id="_idIndexMarker667" class="pcalibre1 pcalibre calibre6"/>when adding new effects!</p>
<p class="calibre3">To enable<a id="_idIndexMarker668" class="pcalibre1 pcalibre calibre6"/> post-processing in our <a id="_idIndexMarker669" class="pcalibre1 pcalibre calibre6"/>game, follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">For the camera in the current scene, select <strong class="bold">Main Camera</strong> in the <strong class="bold">Hierarchy</strong>.</li>
<li class="calibre15">Under the <strong class="bold">Rendering</strong> section (refer to <em class="italic">Figure 7</em><em class="italic">.1</em>), enable <strong class="bold">Post Processing</strong>.</li>
<li class="calibre15">For <code>Assets/Settings</code> folder and select the <code>UniversalRP</code> asset.</li>
<li class="calibre15">Under the <strong class="bold">Quality</strong> section, enable <strong class="bold">HDR</strong>.</li>
</ol>
<p class="calibre3">Now that we have post-processing enabled, we can start<a id="_idIndexMarker670" class="pcalibre1 pcalibre calibre6"/> adding <strong class="bold">volume overrides</strong> that will work with the effects we’ll be adding to our objects. To do that, we’ll need to add a volume to our scene and add the volume overrides by following these steps:</p>
<ol class="calibre14">
<li class="calibre15">From the <strong class="bold">Scene Hierarchy</strong>, use the <strong class="bold">Create</strong> menu and select <strong class="bold">Volume</strong> | <strong class="bold">Global Volume</strong>.</li>
<li class="calibre15">With the <code>Global Volume</code> object still selected, in the Inspector, on the <code>Volume</code> component’s <code>Volume Profile</code> asset. This will create an asset file named <code>Global Volume Profile</code> in a subfolder with the same name as your scene.</li>
<li class="calibre15">With a profile assigned, we now see a new <strong class="bold">Add Override</strong> button (refer to <em class="italic">Figure 7</em><em class="italic">.1</em>). Click it and select <strong class="bold">Post Processing</strong> | <strong class="bold">Vignette</strong>.</li>
<li class="calibre15">Click the checkbox to the left of <strong class="bold">Intensity</strong> to enable it, then raise the value to see the <em class="italic">screen-edge-darkening</em> effect in both <strong class="bold">Scene</strong> and <strong class="bold">Game</strong> views.</li>
<li class="calibre15">Now, repeat adding another override, but this time select <code>1</code> – pixels in the scene with a brightness lower than this value will not have the effect applied by URP. The default <a id="_idIndexMarker671" class="pcalibre1 pcalibre calibre6"/>value is <code>0.9</code> (which is great in most cases), but I’ve decided to give almost any object the potential to contribute glow to the overall look, so I raised it slightly.</li><li class="calibre15">Enable <code>1.15</code> to make things glow pretty good as an initial visual check, but I will be dialing this down later, I’m sure.</li></ol></li>
</ol>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Post-processing and full-screen effects: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/PostProcessingOverview.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/PostProcessingOverview.xhtml</a></p>
<p class="callout">Post-processing in the Universal Render Pipeline: <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/integration-with-post-processing.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/integration-with-post-processing.xhtml</a></p>
<p class="calibre3">Now that things look more cinematic and have the potential to emit some cool glow effects, let’s finally<a id="_idIndexMarker672" class="pcalibre1 pcalibre calibre6"/> set up our bullet Prefab sprite!</p>
<h2 id="_idParaDest-131" class="calibre8"><a id="_idTextAnchor135" class="pcalibre1 pcalibre calibre6"/>Applying glow to the bullet with Shader Graph</h2>
<p class="calibre3">You previously saw <a id="_idIndexMarker673" class="pcalibre1 pcalibre calibre6"/>how we <a id="_idIndexMarker674" class="pcalibre1 pcalibre calibre6"/>added a secondary texture to a sprite when we added sprite Normal maps in <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a> (for giving a pseudo-3D effect to sprites).</p>
<p class="calibre3">We’ll now <a id="_idIndexMarker675" class="pcalibre1 pcalibre calibre6"/>use a <code>1</code>, which will be possible by using an HDR color value).</p>
<p class="calibre3">In <em class="italic">Figure 7</em><em class="italic">.2</em>, you can see the artwork for the bullet as well as the bullet’s <strong class="bold">emission map</strong> – a black-and-white image where the white areas define parts that will be emissive:</p>
<div><div><img alt="Figure 7.2 – Emission map for bullet sprite" src="img/B18347_07_2.jpg" class="calibre83"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Emission map for bullet sprite</p>
<p class="calibre3">As you can see from the screenshot, we’ve created an emission map named <code>bullet1_emission</code> that represents only the swirly lines of the bullet sprite. Going back to the <code>bullet 1</code> sprite, select<a id="_idIndexMarker676" class="pcalibre1 pcalibre calibre6"/> it so that we can add the emission map as a secondary texture by following these steps:</p>
<ol class="calibre14">
<li class="calibre15">In the sprite’s <strong class="bold">Import Options</strong> section in the Inspector, click the <strong class="bold">Sprite </strong><strong class="bold">Editor</strong> button.</li>
<li class="calibre15">Select <strong class="bold">Secondary Textures</strong> from the <strong class="bold">Sprite Editor</strong> drop-down menu (top-left corner of the window).</li>
<li class="calibre15">In the <strong class="bold">Secondary Texture</strong> dialog, click the plus (<strong class="bold">+</strong>) button to add a new texture.</li>
<li class="calibre15">Enter <code>_Emission</code> in the <strong class="bold">Name</strong> field.</li>
<li class="calibre15">Drag the <strong class="bold">bullet1_emission</strong> sprite from the <strong class="bold">Project</strong> window into the <strong class="bold">Texture</strong> field.</li>
<li class="calibre15">Click the <strong class="bold">Apply</strong> button to save the changes (or simply close the window and choose <strong class="bold">Save</strong>).</li>
</ol>
<p class="calibre3">As a refresher, you <a id="_idIndexMarker677" class="pcalibre1 pcalibre calibre6"/>can<a id="_idIndexMarker678" class="pcalibre1 pcalibre calibre6"/> refer to <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Figure 4</em><em class="italic">.2</em>, for an example of the <strong class="bold">Secondary </strong><strong class="bold">Texture</strong> dialog.</p>
<p class="calibre3">With our sprite ready to go, we can move on to creating a new shader for applying our effect.</p>
<h2 id="_idParaDest-132" class="calibre8"><a id="_idTextAnchor136" class="pcalibre1 pcalibre calibre6"/>Creating a new Shader Graph 2D material</h2>
<p class="calibre3">Creating custom<a id="_idIndexMarker679" class="pcalibre1 pcalibre calibre6"/> shaders used to be <a id="_idIndexMarker680" class="pcalibre1 pcalibre calibre6"/>complicated by hand-coding them in a special shader language, but <strong class="bold">Shader Graph</strong> allows custom shaders to be authored visually in real time using a node-based system, making the process more accessible to artists and developers alike.</p>
<p class="calibre3">We’ll use <strong class="bold">Shader Graph</strong> to create and connect nodes visually to build out our emission shader. Note that this shader can be the basis for any number of materials we can use to make different sprites with emission maps glow!</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Getting started with Shader Graph: <a href="https://docs.unity3d.com/Packages/com.unity.shadergraph%4014.0/manual/Getting-Started.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.shadergraph%4014.0/manual/Getting-Started.xhtml</a></p>
<p class="calibre3">Let’s go ahead and create this glow shader now with the following steps:</p>
<ol class="calibre14">
<li class="calibre15">First, create a new <code>root</code> folder in the <code>Assets/Shaders</code>.</li>
<li class="calibre15">Create a shader graph in the new folder by using the <code>SpriteEmission_Unlit</code>.</li>
<li class="calibre15">Now, open the <strong class="bold">Shader Editor</strong> by clicking the <strong class="bold">Open Shader Editor</strong> button in the Inspector or double-clicking on the asset.</li>
</ol>
<p class="calibre3">The custom sprite shader we’re going to create is actually pretty simple and will only require a few<a id="_idIndexMarker681" class="pcalibre1 pcalibre calibre6"/> nodes, as seen in the completed shader in the following screenshot:</p>
<div><div><img alt="Figure 7.3 – Shader Graph sprite emission shader" src="img/B18347_07_3.jpg" class="calibre20"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Shader Graph sprite emission shader</p>
<p class="calibre3">Let’s construct this shader by following these steps:</p>
<p class="calibre3">First, starting in the <strong class="bold">Blackboard</strong> (<em class="italic">A</em> in <em class="italic">Figure 7</em><em class="italic">.3</em>) using the plus (<strong class="bold">+</strong>) button, add the following properties:</p>
<ul class="calibre17">
<li class="calibre15"><code>MainTex</code> and <code>_MainTex</code> (these fields are assigned in the <strong class="bold">Graph Inspector</strong> indicated by <em class="italic">B</em> in <em class="italic">Figure 7</em><em class="italic">.3</em>), then drag in the bullet sprite as the <strong class="bold">Default</strong> texture</li>
<li class="calibre15">Note that it is <a id="_idIndexMarker682" class="pcalibre1 pcalibre calibre6"/>essential that <strong class="bold">Reference</strong> is spelled correctly since this is what the shader uses internally for the texture reference</li>
<li class="calibre15"><code>Emission</code> and <code>_Emission</code> (note this is what we previously used as the name for the emission map secondary texture in the <strong class="bold">Sprite Editor</strong>), then drag in the <strong class="bold">Bullet Emission Map</strong> sprite as the <strong class="bold">Default</strong> texture</li>
<li class="calibre15"><code>Color</code> and <code>_Color</code></li>
</ul>
<p class="calibre3">These properties will be exposed in the Inspector so that we can assign values. <code>_MainTex</code> and <code>_Emission</code> will be obtained from the sprite.</p>
<p class="calibre3">Next, create and connect the nodes that make up this simple shader:</p>
<ol class="calibre14">
<li class="calibre15">Right-click anywhere and select <strong class="bold">Create Node</strong> from the pop-up menu (or just press the spacebar).</li>
<li class="calibre15">Start typing to search for the desired node to add. In our case, start typing <code>sample texture 2d</code> and select it from the list under <strong class="bold">Input</strong> | <strong class="bold">Texture</strong>. Let’s add two of these texture nodes – we’ll need one for <strong class="bold">MainTex</strong> and one for <strong class="bold">Emission</strong> (refer to <em class="italic">Figure 7</em><em class="italic">.3</em> as a reference).</li>
<li class="calibre15">Let’s complete the <strong class="bold">MainTex</strong> path first. Create an <strong class="bold">Add</strong> node next and then make the following connections:</li>
</ol>
<p class="calibre3"><strong class="bold">MainTex(T2)</strong> à <strong class="bold">[SampleTexture2D] Texture(T2)</strong> | <strong class="bold">RGBA(4)</strong> à <strong class="bold">[Add] A(4)</strong> | <strong class="bold">Out(4)</strong> à <strong class="bold">[</strong><strong class="bold">Fragment] SpriteColor(4)</strong></p>
<p class="callout-heading">Important note</p>
<p class="callout">A node is indicated as <strong class="bold">[Node]</strong>, connecting lines are shown by à (clicking and dragging on the little circles on the nodes), and input/output is displayed by | (input on the left side, output on the right side).</p>
<ol class="calibre14">
<li value="4" class="calibre15">Complete <a id="_idIndexMarker684" class="pcalibre1 pcalibre calibre6"/>the <strong class="bold">Emission</strong> path next by using the second <strong class="bold">SampleTexture2D</strong> node we previously added. Create a <strong class="bold">Multiply</strong> node and make the following connections:</li>
</ol>
<p class="calibre3"><strong class="bold">Emission(T2)</strong> à <strong class="bold">[SampleTexture2D] Texture(T2)</strong> | <strong class="bold">R(1)</strong> à <strong class="bold">[Multiply] A(4)</strong> | <strong class="bold">Out(4)</strong> à<strong class="bold">[Add] A(4)</strong></p>
<ol class="calibre14">
<li value="5" class="calibre15">Finally, we’ll finish up the shader by connecting the <strong class="bold">Color</strong> property:</li>
</ol>
<p class="calibre3"><strong class="bold">Color(4)</strong> à <strong class="bold">[Multiply] B(4)</strong> | <strong class="bold">Out(4)</strong> à <strong class="bold">[</strong><strong class="bold">Add] B(4)</strong></p>
<p class="callout-heading">Downloading the completed shader graph</p>
<p class="callout">For the completed sprite emission shader, visit the project GitHub repo here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Shaders" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Shaders</a></p>
<p class="calibre3">Before we can apply <a id="_idIndexMarker685" class="pcalibre1 pcalibre calibre6"/>our fancy new emission shader to our bullet Prefab, we’ll have to create a new <strong class="bold">material</strong> based on <a id="_idIndexMarker686" class="pcalibre1 pcalibre calibre6"/>this shader – that’s how it works. Rendering in Unity (and most digital content creation software) is performed with materials, shaders, and textures, each contributing their part to what the end user sees on screen.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Graphics: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/Graphics.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/Graphics.xhtml</a></p>
<p class="calibre3">Create a new material based on this new shader graph we just created by right-clicking on the shader asset named <code>SpriteEmission_Unlit</code> in the <code>Assets/Shaders</code> folder of the <strong class="bold">Project</strong> window, then follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">Go to <code>Bullet 1</code>.</li>
<li class="calibre15">Then, create a new folder at <code>Assets/Materials</code> and move the material into that folder.</li>
<li class="calibre15">Assign the material to the bullet sprite by first opening the <code>Bullet 1</code> Prefab (either in the scene or in <strong class="bold">Prefab Mode</strong>).</li>
<li class="calibre15">With the bullet sprite visible in the scene view, drag the <code>Bullet 1</code> material from the <strong class="bold">Project</strong> window and onto the sprite. Unity provides a visual indicator for what the new material would look like if applied to the sprite before you commit to releasing the mouse button (a pretty neat trick; this also works the same for assigning materials to 3D objects).</li>
<li class="calibre15">Now, this is where the magic happens. Select the <code>bullet1</code> sprite in the <strong class="bold">Hierarchy</strong> to show its<a id="_idIndexMarker687" class="pcalibre1 pcalibre calibre6"/> Inspector, expand the <strong class="bold">Material</strong> section at the bottom, and then click on the color picker (note that you should exit <strong class="bold">Prefab Mode</strong> because post-processing is not visible there). Then, do the following:<ol class="calibre42"><li class="calibre15">Set the <strong class="bold">Color</strong> field to an appropriate glow color and then kick up the <strong class="bold">Intensity</strong> value for the desired amount of glow (as seen in <em class="italic">Figure 7</em><em class="italic">.4</em>, but remember that the post-processing <strong class="bold">Bloom</strong> effect’s <strong class="bold">Intensity</strong> value is also at work here).</li></ol></li>
</ol>
<p class="calibre3">This is the final result of our efforts:</p>
<div><div><img alt="Figure 7.4 – Bullet material HDR color setting" src="img/B18347_07_4.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Bullet material HDR color setting</p>
<p class="calibre3">We are looking good – yay!</p>
<p class="callout-heading">Bonus activity</p>
<p class="callout">Add a material based on the <strong class="bold">SpriteEmission_Unlit</strong> shader for both the player character and weapon!</p>
<p class="calibre3">As you can see from our simple shader, it doesn’t take much effort to pump up the visuals of your <a id="_idIndexMarker688" class="pcalibre1 pcalibre calibre6"/>games <a id="_idIndexMarker689" class="pcalibre1 pcalibre calibre6"/>in Unity! For another quick win on the game’s visuals, let’s add a<a id="_idIndexMarker690" class="pcalibre1 pcalibre calibre6"/> subtle light effect to the player character to make it pop out in the environment.</p>
<h2 id="_idParaDest-133" class="calibre8"><a id="_idTextAnchor137" class="pcalibre1 pcalibre calibre6"/>Adding a 2D light to the player</h2>
<p class="calibre3">This is a very<a id="_idIndexMarker691" class="pcalibre1 pcalibre calibre6"/> quick and easy effect to add but with a<a id="_idIndexMarker692" class="pcalibre1 pcalibre calibre6"/> huge payoff. All we’re going to do here is add a <strong class="bold">2D light</strong> as a child of <strong class="bold">Player</strong>. With the light parented to <strong class="bold">Player</strong> – and within the <strong class="bold">Prefab</strong> <strong class="bold">Hierarchy</strong> – it will be <em class="italic">attached</em> to the object.</p>
<p class="calibre3">Use these steps to add the light:</p>
<ol class="calibre14">
<li class="calibre15">Right-click on the root object of the <code>Player</code> Prefab in the scene.</li>
</ol>
<p class="callout-heading">Working with Prefabs</p>
<p class="callout">A reminder for working with Prefabs: if you add the <strong class="bold">Light</strong> object in <strong class="bold">Prefab Mode</strong> (by double-clicking on the Prefab in the <strong class="bold">Project</strong> window), you won’t be able to visualize changes to the light settings. You can, however, enter the <strong class="bold">Prefab Isolation</strong> mode in the scene by clicking the chevron icon (<em class="italic">&gt;</em>) in the <strong class="bold">Hierarchy</strong> window and still be able to visualize changes. Lastly, you can modify the Prefab directly in the scene but just remember to apply <strong class="bold">Overrides</strong> to save changes to the Prefab.</p>
<ol class="calibre14">
<li value="2" class="calibre15">From the menu, select <strong class="bold">Light</strong> | <strong class="bold">Spot </strong><strong class="bold">Light 2D</strong>.</li>
<li class="calibre15">Adjust the values<a id="_idIndexMarker693" class="pcalibre1 pcalibre calibre6"/> to your liking. Referring to <em class="italic">Figure 7</em><em class="italic">.5</em>, these are the settings I used:<ul class="calibre22"><li class="calibre15">Positioned the light on the chest of the character</li><li class="calibre15"><code>0.6</code></li><li class="calibre15"><code>1.5</code> (<em class="italic">Inner</em>), <code>7</code> (<em class="italic">Outer</em>)</li><li class="calibre15"><code>0.01</code> (just add a touch here for a small contribution to the environment lighting)</li><li class="calibre15"><code>3</code> (<em class="italic">Distance</em>)</li></ul></li>
</ol>
<p class="calibre3">The before and after can be seen in <em class="italic">Figure 7</em><em class="italic">.5</em>. Notice how the player pops out of the environment on the right, whereas things look rather flat on the left:</p>
<div><div><img alt="Figure 7.5 – Making the player pop out with a 2D light" src="img/B18347_07_5.jpg" class="calibre84"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Making the player pop out with a 2D light</p>
<p class="calibre3">That was easy! Let’s <a id="_idIndexMarker694" class="pcalibre1 pcalibre calibre6"/>gain another quick win with<a id="_idIndexMarker695" class="pcalibre1 pcalibre calibre6"/> an additional visual effect that is simple to add!</p>
<h2 id="_idParaDest-134" class="calibre8"><a id="_idTextAnchor138" class="pcalibre1 pcalibre calibre6"/>Polishing is easy with Trail Renderer</h2>
<p class="calibre3">The <code>Trail Renderer</code> component<a id="_idIndexMarker696" class="pcalibre1 pcalibre calibre6"/> creates, well, a <a id="_idIndexMarker697" class="pcalibre1 pcalibre calibre6"/>trail following a moving object. It’s a great way to add more impactful movement to things, and it can be as subtle or over the top as you wish by adjusting only a few settings.</p>
<p class="calibre3">We’ll get right to it.</p>
<h3 class="calibre10">Adding a trail to Prefabs</h3>
<p class="calibre3">Follow these <a id="_idIndexMarker698" class="pcalibre1 pcalibre calibre6"/>steps to add a trail to our bullet:</p>
<ol class="calibre14">
<li class="calibre15">Open the <strong class="bold">Bullet 1</strong> Prefab for editing.</li>
<li class="calibre15">Open the <strong class="bold">Create</strong> menu and add <strong class="bold">Effects</strong> | <strong class="bold">Trail</strong> (parented to the root as a sibling of the <strong class="bold">bullet1</strong> sprite).</li>
<li class="calibre15">Adjust the values to give a nice trailing effect! Here are the values I used as a starting point:<ul class="calibre22"><li class="calibre15"><code>(0.0, 0.2)</code>, <code>(0.5, 0.0)</code> – using this curve will ensure that the trail doesn’t extend to be too long</li><li class="calibre15"><code>0.2</code></li><li class="calibre15"><code>35</code> to <code>0</code></li><li class="calibre15"><code>Package/Universal RP/Runtime/Materials</code>)</li><li class="calibre15"><strong class="bold">Lighting</strong> = <strong class="bold">Off</strong> (cast shadows)</li></ul></li>
</ol>
<p class="calibre3">These settings, and <a id="_idIndexMarker699" class="pcalibre1 pcalibre calibre6"/>the results, can be seen<a id="_idIndexMarker700" class="pcalibre1 pcalibre calibre6"/> in <em class="italic">Figure 7</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 7.6 – Visualizing Trail Renderer component on bullet Prefab" src="img/B18347_07_6.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Visualizing Trail Renderer component on bullet Prefab</p>
<p class="calibre3">Don’t forget that you’ll also have to set the <code>Bullet 1</code> Prefab’s sprite renderer, the ground, and foreground/background<a id="_idIndexMarker701" class="pcalibre1 pcalibre calibre6"/> sorting layers.</p>
<h3 class="calibre10">Clearing trails for pooled Prefabs</h3>
<p class="calibre3">The <code>Trail Renderer</code> component creates a trail of polygons behind the bullet GameObject (that’s how<a id="_idIndexMarker702" class="pcalibre1 pcalibre calibre6"/> the trail is rendered), which will still be there even if the GameObject is deactivated in the scene.</p>
<p class="calibre3">That’s a problem for us because that’s exactly what we’re doing with object pooling: deactivating the GameObject projectile when it’s returned to the pool.</p>
<p class="calibre3">Fortunately, the <code>Trail Renderer</code> component provides a <code>Clear()</code> method for clearing the trail. All we need to do is call this method when we initialize the projectile, and voilà! Problem solved.</p>
<p class="calibre3">Add the following <a id="_idIndexMarker703" class="pcalibre1 pcalibre calibre6"/>code to the <code>ProjectileBase</code> class:</p>
<pre class="source-code">
public virtual void Init(Vector2 direction,
    UnityAction&lt;ProjectileBase&gt; collisionCallback)
{
    // If there is a Trail Renderer component on
    // this GameObject then reset it.
    if (TryGetComponent&lt;TrailRenderer&gt;(out var tr))
        tr.Clear();
    …
}</pre> <p class="calibre3">Here, we’re simply using <code>TryGetComponent&lt;TrailRenderer&gt;()</code> to see if a <code>TrailRenderer</code> component has been added to the GameObject and only returning a reference to it, with an <code>out</code> parameter, if it exists. If the component does not exist, then an allocation will not be made, unlike with <code>GetComponent()</code>.</p>
<p class="calibre3">We use an <code>if</code> statement to evaluate the <code>bool</code> return value from <code>TryGetComponent()</code>, so only if we have a <code>Trail Renderer</code> component on the projectile will the <code>Clear()</code> method be called (essentially, resetting it).</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><strong class="source-inline1">Component.TryGetComponent</strong>: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Component.TryGetComponent.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Component.TryGetComponent.xhtml</a></p>
<p class="calibre3">In this section, we learned how to enable post-processing and add effect overrides such as <strong class="bold">Vignette</strong> and <strong class="bold">Bloom</strong>, making our bullet glow and our player pop with light. We finished up with an<a id="_idIndexMarker704" class="pcalibre1 pcalibre calibre6"/> easy-peasy trail effect on our<a id="_idIndexMarker705" class="pcalibre1 pcalibre calibre6"/> bullet as well!</p>
<p class="calibre3">Next, we’ll add a configurable enemy character and variants of the same.</p>
<h1 id="_idParaDest-135" class="calibre5"><a id="_idTextAnchor139" class="pcalibre1 pcalibre calibre6"/>Enemy Prefabs and variants – Configuring with SOs</h1>
<p class="calibre3">Instead of a GameObject that has to live in a scene, we can create a file-based asset that can be referenced <a id="_idIndexMarker706" class="pcalibre1 pcalibre calibre6"/>from any GameObject, including Prefabs, anywhere in the game, called an SO.</p>
<p class="calibre3">This being a single asset reference means no additional allocations are needed, and the same values are used no matter how many objects in the scene are spawned that reference it. Pretty cool!</p>
<p class="calibre3">An SO, as a small and efficient data container, also allows the separation of data from the code that consumes it. Data can be updated from backend cloud systems without recompiling the code or building a new distribution of the entire game.</p>
<p class="calibre3">Being able to respond to data changes for games in production – where an issue affecting players may need to be solved quickly – is an excellent application of SOs.</p>
<p class="calibre3">Others have used SOs for middleware components and even fully decoupled event systems that are designer-friendly because they allow configuration at design time in the Editor (that is, a developer is not required to wire up new events between objects, and so on).</p>
<p class="calibre3">Unity has also built complete game architecture based on SOs in its <em class="italic">Open Projects</em> development program. And there would be something amiss if I didn’t mention Ryan Hipple’s (Schell Games) now infamous <em class="italic">Game Architecture with Scriptable Objects</em> talk at Unite Austin 2017 (link provided in the <em class="italic">Additional material – Unity documentation</em> callout box), where he describes how SOs can be used for building more extensible systems and data patterns.</p>
<p class="callout-heading">Additional material | Unity documentation</p>
<p class="callout">ScriptableObject: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-ScriptableObject.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/class-ScriptableObject.xhtml</a></p>
<p class="callout">Open Projects: <a href="https://unity.com/open-projects" class="pcalibre1 pcalibre calibre6">https://unity.com/open-projects</a></p>
<p class="callout">Unite Austin 2017 - Game Architecture with Scriptable Objects: <a href="https://youtu.be/raQ3iHhE_Kk" class="pcalibre1 pcalibre calibre6">https://youtu.be/raQ3iHhE_Kk</a></p>
<p class="calibre3">With that bit of <a id="_idIndexMarker707" class="pcalibre1 pcalibre calibre6"/>introduction out of the way, we’ll go on now to create our first SO and use it to configure the traits of our enemies.</p>
<h2 id="_idParaDest-136" class="calibre8"><a id="_idTextAnchor140" class="pcalibre1 pcalibre calibre6"/>Creating an enemy Prefab with configurations</h2>
<p class="calibre3">An SO is<a id="_idIndexMarker708" class="pcalibre1 pcalibre calibre6"/> created in <a id="_idIndexMarker709" class="pcalibre1 pcalibre calibre6"/>a similar way to a <code>MonoBehaviour</code> script with some exceptions:</p>
<ul class="calibre17">
<li class="calibre15">The SO must inherit from <code>ScriptableObject</code> instead of <code>MonoBehaviour</code>.</li>
<li class="calibre15">It cannot be attached to a GameObject (as a component). Instead, it is saved as a file asset and referenced by components as a field exposed in the Inspector.</li>
<li class="calibre15">It does not receive all of the same Unity message events that a <code>MonoBehaviour</code> script does (missing, most notably, are <code>Start()</code>, <code>Update()</code>, and <code>FixedUpdate()</code>).</li>
<li class="calibre15">It can create new custom assets based on the <code>ScriptableObject</code> class by using <code>CreateAssetMenu</code>. In contrast, <code>MonoBehaviour</code> can only be configured in the scene and saved as a Prefab (it can then be edited in the <strong class="bold">Prefab Mode</strong>).</li>
</ul>
<p class="calibre3">The <em class="italic">script template</em> for a new enemy configuration data SO asset would look like this:</p>
<pre class="source-code">
using UnityEngine;
[CreateAssetMenu(fileName = "New EnemyConfigData",
    menuName ="ScriptableObjects/EnemyConfigData")]
public class EnemyConfigData : ScriptableObject
{
    public float Speed, AttackRange,
        FireRange, FireCooldown;
    public bool CanJump;
    public float JumpForce;
}</pre> <p class="calibre3">Here, we <a id="_idIndexMarker710" class="pcalibre1 pcalibre calibre6"/>can see<a id="_idIndexMarker711" class="pcalibre1 pcalibre calibre6"/> the <code>[CreateAssetMenu()]</code> attribute that will create a new menu entry in the Editor to facilitate making new file assets based on this <code>EnemyConfigData</code> SO.</p>
<p class="calibre3">Going to the <strong class="bold">Project</strong> window and selecting <strong class="bold">Create</strong> | <strong class="bold">ScriptableObjects</strong> | <strong class="bold">EnemyConfigData</strong>, we can create multiple enemy configuration assets:</p>
<div><div><img alt="Figure 7.7 – Create ScriptableObjects asset menu" src="img/B18347_07_7.jpg" class="calibre85"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Create ScriptableObjects asset menu</p>
<p class="calibre3">The member fields declared for <code>Speed</code>, <code>AttackRange</code>, <code>FireRange</code>, and so on provide configurable data for different types of enemies. There aren’t any currently defined in the previous code, but you can also create methods (for encapsulating fields, returning calculations, helper methods, and ticks as examples).</p>
<p class="calibre3">Create a new script named <code>EnemyConfigData</code> in a new <code>Assets/Scripts/Data</code> folder using the preceding <code>ScriptableObject</code> template.</p>
<p class="calibre3">Regarding the adventure game, and referring<a id="_idIndexMarker712" class="pcalibre1 pcalibre calibre6"/> to our <strong class="bold">Game Design Document</strong> (<strong class="bold">GDD</strong>) in <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Table 4.3</em>, we’ll introduce two kinds of enemy characters (including the dull and uninteresting <em class="italic">maintenance robot</em>).</p>
<p class="calibre3">Go ahead and create two enemy configuration data assets named <code>Enemy A Config</code> and <code>Enemy B Config</code> in a new <code>Assets/Data</code> folder with some default values assigned to <a id="_idIndexMarker713" class="pcalibre1 pcalibre calibre6"/>give each<a id="_idIndexMarker714" class="pcalibre1 pcalibre calibre6"/> robot unique characteristics, as seen in the following screenshot:</p>
<div><div><img alt="Figure 7.8 – Multiple assets for enemy configurations" src="img/B18347_07_8.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Multiple assets for enemy configurations</p>
<p class="calibre3">As you can also conclude from the preceding screenshot, the evil alien plant entity has had its way with the maintenance robots, which are now under its control! No – not that exactly, but I’ve already imported and set up the enemy actors we’ll be applying the configuration data to.</p>
<p class="calibre3">The process to import, rig, create a<a id="_idIndexMarker715" class="pcalibre1 pcalibre calibre6"/> Prefab, add <strong class="bold">inverse kinematics</strong>(<strong class="bold">IK</strong>), and then add animation is the same workflow we performed for the player character. To revisit this workflow, return to the <em class="italic">Setting up the player character with PSD Importer</em> section of <a href="B18347_05.xhtml#_idTextAnchor096" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 5</em></a>.</p>
<p class="calibre3">Go ahead and create Prefabs of the two enemies – <strong class="bold">Enemy A</strong> and <strong class="bold">Enemy B</strong> – using the artwork provided in the GitHub project repo; create your own, or cheat and download the already completed enemy Prefabs from the project repo (preferably, don’t choose this last option, as you’ll need the practice).</p>
<p class="callout-heading">Adventure game 2D art assets</p>
<p class="callout">To follow along in this chapter, download the art assets from the project GitHub repo here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets</a></p>
<p class="calibre3">Whew! Now that we have enemy Prefabs, we can add a component that will utilize the enemy<a id="_idIndexMarker716" class="pcalibre1 pcalibre calibre6"/> configuration <a id="_idIndexMarker717" class="pcalibre1 pcalibre calibre6"/>data. Create a new script named <code>EnemyController</code> in the <code>Assets/Scripts</code> folder – note that we’re back to creating a <code>MonoBehaviour</code> script now:</p>
<pre class="source-code">
Public class EnemyController : MonoBehaviour
{
    [SerializeField]
    private EnemyConfigData _config;
}</pre> <p class="calibre3">By now, this simple script should make a lot of sense to you. We added a field declaration named <code>_config</code> and of the type <code>EnemyConfigData</code>. We gave it an explicit protection keyword of <code>private</code> for the accessor so that no other script can reach it but added the <code>[SerializeField]</code> attribute so that we can make an assignment in the Inspector.</p>
<p class="calibre3">To achieve the configuration in the following screenshot, drag the <code>EnemyConfigData</code> script to the <code>Enemy B</code> Prefab (on the root object), then drag the <code>Enemy B Config ScriptableObject</code> asset in the <code>Assets/Data</code> folder to the <code>EnemyController</code> component. We’ve just added variable configuration data to our enemy! Repeat for <code>Enemy A</code>:</p>
<div><div><img alt="Figure 7.9 – Enemy B configuration" src="img/B18347_07_9.jpg" class="calibre86"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Enemy B configuration</p>
<p class="calibre3">To quickly access the <code>ScriptableObject</code> asset for editing the values, double-click on the <code>ScriptableObject</code> asset reference assigned to the <strong class="bold">Config</strong> field. Alternatively, you can open a <strong class="bold">Focused Inspector</strong> by right-clicking on the asset in the <strong class="bold">Project</strong> window and selecting <strong class="bold">Properties</strong>.</p>
<p class="calibre3">This way, you can view and edit the data without the Inspector changing to other selected objects/assets as you work (an example of this can be seen in <em class="italic">Figure 7</em><em class="italic">.8</em> with both of the enemy configurations open).</p>
<p class="calibre3">Opening a <strong class="bold">Focused Inspector</strong> is also an alternative to locking the Inspector to a single object, which you can do by clicking the little lock icon at the top right of the <strong class="bold">Inspector </strong>window (as shown in <em class="italic">Figure 7</em><em class="italic">.9</em>).</p>
<p class="calibre3">Now<a id="_idIndexMarker718" class="pcalibre1 pcalibre calibre6"/> that<a id="_idIndexMarker719" class="pcalibre1 pcalibre calibre6"/> we have our enemy characters, let’s see how to easily add some variation by extending upon these base Prefabs with Prefab Variants!</p>
<h2 id="_idParaDest-137" class="calibre8"><a id="_idTextAnchor141" class="pcalibre1 pcalibre calibre6"/>Creating an enemy variant for alternate enemy types</h2>
<p class="calibre3">When Unity<a id="_idIndexMarker720" class="pcalibre1 pcalibre calibre6"/> finally <a id="_idIndexMarker721" class="pcalibre1 pcalibre calibre6"/>added native support for <strong class="bold">Nested Prefabs</strong> (circa <a id="_idIndexMarker722" class="pcalibre1 pcalibre calibre6"/>Unity 2018.3), it also included a great new feature <a id="_idIndexMarker723" class="pcalibre1 pcalibre calibre6"/>called <strong class="bold">Prefab Variants</strong>, which are extremely useful for having a unique set of variations that are all based on the same basic Prefab properties.</p>
<p class="calibre3">A base Prefab will have all the basic behaviors required by the object, and then several variations can be created that override properties to make changes to the behavior or appearance of the object.</p>
<p class="calibre3">In our case, using an enemy Prefab as an example, assigning a unique set of configuration values through an <code>EnemyConfigData</code> asset overrides the base Prefab. This may also include changes in color, artwork, or components.</p>
<p class="calibre3">We accomplish varying the configuration data by creating additional <code>EnemyConfigData</code> assets for each of the different enemy characteristics we’re looking to <a id="_idIndexMarker724" class="pcalibre1 pcalibre calibre6"/>have in the game.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><em class="italic">Prefab </em><em class="italic">Variants</em>: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/PrefabVariants.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/PrefabVariants.xhtml</a></p>
<h2 id="_idParaDest-138" class="calibre8"><a id="_idTextAnchor142" class="pcalibre1 pcalibre calibre6"/>Creating a Prefab Variant</h2>
<p class="calibre3">Let’s create a<a id="_idIndexMarker725" class="pcalibre1 pcalibre calibre6"/> variation of the <code>Enemy B</code> Prefab <a id="_idIndexMarker726" class="pcalibre1 pcalibre calibre6"/>with an increased difficulty level for the player by making it move faster, shoot further, and have a quicker rate of fire by shortening the cooldown period.</p>
<p class="calibre3">To do that, let’s take these steps:</p>
<ol class="calibre14">
<li class="calibre15">First, we’ll duplicate the <code>Enemy B Config EnemyConfigData</code> asset file in the <code>Assets/Data</code> folder:<ol class="calibre42"><li class="calibre15">Click on the <code>Enemy B Config</code> asset in the <code>Enemy B </code><code>Config Difficult</code>.</li><li class="calibre15">On the new asset, adjust the values for <code>70</code>, <code>60</code>, and <code>60</code>, respectively).</li></ol></li>
<li class="calibre15">Now, change to the <code>Assets/Prefabs</code> folder.<ol class="calibre42"><li class="calibre15">Right-click on the <code>Enemy B</code> Prefab, then select <code>Enemy </code><code>B Difficult</code>.</li><li class="calibre15">With the new variant selected and the <code>Assets/Data</code> folder and drag the <code>Enemy B Config Difficult</code> asset to the <code>EnemyController</code> component.</li></ol></li>
</ol>
<p class="calibre3">We now have an <code>Enemy B</code> Prefab with different SO configuration data assigned to it, but the remainder of the enemy object is exactly the same since we only overrode the field assignment.</p>
<p class="calibre3"><em class="italic">Figure 7</em><em class="italic">.10</em> shows what our new enemy Prefab variant looks like in the Editor with the difficult enemy configuration SO data assigned: <em class="italic">A</em> is the difficult enemy Prefab, <em class="italic">B</em> shows that this Prefab <a id="_idIndexMarker727" class="pcalibre1 pcalibre calibre6"/>has a <code>Base</code> Prefab it is a variant of, and <em class="italic">C</em> shows the SO <strong class="bold">Config</strong> field assignment <a id="_idIndexMarker728" class="pcalibre1 pcalibre calibre6"/>override:</p>
<div><div><img alt="Figure 7.10 – Difficult Enemy B Prefab Variant setup" src="img/B18347_07_10.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Difficult Enemy B Prefab Variant setup</p>
<p class="calibre3">We can repeat this process for creating different types of enemies or any other type of Prefab that we’ll use in the game. Think about maybe having the maintenance robots start the game without any plant infestation and then gradually build up the infestation as the game progresses. We can use Prefab Variants for the different stages by simply overriding the art assets. Prefab Variants can make progressive changes to art easy to achieve!</p>
<p class="calibre3">By using the SO to override the configuration data, we have separated the data from the Prefab asset (including various components, art assets, sound, effects, and so on). The SO data is a small object that can be updated outside of having to edit the Prefab, which makes things more accessible to designers and non-programmers.</p>
<p class="calibre3">Also, if only the data needs to change, then it’s a tiny update that can be pushed to games in production without having to push the entire Prefab asset.</p>
<p class="calibre3">From this section, having <a id="_idIndexMarker729" class="pcalibre1 pcalibre calibre6"/>a set of enemies with unique variations is great, but it would be even better <a id="_idIndexMarker730" class="pcalibre1 pcalibre calibre6"/>if they had some behavior based on their configuration data!</p>
<p class="calibre3">The <a id="_idTextAnchor143" class="pcalibre1 pcalibre calibre6"/>next section will look at adding behavior to the enemy robots.</p>
<h1 id="_idParaDest-139" class="calibre5"><a id="_idTextAnchor144" class="pcalibre1 pcalibre calibre6"/>Implementing basic enemy behavior using an FSM</h1>
<p class="calibre3">In <a href="B18347_02.xhtml#_idTextAnchor041" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, we briefly<a id="_idIndexMarker731" class="pcalibre1 pcalibre calibre6"/> introduced the State Pattern, so we’ll now look at how to implement this design pattern for keeping the state of our enemy characters. Expressly, using an FSM, we can declare the fixed set of states (that is, finite) our enemy can be in at any given time – and the FSM is only going to do precisely these things.</p>
<p class="calibre3">The first implementation of our FSM will not adhere to SOLID principles very well, but it will hopefully be a simple enough introduction that will make sense practically. We can also use it as an example to point out any flaws with the approach and later refactor it to something better.</p>
<p class="calibre3">I should note that maybe we won’t refactor it later… sometimes a simple approach is all that is required, and refactoring for the sake of refactoring is just wasted effort where that time could be better spent on tightening up the core game mechanic instead, for example.</p>
<p class="callout-heading">Additional reading | Programming patterns</p>
<p class="callout">Finite state machine explained: <a href="https://www.freecodecamp.org/news/finite-state-machines/" class="pcalibre1 pcalibre calibre6">https://www.freecodecamp.org/news/finite-state-machines/</a></p>
<p class="calibre3">Let’s start by having a look at which states – or behaviors – we want for our enemy characters.</p>
<h2 id="_idParaDest-140" class="calibre8"><a id="_idTextAnchor145" class="pcalibre1 pcalibre calibre6"/>State Model</h2>
<p class="calibre3">Referring <a id="_idIndexMarker732" class="pcalibre1 pcalibre calibre6"/>back to our <a id="_idIndexMarker733" class="pcalibre1 pcalibre calibre6"/>GDD in <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Table 4.1</em>, where we loosely defined the behaviors of our enemy during engagement with the player, we can derive the following minimum states being required: <strong class="bold">Idle</strong>, <strong class="bold">Patrol</strong>, <strong class="bold">Attack</strong>, <strong class="bold">Dead</strong>.</p>
<p class="calibre3">Now, we can take those states and design a UML state diagram for our enemy behaviors. Conditions for determining when to change between the states are also defined:</p>
<div><div><img alt="Figure 7.11 – Enemy behavior State Model" src="img/B18347_07_11.jpg" class="calibre87"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Enemy behavior State Model</p>
<p class="calibre3">Referring to the<a id="_idIndexMarker734" class="pcalibre1 pcalibre calibre6"/> diagram and using <a id="_idIndexMarker735" class="pcalibre1 pcalibre calibre6"/>the conditions to determine when to transition from one state to another, we can observe the following:</p>
<ul class="calibre17">
<li class="calibre15">The default starting state is <strong class="bold">Idle</strong></li>
<li class="calibre15">While in the <strong class="bold">Idle</strong> state, we will transition to <strong class="bold">Patrol</strong> when a timer expires</li>
<li class="calibre15">While in the <strong class="bold">Patrol</strong> state, we will transition back to <strong class="bold">Idle</strong> when a timer expires (for example, <strong class="bold">Idle</strong> --&gt; <strong class="bold">Patrol</strong> --&gt; <strong class="bold">Idle</strong> --&gt; <strong class="bold">Patrol</strong>)</li>
<li class="calibre15">While in the <strong class="bold">Idle</strong> or <strong class="bold">Patrol</strong> state, we will transition to <strong class="bold">Attack</strong> when the player is in range</li>
<li class="calibre15">While in the <strong class="bold">Attack</strong> state, we will go back to <strong class="bold">Patrol</strong> when the player moves out of range</li>
<li class="calibre15">We will transition from any state to <strong class="bold">Dead</strong> when health is zero</li>
</ul>
<p class="calibre3">Now that we <a id="_idIndexMarker736" class="pcalibre1 pcalibre calibre6"/>know which states we need<a id="_idIndexMarker737" class="pcalibre1 pcalibre calibre6"/> and which conditions change state, we can move on to coding up this thing!</p>
<h2 id="_idParaDest-141" class="calibre8"><a id="_idTextAnchor146" class="pcalibre1 pcalibre calibre6"/>A simple FSM pattern</h2>
<p class="calibre3">We’ll make our <a id="_idIndexMarker738" class="pcalibre1 pcalibre calibre6"/>first FSM using enums for defining our finite states and code the state-changing logic within the <code>EnemyController</code> class. This code is similar to what you’ll likely run across in projects for beginners because it’s easy to understand and simple to work with (and, as mentioned previously, may be all that is required).</p>
<p class="calibre3">But it does have some limitations and drawbacks. The first one is that the state machine is integral to the <code>EnemyController</code> class, violating<a id="_idIndexMarker739" class="pcalibre1 pcalibre calibre6"/> the <strong class="bold">Single Responsibility </strong><strong class="bold">Principle</strong> (<strong class="bold">SRP</strong>).</p>
<p class="calibre3">Let’s have a look:</p>
<pre class="source-code">
public class EnemyController : MonoBehaviour
{
    …
    public enum State { Idle, Patrol, Attack, Dead }
    private State _currentState;
    private void Start() =&gt; ChangeState(State.Idle);
    void Update()
    {
        switch (_currentState)
        {
            case State.Idle:
                // UNDONE: Do stuff --&gt; change state?
                break;
            case State.Patrol:
                // UNDONE: Do stuff --&gt; change state?
                break;
            // And so on.
        }
    }
    public void ChangeState(State state) =&gt;
        _currentState = state;
}</pre> <p class="calibre3">As we can see, we have defined the FSM states from our State Model in the <code>public enum State {}</code> declaration line. Our FSM can only be in one of these defined states. Then, we’ll use the <code>_currentState</code> variable to keep track of our current state.</p>
<p class="calibre3">Let’s skip down<a id="_idIndexMarker740" class="pcalibre1 pcalibre calibre6"/> to the <code>ChangeState()</code> method, where we can see we’ll call it by passing in a <code>State</code> to set it as the current state of the FSM (that is, transition to a different state). In <code>Start()</code>, you can see how we call <code>ChangeState(State.Idle)</code> to set our initial (default) state for <strong class="bold">Enemy</strong> to <strong class="bold">Idle</strong>.</p>
<p class="calibre3">Lastly, in the <code>Update()</code> method (called every frame update), we have a <code>switch</code> statement that has an implementation for each state declared in the <code>State</code> enum. When <code>_currentState</code> is equal to one of the defined enum states, we <em class="italic">do stuff</em> – you can relate the <code>switch</code> statement to a block of <code>if</code>, <code>else if</code>, <code>else if</code> statements (but it’s undoubtedly more readable for when we don’t need to test expressions for ranges of values or conditions).</p>
<p class="callout-heading">switch (C#)</p>
<p class="callout">A <strong class="source-inline1">switch</strong> statement<a id="_idIndexMarker741" class="pcalibre1 pcalibre calibre6"/> is a <em class="italic">selection control</em> statement that tests an expression (similar to an <strong class="source-inline1">if</strong> statement) and executes the matching block of code defined by the cases (and as terminated by the <strong class="source-inline1">break</strong> statement). A default case can be defined if there is no match for the expression.</p>
<p class="calibre3">I don’t necessarily have a problem with this oversimplified approach to a State Pattern, but the <code>switch</code> statement quickly gets ugly. With many states, it can start getting hard to manage, as we’ll see when we start adding conditions and behaviors to it, but at least it doesn’t rely on an arbitrary number of Boolean variables to attempt and maintain some form of state (and without having to wrangle two of those variables becoming true simultaneously – yikes!).</p>
<p class="calibre3">One problem with the enum-based approach that breaks the <em class="italic">O</em> in SOLID (<code>EnemyController</code> class (that is, closed for modification). Preferably, we’d like only to change the affected state’s code and not touch anything else!</p>
<p class="calibre3">Code that functions and has nothing to do with the state should not have to be retested (for example, acceptance and regression testing) or, in a team environment, even be code reviewed while committing the modification for the <a id="_idIndexMarker743" class="pcalibre1 pcalibre calibre6"/>state to the <strong class="bold">version control </strong><strong class="bold">system</strong> (<strong class="bold">VCS</strong>).</p>
<p class="calibre3">At the very least, this enum-based approach provides a structure that makes the code more readable than without it, and it’s simple to include the State Pattern without first having to write boilerplate code for the state machine.</p>
<p class="calibre3">You may be able to imagine how we could extend this State Pattern by encapsulating all of a particular state’s<a id="_idIndexMarker744" class="pcalibre1 pcalibre calibre6"/> behaviors (and data) into a single class. If so, great! If not, no worries, since we’ll tackle refactoring this FSM later on in <a href="B18347_13.xhtml#_idTextAnchor256" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>!</p>
<p class="calibre3">Okay – with the caveats out of the way, let’s change some states!</p>
<h2 id="_idParaDest-142" class="calibre8"><a id="_idTextAnchor147" class="pcalibre1 pcalibre calibre6"/>Changing state behaviors</h2>
<p class="calibre3">Now that we have<a id="_idIndexMarker745" class="pcalibre1 pcalibre calibre6"/> our finite set of states defined and coded in our simple FSM pattern, you may wonder how we add in the conditions for changing state. Wonder no more – it’s pretty simple!</p>
<p class="calibre3">We’ll start by <a id="_idIndexMarker746" class="pcalibre1 pcalibre calibre6"/>adding the required fields and assigning default values to evaluate our conditions for the first two states.</p>
<h3 class="calibre10">Idle and patrol behaviors</h3>
<p class="calibre3">Referring to the <strong class="bold">State Model</strong> in <em class="italic">Figure 7</em><em class="italic">.11</em>, let’s have the enemy patrol a path between two positions (we’ll define in the level) after remaining idle (stationary) for a specific time. Then, after patrolling for a particular time, we’ll have our enemy return to idling, and repeat the process indefinitely while the enemy is not attacking the player or, well, is dead.</p>
<p class="calibre3">For this, let’s first add two variables to our <code>EnemyConfigData</code> SO that will specify our times for how long the enemy will idle and patrol:</p>
<pre class="source-code">
public class EnemyConfigData : ScriptableObject
{
    …
    [Header("Behavior Properties")]
    public float TimeIdle = 5f;
    public float TimePatrol = 15f;
}</pre> <p class="calibre3">Don’t forget that<a id="_idIndexMarker747" class="pcalibre1 pcalibre calibre6"/> you can override these default time values in the Editor by selecting the <code>Enemy B Config</code> asset in the <code>Assets/Data</code> folder and changing the values.</p>
<p class="calibre3">Now, back in the <code>EnemyController</code> class, we’ll need a way to track when we changed into a state to calculate the time elapsed:</p>
<pre class="source-code">
private float _timeStateStart;
public void ChangeState(State state)
{
    _currentState = state;
    _timeStateStart = Time.time;
}</pre> <p class="calibre3">We’ve added the <code>_timeStateStart</code> float variable that we set to the current game time in the <code>ChangeState()</code> method (which has been changed to a body block from an expression body). Calling the <code>ChangeState()</code> method provides a way for us to do things <em class="italic">on the state entered</em> rather than just setting the <code>_currentState</code> variable directly to the new state we’re transitioning to (which doesn’t afford us the option).</p>
<p class="calibre3">With the required fields and assigned values now set up, we can proceed to evaluate the conditions<a id="_idIndexMarker748" class="pcalibre1 pcalibre calibre6"/> for changing to/from the <strong class="bold">Idle</strong> and <strong class="bold">Patrol</strong> states:</p>
<pre class="source-code">
…
void Update()
{
    switch (_currentState)
    {
        case State.Idle:
            // UNDONE: Do stuff.
            // Change state?
            if (Time.time - _timeStateStart
                &gt;= _config.TimeIdle)
                    ChangeState(State.Patrol);
            break;
        case State.Patrol:
            // UNDONE: Do stuff.
            if (Time.time - _timeStateStart
                &gt;= _config.TimePatrol)
                    ChangeState(State.Idle);
            break;
        …</pre> <p class="calibre3">As you can see in the preceding code, we have a new <code>if</code> block that evaluates the current time, <code>Time.time</code>, minus the time we transitioned into the current state, <code>_timeStateStart</code>. If the difference is greater than or equal to our configured time to remain idle, <code>_config.TimeIdle</code>, then call the <code>ChangeState()</code> method to transition to the <strong class="bold">Patrol</strong> state. Easy-peasy!</p>
<p class="calibre3">Similarly, we will evaluate transitioning from <code>_configTimePatrol</code> value (that is, how long the enemy should patrol for). And now, you may be wondering: how do we make the enemy character actually patrol?</p>
<h3 class="calibre10">Implementing behavior</h3>
<p class="calibre3">For the <code>EnemyController</code> class, but instead of doing that again, and getting too far away from Single Responsibility, let’s at least abstract the behaviors into their own classes.</p>
<p class="calibre3">We’ll therefore define behaviors via an interface so that we can swap out the behavior code, should we need or want to change it without modifying the class that implements it.</p>
<p class="calibre3">So, create a new C# script named <code>IBehaviorPatrolWaypoints</code> in the <code>Assets/Scripts/Interfaces</code> folder and add the following interface declaration for a <em class="italic">patrol </em><em class="italic">waypoints behavior</em>:</p>
<pre class="source-code">
public interface IBehaviorPatrolWaypoints
{
    Transform WaypointPatrolLeft { get; }
    Transform WaypointPatrolRight { get; }
    void Init(Rigidbody2D rb, Vector2 direction,
        float acceleration, float speedMax);
    void TickPhysics();
}</pre> <p class="calibre3">Here, we can see that we’ve declared two points in the level that will create the path the enemy will patrol between as <code>WaypointPatrolLeft</code> and <code>WaypointPatrolRight</code>. We’ll place an empty GameObject at each position in the level and assign their references to these fields in the Inspector.</p>
<p class="calibre3">To help visualize the concept of a patrol path better, referring to the following diagram, the dots (blue) represent the waypoints (that is, the empty GameObjects), and the dashed line (orange) represents <a id="_idIndexMarker750" class="pcalibre1 pcalibre calibre6"/>the patrol path created from the waypoints:</p>
<div><div><img alt="Figure 7.12 – Waypoints and patrol path" src="img/B18347_07_12.jpg" class="calibre18"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Waypoints and patrol path</p>
<p class="calibre3">(Spoiler… players should hide in the square area (green) just south of the wall to avoid patrolling agents’ gaze. Look out!)</p>
<p class="calibre3">Back to the code, we then have an <code>Init()</code> method that will be called from the implementing class that will pass in (or, you might say, <em class="italic">inject</em>) the required dependencies the behavior needs to function as parameters.</p>
<p class="calibre3">Last is the declaration for the <code>TickPhysics()</code> method that will be called by the implementing class’s <code>FixedUpdate()</code> method to perform the actual function of moving the enemy between the waypoints (using physics).</p>
<p class="calibre3">Back in the <code>EnemyController</code> class now, let’s create a variable of type <code>IBehaviorPatrolWaypoints</code>. We’ll obtain the reference to an instance of it – which should exist as a sibling component on the <code>EnemyController</code> object – by using <code>TryGetComponent()</code>:</p>
<pre class="source-code">
// Implemented behaviors.
private IBehaviorPatrolWaypoints _behaviorPatrol;
private void Awake()
{
    …
    // Get behaviors and initialize.
    if (TryGetComponent&lt;IBehaviorPatrolWaypoints&gt;(
        out _behaviorPatrol))
    {
        _behaviorPatrol.Init(_rb, _movementDirection,
            _config.Acceleration, _config.SpeedMax);
    }
}</pre> <p class="calibre3">This is how we can<a id="_idIndexMarker751" class="pcalibre1 pcalibre calibre6"/> swap out behaviors with other behaviors of the same type without modifying the implementing class. By using Unity’s <code>GetComponent()</code> architecture – which allows a <a id="_idIndexMarker752" class="pcalibre1 pcalibre calibre6"/>form of <code>MonoBehaviour</code>) that implement <code>IBehaviorPatrolWaypoints</code> and obtain the component instance via the interface.</p>
<p class="callout-heading">Composition (OOP)</p>
<p class="callout"><strong class="bold">Composition</strong> is usually referred to as a <em class="italic">has-a-relationship</em> and is achieved by a class using instance variable(s) that refer to another object (of a class or another class). The term <em class="italic">combining</em> is also used to describe composition in <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) because <a id="_idIndexMarker753" class="pcalibre1 pcalibre calibre6"/>it deals with bringing multiple objects together to achieve an outcome.</p>
<p class="calibre3">Since <code>IBehaviorPatrolWaypoints</code> is simply a behavior that moves the object it is added to between two points, and it doesn’t explicitly have to be used on the enemy, it can be used on any object we want to have this behavior.</p>
<p class="calibre3">Okay – for the last part of implementing the behavior, we’ll need to have the <code>TickPhysics()</code> method tied into the <code>FixedUpdate()</code> method of the <code>EnemyController</code> class so<a id="_idIndexMarker754" class="pcalibre1 pcalibre calibre6"/> that it can perform its behavioral function. And we do it like this:</p>
<pre class="source-code">
private void FixedUpdate()
{
    if (_currentState == State.Patrol)
        _behaviorPatrol?.TickPhysics();
    else
        _rb.velocity = Vector2.zero;
}</pre> <p class="calibre3">What we have here again, same as in <code>Update()</code>, is having to check the current state we are in before calling the <code>tick</code> method for the current behavior to execute (that is, more code smell since the state check is occurring in multiple places in the class).</p>
<p class="callout-heading">Code smell</p>
<p class="callout">A <strong class="bold">code smell</strong> refers <a id="_idIndexMarker755" class="pcalibre1 pcalibre calibre6"/>to source code that is a <em class="italic">quick-to-spot indicator</em> for deeper or interesting problems that may exist within the code base. These are not bugs nor errors but violations of fundamental principles that decrease the quality of the code base. By nature, they are unquantifiable and subjective to the developer’s experience.</p>
<p class="calibre3">If <code>_currentState</code> is <code>Patrol</code>, then call <code>_behaviorPatrol?.TickPhysics()</code>. We used the <code>null</code> conditional operator (<code>?.</code>) on the behavior variable (an interface) in case the enemy object was not implemented with an <code>IBehaviorPatrolWaypoint</code> component. You may prefer, however, not to use <code>?.</code> and let it throw an error while playtesting in the Editor to validate the object configuration. It’s up to you how you prefer to work (this would commonly be referred to as <em class="italic">developer style</em>).</p>
<p class="callout-heading">Null conditional operator (?.) and Unity objects</p>
<p class="callout">Note that null propagation is incompatible with Unity objects because Unity overrides the null comparison operator (to properly return null for objects that were destroyed but not yet garbage collected). Your IDE should provide a warning when attempting to use the <strong class="source-inline1">?.</strong> operator on Unity objects (if not, then get a new IDE). The correct approach would be to simply use a null comparison. Example:</p>
<p class="callout">NO</p>
<p class="callout"><strong class="source-inline1"> </strong><strong class="source-inline1">_player?.Jump();</strong></p>
<p class="callout">YES</p>
<p class="callout"><strong class="source-inline1">    if (_player != </strong><strong class="source-inline1">null)</strong></p>
<p class="callout"><strong class="source-inline1"> </strong><strong class="source-inline1">_player.Jump();</strong></p>
<p class="calibre3">Th<a id="_idTextAnchor148" class="pcalibre1 pcalibre calibre6"/>e final step for fully <a id="_idIndexMarker756" class="pcalibre1 pcalibre calibre6"/>implementing the behavior is to create a class that implements <code>IBehaviorPatrolWaypoints</code> and contains the movement logic. I’ll present the completed code later in <a href="B18347_13.xhtml#_idTextAnchor256" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, when we refactor and extend upon the enemy behavior logic, but for now, I’m going to challenge you to create the script yourself!</p>
<p class="calibre3">To give you a hint, take a look at how we added movement to the player (remember – use physics; don’t manipulate the transform position directly!) and start with this class declaration for a new component script named <code>PatrolWaypoints</code>:</p>
<pre class="source-code">
public class PatrolWaypoints
    : MonoBehaviour, IBehaviorPatrolWaypoints
{
     // Do move between waypoints stuff.
}</pre> <p class="calibre3">Or, you can cheat. I mean, take a peek now at the final code in the GitHub project files for the book here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch7/Unity%20Project/Assets/Scripts/Behaviors" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch7/Unity%20Project/Assets/Scripts/Behaviors</a>.</p>
<p class="calibre3">We’ll implement every other behavior in the same fashion, adding on a new state conditional check within each method that requires processing for the current state, as well as doing the following:</p>
<ul class="calibre17">
<li class="calibre15">Declaring an instance variable and using <code>GetComponent()</code> to obtain the reference</li>
<li class="calibre15">Initializing the behavior instance and providing required dependencies via its <code>Init()</code> method</li>
<li class="calibre15">Adding a call to its <code>TickPhysics()</code> method to <code>FixedUpdate()</code> to perform its function</li>
</ul>
<p class="callout-heading">Optimization note</p>
<p class="callout">With our base class – <strong class="source-inline1">EnemyController</strong>, in this case – implementing the behaviors, it means none of our behaviors needs to have its own <strong class="source-inline1">FixedUpdate()</strong> Unity message event being registered and called; so, having a <strong class="source-inline1">tick</strong> method being called instead is a bit more efficient as it reduces the interop overhead (C# code being called from the C++ engine code) – and it could certainly add up if we have many enemies!</p>
<p class="calibre3">As you can see, however, this<a id="_idIndexMarker757" class="pcalibre1 pcalibre calibre6"/> is, in fact, getting ugly with the enum-based State Pattern. For now, let’s continue with setting up the condition for transitioning to the <strong class="bold">Attack</strong> state.</p>
<h3 class="calibre10">Behavior for attacking the player</h3>
<p class="calibre3">We’ll need some additional references for the <strong class="bold">Attack</strong> behavior – specifically, the player. After all, you can’t attack what you can’t see.</p>
<p class="calibre3">In <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, we assigned the <code>Player</code> tag to our <code>Player</code> object in the Inspector to determine if it was the player that interacted with a collision event. Well, we’re going to use the tag again now, but differently.</p>
<p class="calibre3">We’ll use the tag as a parameter for the <code>FindWithTag()</code> method to obtain a reference to our <code>Player</code> object in the scene.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><strong class="source-inline1">FindWithTag</strong>: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.FindWithTag.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.FindWithTag.xhtml</a></p>
<p class="calibre3">Instead of assigning the reference to a field exposed in the Inspector, we need to get the <code>Player</code> reference dynamically because our enemy Prefabs may be spawned into the scene at runtime. Hence, it’s impossible to make that assignment (scene references cannot be made in file-based assets such as Prefabs and SOs).</p>
<p class="calibre3">Still within <code>EnemyController</code>, once we have the reference to <code>Player</code>, let’s check the distance to the player <a id="_idIndexMarker758" class="pcalibre1 pcalibre calibre6"/>and change the state to <strong class="bold">Attack</strong> if the player is within our arbitrary range value:</p>
<pre class="source-code">
private GameObject _player;
private void Awake() =&gt;
    _player = GameObject.FindWithTag(Tags.Player);
private bool IsPlayerInRange(float rangeAttack)
{
    var distance =
        Vector2.Distance(transform.position,
            _player.transform.position);
    return distance &lt;= rangeAttack;
}</pre> <p class="calibre3">We first declare a <code>_player</code> variable to hold the GameObject reference to the <code>Player</code> object. Then, in <code>Awake()</code>, we assign the player found in the scene by using <code>FindWithTag()</code> and passing in our previously declared string constant, <code>Tags.Player</code>.</p>
<p class="callout-heading">Optimization note</p>
<p class="callout"><strong class="source-inline1">FindWithTag()</strong> is a slow command, but we’ll do it in <strong class="source-inline1">Awake()</strong> to get the reference to Player before gameplay stats (i.e., caching the reference). Generally, you wouldn’t want to do this during gameplay because it’s slow, and definitely not in <strong class="source-inline1">Update()</strong> since that is called every frame!</p>
<p class="calibre3">Next, we add the <code>IsPlayerInRange()</code> method for calculating the distance to the <code>Player</code> object using advanced trigonometric geometry mathematics! Nah – you can already see in the previous code that we simply use the <code>Vector2.Distance()</code> method and pass in the current position of both <code>Enemy</code> and <code>Player</code> to get a float value of the distance between them. Easy-peasy!</p>
<p class="calibre3">Previously, we used the <code>return</code> keyword to stop the code in a method from executing further. Here, we’re doing the same thing (sort of; in this case, it’s the last statement), but because the<a id="_idIndexMarker759" class="pcalibre1 pcalibre calibre6"/> method signature for <code>IsPlayerInRange()</code> is declared as <code>bool</code> and not <code>void</code>, we need to return a bool value, the result of evaluating the distance returned from <code>Vector2.Distance()</code> being less than or equal to (<code>&lt;=</code>) the specified <code>rangeAttack</code> value.</p>
<p class="callout-heading">Question</p>
<p class="callout">Is the <strong class="source-inline1">EnemyController</strong> class the best place to declare the <strong class="source-inline1">IsPlayerInRange()</strong> method? Does this follow the SRP? If we need to change the logic for calculating the player distance, will it negatively affect other code?</p>
<p class="callout">While you ponder that, I’ll leave it right where it is in <strong class="source-inline1">EnemyController</strong> (for now?).</p>
<p class="calibre3">And, finally, with our dependencies now in place, let’s wire up the condition for transitioning into and out of the <strong class="bold">Attack</strong> state:</p>
<pre class="source-code">
void Update()
{
    switch (_currentState)
    {
        case State.Idle:
            // UNDONE: Do stuff.
            // Change state?
            if (IsPlayerInRange(_config.AttackRange))
                ChangeState(State.Attack);
            else if (Time.time - _timeStateStart
                &gt;= _config.TimeIdle)
                    ChangeState(State.Patrol);
            break;
        …
        case State.Attack:
            // UNDONE: Do stuff.
            if (!IsPlayerInRange(_config.AttackRange))
                ChangeState(State.Patrol);
            break;
        …</pre> <p class="calibre3">If we refer back <a id="_idIndexMarker760" class="pcalibre1 pcalibre calibre6"/>to the <code>is [player] in range</code> condition and transition to the <strong class="bold">Attack</strong> state if so.</p>
<p class="calibre3">We’ll do this by adding to our <code>Change state?</code> <code>if</code> block, so we add <code>IsPlayerInRange()</code> and pass in the <code>AttackRange</code> value configured for this enemy object. If within range, boom: <code>ChangeState(State.Attack)</code>!</p>
<p class="calibre3">Conversely, in the <code>!</code>) to the <code>IsPlayerInRange()</code> call to reverse the result (the logical <code>not</code> operator returns <code>false</code> if the result is <code>true</code>) – which changes the evaluation from <em class="italic">is player in range</em> to <em class="italic">is player not </em><em class="italic">in range</em>.</p>
<p class="calibre3">Not shown in the preceding code (for brevity), but the <code>IsPlayerInRange()</code> condition check (just as our State Model says it should).</p>
<p class="calibre3">Now let’s see how we<a id="_idIndexMarker761" class="pcalibre1 pcalibre calibre6"/> handle our final state from our State Model: the <strong class="bold">Dead</strong> state (that is, in fact, quite final).</p>
<h3 class="calibre10">Dead state</h3>
<p class="calibre3">The enemy would now be able to attack the player while in range – we’ll look at implementing the exact attack behavior in the following chapter, <a href="B18347_08.xhtml#_idTextAnchor151" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, when the player attacks and immobilizes the infected robot enemy; however, we can, for now, provide a <strong class="bold">Dead</strong> state <a id="_idIndexMarker762" class="pcalibre1 pcalibre calibre6"/>to handle that.</p>
<p class="calibre3">When we change to this state, we’ll simply destroy the <strong class="bold">Enemy</strong> GameObject like so:</p>
<pre class="source-code">
void Update()
{
    switch (_currentState)
    {
        …
        case State.Dead:
            Destroy(gameObject);
            break;
    }
}</pre> <p class="calibre3">Using <code>Destroy()</code> like this is fine since we can still add <em class="italic">on-death</em> effects to the enemy using its <code>OnDestroy()</code> Unity message event.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><strong class="source-inline1">MonoBehaviour.OnDestroy</strong>: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnDestroy.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnDestroy.xhtml</a></p>
<p class="calibre3">The condition, however, needs to be checked outside the <code>switch</code> statement because we want to check for some health value becoming zero all the time – no matter the current state. We can do this by adding an <code>if</code> statement after the <code>switch</code> statement – the <code>switch</code> section is only for processing the current state!</p>
<pre class="source-code">
void Update()
{
    switch (_currentState)
    …
    // Any state.
    if (_health &lt;= 0)
    {
        ChangeState(State.Dead);
    }
}</pre> <p class="calibre3">Don’t worry too much about the <code>_health</code> variable at the moment; we’re going to implement health and damage systems in <a href="B18347_08.xhtml#_idTextAnchor151" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>. As you can see in the preceding code, we’re simply checking if this enemy’s health equals or dips below zero and changing to the <strong class="bold">Dead</strong> state if so.</p>
<p class="calibre3">This section introduced you to the State Pattern, a State Model UML diagram, and setting up a simple <a id="_idIndexMarker763" class="pcalibre1 pcalibre calibre6"/>FSM for managing different states based on the State Model for our enemy characters.</p>
<h1 id="_idParaDest-143" class="calibre5"><a id="_idTextAnchor149" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">In this chapter, we added some polish to the shooting and player character by introducing URP post-processing, <strong class="bold">Shader Graph</strong>, 2D lights, and the <strong class="bold">Trail Renderer</strong> effect. Phew! Having these featur<a id="_idTextAnchor150" class="pcalibre1 pcalibre calibre6"/>es out of the box with Unity allows us to add visual quality to our games with little effort.</p>
<p class="calibre3">We continued by adding some configurable enemy characters to the game by creating two enemy Prefabs and assigning unique configuration variables to each via the ScriptableObject assets. The enemy objects were then given behavior by implementing the State Pattern to introduce basic behavior with an FSM and evaluate conditions for transitioning between states.</p>
<p class="calibre3">In the next chapter, we’ll complete the adventure game by adding health and damage systems for enemies that we’ll spawn into the level, implement the attack mechanics with additional weapon types, create a simple quest system for collecting key objects for solving the entryway puzzle, and introduce a new event system for keeping our code loosely coupled.</p>
</div>
</div></body></html>