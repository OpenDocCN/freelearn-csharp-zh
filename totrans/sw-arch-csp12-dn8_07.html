<html><head></head><body>
<div><h1 class="chapterNumber">7</h1>
<h1 class="chapterTitle" id="_idParaDest-138">Understanding the Different Domains in Software Solutions</h1>
<p class="normal">This chapter is dedicated to a modern software development technique called <strong class="keyWord">domain-driven design</strong> (<strong class="keyWord">DDD</strong>), which was first proposed by Eric Evans (see <em class="italic">Domain-Driven Design</em>: <a href="https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20">https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20</a>). While DDD has existed for more than 15 years, it has achieved great success in the last few years because of its ability to cope with two important problems.</p>
<p class="normal">The main problem is modeling complex systems that involve several domains of knowledge. No single expert has in-depth knowledge of the whole domain; this knowledge is instead split among several people. The second problem is that each expert speaks a language that is specific to his domain of expertise, so for effective communication between the experts and the development team, objects, interfaces, and methods must mimic the language of the domain experts. This means that the different modules that compose an application must use a different vocabulary for each domain of expertise. Consequently, the application must be split into modules that reflect the different domains of knowledge, and the interface between modules that deal with the different domains of knowledge must be carefully designed to carry out the necessary translations.</p>
<p class="normal">DDD copes with this problem by splitting the whole CI/CD cycle into independent parts, assigned to different teams. This way, each team can focus on a specific domain of knowledge by interacting only with the experts in that domain.</p>
<p class="normal">That’s why the evolution of DDD is interleaved with the evolution of microservices and DevOps. Thanks to DDD, big projects can be split among several development teams, with each team having a different domain of knowledge. There are many reasons why a project is split among several teams, with the most common being the team’s size and all of its members having different skills and/or being in different locations. In fact, experience has proven that teams of more than 6–8 people are not effective, and, clearly, different skills and locations prevent tight interaction from occurring.</p>
<p class="normal">In turn, the importance of the two aforementioned problems has grown in the last few years. Software systems have always taken up a lot of space inside every organization, and they have become more and more complex and geographically distributed.</p>
<p class="normal">At the same time, the need for frequent updates has increased so that these complex software systems can be adapted to the needs of a quickly changing market.</p>
<p class="normal">As a result of the increasing complexity and need for frequent updates in software systems, we now face a scenario where it’s common to implement complex software systems with associated fast CI/CD cycles that always require more people to evolve and maintain them. In turn, this created a need for technologies that were adequate for high-complexity domains and for the cooperation of several loosely coupled development teams.</p>
<p class="normal">In this chapter, we will analyze the basic principles, advantages, and common patterns related to DDD, as well as how to use them in our solutions.</p>
<p class="normal">More specifically, we will cover the following topics:</p>
<ul>
<li class="bulletList">What are software domains?</li>
<li class="bulletList">Understanding DDD</li>
<li class="bulletList">Common DDD patterns and architectures</li>
</ul>
<p class="normal">Let’s get started.</p>
<div><p class="normal">As you progress through the second part of the book, you might find it enriching to revisit this particular chapter. Reflecting on these concepts with a deeper understanding can offer new insights and enhance your overall experience. Feel free to come back to this chapter as a resource whenever you encounter related ideas later on.</p>
</div>
<h1 class="heading-1" id="_idParaDest-139">Technical requirements</h1>
<p class="normal">This chapter requires the free Visual Studio 2022 Community Edition or better, with all the database tools installed.</p>
<p class="normal">All the code snippets in this chapter can be found in the GitHub repository associated with this book: <a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</a>.</p>
<h1 class="heading-1" id="_idParaDest-140">What are software domains?</h1>
<p class="normal">As we discussed in <em class="italic">Chapter 2</em>, <em class="italic">Non-Functional Requirements</em>, and <em class="italic">Chapter 3</em>, <em class="italic">Managing Requirements</em>, the transfer of knowledge from domain experts to the development team plays a fundamental role in software design. Developers try to communicate with experts <a id="_idIndexMarker408"/>and describe their solutions in a language that domain experts and stakeholders can also understand. However, often, the same word has a different meaning in various parts of an organization, and what appears to be the same conceptual entities have completely different shapes in different contexts.</p>
<p class="normal">For instance, in our WWTravelClub use case, the order-payment and package-handling subsystems use completely different models for customers. The order-payment subsystem characterizes a customer by their payment methods, currency, bank accounts, and credit cards, while package-handling is more concerned with the locations that have been visited and/or the packages that have been purchased, the user’s preferences, and their geographical location. Moreover, while order-payment refers to various concepts with a language that we may roughly <a id="_idIndexMarker409"/>define as a <strong class="keyWord">bank language</strong>, package-handling uses a language that is typical of travel agencies/operators.</p>
<p class="normal">The classic way to cope with these discrepancies is to use a unique abstract entity called <strong class="keyWord">customer</strong>, which projects<a id="_idIndexMarker410"/> into two different views—the order-payment view and the package-handling view. Each projection operation takes some operations and some properties from the <strong class="keyWord">customer</strong> abstract entity and changes their names. Since domain experts only give us the projected views, our main task as system designers is to create a conceptual model that can explain all the views. The following diagram shows how different views are handled:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_07_01.png"/></figure>
<p class="packt_figref">Figure 7.1: Creating a unique model</p>
<p class="normal">The main advantage of the classic approach is that we have a unique and coherent representation of the data of the domain. If this conceptual model is built successfully, all the operations will have a formal definition and purpose and the whole abstraction will be a rationalization of the way the whole organization should work, possibly highlighting and correcting<a id="_idIndexMarker411"/> errors and simplifying some procedures.</p>
<p class="normal">However, what are the <a id="_idIndexMarker412"/>downsides of this approach?</p>
<p class="normal">The sharp adoption of a new monolithic data model may cause an acceptable impact in a small organization when the software is destined for a small part of the overall organization, or when the software automates a small enough percentage of the data flow. However, if the software becomes the backbone of a complex, geographically distributed organization, sharp changes become unacceptable and unfeasible. On the one hand, big structured companies need to react quickly to market changes, but on the other hand, due to the complexity of their organizations, only gradual changes are feasible. Therefore, the changes in their organizations and information systems that are needed to adapt to the market must be gradual. In turn, a gradual transition is possible only if old data models can coexist <a id="_idIndexMarker413"/>with new data models, and if each of the various components of the organization is allowed to change at its own speed—that is, if each component of the organization can evolve independently of the others.</p>
<p class="normal">Moreover, as the complexity of<a id="_idIndexMarker414"/> a software system grows, several other issues make the unique data model of classical architectures hard to maintain:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Coherency issues</strong>: Arriving at a uniquely coherent view of data becomes more difficult since we can’t retain the complexity when we break these tasks into smaller, loosely coupled tasks.</li>
<li class="bulletList"><strong class="keyWord">Difficulties updating</strong>: As complexity grows, there is a need for frequent system changes, but it is quite difficult to update and maintain a unique global model. Moreover, bugs/errors that are introduced by changes in small subparts of the system may propagate to the whole organization through the uniquely shared model.</li>
<li class="bulletList"><strong class="keyWord">Team organization issues</strong>: System modeling must be split among several teams, and only loosely coupled tasks can be given to separate teams; if two tasks are strongly coupled, they need to be given to the same team.</li>
<li class="bulletList"><strong class="keyWord">Parallelism issues</strong>: As we will discuss in more detail in <em class="chapterRef">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, the need to move to a microservice-based architecture often makes the bottleneck of a unique database unacceptable.</li>
<li class="bulletList"><strong class="keyWord">Language issues</strong>: As the system grows, we need to communicate with more domain experts, each speaking a different language and each with a different view of that data model. Thus, we need to translate our unique model’s properties and operations to/from more languages to be able to communicate with them.</li>
</ul>
<p class="normal">As the system grows, it becomes more inefficient to deal with records with hundreds/thousands of fields that project in smaller views. Such inefficiencies originate in database engines that inefficiently handle big records with several fields (memory fragmentation, problems with too many related indices, and so on). However, the main inefficiencies take place in <strong class="keyWord">object-relational mappings</strong> (<strong class="keyWord">ORMs</strong>) and business layers that are forced to handle<a id="_idIndexMarker415"/> these big records in their update operations. In fact, while query operations usually require just a few fields that have been retrieved from the storage engine, updates and business processing involve the whole entity. ORMs are described in detail in <em class="chapterRef">Chapter 13</em>, <em class="italic">Interacting with Data in C# – Entity Framework Core</em>.</p>
<p class="normal">As the traffic in the data storage subsystem grows, we need read and update/write parallelism in all the data operations. As we will discover in <em class="chapterRef">Chapter 12</em>, <em class="italic">Choosing Your Data Storage in the Cloud</em>, while read parallelism is easily achieved with data replication, write parallelism requires sharding; that is, splitting database records among several distributed databases, and<a id="_idIndexMarker416"/> it is difficult to shard a uniquely monolithic and tightly connected data model.</p>
<p class="normal">These issues are the reason for DDD’s success in the last few years because they were characterized by more complex software systems that became the backbones of entire organizations. DDD’s basic principles will be discussed in detail in the next section.</p>
<h1 class="heading-1" id="_idParaDest-141">Understanding DDD</h1>
<p class="normal">According to DDD, we should not <a id="_idIndexMarker417"/>construct a unique domain model that projects into different views in each application subsystem. Instead, the whole application domain is split into smaller domains, each with its own data model. These separate domains are <a id="_idIndexMarker418"/>called <strong class="keyWord">Bounded Contexts</strong>. Each Bounded Context is characterized by the language used by the experts and used to name all the domain concepts and operations.</p>
<p class="normal">Thus, each Bounded Context defines a common language used by both the experts and the development team called a <strong class="keyWord">Ubiquitous Language</strong>. Translations are <a id="_idIndexMarker419"/>not needed anymore, and if the development team uses C# interfaces as bases for its code, the domain expert is able to understand and validate them since all the operations and properties are expressed in the same language that’s used by the expert.</p>
<p class="normal">Here, we’re getting rid of a cumbersome unique abstract model, but now we have several separate models that we need to relate somehow. DDD proposes that we handle all these separate models (that is, all the Bounded Contexts) as follows:</p>
<ul>
<li class="bulletList"><strong class="keyWord">We need to add Bounded Context boundaries whenever the meanings of the language terms change</strong>. For instance, in the WWTravelClub use case, order-payment and package-handling belong to different Bounded Contexts because they give a different meaning to the word <strong class="keyWord">customer</strong>.</li>
<li class="bulletList"><strong class="keyWord">We need to explicitly represent relations among Bounded Contexts</strong>. Different development teams may work on different Bounded Contexts, but each team must have a clear picture of the relationship between the Bounded Context it is working on and all the other models. For this reason, such relationships are represented in a unique document that’s shared with every team.</li>
<li class="bulletList"><strong class="keyWord">We need to keep all the Bounded Contexts aligned with CI</strong>.<strong class="keyWord"> </strong>Meetings are organized and simplified system prototypes are built in order to verify that all the Bounded Contexts are evolving coherently—that is, that all the Bounded Contexts can be integrated into the desired application behavior.</li>
</ul>
<p class="normal">The following diagram shows how<a id="_idIndexMarker420"/> the WWTravelClub example that we discussed in the previous section changes with the adoption of DDD:</p>
<figure class="mediaobject"><img alt="Diagram, venn diagram  Description automatically generated" src="img/B19820_07_02.png"/></figure>
<p class="packt_figref">Figure 7.2: Relationships between DDD-Bounded Contexts</p>
<p class="normal">There is a relationship between the Customer entities of each Bounded Context, while the Purchase entity of the package-handling Bounded Context is related to the Payments. Identifying entities that map to each other in the various Bounded Contexts is the first step of formally defining the interfaces that represent all the possible communications among the contexts.</p>
<p class="normal">For instance, in the previous diagram, since payments are made after purchases, we can deduce that the order-payment Bounded Context must have an operation to create a payment for a specific customer. In this domain, new customers are created if they don’t already exist.</p>
<p class="normal">The payment creation<a id="_idIndexMarker421"/> operation is triggered immediately after purchase. Since several more operations are triggered after an item is purchased, we can implement all the communication related to a purchase event with the Publisher/Subscriber pattern we explained in <em class="italic">Chapter 6</em>, <em class="italic">Design Patterns and .NET 8 Implementation</em>. In DDD, these are <a id="_idIndexMarker422"/>known as <strong class="keyWord">domain events</strong>. Using events to implement communications between Bounded Contexts is very common since it helps keep Bounded Contexts loosely coupled.</p>
<p class="normal">Once an instance of either an event or an operation that’s been defined in the Bounded Context’s interface crosses the context boundary, it is immediately translated into the Ubiquitous Language of the receiving context. It is important that this translation be performed before the input data starts interacting with the other domain entities to prevent the Ubiquitous Language of the receiving domain from becoming contaminated by extra-contextual terms. An inadequate translation is usually evidenced by the domain experts complaining about “strange words.”</p>
<p class="normal">Each Bounded Context implementation must contain a domain model completely expressed in terms of the Bounded Context Ubiquitous Language (class and interface names and property and method names), with no contamination from other Bounded Contexts’ Ubiquitous Languages, and without contamination from technical programming stuff. This is necessary to ensure good communication with domain experts and to ensure that domain rules are translated correctly into code so that they can be easily validated by domain experts.</p>
<p class="normal">When there is a strong mismatch between the communication language and the target Ubiquitous Language, an anti-corruption layer is added to the receiving Bounded Context boundary. The only purpose of this anti-corruption layer is to perform a language translation.</p>
<h2 class="heading-2" id="_idParaDest-142">Relationships among Bounded Contexts</h2>
<p class="normal">The document that contains a representation of all the Bounded Contexts, along with the Bounded Contexts’ mutual relationships <a id="_idIndexMarker423"/>and interface definitions, is called a <strong class="keyWord">context map</strong>. The relationships between contexts contain organizational constraints that specify the kind of cooperation required among the teams that are working on the different Bounded Contexts. Such<a id="_idIndexMarker424"/> relationships don’t constrain the Bounded Context interfaces but do affect the way they may evolve during the software CI/CD cycle. They represent patterns of team cooperation.</p>
<p class="normal">The most common patterns are as follows:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Partner</strong>: This is the original pattern suggested by Eric Evans. The idea is that the two teams have a mutual dependency on each other for delivery. In other words, they <a id="_idIndexMarker425"/>decide together the Bounded Context’s mutual communication specifications during the software development lifecycle.</li>
<li class="bulletList"><strong class="keyWord">Customer/supplier development teams</strong>: In this case, one team acts as a customer and another one acts as a supplier. In the preliminary stage, both teams define the interface<a id="_idIndexMarker426"/> of the customer side of the Bounded Context and some automated acceptance tests to validate it. After that, the supplier can work independently.
    <p class="normal">This pattern works when the customer’s Bounded Context is the only active part that invokes the interface methods exposed by the other Bounded Context. This is adequate for the interaction between the order-payment and the package-handling contexts, where order-payment acts as a supplier since its functions are subordinate to the needs of package-handling. When this pattern can be applied, it decouples both the implementation and the maintenance of the two Bounded Contexts completely.</p> </li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord">Conformist</strong>: This is similar to the customer/supplier pattern, but in this case, the customer side accepts an interface that’s been imposed by the supplier side with no preliminary<a id="_idIndexMarker427"/> negotiation stage. This pattern offers no advantages to the other patterns, but sometimes we are forced into the situation depicted by the pattern since either the supplier’s Bounded Context is implemented in a preexisting product that can’t be configured/modified too much, or because it is a legacy subsystem that we don’t want to modify.</li>
</ul>
<p class="normal">It is worth pointing out that the separation in Bounded Contexts is only effective if the resulting Bounded Contexts are loosely coupled; otherwise, the reduction of complexity that’s obtained by breaking a whole system into parts would be overwhelmed by the complexity of the coordination and communication processes.</p>
<p class="normal">However, if Bounded Contexts are defined with the language criterion—that is, Bounded Context boundaries are added whenever the Ubiquitous Language changes—this should actually be the case. In fact, different languages may arise as a result of a loose interaction between an organization’s subparts since the more each subpart has tight interactions inside of it and loose interactions with other subparts, the more each subpart ends up defining and using its own internal language, which differs from the language used by the other subparts.</p>
<p class="normal">Moreover, as all human organizations grow just by evolving into loosely coupled subparts, similarly, complex software systems may be implemented just as the cooperation of loosely coupled <a id="_idIndexMarker428"/>submodules: this is the only way humans are able to cope with complexity. From this, we can conclude that complex organizations/artificial systems can always be decomposed into loosely coupled subparts. We just need to understand <em class="italic">how</em>.</p>
<p class="normal">Beyond the basic principles we’ve mentioned so far, DDD provides a few basic primitives to describe each Bounded Context, as well as some implementation patterns. While Bounded Context primitives are an integral part of DDD, the patterns are simply useful heuristics we can use in our implementation, so their usage in some or all Bounded Contexts is not obligatory once we opt for DDD adoption.</p>
<p class="normal">In the next section, we will describe Bounded Context primitives, while the various patterns will be described in the remaining sections of the chapter.</p>
<h2 class="heading-2" id="_idParaDest-143">Entities</h2>
<p class="normal">DDD entities represent domain objects that have a well-defined identity, as well as all the operations that are defined on<a id="_idIndexMarker429"/> them. They don’t differ too much from the<a id="_idIndexMarker430"/> entities of other, more classical approaches.</p>
<p class="normal">The main difference is that DDD stresses the entities’ object-oriented nature, while other approaches use them mainly as <strong class="keyWord">records</strong> whose<a id="_idIndexMarker431"/> properties can be written/updated without too many constraints.</p>
<p class="normal">DDD, on the other hand, forces strong SOLID principles on them to ensure that only certain information is encapsulated inside of them and that only certain information is accessible from outside of them, to stipulate which operations are allowed on them, and to set which business-level validation criteria apply to them.</p>
<p class="normal">In other words, DDD entities are richer than the entities of record-based approaches.</p>
<p class="normal">In the record-based approach, operations that manipulate entities are defined outside of them in classes that represent business and/or domain operations. In DDD, these operations are moved into the entity definitions as their class methods. The reason for this is that this approach offers better modularity and keeps related chunks of software in the same place so that they <a id="_idIndexMarker432"/>can be maintained and tested easily.</p>
<p class="normal">More details on the difference between the record-based approach and the DDD approach will be given later on, in the <em class="italic">Repository pattern</em> subsection of this chapter.</p>
<p class="normal">For the same reason, business validation rules that are specific for each entity are moved inside of DDD entities. DDD entity validation rules are business-level rules, so they must not be confused with database integrity rules or user-input validation rules. They contribute to<a id="_idIndexMarker433"/> the way entities represent domain objects by encoding the constraints the represented objects must obey.</p>
<p class="normal">For instance, it might be obligatory to provide an entity property such as “Shipping Address” on a web page (user input validation rule), even though property is not obligatory in general (no corresponding business validation rule). In fact, the “Shipping Address” property becomes obligatory only if we need to ship something, so if the context of the web page is about shipping something, then “Shipping Address” must be obligatory as a user input in that specific web page but not as a general business rule.</p>
<p class="normal">User input validation will be discussed in more detail in <em class="italic">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>, which will show, in practice, how user input validation and business validation have different and complementary purposes. While business-level validation rules encode domain rules, input validation rules enforce the format of every single input (string length, correct email and URL formats, and so on), ensure that all the necessary input has been provided, enforce the execution of the chosen user machine interaction protocols, and provide fast and immediate feedback that drives the user to interact with the system.</p>
<p class="normal">It is worth pointing out that not all business validation rules can be encoded inside DDD entities. Business rules that are not specific to single DDD entities but involve the interaction of several entities must be encoded in the software module that handles and coordinates the interaction among entities. We will speak more about the software module that coordinates entity interactions later on in this chapter.</p>
<p class="normal">The subsection that follows<a id="_idIndexMarker434"/> gives more details on entity-level validation rules.</p>
<h3 class="heading-3" id="_idParaDest-144">Entity-level validation in .NET</h3>
<p class="normal">In .NET, business validation<a id="_idIndexMarker435"/> can be carried out with one of the following techniques:</p>
<ul>
<li class="bulletList">Calling the validation methods in all the class methods that modify the entity.</li>
<li class="bulletList">Hooking the validation methods to all the property setters.</li>
<li class="bulletList">Decorating the class and/or its properties with custom validation attributes and then invoking the <code class="inlineCode">TryValidateObject</code> static method of the <code class="inlineCode">System.ComponentModel.DataAnnotations.Validator</code> class on the entity each time it is modified. The .NET <code class="inlineCode">System.ComponentModel.DataAnnotations</code> namespace contains predefined validation attributes (see <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-8.0#built-in-attributes">https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-8.0#built-in-attributes</a>), but the developer can define also custom validation attributes by inheriting from the <code class="inlineCode">System.ComponentModel.DataAnnotations.ValidationAttribute</code> abstract class (see <a href="https://makolyte.com/aspnetcore-create-a-custom-model-validation-attribute/">https://makolyte.com/aspnetcore-create-a-custom-model-validation-attribute/</a>).</li>
</ul>
<div><p class="normal">More details on validation attributes will be given in <em class="chapterRef">Chapter 17</em>, <em class="italic">Presenting ASP.NET Core</em>.</p>
</div>
<p class="normal">Once detected, validation errors must be handled somehow; that is, the current operation must be aborted and the error must be reported to an appropriate error handler. The simplest way to handle validation errors is by throwing an exception. This way, both purposes are easily achieved and we can choose where to intercept and handle them. Unfortunately, as we discussed in the <em class="italic">Performance issues that need to be considered while programming in C#</em> section of <em class="italic">Chapter 2</em>, <em class="italic">Non-Functional Requirements</em>, exceptions imply big performance penalties and must be used to deal just with “exceptional circumstances” so, often, different options are considered. Handling errors in the normal flow of control would break modularity by spreading the code that’s needed to handle the error all over the stack of methods that caused the error, with a never-ending set of conditions all over that code. Therefore, more sophisticated options are needed.</p>
<p class="normal">A good alternative to exceptions is to notify errors to an error handler that is unique for each processing request. For instance, it can be implemented as a scoped service in the dependency injection engine. Being scoped, the same service instance is returned while each request is being processed so that the handler that controls the execution of the whole call stack can inspect possible errors when the flow of control returns to it, and can handle them <a id="_idIndexMarker436"/>appropriately. Unfortunately, this sophisticated technique can’t automatically abort the operation’s execution and return immediately to the most adequate controlling handler that is in the call stack.</p>
<p class="normal">This is why exceptions are often used for this scenario, notwithstanding their performance issues. The other option is the<a id="_idIndexMarker437"/> usage of a <strong class="keyWord">result object</strong> that informs the caller of the success of the operation in all method calls. However, result objects have their cons: they imply more coupling between the methods involved in the call stack, so during software maintenance, each change might require modifications in several methods.</p>
<h3 class="heading-3" id="_idParaDest-145">DDD entities in .NET</h3>
<p class="normal">Since DDD entities must have a well-defined identity, they must have properties that act as primary keys. It is common to<a id="_idIndexMarker438"/> override the <code class="inlineCode">Object.Equals</code> method of all the DDD entities in such a way that two objects are considered equal whenever they have the same primary keys. This is easily achieved by letting all the entities inherit from an abstract <code class="inlineCode">Entity</code> class, as shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">public abstract class Entity&lt;K&gt;: IEntity&lt;K&gt;
{
       
    public virtual K Id { get; protected set; }
    public bool IsTransient()
    {
        return Object.Equals(Id, default(K));
    }
    public override bool Equals(object obj)
    {
        return obj is Entity&lt;K&gt; entity &amp;&amp;
          Equals(entity);
    }
    public bool Equals(IEntity&lt;K&gt;? other)
    {
        if (other == null ||
            other.IsTransient() || this.IsTransient())
            return false;
        return Object.Equals(Id, other.Id);
    }
    int? _requestedHashCode;
    public override int GetHashCode()
    {
        if (!IsTransient())
        {
            if (!_requestedHashCode.HasValue)
                _requestedHashCode = HashCode.Combine(Id);
            return _requestedHashCode.Value;
        }
        else
return base.GetHashCode();
    }
    public static bool operator ==(Entity&lt;K&gt; left, Entity&lt;K&gt; right)
    {
        if (Object.Equals(left, null))
            return Object.Equals(right, null);
        return left.Equals(right);
    }
    public static bool operator !=(Entity&lt;K&gt; left, Entity&lt;K&gt; right)
    {
        return !(left == right);
    }
}
</code></pre>
<p class="normal">Note the following<a id="_idIndexMarker439"/> things in the code:</p>
<ul>
<li class="bulletList">It is worth implementing an <code class="inlineCode">IEntity&lt;K&gt;</code> interface that defines all the properties/methods of <code class="inlineCode">Entity&lt;K&gt;</code>. This interface is useful whenever we need to hide data classes behind interfaces.</li>
<li class="bulletList">The <code class="inlineCode">IsTransient</code> predicate returns <code class="inlineCode">true</code> whenever the entity has been recently created and hasn’t been recorded in the permanent storage, so its primary key is still undefined.</li>
<li class="bulletList">In .NET, it is good practice that, whenever you override the <code class="inlineCode">Object.Equals</code> method of a class, you also override its <code class="inlineCode">Object.GetHashCode</code> method so that class instances can be efficiently stored in data structures such as dictionaries and sets. That’s why the <code class="inlineCode">Entity</code> class overrides it.</li>
<li class="bulletList">It is worth pointing out that once we’ve redefined the <code class="inlineCode">Object.Equals</code> method in the <code class="inlineCode">Entity</code> class, we can also override the <code class="inlineCode">==</code> and <code class="inlineCode">!=</code> operators.</li>
</ul>
<p class="normal">Entities are not the only data<a id="_idIndexMarker440"/> ingredient of DDD. Domain modeling also requires data with no unique identities. That’s why value objects were conceived.</p>
<h2 class="heading-2" id="_idParaDest-146">Value objects</h2>
<p class="normal">Value objects, in contrast to entities, represent complex types that can’t be encoded with numbers or strings. Therefore, they have no identity and no principal keys. They have no operations defined on them and are immutable; that is, once they’ve been created, all their fields <a id="_idIndexMarker441"/>can be read but cannot be modified. For this reason, they <a id="_idIndexMarker442"/>are usually encoded with classes whose properties have protected/private setters.</p>
<p class="normal">Two value objects are considered equal when all their independent properties are equal. Some properties are not independent since they just show data that’s been encoded by other properties in a different way, as is the case for the ticks of <code class="inlineCode">DateTime</code> and its representation of the date and time fields.</p>
<p class="normal">Value objects are easily implemented with C# 12 <code class="inlineCode">record</code> types since all <code class="inlineCode">record</code> types automatically override the <code class="inlineCode">Equals</code> method so that it performs a property-by-property comparison. Record types can also be made immutable by adequately defining their properties; once immutable objects are initialized, the only way to change their values is to create a new instance. Here is an example of how to modify a <code class="inlineCode">record</code>:</p>
<pre class="programlisting code"><code class="hljs-code">var modifiedAddress = myAddress with {Street = "new street"}
</code></pre>
<p class="normal">Here is an example of how to define a <code class="inlineCode">record</code>:</p>
<pre class="programlisting code"><code class="hljs-code">public record Address
{
   public string Country {get; init;}
   public string Town {get; init;}
   public string Street {get; init;}
}
</code></pre>
<p class="normal">The <code class="inlineCode">init</code> keyword is what makes <code class="inlineCode">record</code> type properties immutable since it means they can only be initialized.</p>
<p class="normal">If we pass all the properties in the constructor instead of using initializers, the preceding definition can be simplified as follows:</p>
<pre class="programlisting code"><code class="hljs-code">public record Address(string Country, string Town, string Street) ;
</code></pre>
<p class="normal">Typical value objects include costs represented as a number and a currency symbol, locations represented as<a id="_idIndexMarker443"/> longitude and latitude, addresses, and contact information.</p>
<div><p class="normal">The way both entities and value objects typically interact with data storage in .NET applications is explained in <em class="chapterRef">Chapter 13</em>, <em class="italic">Interacting with Data in C# – Entity Framework Core</em>.</p>
</div>
<h2 class="heading-2" id="_idParaDest-147">Aggregates</h2>
<p class="normal">So far, we have talked about entities as the <strong class="keyWord">units</strong> that are processed by a DDD-based business layer. However, several entities can be manipulated and made into single entities. An example of this is a<a id="_idIndexMarker444"/> purchase order and all of its items. In fact, it makes <a id="_idIndexMarker445"/>absolutely no sense to process a single order item independently of the order it belongs to. This happens because order items are actually subparts of an order, not independent entities.</p>
<p class="normal">There is no transaction that may affect a single order item without it affecting the order that the item is in. Imagine that two different people in the same company are trying to increase the total quantity of cement, but one increases the quantity of type-1 cement (item 1) while the other increases the quantity of type-2 cement (item 2). If each item is processed as an independent entity, both quantities will be increased, which could cause an incoherent purchase order since the total quantity of cement would be increased twice.</p>
<p class="normal">On the other hand, if the whole order, along with all its order items, is loaded and saved with every single transaction by both people, one of the two will overwrite the changes of the other one, so whoever makes the final change will have their requirements set.</p>
<p class="normal">A purchase order, along with all its subparts (its order items), is called an <strong class="keyWord">aggregate</strong>, while the order entity is <a id="_idIndexMarker446"/>called the <strong class="keyWord">root</strong> of the aggregate. Aggregates always have roots since they are hierarchies of entities connected<a id="_idIndexMarker447"/> by <strong class="keyWord">subpart</strong> relationships.</p>
<p class="normal">Since each aggregate represents a single complex entity, all the operations on it must be exposed by a unique interface. Therefore, the aggregate root usually represents the whole aggregate, and all the <a id="_idIndexMarker448"/>operations on the aggregate are defined as methods of the root entity.</p>
<p class="normal">When the aggregate pattern is used, the units of information that are transferred between the business layer and the data layer are called aggregates, queries, and query results. Thus, aggregates replace single entities.</p>
<p class="normal">In a few words, aggregates <a id="_idIndexMarker449"/>are in-memory representations of storage information that need to be dealt with as a single object. Being an in-memory representation based on an object-oriented paradigm, they take full advantage of all the benefits of object-oriented programming.</p>
<h2 class="heading-2" id="_idParaDest-148">Domain events</h2>
<p class="normal">Domain events are the main <a id="_idIndexMarker450"/>communication ingredient of DDD. While DDD doesn’t impose constraints on the way communication among bounded contexts is achieved, a communication based on the publisher/subscriber pattern described in <em class="italic">Chapter 6</em>, <em class="italic">Design Patterns and .NET 8 Implementation</em>, maximizes independence among bounded contexts. Each bounded context publishes all information that might interest other bounded contexts, and interested bounded contexts subscribe. This way, the publisher doesn’t need to know about each<a id="_idIndexMarker451"/> subscriber and how it works, but just publish the result of its job in a general format. More implementation details will be given in the<em class="italic"> Command handlers and domain events</em> subsection of this chapter.</p>
<h1 class="heading-1" id="_idParaDest-149">Common DDD patterns and architectures</h1>
<p class="normal">In this and the sections that follow, we will describe some of the patterns and architectures that are commonly used with DDD. Some of them can be adopted in all projects, while others can only be<a id="_idIndexMarker452"/> used for certain Bounded Contexts.</p>
<p class="normal">Before we begin, we should note that, from a conceptual point of view, the functionality of each application can be classified into three groups:</p>
<ul>
<li class="bulletList">Handling the interaction with the user</li>
<li class="bulletList">Performing business-related processing</li>
<li class="bulletList">Interacting with the storage engine</li>
</ul>
<p class="normal">Each of the above groups uses a different language and different technologies. The first group uses the language of the target users and user interface technologies, the second group uses the language of the domain expert and is focused on application domain modeling, and the third group uses both language and technologies related to databases.</p>
<p class="normal">Each of the architectures we will look at organize these functionalities in different ways. We will start with the classic layers architecture since it is simpler to understand, and then we will describe the more sophisticated onion architecture.</p>
<h2 class="heading-2" id="_idParaDest-150">Classic layers architecture</h2>
<p class="normal">The classic layers architecture organizes the<a id="_idIndexMarker453"/> three groups of functionalities as three loosely coupled sets of classes/interfaces called <strong class="keyWord">layers</strong>, put one <a id="_idIndexMarker454"/>after the other:</p>
<ul>
<li class="bulletList">The first layer in the sequence<a id="_idIndexMarker455"/> is the one that takes care of user interaction and is called the <strong class="keyWord">presentation layer</strong>.</li>
<li class="bulletList">The second layer in the<a id="_idIndexMarker456"/> sequence is the one that performs business-related processing and is called the <strong class="keyWord">business layer</strong>.</li>
<li class="bulletList">The third layer is the one dedicated to <a id="_idIndexMarker457"/>database interaction and is called the <strong class="keyWord">data layer</strong>.</li>
</ul>
<p class="normal">Each layer can communicate directly just with the layer that precedes it and the layer that follows it, as shown in the figure below:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_07_03.png"/></figure>
<p class="packt_figref">Figure 7.3: Classic layers architecture</p>
<p class="normal">Each layer call can pass data to methods of public objects in the layer that follows it and receive the resulting data back.</p>
<p class="normal">The presentation layer handles not only graphics but also the whole user-machine interaction protocol. During<a id="_idIndexMarker458"/> its interaction protocol, the presentation layer uses business layer methods either to present data to the user or to update the application state.</p>
<p class="normal">In turn, the business layer uses data layer methods to retrieve all data it needs to prepare the user answer from the data storage and to update the application state.</p>
<p class="normal">Each layer offers a well-defined interface to the layer that precedes it while hiding all implementation details.</p>
<p class="normal">The layer architecture promotes modularity since each layer doesn’t depend on how the layers that precede it are implemented, and avoids the possibility of the language used by each layer contaminating the language used by the others.</p>
<p class="normal">However, data exchanged in the classic layer architecture are record-type objects with no methods that encode any processing logic, since the whole processing logic is contained in the objects and methods that compose the three layers.</p>
<p class="normal">Since record-like objects used by the classic layers architecture are very different from DDD domain objects, which are rich objects that encode most of the business logic in their methods, the classic<a id="_idIndexMarker459"/> layers architecture has a poor match with DDD. That’s why an improvement on the classic layers architecture, called the onion architecture, has been proposed.</p>
<h2 class="heading-2" id="_idParaDest-151">Onion architecture</h2>
<p class="normal">In the onion architecture, layers<a id="_idIndexMarker460"/> obey different rules and are defined in a slightly different way. There is:</p>
<ul>
<li class="bulletList">An outermost layer that takes care of all interactions with the application environment—that is, user interface, test software, and interaction with operating system and data storage</li>
<li class="bulletList">An application layer</li>
<li class="bulletList">A domain layer</li>
</ul>
<p class="normal">Here, the domain layer is an abstraction of the classical data layer based on the Ubiquitous Language. It is where DDD entities and value objects are defined, together with abstractions of the operations that retrieve and save them. For better modularity, all or some domain layer classes may be made internal and hidden behind public interfaces.</p>
<p class="normal">The application layer, instead, defines operations that use the domain layer public interface (public interfaces and public classes) to get DDD entities and value objects and manipulate them to implement the application business logic. The DDD application layer is called <strong class="keyWord">application services</strong> since it <a id="_idIndexMarker461"/>exposes its functionalities through an API that is completely independent of the outermost layers. This way, for instance, any user interface layer and a test suite both call exactly the same methods to interact with the application logic.</p>
<p class="normal">The outermost layer contains the user interface, the functional test suites (if any), and the application interface with the infrastructure that hosts the application.</p>
<p class="normal">The infrastructure represents the environment in which the application runs and includes the operating system, any devices, filesystem services, cloud services, and databases. The infrastructure interface is placed on the outermost level to ensure that no other onion layer depends on it. This maximizes both usability and modifiability.</p>
<p class="normal">The infrastructure layer contains all the drivers needed to adapt the application to its environment. Infrastructure resources communicate with the application through these drivers, and, in turn, drivers expose the infrastructure resources to all application layers through interfaces that are <a id="_idIndexMarker462"/>associated with the drivers implementing them in the dependency injection engine. This way, adapting the application to a different environment just requires changing the drivers.</p>
<p class="normal">Here’s a sketch of the onion architecture:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_07_04.png"/></figure>
<p class="packt_figref">Figure 7.4: Onion architecture</p>
<p class="normal">Each ring is a layer. Inward from the outermost<a id="_idIndexMarker463"/> layer are the <strong class="keyWord">application services</strong>, and inward from the application <a id="_idIndexMarker464"/>services we have the <strong class="keyWord">domain layer</strong>, which contains the representation of the entities involved in the Bounded Context knowledge.</p>
<p class="normal">Both the application services<a id="_idIndexMarker465"/> and the domain layer can be split into sublayers, and all layers/sublayers must conform to the following rule: <em class="italic">Each layer may depend only on the inner layers.</em></p>
<p class="normal">For instance, the domain layer <a id="_idIndexMarker466"/>may be split into <strong class="keyWord">Domain Model</strong> and <strong class="keyWord">Domain Services</strong>, where Domain Model<em class="italic"> </em>is below Domain Services. The <em class="italic">Domain Model</em> layer <a id="_idIndexMarker467"/>contains the classes and interfaces that represent all domain objects, while the <em class="italic">Domain Services</em> layer contains the so-called repositories that are explained later on in this chapter in the<em class="italic"> Repository pattern</em> and<em class="italic"> Unit of work pattern </em>sections.</p>
<p class="normal">As we will see later on in this chapter, it is common to interact with the domain layer through interfaces that are defined in a separate library and implemented in the domain layer. Thus, the domain layer must have a reference to the library containing all domain layer interfaces since it must implement those interfaces, while the application layer is where each domain layer interface is connected with its implementation through a record of the application layer dependency injection engine. More specifically, the only data layer objects referenced by the application layer are these interface implementations that are only referenced in the dependency injection engine.</p>
<div><p class="normal">Outer layers that implement interfaces defined in the next inner layer are a common pattern used in the onion architecture.</p>
</div>
<p class="normal">Each application layer operation requires the interfaces it needs from the dependency engine, uses them to get DDD entities and value objects, manipulates them, and possibly saves them through the same interfaces.</p>
<p class="normal">Here is a diagram that shows the relationships among the three layers discussed in this section:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_07_05.png"/></figure>
<p class="packt_figref">Figure 7.5: Relationships among the layers</p>
<p class="normal">Thus, the domain layer<a id="_idIndexMarker468"/> contains the representation of the domain objects, the methods to use on them, validation constraints, and the domain layer’s relationship with various entities. To increase modularity and decoupling, communication among entities is usually encoded with events—that is, with the <strong class="keyWord">Publisher/Subscriber pattern</strong>. This means entity updates can trigger events that have been hooked to business operations, and these <a id="_idIndexMarker469"/>events act on other entities.</p>
<p class="normal">This layered architecture allows us to change the whole data layer without affecting the domain layer, which only depends on the domain specifications and language and doesn’t depend on the technical details of how the data is handled.</p>
<p class="normal">The application layer contains the definitions of all the operations that may potentially affect several entities and the definitions of all the queries that are needed by the applications. Both business operations and queries use the interfaces defined in the domain layer to interact with the data layer.</p>
<p class="normal">However, while business operations manipulate and exchange entities with these interfaces, queries send query specifications and <a id="_idIndexMarker470"/>receive generic <strong class="keyWord">Data Transfer Objects</strong> (<strong class="keyWord">DTOs</strong>) from them. In fact, the<a id="_idIndexMarker471"/> purpose of queries is just to show data to the user, not to act on them; accordingly, query operations don’t need whole entities with all their methods, properties, and validation rules, but just property tuples.</p>
<p class="normal">Business operations are invoked either by other layers (typically the presentation layer) or by communication operations.</p>
<p class="normal">Summing up, the application layer operates on the interfaces defined in the domain layer instead of interacting directly with their data layer implementations, which means that the application layer is decoupled from the data layer. More specifically, data layer objects are only mentioned in the dependency injection engine definitions. All the other application layer components refer to the interfaces that are defined in the domain layers, and the dependency injection engine injects the appropriate implementations.</p>
<p class="normal">The application layer communicates with other application components through one or more of the following patterns:</p>
<ul>
<li class="bulletList"><strong class="bold-italic" style="font-style: italic;">It exposes business operations and queries on a communication endpoint</strong>, such as an HTTP Web API (see <em class="chapterRef">Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET</em>). In this case, the presentation layer may connect to this endpoint or to other endpoints that, in turn, take information from this and other endpoints. Application components that collect information from several endpoints and expose them in a<a id="_idIndexMarker472"/> unique endpoint are called <strong class="keyWord">gateways</strong>. They may be either custom or general-purpose, such as Ocelot.</li>
<li class="bulletList"><strong class="bold-italic" style="font-style: italic;">It is referenced as a library by an application that directly implements the presentation layer</strong>, such as an ASP.NET Core MVC Web application.</li>
<li class="bulletList"><strong class="bold-italic" style="font-style: italic;">It doesn’t expose all the information through endpoints and communicates some of the data it processes/creates to other application components that, in turn, expose endpoints</strong>. Such communication is often implemented with the Publisher/Subscriber pattern to increase modularity.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-152">Repository pattern</h2>
<p class="normal">The repository pattern is an entity-centric <a id="_idIndexMarker473"/>approach to the definition of the domain layer interfaces: each entity—or better, each aggregate—has its own repository interface that defines how to retrieve and create it, and<a id="_idIndexMarker474"/> defines all queries that involve entities in the aggregate. The implementation of each repository<a id="_idIndexMarker475"/> interface is called a repository. Repositories are associated with aggregates instead of entities, since, as discussed in the <em class="italic">Aggregates</em> subsection, aggregates represent the minimum granularity that makes sense to consider in each data operation.</p>
<p class="normal">With the repository pattern, each operation has an easy-to-find place where it must be defined: the interface of the aggregate the operation works on, or, in the case of a query, the aggregate that contains the root entity of the query.</p>
<p class="normal">The repository pattern was initially conceived for the classical layer architecture and its record-like objects. Then, it was adapted to work with rich DDD entities/aggregates.</p>
<p class="normal">Classical repositories contain all methods needed to handle record-like objects—that is, modification, creation and delete methods since record-like objects have no modification methods. DDD-adapted repositories, instead, only contain create and delete methods since all methods that modify each aggregate are defined as aggregate methods. Moreover, applications based on classic repositories and record-like objects do not have a unique record-like object that represents each domain aggregate, but there are several record-like objects, each containing a different view of the overall domain aggregate. Therefore, classic repositories have modification methods for several different record-like objects.</p>
<p class="normal">Both classic and DDD-adapted repositories have methods to retrieve data to be returned to the user. In both cases, this data is represented by record-like objects, since aggregates are built only when domain entities must be modified or created.</p>
<p class="normal">The diagram below summarizes the differences between classical and DDD-adapted repository patterns.</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_07_06.png"/></figure>
<p class="packt_figref">Figure 7.6: Classical and DDD-adapted repository pattern</p>
<h3 class="heading-3" id="_idParaDest-153">Unit of work pattern</h3>
<p class="normal">While it is preferable for transactions to be confined within the boundary of a single aggregate design, sometimes application<a id="_idIndexMarker476"/> layer transactions might span <a id="_idIndexMarker477"/>several aggregates and, accordingly, might use several different repository interfaces.</p>
<p class="normal">For instance, buying a travel involves the simultaneous modifications of the following entities:</p>
<ul>
<li class="bulletList">Hotel/travel available places</li>
<li class="bulletList">Customer shopping basket</li>
</ul>
<p class="normal">Both operations must be accomplished in a single transaction since either they are both successful or they must both fail. Therefore, we need a way to execute operations on several entities/aggregates in a single transaction, while keeping the methods/code of the involved entities decoupled, according to object-oriented programming best practices.</p>
<p class="normal">The <strong class="keyWord">Unit of Work</strong> pattern is a solution that maintains the independence of the domain layer from the underlying domain layer implementation. It states that each repository interface must also contain<a id="_idIndexMarker478"/> a reference to a Unit of Work interface that represents the identity of the current transaction. This means that several repositories <a id="_idIndexMarker479"/>with the same Unit of Work reference belong to the same transaction.</p>
<p class="normal">The Unit of Work pattern can be used with both aggregates and record-like entities.</p>
<p class="normal">Both the repository and the Unit of Work patterns can be implemented by defining some seed interfaces:</p>
<pre class="programlisting code"><code class="hljs-code">public interface IUnitOfWork
{
    Task&lt;bool&gt; SaveEntitiesAsync();
    Task StartAsync();
    Task CommitAsync();
    Task RollbackAsync();
}
public interface IRepository&lt;T&gt;: IRepository
{
   IUnitOfWork UnitOfWork { get; }
}
</code></pre>
<p class="normal">All repository interfaces inherit from <code class="inlineCode">IRepository&lt;T&gt;</code> and bind <code class="inlineCode">T</code> to the aggregate root or entity they are associated with, while Unit of Work simply implements <code class="inlineCode">IUnitOfWork</code>. When <code class="inlineCode">SaveEntitiesAsync()</code> is called, all pending modifications, deletions, and creations done on aggregates or record-like objects are saved in a single transaction in the storage engine. If a wider transaction that starts when some data is retrieved from the storage engine is needed, it must be started and committed/aborted by the application layer handler, which takes care of the whole operation with the help of the <code class="inlineCode">IUnitOfWork</code> <code class="inlineCode">StartAsync</code>, <code class="inlineCode">CommitAsync</code>, and <code class="inlineCode">RollbackAsync</code> methods. <code class="inlineCode">IRepository&lt;T&gt;</code> inherits from an empty <code class="inlineCode">IRepository</code> interface <a id="_idIndexMarker480"/>to help automatic<a id="_idIndexMarker481"/> repository discovery.</p>
<div><p class="normal">The GitHub repository associated with this book contains a <code class="inlineCode">RepositoryExtensions</code> class whose <code class="inlineCode">AddAllRepositories</code> <code class="inlineCode">IServiceCollection</code> extension method automatically discovers all the repository implementations contained in an assembly and adds them to the dependency injection engine.</p>
</div>
<h3 class="heading-3" id="_idParaDest-154">Classic repository pattern versus DDD aggregates</h3>
<p class="normal">The DDD patterns discussed so far, such as aggregates and DDD-adapted repositories, ensure modularity and modifiability, and, since whole domain aggregates are loaded in memory, they also prevent various kinds<a id="_idIndexMarker482"/> of bugs due to wrong partial updates. However, each addition of new functionality is cumbersome since it usually<a id="_idIndexMarker483"/> involves a complex modeling activity, the reengineering or creation of whole aggregates, and the definition of several classes.</p>
<p class="normal">On the one hand, record-like objects are easier to define and we may define different classes for different usages. So, adding a new functionality simply requires the definition of an independent repository method, and possibly the definition of a new record-like class.</p>
<p class="normal">Suppose we need just to maintain travel descriptions and features. It is a very simple domain, and we need just to perform CRUD operations—that is, creating and deleting travels and modifying their features. In this case, there is no advantage in loading the whole aggregates in memory and performing all operations as methods of a unique entity class.</p>
<p class="normal">On the other hand, with the classical repository pattern, we can load just the features of the travel we would like to modify, say a marketing-optimized description in some web pages, price in other pages where the user is an administrator with the power of deciding on prices, and so on. This way each operation uses a different object that is specific and optimized for that operation.</p>
<p class="normal">Suppose now we are designing a complex resource allocation software for an industrial application. All properties of each entity are constrained by complex business rules, and also several entities are constrained by several complex business rules. Therefore, a partial update of a few properties has consequences that propagate to the whole entity and to other connected entities.</p>
<p class="normal">In this case, each classical repository method would be forced to take into account all possible consequences of each property change, resulting in complex spaghetti code and in the recoding of the same<a id="_idIndexMarker484"/> operations several times in different repository methods.</p>
<p class="normal">In this case, a DDD approach <a id="_idIndexMarker485"/>performs much better. We load in memory the full aggregates involved and let their methods handle the business rule complexity with the help of object-oriented best practices. It is enough that each aggregate encodes the behavior of the real word object it represents, with no need to care about consequences on other entities.</p>
<p class="normal">Summing up, when a Bounded Context is quite simple, meaning a few entities with a few interactions among them and a few different update operations, there is no doubt that the classic repository pattern is more convenient. On the other hand, when there are many entities, or complex entities, and many different update operations are added, repositories turn into spaghetti code with several partially overlapping methods, code duplication, and no easy-to-understand interaction rules.</p>
<p class="normal">A full example showing the DDD-adapted repository pattern is given in the <em class="italic">A frontend microservice</em> section of <em class="italic">Chapter 21, Case Study</em>, while a full example showing the classical repository pattern is given in the <em class="italic">Using client technologies </em>section of the same chapter.</p>
<p class="normal">Moreover, as already pointed out, partial updates performed by several record-like projections of domain aggregates may cause bugs due to simultaneous modifications performed by different users. </p>
<p class="normal">Therefore, when the probability of similar bugs becomes high because of complex update patterns, it is very dangerous to use the classic repository pattern.</p>
<p class="normal">Thus, again, complexity is the main factor that drives us to the usage of DDD patterns. Moreover, the need to centralize the triggering of domain events used to synchronize Bounded Context data stores (review the previous <em class="italic">Understanding domain-driven design</em> section) forces the loading of whole aggregates in memory, and the usage of DDD patterns. Therefore, when a Bounded Context needs to trigger several domain events in complex circumstances, we can’t use the simpler classic repository pattern.</p>
<p class="normal">Now that we’ve discussed <a id="_idIndexMarker486"/>the basic patterns of DDD, we can discuss <a id="_idIndexMarker487"/>some more advanced DDD patterns. In the next section, we will introduce the CQRS pattern.</p>
<h2 class="heading-2" id="_idParaDest-155">Command Query Responsibility Segregation (CQRS) pattern</h2>
<p class="normal">In its general form, the usage of this pattern is quite easy: <em class="italic">use different structures to store/update and query data</em>. Here, the requirements regarding how to store and update data differ from the requirements of queries. This means that both the domain layer and application services of <a id="_idIndexMarker488"/>queries and store/update operations must be designed in completely different ways.</p>
<p class="normal">In the case of DDD, the unit of storage is the <a id="_idIndexMarker489"/>aggregate, so additions, deletions, and updates involve aggregates. On the other hand, differently from storages/updates, queries don’t perform business operations but involve transformations of properties that have been taken from several aggregates (projections, sums, averages, and so on).</p>
<p class="normal">Therefore, while updates require entities enriched with business logic and constraints (methods, validation rules, encapsulated information, and so on), query results just need sets of property/value pairs, so DTOs with only public properties and no methods work well.</p>
<p class="normal">In its common form, the pattern can be depicted as follows:</p>
<figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="img/B19820_07_07.png"/></figure>
<p class="packt_figref">Figure 7.7: Command and query processing</p>
<p class="normal">Where:</p>
<ul>
<li class="bulletList">The middle boxes (Handlers and Repository interfaces) represent operations.</li>
<li class="bulletList">The leftmost and rightmost boxes represent data.</li>
<li class="bulletList">Arrows simply represent the direction of data.</li>
</ul>
<p class="normal">The main takeaway from this is that the extraction of query results doesn’t need to pass through the construction of entities and aggregates, but the fields shown in the query must be extracted from the storage<a id="_idIndexMarker490"/> engine and projected into ad hoc DTOs.</p>
<p class="normal">However, in more complex situations, CQRS may be implemented in a stronger form. Namely, we can use different Bounded Contexts to store preprocessed query results.</p>
<p class="normal">In fact, the other option would be<a id="_idIndexMarker491"/> an aggregator microservice that queries all the necessary microservices in order to assemble each query result. However, recursive calls to other microservices to build an answer may result in unacceptable response times. Moreover, factoring out some preprocessing ensures better usage of the available resources.</p>
<p class="normal">This pattern is implemented as follows:</p>
<ul>
<li class="bulletList">Query handling is delegated to separated and specialized components.</li>
<li class="bulletList">Each query-handling component uses a database table for each query it must handle. There, it stores all fields to be returned by the query. This means that queries are not computed at each request, but precomputed and stored in specific database tables. Clearly, queries with child collections need additional tables, one for each child collection.</li>
<li class="bulletList">All components that process updates forward all changes to the interested query-handling components. Records are versioned so the query-handling components that receive the changes can apply them in the right order to their query-handling tables. In fact, since communication is asynchronous to improve performance, changes are not guaranteed to be received in the same order they were sent.</li>
<li class="bulletList">Changes received by each query-handling microservice are cached while they wait for the changes to be applied. Whenever a change has a version number that immediately follows the last change applied, it is applied to the right query-handling table.</li>
</ul>
<p class="normal">It is worth noticing that the software “components” we mentioned above run as separate processes on possibly different machines, and are called microservices. They will be discussed in detail in <em class="chapterRef">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>.</p>
<p class="normal">The usage of this stronger form of the<a id="_idIndexMarker492"/> CQRS pattern transforms typical local database transactions into complex time-consuming distributed transactions since a failure in a single query preprocessor microservice should invalidate the whole transaction. As we will discuss in <em class="chapterRef">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, implementing distributed transactions is usually unacceptable for performance reasons and sometimes is not supported at all, so the common solution is to renounce the idea of a database that is immediately consistent overall and to accept that the overall database will eventually be consistent after each update. </p>
<p class="normal">Transient failures can be solved with retry policies, which we will discuss in <em class="italic">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, while permanent failures are handled by performing corrective actions on the already committed local transactions instead of pretending to<a id="_idIndexMarker493"/> implement an overall globally distributed transaction.</p>
<p class="normal">At this point, you may be asking the following question:</p>
<p class="normal"><em class="italic">“Why do we need to keep the original data once we have all the preprocessed query results? We will never use it to answer queries!”</em></p>
<p class="normal">Some of the answers to this<a id="_idIndexMarker494"/> question are as follows:</p>
<ul>
<li class="bulletList">They are the source of truth that we may need to recover from failures.</li>
<li class="bulletList">We need them to compute new preprocessed results when we add new queries.</li>
<li class="bulletList">We need them to process new updates. In fact, processing updates usually requires that some of the data is retrieved from the database, possibly shown to the user, and then modified.</li>
</ul>
<p class="normal">For instance, to modify an item in an existing purchase order, we need the whole order so that we can show it to the user and compute the changes so that we can forward it to other microservices. Moreover, whenever we modify or add data to the storage engine, we must verify the coherence of the overall database (unique key constraints, foreign key constraints, and so on).</p>
<p class="normal">The next subsection is dedicated to an extreme implementation of the CQRS pattern.</p>
<h2 class="heading-2" id="_idParaDest-156">Event sourcing</h2>
<p class="normal">Event sourcing is a more advanced implementation of the stronger form of CQRS. It is useful when the original Bounded <a id="_idIndexMarker495"/>Context is a <strong class="keyWord">source of truth</strong>—that is, for<a id="_idIndexMarker496"/> recovering from failures and for software maintenance. In this case, instead of updating data, we simply add events that describe the operation that <a id="_idIndexMarker497"/>was performed, such as <em class="italic">deleted record Id 15</em>, <em class="italic">changed the name to John in Id 21</em>, and so on. These events are immediately sent to all the dependent Bounded Contexts, and in the case of failures and/or the addition of new queries, all we have to do is reprocess some of them. For performance reasons, together with the events representing all changes, the current state is also maintained; otherwise, each time it is needed, it will need to be recomputed, replaying all events. Moreover, usually, the full state is cached after, say, every <em class="italic">N</em> changes. This way, if there is a crash or any kind of failure, only a few events must be replayed.</p>
<p class="normal">Replaying events can’t cause problems if events are <strong class="keyWord">idempotent</strong>—that is, if processing the same event several times has the same effect as processing it once.</p>
<p class="normal">As we will discuss in <em class="chapterRef">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, idempotency is a standard requirement for microservices that communicate through events.</p>
<p class="normal">In the next section, we will describe <a id="_idIndexMarker498"/>a common pattern that’s used for handling operations that span several aggregates and several Bounded Contexts.</p>
<h2 class="heading-2" id="_idParaDest-157">Command handlers and aggregate events</h2>
<p class="normal">According to the Command pattern, each application domain operation is handled by a so-called command handler. Since each command handler encodes a single application domain operation, all of its actions must <a id="_idIndexMarker499"/>take place in the same transaction because the operation must succeed or fail as<a id="_idIndexMarker500"/> a whole. Command handlers perform their job by calling aggregates and repository methods. However, some actions might be triggered by state changes inside aggregates, so they can’t be called by command handlers but must rely on some form of direct aggregate-to-aggregate communication.</p>
<p class="normal">To keep aggregates separated, usually, communication among aggregates and also with other Bounded Contexts is done through events. We already discussed domain events used to communicate with other bounded contexts in the <em class="italic">Domain events</em> subsection. However, direct communication among aggregates can also take advantage of the publisher/subscriber pattern to keep the code more modular and easy to modify. It is good practice to store all the events when they are triggered during the processing of each aggregate, instead of executing<a id="_idIndexMarker501"/> them immediately, in order to prevent event execution from interfering <a id="_idIndexMarker502"/>with the ongoing aggregate processing. This is easily achieved by adding the following code to the abstract <code class="inlineCode">Entity</code> class defined in the <em class="italic">Entities</em> subsection of this chapter, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">public List&lt;IEventNotification&gt; DomainEvents { get; private set; }
public void AddDomainEvent(IEventNotification evt)
{
    DomainEvents ??= new List&lt;IEventNotification&gt;();
    DomainEvents.Add(evt);
}
public void RemoveDomainEvent(IEventNotification evt)
{
    DomainEvents?.Remove(evt);
}
</code></pre>
<p class="normal">Here, <code class="inlineCode">IEventNotification</code> is an empty interface that’s used to mark classes as events.</p>
<p class="normal">Event processing is usually performed immediately before changes are stored in the storage engine. Accordingly, a good place to perform event processing is immediately before the command handler calls the <code class="inlineCode">SaveEntitiesAsync()</code> method of each <code class="inlineCode">IUnitOfWork</code> implementation (see the <em class="italic">Repository pattern </em>subsection). Similarly, if event handlers can create other events, they must process them after they finish processing all their aggregates.</p>
<p class="normal">Subscriptions to an event, <code class="inlineCode">T</code>, can be provided as an implementation of the <code class="inlineCode">IEventHandler&lt;T&gt;</code> interface:</p>
<pre class="programlisting code"><code class="hljs-code">public interface IEventHandler&lt;T&gt;: IEventHandler
where T: IEventNotification
{
    Task HandleAsync(T ev);
}
</code></pre>
<p class="normal">Analogously, the command pattern is implemented with a <code class="inlineCode">command</code> object, which contains all the input data of the application domain operation, while the code that implements the actual operation can be provided through a command handler that is an implementation of an <code class="inlineCode">ICommandHandler&lt;T&gt;</code> interface:</p>
<pre class="programlisting code"><code class="hljs-code">public interface ICommandHandler&lt;T&gt;: ICommandHandler
where T: ICommand
{
    Task HandleAsync(T command);
}
</code></pre>
<p class="normal">Here, <code class="inlineCode">ICommand</code> is an empty interface that’s used to mark classes as commands. <code class="inlineCode">ICommandHandler&lt;T&gt;</code> and <code class="inlineCode">IEventHandler&lt;T&gt;</code> are examples of the <strong class="keyWord">Command pattern</strong> we described in <em class="chapterRef">Chapter 6</em>, <em class="italic">Design Patterns and .NET 8 Implementation</em>.</p>
<p class="normal">Each <code class="inlineCode">ICommandHandler&lt;T&gt;</code> can be registered in the dependency injection engine so that classes that need to execute a command, <code class="inlineCode">T</code>, can use <code class="inlineCode">ICommandHandler&lt;T&gt;</code> in their constructor. This way, we decouple the abstract definition of a command (the class that implements <code class="inlineCode">ICommand</code>) from the way it is executed.</p>
<p class="normal">The same construction can’t be applied to events, <code class="inlineCode">T</code>, and their <code class="inlineCode">IEventHandler&lt;T&gt;</code>, because when an event is triggered, we need to retrieve several instances of <code class="inlineCode">IEventHandler&lt;T&gt;</code> and not just one. We need<a id="_idIndexMarker503"/> to do this since each event may have several subscriptions. However, a few lines of code <a id="_idIndexMarker504"/>can easily solve this difficulty. First, we need to define a class that hosts all the handlers for a given event type:</p>
<pre class="programlisting code"><code class="hljs-code">public class EventTrigger&lt;T&gt;
    where T: IEventNotification
{
    private IEnumerable&lt;IEventHandler&lt;T&gt;&gt; handlers;
    public EventTrigger(IEnumerable&lt;IEventHandler&lt;T&gt;&gt; handlers)
    {
        this.handlers = handlers;
    }
    public async Task Trigger(T ev)
    {
        foreach (var handler in handlers)
            await handler.HandleAsync(ev);
    }
}
</code></pre>
<p class="normal">Declaring a <code class="inlineCode">handlers</code> <code class="inlineCode">IEnumerable&lt;IEventHandler&lt;T&gt;&gt;</code> parameter in the <code class="inlineCode">EventTrigger&lt;T&gt;</code> constructor lets a .NET dependency injection engine pass all <code class="inlineCode">IEventHandler&lt;T&gt;</code> implementations available in the dependency injection container to this <code class="inlineCode">handlers</code> parameter.</p>
<p class="normal">The idea is that each class that needs to trigger event <code class="inlineCode">T</code> requires <code class="inlineCode">EventTrigger&lt;T&gt;</code> and then passes the event to be triggered <a id="_idIndexMarker505"/>to its <code class="inlineCode">Trigger</code> method, which, in turn, invokes all the handlers.</p>
<p class="normal">Then, we need to register <code class="inlineCode">EventTrigger&lt;T&gt;</code> in the dependency injection engine. A good idea is to define the dependency <a id="_idIndexMarker506"/>injection extensions that we can invoke to declare each event, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">        service.AddEventHandler&lt;MyEventType, MyHandlerType&gt;()
</code></pre>
<p class="normal">This <code class="inlineCode">AddEventHandler</code> extension must automatically produce a dependency injection definition for <code class="inlineCode">EventTrigger&lt;T&gt;</code> and must process all the handlers that are declared with <code class="inlineCode">AddEventHandler</code> for each type, <code class="inlineCode">T</code>.</p>
<p class="normal">The following extension class does this for us:</p>
<pre class="programlisting code"><code class="hljs-code">public static class EventDIExtensions
{
    public static IServiceCollection AddEventHandler&lt;T, H&gt;
        (this IServiceCollection services)
 where T : IEventNotification
 where H: class, IEventHandler&lt;T&gt;
    {
        services.AddScoped&lt;H&gt;();
        services.TryAddScoped(typeof(EventTrigger&lt;&gt;));
        return services;
    }
    ...
    ...
}
</code></pre>
<p class="normal">The <code class="inlineCode">H</code> type passed to <code class="inlineCode">AddEventHandler</code> is recorded in the dependency injection engine, and the first time <code class="inlineCode">AddEventHandler</code> is called, <code class="inlineCode">EventTrigger&lt;T&gt;</code> is also added to the dependency injection engine. Then, when an <code class="inlineCode">EventTrigger&lt;T&gt;</code> instance is required by the dependency injection engine, all <code class="inlineCode">IEventHandler&lt;T&gt;</code> types added to the dependency injection engine are created, collected, and passed to the <code class="inlineCode">EventTrigger(IEnumerable&lt;IEventHandler&lt;T&gt;&gt; handlers)</code> constructor.</p>
<p class="normal">When the program starts up, all the <code class="inlineCode">ICommandHandler&lt;T&gt;</code> and <code class="inlineCode">IEventHandler&lt;T&gt;</code> implementations can be retrieved with reflection and registered automatically. To help with automatic discovery, they inherit from <code class="inlineCode">ICommandHandler</code> and <code class="inlineCode">IEventHandler</code>, which are both empty<a id="_idIndexMarker507"/> interfaces.</p>
<div><p class="normal">The <code class="inlineCode">EventDIExtensions</code> class, which is available in this book’s GitHub repository, contains methods for the automatic discovery and registration of command handlers and event handlers. The GitHub repository also contains an <code class="inlineCode">IEventMediator</code> interface and its <code class="inlineCode">EventMediator</code> implementation, whose <code class="inlineCode">TriggerEvents(IEnumerable&lt;IEventNotification&gt; events)</code> method retrieves all the handlers associated with the events it receives in its argument from the dependency injection engine and executes them. It is sufficient to have <code class="inlineCode">IEventMediator</code> injected into a class so that it can trigger events. <code class="inlineCode">EventDIExtensions</code> also contains an extension method that discovers all the queries that implement the empty <code class="inlineCode">IQuery</code> interface and adds them to the dependency injection engine.</p>
</div>
<p class="normal">A more sophisticated<a id="_idIndexMarker508"/> implementation is given by the <code class="inlineCode">MediatR</code> NuGet package.</p>
<h1 class="heading-1" id="_idParaDest-158">Summary</h1>
<p class="normal">In this chapter, we analyzed the main reasons for the adoption of DDD and why and how it meets the needs of the market. We described how to identify domains and how to coordinate the teams that work on different domains of the same application with domain maps. Then, we analyzed the way DDD represents data with entities, value objects, and aggregates, providing advice and code snippets so that we can implement them in practice.</p>
<p class="normal">We also described the onion architecture frequently used in conjunction with DDD-based projects, and compared it with the classical layer architecture.</p>
<p class="normal">We also covered some typical patterns that are used with DDD—that is, the repository and Unit of Work patterns, domain event patterns, CQRS, and event sourcing. Then, we learned how to implement them in practice. We also showed you how to implement domain events and the command pattern with decoupled handling so that we can add code snippets to real-world projects.</p>
<h1 class="heading-1" id="_idParaDest-159">Questions</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">What provides the main hints so that we can discover domain boundaries?</li>
<li class="numberedList">What is the main tool that’s used for coordinating the development of a separate Bounded Context?</li>
<li class="numberedList">Is it true that each entry that composes an aggregate communicates with the remainder of the system with its own methods?</li>
<li class="numberedList">Why is there a single aggregate root?</li>
<li class="numberedList">How many repositories can manage an aggregate?</li>
<li class="numberedList">How does a repository interact with the application layer?</li>
<li class="numberedList">Why is the Unit of Work pattern needed?</li>
<li class="numberedList">What are the reasons for the light form of CQRS? What about the reasons for its strongest form?</li>
<li class="numberedList">What is the main tool that allows us to couple commands/domain events with their handlers?</li>
<li class="numberedList">Is it true that event sourcing can be used to implement any Bounded Context?</li>
</ol>
<h1 class="heading-1" id="_idParaDest-160">Further reading</h1>
<ul>
<li class="bulletList">Eric Evans, Domain-Driven Design: <a href="https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20">https://www.amazon.com/exec/obidos/ASIN/0321125215/domainlanguag-20</a></li>
<li class="bulletList">More resources on DDD can be found here: <a href="https://domainlanguage.com/ddd/">https://domainlanguage.com/ddd/</a></li>
<li class="bulletList">A detailed discussion of CQRS design principles can be found here: <a href="http://udidahan.com/2009/12/09/clarified-cqrs/">http://udidahan.com/2009/12/09/clarified-cqrs/</a></li>
<li class="bulletList">More information on MediatR can be found on MediatR’s GitHub repository: <a href="https://github.com/jbogard/MediatR">https://github.com/jbogard/MediatR</a></li>
<li class="bulletList">A good description of event sourcing, along with an example of it, can be seen in the following blog post by Martin Fowler: <a href="https://martinfowler.com/eaaDev/EventSourcing.html">https://martinfowler.com/eaaDev/EventSourcing.html</a></li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code175081751210902046.png"/></p>
</div>
</body></html>