<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Creating Your First Game"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Creating Your First Game</h1></div></div></div><p>In <a class="link" href="ch03.html" title="Chapter 3. Components and State Machines">Chapter 3</a>, <span class="emphasis"><em>Components and State Machines</em></span>, you made your first game mechanic for the air hockey game, which we are going to keep improving for the rest of this book. You made a puck and a mallet that is controlled using the mouse pointer and pushes the puck. The pushing mechanic was rather complex and requires some in-depth analysis, which will be the first thing we talk about in this chapter. This chapter is going to cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using vector geometry and physics</li><li class="listitem" style="list-style-type: disc">Win/lose conditions</li><li class="listitem" style="list-style-type: disc">Creating artificial intelligence</li><li class="listitem" style="list-style-type: disc">Playmaker debugging</li></ul></div><p>In the end, I will give you a couple of exercises that you will be able to complete with skills and knowledge you will have acquired by the end of this chapter, as well as some advice on how to look for answers to your questions if you have any.</p><div class="section" title="Using Vector geometry and physics"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Using Vector geometry and physics</h1></div></div></div><p>If you are anything like me, you <a id="id90" class="indexterm"/>found the title of this section intimidating. However, before <a id="id91" class="indexterm"/>you decide to skip it or start looking for a new book about Unity, I assure you that it will not expose you to a single mathematical formula. Instead, it will use the Playmaker actions and explain what each of them does, which, in turn, will lead us to a conclusion about the science behind it.</p><p>Practically no 3D video game is possible without vector geometry and physics of some kind, and naturally both are instrumental in explaining how the mallet-puck interaction works in your new air hockey game.</p><p>To begin, let us select the <span class="strong"><strong>Push Puck</strong></span> state in the Mallet FSM by clicking on it in the FSM view of the <span class="strong"><strong>playMaker</strong></span> panel and open the <span class="strong"><strong>Variables</strong></span> tab on the right. There are three variables of type <span class="strong"><strong>Vector3</strong></span> and one of type <span class="strong"><strong>Float</strong></span> in the list. The following variables are of interest to us, since they are used for the calculation of push force and direction:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>hitPos</strong></span> is a <span class="strong"><strong>Vector3</strong></span> variable in which we store the <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span> coordinates of the collision point between the mallet and the puck</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>pushDir</strong></span> is a <span class="strong"><strong>Vector3</strong></span> variable we store the <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span> direction in which the puck is going to be pushed when it collides with the mallet</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>pushMag</strong></span> is a <span class="strong"><strong>Float</strong></span> variable that is currently equal to 20 and corresponds to the magnitude of the push</li></ul></div><p>To understand how things work in video games, you will have to be comfortable using <span class="strong"><strong>Vector3</strong></span> variables, because much of everything you will do is going to happen in 3D space. Each <span class="strong"><strong>Transform</strong></span> component has three <span class="strong"><strong>Vector3</strong></span> properties: <span class="strong"><strong>Position</strong></span>, <span class="strong"><strong>Rotation</strong></span>, and <span class="strong"><strong>Scale</strong></span>, each of which has its own <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span> values.</p><p>Each point in 3D space has coordinates that can be written down in the form of three <span class="strong"><strong>Float</strong></span> variables: a position on the X axis, a position on the Y axis, and a position on the Z axis. A <span class="strong"><strong>Vector3</strong></span> variable can store these three position values at the same time.</p><p>You can <a id="id92" class="indexterm"/>perform various actions over <span class="strong"><strong>Vector3</strong></span>, you can add it to another vector, you can <a id="id93" class="indexterm"/>multiply it by a float (or an integer), you can store its <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span> in separate <span class="strong"><strong>Float</strong></span> variables or write separate float values into its <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span>. Most of these actions are under the <span class="strong"><strong>Vector3</strong></span> category of the <span class="strong"><strong>Actions</strong></span> panel.</p><p>The first action that we use is called <span class="strong"><strong>Get Controller Hit Info</strong></span>, and it gets the position of the last collision that happened to a game object. If you look at the <span class="strong"><strong>Collision Event</strong></span> action in the <span class="strong"><strong>Move</strong></span> state that triggers the <span class="strong"><strong>Push</strong></span> event, you will see that this only happens when the mallet collides with the puck, so we do not have to worry about weeding out false collisions once we are already in the <span class="strong"><strong>Push Puck</strong></span> state. All we have to do is save the contact point in a variable, which is exactly what happens.</p><div class="mediaobject"><img src="graphics/8108OT_04_01.jpg" alt="Using Vector geometry and physics"/></div><p>Next, we simply get the current position of the mallet and store it in the <span class="strong"><strong>pushDir</strong></span> variable, for the time being using the <span class="strong"><strong>GetPosition</strong></span> action. This variable is called <span class="strong"><strong>pushDir</strong></span>, because later it will contain the direction in which the mallet will be pushed. We get this position simply by accessing the <span class="strong"><strong>Position</strong></span> property of the mallet's <span class="strong"><strong>Transform</strong></span> component.</p><div class="mediaobject"><img src="graphics/8108OT_04_02.jpg" alt="Using Vector geometry and physics"/></div><p>If these are all <a id="id94" class="indexterm"/>positions, how do you get a direction? What is a direction and<a id="id95" class="indexterm"/> how can you write it down in <span class="strong"><strong>Vector3</strong></span>? The answer is quite simple. A direction is the relative position of one point with respect to another point in space, which is another way of saying that it is the difference between <span class="strong"><strong>Position A</strong></span> and <span class="strong"><strong>Position B</strong></span>. The following figure shows two points and their relative directions.</p><div class="mediaobject"><img src="graphics/8108OT_04_03.jpg" alt="Using Vector geometry and physics"/></div><p>So, in order to find the direction in which point B lies in relation to point A, you will have to subtract the position of point B from the position of point A. Then you need to normalize the result, which means writing it down as a <span class="strong"><strong>Vector3</strong></span> variable that has its <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span> properties as numbers between <code class="literal">0</code> and <code class="literal">1</code> (that is, without a magnitude).</p><p>For example, if the original result of subtraction was (<code class="literal">-1</code>, <code class="literal">27</code>, <code class="literal">350</code>), the normalized vector of direction will be (<code class="literal">-0.00284867</code>, <code class="literal">0.076914</code>, <code class="literal">0.997034</code>), and the best part of it is that you do not need to know how this happens, because there is a Playmaker action that does it automatically for you. The following screenshot shows the two actions that are used to get the direction from the center of the mallet to the hit point:</p><div class="mediaobject"><img src="graphics/8108OT_04_04.jpg" alt="Using Vector geometry and physics"/></div><p>Let us go through the <a id="id96" class="indexterm"/>things we have covered so far:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We need the <a id="id97" class="indexterm"/>position of the mallet, because this is where we are going to push the puck from</li><li class="listitem" style="list-style-type: disc">We need the point of the impact between the mallet and the puck in order to find where the puck lies in space in relation to the mallet when the mallet hits it</li><li class="listitem" style="list-style-type: disc">Both of these values are saved as <span class="strong"><strong>Vector3</strong></span> variables, each of which contains an <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span> position</li><li class="listitem" style="list-style-type: disc">We can find out in which direction the puck lies in relation to the mallet by subtracting the position of the impact from the position of the mallet and normalizing the resulting vector, that is, writing down its <span class="strong"><strong>X</strong></span>, <span class="strong"><strong>Y</strong></span>, and <span class="strong"><strong>Z</strong></span> properties as numbers between <code class="literal">0</code> and <code class="literal">1</code></li></ul></div><p>Now that we know how to find the direction in which the puck lies in relation to the mallet, we want to push it in that direction, so this is exactly what we are going to do. However, we cannot just assign the direction vector as the puck's velocity, because the direction vector does not have a magnitude, which means that the velocity of the puck will be way smaller than we want it to be.</p><p>In order to control the force with which the puck is being pushed, we have to multiply the direction by a magnitude, which is stored in the <span class="strong"><strong>pushMag</strong></span> variable. This variable determines how fast the puck will move in the opposite direction once it meets the mallet.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>If you assign <span class="strong"><strong>pushMag</strong></span> a negative value, the puck will be pushed towards the mallet every time it collides with it, which, in turn, means that it will stick to it. This too can be a useful game mechanic, albeit not in this case.</p></div></div><p>The following screenshot shows the <span class="strong"><strong>Vector3 Multiply</strong></span> action that multiplies the <span class="strong"><strong>pushDir</strong></span> direction vector by <span class="strong"><strong>pushMag</strong></span> magnitude as well as the <span class="strong"><strong>Add Force</strong></span> action that applies the force to the puck at the impact point.</p><div class="mediaobject"><img src="graphics/8108OT_04_05.jpg" alt="Using Vector geometry and physics"/></div></div></div>
<div class="section" title="Win/Lose conditions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Win/Lose conditions</h1></div></div></div><p>While there are games where <a id="id98" class="indexterm"/>win/lose conditions are not necessary, air hockey is definitely not one of them. In classic air hockey, there are two goal slots on the opposite sides of the table. If the puck gets into the goal of player 1, then player 2 gets a point and vice versa. The game ends when one of the players has 7 points.</p><p>There is the short-term win condition (score once) and the long-term win condition (score seven times before your opponent does). We will only implement the short-term win condition, although you are highly encouraged to try and implement the long-term one once you are done with this chapter.</p><p>Before we start implementing the win/lose conditions, let us make sure that the puck cannot get stuck in the corner, because this kind of behavior will prevent the win/lose condition from being triggered. Make four new walls, rotate them 45 degrees on the Y axis, and place them in the corners so as to get rid of the straight angles there, as shown in the next figure. This should solve the problem.</p><p>Now that this is taken care <a id="id99" class="indexterm"/>of, let us make the goal slots. Change the puck's <span class="strong"><strong>Scale</strong></span> property to (<code class="literal">1</code>, <code class="literal">0.7</code>, <code class="literal">1</code>) and place it in (<code class="literal">-3</code>, <code class="literal">0.3</code>, <code class="literal">0</code>).</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Make one more wall on the left and one more wall on the right. The walls should be placed as shown in the following figure:<div class="mediaobject"><img src="graphics/8108OT_04_06.jpg" alt="Win/Lose conditions"/></div></li><li class="listitem">Make two new cubes (<span class="strong"><strong>GoalLeft</strong></span> and <span class="strong"><strong>GoalRight</strong></span>) and place them in the gaps on the left and on the right, as shown in the next figure. Make the cube on the left green (<code class="literal">0</code>, <code class="literal">255</code>, <code class="literal">0</code>) and the cube on the right red (<code class="literal">255</code>, <code class="literal">0</code>, <code class="literal">0</code>) by making new materials for them. Both of them should be in <code class="literal">2.5</code> on the Y axis. These are there to block the mallet, but not the puck.</li><li class="listitem">Make two more cubes. Call them <code class="literal">GoalTriggerLeft</code> and <code class="literal">GoalTriggerRight</code>. Place them just behind the game field on either side of the table. These objects will act as triggers to detect which goal the puck has scored. Check the <span class="strong"><strong>Is Trigger</strong></span> property of these game objects' <span class="strong"><strong>Box Collider</strong></span> component. This property of the collider component makes sure that the object does not do any physics collisions (as opposed to the puck or the walls), but instead acts as a trigger, detecting when rigidbodies enter, stay inside, and exit it. These objects are the actual goals that will trigger the win/lose conditions.</li><li class="listitem">Your <span class="strong"><strong>Scene</strong></span> view should look something like the following screenshot at this point:<div class="mediaobject"><img src="graphics/8108OT_04_07.jpg" alt="Win/Lose conditions"/></div></li><li class="listitem">Select the <a id="id100" class="indexterm"/><span class="strong"><strong>GoalTriggerLeft</strong></span> game object and add an FSM to it. Make two states and rename <span class="strong"><strong>State1</strong></span> to <code class="literal">Scored</code> and <span class="strong"><strong>State2</strong></span> to <code class="literal">LoadLevel</code>.</li><li class="listitem">Right-click the <span class="strong"><strong>Scored</strong></span> state and go to <span class="strong"><strong>Add Transition</strong></span> | <span class="strong"><strong>System Events</strong></span> | <span class="strong"><strong>TRIGGER ENTER</strong></span> from the contextual menu.</li><li class="listitem">Make a transition from <span class="strong"><strong>TRIGGER ENTER </strong></span>to <span class="strong"><strong>LoadLevel</strong></span>. When something enters the trigger (and it should only be the puck, because of the way things are placed in the scene), this event will get called, and the transition will be made.</li><li class="listitem">Select the <span class="strong"><strong>LoadLevel</strong></span> state and add a <span class="strong"><strong>Load Level</strong></span> action to it. It should be located under the <span class="strong"><strong>Level</strong></span> category.</li><li class="listitem">In the <span class="strong"><strong>Level Name</strong></span> property of the <span class="strong"><strong>Load Level</strong></span> action, type the name of your game scene. It should be called <code class="literal">Scene1</code> if you haven't changed anything. To make sure, look at the top of the <span class="strong"><strong>Unity Editor</strong></span> window. It always says <code class="literal">[SceneName].unity - [ProjectName] - [Platform]</code>, where the things in the brackets are <span class="strong"><strong>Scene1</strong></span>, <span class="strong"><strong>UPMTutorial</strong></span>, and <span class="strong"><strong>Web Player</strong></span> for me, but can differ for you.</li><li class="listitem">Do the same thing for <span class="strong"><strong>GoalTriggerRight</strong></span>. For now, keep the FSM exactly the same.</li></ol></div><p>Now, we can add some finishing touches to our scene by importing a 3D model:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Make sure <a id="id101" class="indexterm"/>that you have downloaded the project archive from the Packt Publishing website. If you haven't, do it now and unpack the archive.</li><li class="listitem">Right-click in the empty space under the file list in the <span class="strong"><strong>Project</strong></span> panel and select <span class="strong"><strong>Import New Asset...</strong></span> from the contextual menu. A file browser should pop up.</li><li class="listitem">Locate the <code class="literal">WallVisual.fbx</code> file in the <code class="literal">UnityPlaymakerTutorial</code> directory and click on <span class="strong"><strong>Import</strong></span>. The file browser will close and a <code class="literal">WallVisual</code> file will appear in the <span class="strong"><strong>Project</strong></span> panel. Create a <code class="literal">Models</code> folder and drag it there.</li><li class="listitem">Select the <code class="literal">WallVisual</code> file and have a look at <span class="strong"><strong>Inspector</strong></span>. There are three tabs in this <span class="strong"><strong>Inspector</strong></span>: <span class="strong"><strong>Model</strong></span>, <span class="strong"><strong>Rig</strong></span>, and <span class="strong"><strong>Animations</strong></span>. These are all responsible for changing import settings of your model.</li><li class="listitem">Since the model that we have imported is not an animated one, only the <span class="strong"><strong>Model</strong></span> tab is of interest to us. Set <span class="strong"><strong>Scale Factor</strong></span> to <code class="literal">1.05</code> and uncheck <span class="strong"><strong>Import Materials</strong></span>. Leave the rest of the properties at their default values. <span class="strong"><strong>Scale Factor</strong></span> changes the scale of the model on import, meaning that the <span class="strong"><strong>Transform Scale</strong></span> property will be equal to (<code class="literal">1</code>, <code class="literal">1</code>, <code class="literal">1</code>) while the actual size in 3D space may change. This is needed because the working scale in the 3D modeling software (such as Maya or 3DS Max) may differ from that in Unity. To make the model appear bigger, increase the scale factor. See the following screenshot to confirm that your import settings are set correctly:<div class="mediaobject"><img src="graphics/8108OT_04_15.jpg" alt="Win/Lose conditions"/></div></li><li class="listitem">Drag <a id="id102" class="indexterm"/><span class="strong"><strong>WallVisual</strong></span> into <span class="strong"><strong>Hierarchy</strong></span> twice. Position the first instance in (<code class="literal">0</code>, <code class="literal">0.5</code>, <code class="literal">-3.5</code>) and the second one in (<code class="literal">0</code>, <code class="literal">0.5</code>, <code class="literal">3.5</code>). Set the first one's <span class="strong"><strong>Rotation</strong></span> to (<code class="literal">0</code>, <code class="literal">0</code>, <code class="literal">0</code>) and the second one's to (<code class="literal">0</code>, <code class="literal">180</code>, <code class="literal">0</code>).<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>The difference between a prefab and an imported model is that you cannot apply the changes that you made to one of the instances. You also cannot add or remove any components from the model. You can make a prefab from one of the instances of the model to be able to do that.</p></div></div></li><li class="listitem">Set the material of both <span class="strong"><strong>WallVisual</strong></span> game objects to <span class="strong"><strong>WallMaterial</strong></span> that you created previously to be used on walls. Select all of the <span class="strong"><strong>Wall</strong></span> objects and deactivate their <span class="strong"><strong>Mesh Renderer</strong></span> components. The following figure shows what you should see in the <span class="strong"><strong>Game</strong></span> view if you did everything right:<div class="mediaobject"><img src="graphics/8108OT_04_16.jpg" alt="Win/Lose conditions"/></div></li></ol></div><p>Now, when<a id="id103" class="indexterm"/> you hit play, you should be able to score in both goals. Doing so will reload the currently loaded level. We also made sure that the puck does not get stuck in the corners of the table and imported a model that covers our cubic walls and makes the game look more like an actual air hockey table. This means that the game is finally playable, if, admittedly, not very fun yet.</p></div>
<div class="section" title="Creating artificial intelligence"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Creating artificial intelligence</h1></div></div></div><p>Having an <span class="strong"><strong>artificial intelligence</strong></span> (<span class="strong"><strong>AI</strong></span>)<a id="id104" class="indexterm"/> in the game, even a really simple one, will definitely make it more challenging and fun, so let us get to it with no further delay.</p><p>Here is how our AI <a id="id105" class="indexterm"/>is going to work: it is going to constantly try and move to the point on the right side of the puck, pushing it to the left upon collision. We will keep the same collision logic that we use for the player's mallet in order to keep the game fair. In order to make sure that the AI does not get stuck in a wall while pushing directly to the left, we will make adjustments to the direction based on the current position of the mallet. This way, the AI will appear to aim at the player's goal slot.</p><p>Follow the given steps to implement the AI:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Duplicate the <span class="strong"><strong>Mallet</strong></span> game object by selecting it in <span class="strong"><strong>Hierarchy</strong></span> and pressing <span class="emphasis"><em>command</em></span> + <span class="emphasis"><em>D</em></span> (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>D</em></span> in Windows).</li><li class="listitem">Move the copy to the right side of the table and put it next to the red goal.</li><li class="listitem">Name the original mallet on the left <code class="literal">MalletLeft</code>, and the copy on the right <code class="literal">MalletRight</code>.</li><li class="listitem">Make a new red material for <span class="strong"><strong>MalletRight</strong></span> and assign it to it.</li><li class="listitem">Put both mallets on a new layer called <span class="strong"><strong>Player</strong></span> using the <span class="strong"><strong>TagManager</strong></span> menu accessible from <span class="strong"><strong>Inspector</strong></span>.</li><li class="listitem">In the main menu, go to <span class="strong"><strong>Edit</strong></span> | <span class="strong"><strong>Project Settings</strong></span> | <span class="strong"><strong>Physics</strong></span>. You will see a matrix of checkboxes with names of layers written horizontally and vertically next to each row and column in the <span class="strong"><strong>Inspector</strong></span> panel.</li><li class="listitem">Find the intersection between <span class="strong"><strong>Player</strong></span> horizontally and <span class="strong"><strong>Player</strong></span> vertically and uncheck that box. Make sure that the rest of the boxes stay checked. This matrix determines which layers can interact with each other and with themselves, so if you accidentally uncheck something else, such as <span class="strong"><strong>Default</strong></span>/<span class="strong"><strong>Player</strong></span> or <span class="strong"><strong>Default</strong></span>/<span class="strong"><strong>Default</strong></span>, the puck may no longer collide with the goal triggers and the mallets may stop colliding with the walls.</li><li class="listitem">Select the <span class="strong"><strong>MalletRight</strong></span> game object. In <span class="strong"><strong>Inspector</strong></span>, remove the <span class="strong"><strong>Character Controller</strong></span> component and add <span class="strong"><strong>Capsule Collider</strong></span>. Add a <span class="strong"><strong>Rigidbody</strong></span> component. Set <span class="strong"><strong>Freeze Rotation</strong></span> on the <span class="strong"><strong>Rigidbody</strong></span> component to X, Y and Z. If you don't, the red mallet will fall when you press play. <span class="strong"><strong>Rigidbody</strong></span> is the component responsible for physics interactions.</li><li class="listitem">In the FSM view of the <span class="strong"><strong>playMaker</strong></span> panel, select the <span class="strong"><strong>Move</strong></span> state. It is here that we are going to set up the AI.</li><li class="listitem">Remove all the <a id="id106" class="indexterm"/>actions except <span class="strong"><strong>Collision Event</strong></span>. You can select multiple actions at the same time by <span class="emphasis"><em>Shift</em></span>-clicking their headers. Open the <span class="strong"><strong>Actions</strong></span> panel and add the following actions to the state, keeping in mind that the order of the actions matters, and moving <span class="strong"><strong>Collision Event</strong></span> to the very bottom: <span class="strong"><strong>Get Property</strong></span>, <span class="strong"><strong>Get Property</strong></span>, <span class="strong"><strong>Get Property</strong></span>, <span class="strong"><strong>Float Multiply</strong></span>, <span class="strong"><strong>Float Add</strong></span>, <span class="strong"><strong>Float Add</strong></span>, <span class="strong"><strong>Set Vector3 XYZ</strong></span>, and <span class="strong"><strong>Move Towards</strong></span>. The following screenshot shows the exact order of the actions that you should have in the <span class="strong"><strong>Move</strong></span> state of the FSM of <span class="strong"><strong>MalletRight</strong></span>.<div class="mediaobject"><img src="graphics/8108OT_04_08.jpg" alt="Creating artificial intelligence"/></div></li><li class="listitem">In the <span class="strong"><strong>Events</strong></span> tab, add a new event, calling it <code class="literal">Return</code>.</li><li class="listitem">Open the <span class="strong"><strong>Variables</strong></span> tab and add/remove variables until you have the variables shown in the following screenshot:<div class="mediaobject"><img src="graphics/8108OT_04_09.jpg" alt="Creating artificial intelligence"/></div></li><li class="listitem">These are <a id="id107" class="indexterm"/>the variables used for collision calculations that were left from before, and some new ones used for the simple AI behavior that we discussed earlier.</li><li class="listitem">Go back to the <span class="strong"><strong>State</strong></span> tab and open the first <span class="strong"><strong>Get Property</strong></span> action. Drag and drop the <span class="strong"><strong>Puck</strong></span> game object into <span class="strong"><strong>Target Object</strong></span>, and set <span class="strong"><strong>Property</strong></span> to <span class="strong"><strong>transform</strong></span> | <span class="strong"><strong>position</strong></span> | <span class="strong"><strong>x</strong></span> and <span class="strong"><strong>Store Float</strong></span> to <span class="strong"><strong>puckX</strong></span>. Check <span class="strong"><strong>Every Frame</strong></span>. In fact, check <span class="strong"><strong>Every Frame</strong></span> every time you see this checkbox in this state.</li><li class="listitem">Do the same for the second <span class="strong"><strong>Get Property</strong></span> tab, but choose <span class="strong"><strong>z</strong></span> instead of <span class="strong"><strong>x</strong></span> and <span class="strong"><strong>puckZ</strong></span> instead of <span class="strong"><strong>puckX</strong></span>. These actions are used to retrieve the position of the puck on the two axes that matter to us.</li><li class="listitem">Open the third <span class="strong"><strong>Get Property</strong></span> action and drag <span class="strong"><strong>MalletRight</strong></span> into its <span class="strong"><strong>Target Object</strong></span> property; store its Z position in the offset variable.</li><li class="listitem">In the <span class="strong"><strong>Float Multiply</strong></span> action, set <span class="strong"><strong>Float Variable</strong></span> to <span class="strong"><strong>offset</strong></span> and <span class="strong"><strong>Multiply By</strong></span> to <code class="literal">0.2</code>. This is where we define how hard the AI should try to aim the player's goal. If it tries too hard, it will miss. If it tries not hard enough, it will miss as well.</li><li class="listitem">In the first <span class="strong"><strong>Float Add</strong></span> action, set <span class="strong"><strong>Float Variable</strong></span> to <span class="strong"><strong>puckX</strong></span> and the <span class="strong"><strong>Add</strong></span> property to <span class="strong"><strong>offset</strong></span>. You need to click on the option button on the right to do that. This is where the offset is actually applied.</li><li class="listitem">In the second <span class="strong"><strong>Float Add</strong></span> action, set <span class="strong"><strong>Float Variable</strong></span> to <span class="strong"><strong>puckZ</strong></span>, and <span class="strong"><strong>Add</strong></span> to <code class="literal">0.9</code>. This value can be changed as you want later. It defines the distance between the actual center of the puck and the point to which the AI is going to move. It is very important that the AI aim somewhat to the right, because otherwise it will never be able to hit the player's goal.</li><li class="listitem">In <span class="strong"><strong>Set Vector3 XYZ</strong></span>, set <span class="strong"><strong>Vector3 Variable</strong></span> to <span class="strong"><strong>targetPos</strong></span>, <span class="strong"><strong>X</strong></span> to <span class="strong"><strong>puckX,</strong></span> and <span class="strong"><strong>Z</strong></span> to <span class="strong"><strong>puckZ</strong></span>. Make sure that <span class="strong"><strong>Y</strong></span> is set to <span class="strong"><strong>None</strong></span>. This is where we define the actual position where the AI is going to try and go in the current frame.</li><li class="listitem"><span class="strong"><strong>Move Towards</strong></span> is the action that applies movement to the AI. Set <span class="strong"><strong>Target Position</strong></span> to <span class="strong"><strong>targetPos</strong></span>, <span class="strong"><strong>Max Speed</strong></span> to <code class="literal">5</code>, <span class="strong"><strong>Finish Distance</strong></span> to <code class="literal">0.15,</code> and <span class="strong"><strong>Finish Event</strong></span> to <span class="strong"><strong>Return</strong></span>.</li><li class="listitem">Finally, open <a id="id108" class="indexterm"/><span class="strong"><strong>Collision Event</strong></span> and change its <span class="strong"><strong>Collision</strong></span> property to <span class="strong"><strong>On Collision Stay</strong></span>; leaving everything else intact.</li><li class="listitem">Now you might have an error in the <span class="strong"><strong>Move Towards</strong></span> action. That would be because there is no transition from the <span class="strong"><strong>Return</strong></span> event. Right-click the <span class="strong"><strong>Move</strong></span> state in the FSM view and add a transition from the <span class="strong"><strong>Return</strong></span> event to <span class="strong"><strong>Move</strong></span>. Yes, this is a state that loops on itself. The following figure shows the layout that you should see in the FSM view of <span class="strong"><strong>MalletRight</strong></span> now.<div class="mediaobject"><img src="graphics/8108OT_04_10.jpg" alt="Creating artificial intelligence"/></div></li></ol></div><p>If you click on the play button right now, the AI should be completely functional and, in fact, quite strong. Now, there are ways of improving it that will be discussed in the <span class="emphasis"><em>Exercises</em></span> section of this chapter, but it should be enough to have a good bit of fun with the game debugging in Playmaker.</p><p>Now that you have a player controller, a win/lose condition, and a functional AI in the game, it begins to get quite big, and if you want to add anything to it or if something goes wrong, you will be hard-pressed to know what exactly is going on in your actions in real time. This is what debugging is for: it is a diagnosis tool that lets you get additional information about your game or its specific systems that you can later use in order to fix something.</p><p>Let us look at an example. Select <span class="strong"><strong>MalletLeft</strong></span> and open its <span class="strong"><strong>Move</strong></span> state in the FSM view of the <span class="strong"><strong>playMaker</strong></span> panel. If you look at the bottom of the <span class="strong"><strong>State</strong></span> tab, you will see two checkboxes there: <span class="strong"><strong>Debug</strong></span> and <span class="strong"><strong>Hide Unused</strong></span>. The first one shows you the values of all your properties at all time, while the second one hides the unused ones. Check both of them and, keeping <span class="strong"><strong>MalletLeft</strong></span> selected, press the play button.</p><p>As you move the <a id="id109" class="indexterm"/>mallet around, observe the numbers that change under all the properties of the actions. When you implement a new gameplay feature, you will want to know in what range values change, and if they do at all.</p><p>You can also use the <span class="strong"><strong>Console</strong></span> panel for debugging some things. Uncheck both <span class="strong"><strong>Debug</strong></span> and <span class="strong"><strong>Hide Unused</strong></span>, and then open the <span class="strong"><strong>Push Puck</strong></span> state of the same FSM. Add a <span class="strong"><strong>Debug Log</strong></span> action (under the <span class="strong"><strong>Debug</strong></span> category) to the very top of it. Set <span class="strong"><strong>Log Level</strong></span> to <span class="strong"><strong>Warning</strong></span> and write <code class="literal">Hit!</code> in the text field.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>You should know that there are three types of debug logs: <span class="emphasis"><em>Info</em></span>, <span class="emphasis"><em>Warning</em></span>, and <span class="emphasis"><em>Error</em></span>, each with a specific function. Warning is there to attract your attention to an issue, Info is a simple message that provides information about something, while Error lets you know that there is a problem. These are merely conventions, but you will see some Unity internal Info, Warnings, and Errors that follow them.</p></div></div><p>Now open the <span class="strong"><strong>Console</strong></span> panel. We have talked about it briefly before, but let us have a detailed look at various buttons in it now (from left to right).</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Clear</strong></span> is quite self-explanatory; it clears the log, removing all the messages from it, apart from compilation errors that were not fixed</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Collapse</strong></span> is a toggle button that makes similar debug messages appear in the same line or separately</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Clear on Play</strong></span> is a toggle button that forces the <span class="strong"><strong>Console</strong></span> to clear the log when you press play.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Error Pause</strong></span> automatically pauses the game when there is an error to give you a better look at it.</li></ul></div><p>Finally, the three toggle buttons on the right are filters for <span class="strong"><strong>Console</strong></span> that let you focus on different types of debug messages: Info, Warning, and Error.</p><p>If you press play now and hit the puck with your mallet, a message with a yellow triangle should appear in Console saying something like <span class="strong"><strong>MalletLeft : FSM : Push Puck : DebugLog : Hit!</strong></span> You might also have several of them. Stop the game and see what happens when you switch <span class="strong"><strong>Collapse</strong></span> on and off and toggle the Warning filter.</p><p>If you press play now and hit the puck with your mallet, a message with a yellow triangle should appear in <span class="strong"><strong>Console</strong></span> saying something like <span class="strong"><strong>MalletLeft : FSM : Push Puck : DebugLog : Hit!</strong></span> You might also have several of them. Stop the game and see what happens when you switch <span class="strong"><strong>Collapse</strong></span> on and off and toggle the Warning filter. You might also have several of them, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8108OT_04_11.jpg" alt="Creating artificial intelligence"/></div><p>You can also debug variable values in the same way. Open <span class="strong"><strong>playMaker</strong></span>, remove the <span class="strong"><strong>Debug Log</strong></span> action, and put a <span class="strong"><strong>Debug Vector3</strong></span> action right after <span class="strong"><strong>Get Controller Hit Info</strong></span>, setting the <span class="strong"><strong>Log Level</strong></span> to <span class="strong"><strong>Error</strong></span> and <span class="strong"><strong>Vector3 Variable</strong></span> to <span class="strong"><strong>hitPos</strong></span>. Then open <span class="strong"><strong>Console</strong></span> and test the game again, pushing the puck with your mallet. You should see red error messages appear in <span class="strong"><strong>Console</strong></span> now. If you have <span class="strong"><strong>Error Pause</strong></span> toggled, the game will pause and the <span class="strong"><strong>Console</strong></span> panel will be revealed to show you the errors.</p><p>You can achieve a <a id="id110" class="indexterm"/>similar effect by using something called breakpoints. Get rid of the <span class="strong"><strong>Debug Vector3</strong></span> action in the <span class="strong"><strong>Push Puck</strong></span> state of the FSM of <span class="strong"><strong>MalletLeft</strong></span>, then right-click on the <span class="strong"><strong>Push Puck</strong></span> state in the FSM view and select <span class="strong"><strong>Toggle Breakpoint</strong></span> from the contextual menu. A red line will appear next to the state's name in the FSM view.</p><p>Now, if you press play and touch the puck with your mallet, the game will stop the same way it did when you used an <span class="strong"><strong>Error Debug</strong></span> log and the <span class="strong"><strong>Error Pause</strong></span> toggle in <span class="strong"><strong>Console</strong></span>, except this time the pause will be triggered by Playmaker. A red circle with the name of the breakpoint's state will appear in the FSM view. The following screenshot shows what it is supposed to look like:</p><div class="mediaobject"><img src="graphics/8108OT_04_12.jpg" alt="Creating artificial intelligence"/></div><p>Note that the transition arrow from the <span class="strong"><strong>Push</strong></span> event to the <span class="strong"><strong>Push Puck</strong></span> state became yellow. This means that the breakpoint was triggered after this particular transition and not something else.</p><p>You can <a id="id111" class="indexterm"/>unpause the game when it was paused because of a breakpoint, but it will be paused all over again if this or another breakpoint gets triggered. You can remove the breakpoint by right-clicking the state with a breakpoint and selecting <span class="strong"><strong>Toggle Breakpoint</strong></span> from the contextual menu.</p><p>Another useful debugging tool is step-by-step execution. When the game is paused (including when it was paused because of breakpoints or <span class="strong"><strong>Error Pause</strong></span>), you can press the next step (<span class="inlinemediaobject"><img src="graphics/8108OT_04_13.jpg" alt="Creating artificial intelligence"/></span>) button in the toolbar or on the bottom of the <span class="strong"><strong>playMaker</strong></span> panel. This will execute the next frame of the game. As you already know, some actions are executed in every frame so, using the <span class="strong"><strong>Debug</strong></span> checkbox on the bottom of the <span class="strong"><strong>State</strong></span> tab in the <span class="strong"><strong>playMaker</strong></span> panel, you can see the exact values of each parameter of each action in any particular frame. You can press the next step button as you want to observe changes. When you are done debugging, just unpause or stop the game.</p><p>The final debug tool that we are going to talk about is the Playmaker <span class="strong"><strong>FSM Log</strong></span> panel that lets you see everything that happens to your objects that are under Playmaker control. You can open it by pressing the <span class="strong"><strong>Debug</strong></span> button on the bottom of the <span class="strong"><strong>playMaker</strong></span> panel next to the play/pause/next step buttons, then select <span class="strong"><strong>Open Log Window</strong></span> from the drop-down menu. The following screenshot shows the <span class="strong"><strong>FSM Log</strong></span> panel in action:</p><div class="mediaobject"><img src="graphics/8108OT_04_14.jpg" alt="Creating artificial intelligence"/></div><p>It might <a id="id112" class="indexterm"/>be a good idea to keep this log handy, so you could attach it as the second panel to the same area of the screen as <span class="strong"><strong>Hierarchy</strong></span> or <span class="strong"><strong>Project</strong></span>.</p></div>
<div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Exercises</h1></div></div></div><p>There are some exercises that I would like to suggest that you try doing before you move on to the next chapters, which cover more advanced topics. You already know the basics of Unity and Playmaker—enough to make your game better or make a completely new one from scratch. Doing these exercises will improve your skills and help consolidate the new information that you have been exposed to in this book. Exercises are sorted by difficulty, from the easiest to the hardest one:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Debug log all the important events in the game, including puck hits, goal hits, and wall collisions for both mallets.</li><li class="listitem">Hit sounds: Your <code class="literal">Wall</code> prefab has a FSM. Use it to play some sounds when a mallet and/or a puck hits the wall. <a class="ulink" href="http://Freesound.org">Freesound.org</a> is a good resource for free sound effects. If you are more into retro sounds, try <a class="ulink" href="http://bfxr.net">bfxr.net</a>.</li><li class="listitem">Multiple levels: Try making multiple levels with obstacles/additional walls in the middle. You can just duplicate them all over the place and then, when the round is over, move on to the next level.</li><li class="listitem">By now you have probably encountered a situation where the puck falls off of the table, and you are forced to restart the game using the play button. This is annoying for other players as well! You could try changing the table set up, detecting the puck position, or some other way of fixing this.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>When you are working on this, think about the way goal triggers work, or be creative and come up with your own solution.</p></div></div></li><li class="listitem">You know how to manipulate the <span class="strong"><strong>Scene</strong></span> view and make new materials for objects, and you also know how to change the size and the projection of the camera. You can make your game much prettier if you come up with a beautiful color scheme and/or camera projection/orientation.</li><li class="listitem">By now you have probably started wondering whether mouse controls are the best solution for this game. This is a perfectly valid question, and you should make this decision yourself. You will never know for sure until you try different ones, so take a look at the <span class="strong"><strong>Input</strong></span> category in the <span class="strong"><strong>Actions</strong></span> panel.</li><li class="listitem">If you manage to implement keyboard controls, why not go a step further and make a level where instead of competing with an AI opponent you could play with your friend or family member while sitting at the same computer?</li><li class="listitem">Have a close look at states and actions that control the AI. Try modifying some of the properties there or even replacing actions themselves in order to make the AI more intelligent and life-like. You could try and make the AI alternate its behavior based on the position of the puck by going back to its own goal slot in order to protect it. You can also try and figure out a way to stop the AI from being pushed backwards whenever the player pushes the puck that the AI is trying to push itself.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>In order to do this, you will need to add a Playmaker variable to the puck and then use one of the <span class="strong"><strong>Get FSM</strong></span> actions under the <span class="strong"><strong>StateMachine</strong></span> category.</p></div></div></li><li class="listitem">Introduce a new game mechanic to the game: how about rounds of seven games instead of one? Or power-ups? Or limiting the mallets to their side of the table? You choose, you can do them all if you like.</li></ol></div><p>Before you take up any of these challenges, you should know about some of the useful Unity and Playmaker online resources that can help you find answers to some, if not all, of the questions. You can be sure that questions will inevitably appear when you start implementing something on your own.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Unity answers</strong></span>: <a class="ulink" href="http://answers.unity3d.com/">http://answers.unity3d.com/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Unity wiki</strong></span>: <a class="ulink" href="http://wiki.unity3d.com/">http://wiki.unity3d.com/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Unity forum</strong></span>: <a class="ulink" href="http://forum.unity3d.com/">http://forum.unity3d.com/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Unity documentation</strong></span>: <a class="ulink" href="http://unity3d.com/learn/documentation">http://unity3d.com/learn/documentation</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Playmaker manual</strong></span>: <a class="ulink" href="https://hutonggames.fogbugz.com/">https://hutonggames.fogbugz.com/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Playmaker forums</strong></span>: <a class="ulink" href="http://hutonggames.com/playmakerforum/">http://hutonggames.com/playmakerforum/</a></li></ul></div><p>On Unity answers and the Unity forums, you should not hesitate to ask questions; the Unity community is very active, and there are chances that your problem will be solved in a matter of minutes. Just make sure you explain it well. But before asking, I strongly advise you to use the search option first, since there is a good chance that most of the problems that you might encounter have already been solved.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Summary</h1></div></div></div><p>In this chapter, you learned the fundamentals of game development with Unity and Playmaker. You now know how to make objects, have them interact, make them respond to input, and even move on their own based on your algorithm. On top of that, you now know the fundamentals of vector geometry that you are going to use in most of the games you will make.</p><p>The next chapter is about programming. You will learn how to code your own Unity component and then make it into a Playmaker action. We will also demonstrate that Playmaker is essentially visual programming that uses logic very similar to that of conventional scripts.</p></div></body></html>