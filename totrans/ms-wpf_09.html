<html><head></head><body>
        

                            
                    <h1 class="header-title">Implementing Responsive Data Validation</h1>
                
            
            
                
<p>Data validation goes hand in hand with data input forms and is essential for promoting clean, usable data. While the UI controls in WPF can automatically corroborate the fact that values entered match the type of their data bound properties, they cannot validate the correctness of the data entered.</p>
<p>For example, a <kbd>TextBox</kbd> control that is data bound to an integer may highlight an error if a user entered a non-numeric value, but it wouldn't validate the fact that the number entered had the correct number of digits, or that the first four digits were appropriate for the type of credit card specified.</p>
<p>In order to validate these types of data correctness when using MVVM, we'll need to implement one of the .NET validation interfaces. In this chapter, we'll examine in detail the available interfaces, looking at a number of implementations and explore the other validation-related features that WPF provides us with. Let's start by looking at the validation system.</p>
<p>In WPF, the validation system very much revolves around the static <kbd>Validation</kbd> class. This class has several Attached Properties, methods, and an Attached Event that support data validation. Each binding instance has a <kbd>ValidationRules</kbd> collection that can contain <kbd>ValidationRule</kbd> elements.</p>
<p>WPF provides three built-in rules:</p>
<ul>
<li>The <kbd>ExceptionValidationRule</kbd> object checks for any exceptions thrown as the binding source property is updated.</li>
<li>The <kbd>DataErrorValidationRule</kbd> class checks for errors that may be raised by classes that implement the <kbd>IDataErrorInfo</kbd> interface.</li>
<li>The <kbd>NotifyDataErrorValidationRule</kbd> class checks for errors raised by classes that implement the <kbd>INotifyDataErrorInfo</kbd> interface.</li>
</ul>
<p>Each time an attempt is made to update a data source property, the binding engine first clears the <kbd>Validation.Errors</kbd> collection and then checks the binding's <kbd>ValidationRules</kbd> collection to see whether it contains any <kbd>ValidationRule</kbd> elements. If it does, it calls each rule's <kbd>Validate</kbd> method in turn until they all pass, or one returns an error.</p>
<p>When a data bound value fails the condition in the <kbd>Validation</kbd> method of a <kbd>ValidationRule</kbd> element, the binding engine adds a new <kbd>ValidationError</kbd> object to the <kbd>Validation.Errors</kbd> collection of the data binding target control.</p>
<p>This, in turn, will set the <kbd>Validation.HasError</kbd> Attached Property of the element to <kbd>true</kbd> and, if the <kbd>NotifyOnValidationError</kbd> property of the binding is set to <kbd>true</kbd>, the binding engine will also raise the <kbd>Validation.Error</kbd> Attached Event on the data binding target.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using validation rules – to do or not to do?</h1>
                
            
            
                
<p>In WPF, there are two different approaches for dealing with data validation. On the one hand, we have the UI-based <kbd>ValidationRule</kbd> classes, the <kbd>Validation.Error</kbd> Attached Event, and the <kbd>Binding.NotifyOnValidationError</kbd> and <kbd>UpdateSourceExceptionFilter</kbd> properties, and, on the other, we have two code-based validation interfaces.</p>
<p>While the <kbd>ValidationRule</kbd> classes and their related validation approach work perfectly well, they are specified in the XAML and, as such, are tied to the UI. Furthermore, when using the <kbd>ValidationRule</kbd> classes, we are effectively separating the validation logic from the data Models that they are validating and storing it in a completely different assembly.</p>
<p>When developing a WPF application using the MVVM methodology, we work with data, rather than UI elements, and so we tend to shy away from using the <kbd>ValidationRule</kbd> classes and their related validation strategy directly.</p>
<p>Additionally, the <kbd>NotifyOnValidationError</kbd> and <kbd>UpdateSourceExceptionFilter</kbd> properties of the <kbd>Binding</kbd> class also require event or delegate handlers, respectively, and, as we have discovered, we prefer to avoid doing this when using MVVM. Therefore, we will not be looking at this UI-based validation approach in this book, instead focusing on the two code-based validation interfaces.</p>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting to grips with validation interfaces</h1>
                
            
            
                
<p>In WPF, we have access to two main validation interfaces; the original one is the <kbd>IDataErrorInfo</kbd> interface, and, in .NET 4.5, the <kbd>INotifyDataErrorInfo</kbd> interface was added. In this section, we'll first investigate the original validation interface and its shortcomings and see how we can make it more usable, before examining the latter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the IDataErrorInfo interface</h1>
                
            
            
                
<p>The <kbd>IDataErrorInfo</kbd> interface is a very simple affair, with only two required properties to implement. The <kbd>Error</kbd> property returns the error message that describes the validation error, and the <kbd>Item[string]</kbd> indexer returns the error message for the specified property.</p>
<p>It certainly seems straightforward enough, so let's take a look at a basic implementation of this interface. Let's create another base class to implement this in and, for now, omit all other unrelated base class members so that we can concentrate on this interface:</p>
<pre>using System.ComponentModel; 
using System.Runtime.CompilerServices; <br/>using CompanyName.ApplicationName.Extensions;
 
namespace CompanyName.ApplicationName.DataModels 
{ 
  public abstract class BaseValidationModel : INotifyPropertyChanged, 
    IDataErrorInfo 
  { 
    protected string error = string.Empty; 
 
    #region IDataErrorInfo Members 
 
    public string Error =&gt; error; 
 
    public virtual string this[string propertyName] =&gt; error; 
 
    #endregion 
 
    #region INotifyPropertyChanged Members 
 
    ... 
 
    #endregion 
  } 
} </pre>
<p> </p>
<p>In this simplest of implementations, we have declared a protected <kbd>error</kbd> field, which will be accessible to derived classes. Note that the <kbd>Error</kbd> property that returns it uses the C# 6.0 expression-bodied property syntax. This syntax is a shorthand notation for methods, properties, indexers, constructors, and destructors, where the member body is replaced by an inline expression.</p>
<p>We have declared the class indexer (the <kbd>this</kbd> property) as <kbd>virtual</kbd>, so that we can override it in the derived classes. Another option would be to declare it as <kbd>abstract</kbd>, so that derived classes were forced to override it. Whether you prefer to use <kbd>virtual</kbd> or <kbd>abstract</kbd> will depend on your particular circumstances, such as whether you expect every derived class to require validation.</p>
<p>Let's take a look at an example of a class that derives from our new base class:</p>
<pre>using System; 
 
namespace CompanyName.ApplicationName.DataModels 
{ 
  public class Product : BaseValidationModel 
  { 
    private Guid id = Guid.Empty; 
    private string name = string.Empty; 
    private decimal price = 0; 
 
    public Guid Id 
    { 
      get { return id; } 
      set { if (id != value) { id = value; NotifyPropertyChanged(); } } 
    } 
 
    public string Name 
    { 
      get { return name; } 
      set { if (name != value) { name = value; NotifyPropertyChanged(); } }
    } 
 
    public decimal Price 
    { 
      get { return price; } 
      set { if (price != value) { price = value;
        NotifyPropertyChanged(); } } 
    } 
 
    public override string this[string propertyName] 
    { 
      get 
      { 
        error = string.Empty; 
        if (propertyName == nameof(Name)) 
        { 
          if (string.IsNullOrEmpty(Name))  
            error = "Please enter the product name."; 
          else if (Name.Length &gt; 25) error = "The product name cannot be
            longer than twenty-five characters."; 
        } 
        else if (propertyName == nameof(Price) &amp;&amp; Price == 0)
          error = "Please enter a valid price for the product."; 
        return error; 
      } 
    } 
  } 
} </pre>
<p>Here, we have a basic <kbd>Product</kbd> class that extends our new base class. The only job that each derived class that wants to participate in the validation process needs to do is to override the class indexer and supply details regarding their relevant validation logic.</p>
<p>In the indexer, we first set the <kbd>error</kbd> field to an empty string. Note that this is an essential part of this implementation, as without it, any triggered validation errors would never be cleared. There are a number of ways to implement this method, with several different abstractions being possible. However, all implementations require validation logic to be run when this property is called.</p>
<p>In our particular example, we simply use an <kbd>if</kbd> statement to check for errors in each property, although a <kbd>switch</kbd> statement works just as well here. The first condition checks the value of the <kbd>propertyName</kbd> input parameter, while multiple validation rules per property can be handled with inner <kbd>if</kbd> statements.</p>
<p>If the <kbd>propertyName</kbd> input parameter equals <kbd>Name</kbd>, then we first check to ensure that it has some value and provide an error message in case of failure. If the property value is not <kbd>null</kbd> or empty, then a second validation condition checks that the length is no longer than 25 characters, which simulates a particular database constraint that we may have.</p>
<p>If the <kbd>propertyName</kbd> input parameter equals <kbd>Price</kbd>, then we simply check that a valid, positive value has been entered and provide another error message in case of failure. If we had further properties in this class, then we would simply add further <kbd>if</kbd> conditions, checking their property names, and further relevant validation checks.</p>
<p> </p>
<p>Now that we have our validatable class, let's add a new View and View Model and the <kbd>DataTemplate</kbd> in the <kbd>App.xaml</kbd> file that connects the two, to demonstrate what else we need to do to get our validation logic connected to the data in the UI. Let's first see the <kbd>ProductViewModel</kbd> class:</p>
<pre>using CompanyName.ApplicationName.DataModels; 
 
namespace CompanyName.ApplicationName.ViewModels 
{ 
  public class ProductViewModel : BaseViewModel 
  { 
    private Product product = new Product(); 
 
    public Product Product 
    { 
      get { return product; } 
      set { if (product != value) { product = value;  
        NotifyPropertyChanged(); } } 
    } 
  } 
} </pre>
<p>The <kbd>ProductViewModel</kbd> class simply defines a single <kbd>Product</kbd> object and exposes it via the <kbd>Product</kbd> property. Let's now add some basic styles to the application resources file, which we'll use in the related View:</p>
<pre>&lt;Style x:Key="LabelStyle" TargetType="{x:Type TextBlock}"&gt;<br/>  &lt;Setter Property="HorizontalAlignment" Value="Right" /&gt;<br/>  &lt;Setter Property="VerticalAlignment" Value="Center" /&gt; <br/>  &lt;Setter Property="Margin" Value="0,0,10,10" /&gt;<br/>&lt;/Style&gt; <br/>&lt;Style x:Key="FieldStyle" TargetType="{x:Type TextBox}"&gt;<br/>  &lt;Setter Property="SnapsToDevicePixels" Value="True" /&gt;<br/>  &lt;Setter Property="VerticalAlignment" Value="Center" /&gt; <br/>  &lt;Setter Property="Margin" Value="0,0,0,10" /&gt; <br/>  &lt;Setter Property="Padding" Value="1.5,2" /&gt; <br/>&lt;/Style&gt; </pre>
<p>And now, let's see the View:</p>
<pre>&lt;UserControl x:Class="CompanyName.ApplicationName.Views.ProductView"  
   
   
  Width="320" FontSize="14"&gt; <br/>  &lt;Grid Margin="20"&gt;
    &lt;Grid.RowDefinitions&gt; 
      &lt;RowDefinition Height="Auto" /&gt; 
      &lt;RowDefinition Height="Auto" /&gt; 
    &lt;/Grid.RowDefinitions&gt; 
    &lt;Grid.ColumnDefinitions&gt; 
      &lt;ColumnDefinition Width="Auto" /&gt; 
      &lt;ColumnDefinition /&gt; 
    &lt;/Grid.ColumnDefinitions&gt; 
    &lt;TextBlock Text="Name" Style="{StaticResource LabelStyle}" /&gt; 
    &lt;TextBox Grid.Column="1" Text="{Binding Product.Name,  
      UpdateSourceTrigger=PropertyChanged, ValidatesOnDataErrors=True}"
      Style="{StaticResource FieldStyle}" /&gt; 
    &lt;TextBlock Grid.Row="1" Text="Price" 
      Style="{StaticResource LabelStyle}" /&gt; 
    &lt;TextBox Grid.Row="1" Grid.Column="1" Text="{Binding Product.Price,
      UpdateSourceTrigger=PropertyChanged, ValidatesOnDataErrors=True}"
      Style="{StaticResource FieldStyle}" /&gt; 
  &lt;/Grid&gt; 
&lt;/UserControl&gt; </pre>
<p>In the XAML, we have a typical two column <kbd>Grid</kbd> panel, with two rows. The two <kbd>TextBlock</kbd> labels have the <kbd>LabelStyle</kbd> style applied, and the two <kbd>TextBox</kbd> input controls have the <kbd>FieldStyle</kbd> style applied. The binding applied to each <kbd>TextBox.Text</kbd> property has two important properties set on it.</p>
<p>The first is the <kbd>UpdateSourceTrigger</kbd> property, and this controls when the data source is updated and therefore, also when validation occurs. If you remember, a value of <kbd>PropertyChanged</kbd> causes updates to occur as soon as the data bound property value changes. An alternative value would be <kbd>LostFocus</kbd>, which causes updates to occur when the UI control loses focus, for example, when tabbing to the next control. </p>
<p>The other important property here is the <kbd>ValidatesOnDataErrors</kbd> property, without which our current example would not work. Setting this property to <kbd>True</kbd> on a binding causes a built-in <kbd>DataErrorValidationRule</kbd> element to be implicitly added to the <kbd>Binding.ValidationRules</kbd> collection.</p>
<p>As the data bound value changes, this element will check for errors raised by the <kbd>IDataErrorInfo</kbd> interface. It does this by calling the indexer in our data Model, with the name of the data bound property each time the data source is updated. Therefore, in this basic example, developers would be responsible for setting this property to <kbd>True</kbd> on each binding to make the validation work.</p>
<p>In .NET 4.5, Microsoft introduced a breaking change to the way that numeric data is entered in the <kbd>TextBox</kbd> control when the <kbd>UpdateSourceTrigger</kbd> binding is set to <kbd>PropertyChanged</kbd>. Their change stops users from entering numerical separators. Refer to the <em>Keeping Synchronized with Legacy Behavior</em> section later in this chapter to find out why and how to work around this issue.</p>
<p>When using a value of <kbd>PropertyChanged</kbd> for the <kbd>UpdateSourceTrigger</kbd> property, along with the fact that we validate each time the properties change, we have the benefit of immediate updates of errors. However, this method of validation works in a pre-emptive manner, with all validation errors being shown <em>b</em><em>efore</em> the user has a chance to enter any data. This can be somewhat off-putting to a user, so let's take a quick look at our example when it first starts:</p>
<div><img class="alignnone size-full wp-image-2066 image-border" src="img/1bc6e515-3321-4282-9ea5-0f37aff5e791.png" style="width:22.50em;height:10.17em;"/></div>
<p>As you can see, it's clear that there are some problems, but it's unclear as to what they are. So far, we have no output for our error messages. One common output that we could use would be the tooltips of the various form controls.</p>
<p>We could add a trigger to our <kbd>FieldStyle</kbd> style, which listened to the <kbd>Validation.HasError</kbd> Attached Property and set the <kbd>TextBox</kbd> control's tooltip to the <kbd>ErrorContent</kbd> property of the error whenever one was present. This is how Microsoft has traditionally demonstrated how to do this on their website:</p>
<pre>&lt;Style.Triggers&gt; 
  &lt;Trigger Property="Validation.HasError" Value="True"&gt; 
    &lt;Setter Property="ToolTip" Value="{Binding (Validation.Errors)[0]. 
      ErrorContent, RelativeSource={RelativeSource Self}}" /&gt; 
  &lt;/Trigger&gt; 
&lt;/Style.Triggers&gt; </pre>
<p>Note that we use brackets in the binding path for the <kbd>Validation.Errors</kbd> collection because it is an Attached Property, and that we use the <kbd>RelativeSource.Self</kbd> instance because we want to target the <kbd>Errors</kbd> collection of the <kbd>TextBox</kbd> control itself. Also note that this example only displays the first <kbd>ValidationError</kbd> object in the <kbd>Errors</kbd> collection.</p>
<p> </p>
<p>Using this style on our data bound <kbd>TextBox</kbd> controls helps to provide the user with further information when they position their mouse cursor over the relevant control(s):</p>
<div><img class="alignnone size-full wp-image-2067 image-border" src="img/bab6015a-c774-409b-9b26-68a4c7ba4e4c.png" style="width:26.50em;height:10.17em;"/></div>
<p>However, when there are no validation errors to display, an error will be seen in the Output window of Visual Studio, because we are attempting to view the first error from the <kbd>Validation.Errors</kbd> Attached Property collection, but none exist:</p>
<pre><strong>System.Windows.Data Error: 17 : Cannot get 'Item[]' value (type 'ValidationError') from '(Validation.Errors)' (type 'ReadOnlyObservableCollection`1'). BindingExpression:
Path=(Validation.Errors)[0].ErrorContent; DataItem='TextBox' (Name='');
target element is 'TextBox' (Name=''); target property is 'ToolTip' (type 'Object') ArgumentOutOfRangeException: 'System.ArgumentOutOfRangeException: Specified argument was out of the range of valid values.
Parameter name: index'</strong></pre>
<p>There are a number of ways to avoid this error, such as simply displaying the whole collection, and we'll see an example of this later in the chapter. However, the simplest way is to make use of the <kbd>CurrentItem</kbd> property of the <kbd>ICollectionView</kbd> object that is implicitly used to wrap <kbd>IEnumerable</kbd> data collections, which are data bound to <kbd>ItemsControl</kbd> elements.</p>
<p>This is similar to the way that a <kbd>ListBox</kbd> will implicitly wrap our data bound data items in <kbd>ListBoxItem</kbd> elements. The implementation of the <kbd>ICollectionView</kbd> interface that wraps our data collection is primarily used to enable sorting, filtering, and grouping of the data, without affecting the actual data, but its <kbd>CurrentItem</kbd> property is a bonus in this situation.</p>
<p>With this, we can replace the indexer that was causing us a problem when there were no validation errors. Now, when there are no errors, the <kbd>CurrentItem</kbd> property will return <kbd>null</kbd>, rather than throwing an Exception and so, despite Microsoft's own example showing the use of the indexer, this is a far better solution:</p>
<pre>&lt;Setter Property="ToolTip" Value="{Binding (Validation.Errors). 
  CurrentItem.ErrorContent, RelativeSource={RelativeSource Self}}" /&gt; </pre>
<p>Nevertheless, if an end user is not aware of having to place their mouse cursor over the control to see the tooltip, then the situation is still not improved. Therefore, this initial implementation still has room for improvement. Another shortcoming of this interface is that it was designed to be atomic, so it only deals with a single error per property at a time.</p>
<p>In our <kbd>Product</kbd> class example, we want to validate the fact that the <kbd>Name</kbd> property is not only entered, but also has a valid length. In the order that we declared our two validation conditions for this property, the first error will be raised when the field in the UI is empty, and the second will be raised if the entered value is too long. As the entered value cannot be both non-existent and too long at the same time, having only a single reported error at one time is not a problem in this particular example.</p>
<p>However, if we had a property that had multiple validation conditions, such as a maximum length and a particular format, then with the usual <kbd>IDataErrorInfo</kbd> interface implementation, we'd only be able to view one of these errors at once. However, despite this limitation, we can still improve this basic implementation. Let's see how we can do this with a new base class:</p>
<pre>using System.Collections.ObjectModel; 
using System.Collections.Specialized; 
using System.ComponentModel; 
using System.Linq; 
using System.Runtime.CompilerServices; 
using System.Text; 
using CompanyName.ApplicationName.Extensions; 
 
namespace CompanyName.ApplicationName.DataModels 
{ 
  public abstract class BaseValidationModelExtended : 
    INotifyPropertyChanged, IDataErrorInfo 
  { 
    protected ObservableCollection&lt;string&gt; errors =  
      new ObservableCollection&lt;string&gt;(); 
    protected ObservableCollection&lt;string&gt; externalErrors =  
      new ObservableCollection&lt;string&gt;(); 
 
    protected BaseValidationModelExtended() 
    { 
      ExternalErrors.CollectionChanged += ExternalErrors_CollectionChanged; 
    } 
 
    public virtual ObservableCollection&lt;string&gt; Errors =&gt; errors; 
 
    public ObservableCollection&lt;string&gt; ExternalErrors =&gt; externalErrors; 
 
    public virtual bool HasError =&gt; errors != null &amp;&amp; errors.Any(); 
 
    #region IDataErrorInfo Members 
 
    public string Error 
    { 
      get 
      { 
        if (!HasError) return string.Empty; 
        StringBuilder errors = new StringBuilder(); 
        Errors.ForEach(e =&gt; errors.AppendUniqueOnNewLineIfNotEmpty(e)); 
        return errors.ToString(); 
      } 
    } 
 
    public virtual string this[string propertyName] =&gt; string.Empty; 
 
    #endregion 
 
    #region INotifyPropertyChanged Members 
 
    public virtual event PropertyChangedEventHandler PropertyChanged;<br/><br/>    protected virtual void NotifyPropertyChanged( 
      params string[] propertyNames) 
    { 
      if (PropertyChanged != null) 
      { 
        foreach (string propertyName in propertyNames) 
        { 
          if (propertyName != nameof(HasError)) PropertyChanged(this, 
            new PropertyChangedEventArgs(propertyName)); 
        } 
        PropertyChanged(this,  
          new PropertyChangedEventArgs(nameof(HasError))); 
      } 
    } 
 
    protected virtual void NotifyPropertyChanged( 
      [CallerMemberName]string propertyName = "") 
    { 
      if (PropertyChanged != null) 
      { 
        if (propertyName != nameof(HasError)) PropertyChanged(this, 
          new PropertyChangedEventArgs(propertyName)); 
        PropertyChanged(this,
          new PropertyChangedEventArgs(nameof(HasError))); 
      } 
    } 
 
    #endregion 
 
    private void ExternalErrors_CollectionChanged(object sender,  
      NotifyCollectionChangedEventArgs e) =&gt;  
      NotifyPropertyChanged(nameof(Errors)); 
  } 
} </pre>
<p>In this example, we add two collections to hold error messages; the <kbd>Errors</kbd> collection property contains validation errors that are generated within the derived class, and the <kbd>ExternalErrors</kbd> collection property holds externally generated validation errors, typically from a parent View Model.</p>
<p>In the constructor, we attach the <kbd>ExternalErrors_CollectionChanged</kbd> event handler to the <kbd>CollectionChanged</kbd> event of the <kbd>ExternalErrors</kbd> collection property so that it is notified whenever items are added or removed from it.</p>
<p>After the declaration of the error collection properties, we see the <kbd>HasError</kbd> expression-bodied property, which checks whether the <kbd>Errors</kbd> collection contains any errors. Note that we check the <kbd>errors</kbd> field for <kbd>null</kbd>, rather than the <kbd>Errors</kbd> property, because calling the <kbd>Errors</kbd> property regenerates the error messages and we do not want to regenerate them all twice each time the <kbd>HasError</kbd> property is called.</p>
<p>Next, we see the new implementation of the <kbd>IDataErrorInfo</kbd> interface. The class indexer remains the same as the one from the previous implementation, but we see a difference in the definition of the <kbd>Error</kbd> property, which now compiles a complete list of all errors, rather than returning a single error message at a time.</p>
<p>In it, we first check whether any errors exist, and return an empty string if not. If errors do exist, we initialize a <kbd>StringBuilder</kbd> object and use our <kbd>ForEach</kbd> Extension Method to iterate through the <kbd>Errors</kbd> collection and append each of them to it, if they haven't already been included. We do this using another Extension Method before returning the output, so let's see what that looks like now:</p>
<pre>public static void AppendUniqueOnNewLineIfNotEmpty(
  this StringBuilder stringBuilder, string text)
{ 
  if (text.Trim().Length &gt; 0 &amp;&amp; !stringBuilder.ToString().Contains(text))
    stringBuilder.AppendFormat("{0}{1}", stringBuilder.ToString().Trim().
    Length == 0 ? string.Empty : Environment.NewLine, text); 
}</pre>
<p> </p>
<p>In our <kbd>AppendUniqueOnNewLineIfNotEmpty</kbd> Extension Method, we first check that the input value is not an empty string and that it is not already present in the <kbd>StringBuilder</kbd> object. If the <kbd>text</kbd> input parameter is valid, we use the ternary operator to determine whether it is the first value to be added and whether we need to precede it with a new line or not, before adding the new, unique value.</p>
<p>Returning to our validation base class now, we see the new implementation of the <kbd>INotifyPropertyChanged</kbd> interface. Note that we repeat our earlier <kbd>BaseSynchronizableDataModel</kbd> class example by raising the <kbd>PropertyChanged</kbd> event each time changes are registered for any other properties, but, unlike the previous example, we raise the <kbd>HasError</kbd> property here, rather than the <kbd>HasChanges</kbd> property.</p>
<p>We can combine both of these and raise the <kbd>PropertyChanged</kbd> event for both properties each time we receive notification of changes to other properties if we so desire. In this case, the purpose is to call the <kbd>HasError</kbd> property, which will be used in the UI to display or hide the control that displays the error messages, and so it will be updated after every validatable property change.</p>
<p>At the bottom of our class, we see the expression-bodied <kbd>ExternalErrors_CollectionChanged</kbd> method, which calls the <kbd>NotifyPropertyChanged</kbd> method for the <kbd>Errors</kbd> collection property. This notifies controls that are data bound to this property that its value has changed and that they should retrieve that new value.</p>
<p>Let's see an example implementation of this now, using an extended version of our <kbd>Product</kbd> class:</p>
<pre class="mce-root">public class ProductExtended : BaseValidationModelExtended<br/>{<br/>  ...<br/><br/>  public override ObservableCollection&lt;string&gt; Errors<br/>  {<br/>    get<br/>    {<br/>      errors = new ObservableCollection&lt;string&gt;();<br/>      errors.AddUniqueIfNotEmpty(this[nameof(Name)]);<br/>      errors.AddUniqueIfNotEmpty(this[nameof(Price)]);<br/>      errors.AddRange(ExternalErrors);<br/>      return errors;<br/>    }<br/>  }<br/><br/>  ...<br/>}</pre>
<p>Therefore, when an error is externally added to the <kbd>ExternalErrors</kbd> collection, the <kbd>ExternalErrors_CollectionChanged</kbd> method will be called and this notifies changes to the <kbd>Errors</kbd> property. This results in the property being called and the external error(s) being added to the internal <kbd>errors</kbd> collection, along with any internal errors.</p>
<p>To get this particular implementation of the <kbd>IDataErrorInfo</kbd> interface to work, each data Model class will need to override this <kbd>Errors</kbd> property to add error messages from each validated property. We provide a few Extension Methods to make this task easier. As its name implies, the <kbd>AddUniqueIfNotEmpty</kbd> method adds strings to the collection if they do not already exist in it:</p>
<pre>public static void AddUniqueIfNotEmpty(
  this ObservableCollection&lt;string&gt; collection, string text) 
{ 
  if (!string.IsNullOrEmpty(text) &amp;&amp; !collection.Contains(text))  
    collection.Add(text); 
} </pre>
<p>The <kbd>AddRange</kbd> method is another useful Extension Method that simply iterates through the <kbd>range</kbd> collection input parameter and adds them to the <kbd>collection</kbd> parameter one by one:</p>
<pre>public static void AddRange&lt;T&gt;(this ICollection&lt;T&gt; collection,  
  ICollection&lt;T&gt; range) 
{ 
  foreach (T item in range) collection.Add(item); 
} </pre>
<p>In addition to implementing this new <kbd>Errors</kbd> collection property in their derived classes, developers will also need to ensure that they notify changes to it each time a validatable property value is changed. We can do this using our overload of the <kbd>NotifyPropertyChanged</kbd> method that takes multiple values:</p>
<pre>public string Name 
{ 
  get { return name; } 
  set { if (name != value) { name = value;  
    NotifyPropertyChanged(nameof(Name), nameof(Errors)); } } 
} 
 
public decimal Price 
{ 
  get { return price; } 
  set { if (price != value) { price = value;  
    NotifyPropertyChanged(nameof(Price), nameof(Errors)); } } 
}</pre>
<p>The <kbd>Errors</kbd> property is responsible for calling the class indexer with the name of each of the properties that we want to validate. Any error messages that are returned, including those from the <kbd>ExternalErrors</kbd> collection property, are then added to the internal <kbd>errors</kbd> collection.</p>
<p>In effect, we have replicated what the <kbd>Validation</kbd> class and the <kbd>DataErrorValidationRule</kbd> element does in the UI, but in our data Model instead. This means that we no longer have to set the <kbd>ValidatesOnDataErrors</kbd> property to <kbd>True</kbd> on each binding. This is a better solution when using MVVM, as we prefer to work with data, rather than UI elements, and now also have full access to all of the data validation errors in our View Models.</p>
<p>Furthermore, we now have the ability to manually feed in error messages from our View Models to our data Models via the <kbd>ExternalErrors</kbd> collection property. This can be very useful when we need to validate across a collection of data Model objects.</p>
<p>For example, if we need to ensure that the name of each data Model object is unique within a collection of related objects, we can use this feature. Let's now create a new <kbd>ProductViewModelExtended</kbd> class to see how we can accomplish this:</p>
<pre>using System;<br/>using System.ComponentModel;<br/>using System.Linq;<br/>using CompanyName.ApplicationName.DataModels;<br/>using CompanyName.ApplicationName.DataModels.Collections;<br/><br/>namespace CompanyName.ApplicationName.ViewModels<br/>{<br/>  public class ProductViewModelExtended : BaseViewModel<br/>  {<br/>    private ProductsExtended products = new ProductsExtended();<br/><br/>    public ProductViewModelExtended()<br/>    {<br/>      Products.Add(new ProductExtended() { Id = Guid.NewGuid(), <br/>        Name = "Virtual Reality Headset", Price = 14.99m });<br/>      Products.Add(new ProductExtended() { Id = Guid.NewGuid(), <br/>        Name = "Virtual Reality Headset" });<br/>      Products.CurrentItemChanged += Products_CurrentItemChanged;<br/>      Products.CurrentItem = Products.Last();<br/>      ValidateUniqueName(Products.CurrentItem);<br/>    }<br/><br/>    public ProductsExtended Products<br/>    {<br/>      get { return products; }<br/>      set { if (products != value) { products = value; <br/>        NotifyPropertyChanged(); } }<br/>    }<br/><br/>    private void Products_CurrentItemChanged(<br/>      ProductExtended oldProduct, ProductExtended newProduct)<br/>    {<br/>      if (newProduct != null) <br/>        newProduct.PropertyChanged += Product_PropertyChanged;<br/>      if (oldProduct != null) <br/>        oldProduct.PropertyChanged -= Product_PropertyChanged;<br/>    }<br/><br/>    private void Product_PropertyChanged(object sender, <br/>      PropertyChangedEventArgs e)<br/>    {<br/>      if (e.PropertyName == nameof(Products.CurrentItem.Name)) <br/>        ValidateUniqueName(Products.CurrentItem);<br/>    }<br/><br/>    private void ValidateUniqueName(ProductExtended product)<br/>    {<br/>      string errorMessage = "The product name must be unique.";<br/>      if (!IsProductNameUnique(product)) <br/>        product.ExternalErrors.Add(errorMessage);<br/>      else product.ExternalErrors.Remove(errorMessage);<br/>    }<br/><br/>    private bool IsProductNameUnique(ProductExtended product) =&gt; <br/>      !Products.Any(p =&gt; p.Id != product.Id &amp;&amp; <br/>      !string.IsNullOrEmpty(p.Name) &amp;&amp; p.Name == product.Name);<br/>  }<br/>}</pre>
<p>Like the <kbd>ProductViewModel</kbd> class, our <kbd>ProductViewModelExtended</kbd> class also extends the <kbd>BaseViewModel</kbd> class, but it declares a <kbd>ProductsExtended</kbd> collection and adds two <kbd>ProductExtended</kbd> objects to it in the constructor, instead of the single <kbd>Product</kbd> instance used previously. The <kbd>ProductsExtended</kbd> class simply extends our <kbd>BaseCollection</kbd> class:</p>
<pre>namespace CompanyName.ApplicationName.DataModels.Collections 
{ 
  public class ProductsExtended : BaseCollection&lt;ProductExtended&gt; { } 
} </pre>
<p>In the class constructor, we first add a couple of test products to the <kbd>ProductsExtended</kbd> collection and then attach the <kbd>Products_CurrentItemChanged</kbd> method to its <kbd>CurrentItemChanged</kbd> delegate. In order to set the second item as the current item, we call the <kbd>Last</kbd> method on the <kbd>ProductsExtended</kbd> collection and set that to its <kbd>CurrentItem</kbd> property.</p>
<p>This ensures that the <kbd>Products_CurrentItemChanged</kbd> method is called when setting the second item as the current item and the <kbd>Product_PropertyChanged</kbd> handler is attached to it. After this, we then call the <kbd>ValidateUniqueName</kbd> method that is described shortly, passing in the current item.</p>
<p>After the declaration of the <kbd>Products</kbd> property, we see the <kbd>Products_CurrentItemChanged</kbd> method, which will be called each time the value of the <kbd>CurrentItem</kbd> property is changed. In it, we attach the <kbd>Product_PropertyChanged</kbd> method to the <kbd>PropertyChanged</kbd> event of the new, current <kbd>ProductExtended</kbd> object and detach it from the previous one. </p>
<p>The <kbd>Product_PropertyChanged</kbd> method will be called each time any property of the related <kbd>ProductExtended</kbd> object changes. If the property that changed was the <kbd>Name</kbd> property, we call the <kbd>ValidateUniqueName</kbd> method, as that is the property that we need to validate for uniqueness.</p>
<p>The <kbd>ValidateUniqueName</kbd> method is responsible for adding or removing the error from the <kbd>ExternalErrors</kbd> collection property of the <kbd>product</kbd> input parameter. It does this by checking the result of the <kbd>IsProductNameUnique</kbd> method, which does the actual check for uniqueness.</p>
<p>In the expression-bodied <kbd>IsProductNameUnique</kbd> method, we use LINQ to query the <kbd>Products</kbd> collection and find out whether an existing item shares the same name. It does this by checking that each item does not have the same identification number, or, in other words, is not the object being edited, but does have the same name, and that the name is not an empty string.</p>
<p>If any other products that have the same name are found, then the method returns <kbd>false</kbd> and an error is added to the product's <kbd>ExternalErrors</kbd> collection in the <kbd>ValidateUniqueName</kbd> method. Note that we must manually remove this error if the name is found to be unique.</p>
<p>Let's now create a new <kbd>ProductViewExtended</kbd> class, to display these errors better. First, let's add another reusable resource to the application resources file:</p>
<pre>&lt;DataTemplate x:Key="WrapTemplate"&gt;<br/>    &lt;TextBlock Text="{Binding}" TextWrapping="Wrap" /&gt;<br/>&lt;/DataTemplate&gt;</pre>
<p>This <kbd>DataTemplate</kbd> simply displays a <kbd>TextBlock</kbd> control, with its <kbd>Text</kbd> property data bound to the data context of the <kbd>DataTemplate</kbd>, and its <kbd>TextWrapping</kbd> property set to <kbd>Wrap</kbd>, which has the effect of wrapping text that does not fit into the width provided. Now, let's look at the new <kbd>ProductViewExtended</kbd> class that uses this template:</p>
<pre>&lt;UserControl x:Class="CompanyName.ApplicationName.Views.ProductViewExtended"<br/>  <br/>  <br/>  Width="600" FontSize="14"&gt;<br/>  &lt;Grid Margin="20"&gt;<br/>    &lt;Grid.ColumnDefinitions&gt;<br/>      &lt;ColumnDefinition /&gt;<br/>      &lt;ColumnDefinition /&gt;<br/>    &lt;/Grid.ColumnDefinitions&gt;<br/>    &lt;ListBox ItemsSource="{Binding Products}" SelectedItem="{Binding <br/>      Products.CurrentItem}" DisplayMemberPath="Name" Margin="0,0,20,0" /&gt;<br/>    &lt;Grid Grid.Column="1"&gt;<br/>      &lt;Grid.RowDefinitions&gt;<br/>        &lt;RowDefinition Height="Auto" /&gt;<br/>        &lt;RowDefinition Height="Auto" /&gt;<br/>        &lt;RowDefinition Height="Auto" /&gt;<br/>      &lt;/Grid.RowDefinitions&gt;<br/>      &lt;Grid.ColumnDefinitions&gt;<br/>        &lt;ColumnDefinition Width="Auto" /&gt;<br/>        &lt;ColumnDefinition /&gt;<br/>      &lt;/Grid.ColumnDefinitions&gt;<br/>      &lt;Border Grid.ColumnSpan="2" BorderBrush="Red" BorderThickness="2" <br/>        Background="#1FFF0000" CornerRadius="5" Visibility="{Binding <br/>        Products.CurrentItem.HasError, Converter={StaticResource <br/>        BoolToVisibilityConverter}}" Margin="0,0,0,10" Padding="10"&gt;<br/>        &lt;ItemsControl ItemsSource="{Binding Products.CurrentItem.Errors}" <br/>          ItemTemplate="{StaticResource WrapTemplate}" /&gt;<br/>      &lt;/Border&gt;<br/>      &lt;TextBlock Grid.Row="1" Text="Name" <br/>        Style="{StaticResource LabelStyle}" /&gt;<br/>      &lt;TextBox Grid.Row="1" Grid.Column="1" Text="{Binding <br/>        Products.CurrentItem.Name, UpdateSourceTrigger=PropertyChanged}" <br/>        Style="{StaticResource FieldStyle}" /&gt; <br/>      &lt;TextBlock Grid.Row="2" Text="Price" <br/>        Style="{StaticResource LabelStyle}" /&gt;<br/>      &lt;TextBox Grid.Row="2" Grid.Column="1" <br/>        Text="{Binding Products.CurrentItem.Price, Delay=250, <br/>        UpdateSourceTrigger=PropertyChanged}" <br/>        Style="{StaticResource FieldStyle}" /&gt;<br/>    &lt;/Grid&gt;<br/>  &lt;/Grid&gt;<br/>&lt;/UserControl&gt;</pre>
<p>In this example, we now have a <kbd>Grid</kbd> panel with two columns. In the left column, we have a <kbd>ListBox</kbd> control, and, in the right column, we have another <kbd>Grid</kbd> panel containing our form fields. The <kbd>ItemsSource</kbd> property of the <kbd>ListBox</kbd> control is data bound to the <kbd>Products</kbd> collection property from our View Model, and the <kbd>SelectedItem</kbd> property is data bound to its <kbd>CurrentItem</kbd> property.</p>
<p class="mce-root">We set the <kbd>DisplayMemberPath</kbd> property to <kbd>Name</kbd>, to output the name of each product, as a shortcut for creating a <kbd>DataTemplate</kbd> for our <kbd>Product</kbd> class. Alternatively, we could have returned the value of the <kbd>Name</kbd> property from the <kbd>ToString</kbd> method in our <kbd>Product</kbd> class to achieve the same visual result, although that would not update in the UI when the property value changed.</p>
<p>In the <kbd>Grid</kbd> panel on the right, we declare three rows and, in the top one, we define a <kbd>Border</kbd> element containing an <kbd>ItemsControl</kbd> object. Its <kbd>ItemsSource</kbd> property is data bound to the <kbd>Errors</kbd> collection property of the item that is set to the <kbd>CurrentItem</kbd> property of the <kbd>Products</kbd> collection, and its <kbd>ItemTemplate</kbd> property is set to our new <kbd>WrapTemplate</kbd> data template. The <kbd>Visibility</kbd> property of the border is data bound to the item's <kbd>HasError</kbd> property using the <kbd>BoolToVisibilityConverter</kbd> instance from the application resources.</p>
<p>Therefore, when a change is made to a validated property of the item and an error is raised in our validation base class, the <kbd>PropertyChanged</kbd> event is raised for the <kbd>HasError</kbd> property and this alerts this binding to check the latest value and update its visibility value via the applied <kbd>BoolToVisibilityConverter</kbd> instance accordingly.</p>
<p>Note that we use <kbd>ItemsControl</kbd> here, because with this collection, we have no need for the extra features that the <kbd>ListBox</kbd> control provides us with, such as a border, or the notion of a selected item. The two rows underneath the error output contain the form fields from the <kbd>ProductView</kbd> example.</p>
<p>When this example is run, we'll see two items that have the same name in our <kbd>ListBox</kbd> control. As such, there will already be a validation error displayed that highlights this fact and that was added through the <kbd>ExternalErrors</kbd> collection in the View Model.</p>
<p>In addition to this, we'll see another error, highlighting the fact that a valid price needs to be entered:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a201f297-20ff-44d8-b547-58b55ccb45c2.png" style="width:32.42em;height:10.67em;"/></p>
<p>As the <kbd>UpdateSourceTrigger</kbd> property of the field bindings have been set to <kbd>PropertyChanged</kbd> and the data bound properties are validated straight away, the errors will immediately disappear and/or reappear as soon as we type in the relevant form fields. This setting, along with the fact that we validate each time the properties change, makes our validation work in a pre-emptive manner.</p>
<p>We can also change this to work only when a user presses a submit button by setting the <kbd>UpdateSourceTrigger</kbd> property to the <kbd>Explicit</kbd> value. However, this requires that we access the data bound controls in the code behind files and so we tend to avoid this approach when using the MVVM methodology:</p>
<pre>BindingExpression bindingExpression =  
  NameOfTextBox.GetBindingExpression(TextBox.TextProperty); 
bindingExpression.UpdateSource(); </pre>
<p>Alternatively, if we wanted to validate in this way when using MVVM, we could simply call the validation code when the command that is data bound to the submit or save button is executed instead. Let's now take a look at the <kbd>INotifyDataErrorInfo</kbd> interface to see how it differs from the <kbd>IDataErrorInfo</kbd> interface.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing the INotifyDataErrorInfo interface</h1>
                
            
            
                
<p>The <kbd>INotifyDataErrorInfo</kbd> interface was added to the .NET Framework in .NET 4.5 to address concerns over the previous <kbd>IDataErrorInfo</kbd> interface. Like the <kbd>IDataErrorInfo</kbd> interface, the <kbd>INotifyDataErrorInfo</kbd> interface is also a simple affair, with only three members for us to implement.</p>
<p>With this interface, we now have a <kbd>HasErrors</kbd> property, which indicates whether the relevant data Model instance has any errors, a <kbd>GetErrors</kbd> method that retrieves the object's error collection, and an <kbd>ErrorsChanged</kbd> event to raise when the entity's errors change. We can see straight away that this interface was designed to work with multiple errors, unlike the <kbd>IDataErrorInfo</kbd> interface. Now, let's take a look at an implementation of this:</p>
<pre>using System;<br/>using System.Collections;<br/>using System.Collections.Generic;<br/>using System.Collections.ObjectModel;<br/>using System.ComponentModel;<br/>using System.Linq;<br/>using System.Runtime.CompilerServices;<br/>using CompanyName.ApplicationName.Extensions;<br/><br/>namespace CompanyName.ApplicationName.DataModels<br/>{<br/>  public abstract class BaseNotifyValidationModel : INotifyPropertyChanged, <br/>    INotifyDataErrorInfo<br/>  {<br/>    protected Dictionary&lt;string, List&lt;string&gt;&gt; AllPropertyErrors { get; } =<br/>      new Dictionary&lt;string, List&lt;string&gt;&gt;();<br/><br/>    public ObservableCollection&lt;string&gt; Errors =&gt; <br/>      new ObservableCollection&lt;string&gt;(<br/>      AllPropertyErrors.Values.SelectMany(e =&gt; e).Distinct());<br/><br/>    public abstract IEnumerable&lt;string&gt; this[string propertyName] { get; }<br/><br/>    public void NotifyPropertyChangedAndValidate(<br/>      params string[] propertyNames)<br/>    {<br/>      foreach (string propertyName in propertyNames) <br/>        NotifyPropertyChangedAndValidate(propertyName);<br/>    }<br/><br/>    public void NotifyPropertyChangedAndValidate(<br/>      [CallerMemberName]string propertyName = "")<br/>    {<br/>      NotifyPropertyChanged(propertyName);<br/>      Validate(propertyName);<br/>    }<br/><br/>    public void Validate(string propertyName)<br/>    {<br/>      UpdateErrors(propertyName, this[propertyName]);<br/>    }<br/><br/>    private void UpdateErrors(string propertyName, <br/>      IEnumerable&lt;string&gt; errors)<br/>    {<br/>      if (errors.Any())<br/>      {<br/>        if (AllPropertyErrors.ContainsKey(propertyName)) <br/>          AllPropertyErrors[propertyName].Clear();<br/>        else AllPropertyErrors.Add(propertyName, new List&lt;string&gt;());<br/>        AllPropertyErrors[propertyName].AddRange(errors);<br/>        OnErrorsChanged(propertyName);<br/>      }<br/>      else<br/>      {<br/>        if (AllPropertyErrors.ContainsKey(propertyName)) <br/>          AllPropertyErrors.Remove(propertyName);<br/>        OnErrorsChanged(propertyName);<br/>      }<br/>    }<br/><br/>    #region INotifyDataErrorInfo Members<br/><br/>    public event EventHandler&lt;DataErrorsChangedEventArgs&gt; ErrorsChanged;<br/><br/>    protected void OnErrorsChanged(string propertyName)<br/>    {<br/>      ErrorsChanged?.Invoke(this, <br/>        new DataErrorsChangedEventArgs(propertyName));<br/>      NotifyPropertyChanged(nameof(Errors), nameof(HasErrors));<br/>    }<br/><br/>    public IEnumerable GetErrors(string propertyName)<br/>    {<br/>      List&lt;string&gt; propertyErrors = new List&lt;string&gt;();<br/>      if (string.IsNullOrEmpty(propertyName)) return propertyErrors;<br/>      AllPropertyErrors.TryGetValue(propertyName, out propertyErrors);<br/>      return propertyErrors;<br/>    }<br/><br/>    public bool HasErrors =&gt; <br/>      AllPropertyErrors.Any(p =&gt; p.Value != null &amp;&amp; p.Value.Any());<br/><br/>    #endregion<br/><br/>    #region INotifyPropertyChanged Members<br/><br/>    public virtual event PropertyChangedEventHandler PropertyChanged;<br/><br/>    protected virtual void NotifyPropertyChanged(<br/>      params string[] propertyNames)<br/>    {<br/>      if (PropertyChanged != null) propertyNames.ForEach(<br/>        p =&gt; PropertyChanged(this, new PropertyChangedEventArgs(p)));<br/>    }<br/><br/>    protected virtual void NotifyPropertyChanged(<br/>      [CallerMemberName]string propertyName = "")<br/>    {<br/>      PropertyChanged?.Invoke(this, <br/>        new PropertyChangedEventArgs(propertyName));<br/>    }<br/><br/>    #endregion<br/>  }<br/>}</pre>
<p>In our first implementation, we see the declaration of the read-only <kbd>AllPropertyErrors</kbd> auto property, initialized to a new instance. For this collection, we use the <kbd>Dictionary&lt;string, List&lt;string&gt;&gt;</kbd> type, where the name of each property in error is used as the dictionary key, and multiple errors for that property can be stored in the related <kbd>string</kbd> list.</p>
<p>We then see the read-only, expression-bodied <kbd>Errors</kbd> property, which will hold the <kbd>string</kbd> collection of errors to be displayed in the UI. It is set to return a compilation of unique errors from the <kbd>AllPropertyErrors</kbd> collection. Next, we find an abstract <kbd>string</kbd> indexer that returns an <kbd>IEnumerable</kbd> of the <kbd>string</kbd> type, which is responsible for returning multiple validation errors from derived classes that relate to the property specified by the <kbd>propertyName</kbd> input parameter. We'll see how we can implement this property in a derived class shortly.</p>
<p>After that, we add two convenient <kbd>NotifyPropertyChangedAndValidate</kbd> methods, which we can use to both provide notification of changes to our property and to validate it in a single operation. In these methods, we call our implementation of the <kbd>NotifyPropertyChanged</kbd> method and then our <kbd>Validate</kbd> method, passing the relevant property name to each of them.</p>
<p>In the <kbd>Validate</kbd> method, we call the <kbd>UpdateErrors</kbd> method, passing in the <kbd>propertyName</kbd> input parameter and the related errors for the specified property, returned from the <kbd>this</kbd> indexer property. In the <kbd>UpdateErrors</kbd> method, we begin by checking whether there are any errors in the collection specified by the <kbd>errors</kbd> input parameter.</p>
<p>If there are, and it does contain some, we clear the errors for the relevant property from the <kbd>AllPropertyErrors</kbd> collection, or initialize a new entry for the property, with an empty collection otherwise. We then add the incoming errors to the <kbd>AllPropertyErrors</kbd> collection for the relevant property and call the <kbd>OnErrorsChanged</kbd> method to raise the <kbd>ErrorsChanged</kbd> event.</p>
<p>If there are no errors in the collection specified by the <kbd>errors</kbd> input parameter, we remove all previous entries from the <kbd>AllPropertyErrors</kbd> collection for the relevant property, after first validating that some exist, so as to avoid an Exception being thrown. We then call the <kbd>OnErrorsChanged</kbd> method to raise the <kbd>ErrorsChanged</kbd> event to notify changes to the collection.</p>
<p>Next, we see the required <kbd>INotifyDataErrorInfo</kbd> interface members. We declare the <kbd>ErrorsChanged</kbd> event for internal use only and the related <kbd>OnErrorsChanged</kbd> method that raises it using the null conditional operator, although this method is not technically part of the interface and we are free to raise the event as we see fit. After raising the event, we notify the system of changes to the <kbd>Errors</kbd> and <kbd>HasErrors</kbd> properties, to refresh the error collection, and to update the UI of any changes.</p>
<p>In the <kbd>GetErrors</kbd> method, we are required to return the errors for the <kbd>propertyName</kbd> input parameter. We start by initializing the <kbd>propertyErrors</kbd> collection, which we return immediately if the <kbd>propertyName</kbd> input parameter is <kbd>null</kbd>, or empty. Otherwise, we use the <kbd>TryGetValue</kbd> method to populate the <kbd>propertyErrors</kbd> collection with the errors that relate to the <kbd>propertyName</kbd> input parameter from the <kbd>AllPropertyErrors</kbd> collection. We then return the <kbd>propertyErrors</kbd> collection.</p>
<p>The simplified <kbd>HasErrors</kbd> expression-bodied property follows and simply returns <kbd>true</kbd> if the <kbd>AllPropertyErrors</kbd> collection property contains any errors, or <kbd>false</kbd> otherwise. We complete the class with our default implementation of the <kbd>INotifyPropertyChanged</kbd> interface. Note that we can simply omit this if we intend this base class to extend another with its own implementation of this interface.</p>
<p>Let's copy our earlier <kbd>Product</kbd> class so as to create a new <kbd>ProductNotify</kbd> class that extends our new base class. Apart from the class name and the collection of errors, we need to make a number of changes. Let's look at these now:</p>
<pre>using System;<br/>using System.Collections.Generic;<br/><br/>namespace CompanyName.ApplicationName.DataModels<br/>{<br/>  public class ProductNotify : BaseNotifyValidationModel<br/>  {<br/>    ...<br/><br/>    public string Name<br/>    {<br/>      get { return name; }<br/>      set { if (name != value) { name = value; <br/>        NotifyPropertyChangedAndValidate(); } }<br/>    }<br/><br/>    public decimal Price<br/>    {<br/>      get { return price; }<br/>      set { if (price != value) { price = value; <br/>        NotifyPropertyChangedAndValidate(); } }<br/>    }<br/><br/>    public override IEnumerable&lt;string&gt; this[string propertyName]<br/>    {<br/>      get<br/>      {<br/>        List&lt;string&gt; errors = new List&lt;string&gt;();<br/>        if (propertyName == nameof(Name))<br/>        {<br/>          if (string.IsNullOrEmpty(Name)) <br/>            errors.Add("Please enter the product name.");<br/>          else if (Name.Length &gt; 25) errors.Add("The product name cannot<br/>            be longer than twenty-five characters.");<br/>          if (Name.Length &gt; 0 &amp;&amp; char.IsLower(Name[0])) errors.Add("The <br/>            first letter of the product name must be a capital letter.");<br/>        }<br/>        else if (propertyName == nameof(Price) &amp;&amp; Price == 0) <br/>          errors.Add("Please enter a valid price for the product.");<br/>        return errors;<br/>      }<br/>    }<br/>  }<br/>}</pre>
<p>The main differences between the <kbd>ProductNotify</kbd> and <kbd>Product</kbd> classes relate to the base class, the notification method used, and the handling of multiple concurrent errors. We start by extending our new <kbd>BaseNotifyValidationModel</kbd> base class. Each property, with the Exception of the <kbd>Id</kbd> property, which requires no validation, now calls the <kbd>NotifyPropertyChangedAndValidate</kbd> method from the new base class, instead of the <kbd>NotifyPropertyChanged</kbd> method from the <kbd>BaseValidationModel</kbd> class.</p>
<p>In addition to that, the <kbd>this</kbd> indexer property can now report multiple errors simultaneously, rather than the single error that the <kbd>BaseValidationModel</kbd> class could work with. As such, it now declares a <kbd>string</kbd> list to hold the errors, with each valid error being added to it in turn. The final difference is that we have also added a new error, which validates the fact that the first letter of the product name should start with a capital letter.</p>
<p>Let's now see our <kbd>ProductNotifyViewModel</kbd> class:</p>
<pre>using System;<br/>using System.Linq;<br/>using CompanyName.ApplicationName.DataModels;<br/>using CompanyName.ApplicationName.DataModels.Collections;<br/><br/>namespace CompanyName.ApplicationName.ViewModels<br/>{<br/>  public class ProductNotifyViewModel : BaseViewModel<br/>  {<br/>    private ProductsNotify products = new ProductsNotify();<br/><br/>    public ProductNotifyViewModel()<br/>    {<br/>      Products.Add(new ProductNotify() { Id = Guid.NewGuid(), <br/>        Name = "Virtual Reality Headset", Price = 14.99m });<br/>      Products.Add(new ProductNotify() { Id = Guid.NewGuid(), <br/>        Name = "Virtual Reality Headset" });<br/>      Products.CurrentItem = Products.Last();<br/>      Products.CurrentItem.Validate(nameof(Products.CurrentItem.Name));<br/>      Products.CurrentItem.Validate(nameof(Products.CurrentItem.Price));<br/>    }<br/><br/>    public ProductsNotify Products<br/>    {<br/>      get { return products; }<br/>      set { if (products != value) { products = value; <br/>        NotifyPropertyChanged(); } }<br/>    }<br/>  }<br/>}</pre>
<p>We start our <kbd>ProductNotifyViewModel</kbd> View Model by extending our usual <kbd>BaseViewModel</kbd> base class. We declare a <kbd>ProductsNotify</kbd> collection and, in the constructor, we populate it with two <kbd>ProductNotify</kbd> objects, with the same property values that were used in the <kbd>ProductViewModelExtended</kbd> class example. We again call the <kbd>Last</kbd> method on the <kbd>ProductsNotify</kbd> collection and set that last element to its <kbd>CurrentItem</kbd> property to pre-select the second item in the UI.</p>
<p class="mce-root"/>
<p>We then call the <kbd>Validate</kbd> method twice on the object set to the <kbd>CurrentItem</kbd> property, passing in the <kbd>Name</kbd> and <kbd>Price</kbd> properties, using the <kbd>nameof</kbd> operator for correctness. The class ends with the standard declaration of the <kbd>Products</kbd> property. Note that the <kbd>ProductsNotify</kbd> class simply extends our <kbd>BaseCollection</kbd> class, just like our <kbd>Products</kbd> class did:</p>
<pre>namespace CompanyName.ApplicationName.DataModels.Collections<br/>{<br/>  public class ProductsNotify : BaseCollection&lt;ProductNotify&gt; { }<br/>}</pre>
<p>Also note that if we removed the call to the <kbd>Validate</kbd> method from the constructor, this implementation would no longer work in a pre-emptive manner. It would instead initially hide any pre-existing validation errors, such as empty required values, until the user makes changes and there is a problem. Therefore, empty required values would never cause an error to be raised, unless a value was entered and then deleted, to once again be empty.</p>
<p>To address this, we could instead declare a <kbd>ValidateAllProperties</kbd> method that our View Models can call to force a new validation pass, either pre-emptively, before the user has a chance to enter any data, or on the click of a save button, once all fields have been filled. We'll see an example of this later in this chapter, but for now, let's see the XAML of our <kbd>ProductNotifyView</kbd> class:</p>
<pre>&lt;UserControl x:Class="CompanyName.ApplicationName.Views.ProductNotifyView"<br/>  <br/>  <br/>  Width="600" FontSize="14"&gt;<br/>  &lt;Grid Margin="20"&gt;<br/>    &lt;Grid.Resources&gt;<br/>      &lt;DataTemplate x:Key="ProductTemplate"&gt;<br/>        &lt;TextBlock Text="{Binding Name, <br/>          ValidatesOnNotifyDataErrors=False}" /&gt;<br/>      &lt;/DataTemplate&gt;<br/>    &lt;/Grid.Resources&gt;<br/>    &lt;Grid.ColumnDefinitions&gt;<br/>      &lt;ColumnDefinition /&gt;<br/>      &lt;ColumnDefinition /&gt;<br/>    &lt;/Grid.ColumnDefinitions&gt;<br/>    &lt;ListBox ItemsSource="{Binding Products}" <br/>      SelectedItem="{Binding Products.CurrentItem}" <br/>      ItemTemplate="{StaticResource ProductTemplate}" Margin="0,0,20,0" /&gt;<br/>    &lt;Grid Grid.Column="1"&gt;<br/>      &lt;Grid.RowDefinitions&gt;<br/>        &lt;RowDefinition Height="Auto" /&gt;<br/>        &lt;RowDefinition Height="Auto" /&gt;<br/>        &lt;RowDefinition Height="Auto" /&gt;<br/>      &lt;/Grid.RowDefinitions&gt;<br/>      &lt;Grid.ColumnDefinitions&gt;<br/>        &lt;ColumnDefinition Width="Auto" /&gt;<br/>        &lt;ColumnDefinition /&gt;<br/>      &lt;/Grid.ColumnDefinitions&gt;<br/>      &lt;Border Grid.ColumnSpan="2" BorderBrush="Red" <br/>        BorderThickness="2" Background="#1FFF0000" CornerRadius="5" <br/>        Visibility="{Binding Products.CurrentItem.HasErrors, <br/>        Converter={StaticResource BoolToVisibilityConverter}}" <br/>        Margin="0,0,0,10" Padding="10"&gt;<br/>        &lt;ItemsControl ItemsSource="{Binding Products.CurrentItem.Errors}" <br/>          ItemTemplate="{StaticResource WrapTemplate}" /&gt;<br/>      &lt;/Border&gt;<br/>      &lt;TextBlock Grid.Row="1" Text="Name" <br/>        Style="{StaticResource LabelStyle}" /&gt;<br/>      &lt;TextBox Grid.Row="1" Grid.Column="1" <br/>        Text="{Binding Products.CurrentItem.Name, <br/>        UpdateSourceTrigger=PropertyChanged, <br/>        ValidatesOnNotifyDataErrors=True}" <br/>        Style="{StaticResource FieldStyle}" /&gt;<br/>      &lt;TextBlock Grid.Row="2" Text="Price" <br/>        Style="{StaticResource LabelStyle}" /&gt;<br/>      &lt;TextBox Grid.Row="2" Grid.Column="1" <br/>        Text="{Binding Products.CurrentItem.Price, <br/>        UpdateSourceTrigger=PropertyChanged, <br/>        ValidatesOnNotifyDataErrors=True, Delay=250}" <br/>        Style="{StaticResource FieldStyle}" /&gt;<br/>    &lt;/Grid&gt;<br/>  &lt;/Grid&gt;<br/>&lt;/UserControl&gt;</pre>
<p>In the <kbd>Resources</kbd> section, we have declared a new <kbd>DataTemplate</kbd> element, named <kbd>ProductTemplate</kbd>. This just displays the value of the <kbd>Name</kbd> property, but importantly, with the binding’s <kbd>ValidatesOnNotifyDataErrors</kbd> property set to <kbd>False</kbd>, so that no error template is displayed within the <kbd>ListBoxItem</kbd> elements.</p>
<p>Another point to note is that the <kbd>Visibility</kbd> property of the global error display's border has now been updated to work with the new <kbd>HasErrors</kbd> property from the <kbd>INotifyDataErrorInfo</kbd> interface, rather than the <kbd>HasError</kbd> property from our previous <kbd>BaseValidationModelExtended</kbd> class.</p>
<p>The only other change was made to the <kbd>Text</kbd> property binding of the two <kbd>TextBox</kbd> controls; when using the <kbd>INotifyDataErrorInfo</kbd> interface, instead of setting the <kbd>ValidatesOnDataErrors</kbd> property to <kbd>True</kbd> as before, we now need to set the <kbd>ValidatesOnNotifyDataErrors</kbd> property to <kbd>True</kbd>.</p>
<p>We'll update this example again shortly, but before that, let's explore another method of providing validation logic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Annotating data</h1>
                
            
            
                
<p>The .NET Framework also provides us with an alternative, attribute-based validation system in the <kbd>System.ComponentModel.DataAnnotations</kbd> namespace. It is mostly comprised of a wide range of attribute classes that we can decorate our data Model properties with so as to specify our validation rules. In addition to these attributes, it also includes a few validation classes, which we will investigate later.</p>
<p>As an example, let's look at replicating the current validation rules from our <kbd>ProductNotify</kbd> class with these data annotation attributes. We need to corroborate the fact that the <kbd>Name</kbd> property is entered and has a length of 25 characters or less, and that the <kbd>Price</kbd> property is more than zero. For the <kbd>Name</kbd> property, we can use the <kbd>RequiredAttribute</kbd> and the <kbd>MaxLengthAttribute</kbd> attributes:</p>
<pre>using System.ComponentModel.DataAnnotations;<br/><br/>...<br/><br/>[Required(ErrorMessage = "Please enter the product name.")] 
[MaxLength(25, ErrorMessage = "The product name cannot be longer than  
  twenty-five characters.")] 
public string Name 
{ 
  get { return name; } 
  set { if (name != value) { name = value; 
    NotifyPropertyChangedAndValidate(); } } 
}</pre>
<p>As with all attributes, we can omit the word <kbd>Attribute</kbd> when using them to decorate properties. Most of these data annotation attributes declare one or more constructors with a number of optional parameters. The <kbd>ErrorMessage</kbd> input parameter is used in each to set the message to output when the specified condition is not met.</p>
<p>The <kbd>RequiredAttribute</kbd> constructor has no input parameters and simply checks that the data bound value is not <kbd>null</kbd> or empty. The constructor of the <kbd>MaxLengthAttribute</kbd> class takes an integer that specifies the maximum allowable length of the data bound value and it will raise a <kbd>ValidationError</kbd> instance if the input value is longer.</p>
<p> </p>
<p>For the <kbd>Price</kbd> property, we can make use of the <kbd>RangeAttribute</kbd> with a really high maximum value, as there is no <kbd>MinimumAttribute</kbd> class available:</p>
<pre>[Range(0.01, (double)decimal.MaxValue,  
  ErrorMessage = "Please enter a valid price for the product.")] 
public decimal Price 
{ 
  get { return price; } 
  set { if (price != value) { price = value; 
    NotifyPropertyChangedAndValidate(); } } 
} </pre>
<p>The constructor of the <kbd>RangeAttribute</kbd> class takes two <kbd>double</kbd> values, which specify the minimum and maximum valid values, and, in this example, we set the minimum to one penny and the maximum to the maximum <kbd>decimal</kbd> value, as our <kbd>Price</kbd> property is of the <kbd>decimal</kbd> type. Note that we could not use the <kbd>RequiredAttribute</kbd> class here, as numeric data bound values will never be <kbd>null</kbd> or empty.</p>
<p>There are a large number of these data annotation attribute classes, covering the most common validation situations, but when we have a requirement that does not have a pre-existing attribute to help us, we can create our own custom attribute by extending the <kbd>ValidationAttribute</kbd> class. Let's create an attribute that only validates a minimum value:</p>
<pre>using System.ComponentModel.DataAnnotations; 
 
namespace CompanyName.ApplicationName.DataModels.Attributes 
{ 
  public class MinimumAttribute : ValidationAttribute 
  { 
    private double minimumValue = 0.0; 
 
    public MinimumAttribute(double minimumValue) 
    { 
      this.minimumValue = minimumValue; 
    } 
 
    protected override ValidationResult IsValid(object value,  
      ValidationContext validationContext) 
    { 
      if (value.GetType() != typeof(decimal) || 
        (decimal)value &lt; (decimal)minimumValue) 
      { 
        string[] memberNames =  
          new string[] { validationContext.MemberName }; 
        return new ValidationResult(ErrorMessage, memberNames); 
      } 
      return ValidationResult.Success; 
    } 
  } 
} </pre>
<p>When we extend the <kbd>ValidationAttribute</kbd> class, we only need to override the <kbd>IsValid</kbd> method to return <kbd>true</kbd> or <kbd>false</kbd>, depending on our input value, which is specified by the <kbd>value</kbd> input parameter. In our simple example, we first declare the <kbd>minimumValue</kbd> field to store the target minimum allowable value to use during validation.</p>
<p>We populate this field in the class constructor, with the value that users of our class provide. Next, we override the <kbd>IsValid</kbd> method that returns a <kbd>ValidationResult</kbd> instance. In this method, we first check the type of the <kbd>value</kbd> input parameter and then cast it to <kbd>decimal</kbd>, in order to compare it with the value of our <kbd>minimumValue</kbd> field.</p>
<p>Note that we have hardcoded this <kbd>double</kbd> type as the type of our minimum value, because although our <kbd>Price</kbd> property is <kbd>decimal</kbd>, the <kbd>decimal</kbd> type is not considered primitive and therefore cannot be used in an attribute. A better, more reusable solution, would be to declare a number of constructors that accept different numerical types that could be used in a wider range of situations and to update our <kbd>IsValid</kbd> method to be able to compare the different types with the input value.</p>
<p>In our example, if the input value is either the incorrect type, or the cast value is less than the value of the <kbd>minimumValue</kbd> field, we first create the <kbd>memberNames</kbd> variable and insert the value of the <kbd>MemberName</kbd> property from the <kbd>validationContext</kbd> input parameter. We then return a new instance of the <kbd>ValidationResult</kbd> class, inputting the used error message and our <kbd>memberNames</kbd> collection.</p>
<p>If the input value is valid according to our particular validation logic, then we simply return the <kbd>ValidationResult.Success</kbd> field to signify successful validation. Let's now look at our new attribute being used on the <kbd>Price</kbd> property of our <kbd>ProductNotify</kbd> class:</p>
<pre>[Minimum(0.01, 
  ErrorMessage = "Please enter a valid price for the product.")] 
public decimal Price 
{ 
  get { return price; } 
  set { if (price != value) { price = value;  
    NotifyPropertyChangedAndValidate(); } } 
} </pre>
<p> </p>
<p>In effect, our new attribute will work exactly as the previously used <kbd>RangeAttribute</kbd> instance, but it clearly demonstrates how we can create our own custom validation attributes. Before we move on to see how we can read these errors with our code, let's first see how we can access the value of a second property from the data Model in our attribute, as this is a common requirement when validating:</p>
<pre>PropertyInfo propertyInfo =  
  validationContext.ObjectType.GetProperty(otherPropertyName); 
if (propertyInfo == null) throw new ArgumentNullException( 
  $"Unknown property: {otherPropertyName}"); 
object otherPropertyValue =  
  propertyInfo.GetValue(validationContext.ObjectInstance); </pre>
<p>This example assumes that we have added a reference to the <kbd>System</kbd> and <kbd>System.Reflection</kbd> namespaces and declared a <kbd>string</kbd> field named <kbd>otherPropertyName</kbd>, which is populated with the name of the other property name in the constructor. Using reflection, we attempt to access the <kbd>PropertyInfo</kbd> object that relates to the specified property name.</p>
<p>If the <kbd>PropertyInfo</kbd> object is <kbd>null</kbd>, we throw an <kbd>ArgumentNullException</kbd> object, alerting the developer that they have used a non-existent property name. Otherwise, we use the <kbd>GetValue</kbd> method of the <kbd>PropertyInfo</kbd> object to retrieve the value from the other property.</p>
<p>Now that we've seen how to use and create our own custom validation attributes, let's see how we can use them to validate our data Model instances from one of their base classes:</p>
<pre>ValidationContext validationContext = new ValidationContext(this);
List&lt;ValidationResult&gt; validationResults = new List&lt;ValidationResult&gt;(); 
Validator.TryValidateObject(this, validationContext, validationResults,  
  true); </pre>
<p>We start by initializing a <kbd>ValidationContext</kbd> object, passing in the data Model instance from the base class. The context object is then passed to the <kbd>TryValidateObject</kbd> method of the <kbd>Validator</kbd> class, in order to retrieve any validation errors from any of the data annotation attributes.</p>
<p>We also initialize and pass a list of the <kbd>ValidationResult</kbd> type to the <kbd>TryValidateObject</kbd> method, which will get filled with errors for the current data object. Note that the fourth <kbd>bool</kbd> input parameter of this method specifies whether it will return errors for all properties, or just for those that have been decorated with <kbd>RequiredAttribute</kbd> from the data annotations namespace.</p>
<p>Later, we'll see how we can incorporate this into our application framework's validation base class, but now let's investigate how we can perform different levels of validation in different scenarios.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Varying levels of validation</h1>
                
            
            
                
<p>One thing that is not addressed by either of the .NET validation interfaces is the ability to either turn validation on or off, or to set varying levels of validation. This can be useful in several different scenarios, such as having different Views to edit different properties of a data Model object.</p>
<p>An example of this might be having a View that enables users to update the security settings of a <kbd>User</kbd> object, where we want to validate that each property has a value, but only for the properties that are currently displayed in the View. After all, there is no point in informing the user that a certain field must be entered if they can't do that in their current View.</p>
<p>The solution is to define a number of levels of validation, in addition to the levels that represent full and no validation. Let's take a look at a simple <kbd>ValidationLevel</kbd> enumeration that could fulfill this requirement:</p>
<pre>namespace CompanyName.ApplicationName.DataModels.Enums 
{ 
  public enum ValidationLevel 
  { 
    None, Partial, Full 
  } 
} </pre>
<p>As we can see, in this simple example, we just have the three levels of validation, although we could have added many more. However, in practice, we could still manage with this simple enumeration. Let's see how we could use it to implement multi-level validation in our validation base class:</p>
<pre>private ValidationLevel validationLevel = ValidationLevel.Full; 
 
public ValidationLevel ValidationLevel 
{ 
  get { return validationLevel; } 
  set { if (validationLevel != value) { validationLevel = value; } } 
} 
 
private void Validate(string propertyName, IEnumerable&lt;string&gt; errors)<br/>{<br/>  if (ValidationLevel == ValidationLevel.None) return;<br/>  UpdateErrors(propertyName, this[propertyName]);<br/>}</pre>
<p>We add a <kbd>ValidationLevel</kbd> property, with its <kbd>validationLevel</kbd> backing field that defaults to the <kbd>Full</kbd> enumeration member, as that is the normal action. Then, in the <kbd>Validate</kbd> method, we add a new line that simply exits the method if the <kbd>ValidationLevel</kbd> property is set to the <kbd>None</kbd> enumeration member.</p>
<p>Finally, the developers that use our application framework need to use the <kbd>ValidationLevel</kbd> property when validating their properties in the data Model classes. Imagine a scenario where users could edit the names of our products directly in a collection control, or edit all of the product's properties in a separate View. Let's see what our <kbd>ProductNotify</kbd> class indexer property would need to look like to demonstrate this:</p>
<pre>public override IEnumerable&lt;string&gt; this[string propertyName] 
{ 
  get 
  { 
    List&lt;string&gt; errors = new List&lt;string&gt;(); 
    if (propertyName == nameof(Name)) 
    { 
      if (string.IsNullOrEmpty(Name)) 
        errors.Add("Please enter the product name."); 
      else if (Name.Length &gt; 25) errors.Add("The product name cannot be
        longer than twenty-five characters."); 
      if (Name.Length &gt; 0 &amp;&amp; char.IsLower(Name[0])) errors.Add("The first
        letter of the product name must be a capital letter."); 
    } 
    else if (propertyName == nameof(Price) &amp;&amp;  
      ValidationLevel == ValidationLevel.Full &amp;&amp; Price == 0) 
      errors.Add("Please enter a valid price for the product."); 
    return errors; 
  } 
} </pre>
<p>Using our implementation of the <kbd>INotifyDataErrorInfo</kbd> interface, we first initialize a <kbd>string</kbd> list named <kbd>errors</kbd> and then we check the value of the <kbd>propertyName</kbd> input parameter. As this implementation enables us to return multiple validation errors per property, we need to take care with our <kbd>if</kbd> and <kbd>else</kbd> statements.</p>
<p>For example, when the <kbd>propertyName</kbd> input parameter equals <kbd>Name</kbd>, we have two <kbd>if</kbd> statements and one <kbd>else</kbd> statement. The first <kbd>if</kbd> statement verifies that the <kbd>Name</kbd> property has a value, while the <kbd>else</kbd> statement checks that its value is no longer than 25 characters.</p>
<p>As these two conditions cannot possibly both be true at the same time, we tie them together with the <kbd>if...else</kbd> statement. On the other hand, the product name could be longer than 25 characters and start with a lowercase letter and so, the next condition has its own <kbd>if</kbd> statement. In this example, the <kbd>Name</kbd> property will be validated when the <kbd>ValidationLevel</kbd> property is set to either the <kbd>Partial</kbd> or <kbd>Full</kbd> members.</p>
<p>However, the remaining condition for the <kbd>Price</kbd> property is only to be validated when the <kbd>ValidationLevel</kbd> property is set to the <kbd>Full</kbd> member and so, that is simply added as a further condition. To trigger partial validation on a data Model variable, we can simply set its <kbd>ValidationLevel</kbd> property as follows:</p>
<pre>product.ValidationLevel = ValidationLevel.Partial;</pre>
<p>Let's now investigate how we can combine the different techniques that we have viewed so far.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Incorporating multiple validation techniques</h1>
                
            
            
                
<p>Now that we've had a good look at the two validation interfaces, the data annotation attributes and the ability to validate with different levels, let's take a look at how we can amalgamate these different techniques.</p>
<p>Let's create a <kbd>BaseNotifyValidationModelExtended</kbd> class by copying what we have in our <kbd>BaseNotifyValidationModel</kbd> class, and incorporating these following new additions. First, we need to add some extra using directives to the ones used in the previous implementation:</p>
<pre>using System.Collections.Specialized;<br/>using System.ComponentModel.DataAnnotations;<br/>using CompanyName.ApplicationName.DataModels.Enums;</pre>
<p>Next, we need to add our <kbd>validationLevel</kbd> field:</p>
<pre>private ValidationLevel validationLevel = ValidationLevel.Full;</pre>
<p>We need to add a constructor, in which we attach the <kbd>ExternalErrors_CollectionChanged</kbd> event handler to the <kbd>CollectionChanged</kbd> event of the <kbd>ExternalErrors</kbd> collection property, as we did earlier:</p>
<pre>protected BaseNotifyValidationModelExtended() 
{ 
  ExternalErrors.CollectionChanged += ExternalErrors_CollectionChanged; 
} </pre>
<p>Now, let's add the familiar <kbd>ValidationLevel</kbd>, <kbd>Errors</kbd>, and <kbd>ExternalErrors</kbd> properties, along with the abstract <kbd>ValidateAllProperties</kbd> method:</p>
<pre>public ValidationLevel ValidationLevel 
{ 
  get { return validationLevel; } 
  set { if (validationLevel != value) { validationLevel = value; } } 
} 
 
public virtual ObservableCollection&lt;string&gt; Errors 
{ 
  get 
  { <br/>    ObservableCollection&lt;string&gt; errors = new ObservableCollection&lt;string&gt;<br/>      (AllPropertyErrors.Values.SelectMany(e =&gt; e).Distinct());
    ExternalErrors.Where(
      e =&gt; !errors.Contains(e)).ForEach(e =&gt; errors.Add(e)); 
    return errors; 
  } 
} 
 
public ObservableCollection&lt;string&gt; ExternalErrors { get; } =  
  new ObservableCollection&lt;string&gt;(); 
 
public abstract void ValidateAllProperties(); </pre>
<p>Note that in this implementation, users of our framework will no longer need to override the <kbd>Errors</kbd> property in order to ensure that their validatable properties are validated. While we still declare this property as virtual, so that it can be overridden if necessary, this base class implementation already compiles all validation errors into the internal collection, ready for display, and should replace the one that we copied from the previous base class.</p>
<p>This time, we initialize a new local <kbd>errors</kbd> collection with all of the unique errors from each property error collection in the <kbd>AllPropertyErrors</kbd> property <kbd>Dictionary</kbd> object. We then add any errors from the <kbd>ExternalErrors</kbd> collection, if they do not already exist in the <kbd>errors</kbd> collection. This string <kbd>Errors</kbd> collection is primarily used because it is convenient to data bind to in the UI.</p>
<p>After the new <kbd>Errors</kbd> property, we see the <kbd>ExternalErrors</kbd> auto property with its initializer and the abstract <kbd>ValidateAllProperties</kbd> method that needs to be implemented in the derived classes and can be called to force a new validation pass, either pre-emptively, or on the click of a save button, once all fields have been filled. We'll see an example implementation of this shortly.</p>
<p class="mce-root"/>
<p>Returning to our base class now, after the <kbd>ValidateAllProperties</kbd> method, we need to declare a couple of <kbd>Validate</kbd> methods, to replace the one from the <kbd>BaseNotifyValidationModel</kbd> class. The first of these is a convenience method that accepts any number of property name input parameters and simply calls the second method once for each property name:</p>
<pre>public void Validate(params string[] propertyNames) <br/>{ <br/>  foreach (string propertyName in propertyNames) <br/>    Validate(propertyName); <br/>} <br/><br/>public void Validate(string propertyName)<br/>{<br/>  if (ValidationLevel == ValidationLevel.None) return;<br/>  ValidationContext validationContext = new ValidationContext(this);<br/>  List&lt;ValidationResult&gt; validationResults = new List&lt;ValidationResult&gt;();<br/>  Validator.TryValidateObject(this, validationContext, validationResults, <br/>    true);<br/>  IEnumerable&lt;string&gt; allErrors = <br/>    validationResults.Where(v =&gt; v.MemberNames.Contains(propertyName)).<br/>    Select(v =&gt; v.ErrorMessage).Concat(this[propertyName]);<br/>  UpdateErrors(propertyName, allErrors);<br/>}</pre>
<p>In the <kbd>Validate</kbd> method, if the <kbd>ValidationLevel</kbd> property is set to the <kbd>None</kbd> member, we perform no validation and return from the method immediately. Otherwise, we retrieve the data annotation-related validation errors, as described earlier, in the <em>Annotating data</em> section.</p>
<p>We then filter just the errors that relate to the property that is specified by the <kbd>propertyName</kbd> input parameter and concatenate them with the collection of errors returned from the <kbd>this</kbd> indexer property. We end by passing the compiled collection, containing all of the errors, along with the <kbd>propertyName</kbd> input parameter, to the unchanged <kbd>UpdateErrors</kbd> method from our <kbd>BaseNotifyValidationModel</kbd> class.</p>
<p>Next, we need to add the <kbd>ExternalErrors_CollectionChanged</kbd> method, that is now referenced in the constructor. It simply notifies changes to the <kbd>Errors</kbd> collection property and the <kbd>HasError</kbd> property, so that they will be updated in the UI each time an external error is added or removed:</p>
<pre>private void ExternalErrors_CollectionChanged(object sender, 
  NotifyCollectionChangedEventArgs e) 
{ 
  NotifyPropertyChanged(nameof(Errors), nameof(HasErrors)); 
} </pre>
<p>The <kbd>HasErrors</kbd> property can be used to set the visibility of a collection control in the UI so that it can display the complete collection of errors, whenever any exist, and hide it when there are none. The last change that we need to make is to add an additional condition to the <kbd>HasErrors</kbd> property, which listens out for external errors, as well the internally generated ones:</p>
<pre>public bool HasErrors =&gt; ExternalErrors.Any() ||  
  allPropertyErrors.Any(p =&gt; p.Value != null &amp;&amp; p.Value.Any()); </pre>
<p>Now, our base validation class will manage errors that are defined in the indexer of each derived class, along with those defined in any data annotation attributes that may decorate the class properties and also those generated by external View Models. Let's now see how we can use this.</p>
<p>Let's first duplicate our <kbd>ProductNotify</kbd> class, rename it to <kbd>ProductNotifyExtended</kbd>, and make it extend our new <kbd>BaseNotifyValidationModelExtended</kbd> base class. We'll then need to make these following changes:</p>
<pre>public class ProductNotifyExtended : <br/>  BaseNotifyValidationModelExtended<br/>{<br/>  ...<br/><br/>  public override IEnumerable&lt;string&gt; this[string propertyName]<br/>  {<br/>    get<br/>    {<br/>      List&lt;string&gt; errors = new List&lt;string&gt;();<br/>      if (propertyName == nameof(Name))<br/>      {<br/>        ...<br/>      }<br/>      else if (propertyName == nameof(Price) &amp;&amp; <br/>        ValidationLevel == ValidationLevel.Full &amp;&amp; Price == 0) <br/>        errors.Add("Please enter a valid price for the product.");<br/>      return errors;<br/>    }<br/>  }<br/><br/>  public override void ValidateAllProperties()<br/>  {<br/>    Validate(nameof(Name), nameof(Price));<br/>  }<br/>}</pre>
<p>This new data Model is the same as the duplicated one, other than the name, the base class, the <kbd>ValidateAllProperties</kbd> method, and the addition of the extra condition to the <kbd>this</kbd> indexer, which was discussed in the previous section.</p>
<p>The <kbd>ValidateAllProperties</kbd> method calls the <kbd>Validate</kbd> method of the base class, passing in the names of the <kbd>Name</kbd> and <kbd>Price</kbd> properties, and can be called from a View Model to validate those two properties at any time. The <kbd>this</kbd> indexer has been updated according to the example from the previous section, to enable the <kbd>ValidationLevel</kbd> property to play its part in the validation process.</p>
<p>Now, let's create a <kbd>ProductNotifyViewModelExtended</kbd> class by duplicating and renaming the <kbd>ProductNotifyViewModel</kbd> class and making the following changes:</p>
<pre>public class ProductNotifyViewModelExtended : BaseViewModel<br/>{<br/>  private ProductsNotifyExtended products = <br/>    new ProductsNotifyExtended();<br/><br/>  public ProductNotifyViewModelExtended()<br/>  {<br/>    Products.Add(new ProductNotifyExtended() { Id = Guid.NewGuid(), <br/>      Name = "Virtual Reality Headset", Price = 14.99m });<br/>    Products.Add(new ProductNotifyExtended() { Id = Guid.NewGuid(), <br/>      Name = "super virtual reality headset", Price = 49.99m });<br/>    Products.CurrentItem = Products.Last();<br/>    Products.CurrentItem.Validate(nameof(Products.CurrentItem.Name));<br/>    Products.CurrentItem.Validate(nameof(Products.CurrentItem.Price));<br/>  }<br/><br/>  public ProductsNotifyExtended Products<br/>  {<br/>    get { return products; }<br/>    set { if (products != value) { products = value; <br/>      NotifyPropertyChanged(); } }<br/>  }<br/>}</pre>
<p>First, we replace all instances of the <kbd>ProductNotify</kbd> class with the <kbd>ProductNotifyExtended</kbd> class, and all instances of the <kbd>ProductsNotify</kbd> class with the <kbd>ProductsNotifyExtended</kbd> class.</p>
<p>The <kbd>ProductsNotifyExtended</kbd> class is the standard wrapper for encapsulating our <kbd>BaseCollection</kbd> class' functionality:</p>
<pre>namespace CompanyName.ApplicationName.DataModels.Collections<br/>{<br/>  public class ProductsNotifyExtended : <br/>    BaseCollection&lt;ProductNotifyExtended&gt; { }<br/>}</pre>
<p>The final change in the <kbd>ProductNotifyViewModelExtended</kbd> class is to alter the values of the second data item in the constructor to those shown in the new example. Let's also create a new <kbd>ProductNotifyViewExtended</kbd> class from our <kbd>ProductNotifyView</kbd> class by simply duplicating and renaming it. No other changes to it are required at this point.</p>
<p>After wiring up the View and View Model in the <kbd>App.xaml</kbd> file and running this example, we can see that, like our <kbd>BaseValidationModelExtended</kbd> example, this implementation also enables us to display multiple validation errors per property in our global error output collection control:</p>
<div><img src="img/4ef2fd29-6b5b-4d52-8ea0-2fe4a8eac54d.png" style="width:23.58em;height:15.00em;"/></div>
<p>Let's now examine how we can customize the way in which we highlight these validation errors to users.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Customizing the error template</h1>
                
            
            
                
<p>In addition to the essential <kbd>Errors</kbd> and <kbd>HasError</kbd> properties, the <kbd>Validation</kbd> class also declares an <kbd>ErrorTemplate</kbd> Attached Property of the <kbd>ControlTemplate</kbd> type. The default template assigned to this property is responsible for defining the red rectangle that surrounds UI fields that have validation errors associated with them.</p>
<p>However, this property enables us to change this template and so, we are able to define how validation errors are highlighted to the application users. As this property is an Attached Property, this effectively means that we could apply a different template to be displayed for each control in the UI. However, this cannot be recommended because it could make the application look less consistent.</p>
<p>This template actually uses an <kbd>Adorner</kbd> element to render its graphics in the adorner layer, on top of the related control in error. Therefore, in order to specify where our error visual(s) should be rendered in relation to the related control, we need to declare an <kbd>AdornedElementPlaceholder</kbd> element in the error template.</p>
<p>Let's take a look at a simple example, where we define a slightly thicker, non-blurry border, unlike the default one, and paint over the background of the related control with feint red for added emphasis. We first need to define a <kbd>ControlTemplate</kbd> object in a suitable resource section:</p>
<pre>&lt;ControlTemplate x:Key="ErrorTemplate"&gt; 
  &lt;Border BorderBrush="Red" BorderThickness="2" Background="#1FFF0000"  
    SnapsToDevicePixels="True"&gt; 
    &lt;AdornedElementPlaceholder /&gt; 
  &lt;/Border&gt; 
&lt;/ControlTemplate&gt; </pre>
<p>In this example, we declare the <kbd>AdornedElementPlaceholder</kbd> element inside a <kbd>Border</kbd> element, so that the border will be rendered around the outside of the related control. Note that without declaring this <kbd>AdornedElementPlaceholder</kbd> element, our border would resemble a tiny red dot in the top left of the related control when an error occurred.</p>
<p>Now, let's see how we apply this template, using our earlier example of the control that was data bound to the <kbd>Product.Price</kbd> property:</p>
<pre>&lt;TextBox Grid.Row="2" Grid.Column="1" 
  Text="{Binding Products.CurrentItem.Price,
  UpdateSourceTrigger=PropertyChanged, 
  ValidatesOnNotifyDataErrors=True, Delay=250}" 
  Style="{StaticResource FieldStyle}"
  Validation.ErrorTemplate="{StaticResource ErrorTemplate}" /&gt;</pre>
<p class="mce-root">Now, let's see what it looks like when rendered:</p>
<div><img class="alignnone size-full wp-image-2069 image-border" src="img/a7dad1ca-1f85-42a2-96ae-e9a1971b7f20.png" style="width:23.33em;height:8.42em;"/></div>
<p>If we wanted to position our error highlighting elements in a different position with relation to the related control in error, we could use one of the panels to position them. Let's take a look at a slightly more advanced error template that we could use. Let's begin by declaring some resources in a suitable resource section:</p>
<pre>&lt;ToolTip x:Key="ValidationErrorsToolTip"&gt; 
  &lt;ItemsControl ItemsSource="{Binding}"&gt; 
    &lt;ItemsControl.ItemTemplate&gt; 
      &lt;DataTemplate&gt; 
        &lt;TextBlock Text="{Binding ErrorContent}" /&gt; 
      &lt;/DataTemplate&gt; 
    &lt;/ItemsControl.ItemTemplate&gt; 
  &lt;/ItemsControl&gt; 
&lt;/ToolTip&gt; 
&lt;ControlTemplate x:Key="WarningErrorTemplate"&gt; 
  &lt;StackPanel Orientation="Horizontal"&gt; <br/>    &lt;AdornedElementPlaceholder Margin="0,0,10,0" /&gt; <br/>    &lt;Image Source="pack://application:,,,/CompanyName.ApplicationName; <br/>      component/Images/Warning_16.png" Stretch="None" <br/>      ToolTip="{StaticResource ValidationErrorsToolTip}" /&gt; <br/>  &lt;/StackPanel&gt; 
&lt;/ControlTemplate&gt; </pre>
<p>In this example, we declare a <kbd>ToolTip</kbd> resource named <kbd>ValidationErrorsToolTip</kbd>. In it, we declare an <kbd>ItemsControl</kbd> element to display all of the validation errors together. We define a <kbd>DataTemplate</kbd> element in the <kbd>ItemTemplate</kbd> property, which will output the value of the <kbd>ErrorContent</kbd> property of each <kbd>ValidationError</kbd> object in the <kbd>Validation.Errors</kbd> collection. This collection will be implicitly set as the data context of the control template.</p>
<p>Next, we declare a <kbd>ControlTemplate</kbd> element to set to the <kbd>ErrorTemplate</kbd> property, with the <kbd>WarningErrorTemplate</kbd> key. In it, we define a horizontal <kbd>StackPanel</kbd> control and, within that, we declare the required <kbd>AdornedElementPlaceholder</kbd> element. This is followed by the warning icon, taken from the Visual Studio icon set, that was discussed in <a href="181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml">Chapter 8</a>, <em>Creating Visually Appealing User Interfaces</em>, with the <kbd>ValidationErrorsToolTip</kbd> resource applied to its <kbd>ToolTip</kbd> property.</p>
<p>We can apply this template using the <kbd>ErrorTemplate</kbd> property as follows:</p>
<pre>&lt;TextBox Grid.Row="2" Grid.Column="1" 
  Text="{Binding Products.CurrentItem.Price, 
  UpdateSourceTrigger=PropertyChanged,  
  ValidatesOnNotifyDataErrors=True, Delay=250}" 
  Style="{StaticResource FieldStyle}" 
  Validation.ErrorTemplate="{StaticResource WarningErrorTemplate}" /&gt; </pre>
<p>When a validation error now occurs on this <kbd>TextBox</kbd> control, it will look like this:</p>
<div><img class="alignnone size-full wp-image-2070 image-border" src="img/62127b07-35d2-4b77-a551-486c2eace818.png" style="width:44.50em;height:10.75em;"/></div>
<p class="packt_figure CDPAlignLeft CDPAlign">Now that we've investigated a variety of ways to display our validation errors, let's move on to explore how we can avoid UI-based validation errors altogether.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Avoiding UI-based validation errors</h1>
                
            
            
                
<p>In the last example from the previous section, we data bound the entire <kbd>Validation.Errors</kbd> collection to a tooltip in the error template for our <kbd>TextBox</kbd> control. We also data bound our own <kbd>Errors</kbd> collection from our base class to the <kbd>ItemsControl</kbd> element above the form fields.</p>
<p>Our <kbd>Errors</kbd> collection can display all of the errors for all of the properties in each data Model. However, the <kbd>Validation.Errors</kbd> collection has access to UI-based validation errors that never make it back to the View Models. Take a look at the following example:</p>
<div><img class="alignnone size-full wp-image-2071 image-border" src="img/5c519c13-cfcf-4ea7-8e84-df346068215d.png" style="width:40.42em;height:16.75em;"/></div>
<p>The UI-based validation error says Value '0t' could not be converted, and that explains why the View Models never see this error. The type of value expected in the data bound property is <kbd>decimal</kbd>, but an unconvertible value has been entered. Therefore, the input value cannot be converted to a valid <kbd>decimal</kbd> number and so, the data bound value is never updated.</p>
<p>However, the <kbd>Validation.Errors</kbd> collection is a UI element, and each data bound control has its own collection, and so we have no simple way to access them all from our View Model classes. Furthermore, the <kbd>ValidationError</kbd> class is in the <kbd>System.Windows.Controls</kbd> UI assembly, so we don't want to add a reference of that to our <kbd>ViewModels</kbd> project.</p>
<p>Instead of trying to control the UI-based validation errors from the View Models, we can alternatively extend controls, or define Attached Properties that restrict the ability of the users to enter invalid data in the first place, thereby avoiding the need for UI-based validation. Let's take a look at one way in which we can modify a standard <kbd>TextBox</kbd> control, so that it will only accept numerical input, using our <kbd>TextBoxProperties</kbd> class:</p>
<pre>using System.Text.RegularExpressions; 
using System.Windows; 
using System.Windows.Controls; 
using System.Windows.Input; 
 
namespace CompanyName.ApplicationName.Views.Attached 
{ 
  public class TextBoxProperties : DependencyObject 
  { 
    #region IsNumericOnly 
 
    public static readonly DependencyProperty IsNumericOnlyProperty =  
      DependencyProperty.RegisterAttached("IsNumericOnly",  
      typeof(bool), typeof(TextBoxProperties),  
      new UIPropertyMetadata(default(bool), OnIsNumericOnlyChanged)); 
 
    public static bool GetIsNumericOnly(DependencyObject dependencyObject) 
    { 
      return (bool)dependencyObject.GetValue(IsNumericOnlyProperty); 
    } 
 
    public static void SetIsNumericOnly(DependencyObject dependencyObject, 
      bool value) 
    { 
      dependencyObject.SetValue(IsNumericOnlyProperty, value); 
    } 
 
    private static void OnIsNumericOnlyChanged(DependencyObject  
      dependencyObject, DependencyPropertyChangedEventArgs e) 
    { 
      TextBox textBox = (TextBox)dependencyObject; 
      bool newIsNumericOnlyValue = (bool)e.NewValue; 
      if (newIsNumericOnlyValue) 
      { 
        textBox.PreviewTextInput += TextBox_PreviewTextInput; 
        textBox.PreviewKeyDown += TextBox_PreviewKeyDown; 
        DataObject.AddPastingHandler(textBox, TextBox_Pasting); 
      } 
      else 
      { 
        textBox.PreviewTextInput -= TextBox_PreviewTextInput; 
        textBox.PreviewKeyDown -= TextBox_PreviewKeyDown; 
        DataObject.RemovePastingHandler(textBox, TextBox_Pasting); 
      } 
    } 
 
    private static void TextBox_PreviewTextInput(object sender,  
      TextCompositionEventArgs e) 
    { 
      string text = GetFullText((TextBox)sender, e.Text); 
      e.Handled = !IsTextValid(text); 
    } 
 
    private static void TextBox_PreviewKeyDown(object sender, 
      KeyEventArgs e) 
    { 
      TextBox textBox = (TextBox)sender; 
      if (textBox.Text.Length == 1 &amp;&amp; <br/>        (e.Key == Key.Delete || e.Key == Key.Back))<br/>      {<br/>        textBox.Text = "0";<br/>        textBox.CaretIndex = 1;<br/>        e.Handled = true;<br/>      }<br/>      else if (textBox.Text == "0") textBox.Clear();<br/>      else e.Handled = e.Key == Key.Space;
    } 
 
    private static void TextBox_Pasting(object sender,  
      DataObjectPastingEventArgs e) 
    { 
      if (e.DataObject.GetDataPresent(typeof(string))) 
      { 
        string text = GetFullText((TextBox)sender,  
          (string)e.DataObject.GetData(typeof(string))); 
        if (!IsTextValid(text)) e.CancelCommand(); 
      } 
      else e.CancelCommand(); 
    } 
 
    private static string GetFullText(TextBox textBox, string input) 
    { 
      return textBox.SelectedText.Length &gt; 0 ?  
        string.Concat(textBox.Text.Substring(0, textBox.SelectionStart), 
        input, textBox.Text.Substring(textBox.SelectionStart +  
        textBox.SelectedText.Length)) :  
        textBox.Text.Insert(textBox. SelectionStart, input); 
    } 
 
    private static bool IsTextValid(string text) 
    { 
      return Regex.Match(text, @"^\d*\.?\d*$").Success; 
    } 
 
    #endregion 
 
    ... 
  } 
} </pre>
<p>Excluding the other, existing members from our <kbd>TextBoxProperties</kbd> class, we first declare the <kbd>IsNumericOnly</kbd> Attached Property and its related getter and setter methods and attach the <kbd>OnIsNumericOnlyChanged</kbd> handler.</p>
<p>In the <kbd>OnIsNumericOnlyChanged</kbd> method, we first cast the <kbd>dependencyObject</kbd> input parameter to a <kbd>TextBox</kbd> element and then cast the <kbd>NewValue</kbd> property of the <kbd>DependencyPropertyChangedEventArgs</kbd> class to the <kbd>bool</kbd> <kbd>newIsNumericOnlyValue</kbd> variable.</p>
<p>If the <kbd>newIsNumericOnlyValue</kbd> variable is <kbd>true</kbd>, we attach our event handlers for the <kbd>PreviewTextInput</kbd>, <kbd>PreviewKeyDown</kbd>, and <kbd>DataObject.Pasting</kbd> events. If the <kbd>newIsNumericOnlyValue</kbd> variable is <kbd>false</kbd>, we detach the handlers.</p>
<p>We need to handle all of these events in order to create a <kbd>TextBox</kbd> control that can only enter numerical values. The <kbd>UIElement.PreviewTextInput</kbd> event is raised when a <kbd>TextBox</kbd> element receives a text input from any device, the <kbd>Keyboard.PreviewKeyDown</kbd> event occurs specifically when a keyboard key is pressed, and the <kbd>DataObject.Pasting</kbd> event is raised when we paste from the clipboard.</p>
<p>The <kbd>TextCompositionEventArgs</kbd> object in the <kbd>TextBox_PreviewTextInput</kbd> handler method only provides us with the last typed character through its <kbd>Text</kbd> property, along with <kbd>TextComposition</kbd> details. At the stage that this tunneling event is called, the <kbd>Text</kbd> property of the relevant <kbd>TextBox</kbd> control is not yet aware of this latest character.</p>
<p>Therefore, in order to correctly validate the whole entered text value, we need to combine the existing value with this new character. We do that in the <kbd>GetFullText</kbd> method and pass the returned value to the <kbd>IsTextValid</kbd> method.</p>
<p>We then set the inverted return value of the <kbd>IsTextValid</kbd> method to the <kbd>Handled</kbd> property of the <kbd>TextCompositionEventArgs</kbd> input parameter. Note that we invert this <kbd>bool</kbd> value, because setting the <kbd>Handled</kbd> property to <kbd>true</kbd> will stop the event from being routed any further and result in the latest character not being accepted. Therefore, we do this when the input value is invalid.</p>
<p>Next, we see the <kbd>TextBox_PreviewKeyDown</kbd> event handler method, and in it, we again start by casting the <kbd>sender</kbd> input parameter to a <kbd>TextBox</kbd> instance. We specifically need to handle this event, because the <kbd>PreviewTextInput</kbd> event does not get raised when the <em>Space bar</em>, <em>Delete</em>, or <em>Backspace</em> keys on the keyboard are pressed.</p>
<p>Therefore, we stop the event being routed any further by setting the <kbd>Handled</kbd> property of the <kbd>KeyEventArgs</kbd> input parameter to <kbd>true</kbd> if the pressed key is the <em>Space bar</em> key, or if the length of the entered text is a single character and the <em>Delete</em> or <em>Backspace</em> key is pressed; this stops the user from deleting the last character from the <kbd>TextBox</kbd> control, which would result in a UI-based validation error. </p>
<p>However, if the user was trying to delete the last character because it was incorrect and they wanted to replace it with a different value, this could be awkward. Therefore, in this situation, we replace the last character with a zero and place the caret position after it, which then enables the user to type a different value. Note our extra condition that clears the text if the input is <kbd>0</kbd>, so that it will be replaced with the typed character.</p>
<p>In the <kbd>TextBox_Pasting</kbd> handler method, we check whether the <kbd>DataObject</kbd> property that is accessed from the <kbd>DataObjectPastingEventArgs</kbd> input parameter has any <kbd>string</kbd> data available, and call its <kbd>CancelCommand</kbd> method to cancel the paste operation if not.</p>
<p>If <kbd>string</kbd> data is present, we cast the <kbd>sender</kbd> input parameter to a <kbd>TextBox</kbd> instance and then pass the data from the <kbd>DataObject</kbd> property to the <kbd>GetFullText</kbd> method to reconstruct the whole entered string. We pass the reconstructed text to the <kbd>IsTextValid</kbd> method and, if it is invalid, then we call the <kbd>CancelCommand</kbd> method to cancel the paste operation.</p>
<p>Next is the <kbd>GetFullText</kbd> method, where the entered text from the <kbd>TextBox</kbd> element is reconstructed. In this method, if any text is selected in the <kbd>TextBox</kbd> control, we rebuild the string by concatenating the portion of text before the selection with the newly entered or pasted text and the portion of text after the selection. Otherwise, we use the <kbd>Insert</kbd> method of the <kbd>String</kbd> class, along with the <kbd>TextBox</kbd> control's <kbd>SelectionStart</kbd> property, to insert the new character into the appropriate place in the string.</p>
<p>At the end of the class, we see the <kbd>IsTextValid</kbd> method, which simply returns the <kbd>Success</kbd> property value of the <kbd>Regex.Match</kbd> method. The regular expression that we validate with is as follows:</p>
<pre>@"^\d*\.?\d*$"</pre>
<p>The ampersand (<kbd>@</kbd>)marks the string as a Verbatim String Literal, which is useful when using characters that normally need to be escaped, the caret (<kbd>^</kbd>) signifies the start of the input line, <kbd>\d*</kbd> indicates that we can have zero or more numerical digits, <kbd>\.?</kbd> specifies that zero or one periods are then valid, <kbd>\d*</kbd> again indicates that we can then have zero or more numerical digits, and finally, <kbd>$</kbd> signifies the end of the input line.</p>
<p>When attached to an ordinary <kbd>TextBox</kbd> control, we can now only enter numeric values, but both integer and decimal values are allowed. Note that this particular implementation does not accept the minus sign, as we don’t want to allow negative prices, but that could be easily changed. Using our earlier <kbd>ProductNotifyViewExtended</kbd> example, we can attach our new property like this:</p>
<pre> 
... 
&lt;TextBox Grid.Row="2" Grid.Column="1" 
  Text="{Binding Products.CurrentItem.Price, 
  UpdateSourceTrigger=PropertyChanged, 
  ValidatesOnNotifyDataErrors=True, Delay=250}" 
  Style="{StaticResource FieldStyle}"
  Attached:TextBoxProperties.IsNumericOnly="True" /&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Keeping Synchronized with Legacy Behavior</h1>
                
            
            
                
<p>Those of you who have been experimenting with our various <kbd>Product</kbd>-related examples may have noticed something peculiar occurring when attempting to enter a price. In .NET 4.5, Microsoft decided to introduce a breaking change to the way that data is entered in the <kbd>TextBox</kbd> control, when the binding <kbd>UpdateSourceTrigger</kbd> value is set to <kbd>PropertyChanged</kbd>.</p>
<p>From .NET 4.5, we can no longer enter a numerical separator, neither a period nor a comma, when we have data bound the <kbd>TextBox.Text</kbd> property to a <kbd>float</kbd>, <kbd>double</kbd>, or <kbd>decimal</kbd> data type. The reason why they did this was because previously, the value displayed in the <kbd>TextBox</kbd> control would get out of sync with the data bound value, at the moment when the user types a non-numerical character.</p>
<p>Let’s investigate this situation; A user wants to enter <kbd>0.99</kbd> and, after the second character, the input value of <kbd>0.</kbd> is sent back to the data bound View Model. But as it is not a valid decimal value, it is therefore parsed to <kbd>0</kbd> and that value is sent back to the data bound <kbd>Textbox</kbd> element to be displayed. Therefore, the second character, the decimal point, is removed from the <kbd>Text</kbd> field.</p>
<p>Unfortunately, this change means that users can no longer directly type decimal places into a <kbd>TextBox</kbd> control when the <kbd>UpdateSourceTrigger</kbd> property is set to <kbd>PropertyChanged</kbd>. This can be seen in our <kbd>ProductView</kbd> example, where there is simply no way to enter a valid value with decimal places in the <kbd>TextBox</kbd> control labeled <kbd>Price</kbd>.</p>
<p>There are a number of ways to get around this issue, but none of them are perfect. One simple way is to set the <kbd>Mode</kbd> property on the <kbd>Binding</kbd> element to the <kbd>OneWayToSource</kbd> member, to stop the value being returned from the View Model, although this will also stop any initial default values being sent as well.</p>
<p>When this breaking change was announced in .NET 4.5, a new property was introduced along with the change; The <kbd>KeepTextBoxDisplaySynchronizedWithTextProperty</kbd> property was added to the <kbd>FrameworkCompatibilityPreferences</kbd> class and specifies whether a <kbd>TextBox</kbd> control should display the same as its data bound property value. If we set this to <kbd>false</kbd>, it should return the previous behavior:</p>
<pre>FrameworkCompatibilityPreferences. 
  KeepTextBoxDisplaySynchronizedWithTextProperty = false; </pre>
<p>Note that we need to set this property very early in the application lifetime, such as in the constructor of the <kbd>App.xaml.cs</kbd> file. Once set, it cannot be changed. Another way to avoid this problem is to set the <kbd>UpdateSourceTrigger</kbd> property to any value other than <kbd>PropertyChanged</kbd>:</p>
<pre>&lt;TextBox Text="{Binding Products.CurrentItem.Price, <br/>  Style="{StaticResource FieldStyle}" UpdateSourceTrigger=LostFocus ... /&gt;</pre>
<p>However, this is no use if we want to validate pre-emptively, or want our data source to update with each key press. Alternatively, we could simply data bind a <kbd>string</kbd> property to our <kbd>TextBox</kbd> control and perform our own number parsing in our View Model. This is perhaps the best solution from a user’s point of view, as it would enable them to type their values with ease.</p>
<p>Another option would be to utilize the <kbd>Delay</kbd> property of the <kbd>Binding</kbd> class, that we discussed in <a href="2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml">Chapter 4</a>, <em>Becoming Proficient with Data Binding</em>. If we set this to a figure of just a few hundred milliseconds, this would give the user enough time to enter their number, including the decimal point and the following digit(s), before the value is parsed to the data bound type:</p>
<pre>&lt;TextBox Text="{Binding Products.CurrentItem.Price,<br/>  UpdateSourceTrigger=PropertyChanged, Delay=250}" ... /&gt;</pre>
<p>This is the option that we used in our examples, primarily because it is a quick and easy fix for this problem. However, care should be taken when using this method with actual monetary properties, as mistakes can easily be made if the user types slowly and does not pay attention to the entered value.</p>
<p>As always with WPF, there are a number of different ways to implement any solution. As we just saw in the previous section, there are also other ways to stop users from entering invalid data in the first place; we could build, or make use of a third-party numeric up/down control, enable users to enter time values using a custom clock control, or even use combo boxes to restrict the values that users can select to a set of allowable values.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Amalgamating validation and visuals</h1>
                
            
            
                
<p>Let's now utilize some of the techniques that we discussed in <a href="181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml">Chapter 8</a>, <em>Creating Visually Appealing User Interfaces</em>, to design a visually appealing user interface that highlights validation errors in a novel way, using our glowing example. For this example, we want the ability to know when the data has changed, so we'll need to extend our earlier <kbd>BaseSynchronizableDataModel</kbd> class in another new base class.</p>
<p>Let's duplicate our <kbd>BaseNotifyValidationModelExtended</kbd> class so as to create a new <kbd>BaseNotifyValidationModelGeneric</kbd> class, and make it extend our synchronizable base class. In doing so, we will also need to make it generic and add the same generic constraints for the <kbd>T</kbd> generic type parameter from the base class to its declaration:</p>
<pre>using CompanyName.ApplicationName.DataModels.Interfaces;<br/><br/>...<br/><br/>public abstract class BaseNotifyValidationModelGeneric&lt;T&gt; : <br/>  BaseSynchronizableDataModel&lt;T&gt;, INotifyPropertyChanged, <br/>  INotifyDataErrorInfo <br/>  where T : BaseDataModel, ISynchronizableDataModel&lt;T&gt;, new()</pre>
<p>We'll need to remove the copied implementation of the <kbd>INotifyPropertyChanged</kbd> interface and make use of the existing implementation from the <kbd>BaseSynchronizableDataModel</kbd> class instead. We'll also need to implement the new base class' required members in a new <kbd>ProductNotifyGeneric</kbd> class. Let's start by duplicating the <kbd>ProductNotifyExtended</kbd> class, renaming it to <kbd>ProductNotifyGeneric</kbd>, and then adding these methods to the end of it:</p>
<pre>public class ProductNotifyGeneric : <br/>  BaseNotifyValidationModelGeneric&lt;ProductNotifyGeneric&gt; 
{ 
  ...
   
  public override void CopyValuesFrom(ProductNotifyGeneric product) 
  { 
    Id = product.Id; 
    Name = product.Name; 
    Price = product.Price; 
  } 
   
  public override bool PropertiesEqual(ProductNotifyGeneric otherProduct) 
  { 
    if (otherProduct == null) return false; 
    return Id == otherProduct.Id &amp;&amp; Name == otherProduct.Name &amp;&amp; 
      Price == otherProduct.Price;
  }<br/><br/>  public override string ToString()<br/>  {<br/>    return $"{Name}: £{Price:N2}";<br/>  }
} </pre>
<p>First, we extend from our new generic <kbd>BaseNotifyValidationModelGeneric</kbd> class and implement all required members of the base class; the <kbd>CopyValuesFrom</kbd> method is used to make cloned copies of the data object, the <kbd>PropertiesEqual</kbd> method is used to compare its property values with other <kbd>ProductNotifyGeneric</kbd> instances, and the <kbd>ToString</kbd> method provides a useful textual output for the class.</p>
<p>Now that we have extended our <kbd>BaseNotifyValidationModelGeneric</kbd> class from our earlier <kbd>BaseSynchronizableDataModel</kbd> class and extended from this, in turn, in our <kbd>ProductNotifyGeneric</kbd> class, we can now create a new <kbd>ProductsNotifyGeneric</kbd> collection class to extend our earlier <kbd>BaseSynchronizableCollection</kbd> class:</p>
<pre>public class ProductsNotifyGeneric : <br/>  BaseSynchronizableCollection&lt;ProductNotifyGeneric&gt; { } </pre>
<p>Let's now create a View Model for this new example, where we will use these new Models. We can start by duplicating the <kbd>ProductViewModelExtended</kbd> View Model and renaming it to <kbd>ProductNotifyViewModelGeneric</kbd>. We will need to replace all instances of the <kbd>ProductExtended</kbd> class with our new <kbd>ProductNotifyGeneric</kbd> class, and all instances of the <kbd>ProductsExtended</kbd> collection class with the new <kbd>ProductsNotifyGeneric</kbd> class.</p>
<p>After adding the two unchanged products from the previous View Model to it, we can now call the <kbd>Synchronize</kbd> method on our new <kbd>ProductsNotifyGeneric</kbd> collection in the constructor, in order to set the unchanged state of all of the contained data items:</p>
<pre>public ProductNotifyViewModelGeneric()<br/>{<br/>  Products.Add(new ProductNotifyGeneric() { Id = Guid.NewGuid(), <br/>    Name = "Virtual Reality Headset", Price = 14.99m });<br/>  Products.Add(new ProductNotifyGeneric() { Id = Guid.NewGuid(), <br/>    Name = "Virtual Reality Headset" });<br/>  Products.Synchronize();<br/>  Products.CurrentItemChanged += Products_CurrentItemChanged;<br/>  Products.CurrentItem = Products.Last();<br/>  Products.CurrentItem.Validate(nameof(Products.CurrentItem.Name), <br/>    nameof(Products.CurrentItem.Price));<br/>  ValidateUniqueName(Products.CurrentItem);<br/>}</pre>
<p>The only other change in the constructor is that we now call the base class <kbd>Validate</kbd> method on the current item, passing in the names of the <kbd>Name</kbd> and <kbd>Price</kbd> properties, which validates these fields in a pre-emptive manner, before the user has a chance to enter any data. </p>
<p>The final thing that we need to add to this class is a number of methods that handle a command from the UI:</p>
<pre>using System.Windows.Input; 
using CompanyName.ApplicationName.ViewModels.Commands;

...

public ICommand DeleteCommand 
{ 
  get { return new ActionCommand(action =&gt; Delete(action),  
    canExecute =&gt; CanDelete(canExecute)); } 
} 
 
private bool CanDelete(object parameter) 
{ 
  return Products.Contains((ProductNotifyGeneric)parameter);       
} 
 
private void Delete(object parameter) 
{ 
  Products.Remove((ProductNotifyGeneric)parameter);       
} </pre>
<p>Here, we use our <kbd>ActionCommand</kbd> class to create an <kbd>ICommand</kbd> instance, which users can use to delete the selected item from the product collection in the UI. In the <kbd>CanDelete</kbd> method, we verify that the item to delete actually exists in the collection, but this can be replaced with your own condition. For example, you could check whether the item has any changes, or whether the current user has the correct security permission to delete objects. In the <kbd>Delete</kbd> method, we simply remove the selected item from the collection.</p>
<p>Now that our View Model is ready, let's turn our attention to the accompanying View. For this, let's create a new View and name it <kbd>ProductNotifyViewGeneric</kbd>. We'll then need to supply some more resources to use in this example. Let's start by adding two further glow brush resources to the application resources file, with the <kbd>GreenGlow</kbd> brush resource from <a href="181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml">C<em>hapter 8</em></a>, <em>Creating Visually Appealing User Interfaces</em>:</p>
<pre>&lt;RadialGradientBrush x:Key="BlueGlow" Center="0.5,0.848"  
  GradientOrigin="0.5,0.818" RadiusX="-1.424" RadiusY="-0.622"  
  RelativeTransform="{StaticResource GlowTransformGroup}"&gt; 
  &lt;GradientStop Color="#CF01C7FF" Offset="0.168" /&gt; 
  &lt;GradientStop Color="#4B01C7FF" Offset="0.478" /&gt; 
  &lt;GradientStop Color="#1101C7FF" Offset="1" /&gt; 
&lt;/RadialGradientBrush&gt; 
&lt;RadialGradientBrush x:Key="RedGlow" Center="0.5,0.848"  
  GradientOrigin="0.5,0.818" RadiusX="-1.424" RadiusY="-0.622"  
  RelativeTransform="{StaticResource GlowTransformGroup}"&gt; 
  &lt;GradientStop Color="#CFFF0000" Offset="0.168" /&gt; 
  &lt;GradientStop Color="#4BFF0000" Offset="0.478" /&gt; 
  &lt;GradientStop Color="#00FF0000" Offset="1" /&gt; 
&lt;/RadialGradientBrush&gt; </pre>
<p>Let's now see the styles that use these brush resources:</p>
<pre>&lt;Style x:Key="GlowStyle" TargetType="{x:Type Rectangle}"&gt; 
  &lt;Setter Property="SnapsToDevicePixels" Value="True" /&gt; 
  &lt;Setter Property="Opacity" Value="1.0" /&gt; 
  &lt;Setter Property="StrokeThickness" Value="0" /&gt; 
  &lt;Setter Property="RadiusX" Value="2.5" /&gt; 
  &lt;Setter Property="RadiusX" Value="2.5" /&gt; 
  &lt;Setter Property="IsHitTestVisible" Value="False" /&gt; 
  &lt;Setter Property="VerticalAlignment" Value="Stretch" /&gt; 
  &lt;Setter Property="HorizontalAlignment" Value="Stretch" /&gt; 
  &lt;Setter Property="Fill" Value="{StaticResource BlueGlow}" /&gt; 
&lt;/Style&gt; </pre>
<p>This first style is reusable and can be declared in the global application resources, while the following styles extend the first, are data Model-specific, and could be declared locally in our new <kbd>ProductNotifyViewGeneric</kbd> class:</p>
<pre>&lt;Style x:Key="ProductGlowStyle" TargetType="{x:Type Rectangle}"  
  BasedOn="{StaticResource GlowStyle}"&gt; 
  &lt;Style.Triggers&gt; 
    &lt;DataTrigger Binding="{Binding Products.CurrentItem.HasChanges,  
      FallbackValue=False, Mode=OneWay}" Value="True"&gt; 
      &lt;Setter Property="Fill" Value="{StaticResource GreenGlow}" /&gt; 
    &lt;/DataTrigger&gt; 
    &lt;DataTrigger Binding="{Binding Products.CurrentItem.HasErrors,  
      FallbackValue=False, Mode=OneWay}" Value="True"&gt; 
      &lt;Setter Property="Fill" Value="{StaticResource RedGlow}" /&gt; 
    &lt;/DataTrigger&gt; 
  &lt;/Style.Triggers&gt; 
&lt;/Style&gt; 
&lt;Style x:Key="ProductItemGlowStyle" TargetType="{x:Type Rectangle}"  
  BasedOn="{StaticResource GlowStyle}"&gt; 
  &lt;Style.Triggers&gt; 
    &lt;DataTrigger Binding="{Binding HasChanges, FallbackValue=False,  
      Mode=OneWay}" Value="True"&gt; 
      &lt;Setter Property="Fill" Value="{StaticResource GreenGlow}" /&gt; 
    &lt;/DataTrigger&gt; 
    &lt;DataTrigger Binding="{Binding HasErrors, FallbackValue=False,  
      Mode=OneWay}" Value="True"&gt; 
      &lt;Setter Property="Fill" Value="{StaticResource RedGlow}" /&gt; 
    &lt;/DataTrigger&gt; 
  &lt;/Style.Triggers&gt; 
&lt;/Style&gt; </pre>
<p>We declare the <kbd>ProductGlowStyle</kbd> style for our form rectangle, and the <kbd>ProductItemGlowStyle</kbd> style for our data items in the <kbd>Products</kbd> collection. The only differences can be found in the binding paths of the two data triggers.</p>
<p>In these styles, we add a <kbd>DataTrigger</kbd> element that sets the rectangle <kbd>Fill</kbd> property to the <kbd>GreenGlow</kbd> resource when the <kbd>HasChanges</kbd> property of the current item in the <kbd>Products</kbd> collection is <kbd>True</kbd>, and another that sets it to the <kbd>RedGlow</kbd> resource when the <kbd>HasErrors</kbd> property of the current item is <kbd>True</kbd>. As the trigger that highlights errors is declared after the one that highlights valid changes, this will override the first if both conditions are <kbd>True</kbd>, which is essential for this example. </p>
<p>Next, we need to alter our default styles, which we added to the application resources for our first product example. Let's add these new styles that are based on the original ones to our <kbd>ProductNotifyViewGeneric</kbd> class, so that they override the default ones:</p>
<pre>&lt;Style x:Key="WhiteLabelStyle" TargetType="{x:Type TextBlock}" <br/>  BasedOn="{StaticResource LabelStyle}"&gt;<br/>  &lt;Setter Property="Foreground" Value="White" /&gt;<br/>&lt;/Style&gt;<br/>&lt;Style x:Key="ErrorFreeFieldStyle" TargetType="{x:Type TextBox}" <br/>  BasedOn="{StaticResource FieldStyle}"&gt;<br/>  &lt;Setter Property="Validation.ErrorTemplate" Value="{x:Null}" /&gt;<br/>&lt;/Style&gt;</pre>
<p>As these new styles are based on the previous ones, we keep the same attribute values, but add a further one to each style. The <kbd>WhiteLabelStyle</kbd> style sets the <kbd>Foreground</kbd> property to <kbd>White</kbd>, and the <kbd>ErrorFreeFieldStyle</kbd> style sets the <kbd>Validation.ErrorTemplate</kbd> Attached Property to <kbd>null</kbd>, as we will have other ways to highlight validation errors in this example.</p>
<p>Let's now see the data template resource for the new <kbd>ProductNotifyGeneric</kbd> class, which makes use of our new <kbd>ProductItemGlowStyle</kbd> style, first ensuring that we have added a couple of XML namespace prefixes for our <kbd>DataModels</kbd> and <kbd>Views</kbd> projects:</p>
<pre>xmlns:DataModels="clr-namespace:CompanyName.ApplicationName.DataModels; 
  assembly=CompanyName.ApplicationName.DataModels" 
 
... 
&lt;DataTemplate DataType="{x:Type DataModels:ProductNotifyGeneric}"&gt; 
  &lt;Border CornerRadius="3" BorderBrush="{StaticResource TransparentBlack}" 
    BorderThickness="1" Background="{StaticResource TransparentWhite}"&gt; 
    &lt;Border Name="InnerBorder" CornerRadius="2" Margin="1"  
      Background="{StaticResource LayeredButtonBackground}"&gt; 
      &lt;Grid&gt; 
        &lt;Rectangle IsHitTestVisible="False" RadiusX="2" RadiusY="2"  
          Style="{StaticResource ProductItemGlowStyle}" /&gt; 
        &lt;Grid&gt; 
          &lt;Grid.ColumnDefinitions&gt; 
            &lt;ColumnDefinition Width="Auto" /&gt; 
            &lt;ColumnDefinition /&gt; 
            &lt;ColumnDefinition Width="Auto" /&gt; 
          &lt;/Grid.ColumnDefinitions&gt; 
          &lt;Image Width="24" Height="24" 
            Source="pack://application:,,,/CompanyName.ApplicationName;
            component/Images/Product.ico" VerticalAlignment="Center"
            Margin="3,2,5,2" /&gt; 
          &lt;TextBlock Grid.Column="1" HorizontalAlignment="Left"  
            VerticalAlignment="Center" Text="{Binding Name}"  
            TextWrapping="Wrap" Margin="0,1,5,3" Foreground="White"  
            FontSize="14" Validation.ErrorTemplate="{x:Null}" /&gt; 
          &lt;Button Grid.Column="2"  
            Command="{Binding DataContext.DeleteCommand,  
            RelativeSource={RelativeSource FindAncestor,  
            AncestorType={x:Type Views:ProductNotifyViewGeneric}}}" 
            CommandParameter="{Binding}" Margin="0,2,4,2" 
            Width="20" Height="20"&gt; 
            &lt;Image Width="16" Height="16"  
              Source="pack://application:,,,/CompanyName.ApplicationName; 
              component/Images/Delete_16.png"  
              HorizontalAlignment="Center" VerticalAlignment="Center" /&gt; 
          &lt;/Button&gt; 
        &lt;/Grid&gt; 
      &lt;/Grid&gt; 
    &lt;/Border&gt; 
  &lt;/Border&gt; 
&lt;/DataTemplate&gt; </pre>
<p>In this example, we reuse our double border technique from <a href="181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml">Chapter 8</a>,<em> Creating Visually Appealing User Interfaces</em>, so there's no need to examine that code again. Inside the borders, we declare a <kbd>Grid</kbd> panel, which contains a <kbd>Rectangle</kbd> element, that has our new <kbd>ProductItemGlowStyle</kbd> style applied to it, and another <kbd>Grid</kbd> panel to display each user's name and a couple of images.</p>
<p>These images are from the Visual Studio Image Library, which we discussed earlier, and we use the first to signify that these objects are products. The <kbd>VerticalAlignment</kbd> property of each of the three elements is set to <kbd>Center</kbd>, to ensure that they are all aligned vertically, and the <kbd>TextWrapping</kbd> property of the <kbd>TextBlock</kbd> element is set to <kbd>Wrap</kbd> in case any products have a long name.</p>
<p>Note that the <kbd>ErrorTemplate</kbd> property of the <kbd>Validation</kbd> class has been set to <kbd>null</kbd> here in order to remove the default error template, which usually shows up as an unappealing red rectangle. As we make the entire object glow red when it has an error, there is no need for the default template to be displayed as well.</p>
<p>The second image specifies that each of these items can be deleted. Note that it is declared within a <kbd>Button</kbd> control, and while we have not attempted to style that button, it could also be given the double border treatment, or any other custom style. This button is optional, but has been included merely as an example of linking a command from the View Model to each data object.</p>
<p>Note that the binding path in the button's <kbd>Command</kbd> property uses a <kbd>RelativeSource</kbd> binding to reference the ancestor of the <kbd>ProductNotifyViewGeneric</kbd> type. In particular, it references the <kbd>DeleteCommand</kbd> property of the <kbd>DataContext</kbd> of the View, which, in our case, is an instance of our <kbd>ProductNotifyViewModelGeneric</kbd> class.</p>
<p>The <kbd>CommandParameter</kbd> property is then data bound to the entire data context of each data template, which means that the whole <kbd>ProductNotifyGeneric</kbd> data Model object will be passed through as the command parameter. Using our <kbd>ActionCommand</kbd> class, this is specified by the <kbd>action</kbd> and <kbd>canExecute</kbd> fields in the earlier example from our <kbd>ProductNotifyViewModelGeneric</kbd> class.</p>
<p>Now that we have styled our <kbd>ProductNotifyGeneric</kbd> items in the <kbd>ListBox</kbd> control with this data template, there is something else that we can do to improve the look further; we can remove the default selection rectangle of the <kbd>ListBoxItem</kbd> elements that wrap our data Models. In .NET 3.5 and before, we could simply add some resources to a style for the <kbd>ListBoxItem</kbd> class that would do the job for us:</p>
<pre>&lt;Style TargetType="{x:Type ListBoxItem}"&gt; 
  &lt;Style.Resources&gt; 
    &lt;SolidColorBrush x:Key="{x:Static SystemColors.HighlightBrushKey}"  
      Color="Transparent" /&gt; 
    &lt;SolidColorBrush x:Key="{x:Static SystemColors.ControlBrushKey}"  
      Color="Transparent" /&gt; 
    &lt;SolidColorBrush x:Key="{x:Static SystemColors.HighlightTextBrushKey}" 
      Color="Black" /&gt; 
    &lt;SolidColorBrush x:Key="{x:Static SystemColors.ControlTextBrushKey}" 
      Color="Black" /&gt; 
  &lt;/Style.Resources&gt; 
&lt;/Style&gt; </pre>
<p>However, from .NET 4.0 onward, this will no longer work. Instead, we now need to define a new <kbd>ControlTemplate</kbd> object for the <kbd>ListBoxItem</kbd> class that does not highlight its background when selected, or when the user's mouse cursor is over it:</p>
<pre>&lt;Style TargetType="{x:Type ListBoxItem}"&gt; 
  &lt;Setter Property="Padding" Value="0" /&gt; 
  &lt;Setter Property="Margin" Value="2,2,2,0" /&gt; 
  &lt;Setter Property="BorderThickness" Value="1" /&gt; 
  &lt;Setter Property="Template"&gt; 
    &lt;Setter.Value&gt; 
      &lt;ControlTemplate TargetType="{x:Type ListBoxItem}"&gt; 
        &lt;Border x:Name="Bd" BorderBrush="{TemplateBinding BorderBrush}" 
          BorderThickness="{TemplateBinding BorderThickness}" 
          Background="{TemplateBinding Background}" 
          Padding="{TemplateBinding Padding}" SnapsToDevicePixels="True"&gt; 
          &lt;ContentPresenter 
            ContentTemplate="{TemplateBinding ContentTemplate}" 
            Content="{TemplateBinding Content}" 
            ContentStringFormat="{TemplateBinding ContentStringFormat}" 
            HorizontalAlignment="{TemplateBinding 
            HorizontalContentAlignment}"       
            SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
            VerticalAlignment="{TemplateBinding VerticalContentAlignment}"
            /&gt; 
        &lt;/Border&gt; 
        &lt;ControlTemplate.Triggers&gt; 
          &lt;Trigger Property="IsEnabled" Value="False"&gt; 
            &lt;Setter Property="TextElement.Foreground"  
              TargetName="Bd" Value="{DynamicResource  
              {x:Static SystemColors.GrayTextBrushKey}}" /&gt; 
          &lt;/Trigger&gt; 
        &lt;/ControlTemplate.Triggers&gt; 
      &lt;/ControlTemplate&gt; 
    &lt;/Setter.Value&gt; 
  &lt;/Setter&gt; 
&lt;/Style&gt; </pre>
<p>To create the <kbd>ControlTemplate</kbd> element in this style, we first accessed the default template of the <kbd>ListBoxItem</kbd> class, as described in the <em>Modifying Existing Controls</em> section of <a href="d5906090-c679-45d6-81cd-016d4337eb75.xhtml">Chapter 5</a>, <em>Using the Right Controls for the Job</em>, and then simply removed the triggers that colored the background. We then added it to a style with no <kbd>x:Key</kbd> directive, so that it will be implicitly applied to all <kbd>ListBoxItem</kbd> elements within scope.</p>
<p>Next, we have the <kbd>ErrorBorderStyle</kbd> style, which styles the border of our global validation error display and uses our <kbd>BoolToVisibilityConverter</kbd> class to set the <kbd>Visibility</kbd> property to show the control when the <kbd>HasErrors</kbd> property of the current item in the <kbd>Products</kbd> collection is <kbd>True</kbd>:</p>
<pre>&lt;Style x:Key="ErrorBorderStyle" TargetType="{x:Type Border}"&gt; 
  &lt;Setter Property="BorderBrush" Value="#7BFF0000" /&gt; 
  &lt;Setter Property="Background" Value="#FFFFDFE1" /&gt; 
  &lt;Setter Property="BorderThickness" Value="1" /&gt; 
  &lt;Setter Property="CornerRadius" Value="2.75" /&gt; 
  &lt;Setter Property="Padding" Value="5,3" /&gt; 
  &lt;Setter Property="Margin" Value="0,0,0,5" /&gt; 
  &lt;Setter Property="SnapsToDevicePixels" Value="True" /&gt; 
  &lt;Setter Property="Visibility" 
    Value="{Binding Products.CurrentItem.HasErrors, 
    Converter={StaticResource BoolToVisibilityConverter},  
    FallbackValue=Collapsed, Mode=OneWay}" /&gt; 
&lt;/Style&gt; </pre>
<p>Now that we've added all of the required resources for our View, let's move on to see the XAML file in the <kbd>ProductNotifyViewGeneric</kbd> class that uses them:</p>
<pre>&lt;Grid Margin="20"&gt;<br/>  &lt;Grid.Resources&gt;<br/>    ...<br/>  &lt;/Grid.Resources&gt;<br/>  &lt;Grid.ColumnDefinitions&gt;<br/>    &lt;ColumnDefinition /&gt;<br/>    &lt;ColumnDefinition /&gt;<br/>  &lt;/Grid.ColumnDefinitions&gt;<br/>  &lt;ListBox ItemsSource="{Binding Products}" <br/>    SelectedItem="{Binding Products.CurrentItem}" Margin="0,0,20,0" <br/>    HorizontalContentAlignment="Stretch" /&gt;<br/>  &lt;Border Grid.Column="1" CornerRadius="3" <br/>    BorderBrush="{StaticResource TransparentBlack}" BorderThickness="1" <br/>    Background="{StaticResource TransparentWhite}"&gt;<br/>    &lt;Border Name="InnerBorder" CornerRadius="2" Margin="1" <br/>      Background="{StaticResource LayeredButtonBackground}"&gt;<br/>      &lt;Grid&gt;<br/>        &lt;Rectangle IsHitTestVisible="False" RadiusX="2" RadiusY="2" <br/>          Style="{StaticResource ProductGlowStyle}" /&gt;<br/>        &lt;Grid Margin="10"&gt;<br/>          &lt;Grid.RowDefinitions&gt;<br/>            &lt;RowDefinition Height="Auto" /&gt;<br/>            &lt;RowDefinition Height="Auto" /&gt;<br/>            &lt;RowDefinition Height="Auto" /&gt;<br/>          &lt;/Grid.RowDefinitions&gt;<br/>          &lt;Grid.ColumnDefinitions&gt;<br/>            &lt;ColumnDefinition Width="Auto" /&gt;<br/>            &lt;ColumnDefinition /&gt;<br/>          &lt;/Grid.ColumnDefinitions&gt;<br/>          &lt;TextBlock Text="Name" <br/>            Style="{StaticResource WhiteLabelStyle}" /&gt;<br/>          &lt;TextBox Grid.Column="1" <br/>            Text="{Binding Products.CurrentItem.Name, <br/>            UpdateSourceTrigger=PropertyChanged}" <br/>            Style="{StaticResource ErrorFreeFieldStyle}" /&gt;<br/>          &lt;TextBlock Grid.Row="1" Text="Price" <br/>            Style="{StaticResource WhiteLabelStyle}" /&gt;<br/>          &lt;TextBox Grid.Row="1" Grid.Column="1" <br/>            Text="{Binding Products.CurrentItem.Price, <br/>            UpdateSourceTrigger=PropertyChanged, Delay=250}" <br/>            Style="{StaticResource ErrorFreeFieldStyle}" <br/>            Attached:TextBoxProperties.IsNumericOnly="True" /&gt;<br/>          &lt;Border Grid.Row="2" Grid.ColumnSpan="2" Style="{StaticResource <br/>            ErrorBorderStyle}" Margin="0,0,0,10" Padding="10"&gt;<br/>            &lt;ItemsControl ItemsSource="{Binding Products.CurrentItem.Errors}" <br/>              ItemTemplate="{StaticResource WrapTemplate}" /&gt;<br/>          &lt;/Border&gt;<br/>        &lt;/Grid&gt;<br/>      &lt;/Grid&gt;<br/>    &lt;/Border&gt;<br/>  &lt;/Border&gt;<br/>&lt;/Grid&gt;</pre>
<p>We use the same <kbd>Grid</kbd> panel as in the last example, with a <kbd>ListBox</kbd> control on the left and some form controls on the right. Note that we set the <kbd>HorizontalContentAlignment</kbd> property to <kbd>Stretch</kbd> on the <kbd>ListBox</kbd> control to ensure that its <kbd>ListBoxItem</kbd> elements stretch to fit its whole width.</p>
<p>On the right, we see the double borders and the <kbd>Rectangle</kbd> element that is painted with the glow color resource that we created in <a href="181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml">Chapter 8</a>, <em>Creating Visually Appealing User Interfaces</em>. Rather than hardcoding one particular color resource, as we did earlier, we instead apply our new <kbd>ProductGlowStyle</kbd> style to it, which will change the color with its data triggers, according to the validity of the data.</p>
<p>Note that we have added an outer <kbd>Grid</kbd> panel, that contains only the glow rectangle and the original <kbd>Grid</kbd> panel, which now adds an outer margin to our form. The original panel remains much unchanged from the previous example, although the error display border now uses our new <kbd>ErrorBorderStyle</kbd> style and is displayed underneath the form fields, in acknowledgment that some users don't like their fields moving as errors appear and disappear.</p>
<p>The form fields also mostly remain the same, although when using our new implementation, we no longer need to set the <kbd>ValidatesOnNotifyDataErrors</kbd> property to <kbd>True</kbd> on each binding. We also apply our new <kbd>WhiteLabelStyle</kbd> and <kbd>ErrorFreeFieldStyle</kbd> styles to the form labels and fields, to color the label foreground white and to hide the default red error border when there are validation errors.</p>
<p>When running this View now, it would render the following visual output, with a red glow on the form and the item in error:</p>
<div><img class="alignnone size-full wp-image-2123 image-border" src="img/f39840c4-cf84-421b-9a63-a8a9e9f1e86c.png" style="width:52.33em;height:20.75em;"/></div>
<p>After correcting the errors, we'll see a green glow on the form and the edited item:</p>
<div><img class="alignnone size-full wp-image-2124 image-border" src="img/7a0f8496-2a6f-4462-81a6-dc6f34d41b8e.png" style="width:36.58em;height:9.42em;"/></div>
<p>After saving the changes, we'd need to call the <kbd>Synchronize</kbd> method on the <kbd>Products</kbd> collection again and then we'd see the following screenshot, where all objects are now painted with the default blue glow:</p>
<div><img class="alignnone size-full wp-image-2125 image-border" src="img/422e278f-b0d5-4657-85bc-26e4e964d378.png" style="width:38.67em;height:9.92em;"/></div>
<p>In this way, we are able to use the color of the glow to clearly inform users of the state of the control at any given time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we had a thorough look at the data validation options that the .NET Framework offers us, primarily concentrating on a variety of ways to implement the two available validation interfaces. We investigated the use of the data annotation validation attributes, explored the provision of custom error templates, and aggregated our new found knowledge with that from <a href="181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml">Chapter 8</a>, <em>Creating Visually Appealing User Interfaces,</em> in order to build up a visually pleasing validation example.</p>
<p>In the next chapter, we'll look at a number of ways in which we can provide users of our applications with a great user experience, from asynchronous programming to feedback mechanisms. We will also examine how to make use of application settings to provide user preferences and explore a variety of ways of supplying in-application help to the application users. We will end with a further look into additional ways of improving the user experience for end users.</p>


            

            
        
    </body></html>