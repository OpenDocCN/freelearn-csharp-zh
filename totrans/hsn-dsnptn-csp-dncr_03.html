<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Modern Software Design Patterns and Principles</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, <strong>object-oriented programming</strong> (<strong>OOP</strong>) was discussed in preparation for exploring different patterns. As many patterns rely on concepts in OOP, it is important to introduce and/or revisit these concepts. <span>Inheritance between classes allows us to define an <em>is-a-type-of relationship</em>. This provides a higher degree of abstraction. For example, with inheritance it is possible to perform comparisons such as a <em>cat </em>is a type of <em>animal</em> and a <em>dog</em> is a type of <em>animal</em>. Encapsulation provides a way of controlling the visibility and access of details of a class. Polymorphism provides the ability to handle different objects using the same interface. With OOP, a higher level of abstraction can be achieved, providing a more manageable and understandable way to deal with large solutions.</span></p>
<p><span>This chapter catalogs and introduces different patterns used in modern software development. This book takes a very broad view of what a pattern is. A pattern in software development is any solution to a general problem that software programmers face during development. They are built from experience on what works and what does not. Also, these solutions are trialed and tested by numerous developers in various situations. The benefit of using a pattern is based on this past activity both in not repeating the effort and in the assurance that the problem will be solved without introducing a defect or issue.</span></p>
<p>Especially when taking technology-specific patterns into consideration, there are too many to cover in a single book so this chapter will highlight specific patterns to illustrate different types of pattern. We have tried to pick out the commonest and most influential patterns based on our experience. In subsequent chapters, specific patterns will be explored in more detail.</p>
<p class="mce-root"/>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Design principles, including SOLID</li>
<li>Pattern catalogs, including <strong>Gang of Four</strong> (<strong>GoF</strong>) patterns and <strong>Enterprise Integration Pattern</strong> (<strong>EIP</strong>)</li>
<li>Software development life cycle patterns</li>
<li>Patterns and practices for solution development, cloud development, and service development</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter contains various code examples to explain the concepts. The code is kept simple and is just for demonstration purposes. Most of the examples involve a .NET Core console application written in C#.</p>
<p>To run and execute the code, you need the following:</p>
<ul>
<li>Visual Studio 2019 (you can also run the application using Visual Studio 2017<span> </span>version 3<span> </span>or later)</li>
<li>.NET Core</li>
<li>SQL Server (the Express Edition is used in this chapter)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Visual Studio</h1>
                </header>
            
            <article>
                
<p>To run these code examples, you need to install Visual Studio or you can use your preferred IDE. To do this, follow these instructions:</p>
<ol>
<li>Download Visual Studio from the following link:<span> </span><a href="https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio">https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio</a>.</li>
<li>Follow the installation instructions included. Multiple versions are available for Visual Studio installation. In this chapter, we are using Visual Studio for Windows.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up .NET Core</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you do not have .NET Core installed, you need to follow these instructions:</p>
<ol>
<li class="mce-root">Download .NET Core from the following link:<span> </span><a href="https://www.microsoft.com/net/download/windows">https://www.microsoft.com/net/download/windows</a>.</li>
<li><span>Follow the </span>Installation instructions and related library: <a href="https://dotnet.microsoft.com/download/dotnet-core/2.2">https://dotnet.microsoft.com/download/dotnet-core/2.2</a>.</li>
</ol>
<div class="packt_infobox"><span>The complete source code is available in GitHub. The source code shown in the chapter might not be complete so it is advisable to retrieve the source in order to run the examples: <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter2">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter2</a>.<a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter2"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Design principles</h1>
                </header>
            
            <article>
                
<p>Arguably, the most important aspect of good software development is software design. Developing software solutions that <span>are both functionally accurate and easy to maintain</span> is challenging and relies considerably on using good development principles. Over time, some decisions that were made early in the project can cause solutions to become too costly to maintain and extend, forcing systems to be rewritten, while others with a good design can be extended and adapted as business requirements and technology change. There are many software development design principles and this section will highlight some popular and important ones you need to be familiar with.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DRY – Don't Repeat Yourself</h1>
                </header>
            
            <article>
                
<p>The guiding thought behind the <strong>Don't Repeat Yourself</strong> <span>(<strong>DRY</strong>)</span> principle is that duplication is a waste of time and effort. The repetition could take the form of processes and code. Handling the same requirement multiple times is a waste of effort and creates confusion within a solution. When first viewing this principle, it might not be clear how a system could end up duplicating a process or code. For example, once someone has determined how to do a requirement, why would someone else take the effort to duplicate the same functionality? There are many circumstances in which this happens in software development, and understanding why this happens is key to understanding the value of this principle.</p>
<p class="mce-root"/>
<p>The following are some common causes of code duplication:</p>
<ul>
<li><strong>Lack of understanding</strong>: In large solutions, a developer might not have a full understanding of an existing solution and/or does not know how to apply abstraction to solve the problem with existing functionality.</li>
<li><strong>Copy and paste</strong>: <span>To put this simply</span>, the code is duplicated in multiple classes instead of refactoring the solution to allow for multiple classes to access the shared functionality. </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">KISS – Keep It Simple Stupid</h1>
                </header>
            
            <article>
                
<p>Similar to DRY, <strong>Keep It Simple Stupid</strong> (<strong>KISS</strong>) has been an important principle in software development for many years. KISS stresses that simplicity should be the goal and complexity should be avoided. The key here is to avoid unnecessary complexity and thus reduce the chances of things going wrong.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">YAGNI – You Aren't Gonna Need It</h1>
                </header>
            
            <article>
                
<p><strong>You Aren't Gonna Need It</strong> (<strong>YAGNI</strong>) simply states that functionality should only be added when it is required. Sometimes in software development, there is a tendency to <em>futureproof</em> a design in case something changes. This can create requirements that are actually not needed currently or in the future: </p>
<div class="packt_quote">"Always implement things when you actually need them, never when you just foresee that you need them."</div>
<p class="CDPAlignRight CDPAlign"><em>- Ron Jeffries</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MVP – Minimum Viable Product</h1>
                </header>
            
            <article>
                
<p>By taking a <strong>Minimum Viable Product</strong> (<strong>MVP</strong>) approach, the scope of a piece of work is limited to the smallest set of requirements in order to produce a functioning deliverable. MVP is often combined with Agile software development (see the <em>Software development life cycle patterns</em> section later in the chapter) by limiting requirements to a manageable amount that can be designed, developed, tested, and delivered. This approach lends itself well to smaller website or application development, where a feature set can be progressed all the way to production in a single development cycle.</p>
<p class="mce-root"/>
<div class="packt_infobox">In <a href="3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml">Chapter 3</a>, <em>Implementing Design Patterns - Basics Part 1</em>, MVP will be illustrated in a fictitious scenario where the technique will be used to limit the scope of changes as well as to help the team focus during the design and requirement gathering phases.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SOLID</h1>
                </header>
            
            <article>
                
<p>SOLID is one of the most influential design principles and we will cover it in more detail in <a href="3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml">Chapter 3</a>, <em>Implementing Design Patterns<span> </span>- Basics Part 1</em>. Actually made up of five design principles, the intention of SOLID is to encourage designs that are more maintainable and easier to understand. These principles encourage code bases that are easier to modify and they reduce the risk of issues being introduced.</p>
<div class="packt_infobox">In <a href="3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml">Chapter 3</a>, <em>Implementing Design Patterns<span> </span>- Basics Part 1,</em> SOLID will be covered in more detail by being applied to a C# application.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single responsibility principle</h1>
                </header>
            
            <article>
                
<p>A class should have only one responsibility. The goal of this principle is to simplify our classes and logically structure them. Classes with multiple responsibilities are harder to understand and modify, as they are more complex. Responsibility in this circumstance is simply a reason for the change. Another way of looking at responsibility is to define it as a single part of the functionality: </p>
<div class="packt_quote"><span>"A class should have one, and only one, reason to change."</span></div>
<p class="CDPAlignRight CDPAlign"><em>- Robert C. Martin</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Open/closed principle</h1>
                </header>
            
            <article>
                
<p>The open/closed principle is best described in terms of OOP. A class should be designed with inheritance as a means of extending its functionality. Change, in other words, is planned for and considered while the class is being designed. By defining and using an interface that the class implements, the open/closed principle is applied. The class is <em>open</em> for modification, while its description, the interface, is <em>closed </em>for modification.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Liskov substitution principle</h1>
                </header>
            
            <article>
                
<p>Being able to substitute objects at runtime is the basis of the Liskov substitution principle. In OOP, if a class inherits from a base class or implements an interface, then it can be referenced as an object of the base class or interface. This is easier to describe with a simple example.</p>
<p>We'll define an interface for an animal and implement two animals, <kbd>Cat</kbd> and <kbd>Dog</kbd>, as follows:</p>
<pre>interface IAnimal<br/>{<br/>     string MakeNoise();<br/>}<br/>class Dog : IAnimal<br/>{<br/>   public string MakeNoise()<br/>     {<br/>        return "Woof";<br/>     }<br/>}<br/>class Cat : IAnimal<br/>{<br/>    public string MakeNoise()<br/>    {<br/>        return "Meouw";<br/>    }<br/>}</pre>
<p>Then we can refer to the <kbd>Cat</kbd> and <kbd>Dog</kbd> as an animal as follows:</p>
<pre>var animals = new List&lt;IAnimal&gt; { new Cat(), new Dog() };<br/><br/>foreach(var animal in animals)<br/>{<br/>    Console.Write(animal.MakeNoise());<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interface segregation principle</h1>
                </header>
            
            <article>
                
<p>Similar to the single responsibility principle, the interface segregation principle states that an interface should be limited to containing only methods that are relevant to a single responsibility. By reducing the complexity of the interface, the code becomes easier to refactor and understand. An important benefit of adhering to this principle in a system is that it aids in decoupling a system by reducing the number of dependencies.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dependency inversion principle</h1>
                </header>
            
            <article>
                
<p><span>The </span><strong>dependency inversion principle</strong><span> (</span><strong>DIP</strong><span>), also referred to as the dependency injection principle, states that modules should not depend on details but on abstractions instead. This principle encourages writing loosely coupled code to enhance readability and maintenance, especially in a large complex code base.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Software patterns</h1>
                </header>
            
            <article>
                
<p>Over the years, many patterns have been compiled into catalogs. This section will use two catalogs as an illustration. The first catalog is a collection of OOP-related patterns by the <strong>GoF</strong>. The second relates to the integration of systems and remains<span> </span>technologically <span>agnostic</span>. At the end of the chapter, there are some references for additional catalogs and resources.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GoF patterns</h1>
                </header>
            
            <article>
                
<p>Potentially, the most influential and well-known OOP collection of patterns comes from the <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> book by <em>GoF.</em> The aim of the patterns in the book is on a lower level—that is, object creation and interaction—instead of a larger software architecture concern. The collection consists of templates that can be applied to particular scenarios with the goal of producing solid building blocks while avoiding common pitfalls in object-oriented development.</p>
<div class="packt_infobox"><em>Erich Gamma, John Vlissides, Richard Helm</em>, and <em>Ralph Johnson</em> are referred to as the GoF because of their widely influential publications in the 1990s. The book <em>Design Patterns: Elements of Reusable Object-Oriented Software </em>has been translated into several languages and contains examples in both C++ and Smalltalk. </div>
<p>The collection is broken into three categories: creational patterns, structural patterns, and behavioral patterns <span>which will be explained in the following sections</span>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creational patterns</h1>
                </header>
            
            <article>
                
<p>The following five patterns are concerned with the instantiation of objects:</p>
<ul>
<li><strong>Abstract Factory</strong>: A pattern for the creation of objects belonging to a family of classes. The specific object is determined at runtime.</li>
<li><strong>Builder</strong>: A useful pattern for more complex objects where the construction of the object is controlled externally to the constructed class.</li>
<li><strong>Factory Method</strong>: A pattern for creating objects derived from a class where the specific class is determined at runtime.</li>
<li><strong>Prototype</strong>: A pattern for copying or cloning an object. </li>
<li><strong>Singleton</strong>: A pattern for enforcing only one instance of a class.</li>
</ul>
<div class="packt_infobox"><span>In <a href="3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml">Chapter 3</a>, <em>Implementing Design Patterns - Basics Part 1</em>, the Abstract Factory pattern will be explored in more detail. In <a href="4f644693-85a7-4543-af8c-109d8519b2e5.xhtml">Chapter 4</a>, <em>Implementing Design Patterns - Basics Part 2</em>, the Singleton and Factory Method patterns will be explored in detail, including using the .NET Core framework support for these patterns.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Structural patterns</h1>
                </header>
            
            <article>
                
<p>The following patterns are concerned with defining relationships between classes and objects:</p>
<ul>
<li><strong>Adapter</strong>: A pattern for providing a match between two different classes</li>
<li><strong>Bridge</strong>: A pattern for allowing the implementation details of a class to be replaced without requiring the class to be modified</li>
<li><strong>Composite</strong>: Used to create a hierarchy of classes in a tree structure</li>
<li><strong>Decorator</strong>: A pattern for replacing the functionality of a class at runtime</li>
<li><strong>Facade</strong>: A pattern used to simplify complex systems</li>
<li><strong>Flyweight</strong>: A pattern used to reduce the resource usage for complex models</li>
<li><strong>Proxy</strong>: A pattern used to represent another object allowing for an additional level of control between the calling and called objects</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decorator patterns</h1>
                </header>
            
            <article>
                
<p class="mce-root">To illustrate a structural pattern, let's take a closer look at the Decorator pattern by using an example. This example will print messages on a console application. First, a base message is defined with a corresponding interface:</p>
<pre>interface IMessage<br/>{<br/>    void PrintMessage();<br/>}<br/><br/>abstract class Message : IMessage<br/>{<br/>    protected string _text;<br/>    public Message(string text)<br/>    {<br/>        _text = text;<br/>    }<br/>    abstract public void PrintMessage();<br/>}</pre>
<p>The base class allows for the storage of a text string and requires that child classes implement the <kbd>PrintMessage()</kbd> method. This will then be extended into two new classes.</p>
<p>The first class is a <kbd>SimpleMessage</kbd> that writes the given text to the console:</p>
<pre>class SimpleMessage : Message<br/>{<br/>    public SimpleMessage(string text) : base(text) { }<br/><br/>    public override void PrintMessage()<br/>    {<br/>        Console.WriteLine(_text);<br/>    }<br/>}</pre>
<p>The second class is an <kbd>AlertMessage</kbd> that also writes the given text to the console but performs a beep as well:</p>
<pre>class AlertMessage : Message<br/>{<br/>    public AlertMessage(string text) : base(text) { }<br/>    public override void PrintMessage()<br/>    {<br/>        Console.Beep();<br/>        Console.WriteLine(_text);<br/>    }<br/>}</pre>
<p>The difference between the two is that the <kbd>AlertMessage</kbd> class will issue a beep instead of only printing the text to the screen like the <kbd>SimpleMessage</kbd> class.</p>
<p>Next, a base decorator class is defined that will contain a reference to a <kbd>Message</kbd> object as follows:</p>
<pre>abstract class MessageDecorator : IMessage<br/>{<br/>    protected Message _message;<br/>    public MessageDecorator(Message message)<br/>    {<br/>        _message = message;<br/>    }<br/><br/>    public abstract void PrintMessage();<br/>}</pre>
<p>The following two classes illustrate the Decorator pattern by providing additional functionality for our existing implementation of <kbd>Message</kbd>.</p>
<p>The first is a <kbd>NormalDecorator</kbd> that prints the message whose foreground is green:</p>
<pre>class NormalDecorator : MessageDecorator<br/>{<br/>    public NormalDecorator(Message message) : base(message) { }<br/><br/>    public override void PrintMessage()<br/>    {<br/>        Console.ForegroundColor = ConsoleColor.Green;<br/>        _message.PrintMessage();<br/>        Console.ForegroundColor = ConsoleColor.White;<br/>    }<br/>}</pre>
<p><kbd>ErrorDecorator</kbd> uses a red foreground color to make the message more pronounced when printed to the console:</p>
<pre><br/>class ErrorDecorator : MessageDecorator<br/>{<br/>    public ErrorDecorator(Message message) : base(message) { }<br/><br/>    public override void PrintMessage()<br/>    {<br/>        Console.ForegroundColor = ConsoleColor.Red;<br/>        _message.PrintMessage();<br/>        Console.ForegroundColor = ConsoleColor.White;<br/>    }<br/>}</pre>
<p><kbd>NormalDecorator</kbd> will print the text in green while the <kbd>ErrorDecorator</kbd> will print the text in red. The important thing with this example is that the decorator is extending the behavior of the referenced <kbd>Message</kbd> object.</p>
<p>To complete the example, the following shows how new messages can be used:</p>
<pre>static void Main(string[] args)<br/>{<br/>    var messages = new List&lt;IMessage&gt;<br/>    {<br/>        new NormalDecorator(new SimpleMessage("First Message!")),<br/>        new NormalDecorator(new AlertMessage("Second Message with a beep!")),<br/>        new ErrorDecorator(new AlertMessage("Third Message with a beep and in red!")),<br/>        new SimpleMessage("Not Decorated...")<br/>    };<br/>    foreach (var message in messages)<br/>    {<br/>        message.PrintMessage();<br/>    }<br/>    Console.Read();<br/>}</pre>
<p>Running the example will illustrate how the different Decorator patterns can be used to change the referenced functionality as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/38b95d57-b790-4f1f-bb20-6984784a8d82.png" style=""/></div>
<p>This is a simplified example but imagine a scenario where a new requirement is added to the project. Instead of using the beep sound, the system sound for exclamation should be played. </p>
<pre>class AlertMessage : Message<br/>{<br/>    public AlertMessage(string text) : base(text) { }<br/>    public override void PrintMessage()<br/>    {<br/>        System.Media.SystemSounds.Exclamation.Play();<br/>        Console.WriteLine(_text);<br/>    }<br/>}</pre>
<p><span>As we have a structure in place to handle this, the amendment is a one-line change as shown in the previous code block.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Behavioral patterns</h1>
                </header>
            
            <article>
                
<p>The following behavioral patterns can be used to define the communication between classes and objects:</p>
<ul>
<li><strong>Chain</strong> <strong>of</strong> <strong>Responsibility</strong>: A pattern for handling a request between a collection of objects</li>
<li><strong>Command</strong><span>:</span> A pattern used to represent a request</li>
<li><strong>Interpreter</strong><span>:</span> A pattern for defining syntax or language for instructions in a program</li>
<li><strong>Iterator</strong><span>:</span> A pattern for traversing a collection of items without detailed knowledge of the elements in a collection</li>
<li><strong>Mediator</strong><span>:</span> A pattern for simplifying communication between classes</li>
<li><strong>Memento</strong><span>: </span>A pattern for capturing and storing the state of an object</li>
<li><strong>Observer</strong>: A pattern for allowing objects to be notified of changes to another object's state</li>
<li><strong>State</strong>: A pattern for altering an object's behavior when its state changes</li>
<li><strong>Strategy</strong>: A pattern for implementing a collection of algorithms where a specific algorithm can be applied at runtime</li>
<li><strong>Template</strong> <strong>Method</strong>: A pattern for defining the steps of an algorithm while leaving the implementation details in a subclass</li>
<li><strong>Visitor</strong>: A pattern promoting loose coupling between data and functionality, allowing for additional operations to be added without requiring changes to the data classes</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chain of responsibility</h1>
                </header>
            
            <article>
                
<p>A useful pattern you need to be familiar with is the Chain of Responsibility pattern so we will use it as an example. With this pattern, we will set up a collection or chain of classes for handling a request. The idea is the request will pass through each class until it is handled. T<span>his illustration uses a car service center, where each car will pass through the different sections of the center until the service is complete.</span></p>
<p>Let's start by defining a collection of flags that will be used to indicate the services required:</p>
<pre>[Flags]<br/>enum ServiceRequirements<br/>{<br/>    None = 0,<br/>    WheelAlignment = 1,<br/>    Dirty = 2,<br/>    EngineTune = 4,<br/>    TestDrive = 8<br/>}</pre>
<div class="packt_tip">The <kbd>FlagsAttribute</kbd> in C# is a great way of using a bit field to hold a collection of flags. The single field will be used to indicate the enum values that are <em>turned on</em> by using bitwise operations. </div>
<p>The <kbd>Car</kbd> will contain a field to capture what servicing is required and a field that returns true when the service has been completed:</p>
<pre>class Car<br/>{<br/>    public ServiceRequirements Requirements { get; set; }<br/><br/>    public bool IsServiceComplete<br/>    {<br/>        get<br/>        {<br/>            return Requirements == ServiceRequirements.None;<br/>        }<br/>    }<br/>}</pre>
<p>One thing to point out is that a <kbd>Car</kbd> is considered to have its service completed once all the requirements have been completed, as represented by the <kbd>IsServiceComplete</kbd> property.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>An abstract base class will be used to represent each of our service technicians in the following manner:</p>
<pre>abstract class ServiceHandler<br/>{<br/>    protected ServiceHandler _nextServiceHandler;<br/>    protected ServiceRequirements _servicesProvided;<br/><br/>    public ServiceHandler(ServiceRequirements servicesProvided)<br/>    {<br/>        _servicesProvided = servicesProvided;<br/>    }<br/>}</pre>
<p>Take note that the service provided by the class that extends the <kbd>ServiceHandler</kbd> class, in other words the technician, is required to be passed in.</p>
<p>The service will then be performed by using the bitwise <kbd>NOT</kbd> operation (<kbd>~</kbd>) to <em>turn off</em> the bit on the given <kbd><span>Car</span></kbd>, indicating the service is required in the <kbd>Service</kbd> method: </p>
<pre>public void Service(Car car)<br/>{<br/>    if (_servicesProvided == (car.Requirements &amp; _servicesProvided))<br/>    {<br/>        Console.WriteLine($"{this.GetType().Name} providing {this._servicesProvided} services.");<br/>        car.Requirements &amp;= ~_servicesProvided;<br/>    }<br/><br/>    if (car.IsServiceComplete || _nextServiceHandler == null)<br/>        return;<br/>    else<br/>        _nextServiceHandler.Service(car);<br/>}</pre>
<p>If all services have been completed on the car and/or there are no more services, the chain is stopped. If there is another service and a car is not ready, then the next service handler is called.</p>
<p>This approach requires the chain to be set and the preceding <span>example shows this being done using the</span><span> </span><kbd>SetNextServiceHandler()</kbd> <span>method to set the next service to be performed:</span></p>
<pre>public void SetNextServiceHandler(ServiceHandler handler)<br/>{<br/>    _nextServiceHandler = handler;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The service specialists include a <kbd>Detailer</kbd>, <kbd>Mechanic</kbd>, <kbd>WheelSpecialist</kbd>, and a <kbd>QualityControl</kbd> engineer. The <kbd>ServiceHandler</kbd> representing a <kbd>Detailer</kbd> is shown in the following code:</p>
<pre class="mce-root">class Detailer : ServiceHandler<br/>{<br/>    public Detailer() : base(ServiceRequirements.Dirty) { }<br/>}</pre>
<p class="mce-root">The mechanic, whose specialty is tuning the engine, is shown in the following code:</p>
<pre class="mce-root">class Mechanic : ServiceHandler<br/>{<br/>    public Mechanic() : base(ServiceRequirements.EngineTune) { }<br/>}</pre>
<p>The wheel specialist is shown in the following code:</p>
<pre class="mce-root">class WheelSpecialist : ServiceHandler<br/>{<br/>    public WheelSpecialist() : base(ServiceRequirements.WheelAlignment) { }<br/>}</pre>
<p>And last is quality control, who will take the car for a test drive:</p>
<pre class="mce-root">class QualityControl : ServiceHandler<br/>{<br/>    public QualityControl() : base(ServiceRequirements.TestDrive) { }<br/>}</pre>
<p>The service center technicians have been defined, so the next step is to service a couple of cars. This will be illustrated in the <kbd>Main</kbd> code block, starting with constructing the required objects:</p>
<pre>static void Main(string[] args)<br/>{ <br/>    var mechanic = new Mechanic();<br/>    var detailer = new Detailer();<br/>    var wheels = new WheelSpecialist();<br/>    var qa = new QualityControl();</pre>
<p>The next step will be to set up the <span>handling </span>order for the different services:</p>
<pre>    qa.SetNextServiceHandler(detailer);<br/>    wheels.SetNextServiceHandler(qa);<br/>    mechanic.SetNextServiceHandler(wheels);</pre>
<p class="mce-root"/>
<p>Then two calls will be made to the mechanic, which is the start of the chain of responsibility:</p>
<pre>    Console.WriteLine("Car 1 is dirty");<br/>    mechanic.Service(new Car { Requirements = ServiceRequirements.Dirty });<br/><br/>    Console.WriteLine();<br/><br/>    Console.WriteLine("Car 2 requires full service");<br/>    mechanic.Service(new Car { Requirements = ServiceRequirements.Dirty | <br/>                                                ServiceRequirements.EngineTune | <br/>                                                ServiceRequirements.TestDrive | <br/>                                                ServiceRequirements.WheelAlignment });<br/><br/>    Console.Read();<br/>}</pre>
<p>An important thing to note is the order in which the chain is set. For this service center, the mechanic first performs tuning, followed by the wheels being aligned. Then, a test drive is performed and after that, the car is worked up in detail. Originally, the test drive used to be performed as the last step, but the service center determined that, on rainy days, this required the car details to be repeated. A bit of a silly example, but it illustrates the benefit of having the chain of responsibility defined in a flexible manner.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/50fb4e09-4160-462b-91f8-2a84ddde769c.png" style=""/></div>
<p><span>The preceding s</span><span>c</span><span>reenshot shows the display after our two cars have been serviced.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observer pattern</h1>
                </header>
            
            <article>
                
<p>An interesting pattern to explore in more detail is the<span> </span><strong>Observer pattern</strong>. This pattern allows for instances to be informed of when a particular event happens in another instance. In this way, there are many observers and a single subject. The following diagram illustrates this pattern:</p>
<p class="mce-root"/>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c945ea79-025c-437f-a14b-f61c6af08216.png" style=""/></div>
<p>Let's provide an example by creating a simple C# console application that will create a single instance of a<span> </span><kbd>Subject</kbd><span> </span>class and multiple<span> </span><kbd>Observer</kbd><span> </span>instances. When a quantity value changes in the<span> </span><kbd>Subject</kbd><span> </span>class, we want each<span> </span><kbd>Observer</kbd><span> </span>instance to be notified.</p>
<p>The<span> </span><kbd>Subject</kbd><span> </span>class contains a private quantity field that is updated by a public<span> </span><kbd>UpdateQuantity</kbd><span> </span>method:</p>
<pre>class Subject<br/>{<br/>    private int _quantity = 0;<br/><br/>    public void UpdateQuantity(int value)<br/>    {<br/>        _quantity += value;<br/><br/>        // alert any observers<br/>    }<br/>}</pre>
<p>In order to alert any observers, we use the C# keywords, <kbd>delegate</kbd><span> </span>and<span> </span><kbd>event</kbd>. The<span> </span><kbd>delegate</kbd> keyword defines the format or handler that will be called. The delegate to be used when the quantity is updated is shown in the following code:</p>
<pre>public delegate void QuantityUpdated(int quantity);</pre>
<p>The delegate defines<span> </span><kbd>QuantityUpdated</kbd><span> </span>to be a method that receives an integer and does not return any value. An event is then added to the<span> </span><kbd>Subject</kbd><span> </span>class as follows:</p>
<pre>public event QuantityUpdated OnQuantityUpdated;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>And, in the<span> </span><kbd>UpdateQuantity</kbd><span> </span>method, it is called as follows:</p>
<pre>public void UpdateQuantity(int value)<br/>{<br/>    _quantity += value;<br/><br/>    // alert any observers<br/>    OnQuantityUpdated?.Invoke(_quantity);<br/>}</pre>
<p>In this example, we will define a method in the<span> </span><kbd>Observer</kbd><span> </span>class that has the same signature as the<span> </span><kbd>QuantityUpdated</kbd><span> </span>delegate:</p>
<pre>class Observer<br/>{<br/>    ConsoleColor _color;<br/>    public Observer(ConsoleColor color)<br/>    {<br/>        _color = color;<br/>    }<br/><br/>    internal void ObserverQuantity(int quantity)<br/>    {<br/>        Console.ForegroundColor = _color;<br/>        Console.WriteLine($"I observer the new quantity value of {quantity}.");<br/>        Console.ForegroundColor = ConsoleColor.White;<br/>    }<br/>}</pre>
<p>This implementation will be alerted when the quantity of the<span> </span><kbd>Subject</kbd><span> </span>instance changes and will print a message to the console in a specific color.</p>
<p>Let's put these together in a simple application. At the start of the application, a single<span> </span><kbd>Subject</kbd><span> </span>and three<span> </span><kbd>Observer</kbd><span> </span>objects will be created:</p>
<pre>var subject = new Subject();<br/>var greenObserver = new Observer(ConsoleColor.Green);<br/>var redObserver = new Observer(ConsoleColor.Red);<br/>var yellowObserver = new Observer(ConsoleColor.Yellow);</pre>
<p>Next, each<span> </span><kbd>Observer</kbd><span> </span>instance will register to be alerted by the<span> </span><kbd>Subject</kbd><span> </span>when the quantity changes:</p>
<pre>subject.OnQuantityUpdated += greenObserver.ObserverQuantity;<br/>subject.OnQuantityUpdated += redObserver.ObserverQuantity;<br/>subject.OnQuantityUpdated += yellowObserver.ObserverQuantity;</pre>
<p>Then, we will update the quantity twice, as shown here:</p>
<pre>subject.UpdateQuantity(12);<br/>subject.UpdateQuantity(5); </pre>
<p>When the application is run, we get three messages printed in different colors for each update statement, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6bd7a38b-7646-41ff-b808-139593727342.png" style=""/><br/></div>
<p>This was a simple sample using the C#<span> </span><kbd>event</kbd><span> </span>keyword, but, hopefully, it illustrates how this pattern could be used. The advantage here is it loosely couples the subject from the observers. The subject does not have to have knowledge of the different observers, or even knowledge of whether any exist.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enterprise integration patterns</h1>
                </header>
            
            <article>
                
<p><strong>Integration</strong> is a discipline of software development that benefits greatly from leveraging the knowledge and experience of others. With this in mind, many catalogs of EIPs exist, some of which are technology agnostic <span><span>while others are</span></span> tailored to a particular technology stack. This section will highlight some popular integration patterns.</p>
<div class="packt_infobox"><em>Enterprise Integration Patterns</em>, by <em>Gregor Hohpe</em> and <em>Bobby Woolf</em>, provides a solid resource for many integration patterns across a variety of technologies. This book is often referenced when discussing EIPs. The book is available at <a href="https://www.enterpriseintegrationpatterns.com/">https://www.enterpriseintegrationpatterns.com/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Topology</h1>
                </header>
            
            <article>
                
<p>An important consideration for enterprise integration is the topology of the systems being connected. In general, there are two distinct topologies: hub-and-spoke and enterprise service bus.</p>
<p class="mce-root"/>
<p>A <strong>hub-and-spoke</strong> (hub) topology describes an integration pattern where a single component, the hub, is centralized and it communicates with each application explicitly. This centralizes the communication so that the hub only needs to know about the other applications, as illustrated in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/04877dd8-6fef-492a-9f17-cdde6bd30f1c.png" style=""/></div>
<p>The diagram shows the hub, in blue, as having explicit knowledge of how to communicate with the different applications. This means that, when a message is to be sent from A to B, it is sent from A to the hub and then forwarded on to B. The advantage of this approach for an enterprise is that connectivity to B has to be defined and maintained only in one place, the hub. The significance here is that the security is controlled and maintained in one central location. </p>
<p>An <strong>enterprise service bus</strong> (<strong>ESB</strong>) relies on a messaging model comprising of publishers and subscribers (Pub-Sub). A publisher submits messages to the bus and a subscriber registers to receive published messages. The following diagram illustrates this topology:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5707b39e-5129-49e1-aa5c-cac62cc3f58f.png" style=""/></div>
<p class="mce-root"/>
<p>In the preceding diagram, if a message is to be routed from <strong>A</strong> to <strong>B</strong>, <strong>B</strong> subscribes to the ESB for messages published from <strong>A</strong>. When <strong>A</strong> publishes a new message, the message is sent to <strong>B</strong>. In practice, the subscription can be more complex. For example, in an ordering system, there might be two subscribers for priority orders and normal orders. In this situation, priority orders might then be handled differently from normal orders.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Patterns</h1>
                </header>
            
            <article>
                
<p>If we define an integration between two systems as having distinct steps, we can then define patterns in each step. Let's take a look at the following diagram to discuss an integration pipeline:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b23a2329-2813-437d-8cfa-914e26954910.png" style=""/></div>
<p>This pipeline is simplified as there could be more or fewer steps in a pipeline depending on the technology used. The purpose of the diagram is to provide some context as we look at some common integration patterns. These can be broken into categories as follows:</p>
<ul>
<li><strong>Messaging</strong>: Patterns related to the handling of messages</li>
<li><strong>Transformation</strong>: Patterns related to altering message content</li>
<li><strong>Routing</strong>: Patterns related to the exchange of messages</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Messaging</h1>
                </header>
            
            <article>
                
<p>Patterns related to messaging can take the form of message construction and channels. A channel, in this context, is the endpoint and/or how the message enters and exits the integration pipeline. Some examples of construction-related patterns are the following:</p>
<ul>
<li><strong>Message Sequence</strong>: The message contains a sequence to indicate a particular processing order.</li>
<li><strong>Correlation Identifier</strong><span>:</span> The message contains a medium to identify related messages.</li>
<li><strong>Return Address</strong><span>:</span> The message identifies information about returning a response message.</li>
<li><strong>Expiration</strong>: The message has a finite time that it is considered valid.</li>
</ul>
<p class="mce-root"/>
<p>In the <em>Topology</em> section, we covered some patterns related to channels but the following are additional patterns you should consider in integration:</p>
<ul>
<li><strong>Competing Consumers</strong>: Multiple processes could handle the same message.</li>
<li><strong>Selective Consumer</strong>: Consumers use criteria to determine the message to process.</li>
<li><strong>Dead Letter Channel</strong>: Handles messages that are not successfully processed.</li>
<li><strong>Guaranteed Delivery</strong>: Ensures reliable handling of messages, where no message is lost.</li>
<li><strong>Event-driven Consumer:</strong> The handling of messages is based on published events.</li>
<li><strong>Polling Consumer:</strong> Handles messages that are retrieved from a source system.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transformation</h1>
                </header>
            
            <article>
                
<p>When integrating complex enterprise systems, transformation patterns allow for flexibility in how messages are handled in the system. With transformation, a message between two applications can be altered and/or enhanced. Here are some transformation-related patterns:</p>
<ul>
<li><strong>Content Enricher</strong>: A message is <em>enriched</em> by adding information.</li>
<li><strong>Canonical Data Model</strong>: A message is transformed into an application-neutral message format.</li>
<li><strong>Message Translator</strong>: A pattern for translating one message to another.</li>
</ul>
<p>The <strong>Canonical Data Model</strong> (<strong>CDM</strong>) is a good pattern to highlight. With this pattern, a message can be exchanged between multiple applications without having to perform a translation for each specific message type. This is best shown by an example of multiple systems exchanging messages, as illustrated in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/00eb3fd5-9c81-45d5-8c3a-8c9703de4bed.png" style=""/></div>
<p class="mce-root"/>
<p>In the diagram, applications <strong>A</strong> and <strong>C</strong> want to send their messages in their format to application <strong>B</strong> and <strong>D</strong>. If we used the Message Translator pattern, <span>only the process, which is handling the transformation, would need to know how to translate from</span> <strong>A</strong> to <strong>B</strong> <span>and from</span> <strong>A</strong> to <strong>D</strong> as well as <strong>C</strong> to <strong>B</strong> and <strong>C</strong> to <strong>D</strong>. <span>This becomes increasingly difficult as the number of applications increases and when the publisher might not know the details of its consumers. With the CDM, source application messages</span> for <strong>A</strong> and <strong>B</strong> are translated into a neutral schema X.</p>
<div class="packt_infobox"><span><span class="packt_screen">Canonical schema</span></span><br/>
A canonical schema is sometimes referred to as a neutral schema, meaning it is not aligned directly with a source or destination system. The schema is then thought of as being impartial.</div>
<p>The message in the neutral schema format is then translated to the message formats for <strong>B</strong> and <strong>D</strong> as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/16e7e2ad-8684-4ee0-beaf-add4d3bcb4d3.png" style=""/></div>
<p>In the enterprise, this becomes unmanageable without some standards, and fortunately, many organizations have been created to produce as well as govern standards in many industries, including the following examples (but there are many more!):</p>
<ul>
<li><strong>Electronic Data Interchange For Administration, Commerce and Transport</strong> (<strong>EDIFACT</strong>): An international standard for trade</li>
<li><strong>IMS Question and Test Interoperability specification</strong> (<strong>QTI</strong>)<strong>:</strong> Standards for the representation of assessment content and results produced by the <span><strong>Information Management System</strong> <strong>(</strong></span><strong>IMS</strong>) <strong>Global Learning Consortium</strong> (<strong>GLC</strong>)</li>
<li><strong>Hospitality Industry Technology Integration Standards (HITIS)</strong>: Standards for property management systems maintained by the American Hotel and Motel Association</li>
<li><strong>X12 EDI (X12)</strong>: Collection of schemas for health care, insurance, government, finance, transportation, and other industries maintained by the Accredited Standards Committee X12</li>
<li><strong>Business Process Framework</strong> (<strong>eTOM</strong>): Telecommunications operating model maintained by the TM Forum</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Routing</h1>
                </header>
            
            <article>
                
<p>Routing patterns provide different approaches to handling messages. Here are some examples of patterns that fall into this category:</p>
<ul>
<li><strong>Content-based Routing</strong>: The route or destination application(s) is determined by the content in the message.</li>
<li><strong>Message Filtering</strong>: Only messages of interest are forwarded on to the destination application(s).</li>
<li><strong>Splitter</strong>: Multiple messages are generated from a single message.</li>
<li><strong>Aggregator</strong>: A single message is generated from multiple messages.</li>
<li><strong>Scatter-Gather</strong>: A pattern for handling a broadcast of multiple messages and aggregating the responses into a single message.</li>
</ul>
<p>The Scatter-Gather pattern is a very useful pattern and, as it combines both the Splitter and Aggregator patterns, it is a great example to explore. With this pattern, a more complex business process can be modeled.</p>
<p>In our scenario, we will take the fulfillment of an ordering system of widgets. The good news is, several vendors, sell widgets, but the price of widgets fluctuates often. So, which vendor has the best price changes? Using the Scatter-Gather pattern, the ordering system can query multiple vendors, select the best price, and then return the result back to the calling system. </p>
<p>The Splitter pattern will be used to generate multiple messages to the vendors as shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fb4565e5-a899-41d0-8c81-1d050bf2f76f.png" style=""/></div>
<p>The routing then waits until the vendor responses are received. Once the responses have been received, the Aggregator pattern is used to compile the results into a single message to the calling application: </p>
<p class="mce-root"/>
<div class="CDPAlignCenter CDPAlign"><img src="assets/451c57f7-ef45-48ee-ae38-abd3ee2493e2.png" style=""/></div>
<p>It is worth noting that there are many variations and circumstances for this pattern. The Scatter-Gather pattern might require all vendors to respond or just some of them. Another scenario might require a limit on the amount of time the process should wait for a response from a vendor. Some messages might take milliseconds for a response while other scenarios might take days for a response to be returned. </p>
<div class="packt_infobox"><span>An integration engine is software that supports many integration patterns. The integration engine can range from locally installed services to cloud-based solutions. Some of the more popular engines are Microsoft BizTalk, Dell Boomi, MuleSoft Anypoint Platform, IBM WebSphere, and SAS Business Intelligence.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Software development life cycle patterns</h1>
                </header>
            
            <article>
                
<p>There are many approaches to managing software development and the two most common <strong>software development life cycle</strong> (<strong>SDLC</strong>) patterns are <strong>Waterfall</strong> and <strong>Agile</strong>. There are many variations of these two SDLC methodologies and often an organization will adapt a methodology to fit the project and team(s) as well as the company culture. </p>
<div class="packt_tip">The Waterfall and Agile SDLCs patterns are just two examples and there are several other patterns for software development that may suit a company's culture, software maturity, and industry better than others. </div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Waterfall SDLC</h1>
                </header>
            
            <article>
                
<p>The Waterfall approach comprises distinct phases that a project or piece of work goes through sequentially. Conceptually, it is simple to understand and it follows patterns used in other industries. The following is an example of the different phases:</p>
<ul>
<li><strong>Requirements phase</strong>: All requirements to be implemented are gathered and documented.</li>
<li><strong>Design phase</strong>: Using the documentation produced in the previous step, the design that which is to be implemented is completed.</li>
<li><strong>Development phase</strong>: Using the design from the previous step, the changes are implemented.</li>
<li><strong>Testing phase</strong>: The changes implemented in the previous step are verified against the specified requirements.</li>
<li><strong>Deployment phase</strong>: Once the testing has been completed, the changes performed by the project are deployed.</li>
</ul>
<p>There are many strengths to the Waterfall model. The model is easy to understand and easy to manage, as each phase has a clear definition of what has to be done and what has to be delivered out of each phase. By having a series of phases, milestones can be defined, allowing for easier reporting on progress. Also, with distinct phases, the roles and responsibilities of the resources required can be more easily planned.</p>
<p>But what if something does not go to plan or things change? The Waterfall SDLC does have some disadvantages, and many of the disadvantages stem from its lack of flexibility for change, or the instances when things are discovered, requiring input from a previous step. In Waterfall, if a situation occurs requiring information from a previous phase, the previous phase is repeated. This poses several problems. As phases might be reported, reporting becomes difficult because a project (that had passed a phase or milestone) is now repeating the phase. This could promote a <em>witch-hunt</em> company culture, where the effort is diverted to finding blame rather than measures to prevent <span>recurring</span> issues. Also, resources might no longer be available, as they have been moved onto other projects and/or have left the company.</p>
<p>The following diagram illustrates how the cost and time increase the further into the phases that an issue is discovered:</p>
<p class="mce-root"/>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0fd85921-da03-4dc6-a7fa-96788393df98.png" style=""/></div>
<p>Because of the cost associated with change, the Waterfall SDLC tends to suit smaller projects with a lower risk of change. Larger and more complex projects increase the potential for change, as requirements might be altered or the business drivers change during the project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Agile SDLC</h1>
                </header>
            
            <article>
                
<p>The Agile SDLC approach to software development attempts to embrace change and uncertainty. This is achieved by using a pattern that allows for change and/or the occurrence of issues that are discovered during the life of a project or product development. The key concept is to break the project into smaller iterations of development, often referred to as development cycles. In each cycle, the basic Waterfall stages are repeated so each cycle has requirements, design, development, testing, and deployment phase.</p>
<p>This is a simplification but the strategy of breaking the project into cycles has several advantages over Waterfall:</p>
<ul>
<li>The impact of shifting business requirements is lessened as the scope is smaller.</li>
<li>The stakeholders get a <span>visibly </span>working system earlier than with Waterfall. Though not complete, this provides value as it allows for feedback to be incorporated earlier into a product.</li>
<li>Resourcing might benefit as the type of resources has fewer fluctuations.</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f843873a-17d4-4174-8ca2-3a977d04bf18.png" style=""/></div>
<p><span>The preceding diagram provides a summary of the two approaches.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have discussed major design patterns used in modern software development that were introduced in the previous chapter. We started with the discussion of various software development principles such as the DRY, KISS, YAGNI, MVP, and SOLID programming principles. Then, we covered software development patterns including GoF and EIPs. The methodology for SDLC was covered, including Waterfall and Agile. The purpose of this chapter was to illustrate how patterns <span>are used across</span> all levels of software development. </p>
<p><span>As the software industry matures, patterns emerge as experience evolves, techniques grow, and technology advances. Some patterns have been developed to help different phases of the SDLC. For example in </span><a href="3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml">Chapter 3</a><span>, </span><em>Implementing Design Patterns - Basics Part 1</em><span>, </span><strong>Test-driven development</strong><span> (</span><strong>TDD</strong><span>) will be explored, where the definitions of tests are used to provide both measurable progress as well as clear requirements, during the development phase. As the chapters progress, we will discuss higher levels of abstraction in software development, including patterns for web development as well as modern architecture patterns for on-premise and cloud-based solutions. </span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the next chapter, we will start by building a fictitious application in .NET Core. Also, we will explain the various patterns discussed in this chapter, including programming principles such as SOLID, and illustrate several GoF patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>The following questions will allow you to consolidate the information contained in this chapter:</span></p>
<ol>
<li>In SOLID, what does the S stand for? What is meant by a responsibility?</li>
<li>Which SDLC method is built around cycles: Waterfall or Agile?</li>
<li>Is the Decorator pattern a creational or structural pattern? </li>
<li>What does Pub-Sub integration stand for?</li>
</ol>


            </article>

            
        </section>
    </body></html>