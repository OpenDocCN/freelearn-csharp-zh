- en: Chapter 6. Synchronization Primitives
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。同步原语
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Using monitor
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用监视器
- en: Using mutual exclusion lock
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互斥锁
- en: Using `SpinLock` for synchronization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SpinLock` 进行同步
- en: Interlocked operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互锁操作
- en: Synchronizing multiple tasks with a Barrier
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用屏障同步多个任务
- en: Using `ReaderWriterLockSlim`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ReaderWriterLockSlim`
- en: Using `WaitHandles` with Mutex
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mutex 与 `WaitHandles` 结合
- en: Waiting for multiple threads with `CountdownEvent`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `CountdownEvent` 等待多个线程
- en: Using `ManualResetEventSlim` to spin and wait
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ManualResetEventSlim` 进行自旋和等待
- en: Using `SemaphoreSlim` to limit access
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SemaphoreSlim` 限制访问
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is about coordinating the work that is performed by parallel tasks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于协调并行任务执行的工作。
- en: When concurrent tasks read from and write to variables without an appropriate
    synchronization mechanism, a **race condition** has the potential to appear. Race
    conditions can produce inconsistent results in your program, and can be very difficult
    to detect and correct.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当并发任务在没有适当的同步机制的情况下从变量中读取和写入时，可能会出现 **竞态条件**。竞态条件可能导致程序中出现不一致的结果，并且可能非常难以检测和纠正。
- en: Let's take a second to understand what a race condition is. Consider a scenario
    that has two parallel tasks; task1 and task2\. Each task tries to read and increment
    the value of a public variable. Task1 reads the original value of the variable,
    let's say 10, and increments the value to 11\. At the same time task1 is reading
    the value of the variable but before it increments the value, task2 reads the
    same value of 10 and increments to 11\. The final value of the variable ends up
    being 11 instead of the correct value of 12.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来理解什么是竞态条件。考虑一个有两个并行任务；task1 和 task2 的场景。每个任务都尝试读取和增加一个公共变量的值。task1 读取变量的原始值，比如说
    10，并将值增加到 11。同时，task1 正在读取变量的值，但在它增加值之前，task2 读取相同的值 10 并增加到 11。变量的最终值最终变成了 11，而不是正确的值
    12。
- en: '**.NET framework 4.5** offers several new data structures for parallel programming
    that simplify complex synchronization problems. Knowledge of these synchronization
    primitives will enable you to implement more complex algorithms and solve many
    of the issues associated with multithreaded programming. It is important to learn
    the various alternatives so that you can choose the most appropriate one for scenarios
    that require communication and synchronization among multiple tasks.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET 框架 4.5** 为并行编程提供了几个新的数据结构，这些数据结构简化了复杂的同步问题。了解这些同步原语将使您能够实现更复杂的算法并解决与多线程编程相关的大量问题。了解各种替代方案非常重要，这样您就可以为需要多个任务之间通信和同步的场景选择最合适的方案。'
- en: Using monitor
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用监视器
- en: A monitor, like the lock statement, is a mechanism for ensuring that only one
    thread at a time may be running in a critical section of code. A monitor has a
    lock, and only one thread at a time may acquire it. To run in a critical section
    of code, a thread must have acquired the monitor. While a thread owns the lock
    for an object, no other thread can acquire that lock.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器，就像锁语句一样，是一种确保一次只有一个线程可以运行在代码关键部分的机制。监视器有一个锁，一次只有一个线程可以获取它。要运行在代码的关键部分，线程必须获取监视器。当一个线程拥有对象的锁时，没有其他线程可以获取该锁。
- en: For this recipe, we are going to create an application that uses a `ConsoleWriter`
    class with a `WriteNumbers` method to write some numbers out to the Console. Three
    parallel tasks will each be trying to write some numbers to the Console, and we
    will use monitor to control access to the critical section of code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将创建一个应用程序，该应用程序使用一个具有 `WriteNumbers` 方法的 `ConsoleWriter` 类将一些数字写入控制台。三个并行任务将各自尝试将一些数字写入控制台，我们将使用监视器来控制对代码关键部分的访问。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Have a look at the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下步骤：
- en: Start a new project using the **C# Console Application** project template and
    assign `MonitorExample` as the **Solution name**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板启动一个新的项目，并将 `MonitorExample` 作为 **解决方案名称** 指定。
- en: Add a new class to your project and name the class `ConsoleWriter.cs`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您的项目中添加一个新的类，并将该类命名为 `ConsoleWriter.cs`。
- en: 'Add the following code snippet using the directives to the top of your `ConsoleWriter`
    class:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到 `ConsoleWriter` 类的顶部，使用指令：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, inside the declaration of your `ConsoleWriter` class, create a private
    member variable of type object which we will use as our lock object.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在您的 `ConsoleWriter` 类的声明内部，创建一个类型为 object 的私有成员变量，我们将使用它作为我们的锁对象。
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now let's create a method of the `ConsoleWriter` class called `WriteNumbersUnprotected`.
    This is a simple method that executes a `for` loop. Each iteration of the loop
    will write the number of the loop index to the Console. As you might have guessed
    by the method name, we will not use monitor to lock the critical section of this
    method.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们为`ConsoleWriter`类创建一个名为`WriteNumbersUnprotected`的方法。这是一个简单的执行`for`循环的方法。循环的每次迭代都会将循环索引的数字写入控制台。正如你可能从方法名中猜到的，我们不会使用监视器来锁定此方法的临界区。
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now let's create a method on the `ConsoleWriter` class named `WriteNumbers`.
    This method will have the same functionality as the previous method we created.
    However, this method will use monitor to ensure that only a single thread can
    enter the critical section of code.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们为`ConsoleWriter`类创建一个名为`WriteNumbers`的方法。这个方法将具有与我们之前创建的方法相同的函数功能。然而，这个方法将使用监视器来确保只有一个线程可以进入代码的临界区。
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let''s go back to the `Program` class. Add the following code snippet using
    directives to the top of the `Program` class:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到`Program`类。使用指令将以下代码片段添加到`Program`类的顶部：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `Main` method of the `Program` class, start by creating, and instantiating
    an instance of `ConsoleWriter`. Also create a list of tasks which we will use
    to hold a reference to our tasks.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类的`Main`方法中，首先创建并实例化一个`ConsoleWriter`实例。同时创建一个任务列表，我们将使用它来保存对任务的引用。
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now let's create a `for` loop that creates and starts three tasks. The task
    will each call the `WriteNumbersUnprotected` method of the shared `ConsoleWriter`
    object.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`for`循环，创建并启动三个任务。每个任务将调用共享`ConsoleWriter`对象的`WriteNumbersUnprotected`方法。
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finish up the `Main` method of the `Program` class by waiting on the tasks to
    complete and waiting on user input before exiting.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过等待任务完成并在退出前等待用户输入来完成`Program`类的`Main`方法。
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, in Visual Studio 2012, press *F5* to run the project. You will probably
    see some pretty ugly output because more than one thread is calling the method
    at a time. Have look at the following screenshot:![How to do it…](img/0225OT_06_03.jpg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在Visual Studio 2012中按*F5*来运行项目。你可能会看到一些相当丑陋的输出，因为多个线程同时调用该方法。看看下面的屏幕截图：![如何操作…](img/0225OT_06_03.jpg)
- en: Let's fix this by going back to our tasks in the `Main` method of the `Program`
    class and change them now to call the `WriteNumbers` method which protects the
    critical section of code with monitor.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到`Program`类的`Main`方法中的任务，并将它们现在改为调用带有监视器保护代码临界区的`WriteNumbers`方法。
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's press *F5* again to run the project. This time you should see more orderly
    output because only one thread at a time can be in the critical section. This
    is shown in the following screenshot:![How to do it…](img/0225OT_06_04.jpg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次按*F5*来运行项目。这次你应该看到更有序的输出，因为一次只有一个线程可以进入临界区。这在上面的屏幕截图中有显示：![如何操作…](img/0225OT_06_04.jpg)
- en: How it works…
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Lock and monitor are very similar. In fact, the `lock` keyword is implemented
    using the `Monitor` class. When using `Monitor`, the developer has to be a bit
    more careful to explicitly remove the lock using `exit`. Lock calls `Enter` and
    `Exit` implicitly, but when using `Monitor` they have to be called by the developer.
    It is best practice to call `exit` in a `finally` block to ensure the lock will
    be released in the event of an `Exception`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 锁和监视器非常相似。实际上，`lock`关键字是通过`Monitor`类实现的。当使用`Monitor`时，开发者必须更加小心，显式地使用`exit`来移除锁。Lock隐式调用`Enter`和`Exit`，但使用`Monitor`时，它们必须由开发者调用。最佳实践是在`finally`块中调用`exit`，以确保在发生`Exception`时释放锁。
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using `lock` is generally preferred over using `Monitor` directly. This is because
    lock is more concise and lock ensures that the underlying monitor is released,
    even if the protected code throws an `Exception`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用`lock`比直接使用`Monitor`更受欢迎。这是因为`lock`更简洁，并且确保即使在受保护的代码抛出`Exception`时，底层的监视器也会被释放。
- en: However, the `lock` keyword isn't quite as fully-featured as the `Monitor` class.
    For example, `Monitor` has a `TryEnter` method that can wait for a `lock` for
    a specified period of time instead of waiting infinitely.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`lock`关键字并不像`Monitor`类那样功能全面。例如，`Monitor`有一个`TryEnter`方法，可以在指定的时间内等待`lock`，而不是无限期地等待。
- en: Using a mutual exclusion lock
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用互斥锁
- en: Locking is essential in parallel programs. It restricts code from being executed
    by more than one thread at the same time. Exclusive locking is used to ensure
    that only one thread can enter a particular section of code at a time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定在并行程序中是必不可少的。它限制了代码不能同时被多个线程执行。独占锁定用于确保一次只有一个线程可以进入代码的特定部分。
- en: The simplest way to use synchronization in c# is with the `lock` keyword. The
    `lock` keyword works by marking a block of code as a critical section by obtaining
    a mutual exclusion lock for an object running a statement and then releasing the
    lock.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中使用同步的最简单方法是使用`lock`关键字。`lock`关键字通过为运行语句的对象获取互斥锁来标记代码块为关键部分，然后释放锁。
- en: In this recipe, we are going to create a class that represents a bank account.
    An object of this class will be shared by a couple of parallel tasks that will
    be making a series of withdrawals for random amounts. The critical section of
    code in the `Withdraw` method that updates the balance of the shared account object
    will be protected by a `lock` statement.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个表示银行账户的类。这个类的对象将被几个并行任务共享，这些任务将进行一系列随机金额的提款。`Withdraw`方法中更新共享账户对象余额的关键代码部分将通过`lock`语句进行保护。
- en: How to do it…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s go to Visual Studio 2012 and take a look at the following steps on how
    to use mutual exclusion locks:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去Visual Studio 2012看看如何使用互斥锁的以下步骤：
- en: Start a new project using the **C# Console Application** project template and
    assign `LockExample` as the **Solution name**.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板创建一个新的项目，并将`LockExample`作为**解决方案名称**。
- en: Add a new class to the project and name the class `Account.cs`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个新的类，并将其命名为`Account.cs`。
- en: 'Add the following code snippet using directives to the top of your `Account`
    class:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段使用指令添加到你的`Account`类顶部：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Add a private field of type `double` to the `Account` class to store the balance
    of the account and a private object that will be used for locking.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Account`类中添加一个类型为`double`的私有字段来存储账户余额以及一个用于锁定的私有对象。
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next let's add a constructor to the `Account` class. This constructor should
    accept a parameter of type `double` and should initialize the `balance` field.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们为`Account`类添加一个构造函数。这个构造函数应该接受一个类型为`double`的参数，并初始化`balance`字段。
- en: '[PRE12]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now let's create a `Withdraw` method for the account. If the account has a negative
    balance, the `Withdraw` method should throw an error. Otherwise, the `Withdraw`
    method should obtain a mutual exclusion lock on the `Account` object and deduct
    the requested amount from the balance.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为账户创建一个`Withdraw`方法。如果账户余额为负，则`Withdraw`方法应抛出错误。否则，`Withdraw`方法应获取对`Account`对象的互斥锁，并从余额中扣除请求的金额。
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now let''s go back to our `Program` class. Make sure to add the following code
    snippet using directives that are at the top of the `Program` class:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的`Program`类。确保添加以下代码片段使用指令，这些指令位于`Program`类顶部：
- en: '[PRE14]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create a static `DoTransactions` method for the `Program` class. The `DoTransactions`
    method should loop ten times doing a withdrawal of a random amount.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Program`类创建一个静态的`DoTransactions`方法。`DoTransactions`方法应该循环十次，每次进行随机金额的提款。
- en: '[PRE15]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, in the `Main` method of the `Program` class, let's create a shared
    account object and two tasks that will concurrently execute the withdrawals. Finish
    up by waiting for the user input before exiting.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`Program`类的`Main`方法中，让我们创建一个共享的账户对象和两个将并发执行提款的任务。完成之后，等待用户输入再退出。
- en: '[PRE16]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_06_02.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到类似于以下截图的输出：![如何操作…](img/0225OT_06_02.jpg)
- en: How it works…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `lock` keyword is a c# language shortcut for using the `System.Threading`.`Monitor`
    class. Basically, the `lock` keyword ensures that threads cannot enter a critical
    section of code while another thread is in the critical section; the following
    is the code contained in the scope of the `lock` statement:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock`关键字是C#语言中用于`System.Threading`的`Monitor`类的快捷方式。基本上，`lock`关键字确保当另一个线程在关键部分时，线程不能进入关键代码部分；以下是在`lock`语句作用域内的代码：'
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A critical section is simply a piece of code that accesses a shared resource
    that must not be concurrently accessed by more than one thread.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关键部分只是一段访问必须不能被多个线程并发访问的共享资源的代码。
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If a thread tries to enter a locked section of code, it will block and wait
    until the locked object is released. The lock will be released when the locking
    thread exits the scope of the lock. The `lock` keyword calls `System.Threading.Monitor.Enter`
    at the start of the scope and `System.Threading.Monitor.Exit` at the end of the
    scope.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个线程尝试进入被锁定的代码部分，它将会阻塞并等待直到被锁定的对象被释放。当锁定线程退出锁的作用域时，锁将被释放。`lock` 关键字在作用域的开始调用
    `System.Threading.Monitor.Enter`，在作用域的结束调用 `System.Threading.Monitor.Exit`。
- en: Notice that we created a private lockable object to lock on instead of locking
    on the instance of the `Account` class. This is the best practice. In general,
    you should avoid locking on a public type or on instances of objects that are
    beyond your code's control. If another programmer locks your class to synchronize
    their data, a deadlock can occur. A deadlock is a situation in which two or more
    competing threads are waiting for each other to finish their work and release
    a lock, and thus neither one ever does. Note also that locks can only be obtained
    on reference types.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们创建了一个私有的可锁定对象来锁定，而不是锁定 `Account` 类的实例。这是最佳实践。一般来说，你应该避免锁定在公共类型上或锁定在代码控制之外的对象实例上。如果另一个程序员锁定你的类来同步他们的数据，可能会发生死锁。死锁是一种情况，其中两个或多个竞争线程都在等待对方完成工作并释放锁，因此没有一个线程能够完成。还要注意，锁只能获取引用类型。
- en: Using SpinLock for synchronization
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SpinLock 进行同步
- en: '**SpinLock** is a special purpose lock that should only be used when lock contention
    is relatively rare and when lock-hold times are always very short. Unlike monitor
    and other lock types that work by using what is essentially a wait event; SpinLock
    sits in a loop and repeatedly checks until the lock becomes available. The SpinLock
    can be faster than a monitor lock because it reduces thread context switches.
    However, because the thread is spinning in a loop, a SpinLock can cause high CPU
    usage if locks are held for a long time.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**SpinLock** 是一种特殊用途的锁，只有在锁竞争相对较少且锁持有时间总是非常短的情况下才应使用。与通过使用本质上是一个等待事件来工作的监视器和其它锁类型不同；SpinLock
    在一个循环中等待并重复检查直到锁可用。由于减少了线程上下文切换，SpinLock 可能比监视器锁更快。然而，由于线程在循环中旋转，如果锁被长时间持有，SpinLock
    可能会导致高CPU使用率。'
- en: In this recipe, we are going to revisit our bank account solution which will
    have a shared bank account object that will be updated by multiple tasks in parallel.
    Each of the tasks will have access to the shared account object and will manage
    concurrency using SpinLock.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将重新访问我们的银行账户解决方案，该解决方案将有一个共享的银行账户对象，它将由多个并行任务更新。每个任务都将有权访问共享的账户对象，并使用
    SpinLock 来管理并发。
- en: How to do it…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s create a new Console Application and see how to use SpinLock for synchronization,
    by going through the following steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的控制台应用程序，通过以下步骤来了解如何使用 SpinLock 进行同步：
- en: Start a new project using the **C# Console Application** project template and
    assign `SpinBasedLocking` as the **Solution name**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板启动一个新的项目，并将 `SpinBasedLocking` 作为 **解决方案名称**。
- en: 'Add the following code snippet using directives to the top of your `Program`
    class:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段使用指令添加到 `Program` 类的顶部：
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After the `Program` class, but inside the `SpinBasedLocking` namespace, create
    a very simple definition for an `Account` class. This class only needs to have
    a single `public integer` field for the balance.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类之后，但在 `SpinBasedLocking` 命名空间内部，为 `Account` 类创建一个非常简单的定义。这个类只需要一个
    `public integer` 字段用于余额。
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, in the `Main` method of the `Program` class, let's start by creating the
    shared account object, a `SpinLock`, and a list to hold our tasks.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Program` 类的 `Main` 方法中，让我们首先创建共享的账户对象、一个 `SpinLock` 和一个用于存储我们的任务的列表。
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, let's add a `for` loop to the `Main` method that creates five tasks. Each
    task will loop several times updating the balance and using `SpinLock` to manage
    concurrent access. The `SpinLock` should be acquired in a `try` block and released
    in a `finally` block.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `Main` 方法中添加一个 `for` 循环来创建五个任务。每个任务将循环多次更新余额并使用 `SpinLock` 来管理并发访问。`SpinLock`
    应该在 `try` 块中获取并在 `finally` 块中释放。
- en: '[PRE21]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finish up the `Main` method by waiting for all of our tasks to complete and
    wait for the user input before exiting.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过等待所有任务完成并在退出前等待用户输入来完成 `Main` 方法。
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output,
    similar to the following screenshot:![How to do it…](img/0225OT_06_06.jpg)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到类似以下截图的输出：![如何操作…](img/0225OT_06_06.jpg)
- en: How it works…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A SpinLock can be useful to avoid blocking in our applications, but if we expect
    a large amount of blocking, we probably shouldn't use SpinLock, as excessive spinning
    could make the situation much worse. However, if the critical section performs
    a very minimal amount of work and the wait times for the lock are minimal, then
    spin locking could be a good choice.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: SpinLock可以用来避免在我们的应用程序中发生阻塞，但如果我们预期会有大量的阻塞，那么可能不应该使用SpinLock，因为过度的自旋可能会使情况变得更糟。然而，如果临界区执行的工作量非常小，并且等待锁的时间也很短，那么自旋锁定可能是一个不错的选择。
- en: The `enter` method of `SpinLock` takes a `Boolean` parameter that indicates
    if the lock was successfully taken. Even in the case of an `Exception`, we can
    examine the `Boolean` parameter to reliably determine if the lock was successfully
    taken.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpinLock`的`enter`方法接受一个`Boolean`参数，表示锁是否成功获取。即使在`Exception`的情况下，我们也可以检查`Boolean`参数，以可靠地确定锁是否成功获取。'
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `SpinLock` should be exited in a `finally` block to ensure that the locked
    is released. You should also use the `Boolean` parameter to check if the lock
    is actually held before exiting because calling `exit` on a lock that isn't held
    will produce an error.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在`finally`块中退出`SpinLock`以确保锁被释放。在退出之前，您还应该使用`Boolean`参数检查锁是否实际上被持有，因为在一个未持有的锁上调用`exit`会产生错误。
- en: Interlocked operations
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互锁操作
- en: Locking is fairly safe in most of the cases but there are cases when locking
    may not be the safe solution. Some of these cases are incrementing or decrementing
    the value of a variable, adding to, or subtracting from a variable, and exchanging
    two variables with each other. These operations seem like atomic operations, but
    actually are not.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，锁定相对安全，但有些情况下锁定可能不是安全的解决方案。这些情况包括增加或减少变量的值、向变量中添加或从变量中减去，以及交换两个变量。这些操作看起来像是原子操作，但实际上并不是。
- en: For example, increment and decrement operations include three steps. The first
    is loading the value of from the variable to a register, the second is incrementing
    the value of variable, and the third is storing the incremented value back in
    the variable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，增量或减量操作包括三个步骤。第一步是从变量中加载值到寄存器，第二步是增加变量的值，第三步是将增加后的值存储回变量。
- en: The problem is that a thread can be pre-empted after the first two steps and
    another thread can start execution before the incremented value of the variable
    is saved back in the variable from the register. In the meantime, a second thread
    can go ahead and execute all three steps. After that, the first thread executes
    the third step and overwrites the value of the counter variable. Now the operation
    that was executed by the second thread is lost.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，线程可以在前两步之后被抢占，而另一个线程可以在变量的增量值被保存回寄存器中的变量之前开始执行。在此期间，第二个线程可以继续执行所有三个步骤。之后，第一个线程执行第三个步骤并覆盖计数器变量的值。现在，第二个线程执行的操作就丢失了。
- en: So how do can we avoid this scenario? This is where interlocking comes in. The
    `Interlock` class provides members that can be used to increment/decrement values,
    and exchange data between two variables. The `Interlock` class provides atomic
    operations in variables that are shared among multiple concurrent threads.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何避免这种情况呢？这就是互斥锁的作用所在。`Interlock`类提供了可以用来增加/减少值以及交换两个变量之间数据的成员。`Interlock`类为在多个并发线程之间共享的变量提供了原子操作。
- en: In this recipe, we are going to create an application that has a bank account
    object that will be updated by multiple tasks in parallel. Each of the tasks will
    have access to the shared account object, which has only a public field for the
    balance. The tasks will use `Interlocked.Add` to update the account balance as
    an atomic operation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个应用程序，它有一个银行账户对象，该对象将由多个并行任务更新。每个任务都将有权访问共享的账户对象，该对象只有一个公共字段用于余额。任务将使用`Interlocked.Add`将账户余额作为一个原子操作更新。
- en: How to do it…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Now, let''s take a look at the following steps on how to use interlocked in
    a Console Application:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在控制台应用程序中使用互锁的以下步骤：
- en: Start a new project using the **C# Console Application** project template and
    assign `InterlockedExample` as the **Solution name**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板开始一个新的项目，并将`InterlockedExample`作为**解决方案名称**。
- en: 'Add the following code snippet using directives to the top of your `InterlockedExample`
    namespace:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段使用指令添加到`InterlockedExample`命名空间顶部：
- en: '[PRE24]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the `Program` class, but inside the `InterlockedExample` namespace, create
    a very simple definition for an `Account` class. This class only needs to have
    a single `public integer` field for the balance.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类之后，但在`InterlockedExample`命名空间内部，为`Account`类创建一个非常简单的定义。这个类只需要一个`public
    integer`字段来表示余额。
- en: '[PRE25]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, in the `Main` method of the `Program` class, let's start by creating the
    shared account object and a list of `Task` to hold our tasks.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Program`类的`Main`方法中，让我们首先创建共享的账户对象和一个`Task`列表来保存我们的任务。
- en: '[PRE26]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, let's add a `for` loop to the `Main` method that creates five tasks. Each
    task will loop several times and use `Interlocked.Add` to increase the balance
    of the `Account` object as an atomic operation.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`Main`方法中添加一个`for`循环来创建五个任务。每个任务将循环多次，并使用`Interlocked.Add`以原子操作增加`Account`对象的余额。
- en: '[PRE27]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finish up the `Main` method by waiting for all of our tasks to complete and
    wait for the user input before exiting.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过等待所有任务完成并在退出之前等待用户输入来完成`Main`方法。
- en: '[PRE28]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see an output
    similar to the following screenshot:![How to do it…](img/0225OT_06_05.jpg)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。您应该看到类似于以下截图的输出：![如何做到这一点…](img/0225OT_06_05.jpg)
- en: How it works…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Interlocked can be used instead of a locking mechanism to provide simpler and
    fast operations on shared variables.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Interlocked`代替锁定机制，以提供对共享变量的简单且快速的运算。
- en: The usage of interlocked is very simple. You just use its `static` method to
    automatically, add to, subtract from, increment, decrement, or exchange values
    in a variable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Interlocked`的使用非常简单。您只需使用其`static`方法自动向变量中添加、减去、增加、减少或交换值。'
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These `static` methods change the math operations to be atomic. This means no
    other operations can be performed on the value during the call, and the operation
    won't be affected by context switching between threads.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`static`方法将数学运算改为原子操作。这意味着在调用期间不能对值执行其他操作，并且操作不会受到线程之间上下文切换的影响。
- en: Synchronizing multiple tasks with a Barrier
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用屏障同步多个任务
- en: When you need some tasks to perform a series of parallel phases, and each phase
    needs to start, after all other tasks complete the previous phase, you can synchronize
    and coordinate this work using a barrier. In short, a barrier prevents individual
    tasks from continuing until all tasks reach the barrier.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要一些任务执行一系列并行阶段，并且每个阶段需要在所有其他任务完成上一个阶段后开始时，您可以使用屏障来同步和协调这项工作。简而言之，屏障阻止单个任务继续，直到所有任务都达到屏障。
- en: Each task in the group is referred to as a participant, and signals that it
    has reached the barrier in each phase and is waiting for all the other participants
    to signal their arrival at the barrier before continuing. Optionally, you can
    also specify a time out to avoid the deadlock that will occur if one task fails
    to reach the barrier.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 团队中的每个任务都被称为参与者，并且表示它在每个阶段已经达到障碍，并在继续之前等待所有其他参与者发出到达障碍的信号。可选地，您还可以指定一个超时时间，以避免在某个任务未能达到障碍时发生的死锁。
- en: In this recipe, we are going to create a Console Application that has four participant
    tasks that execute a method with a `for` loop. Each iteration of the loop is a
    phase controlled by the barrier. The tasks will signal when they have reached
    the barrier and wait for all of the other tasks before continuing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个控制台应用程序，它有四个参与者任务，这些任务执行一个带有`for`循环的方法。循环的每次迭代都是由屏障控制的阶段。任务将在达到屏障时发出信号，并在继续之前等待所有其他任务。
- en: How to do it…
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s create a new Console Application and take a look at the following steps
    on how to synchronize tasks with Barrier:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的控制台应用程序，并查看以下步骤，了解如何使用屏障同步任务：
- en: Start a new project using the **C# Console Application** project template and
    assign `Barrier` as the **Solution name**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板启动一个新的项目，并将`Barrier`作为**解决方案名称**。
- en: 'Add the following code snippet using directives to the top of your `Program`
    class:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指令将以下代码片段添加到`Program`类的顶部：
- en: '[PRE30]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First, in the `Program` class, let's use a `static` method called `OperationWithBarrier`
    that accepts a parameter of a `Barrier` object.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Program`类中，让我们使用一个名为`OperationWithBarrier`的`static`方法，它接受一个`Barrier`对象作为参数。
- en: '[PRE31]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, in the body of the `OperationWithBarrier` method, let's create a `for`
    loop that loops three times. In each loop, get the `threadId` of the executing
    thread and then signal that the thread has reached the barrier.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`OperationWithBarrier`方法的主体中，让我们创建一个循环三次的`for`循环。在每次循环中，获取执行线程的`threadId`，然后发出信号表示线程已达到屏障。
- en: '[PRE32]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Back in the `Main` method of the `Program` class, let's create a `Barrier` object
    that has four participants and a post-phase action that writes to the Console
    when each barrier phase is reached.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类的`Main`方法中，让我们创建一个具有四个参与者和一个后阶段动作的`Barrier`对象，该动作在达到每个屏障阶段时写入控制台。
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now let's start four new tasks, each of which runs `OperationWithBarrier` passing
    in the `Barrier` object we just created at the parameter.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们启动四个新的任务，每个任务都运行`OperationWithBarrier`，并将我们刚刚创建的`Barrier`对象作为参数传入。
- en: '[PRE34]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, let's wait for all of our tasks to complete and wait for user input
    before exiting.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们等待所有任务完成，并在退出之前等待用户输入。
- en: '[PRE35]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_06_01.jpg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到类似于以下截图的输出：![如何实现…](img/0225OT_06_01.jpg)
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When you create a `Barrier`, specify the number of participants; in our case
    four. The `Barrier` constructor also has an overload that allows you to specify
    a post phase action of type `Action<Barrier>`. This action will fire after all
    the four tasks signal have reached the barrier.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个`Barrier`时，指定参与者的数量；在我们的例子中是四个。`Barrier`构造函数还有一个重载版本，允许你指定一个类型为`Action<Barrier>`的后阶段动作。这个动作将在所有四个任务发出信号达到屏障后触发。
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Each of the four tasks signals reach the barrier and wait for the other tasks
    by calling the `Barrier.SignalAndWait` method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 四个任务中的每一个都通过调用`Barrier.SignalAndWait`方法发出信号达到屏障，并等待其他任务。
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A deadlock will occur if one participant's task fails to reach the barrier because
    the tasks that reach the barrier will wait indefinitely for the fourth call to
    `Barrier.SignalAndWait`. To avoid these deadlocks, we used one of the overloads
    of the `SignalAndWait` method that specifies a time out. After the time out the
    remaining tasks are free to continue to the next phase.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个参与者的任务未能达到屏障，将发生死锁，因为达到屏障的任务将无限期地等待对`Barrier.SignalAndWait`的第四次调用。为了避免这些死锁，我们使用了`SignalAndWait`方法的重载版本，该版本指定了一个超时时间。超时后，剩余的任务可以自由地继续到下一个阶段。
- en: Using ReaderWriterLockSlim
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ReaderWriterLockSlim
- en: The `ReaderWriterLockSlim` class is used to protect a resource that is read
    by multiple threads and written to by one thread at a time.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReaderWriterLockSlim`类用于保护一个资源，该资源被多个线程读取，并且一次只有一个线程写入。'
- en: '`ReaderWriterLockSlim` allows a thread to enter one of the following three
    modes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReaderWriterLockSlim`允许线程进入以下三种模式之一：'
- en: '**Read mode**: Allows multiple threads to enter the lock as long as there is
    no thread currently holding a write lock or waiting to acquire a write lock. If
    there are any threads that are holding or waiting for a write lock, the threads
    waiting to enter in read mode are blocked.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读模式**：只要没有线程当前持有写锁或正在等待获取写锁，多个线程就可以进入锁。如果有任何线程持有或正在等待获取写锁，等待进入读模式的线程将被阻塞。'
- en: '**Upgradeable mode**: Intended for cases where a thread usually performs reads
    and might also occasionally perform writes.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可升级模式**：适用于线程通常执行读取操作，偶尔也可能执行写入操作的情况。'
- en: '**Write mode**: Only one thread can be in write mode at a time. A thread waiting
    to enter the lock in write mode will block if there is a thread currently holding
    a lock in write mode or waiting to enter write mode. If there are threads in read
    mode, the thread that is upgrading to write mode will block.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写模式**：一次只能有一个线程处于写模式。如果有一个线程当前持有写锁或正在等待进入写模式，等待进入写模式的线程将被阻塞。如果有线程处于读模式，升级到写模式的线程将被阻塞。'
- en: In this recipe, we are going to build a Console Application that creates a writer
    task to write numeric values to an array. The application will also start up three
    reader tasks that read the values that were written to the array and append the
    values to a string using `StringBuilder`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建一个控制台应用程序，创建一个写入任务将数值写入数组。应用程序还将启动三个读取任务，这些任务读取写入到数组中的值，并使用`StringBuilder`将这些值追加到字符串中。
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Now, let''s see how to use `ReaderWriterLockSlim` by having a look at the following
    steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过查看以下步骤来了解如何使用`ReaderWriterLockSlim`：
- en: Start a new project using the **C# Console Application** project template and
    assign `ReaderWriter` as the **Solution name**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板启动一个新的项目，并将`ReaderWriter`作为**解决方案名称**。
- en: 'Add the following code snippet using directives to the top of your `Program`
    class:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段使用指令添加到`Program`类的顶部：
- en: '[PRE38]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let's start by creating a `static` method on the `Program` class which our writer
    task will call to write values to an array. The `write` method will ask to enter
    the lock in write mode and will loop a few times writing the square of the loop
    index to the array.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在`Program`类上创建一个`static`方法开始，我们的写入任务将调用它将值写入数组。`write`方法将请求以写入模式进入锁，并将循环几次，将循环索引的平方写入数组。
- en: '[PRE39]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now let's create another `static` method on the `Program` class called `Read`
    that our reader tasks will use to read the values from the array and append the
    values to a string using `StringBuilder`. The `Write` method will request a reader
    lock and loop through the values of the array, writing the values to the output
    string.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们为`Program`类创建另一个名为`Read`的`static`方法，我们的读取任务将使用它从数组中读取值，并使用`StringBuilder`将这些值追加到字符串中。`Write`方法将请求读取锁，并遍历数组的值，将值写入输出字符串。
- en: '[PRE40]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, at the top of the `Program` class, let's create a constant for the maximum
    number of values and a couple of static fields for the array and the lock.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Program`类的顶部，让我们创建一个表示最大值的常量，以及为数组和锁创建几个静态字段。
- en: '[PRE41]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now we need to create the `Main` method of our `program` class. The `Main` method
    will have a list of tasks that we can use to wait. We will need to create a single
    writer task that calls the `write` method and will do a loop to create three reader
    tasks which will call the `reader` method. Finish up by waiting for the user input
    before exiting.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建`program`类的`Main`方法。`Main`方法将有一个任务列表，我们可以使用它来等待。我们需要创建一个单独的写入任务，该任务调用`write`方法，并循环创建三个读取任务，这些任务将调用`reader`方法。完成等待用户输入后退出。
- en: '[PRE42]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In Visual Studio 2012, press *F5* to run the project. Notice the ordered results
    in the following screenshot:![How to do it…](img/0225OT_06_07.jpg)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。注意以下截图中的有序结果：![如何操作…](img/0225OT_06_07.jpg)
- en: How it works…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`ReaderWriterLockSlim` allows multiple threads to be in read mode; allows one
    thread to be in write mode with an exclusive ownership of the lock, and allows
    one thread that has read access to be in upgradeable read mode.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReaderWriterLockSlim`允许多个线程处于读取模式；允许一个线程以独占锁的写入模式运行，并允许一个具有读取访问权限的线程处于可升级的读取模式。'
- en: 'A thread can enter the lock in three modes: read mode, write mode, and upgradeable
    read mode. In our Console Application, the `Write` method requests to enter the
    lock in write mode by calling the `EnterWriteLock` method and the `Read` method
    enters the read mode by calling the `EnterReadLock` method.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以以三种模式进入锁：读取模式、写入模式和可升级读取模式。在我们的控制台应用程序中，`Write`方法通过调用`EnterWriteLock`方法请求以写入模式进入锁，而`Read`方法通过调用`EnterReadLock`方法进入读取模式。
- en: Only one thread can be in write mode at any time. When a thread is in write
    mode, no other thread can enter the lock in any mode. So, any of our reader tasks
    will block if a writer lock is currently held. Once our writer task releases the
    write lock by calling the `ExitWriteLock` method, multiple reader tasks will be
    able to obtain a read lock and enter the critical section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候只能有一个线程处于写入模式。当一个线程处于写入模式时，没有其他线程可以以任何模式进入锁。因此，如果当前持有写入锁，我们的任何读取任务都将阻塞。一旦我们的写入任务通过调用`ExitWriteLock`方法释放写入锁，多个读取任务将能够获得读取锁并进入临界区。
- en: Using WaitHandles with Mutex
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用互斥锁的`WaitHandles`
- en: A **Mutex** is like a lock, but it can work across multiple processes. A Mutex
    is a synchronization primitive that can also be used for inter-process synchronization.
    When two or more threads need to access a shared resource at the same time, the
    system needs a synchronization mechanism to ensure that only one thread at a time
    uses the resource. Mutex is a synchronization primitive that grants exclusive
    access to the shared resource to only one thread. If a thread acquires a Mutex,
    the second thread that wants to acquire that Mutex is suspended until the first
    thread releases the Mutex.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**互斥锁（Mutex**）就像一把锁，但它可以在多个进程之间工作。互斥锁是一种同步原语，也可以用于进程间同步。当两个或多个线程需要同时访问共享资源时，系统需要一个同步机制来确保一次只有一个线程使用该资源。互斥锁是一种同步原语，它只允许一个线程独占访问共享资源。如果一个线程获取了互斥锁，那么想要获取该互斥锁的第二个线程将被挂起，直到第一个线程释放互斥锁。'
- en: In this recipe, we are going to return to our bank account example and build
    a Console Application that creates several tasks to update the balance on a shared
    bank account object. The tasks will use a Mutex to provide access to the balance
    for a single task at a time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将回到我们的银行账户示例，并构建一个控制台应用程序，该程序创建几个任务来更新共享银行账户对象的余额。这些任务将使用`Mutex`来为每次单个任务提供对余额的访问。
- en: How to do it…
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s create a new Console Application and see how to use Mutex by having
    a look at the following steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的控制台应用程序，通过查看以下步骤来了解如何使用`Mutex`：
- en: Start a new project using the **C# Console Application** project template and
    assign `MutexExample` as the **Solution name**.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板创建一个新的项目，并将`MutexExample`作为**解决方案名称**。
- en: 'Add the following code snippet using directives to the top of your `Program`
    class:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指令将以下代码片段添加到`Program`类的顶部：
- en: '[PRE43]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After the `Program` class, but inside the `MutexExample` namespace, create a
    very simple definition for an `Account` class. This class only needs to have a
    single `public integer` field for the balance.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类之后，但在`MutexExample`命名空间内部，为`Account`类创建一个非常简单的定义。这个类只需要一个`public
    integer`字段来表示余额。
- en: '[PRE44]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, in the `Main` method of the `Program` class, let's start by creating the
    shared account object, a `Mutex`, and a list of `Task` to hold our tasks.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Program`类的`Main`方法中，让我们首先创建共享的账户对象、一个`Mutex`和一个`Task`列表来保存我们的任务。
- en: '[PRE45]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next, let's add a `for` loop to the `Main` method that creates five tasks. Each
    task will loop several times updating the balance and using `Mutex` to manage
    concurrent access. The `Mutex` should be acquired in a `try` block and released
    in a `finally` block.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`Main`方法中添加一个`for`循环来创建五个任务。每个任务将循环多次更新余额，并使用`Mutex`来管理并发访问。`Mutex`应该在`try`块中获取，并在`finally`块中释放。
- en: '[PRE46]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finish up the `Main` method by waiting for all of our tasks to complete and
    wait for the user input before exiting.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过等待所有任务完成并等待用户输入来结束`Main`方法。
- en: '[PRE47]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_06_08.jpg)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该看到类似于以下截图的输出：![如何做到这一点…](img/0225OT_06_08.jpg)
- en: How it works…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Basically, a Mutex is a mechanism that acts as a flag to prevent two threads
    from performing one or more actions simultaneously.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`Mutex`是一种机制，充当标志以防止两个线程同时执行一个或多个操作。
- en: With a `Mutex` class, you call the `WaitHandle.WaitOne` method to lock. The
    `WaitOne` method takes a `Boolean` parameter that indicates if the lock was successfully
    taken. Even in the case of an `Exception`, you can examine the `Boolean` parameter
    to reliably determine if the lock was successfully taken.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Mutex`类，你调用`WaitHandle.WaitOne`方法来锁定。`WaitOne`方法接受一个`Boolean`参数，表示是否成功获取了锁。即使在`Exception`的情况下，你也可以检查`Boolean`参数来可靠地确定是否成功获取了锁。
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Closing or disposing a `Mutex` automatically releases it. Just as with the lock
    statement, a Mutex can be released only from the same thread that obtained it.
    The `Mutex` should be released in a `finally` block to ensure that the locked
    is released. You should also use the `Boolean` parameter to check if the `Mutex`
    is actually held before exiting because calling `ReleaseMutex` on a `Mutex` that
    isn't held will produce an error.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭或释放`Mutex`会自动释放它。就像锁语句一样，`Mutex`只能从获取它的同一个线程释放。应该在`finally`块中释放`Mutex`以确保锁被释放。你还应使用`Boolean`参数在退出前检查`Mutex`是否实际上被持有，因为在一个未持有的`Mutex`上调用`ReleaseMutex`会产生错误。
- en: Waiting for multiple threads with CountdownEvent
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`CountdownEvent`等待多个线程
- en: A common asynchronous pattern is the pattern known as fork/join parallelism.
    This typically manifests by starting a number of pieces of work and later joining
    with that work.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的异步模式是称为fork/join并行模式。这通常表现为启动多个工作项，稍后与这些工作项合并。
- en: A `CountdownEvent` is initialized with a count. Threads can block waiting on
    the event until the count reaches `0`, at which point the `CountdownEvent` will
    be set and the threads can proceed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountdownEvent`使用计数初始化。线程可以阻塞等待事件直到计数达到`0`，此时`CountdownEvent`将被设置，线程可以继续执行。'
- en: In this recipe, we will create a Console Application that performs some simulated
    work in a loop. We will initialize a `CountdownEvent` to a small number of tasks,
    and then start simulating the work with the specified number of tasks. Each task
    will decrement the `CountDownEvent`. When the `CountDownEvent` reaches `0` and
    is signaled, we will reset the `CountDownEvent` with a higher count and start
    over until we reach the maximum number of tasks.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个控制台应用程序，在循环中执行一些模拟工作。我们将初始化一个`CountdownEvent`为少量任务，然后使用指定数量的任务开始模拟工作。每个任务都会减少`CountDownEvent`的值。当`CountDownEvent`达到`0`并被触发时，我们将使用更高的计数重置`CountDownEvent`并重新开始，直到达到最大任务数。
- en: How to do it…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Now, let''s take a look at using `CoundownEven`t to wait for multiple threads.
    Have a look at the following steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`CoundownEven`t等待多个线程。查看以下步骤：
- en: Start a new project using the **C# Console Application** project template and
    assign `ForkAndJoin` as the **Solution name**.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板启动一个新的项目，并将`ForkAndJoin`作为**解决方案名称**。
- en: 'Add the following code snippet using directives to the top of your `Program`
    class:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段使用指令添加到你的`Program`类的顶部：
- en: '[PRE49]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: At the beginning of your `Program` class, start by creating a static variable
    for the `CountdownEvent` and a couple of constants for the number of tasks we
    want to start with and the number of tasks we want to finish with.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Program`类开始时，首先创建一个用于`CountdownEvent`的静态变量，以及一些表示我们想要开始和结束的任务数量的常量。
- en: '[PRE50]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: At the bottom of the `Program` class, after the `Main` method, create a new
    `static` method called `SimulateWork`. This method will take an `integer` parameter
    which represents the number of tasks to create. The method will then loop to create
    the number of tasks specified. The tasks will just sleep for a bit and write a
    message to the Console. When the tasks are finished executing, to call the `Signal`
    method of the `CountdownEvent` to decrement the count.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program`类的底部，在`Main`方法之后，创建一个新的`static`方法，命名为`SimulateWork`。此方法将接受一个`integer`参数，表示要创建的任务数量。然后，该方法将循环以创建指定数量的任务。任务将稍微休眠并写入一条消息到控制台。当任务执行完毕后，将调用`CountdownEvent`的`Signal`方法以减少计数。
- en: '[PRE51]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the `Main` method of your `Program` class, start with instantiating the `CountdownEvent`
    object. Pass in the `Begin_Tasks` constant to the `CountdownEvent` constructor
    so that the event will be signaled after two tasks.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Program`类的`Main`方法中，首先实例化`CountdownEvent`对象。将`Begin_Tasks`常量传递给`CountdownEvent`构造函数，以便在两个任务之后触发事件。
- en: '[PRE52]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Next, in the `Main` method, create a task that executes a `for` loop. Each iteration
    of the loop should reset the `CountdownEvent` to the number of tasks we want to
    wait for. Then the task will call the `SimulateWork` method and wait for the tasks
    to finish by calling the `Wait` method of `CountdownEvent`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Main`方法中，创建一个执行`for`循环的任务。循环的每次迭代都应该将`CountdownEvent`重置为我们想要等待的任务数量。然后，任务将调用`SimulateWork`方法并通过调用`CountdownEvent`的`Wait`方法等待任务完成。
- en: '[PRE53]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finish up the `Main` method by waiting for the previous task to complete in
    a `try` block and disposing of the `CountdownEvent` in a `finally` block. Wait
    for the user input before exiting.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`try`块中等待前一个任务完成并在`finally`块中处理`CountdownEvent`来完成`Main`方法。在退出之前等待用户输入。
- en: '[PRE54]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_06_09.jpg)
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*键运行项目。你应该会看到类似于以下截图的输出：![如何操作…](img/0225OT_06_09.jpg)
- en: How it works…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The main feature of `CoutndownEvent`, as you have already seen, is that it can
    be used to signal when several tasks have been completed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`CoutndownEvent`的主要功能是可以在多个任务完成时发出信号。
- en: The constructor for `CountDownEvent` accepts an `integer` parameter to specify
    the initial count of signals that we want to wait for before triggering the event.
    In our case, we passed in a constant value that is equal to two.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountDownEvent`的构造函数接受一个`integer`参数，用于指定在触发事件之前我们想要等待的初始信号计数。在我们的例子中，我们传递了一个等于两个的常量值。'
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The number of events we are waiting for can be reset by calling the `Reset`
    method as we have done in our `for` loop. Each iteration of the `for` loop increases
    the number of events we are waiting for, up to the maximum number which we specified
    in another constant.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们等待的事件数量可以通过调用`Reset`方法重置，就像我们在`for`循环中所做的那样。`for`循环的每次迭代都会增加我们等待的事件数量，直到达到我们在另一个常量中指定的最大数量。
- en: '[PRE56]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: After calling the `SimulateWork` method with the desired number of tasks to
    spin up, we wait for the tasks to complete by calling the `WaitMethod` on the
    `CountdownEvent`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`SimulateWork`方法并启动所需数量的任务后，我们通过在`CountdownEvent`上调用`WaitMethod`来等待任务完成。
- en: Finally, in the `SimulateWork` method, each task indicates that it has completed
    and decrements the count of the signals we are waiting for by calling the `Signal`
    method of `CountDownEvent`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`SimulateWork`方法中，每个任务都会调用`CountDownEvent`的`Signal`方法来指示它已完成，并减少我们等待的信号计数。
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Using ManualResetEventSlim to spin and wait
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ManualResetEventSlim`进行旋转和等待
- en: '`ManualResetEventSlim`, a light-weight synchronization primitive that was introduced
    in .NET Framework 4.0, allows threads to communicate with each other by signaling.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManualResetEventSlim`是一种轻量级同步原语，自.NET Framework 4.0以来被引入，允许线程通过信号相互通信。'
- en: When a task begins an activity that it must complete before other tasks proceed,
    it calls `Reset` to put `ManualResetEventSlim` in the non-signaled state. This
    thread can be thought of as controlling the reset event. Tasks that call the `Wait`
    method of `ManualResetEventSlim` will block, awaiting the signal. When the controlling
    thread completes the activity, it calls `Set` to signal that the waiting threads
    can proceed. All waiting threads are then released.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个任务开始一项必须在其他任务继续之前完成的操作时，它会调用`Reset`来将`ManualResetEventSlim`置于非信号状态。这个线程可以被视为控制重置事件。调用`ManualResetEventSlim`的`Wait`方法的任务将会阻塞，等待信号。当控制线程完成活动后，它会调用`Set`来指示等待的线程可以继续。然后所有等待的线程都会被释放。
- en: In this recipe, the main application thread will create a `ManualResetEventSlim`
    to coordinate five tasks that it spins up. The tasks will call the `Wait` method
    of the reset event and wait for the event to be signaled. After sleeping for a
    bit, the main thread will wake up and call the `Set` method of the reset event
    to release all of the other tasks to proceed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，主应用程序线程将创建一个`ManualResetEventSlim`来协调它启动的五个任务。任务将调用重置事件的`Wait`方法并等待事件被信号。经过一段时间的休眠后，主线程将唤醒并调用重置事件的`Set`方法来释放所有其他任务继续执行。
- en: How to do it…
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Now, let''s take a look at how to use `ManualResetEventSlim` by going through
    the following steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下步骤来了解一下如何使用`ManualResetEventSlim`：
- en: Start a new project using the **C# Console Application** project template and
    assign `SpinAndWait` as the **Solution name**.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板启动一个新的项目，并将`SpinAndWait`作为**解决方案名称**。
- en: 'Add the following code snippet using directives to the top of your `Program`
    class:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指令将以下代码片段添加到`Program`类的顶部：
- en: '[PRE58]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: First, let's create a `static` method on the `Program` class that will use a
    `for` loop to create and start five tasks. Each task will sleep for two seconds,
    write a message to the Console, and wait for the main thread to set the `ManualResetEventSlim`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在`Program`类上创建一个`static`方法，该方法将使用`for`循环来创建和启动五个任务。每个任务将休眠两秒钟，向控制台写入一条消息，并等待主线程设置`ManualResetEventSlim`。
- en: '[PRE59]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, in the `Main` method, create a `ManualResetEventSlim` object, and call
    the `StartTasks` method.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Main`方法中，创建一个`ManualResetEventSlim`对象，并调用`StartTasks`方法。
- en: '[PRE60]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, put the main thread to sleep for a second and then call the `Set` method
    of the reset event object to the tasks that are waiting.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让主线程休眠一秒钟，然后调用重置事件对象的`Set`方法，以通知等待的任务。
- en: '[PRE61]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Next, sleep the main thread for `500` ms and then call the `Reset` method of
    the reset event object to stop any more tasks from continuing.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，让主线程休眠`500`毫秒，然后调用重置事件对象的`Reset`方法来停止任何更多任务的继续执行。
- en: '[PRE62]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Finally, sleep the main thread for another second, the call the `Set` method
    of the reset event to release the waiting tasks. Wait for the user input before
    exiting.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让主线程再休眠一秒钟，然后调用重置事件的`Set`方法来释放等待的任务。在退出之前等待用户输入。
- en: '[PRE63]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_06_10.jpg)
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*键运行项目。你应该会看到类似于以下截图的输出：![如何操作…](img/0225OT_06_10.jpg)
- en: How it works…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: '`ManualResetEventSlim` functions like a gate. When you call the `Set` method,
    you open the up the gate, allowing any tasks that have called the `Wait` method
    to start running. Calling `Reset` closes the gate and any task that calls `Wait`
    will block, waiting for the event to be set. When the gate is next opened, they
    will all be released again at once.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManualResetEventSlim`就像一个门。当你调用`Set`方法时，你打开门，允许任何已经调用`Wait`方法的任务开始运行。调用`Reset`关闭门，任何调用`Wait`的任务都会阻塞，等待事件被设置。当门再次打开时，它们将一次性全部释放。'
- en: The code is pretty simple. We create five tasks and each of the tasks call the
    `Wait` method of the reset event object and block, waiting for the event to be
    set.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单。我们创建了五个任务，每个任务都会调用重置事件对象的`Wait`方法并阻塞，等待事件被设置。
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The main thread then goes to sleep for a second, releasing the currently blocking
    tasks to run. Then we sleep for a bit more, reset, and set the event again, releasing
    the remaining tasks.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，主线程将休眠一秒钟，释放当前阻塞的任务以运行。然后我们再稍微休眠一会儿，重置，并再次设置事件，释放剩余的任务。
- en: '`ManualResetEventSlim` is optimized for short waiting times and has the ability
    to opt into spinning for a set number of iterations. It also has a more efficiently
    managed implementation and allows a `Wait` to be cancelled via a `CancellationToken`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManualResetEventSlim`针对短等待时间进行了优化，并且具有在设置次数内旋转的能力。它还有一个更高效的管理实现，并允许通过`CancellationToken`取消`Wait`。'
- en: Using SemaphoreSlim to limit access
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`SemaphoreSlim`限制访问
- en: A semaphore works by keeping a counter. Each time a thread obtains the semaphore,
    the counter is reduced and each time the thread returns the semaphore, it is increased.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量通过保持一个计数器来工作。每次线程获取信号量时，计数器都会减少；每次线程返回信号量时，它都会增加。
- en: '`SemaphoreSlim` is a lightweight semophore that limits the number of threads
    that can access a resource or resources concurrently. A task that calls the `Wait`
    method of a `SemaphoreSlim` object will block until the semaphore counter is below
    the number of requests the semaphore can grant, which is specified in the constructor.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`SemaphoreSlim`是一个轻量级的信号量，它限制了可以并发访问资源或资源的线程数量。调用`SemaphoreSlim`对象的`Wait`方法的任务将阻塞，直到信号量计数器低于信号量可以授予的请求数量，该数量在构造函数中指定。'
- en: In this recipe, the main application thread will use a `for` loop to create
    five tasks. Each of the tasks call a method that waits in a `SemaphoreSlim` object
    before allowing access to a simulated shared resource.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，主应用程序线程将使用一个`for`循环创建五个任务。每个任务在允许访问模拟的共享资源之前，都会调用一个在`SemaphoreSlim`对象中等待的方法。
- en: How to do it…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s finish up the chapter by seeing how to use `SemaphoreSlim` to limit
    access to a shared resource. Have a look at the following steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看如何使用`SemaphoreSlim`限制对共享资源的访问来结束本章。请看以下步骤：
- en: Start a new project using the **C# Console Application** project template and
    assign `SemaphoreSlimExample` as the **Solution name**.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板创建一个新的项目，并将`Solution name`设置为`SemaphoreSlimExample`。
- en: 'Add the following code snippet using directives to the top of your program
    class:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指令将以下代码片段添加到程序类的顶部：
- en: '[PRE65]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: First, let's create a `static` method on the `Program` class that each of our
    threads will call in order to access a simulated shared resource. This method
    will call the `Wait` method of a `SemaphoreSlim` object, which will only grant
    access to three tasks at a time.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在`Program`类中创建一个`static`方法，这样我们的每个线程都可以调用它来访问模拟的共享资源。此方法将调用`SemaphoreSlim`对象的`Wait`方法，它将一次只授予三个任务的访问权限。
- en: '[PRE66]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now, previously to the `Main` method, create a static `SemaphoreSlim` object
    field on the `Program` class that will grant three access requests.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Main`方法之前，在`Program`类中创建一个静态的`SemaphoreSlim`对象字段，该字段将授予三个访问请求。
- en: '[PRE67]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `Main` method just needs to create and start five tasks in a `for` loop.
    The tasks only need to call the `Enter` method. Now, wait for the user input before
    exiting.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Main`方法只需要在`for`循环中创建和启动五个任务。任务只需要调用`Enter`方法。现在，等待用户输入后再退出。'
- en: '[PRE68]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_06_10.jpg)
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该会看到类似于以下截图的输出：![如何做…](img/0225OT_06_10.jpg)
- en: How it works…
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A semaphore is an enforcement of access limitation to a shared resource. Once
    it's full, no more tasks can enter the semaphore until one or more tasks complete
    and get terminated. A queue builds up outside for other tasks. Then, for each
    task that leaves the semaphore, another enters from the queue.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是对共享资源访问限制的强制执行。一旦达到最大容量，就没有更多任务可以进入信号量，直到一个或多个任务完成并终止。其他任务将在队列外积累。然后，对于离开信号量的每个任务，队列中的另一个任务将进入。
- en: Using `SemaphoreSlim` is an easy two-step process. First you need to create
    a `SemaphoreSlim` object that all of your threads have visibility to. Use the
    constructor to specify the number of requests the semaphore can grant concurrently.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SemaphoreSlim` 是一个简单的两步过程。首先，你需要创建一个所有线程都能看到的 `SemaphoreSlim` 对象。使用构造函数来指定信号量可以同时授予的请求数量。
- en: '[PRE69]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Before accessing a shared resource, call the `Wait` method on the semaphore
    method. Execution will continue into the shared resource for the specified number
    of tasks. All other tasks will block until one of the current tasks exits. Exiting
    tasks release the semaphore and decrement the request count by calling the `Release`
    method.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问共享资源之前，需要在信号量方法上调用 `Wait` 方法。执行将继续进入共享资源，直到指定的任务数量完成。其他所有任务将阻塞，直到当前任务之一退出。退出任务将释放信号量，并通过调用
    `Release` 方法减少请求计数。
- en: '[PRE70]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
