- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the first chapter in which you’ll start your amazing adventure with
    data structures and algorithms in the context of the **C# programming language**.
    First, we’ll provide a short introduction to this language. You will get to know
    how broad its possibilities are, in how many scenarios you can apply this language,
    as well as some basic constructions that you can use. This isn’t a C# course,
    so we won't be presenting various features one by one, and only a brief description
    will be provided.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of this chapter is dedicated to **data types**, both built-in
    and user-defined, which you can use in your applications. First, you will learn
    what the difference is between value and reference types. Then, you will go through
    various available data types, starting with value types. Here, we will cover integral
    numeric types, floating-point numeric types, Boolean types, Unicode characters,
    constants, enumerations, value tuples, struct types, and nullable value types.
    Finally, we’ll cover reference types, including object and string types, as well
    as classes, records, interfaces, and delegates, together with dynamic and nullable
    reference types.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you have quite a long journey before you. However, if you get
    to know the basics well, it will be much easier for you to get the most out of
    the content presented in the remainder of this book. I, as the author, am keeping
    my fingers crossed for you – good luck!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: C# as a programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET-based console applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The division of data types between value and reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# as a programming language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, you have probably heard about many programming languages, including
    **C#**, **Java**, **C++**, **C**, **PHP**, and **Ruby**. In all of them, you can
    use various data structures, as well as implement algorithms, to solve both basic
    and complex problems. However, each language has a specificity that’s visible
    while implementing data structures and accompanying algorithms. As mentioned previously,
    this book only focuses on the C# programming language. This is also the main topic
    of this section.
  prefs: []
  type: TYPE_NORMAL
- en: The C# language, pronounced *C sharp*, is a **modern, general-purpose, strongly
    typed, and object-oriented programming language that can be used while developing
    a wide range of applications**, such as web, mobile, desktop, distributed, and
    embedded solutions, as well as even games! It cooperates with various additional
    technologies and platforms, including **ASP.NET Core**, **XAML**, and **Unity**.
    Therefore, when you learn the C# language, as well as get to know more about data
    structures and algorithms in the context of this programming language, you can
    use such skills to create more than one particular type of software. What’s more,
    even if you decide to change your primary programming language to another, your
    knowledge regarding data structures and algorithms will still be useful. You might
    be wondering, *how is this possible?* The answer turns out to be very simple –
    you will understand how various data structures work, how you can implement them,
    as well as how you can apply them to solve various problems with specialized algorithms.
    But let’s go back to the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: The current version of the language is **C# 12**. It is worth mentioning its
    interesting history in terms of various versions of the language (including 2.0,
    3.0, 5.0, and 8.0) in which new features were added to increase language possibilities.
    When you take a look at the release notes for particular versions, you will see
    how the language is being improved and expanded over time to be a powerful and
    convenient solution for developers. New features are pretty awesome and can significantly
    simplify your work and allow you to refactor the code so that it’s shorter, as
    well as easier to understand and maintain. That’s great work that’s been done
    by the team developing C# that you can now benefit from while writing your code.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the C# programming language is similar to other languages, such
    as Java or C++. For this reason, if you know such languages, you should easily
    be able to understand the code written in C#. As an example, similarly as in the
    languages mentioned previously, the code consists of statements that end with
    semicolons (`;`). The curly brackets, namely `{` and `}`, are used to group statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few categories of statements, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` and `switch`. The `if` statement allows you to conditionally execute code,
    depending on the provided condition. The `switch` statement makes it possible
    to choose a statement list to execute using the **pattern match**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do-while`, `while`, `for`, and `foreach`. They are related to **loops** and
    are used to execute a part of code many times while the condition is met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`break`, `continue`, and `goto`. They are used to control the execution of
    loops, such as to break it or move to the next iteration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`throw`, `try-catch`, `try-finally`, and `try-catch-finally`. They are connected
    to handling exceptions that can be thrown in various parts of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other statements exist as well, such as `lock`, `yield`, `checked`, `unchecked`,
    and `fixed`. You will see some of the statements presented in the preceding list
    in the code snippets shown in the following chapters of this book, along with
    explanations.
  prefs: []
  type: TYPE_NORMAL
- en: Developing various applications in the C# language is also simplified by the
    availability of many additional great features, such as **Language Integrated
    Query** (**LINQ**), which allows developers to get data from various sources,
    including SQL databases and XML documents, consistently. There are also some approaches
    to shorten the required code, such as using Lambda expressions, pattern matching,
    properties, expression-bodied members, records, and string interpolations. It
    is worth mentioning automatic **garbage collection**, which greatly simplifies
    the task of releasing memory.
  prefs: []
  type: TYPE_NORMAL
- en: Where can you find more information?
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the newest version of the C# language at [https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12).
    The language history is shown at [https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history).
    A set of detailed information about the language reference (including value and
    reference types) is available at [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference).
    You can find there information about available data types with a set of details,
    including the supported value ranges and precisions, which are presented later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the solutions mentioned previously are only a very limited subset
    of features that are available while developing in C#. You will see some others
    in the following parts of this book, along with examples and detailed descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: .NET-based console applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep things simple, while reading this book, you will create many console-based
    applications, but the data structures and algorithms could be used in other kinds
    of solutions as well. The console-based applications will be created in **Microsoft
    Visual Studio 2022 Community**. This **integrated development environment** (**IDE**)
    is a comprehensive solution for developing various kinds of projects and is equipped
    with many great features that simplify the development and testing of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after launching the IDE, we can proceed by creating a new project. To
    create one, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **File** | **New** | **Project** in the main menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Console App** on the right in the **Create a new** **project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the name of the project (**Project name**), select a location for the files
    (**Location**), and enter the name of the solution (**Solution name**). Then,
    press **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Additional information** window, set the framework version to **.NET
    8.0 (Long Term Support)** and ensure that **Do not use top-level statements**
    is unchecked. If you are ready, click on the **Create** button to automatically
    create the project and generate the necessary files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! You’ve just created the first project. But what’s inside?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the **Solution Explorer** window, which presents the structure
    of the project. It is worth mentioning that the project is included in the solution
    with the same name. Of course, a solution could contain more than one project,
    which is a common scenario while developing more complex applications. You can
    see how it works if you browse the GitHub repository of this book. It contains
    one solution with over 40 projects.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t have Solution Explorer?
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot find the **Solution Explorer** window, you can open it by choosing
    the **View** | **Solution Explorer** option from the main menu. Similarly, you
    could open other windows, such as **Output** or **Class View**. If you cannot
    find a suitable window (for example, **C# Interactive**) directly within the **View**
    option, you can find it in the **View** | **Other** **Windows** node.
  prefs: []
  type: TYPE_NORMAL
- en: The automatically generated project contains the **Dependencies** element, which
    presents additional dependencies used by the project. It is worth noting that
    you could easily add references by choosing the **Add Project Reference**, **Add
    Shared Project Reference**, or **Add COM Reference** option from the context menu
    of the **Dependencies** element. Moreover, you can install additional packages
    using **NuGet Package Manager**, which can be launched by choosing **Manage NuGet
    Packages** from the **Dependencies** context menu.
  prefs: []
  type: TYPE_NORMAL
- en: Write from scratch or reuse existing packages?
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to take a look at packages that are already available before
    writing the complex module on your own since a suitable package could already
    be available for developers. In such a case, you could not only shorten the development
    time but also reduce the chance of introducing mistakes. However, please check
    the license conditions and ensure that the external module is reliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Program.cs` file contains the main code in C#. You could adjust the behavior
    of the application by changing the following default implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial content of this file contains just two lines. The first contains
    the comment, while the other writes the following text in the console when the
    program is launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It looks so simple and easy to modify, doesn’t it? This is true and the default
    implementation of this file has changed significantly over the last few years
    due to the functionality of `Program` class is defined, together with the `Main`
    static method, where the logic of the simple program is placed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what will the default code look like if you disable the top-level statements?
    Let’s take a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code contains the definition of the `Program` class within the
    `GettingStarted` namespace. This class contains the `Main` static method, which
    is called automatically when the application is launched.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, let’s take a look at the structure of the project in the
    file explorer, not in the **Solution Explorer** window. Are such structures the
    same?
  prefs: []
  type: TYPE_NORMAL
- en: How to open a project directory
  prefs: []
  type: TYPE_NORMAL
- en: You could open the directory with the project in the file explorer by choosing
    the **Open Folder in File Explorer** option from the context menu of the project
    node in the **Solution** **Explorer** window.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you can see the `bin` and `obj` directories, which are generated
    automatically. Both contain `Debug` and `Release` directories, whose names are
    related to the configuration set in the IDE. After building the project, a subdirectory
    of the `bin` directory (that is, `Debug` or `Release`) contains the `net8.0` directory
    with `.exe`, `.dll`, and `.pdb` files. What’s more, there is no `Dependencies`
    directory, but there is the `.csproj` file, which contains the XML-based configuration
    of the project. Similarly, the solution-based `.sln` configuration file is located
    in the solution’s directory.
  prefs: []
  type: TYPE_NORMAL
- en: Ignore some files and directories using Git
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a `bin` and `obj` directories, as well as the `.csproj.user`
    file. I strongly encourage you to use a version control system for various projects,
    as well as to **commit and push changes frequently**. If you can, you can also
    try to automate the process of testing and deployment, such as by introducing
    **continuous integration** and **continuous delivery** (**CI/CD**). The introduction
    of such procedures can have a very positive impact on the quality and stability
    of your great applications, regardless of their types.
  prefs: []
  type: TYPE_NORMAL
- en: As you already know how to create projects for the examples we’ll be covering
    in this book, let’s focus on the available data types and their basic divisions,
    as well as write some code!
  prefs: []
  type: TYPE_NORMAL
- en: Division of data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing applications in the C# language, you could use various data
    types, which are divided into two main groups, namely **value types** and **reference
    types**. The difference between them is quite simple – **a variable of a value
    type directly contains data, while a variable of a reference type just stores
    a reference to data, which is located** **somewhere else**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an illustration of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – The difference between value and reference types](img/B18069_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – The difference between value and reference types
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a variable of a **value type** (shown as **A**) stores its actual
    **value** directly in the **stack** memory, while a variable of a **reference
    type** only stores a **reference** here. The actual value is located in the **heap**
    memory. Therefore, it is possible to have two or more variables of a reference
    type that reference the same value, as indicated by the **C** and **D** boxes
    in the preceding figure.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful – it is a simplification!
  prefs: []
  type: TYPE_NORMAL
- en: Please remember that this is some kind of simplification because value types
    are not always stored on the stack. There are some scenarios when they are stored
    on the heap. If you are interested in this topic, you can read much more about
    it at [https://tooslowexception.com/heap-vs-stack-value-type-vs-reference-type/](https://tooslowexception.com/heap-vs-stack-value-type-vs-reference-type/).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a difference between value and reference types is important while
    programming and you should know which types belong to the groups mentioned previously.
    Otherwise, you could make mistakes in the code that could be quite difficult to
    find.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you should be careful while comparing two objects with the `==`)
    since **two variables of a value type are equal if their data are equal, while
    two variables of a reference type are equal if they reference the** **same location**.
  prefs: []
  type: TYPE_NORMAL
- en: You should also take care while assigning a variable of a reference type to
    another variable and while passing a variable of a reference type as an argument
    to a method and updating its data. This is because the change can be reflected
    in other variables that are referencing the same object. In contrast, while using
    a value type, the variable value is copied while it’s being passed as an argument
    to a method, returning a result from a method, or assigning it to another variable,
    so you only modify data in one location.
  prefs: []
  type: TYPE_NORMAL
- en: Does the division between value and reference types seem clear to you? If so,
    let’s proceed to the next section, where the value types will be described in
    more detail, and some code snippets will be provided.
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To give you a better understanding of data types, let’s start by analyzing
    the first group, namely **value types**. They are further divided into the following
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structs**encapsulating data and functionalities, which are divided into the
    following categories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Built-in value types**, also referred to as **simple types**. These are divided
    into:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integral** **numeric types**'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floating-point** **numeric types**'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boolean values**'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unicode** **UTF-16 characters**'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value tuples**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-defined** **struct types**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constants**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enumerations**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these groups will be described in this section, starting with the simple
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Integral numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first group of built-in value types are the `System` namespace. Such types
    differ by the number of bytes used and whether signed or unsigned integral values
    are represented by them.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an integer value
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better visualize an integer value, you can find some examples
    around you – the publication year of this book, the number of legs of your table,
    and the number of keys on your keyboard. All of these are integer values, such
    as `2024`, `4`, and `84`. Yes, I counted the number of keys on my keyboard, especially
    for you!
  prefs: []
  type: TYPE_NORMAL
- en: 'The supported integral numeric types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Byte` (the `byte` keyword), as 8-bit unsigned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sbyte` (`sbyte`), as 8-bit signed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int16` (`short`), as 16-bit signed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uint16` (`ushort`), as 16-bit unsigned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int32` (`int`), as 32-bit signed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UInt32` (`uint`), as 32-bit unsigned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int64` (`long`), as 64-bit signed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UInt64` (`ulong`), as 64-bit unsigned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.IntPtr` (`nint`), as 32- or 64-bit (platform-dependent) signed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.UintPtr` (`nuint`), as 32- or 64-bit (platform-dependent) unsigned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the types differ by the number of bytes for storing values and
    therefore by the range of available values. As an example, the `byte` data type
    supports values in the range from 0 to 255, `sbyte` from -128 to 127, `short`
    from -32,768 to 32,767, and `uint` from 0 to 4,294,967,295\. Is it a huge number?
    Yes, it is. However, let’s take a look at the range for `ulong`, which is from
    0 to 18,446,744,073,709,551,615.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify values for integral types in the following modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`45`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x` or `0X` as a prefix – for example, `0xff` for 255.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0b` or `0B` as a prefix – for example, `0b1101110` for 110\. It can be also
    written as `0b_0110_1110` to improve the readiness of the number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an exemplary code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The last remark we’ll make is about the default value for any built-in integral
    numeric type. You probably won’t be surprised if I told you that it is **zero**.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second group of built-in value types are **floating-point numeric types**,
    which allow you to store **floating-point values**.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a floating-point value
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better imagine a floating-point value, you can measure your current
    body temperature in Celsius degrees, get your height in centimeters, count the
    money that you currently have in your wallet, or take a look at your computer’s
    processor frequency provided in GHz. All of these values are floating-point ones
    – for example, `36.6`, `184.8`, `105.34`, and `1.7`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use three floating-point numeric types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Single` (`float`) using 32 bits – for example, `1.53f` (`f` or `F` suffix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Double` (`double`) using 64 bits – for example, `1.53` (no suffix or `d`/`D`
    suffix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Decimal` (`decimal`) using 128 bits – for example, `1.53M` (`m` or `M` suffix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As the number of used bits differs from 32 up to 128 bits, the range and precision
    of values differ significantly. Just take a look at the numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`float` stores numbers between ±1.5×10−45 and ±3.4×1038'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double` stores numbers between ±5.0×10−324 and ±1.7×10308'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal` stores numbers between ±1.0×10-28 and ±7.9228×1028'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might be surprised that even though `decimal` values use twice as many bits
    as the `double` type does, its range is significantly smaller. However, the `decimal`
    type is a good choice for monetary calculations.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, remember that the default value for any floating-point numeric type
    is **zero**.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regarding `Boolean` type or the `bool` keyword. This makes it possible to store
    a `true` or `false`. The default value is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a Boolean value
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to visualize a Boolean value, answer the following questions: are
    you currently reading this book? Do you have at least 5 years of experience? Have
    you finished university? You can only answer these questions with *yes* (`true`)
    or *no* (`false`). No other answers are accepted. So, you can store such replies
    as Boolean variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: char letter = 'M';
  prefs: []
  type: TYPE_NORMAL
- en: char bullet = '\u25cf';
  prefs: []
  type: TYPE_NORMAL
- en: char special = char value is \0 (U+0000).
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that you can also define **constant values**. **Each constant
    value is an** **immutable value** **that cannot be changed**. Constant values
    can only be created from simple types.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a constant
  prefs: []
  type: TYPE_NORMAL
- en: If you want to remember constant values easily, think about some immutable values,
    such as the number of days in a week (`7`), the number of millimeters in a centimeter
    (`10`), the highest acceptable temperature value for a sensor (`90`), or the maximum
    number of iterations for your algorithm (`5`). None of these values can be changed
    after creation and can be defined as constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `const` keyword to create a constant value, as shown in the
    following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Another interesting fact is that the constant expressions for which all operands
    are constant values of simple types are evaluated at compile time. This has a
    positive impact on the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the already mentioned types, the value types contain **enumerations**.
    **Each has a set of** **named constants** **to specify the available set** **of**
    **values**.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an enumeration
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better visualize an enumeration, try to specify available colors
    for your car while configuring it (for example, black, white, gray, red, and yellow),
    languages supported by your app (for example, English, Polish, and German), or
    currencies in which you accept payments (for example, PLN, USD, and EUR). In all
    of these scenarios, there is a precisely defined list of available values to select,
    so they are good representatives of enumerations.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: CurrencyEnum currency = CurrencyEnum.Pln;
  prefs: []
  type: TYPE_NORMAL
- en: switch (currency)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'case CurrencyEnum.Pln: /* Polish zloty */ break;'
  prefs: []
  type: TYPE_NORMAL
- en: 'case CurrencyEnum.Usd: /* American Dollar */ break;'
  prefs: []
  type: TYPE_NORMAL
- en: 'default: /* Euro */ break;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: CurrencyEnum currency = CurrencyEnum.Pln;
  prefs: []
  type: TYPE_NORMAL
- en: switch (currency)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'case CurrencyEnum.Pln: /* Polish zloty */ break;'
  prefs: []
  type: TYPE_NORMAL
- en: 'case CurrencyEnum.Usd: /* American Dollar */ break;'
  prefs: []
  type: TYPE_NORMAL
- en: 'default: /* Euro */ break;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: enum CurrencyEnum { Pln, Usd, Eur };
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Flags]'
  prefs: []
  type: TYPE_NORMAL
- en: enum ActionEnum
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: None    = 0b_0000_0000, // 0
  prefs: []
  type: TYPE_NORMAL
- en: List    = 0b_0000_0001, // 1
  prefs: []
  type: TYPE_NORMAL
- en: Details = 0b_0000_0010, // 2
  prefs: []
  type: TYPE_NORMAL
- en: Add     = 0b_0000_0100, // 4
  prefs: []
  type: TYPE_NORMAL
- en: Edit    = 0b_0000_1000, // 8
  prefs: []
  type: TYPE_NORMAL
- en: Delete  = 0b_0001_0000, // 16
  prefs: []
  type: TYPE_NORMAL
- en: Publish = 0b_0010_0000  // 32
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: ActionEnum guest = ActionEnum.List;
  prefs: []
  type: TYPE_NORMAL
- en: ActionEnum user = ActionEnum.List | ActionEnum.Details;
  prefs: []
  type: TYPE_NORMAL
- en: ActionEnum editor = ActionEnum.List | ActionEnum.Add
  prefs: []
  type: TYPE_NORMAL
- en: List and Details permissions to a user, the combined permission is equal to
    00000011. The admin with full access to the system has combined permission equal
    to 00111111. Simple and efficient, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth mentioning that enumerations allow you to replace some *magical strings*
    (such as `Pln` or `Usd`) with constant values. This has a very positive impact
    on code quality. What’s more, it significantly simplifies refactoring, maintenance,
    and introducing changes in the code in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Value tuples
  prefs: []
  type: TYPE_NORMAL
- en: The value tuple type is represented by the `System.ValueTuple` type and is **a
    lightweight data structure that allows you to group multiple data elements of
    specific types**. It has a very simple syntax, in which you just need to specify
    the types of all data members and, optionally, provide their names. All of the
    elements are public fields, so a tuple type is a **mutable value type**. What’s
    more, **it is a very data-centric type, so you cannot even define methods** **within
    it**.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a value tuple
  prefs: []
  type: TYPE_NORMAL
- en: If you want to understand a value tuple more easily, stop for a moment to think
    about the programming problem when you need to return a result from a method that
    consists of two or three values, such as a price in the chosen currency and the
    used conversion rate from the base currency, or a set of statistics consisting
    of minimum, maximum, and average values. As a solution, you can define a dedicated
    class, record, or struct and use it as a return type. However, this data structure
    will only be used once, and it will unnecessarily complicate the project and future
    changes. Another solution is to use `out` parameters for the method. However,
    such parameters cannot be used in all circumstances. To solve this problem, you
    can use a value tuple type and simply specify the types of data members that are
    returned from the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the value tuple type seems to be straightforward, it can be used
    in various scenarios. Let’s take a look at the following code snippet, where we
    use a value tuple and specify the type of data members returned from the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Min = 4 / Max = 13 / Avg = 8.33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: (int min, int max, double avg) = Calculate(4, 8, 13);
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine($"Min = {min} / Max = {max}
  prefs: []
  type: TYPE_NORMAL
- en: / Avg = {avg:F2}");
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: (int, int, double) Calculate(params int[] numbers)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (numbers.Length == 0) { return (0, 0, 0); }
  prefs: []
  type: TYPE_NORMAL
- en: int min = int.MaxValue;
  prefs: []
  type: TYPE_NORMAL
- en: int max = int.MinValue;
  prefs: []
  type: TYPE_NORMAL
- en: int sum = 0;
  prefs: []
  type: TYPE_NORMAL
- en: foreach (int number in numbers)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (number > max) { max = number; }
  prefs: []
  type: TYPE_NORMAL
- en: if (number < min) { min = number; }
  prefs: []
  type: TYPE_NORMAL
- en: sum += number;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return (min, max, (double)sum / numbers.Length);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: using Statistics = (int Min, int Max, double Avg);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Statistics Calculate(params int[] numbers)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /* (...) */
  prefs: []
  type: TYPE_NORMAL
- en: return (min, max, (double)sum / numbers.Length);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Statistics result = Calculate(4, 8, 13);
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine($"Min = {result.Min} / Max = {result.Max}
  prefs: []
  type: TYPE_NORMAL
- en: / Avg = {result.Avg:F2}");
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: public readonly struct Price
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public Price(decimal amount, CurrencyEnum currency)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Amount = amount;
  prefs: []
  type: TYPE_NORMAL
- en: Currency = currency;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public readonly decimal Amount { get; init; }
  prefs: []
  type: TYPE_NORMAL
- en: public readonly CurrencyEnum Currency { get; init; }
  prefs: []
  type: TYPE_NORMAL
- en: public override string ToString()
  prefs: []
  type: TYPE_NORMAL
- en: => $"{Amount} {Currency}";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: public readonly struct Price(
  prefs: []
  type: TYPE_NORMAL
- en: decimal amount, CurrencyEnum currency)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public readonly decimal Amount { get; init; } = amount;
  prefs: []
  type: TYPE_NORMAL
- en: public readonly CurrencyEnum Currency { get; init; }
  prefs: []
  type: TYPE_NORMAL
- en: = currency;
  prefs: []
  type: TYPE_NORMAL
- en: public override string ToString()
  prefs: []
  type: TYPE_NORMAL
- en: => $"{Amount} {Currency}";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: public enum CurrencyEnum { Pln, Usd, Eur };
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Price priceRegular = new(100, CurrencyEnum.Pln);
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(priceRegular);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 100 Pln
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Price priceDiscount = priceRegular priceRegular instance and set the value of
    the Amount property to 50. However, values of the remaining properties are the
    same as in the priceRegular instance, so Currency is set to Pln.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude the topic of user-defined structs, it’s worth remembering that the
    default value for each of them is created by setting all reference-type fields
    to `null` and all value-type fields to their default values.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable value types
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve come to the end of this section regarding value types, think
    about a scenario where you need to store either a particular value, such as a
    numeric one (for example, 154), or information that a value is not provided. One
    of the possible solutions is to use two variables. The first specifies whether
    the value is provided (the `bool` type), while the other stores a numeric value
    (for example, of the `int` type). However, is it possible to only use one variable
    instead of two? The answer is yes! To achieve this, you can use a `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a nullable value type
  prefs: []
  type: TYPE_NORMAL
- en: If you want to understand nullable value types more easily, think about the
    scenario of calculating the age of a user of your portal. If the user provides
    you with their date of birth, the task is pretty simple. However, what about a
    situation when such a date is missing? You cannot calculate their age, so the
    age variable can be set to `null` instead of an integer value. Here, you can use
    the `int?` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for its implementation, you can use the `?` operator just after a type name
    or use the `System.Nullable<T>` structure, which has the same effect, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: if (age != null) { Console.WriteLine(age.Value); }
  prefs: []
  type: TYPE_NORMAL
- en: 'if (note.??)GetValueOrDefault method. Examples for both are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: DateTime date = new(1988, 11, 9);
  prefs: []
  type: TYPE_NORMAL
- en: int? age = GetAgeFromBirthDate(date);
  prefs: []
  type: TYPE_NORMAL
- en: 'age ??= 18; // The same as: age = age ?? 18;'
  prefs: []
  type: TYPE_NORMAL
- en: int? GetAgeFromBirthDate(DateTime date)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: double days = (DateTime.Now - date).TotalDays;
  prefs: []
  type: TYPE_NORMAL
- en: 'return days > 0 ? (int)(days / 365) : null;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: string? GetFormatted(float? number)
  prefs: []
  type: TYPE_NORMAL
- en: => numberGetFormatted method returns null if null is provided as the number
    parameter. Otherwise, it returns the number formatted using the specified format.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget that a default value for a nullable value type represents `null`.
    This means that the `HasValue` property returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  prefs: []
  type: TYPE_NORMAL
- en: The second main group of types is `object`, `string`, `delegate`, and `dynamic`.
    Moreover, you can declare **classes**, **records**, and **interfaces**. **Nullable
    reference types** exist as well. All of these types will be described in this
    section. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs: []
  type: TYPE_NORMAL
- en: The `Object` class (the `object` alias) is declared in the `System` namespace
    and performs an important role while developing applications in C#. Why? Because
    all other types in the `Object`. This means that built-in value types, built-in
    reference types, as well as user-defined value types and user-defined reference
    types, are derived from the `Object` class.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an object
  prefs: []
  type: TYPE_NORMAL
- en: If you want to understand the object type more easily, think about it as “*something*.”
    As everything is “*something*,” everything is an object. Representatives of various
    value types and reference types are objects. Oh no – objects are everywhere around
    you! ;-)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a set of methods that are available for all objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ToString` returns a string representation of the object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetType` returns a type of the instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Equals` checks whether the object is equal to a given object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetHashCode` uses the hash function and returns its result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the `Object` type is the base entity for all value types, this means that
    it is possible to convert a variable of any value type (for example, `int` or
    `float`) into the `object` type, as well as to convert a variable of the `object`
    type into a specific value type. Such operations are named **boxing** (the first)
    and **unboxing** (the other), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: string firstName = "Marcin", lastName = "Jamro";
  prefs: []
  type: TYPE_NORMAL
- en: int year = 1988;
  prefs: []
  type: TYPE_NORMAL
- en: string note = firstName + " " + lastName.ToUpper()
  prefs: []
  type: TYPE_NORMAL
- en: + " was born in " + year;
  prefs: []
  type: TYPE_NORMAL
- en: string initials = firstName[0] + "." + lastName[0] + ".";
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: string note = string.Format("{0} {1} was born in {2}",
  prefs: []
  type: TYPE_NORMAL
- en: firstName, lastName.ToUpper(), year);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: string note = $"{firstName} {lastName.ToUpper()}
  prefs: []
  type: TYPE_NORMAL
- en: was born in ,10 value for the minimum 10 characters and right alignment, as
    well as a negative ,-10 value for the minimum 10 characters and left alignment)
    or the :F2 for a floating-point number with two digits after a comma or :HH:mm
    for presenting an hour with minutes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s some example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This example presents a simple table with body temperatures for three people,
    namely `Marcin`, `Adam`, and `Martyna`, together with their birth dates. The alignments
    (for example, `-8`) and format strings (for example, `dd.MM.yyyy`) are used. What’s
    more, the `> 40.0f`), high (`> 37.0f`), normal (`> 36.0f`), low (`> 35.0f`), or
    very low. The latter is the final case and is also called the `_` and matches
    all other values.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute this code, you’ll see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the C# language is equipped with various possibilities, even
    related to just the `string` type. What’s more, you can combine different features,
    such as the interpolation string with the `switch` statement and pattern matching
    to create code that is easy to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: However, you should keep in mind that `string` is not a typical reference type
    and its behavior is a bit different than in the case of other reference types.
    You can see such a difference while comparing two `string` variables using the
    `==` operator. Here, two `string` instances are the same if they contain the same
    sequence of characters, so it is a similar behavior as in the case of value types.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, C# is an object-oriented language and supports declaring
    classes together with various members, including `public`, `protected`, `internal`,
    `private`, and `file`. These access modifiers are mentioned together with classes,
    but you should remember that they can be used for some other types as well.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a class
  prefs: []
  type: TYPE_NORMAL
- en: If you want to visualize a class, think about a vehicle. Each vehicle has some
    properties, namely brand, model, color, length, width, height, and weight. A vehicle
    can perform some actions, such as taking a given distance. You can also define
    more specific variants of vehicles, such as a car, a plane, and a boat. Each has
    the same properties as the base vehicle, as well as has some additional ones,
    such as a number plate and a fuel type (for example, petrol, diesel, or electric)
    for a car. It also has the action of a door opening. You can also create instances
    of such classes – for example, you can create three instances of a car that differ
    by model and number plate, as well as create an instance of a plane. Then, you
    can perform actions on such instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example class is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `Person` class contains the `_location` private field with the default value
    set to an empty string (`string.Empty`) and two public `Name` and `Age`). You
    will use the properties quite often while writing the code examples shown in this
    book, so let’s stop for a moment to explain them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each property is a member of a class that provides a mechanism for reading
    and writing using **accessors**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get` to return the property value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set` to assign a new value for the property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init` to set a value during object construction and prevent modifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By combining such accessors, a property can be put in one of the following
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get` accessor and without the `set` accessor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set` accessor and without the `get` accessor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get` and `set` accessors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another interesting feature is a required variant of the property, which is
    specified by the `required` keyword placed just after the access modifier, as
    shown in the case of the `Age` property. It requires that the client code initializes
    the property, and it is a good idea to mark properties as `required` if they should
    be initialized at the beginning of using the class instance. It is also worth
    noting that a property has an accessibility level as one of the access modifiers,
    including `public` and `private`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the example class:'
  prefs: []
  type: TYPE_NORMAL
- en: It contains a default constructor that sets a value of the `Name` property to
    `---` using the **expression** **body definition**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It contains a constructor that takes one parameter and sets the value of the
    `Name` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It contains the `Relocate` method, which updates the value of the private field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It contains the `GetDistance` method, which calls the `GetDistance` static method
    from the `DistanceHelpers` class and returns the distance between two cities provided
    in kilometers. The implementation of the helper class is not shown in the preceding
    code. Note that if you are curious about how you can create a real implementation
    of the mechanism for calculating the distance between cities, you can take a look
    at [*Chapter 8*](B18069_08.xhtml#_idTextAnchor296), *Exploring Graphs*, where
    such an application of graphs will be mentioned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can create an instance of the class using the `new` operator. Then, you
    can perform various operations on the object that’s been created, such as calling
    a method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As the C# language is still being developed and improved, new amazing features
    were introduced in the following versions and are related to classes as well.
    For example, with the newest version, you can use some concepts that make it possible
    to significantly limit the amount of code. The following code shows some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code performs almost the same role as the previous variant, but
    it is even shorter. If you also like such improvements, keep reading – you will
    see various possibilities of the C# language in the remaining chapters of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s proceed to the next section, which is dedicated to records.
  prefs: []
  type: TYPE_NORMAL
- en: Records
  prefs: []
  type: TYPE_NORMAL
- en: 'In the recent versions of the C# language, another great reference type was
    introduced: `record` or `record` `class` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: Value type records exist as well
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that `record struct` construction exists as well. This construction
    represents a value type with similar functionality. However, in this book, I’ll
    focus on the reference type version only. Of course, you can try another version
    on your own.
  prefs: []
  type: TYPE_NORMAL
- en: One great thing about records is that a smaller amount of code needs to be written
    because the compiler automatically generates the public `init`-only properties
    (called `Deconstruct` method with a set of `out` parameters, each one representing
    a positional parameter. **This means that this data type is data-centric and is
    intended to be immutable, providing a short and** **clear syntax.**
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a record
  prefs: []
  type: TYPE_NORMAL
- en: If you want to visualize a record, stand up and take a look at yourself in your
    mirror, focusing on your beautiful T-shirt. It has some properties, such as size
    (for example, S, M, or L), color (for example, white or red), and brand. All of
    these properties are immutable, so you cannot change them as you cannot resize
    your favorite T-shirt since it is produced. So, as your nice T-shirt is data-centric
    and its properties are immutable, it is a good representative of a record. Smile
    to yourself in your mirror and come back to reading the first chapter of this
    book!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following example of a record declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s all! Now, you have a record with five immutable properties (`Name`,
    `Breed`, `Height`, `Weight`, and `Age`), as well as a constructor with five parameters
    related to the positional parameters on the record declaration. You can use it
    to create a new instance, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Console.WriteLine(rex);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Dog { Name = Rex, Breed = Schnauzer, Height = 40,
  prefs: []
  type: TYPE_NORMAL
- en: Weight = 11, Age = 5 }
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: rex.Name = "Puppy";
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: public record Dog
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public required string Name { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public required string Breed { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public required int Height { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public required float Weight { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public required int Age { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Dog beauty = rex Beauty is created, based on Rex. All of the values of the properties
    are taken from Rex, apart from Name and Height, as specified after the with keyword.
    You also need to remember that you can adjust both positional properties and properties
    created using the standard syntax that have the init or set accessor. In such
    a case, a shallow copy is created, so for value types, a copy is used, while for
    reference types, only a reference is copied, so both a source and a target property
    will reference the same instance of a reference type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: public interface IDevice
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string Model { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: string Number { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: int Year { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: void Configure(DeviceConfiguration configuration);
  prefs: []
  type: TYPE_NORMAL
- en: bool Start();
  prefs: []
  type: TYPE_NORMAL
- en: bool Stop();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: public class Display
  prefs: []
  type: TYPE_NORMAL
- en: ': IDevice'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public string Model { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public string Number { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public int Year { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public int Diagonal { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: public void Configure(
  prefs: []
  type: TYPE_NORMAL
- en: DeviceConfiguration configuration) { (...) }
  prefs: []
  type: TYPE_NORMAL
- en: public bool Start() { (...) }
  prefs: []
  type: TYPE_NORMAL
- en: public bool Stop() { (...) }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Mean arithmetic = (a, b, c) => (a + b + c) / 3;
  prefs: []
  type: TYPE_NORMAL
- en: Mean geometric = delegate (double a, double b, double c)
  prefs: []
  type: TYPE_NORMAL
- en: '{ return Math.Pow(a * b * c, 1 / 3.0); };'
  prefs: []
  type: TYPE_NORMAL
- en: Mean harmonic = Harmonic;
  prefs: []
  type: TYPE_NORMAL
- en: double a = arithmetic.Invoke(5, 6.5, 7);
  prefs: []
  type: TYPE_NORMAL
- en: double g = geometric.Invoke(5, 6.5, 7);
  prefs: []
  type: TYPE_NORMAL
- en: double h = harmonic.Invoke(5, 6.5, 7);
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine($"{a:F2} / {g:F2} / {h:F2}");
  prefs: []
  type: TYPE_NORMAL
- en: double Harmonic(double a, double b, double c) =>
  prefs: []
  type: TYPE_NORMAL
- en: 3 / ((1 / a) + (1 / b) + (1 / c));
  prefs: []
  type: TYPE_NORMAL
- en: 'Mean delegate specifies the required signature of a method for calculating
    a mean value of three floating-point numbers. It is instantiated with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `arithmetic`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `geometric`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `harmonic`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each delegate is invoked by calling the `Invoke` method. The results are presented
    in the console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, the Lambda expression is shown, so it is a good idea to tell you a bit
    more about such a construction. It uses the `=>` operator, which separates the
    input parameters and the `(a, b, c)`. They are the same as the parameters of the
    delegate. On the right-hand side, there is the Lambda body, which calculates the
    result as a sum of inputs divided by 3\. While developing applications in C#,
    you will use Lambda expressions quite often and it is a nice feature that can
    have a positive impact on your code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamics
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the types we’ve already described, `dynamic` is available for developers.
    **It allows you to bypass type checking during compilation so that you can perform
    it during runtime.** Such a mechanism can be useful while you’re accessing some
    types of **application programming** **interfaces** (**APIs**).
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a dynamic type
  prefs: []
  type: TYPE_NORMAL
- en: If you want to better visualize a dynamic type, ask someone nearby to put a
    blindfold on you and then give you a set of instructions on how to move from one
    room to another and sit in a chair – for example, walk 5 steps forward, turn right,
    walk 10 steps forward, and then sit down. If the instructions are correct, you
    will go to the other room and sit comfortably in the chair. However, if anything
    is wrong, you won’t know this by listening to all the instructions at the beginning,
    only when you hit a wall or sit on the floor instead of in the chair. This situation
    is somewhat similar to using dynamic types. If the instructions are correct, the
    application will work correctly, but if something is wrong, it may hurt. ;-)
  prefs: []
  type: TYPE_NORMAL
- en: 'You will not use the `dynamic` type while reading this book. However, to provide
    a short introduction to this feature, take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Random random = new();
  prefs: []
  type: TYPE_NORMAL
- en: List<Measurement?> measurements = [];
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < 100; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Measurement? measurement = random.Next(3) != 0
  prefs: []
  type: TYPE_NORMAL
- en: '? new(DateTime.Now, random.Next(1000) / 1000.0f)'
  prefs: []
  type: TYPE_NORMAL
- en: ': null;'
  prefs: []
  type: TYPE_NORMAL
- en: measurements.Add(measurement);
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(IsValid(measurement)
  prefs: []
  type: TYPE_NORMAL
- en: '? measurement!.ToString()'
  prefs: []
  type: TYPE_NORMAL
- en: ': "-");'
  prefs: []
  type: TYPE_NORMAL
- en: await Task.Delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: static bool IsValid(Measurement? measurement)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return measurement != null
  prefs: []
  type: TYPE_NORMAL
- en: '&& measurement.Value >= 0.0f'
  prefs: []
  type: TYPE_NORMAL
- en: '&& measurement.Value <= 1.0f;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public record null, if the measurement is not received correctly from some external
    device. Within the for loop, we simulate getting a measurement by using the Random
    class. Statistically, about 2/3 of total measurements are retrieved correctly
    (the Measurement instance is then created) and the remaining 1/3 of total measurements
    are not retrieved (null is used instead). Such values are added to the measurements
    list. Then, we need to check whether the obtained reading is correct – that is,
    apart from being provided, its value is within the range of <0.0, 1.0>. We perform
    this check using the IsValid static method while taking the nullable Measurement
    instance as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we just need to show information about a reading in the console. For
    the correct reading, we present a formatted value of the `Measurement` instance.
    Otherwise, we use a dash (`-`). However, if we write `measurement.ToString()`,
    we will receive a warning stating “*Dereference of a possibly null reference*”
    because the compiler does not know that we’re checking whether the measurement
    is not `null` within the `IsValid` method. We can avoid this warning using the
    null-forgiving operator by adding the `!` sign just after the variable name, before
    calling the `ToString` method. A small explanation may also be required for the
    line containing the `Delay` method call. It is only used to simulate the real
    behavior of the device, from which we read a measurement each 100 ms.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, both nullable value types and nullable reference types provide
    you with very similar semantics (such as `bool?` for a nullable value type and
    `string?` for a nullable reference type), but they are implemented in other ways.
    A nullable value type uses `System.Nullable<T>` internally (for example, `System.Nullable<System.Boolean>`
    for `bool?`), while a non-nullable value type uses another type (just `System.Boolean`
    for `bool`). The nullable reference type uses the same type for both nullable
    and non-nullable variants. This means that `string?` and `string` are provided
    by the `System.String` class in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: This was only the first chapter of this book, but it contained quite a lot of
    information that will be useful while you’re reading the remaining ones. First,
    the **C# programming language** was briefly presented with a focus on showing
    various data types, both value and reference ones. You learned the difference
    between them and why understanding this difference is so important while developing
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you saw various **value types**, including the built-in ones, such as
    integral numeric types, floating-point numeric types, Boolean type, and Unicode
    characters. Then, you learned about constants, enumerations, value tuples, user-defined
    struct types, and nullable value types. All of these were equipped with detailed
    descriptions, as well as some code examples to make understanding easier and faster.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned about the second group of types, namely **reference types**.
    Here, you saw the object and string types, classes, records, interfaces, as well
    as delegate and dynamic types. Then, you learned about nullable reference types.
    Again, a lot of information was supported by explanations and some code fragments.
  prefs: []
  type: TYPE_NORMAL
- en: With this introduction, you should be ready to proceed to the next chapter and
    learn **what algorithms are and why they are so important**. Let’s go!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
