- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Querying and Manipulating Data Using LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about **Language INtegrated Query** (**LINQ**) expressions.
    LINQ is a set of language extensions that enable you to work with sequences of
    data and then filter, sort, and project them into different outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing LINQ expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LINQ in practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LINQ with EF Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining, grouping, and lookups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing LINQ expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first question we need to answer is a fundamental one: *Why does LINQ exist?*'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing imperative and declarative language features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'LINQ was introduced in 2008 with C# 3 and .NET Framework 3\. Before that, if
    a C# and .NET programmer wanted to process a sequence of items, they had to use
    procedural, aka imperative, code statements. For example, a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the current position to the first item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the item is one that should be processed by comparing one or more properties
    against specified values. For example, is the unit price greater than 50, or is
    the country equal to Belgium?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there’s a match, process that item. For example, output one or more of its
    properties to the user, update one or more properties to new values, delete the
    item, or perform an aggregate calculation, like counting or summing values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move on to the next item. Repeat until all items have been processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Procedural code tells the compiler *how* to achieve a goal. Do this, then do
    that. Since the compiler does not know what you are trying to achieve, it cannot
    help you as much. You are 100% responsible for ensuring that every *how-to* step
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ makes these common tasks much easier, with less opportunity to introduce
    subtle bugs. Instead of needing to explicitly state each individual action, like
    move, read, update, and so on, LINQ enables the programmer to use a declarative
    aka functional style of writing statements.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative, aka functional, code tells the compiler *what* goal to achieve.
    The compiler works out the best way to achieve it. The statements also tend to
    be more concise.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: If you do not fully understand how LINQ works, then the
    statements you write can introduce their own subtle bugs! A code teaser doing
    the rounds in 2022 involved a sequence of tasks and understanding when they are
    executed ([https://twitter.com/amantinband/status/1559187912218099714](https://twitter.com/amantinband/status/1559187912218099714)).
    Most experienced developers got it wrong! To be fair, it is the combination of
    LINQ behavior with multi-threading behavior that confused most. But by the end
    of this chapter, you will be better informed to understand why the code was dangerous
    due to LINQ behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Although we wrote a few LINQ expressions in *Chapter 10*, *Working with Data
    Using Entity Framework Core*, they weren’t the focus, so I didn’t properly explain
    how LINQ works. Let’s now take the time to properly understand them.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'LINQ has several parts; some are required, and some are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extension methods** (**required**): These include examples such as `Where`,
    `OrderBy`, and `Select`. These are what provide the functionality of LINQ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LINQ providers** (**required**): These include **LINQ to Objects** for processing
    in-memory objects, **LINQ to Entities** for processing data stored in external
    databases and modeled with EF Core, and **LINQ to XML** for processing data stored
    as XML. These providers are the part of LINQ that executes LINQ expressions in
    a way specific to different types of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lambda expressions** (**optional**): These can be used instead of named methods
    to simplify LINQ queries, for example, for the conditional logic of the `Where`
    method for filtering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LINQ query comprehension syntax** (**optional**): These include C# keywords
    like `from`, `in`, `where`, `orderby`, `descending`, and `select`. These are aliases
    for some of the LINQ extension methods, and their use can simplify the queries
    you write, especially if you already have experience with other query languages,
    such as **Structured Query Language** (**SQL**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When programmers are first introduced to LINQ, they often believe that LINQ
    query comprehension syntax is LINQ, but ironically, that is one of the parts of
    LINQ that is optional!
  prefs: []
  type: TYPE_NORMAL
- en: Building LINQ expressions with the Enumerable class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The LINQ extension methods, such as `Where` and `Select`, are appended by the
    `Enumerable` static class to any type, known as a **sequence**, that implements
    `IEnumerable<T>`. A sequence contains zero, one, or more items.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an array of any type implements the `IEnumerable<T>` class, where
    `T` is the type of item in the array. This means that all arrays support LINQ
    to query and manipulate them.
  prefs: []
  type: TYPE_NORMAL
- en: All generic collections, such as `List<T>`, `Dictionary<TKey, TValue>`, `Stack<T>`,
    and `Queue<T>`, implement `IEnumerable<T>`, so they can be queried and manipulated
    with LINQ too.
  prefs: []
  type: TYPE_NORMAL
- en: '`Enumerable` defines more than 50 extension methods, as summarized in *Table
    11.1* and *Table 11.2*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These tables will be useful for you for future reference, but for now, you
    might want to briefly scan them to get a feel for what extension methods exist
    and come back later to review them properly. An online version of these tables
    is available at the following link: [https://github.com/markjprice/cs13net9/blob/main/docs/ch11-linq-methods.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-linq-methods.md).'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here are the deferred methods that return a new sequence of `IEnumerable<T>`
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method(s)** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Where` | Returns a sequence of items that match a specified filter. |'
  prefs: []
  type: TYPE_TB
- en: '| `Index` | Returns a sequence of both the items and their indices. Introduced
    with .NET 9. |'
  prefs: []
  type: TYPE_TB
- en: '| `Select` and `SelectMany` | Project items into a different shape, that is,
    a different type, and flattens a nested hierarchy of items. |'
  prefs: []
  type: TYPE_TB
- en: '| `Skip` | Skips a number of items. |'
  prefs: []
  type: TYPE_TB
- en: '| `SkipWhile` | Skips while an expression is `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| `SkipLast` | Returns a new enumerable collection that contains elements from
    the source, with the last count elements of the source collection omitted. |'
  prefs: []
  type: TYPE_TB
- en: '| `Take` | Takes a number of items. .NET 6 introduced an overload that can
    be passed a `Range`, for example, `Take(range: 3..^5)`, meaning take a subset
    starting three items in from the start and ending five items in from the end,
    or instead of `Skip(4)`, you could use `Take(4..)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `TakeWhile` | Takes items while an expression is `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| `TakeLast` | Returns a new enumerable collection that contains the last count
    elements from the source. |'
  prefs: []
  type: TYPE_TB
- en: '| `OrderBy`, `OrderByDescending`, `ThenBy`, and `ThenByDescending` | Sort items
    by a specified field or property. |'
  prefs: []
  type: TYPE_TB
- en: '| `Order` and `OrderDescending` | Sort items by the item itself. |'
  prefs: []
  type: TYPE_TB
- en: '| `Reverse` | Reverses the order of the items. |'
  prefs: []
  type: TYPE_TB
- en: '| `GroupBy`, `GroupJoin`, and `Join` | Group and/or join two sequences. |'
  prefs: []
  type: TYPE_TB
- en: '| `AggregateBy`, `CountBy`, `DistinctBy`, `ExceptBy`, `IntersectBy`, `UnionBy`,
    `MinBy`, and `MaxBy` | Allow the comparison to be performed on a subset of items
    rather than all of them. For example, instead of removing duplicates with `Distinct`
    by comparing an entire `Person` object, you could remove duplicates with `DistinctBy`
    by comparing just their `LastName` and `DateOfBirth` properties. The `CountBy`
    and `AggregateBy` extension methods were introduced with .NET 9. |'
  prefs: []
  type: TYPE_TB
- en: '| `AsEnumerable` | Returns the input sequence typed as `IEnumerable<T>`. This
    is useful when the type has its own implementation of any of the LINQ extension
    methods, like `Where`, and you want to call the standard LINQ `Where` method instead.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DefaultIfEmpty` | Returns the elements of an `IEnumerable<T>`, or a default
    valued singleton collection if the sequence is empty. For example, if the sequence
    is an empty `IEnumerable<int>`, it will return an `IEnumerable<int>` containing
    a single item, `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Cast<T>` | Casts items into a specified type. It is useful to convert non-generic
    objects into a generic type in scenarios where the compiler would otherwise complain.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `OfType<T>` | Removes items that do not match a specified type. |'
  prefs: []
  type: TYPE_TB
- en: '| `Distinct` | Removes duplicate items. |'
  prefs: []
  type: TYPE_TB
- en: '| `Except`, `Intersect`, and `Union` | Perform operations that return sets.
    Sets cannot have duplicate items. Although the inputs can be any sequence and,
    thereby, the inputs can have duplicates, the result is always a set. |'
  prefs: []
  type: TYPE_TB
- en: '| `Chunk` | Divides a sequence into sized batches. The `size` parameter specifies
    the number of items in each chunk. The last chunk will contain the remaining items
    and could be smaller than `size`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Append`, `Concat`, and `Prepend` | Perform sequence-combining operations.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Zip` | Performs a match operation on two or three sequences based on the
    position of items; for example, the item at position 1 in the first sequence matches
    the item at position 1 in the second sequence. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.1: Deferred LINQ extension methods'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, here are the non-deferred methods that return a single scalar value,
    like a single `TSource` item, a number, or a `bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `First`, `FirstOrDefault`, `Last`, and `LastOrDefault` | Get the first or
    last item in the sequence, throw an exception, or return the default value for
    the type, for example, `0` for an `int` and `null` for a reference type, if there
    is not a first or last item. |'
  prefs: []
  type: TYPE_TB
- en: '| `Single` and `SingleOrDefault` | Return an item that matches a specific filter,
    throw an exception, or return the default value for the type if there is not one
    exact match. |'
  prefs: []
  type: TYPE_TB
- en: '| `ElementAt` and `ElementAtOrDefault` | Return an item at a specified index
    position, throw an exception, or return the default value for the type if there
    is not an item at that position. .NET 6 introduced overloads that can be passed
    as an `Index` instead of an `int`, which is more efficient when working with `Span<T>`
    sequences. |'
  prefs: []
  type: TYPE_TB
- en: '| `Aggregate`, `Average`, `Count`, `LongCount`, `Max`, `Min`, and `Sum` | Calculate
    aggregate values. |'
  prefs: []
  type: TYPE_TB
- en: '| `TryGetNonEnumeratedCount` | `Count()` checks if a `Count` property is implemented
    on the sequence and returns its value, or it enumerates the entire sequence to
    count its items. Introduced in .NET 6, this method only checks for `Count`; if
    it is missing, it returns `false` and sets the `out` parameter to `0` to avoid
    a potentially poor-performing operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `SequenceEqual` | Returns `true` or `false`, depending on whether two sequences
    are equal according to an equality comparer. |'
  prefs: []
  type: TYPE_TB
- en: '| `All`, `Any`, and `Contains` | Return `true` if all or any of the items match
    the filter, or if the sequence contains a specified item. If the sequence is a
    `List<T>`, they use its native `TrueForAll` method instead of LINQ’s `All` method.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ToArray`, `ToList`, `ToDictionary`, `ToHashSet`, and `ToLookup` | Convert
    a sequence into an array or collection. These are the only extension methods that
    force the execution of a LINQ expression immediately, rather than wait for deferred
    execution, which you will learn about shortly. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.2: Non-deferred LINQ extension methods'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Make sure that you understand and remember the difference
    between LINQ extension methods that start with `As` and `To`. The `AsEnumerable`
    method casts the sequence into a different type but does not allocate memory,
    so that method are fast. Methods that start with `To`, like `ToList`, allocate
    memory for a new sequence of items, so they can be slow and will always use more
    memory resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Enumerable` class also has some methods that are not extension methods,
    as shown in *Table 11.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Empty<T>` | Returns an empty sequence of the specified type `T`. It is useful
    for passing an empty sequence to a method that requires an `IEnumerable<T>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Range` | Returns a sequence of integers from the `start` value with `count`
    items. For example, `Enumerable.Range(start: 5, count: 3)` would contain the integers
    5, 6, and 7. |'
  prefs: []
  type: TYPE_TB
- en: '| `Repeat` | Returns a sequence that contains the same element repeated `count`
    times. For example, `Enumerable.Repeat(element: "5", count: 3)` would contain
    the `string` values `"5"`, `"5"`, and `"5"`. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.3: Enumerable non-extension methods'
  prefs: []
  type: TYPE_NORMAL
- en: LINQ in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can build a console app to explore practical examples of using LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding deferred execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'LINQ uses **deferred execution**. It is important to understand that calling
    most of the above extension methods does not execute a query and get the results.
    Most of these extension methods return a LINQ expression that represents a *question*,
    not an *answer*. Let’s explore:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `LinqWithObjects`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter11`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the project file, globally and statically import the `System.Console` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class file named `Program.Helpers.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Helpers.cs`, delete any existing statements, and then define a
    partial `Program` class with a method to output a section title, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new class file named `Program.Functions.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, delete any existing statements, define a partial
    `Program` class with a method named `DeferredExecution` that is passed an array
    of `string` values, and then define two queries, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements, add statements to define a
    sequence of `string` values for people who work in an office, and then pass it
    as an argument to the `DeferredExecution` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Functions.cs`, in the `DeferredExecution` method, to get the answer
    (in other words, to execute the query), you must **materialize** it by either
    calling one of the `To` methods, like `ToArray`, `ToDictionary`, or `ToLookup`,
    or by enumerating the query. Add statements to do this, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Due to deferred execution, after outputting the first result, `Pam`, if the
    original array values change, then by the time we loop back around, there are
    no more matches because `Jim` has become `Jimmy` and does not end with an `m`,
    so only `Pam` is output.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get too deep into the weeds, let’s slow down and look at some common
    LINQ extension methods and how to use them, one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering entities using Where
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common reason for using LINQ is to filter items in a sequence using
    the `Where` extension method. Let’s explore filtering by defining a sequence of
    names and then applying LINQ operations to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project file, add an element to prevent the `System.Linq` namespace
    from automatically being imported globally, as shown highlighted in the following
    markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Functions.cs`, add a new method named `FilteringUsingWhere`, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are using Visual Studio, navigate to **Tools** | **Options**. In the
    **Options** dialog box, navigate to **Text Editor** | **C#** | **IntelliSense**,
    clear the **Show items from unimported namespaces** checkbox, and then click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `FilteringUsingWhere`, attempt to call the `Where` extension method on the
    array of names, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you type the `W`, note that in older code editors (or code editors with
    the option to show items from unimported namespaces disabled), the `Where` method
    is missing from the IntelliSense list of members of a `string` array, as shown
    in *Figure 11.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: IntelliSense with the Where extension method missing'
  prefs: []
  type: TYPE_NORMAL
- en: This is because `Where` is an extension method. It does not exist on the array
    type. To make the `Where` extension method available, we must import the `System.Linq`
    namespace. This is implicitly imported by default in new .NET 6 and later projects,
    but we removed it to illustrate the point. Recent versions of code editors are
    smart enough to suggest using the `Where` method anyway and indicate that they
    will import the `System.Linq` namespace for you automatically.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Visual Studio, navigate to **Tools** | **Options**. In the
    **Options** dialog box, navigate to **Text Editor** | **C#** | **IntelliSense**,
    select the **Show items from unimported namespaces** checkbox, and then click
    **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the project file, comment out the element that removed `System.Linq`, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the change and build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Retype the `W` for the `Where` method, and note that the IntelliSense list
    now includes the extension methods added by the `Enumerable` class, as shown in
    *Figure 11.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: IntelliSense showing LINQ extension methods when System.Linq is
    imported'
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, as you can see in the screenshot of Visual Studio on my computer,
    GitHub Copilot even suggests autocompleting with a lambda expression, very similar
    to the one that we will eventually end up writing. But there are some important
    intermediate steps you need to see before we get to that, so do not insert any
    GitHub Copilot suggestions if you have that feature enabled.
  prefs: []
  type: TYPE_NORMAL
- en: As you type the parentheses for the `Where` method, IntelliSense tells us that,
    to call `Where`, we must pass in an instance of a `Func<string, bool>` delegate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter an expression to create a new instance of a `Func<string, bool>` delegate,
    and for now, note that we have not yet supplied a method name because we will
    define it in the next step, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Leave the statement unfinished for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Func<string, bool>` delegate tells us that for each `string` variable passed
    to the method, the method must return a `bool` value. If the method returns `true`,
    it indicates that we should include the `string` in the results, and if the method
    returns `false`, it indicates that we should exclude it.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting a named method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s define a method that only includes names that are longer than four characters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, add a method that will return `true` only for names
    longer than four characters, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `FilteringUsingWhere` method, pass the method’s name into the `Func<string,
    bool>` delegate, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `FilteringUsingWhere` method, add statements to enumerate the `names`
    array using `foreach`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, comment out the call to `DeferredExecution`, and then pass
    `names` as an argument to the `FilteringUsingWhere` method, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, noting that only names longer than four
    letters are listed, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Simplifying code by removing the explicit delegate instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can simplify code by deleting the explicit instantiation of the `Func<string,
    bool>` delegate because the C# compiler can instantiate the delegate for us:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you learn by seeing progressively improved code, in the `FilteringUsingWhere`
    method, comment out the query and add a comment about how it works, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the query a second time but, this time, without the explicit instantiation
    of the delegate, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code, and note that it has the same behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Targeting a lambda expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can simplify our code even further using a **lambda expression** in place
    of a named method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it can look complicated at first, a lambda expression is simply a
    *nameless function*. It uses the `=>` (read as “goes to”) symbol to indicate the
    return value:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment out the second query, and then add a third version of the query that
    uses a lambda expression, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the syntax for a lambda expression includes all the important parts
    of the `NameLongerThanFour` method, and nothing more. A lambda expression only
    needs to define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The names of input parameters: `name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A return value expression: `name.Length > 4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of the `name` input parameter is inferred from the fact that the sequence
    contains `string` values, and the return type must be a `bool` value, as defined
    by the delegate, for `Where` to work; therefore, the expression after the `=>`
    symbol must return a `bool` value. The compiler does most of the work for us,
    so our code can be as concise as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code, and note that it has the same behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lambda expressions with default parameter values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Introduced with C# 12, you can now provide default values for parameters in
    lambda expressions, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our purpose for using this lambda expression means that setting a default value
    is not necessary, but later, you will see more useful examples.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other commonly used extension methods are `OrderBy` and `ThenBy`, used to sort
    a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by a single property using OrderBy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extension methods can be chained if the previous method returns another sequence,
    that is, a type that implements the `IEnumerable<T>` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue working with the current project to explore sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `FilteringUsingWhere` method, append a call to `OrderBy` to the end
    of the existing query, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Format the LINQ statement so that each extension method
    call happens on its own line, making it easier to read.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, and note that the names are now sorted by the shortest first,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To put the longest name first, you would use `OrderByDescending`.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by a subsequent property using ThenBy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We might want to sort by more than one property, for example, to sort names
    of the same length in alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `FilteringUsingWhere` method, append a call to the `ThenBy` method at
    the end of the existing query, as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note the slight difference in the following sort order. Within
    a group of names of the same length, the names are sorted alphabetically by the
    full value of the `string`, so `Creed` comes before `Kevin`, and `Angela` comes
    before `Dwight`, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sorting by the item itself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET 7 introduced the `Order` and `OrderDescending` extension methods. These
    simplify ordering by the item itself. For example, if you have a sequence of `string`
    values, then before .NET 7, you would have had to call the `OrderBy` method and
    pass a lambda that selects the items themselves, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With .NET 7 or later, we can simplify the statement, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`OrderDescending` does a similar thing but in descending order.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the `names` array contains instances of the `string` type, which
    implements the `IComparable` interface. This is why they can be ordered, aka sorted.
    If the array contained instances of a complex type, like `Person` or `Product`,
    then those types would have to implement the `IComparable` interface so that they
    could be ordered too.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a query using var or a specified type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While writing a LINQ expression, it is convenient to use `var` to declare the
    query object. This is because the return type frequently changes as you work on
    a LINQ expression. For example, our query started as an `IEnumerable<string>`
    and is currently an `IOrderedEnumerable<string>`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hover your mouse over the `var` keyword, and note that its type is `IOrderedEnumerable<string>`,
    as shown in *Figure 11.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_11_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Hover over var to see the actual implied type of the query expression'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 11.3*, I added extra vertical space between `names` and `.Where`
    so that the tooltip did not cover up the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace `var` with the actual type, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good practice**: Once you have finished working on a query, you could change
    the declared type from `var` to the actual type to make it clearer what the type
    is. This is easy because your code editor can tell you what it is. Doing this
    is just for clarity. It has no effect on performance because C# changes all `var`
    declarations to the actual types at compile time.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code, and note that it has the same behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filtering by type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Where` extension method is great for filtering by values, such as text
    and numbers. But what if the sequence contains multiple types and you want to
    filter by a specific type, respecting any inheritance hierarchy?
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have a sequence of exceptions. There are hundreds of exception
    types that form a complex inheritance hierarchy, as partially shown in *Figure
    11.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_11_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: A partial exception inheritance hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore filtering by type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, define a new method to list, and then filter exception-derived
    objects using the `OfType<T>` extension method to remove exceptions that are not
    arithmetic exceptions, writing only the arithmetic exceptions to the console,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, comment out the call to `FilteringUsingWhere`, and then add
    a call to the `FilteringByType` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note that the results only include exceptions of the `ArithmeticException`
    type or the `ArithmeticException`-derived types, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with sets and bags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sets are one of the most fundamental concepts in mathematics. A **set** is a
    collection of one or more unique objects. A **multiset**, aka a **bag**, is a
    collection of one or more objects that can have duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: You might remember being taught about Venn diagrams in school. Common set operations
    include the **intersect** or **union** between sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code that will define three arrays of `string` values for
    cohorts of apprentices, and then we’ll perform some common set and multiset operations
    on them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, add a method that outputs any sequence of `string`
    variables as a comma-separated single `string` to the console output, along with
    an optional description, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Functions.cs`, add a method that defines three arrays of names,
    outputs them, and then performs various set operations on them, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, comment out the call to `FilteringByType`, and then add a
    call to the `WorkingWithSets` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With `Zip`, if there are unequal numbers of items in the two sequences, then
    some items will not have a matching partner. Those without a partner, like `Jared`,
    will not be included in the result.
  prefs: []
  type: TYPE_NORMAL
- en: For the `DistinctBy` example, instead of removing duplicates by comparing the
    whole name, we define a lambda key selector to remove duplicates by comparing
    the first two characters, so `Jared` is removed because `Jack` is already a name
    that starts with `Ja`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the index as well as items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET 9 introduced the `Index` LINQ extension method. In previous versions of
    .NET, if you wanted to get the index position of each item as well as the items
    themselves, you could do it using the `Select` method, but it was a bit messy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of the old way and the new way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, add a method that defines an array of names and
    outputs them with their index position, using the old way (the `Select` method)
    and then the new way (the `Index` method), as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning!** Note the order of the two declared variables that will hold the
    index and the item. When using the `Select` method, you must declare the `item`
    first and then the `index` second. When using the `Index` method, you must declare
    the `index` first and then the `item` second.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, comment out the call to `WorkingWithSets`, and then add a
    call to the `WorkingWithIndices` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So far, we have used the LINQ to Objects provider to work with in-memory objects.
    Next, we will use the LINQ to Entities provider to work with entities stored in
    a database.
  prefs: []
  type: TYPE_NORMAL
- en: Using LINQ with EF Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at LINQ queries that filter and sort, but none that change the
    shape of the items in the sequence. This operation is called **projection** because
    it’s about projecting items of one shape into another shape. To learn about projection,
    it is best to have some more complex types to work with, so in the next project,
    instead of using `string` sequences, we will use sequences of entities from the
    Northwind sample database that you were introduced to in *Chapter 10*, *Working
    with Data Using Entity Framework Core*.
  prefs: []
  type: TYPE_NORMAL
- en: I will give instructions to use SQLite because it is cross-platform, but if
    you prefer to use SQL Server, then feel free to do so. I have included some commented
    code to enable SQL Server if you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a console app for exploring LINQ to Entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we must create a console app and Northwind database to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App** / `console` project,
    named `LinqWithEFCore`, to the `Chapter11` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the project file, globally and statically import the `System.Console` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `LinqWithEFCore` project, add a package reference to the EF Core provider
    for SQLite and/or SQL Server, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `LinqWithEFCore` project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `Northwind4Sqlite.sql` file to the `LinqWithEFCore` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At a command prompt or terminal in the `LinqWithEFCore` folder, create the
    Northwind database by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Be patient because this command might take a while to create the database structure.
    Eventually, you will see the SQLite command prompt, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To exit SQLite command mode, press *Ctrl* + *C* twice on Windows or *Cmd* +
    *D* on macOS or Linux.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you prefer to work with SQL Server, then you should already have the Northwind
    database created in SQL Server from the previous chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building an EF Core model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We must define an EF Core model to represent the database and tables that we
    will work with. We will define the model manually to take complete control, and
    to prevent a relationship from being automatically defined between the `Categories`
    and `Products` tables. Later, you will use LINQ to join the two entity sets:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `LinqWithEFCore` project, add a new folder named `EntityModels`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `EntityModels` folder, add three class files to the project, named `NorthwindDb.cs`,
    `Category.cs`, and `Product.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class file named `Category.cs`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the class file named `Product.cs`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have deliberately not defined any relationships between `Category` and `Product`
    so that we can see how to manually associate them with each other using LINQ later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the class file named `NorthwindDb.cs`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you want to use SQL Server, then comment out the statement that calls `UseSqlite`
    and uncomment the statement that calls `UseSqlServer`.
  prefs: []
  type: TYPE_NORMAL
- en: Build the project and fix any compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filtering and sorting sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s write statements to filter and sort sequences of rows from the tables:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `LinqWithEFCore` project, add a new class file named `Program.Helpers.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Helpers.cs`, define a partial `Program` class with a method to
    configure the console to support special characters, like the Euro currency symbol,
    and control the current culture, as well as a method to output a section title,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `LinqWithEFCore` project, add a new class file named `Program.Functions.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, define a partial `Program` class, and add a method
    to filter and sort products, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following about the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DbSet<T>` implements `IEnumerable<T>`, so LINQ can be used to query and manipulate
    sequences of entities in models built for EF Core. (Actually, I should say `TEntity`
    instead of `T`, but the name of this generic type has no functional effect. The
    only requirement is that the type is a `class`. The name just indicates that the
    class is expected to be an entity model.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sequences implement `IQueryable<T>` (or `IOrderedQueryable<T>` after a call
    to an ordering LINQ method) instead of `IEnumerable<T>` or `IOrderedEnumerable<T>`.
    This is an indication that we are using a LINQ provider that builds the query,
    using expression trees. They represent code in a tree-like data structure and
    enable the creation of dynamic queries, which is useful for building LINQ queries
    for external data providers, like SQLite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The LINQ expression will be converted into another query language, such as SQL.
    Enumerating the query with `foreach` or calling a method such as `ToArray` will
    force the execution of the query and materialize the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete any existing statements, and then call the `ConfigureConsole`
    and `FilterAndSort` methods, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the project and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although this query outputs the information we want, it does so inefficiently
    because it gets all the columns from the `Products` table, instead of just the
    three columns we need. Let’s log the generated SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `FilterAndSort` method, before enumerating the results using `foreach`,
    add a statement to output the SQL, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and view the result that shows the SQL executed before the product
    details, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Projecting sequences into new types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we look at **projection**, we should review object initialization syntax.
    If you have a class defined, then you can instantiate an object using the class
    name, `new()`, and curly braces to set initial values for fields and properties,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'C# 3 and later allow instances of **anonymous types** to be instantiated using
    the `var` keyword, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we did not specify a type, the compiler can infer an anonymous type
    from the setting of two properties, named `Name` and `DateOfBirth`. The compiler
    can infer the types of the two properties from the values assigned: a literal
    `string` and a new instance of a date/time value.'
  prefs: []
  type: TYPE_NORMAL
- en: This capability is especially useful when writing LINQ queries to project an
    existing type into a new type, without having to explicitly define the new type.
    Since the type is anonymous, this can only work with `var`-declared local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make the SQL command executed against the database table more efficient
    by adding a call to the `Select` method, projecting instances of the `Product`
    class into instances of a new anonymous type with only three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, in the `FilterAndSort` method, add a statement to
    extend the LINQ query to use the `Select` method to return only the three properties
    (that is, table columns) that we need, modify the call to `ToQueryString` to use
    the new `projectedProducts` query, and modify the `foreach` statement to use the
    `var` keyword and the new `projectedProducts` query, as shown highlighted in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hover your mouse over the `new` keyword in the `Select` method call, or the
    `var` keyword in the `foreach` statement, and note that it is an anonymous type,
    as shown in *Figure 11.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_11_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: An anonymous type used during LINQ projection'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the project, and confirm that the output is the same as before and the
    generated SQL is more efficient, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**More Information**: You can learn more about projection using the `Select`
    method at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/projection-operations](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/projection-operations).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue to look at common LINQ queries by learning how to join, group,
    and perform lookups.
  prefs: []
  type: TYPE_NORMAL
- en: Joining, grouping, and lookups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three extension methods for joining, grouping, and creating grouped
    lookups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Join`: This method has four parameters: the sequence that you want to join
    with, the property or properties on the *left* sequence to match on, the property
    or properties on the *right* sequence to match on, and a projection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GroupJoin`: This method has the same parameters, but it combines the matches
    into a group object with a `Key` property for the matching value and an `IEnumerable<T>`
    type for the multiple matches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ToLookup`: This method creates a new data structure with the sequence grouped
    by a key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore these methods when working with two tables, `Categories` and
    `Products`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, add a method to select categories and products,
    join them, and output them, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a join, there are two sequences, `outer` and `inner`. In the preceding example,
    `categories` is the outer sequence and `products` is the inner sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, comment out the call to `FilterAndSort`, and then call the
    `JoinCategoriesAndProducts` method, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results. Note that there is a single line of output
    for each of the 77 products, as shown in the following output (edited to only
    include the first four items):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.Functions.cs`, in the `JoinCategoriesAndProducts` method, at the
    end of the existing query, call the `OrderBy` method to sort by `CategoryName`,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results. Note that there is a single line of output
    for each of the 77 products, and the results show all products in the `Beverages`
    category first, then the `Condiments` category, and so on, as shown in the following
    partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Group-joining sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore group joining when working with the same two tables that we used
    to explore joining, `Categories` and `Products`, so that we can compare the subtle
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, add a method to group and join, show the group name,
    and then show all the items within each group, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we had not called the `AsEnumerable` method, then a runtime exception would
    have been thrown, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is because not all LINQ extension methods can be converted from expression
    trees into some other query syntax, like SQL. In these cases, we can convert from
    `IQueryable<T>` to `IEnumerable<T>` by calling the `AsEnumerable` method, which
    forces query processing to use LINQ to EF Core only to bring the data into the
    application, and then LINQ to Objects to execute more complex processing in memory.
    But, often, this is less efficient.
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs`, call the `GroupJoinCategoriesAndProducts` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, view the results, and note that the products inside each category
    have been sorted by their name, as defined in the query and as shown in the following
    partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Grouping for lookups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of writing a LINQ query expression to join and group and running it
    once, you might want to use a LINQ extension method to create, and then store
    a reusable in-memory collection that has entities that have been grouped.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a table named `Products` in the Northwind database that includes a
    column for the categories that they reside in, as partially shown in *Table 11.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ProductName** | **CategoryID** |'
  prefs: []
  type: TYPE_TB
- en: '| Chai | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Chang | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Aniseed Syrup | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Chef Anton’s Cajun Seasoning | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Chef Anton’s Gumbo Mix | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| ... | ... |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.4: The first five rows of the Products table'
  prefs: []
  type: TYPE_NORMAL
- en: You might want to create a data structure in memory that can group the `Product`
    entities by their category, and then provide a quick way to look up all the products
    in a specific category.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create this using the `ToLookup` LINQ method, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: When you call the `ToLookup` method, you must specify a **key selector** to
    choose what value you want to group by. This value can then later be used to look
    up the group and its items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ToLookup` method creates a dictionary-like data structure of key-value
    pairs in memory that has unique category IDs for the key and a collection of `Product`
    objects for the value, as partially shown in *Table 11.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Value (each one is a collection of Product objects)** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | [Chai], [Chang], and so on |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | [Aniseed Syrup], [Chef Anton’s Cajun Seasoning], [Chef Anton’s Gumbo
    Mix], and so on |'
  prefs: []
  type: TYPE_TB
- en: '| ... | ... |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.5: The first two rows in the lookup'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the product names in square brackets, such as [`Chai`], represent
    an entire `Product` object.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the `CategoryId` values as the key to the lookup, we could
    use the category names from the related categories table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do this in a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.Functions.cs`, add a method to join products to category names,
    and then convert them into a lookup, enumerate through the whole lookup using
    an `IGrouping<string, Product>` to represent each row in the lookup dictionary,
    and look up an individual collection of products for a specific category, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Selector** parameters are lambda expressions that select sub-elements for
    different purposes. For example, `ToLookup` has a `keySelector` to select the
    part of each item that will be the key and an `elementSelector` to select the
    part of each item that will be the value. You can learn more at the following
    link: [https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.tolookup](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.tolookup).'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs`, call the `ProductsLookup` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, view the results, enter a category name like `Seafoods`, and
    note that the products have been looked up and listed for that category, as shown
    in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is a lot more to LINQ, and in the final section, you will have the opportunity
    to explore further with some online material to walk through.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring with deeper research the topics covered in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 11.1 – Online material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online materials can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating and paging sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can learn how to use LINQ aggregate methods and implement paging for data
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch11-aggregating.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-aggregating.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple threads with parallel LINQ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can improve performance and scalability by using multiple threads to run
    LINQ queries. Learn how by completing the online-only section found at the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch11-plinq.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-plinq.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Working with LINQ to XML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to process or generate XML using LINQ, then you can learn the basics
    of how by completing the online-only section found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch11-linq-to-xml.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-linq-to-xml.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own LINQ extension methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to create your own LINQ extension methods, then you can learn the
    basics of how by completing the online-only section found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch11-custom-linq-methods.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch11-custom-linq-methods.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Design of the new LINQ methods in .NET 9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read about the design of the new LINQ extension methods introduced
    in .NET 9 at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AggregateBy`: [https://github.com/dotnet/runtime/issues/91533](https://github.com/dotnet/runtime/issues/91533).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CountBy`: [https://github.com/dotnet/runtime/issues/77716](https://github.com/dotnet/runtime/issues/77716).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Index`: [https://github.com/dotnet/runtime/issues/95563](https://github.com/dotnet/runtime/issues/95563).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 11.2 – Practice querying with LINQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Chapter11` solution, create a console application, named `Exercise_LinqQueries`,
    that prompts the user for a city and then lists the company names for Northwind
    customers in that city, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, enhance the application by displaying a list of all the unique cities
    that customers already reside in as a prompt to the user before they enter their
    preferred city, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 11.3 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the two required parts of LINQ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which LINQ extension method would you use to return a subset of properties from
    a type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which LINQ extension method would you use to filter a sequence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List five LINQ extension methods that perform aggregation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `Select` and `SelectMany` extension methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `IEnumerable<T>` and `IQueryable<T>`? How do
    you switch between them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the last type parameter `T` in generic `Func` delegates like `Func<T1,
    T2, T>` represent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of a LINQ extension method that ends with `OrDefault`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is query comprehension syntax optional?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you create your own LINQ extension methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 11.4 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-11---querying-and-manipulating-data-using-linq](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-11---querying-and-manipulating-data-using-linq)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to write LINQ queries to perform common tasks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting just the properties of an item that you need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering items based on conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projecting items into different types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining and grouping items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will be introduced to web development using ASP.NET
    Core. In the remaining chapters, you will learn how to implement modern features
    of ASP.NET Core, like Blazor and Minimal APIs.
  prefs: []
  type: TYPE_NORMAL
