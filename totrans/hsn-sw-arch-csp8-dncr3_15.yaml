- en: Applying Service-Oriented Architectures with .NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET Core应用SOA
- en: The term **Service-Oriented Architecture** (**SOA**) refers to a modular architecture
    where interaction between system components is achieved through communication.
    SOA allows applications from different organizations to exchange data and transactions
    automatically and allows organizations to offer services on the internet.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**面向服务的架构**（**SOA**）指的是一种模块化架构，其中系统组件之间的交互是通过通信实现的。SOA允许来自不同组织的应用程序自动交换数据和事务，并允许组织在互联网上提供服务。
- en: Moreover, as we discussed in the *Microservices as the evolution of the concept
    of modules* section of [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml),
    *Applying a Microservice Architecture to Your Enterprise Application*, communication-based
    interaction solves binary compatibility and version mismatch problems that inevitably
    appear in complex systems made up of modules that share the same address space.
    Moreover, with SOA, you don't need to deploy different copies of the same component
    in the various systems/subsystem that use it – each component only needs to be
    deployed in just one place. This can be a single server, a cluster located in
    a single data center, or a geographically distributed cluster. Here, each version
    of your component is deployed just once, and the server/cluster logic automatically
    creates all the necessary replicas, thus simplifying the overall **Continuous
    Integration / Continuous Delivery** (**CI/CD**) cycle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们在第5章的*模块概念的演变 - 微服务*部分中讨论的，*将微服务架构应用于您的企业应用程序*，基于通信的交互解决了由共享相同地址空间的模块组成的复杂系统中不可避免出现的二进制兼容性和版本不匹配问题。此外，使用SOA，您不需要在所有使用该组件的系统/子系统上部署同一组件的不同副本
    - 每个组件只需在一个地方部署即可。这可以是一个单独的服务器，位于单个数据中心的位置集群，或者地理上分布的集群。在这里，您的组件的每个版本都只部署一次，服务器/集群逻辑自动创建所有必要的副本，从而简化了整体的**持续集成/持续交付**（**CI/CD**）周期。
- en: As long as a newer version conforms to the communication interface that's declared
    to the clients, no incompatibilities can occur. On the other hand, with DLLs/packages,
    when the same interface is maintained, incompatibilities may arise because of
    possible version mismatches in terms of the dependencies of other DLLs/packages
    that the library module might have in common with its clients.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 只要新版本符合向客户端声明的通信接口，就不会出现不兼容性。另一方面，当使用DLLs/packages时，如果保持相同的接口，由于库模块可能与其客户端共享的其他DLLs/packages的依赖项中可能出现的版本不匹配，可能会出现不兼容性。
- en: 'Organizing clusters/networks of cooperating services was discussed in [Chapter
    5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying a Microservice Architecture
    to Your Enterprise Application*. In this chapter, we will mainly focus on the
    communication interface offered by each service. More specifically, we will discuss
    the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章[将微服务架构应用于您的企业应用程序](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)中讨论了组织协作服务的集群/网络。在本章中，我们将主要关注每个服务提供的通信接口。更具体地说，我们将讨论以下主题：
- en: Understanding the principles of the SOA approach
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解SOA方法的原则
- en: How does .NET Core deal with SOA?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core如何处理SOA？
- en: Use case – exposing WWTravelClub packages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例 - 暴露WWTravelClub包
- en: By the end of this chapter, you will know how to publicly expose data from the WWTravelClub
    book use case through an ASP.NET Core service.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解如何通过ASP.NET Core服务公开暴露WWTravelClub书用例中的数据。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Visual Studio 2017 or 2019 free Community Edition or better
    with all the database tools installed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要Visual Studio 2017或2019免费社区版或更高版本，并安装所有数据库工具。
- en: All the concepts in this chapter will be clarified with practical examples based
    on this book's WWTravelClub book use case. You will find the code for this chapter
    at [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有概念都将基于本书的WWTravelClub书用例的实践示例进行阐明。您可以在[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8)找到本章的代码。
- en: Understanding the principles of the SOA approach
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SOA方法的原则
- en: Like classes in an object-oriented architecture, services are implementations
    of interfaces that, in turn, come from system functional specifications. Therefore,
    the first step in a *service* design is the definition of its abstract interface.
    During this stage, you define all the service operations as interface methods
    that operate on the types of your favorite language (C#, Java, C++, JavaScript,
    and so on) and decide which operations to implement with synchronous communication
    and which ones to implement with asynchronous communication.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就像面向对象架构中的类一样，服务是实现接口的实例，而这些接口又来自系统功能规格。因此，*服务* 设计的第一步是定义其抽象接口。在这个阶段，你将所有服务操作定义为操作接口方法，这些方法作用于你喜欢的语言类型（C#、Java、C++、JavaScript
    等），并决定哪些操作使用同步通信实现，哪些操作使用异步通信实现。
- en: The interfaces that are defined in this initial stage won't necessarily be used
    in the actual service implementation, and are just useful design tools. Once we've
    decided on the architecture of the services, these interfaces are usually redefined
    so that we can adapt them to the peculiarity of the architecture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始阶段定义的接口不一定会在实际的服务实现中使用，它们只是有用的设计工具。一旦我们确定了服务的架构，这些接口通常会被重新定义，以便我们可以根据架构的独特性来适应它们。
- en: It is worth pointing out that SOA messages must keep the same kind of semantics
    as method calls/answers; that is, the reaction to a message must not depend on
    any previously received messages. Here, the messages must be independent of each
    other, and the service *must not remember* any previously received messages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，SOA 消息必须保持与方法调用/响应相同类型的语义；也就是说，对消息的反应不能依赖于任何之前接收到的消息。在这里，消息必须相互独立，服务
    *不得记住* 任何之前接收到的消息。
- en: For instance, if the purpose of messages is to create a new database entry,
    this semantic must not change with the context of other messages, and the way
    the database entry is created must depend on the content of the current message
    and not on other previously received messages. As a consequence, a client can't
    create sessions and can't log in to a service, perform some operations, and then
    log out. An authentication token must be repeated in each message.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果消息的目的是创建一个新的数据库条目，这种语义不能随着其他消息的上下文而改变，并且数据库条目的创建方式必须依赖于当前消息的内容，而不是其他之前接收到的消息。因此，客户端不能创建会话，也不能登录到服务，执行一些操作，然后注销。必须在每个消息中重复使用认证令牌。
- en: The reasons for this constraint are modularity, testability, and maintainability.
    In fact, a session-based service would be very hard to test and modify due to
    the interactions that are *hidden* in the session data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种约束的原因是模块化、可测试性和可维护性。实际上，由于会话数据中隐藏的交互，基于会话的服务将很难进行测试和修改。
- en: 'Once you''ve decided on the interface that''s going to be implemented by a
    service, you must decide which communication stack/ SOA architecture to adopt.
    The communication stack must be part of some official or de facto standard to
    ensure your service''s interoperability. Interoperability is the main constraint
    prescribed by SOA: services must offer a communication interface that does not
    depend on the specific communication library used, on the implementation language,
    or on the deployment platform.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了一个服务将要实现的用户界面，你必须决定采用哪种通信栈/ SOA 架构。通信栈必须是某个官方或事实上的标准的一部分，以确保你的服务的互操作性。互操作性是
    SOA 规定的主要约束：服务必须提供一个不依赖于特定通信库、实现语言或部署平台的通信接口。
- en: Once you've decided on the communication stack/architecture, you need to adapt
    your previous interfaces to the architecture's peculiarities (see the *REST web
    services* subsection of this chapter for more details). Then, you must translate
    these interfaces into the chosen communication language. This means that you have
    to map all the programming language types into types that are available in the
    chosen communication language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了通信栈/架构，你需要将之前的接口适应架构的独特性（有关更多详细信息，请参阅本章的 *REST Web 服务* 子节）。然后，你必须将这些接口翻译成选定的通信语言。这意味着你必须将所有编程语言类型映射到所选通信语言中可用的类型。
- en: The actual translation of data is usually performed automatically by the SOA
    libraries that are used by your development environment. However, some configuration
    might be needed and, in any case, we must be aware of how our programming language
    types are transformed before each communication. For instance, some numeric types
    might be transformed into types with less precision or with different ranges of
    values.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的数据转换通常由开发环境使用的SOA库自动执行。然而，可能需要一些配置，并且在任何情况下，我们必须意识到在每次通信之前我们的编程语言类型是如何转换的。例如，某些数值类型可能被转换为精度较低或值范围不同的类型。
- en: The interoperability constraint can be interpreted in a lighter form in the
    case of microservices that aren't accessible outside of their clusters, since
    they need to communicate with other microservices that belong to the same cluster.
    In this case, this means that the communication stack might be platform-specific
    so that it can increase performance, but it must be a de facto standard to avoid
    compatibility problems with other microservices that might be added to the cluster
    as the application evolves.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集群外不可访问的微服务，互操作性约束可以以较轻的形式解释，因为它们需要与其他属于同一集群的微服务进行通信。在这种情况下，这意味着通信栈可能是平台特定的，以便提高性能，但它必须是一个事实上的标准，以避免与其他可能随着应用程序的发展而添加到集群中的微服务兼容性问题。
- en: We've spoken of the *communication stack* and not of the *communication protocol* because
    SOA communication standards usually define the format of the message's content
    and provide different possibilities for the specific protocol that's used to embed
    those messages. For instance, the SOAP protocol just defines an XML-based format
    for the various kind of messages, but SOAP messages can be conveyed by various
    protocols. Usually, the most common protocol that's used for SOAP is HTTP, but
    you may decide to jump to the HTTP level and send SOAP messages directly over
    TCP/IP for better performance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的是*通信栈*而不是*通信协议*，因为SOA通信标准通常定义消息内容的格式，并为嵌入这些消息的特定协议提供不同的可能性。例如，SOAP协议仅定义了各种消息的基于XML的格式，但SOAP消息可以通过各种协议传递。通常，用于SOAP的最常见协议是HTTP，但你可能决定跳到HTTP级别，并通过TCP/IP直接发送SOAP消息以获得更好的性能。
- en: 'The choice of communication stack you should adopt depends on several factors:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该采用的通信栈的选择取决于几个因素：
- en: '**Compatibility constraints**: If your service must be publicly available on
    the internet to business clients, then you must conform to the most common choices,
    which means using either SOAP over HTTP or JSON REST services. The most common
    choices are different if your clients aren''t business clients but **Internet
    of Things** (**IoT**) clients. Also, within IoT, the protocols that are used in
    different application areas can be different. For instance, marine vehicle status
    data isn''t typically exchanged with *Signal K*.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性约束**：如果你的服务必须对互联网上的商业客户公开可用，那么你必须遵守最常见的选择，这意味着使用HTTP上的SOAP或JSON REST服务。如果您的客户端不是商业客户端而是**物联网**（**IoT**）客户端，那么最常见的选择可能会有所不同。在物联网中，不同应用领域使用的协议可能不同。例如，海洋车辆状态数据通常不与*Signal
    K*交换。'
- en: '**Development/deployment platform**: Not all communication stacks are available
    on all development frameworks and on all deployment platforms. For instance, .NET
    remoting, which we used in the code example at the end of [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*, is specific to .NET
    and Azure Service Fabric. Luckily, all the most common communication stacks that
    are used in public business services, such as SOAP and JSON-based REST communication,
    are available in all the main development/deployment platforms.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发/部署平台**：并非所有通信栈都适用于所有开发框架和所有部署平台。例如，我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)的代码示例中使用的.NET远程通信，专门针对.NET和Azure
    Service Fabric。幸运的是，所有在公共商业服务中使用的最常见通信栈，如基于SOAP和JSON的REST通信，都可在所有主要开发/部署平台上使用。'
- en: '**Performance**: If your system is not exposed to the outside world and is
    a private part of your microservice cluster, performance considerations have a
    higher priority. That''s why, in the Service Fabric example at the end of [Chapter
    5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying a Microservice Architecture
    to Your Enterprise Application*, we used .NET remoting as an internal communication
    stack. It is worth pointing out that, with *private* services, you need to be
    concerned about interoperability and refrain from using custom communication stacks.
    .NET remoting is not an official standard, but it is acceptable because it is
    a kind of de facto standard for internal communication within Azure Service Fabric.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：如果你的系统没有暴露给外界，而是你的微服务集群的私有部分，性能考虑的优先级更高。这就是为什么在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)的末尾的Service
    Fabric示例中，*将微服务架构应用于企业应用程序*，我们使用了.NET远程通信作为内部通信栈。值得注意的是，对于*私有*服务，你需要关注互操作性，并避免使用自定义通信栈。.NET远程通信不是一个官方标准，但它是可以接受的，因为它是在Azure
    Service Fabric内部通信的事实标准。'
- en: '**Availability of tools and knowledge in your team**: Having knowledge and
    knowing about the availability of tools in your team/organization has an important
    weight when it comes to choosing between acceptable communication stacks. However,
    this kind of constraint always has less priority than compatibility constraints
    since it makes no sense to conceive a system that is easy to implement for your
    team but that almost nobody can use.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你团队中工具和知识的可用性**：在选择可接受的通信栈时，了解团队/组织中工具和知识的可用性具有重要意义。然而，这种限制通常比兼容性约束的优先级低，因为设想一个对团队来说易于实施但几乎无人能使用的系统是没有意义的。'
- en: '**Flexibility versus available features**: Some communication solutions, while
    less complete, offer a higher degree of flexibility, while other solutions, while
    being more complete, offer less flexibility. The need for flexibility started
    a movement from SOAP-based services to the more flexible REST services in the
    last few years. This point will be discussed in more detail when we describe SOAP
    and REST services in the remainder of this section.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性与可用特性之间的权衡**：一些通信解决方案虽然不够完整，但提供了更高的灵活性，而其他解决方案虽然更完整，但提供的灵活性较低。对灵活性的需求在过去的几年中引发了一场从基于SOAP的服务转向更灵活的REST服务的运动。当我们在本节剩余部分描述SOAP和REST服务时，这一点将更详细地讨论。'
- en: '**Service description**: When services must be exposed on the internet, client
    applications need a publicly available description of the service specifications
    in order to design their communication clients. Some communication stacks include
    languages and conventions to describe service specifications. Formal service specifications
    that are exposed this way can be processed so that they automatically create communication clients.
    SOAP goes further and allows service discoverability by means of a public XML-based
    directory containing information about the tasks each web service can carry out.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务描述**：当服务必须在互联网上公开时，客户端应用程序需要一个公开可用的服务规范描述，以便设计它们的通信客户端。一些通信栈包括用于描述服务规范的语言和约定。以这种方式公开的形式化服务规范可以被处理，以便自动创建通信客户端。SOAP更进一步，通过一个包含有关每个Web服务可以执行的任务信息的公共XML目录，允许服务可发现性。'
- en: Once you've chosen the communication stack you wish to use, you must use the
    tools that are available in your development environment to implement the service
    in a way that conforms to the chosen communication stack. Sometimes, communication
    stack compliance is automatically ensured by the development tools, but sometimes,
    it may require some development effort. For instance, in the .NET world, the compliance
    of SOAP services is automatically ensured by development tools if you use WCF,
    while the compliance of REST services falls under the developer's responsibility.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了希望使用的通信栈，你必须使用你的开发环境中可用的工具以符合所选通信栈的方式实现服务。有时，通信栈的合规性可以通过开发工具自动保证，但有时可能需要一些开发工作。例如，在.NET世界中，如果你使用WCF，SOAP服务的合规性会自动由开发工具保证，而REST服务的合规性则落在开发者的责任之下。
- en: 'Some of the fundamental features of SOA solutions are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: SOA解决方案的一些基本特性如下：
- en: '**Authentication**: Allows the client to authenticate to access service operations.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：允许客户端认证以访问服务操作。'
- en: '**Authorization**: Handles the client''s permissions.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：处理客户端的权限。'
- en: '**Security**: This is how communication is kept safe, that is, how to prevent
    unauthorized systems from reading and/or modifying the content of the communication.
    Typically, encryption prevents both unauthorized modifications and reading, while
    electronic signature algorithms prevent just modifications.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：这是如何保持通信安全的方法，即如何防止未经授权的系统读取和/或修改通信内容。通常，加密可以防止未经授权的修改和读取，而电子签名算法仅防止修改。'
- en: '**Exceptions**: Returns exceptions to the client.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常**：向客户端返回异常。'
- en: '**Message reliability**: Ensures that messages reliably reach their destination
    in case of possible infrastructure faults.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息可靠性**：确保在可能的基础设施故障的情况下，消息可靠地到达其目的地。'
- en: 'Though sometimes desirable, the following features aren''t always necessary:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时是可取的，但以下功能并不总是必要的：
- en: '**Distributed transactions**: The capability to handle distributed transactions,
    thus undoing all the changes you''ve made whenever the distributed transactions
    fail or are aborted'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式事务**：处理分布式事务的能力，因此当分布式事务失败或被中止时，可以撤销所做的所有更改。'
- en: '**Support for the Publisher/Subscriber pattern**: If and how events and notifications
    are supported'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持发布/订阅模式**：如果以及如何支持事件和通知'
- en: '**Addressing**: If and how references to other services and or service/methods
    are supported'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寻址**：如果以及如何支持对其他服务和/或服务/方法的引用'
- en: '**Routing**: If and how messages can be routed through a network of services'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：如果以及如何将消息通过服务网络进行路由'
- en: The remainder of this section is dedicated to describing SOAP and REST services
    since they are the de facto standard for business services that are exposed outside
    of their clusters/servers. For performance reasons, microservices use other protocols
    such as .NET Remoting and AMQP for inter-cluster communication. The usage of .NET
    Remoting was discussed in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*, while links on AMQP
    are given in the *Further reading* section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分致力于描述 SOAP 和 REST 服务，因为它们是公开其集群/服务器之外的业务服务的既定标准。出于性能原因，微服务使用其他协议，如 .NET
    Remoting 和 AMQP 进行集群间通信。.NET Remoting 的使用在第 5 章[将微服务架构应用于您的企业应用程序](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)中讨论，而
    AMQP 的链接在*进一步阅读*部分给出。
- en: SOAP web services
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOAP 网络服务
- en: The **Simple Object Access Protocol** (**SOAP**) allows both one-way messages
    and answer/response messages. Communication can be both synchronous and asynchronous,
    but, if the underlying protocol is synchronous, such as in the case of HTTP, the
    sender receives an acknowledgment saying that the message was received (but not
    necessarily processed). When asynchronous communication is used, the sender must
    listen for incoming communications. Often, asynchronous communication is implemented
    with the subscriber/publisher pattern that we described in [Chapter 9](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml), *Design
    Patterns and .NET Core Implementation*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单对象访问协议**（**SOAP**）允许单向消息和响应/回答消息。通信可以是同步的，也可以是异步的，但如果底层协议是同步的，例如在 HTTP
    的情况下，发送者会收到一个确认消息，表明消息已被接收（但不一定已处理）。当使用异步通信时，发送者必须监听传入的通信。通常，异步通信是通过我们第 9 章[设计模式和
    .NET Core 实现](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml)中描述的订阅者/发布者模式实现的。'
- en: Messages are represented as XML documents called **envelopes**. Each envelope
    contains a `header`, a `body`, and a `fault` element. The `body` is where the
    actual content of the message is placed. The `fault` element contains possible
    errors, so it's the way exceptions are exchanged when communication occurs. Finally,
    the `header` contains any auxiliary information that enriches the protocol but
    does not contain domain data. For example, the `header` may contain an authentication
    token, and/or a signature if the message is signed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 消息表示为称为**封装**的 XML 文档。每个封装包含一个`header`（头部）、一个`body`（主体）和一个`fault`（错误）元素。`body`是放置实际消息内容的地方。`fault`元素包含可能的错误，因此它是通信发生时交换异常的方式。最后，`header`包含任何丰富协议但不包含域数据的辅助信息。例如，`header`可能包含一个身份验证令牌，以及/或如果消息已签名，则包含一个签名。
- en: The underlying protocol that's used to send the XML envelopes is usually HTTP,
    but the SOAP specification allows any protocol, so we can use TCP/IP or SMTP directly.
    As a matter of fact, the more diffused underlying protocol is HTTP, so, if you
    don't have a good reason to choose another protocol, you should use HTTP in order
    to maximize the service's interoperability.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 用于发送 XML 封装的底层协议通常是 HTTP，但 SOAP 规范允许使用任何协议，因此我们可以直接使用 TCP/IP 或 SMTP。实际上，更广泛使用的底层协议是
    HTTP，因此，如果没有充分的理由选择其他协议，您应该使用 HTTP 以最大限度地提高服务的互操作性。
- en: SOAP specifications contain the basics of message exchange, while other auxiliary
    features are described in separate specification documents called `WS- *` and
    are usually handled by adding extra information in the SOAP `header`. `WS-*` specifications
    handle all the fundamental and desirable features of SOA we listed previously.
    For instance, `WS-Security` takes care of security, including authentication,
    authorization, and encryption/signatures; `WS-Eventing` and `WS-Notification`
    are two alternative ways of implementing the publisher/subscriber pattern; `WS-ReliableMessaging` is
    concerned with the reliable delivery of messages in case of possible faults, and `WS-Transaction`
    is concerned with distributed transactions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP 规范包含消息交换的基本内容，而其他辅助功能则在单独的规范文档中描述，称为 `WS-*`，通常通过在 SOAP `header` 中添加额外信息来处理。`WS-*`
    规范处理我们之前列出的 SOA 的所有基本和期望的特性。例如，`WS-Security` 负责安全，包括身份验证、授权和加密/签名；`WS-Eventing`
    和 `WS-Notification` 是实现发布/订阅模式的两种替代方法；`WS-ReliableMessaging` 关注于在可能出现故障的情况下可靠地传递消息，而
    `WS-Transaction` 关注于分布式事务。
- en: The preceding `WS-*` specifications are in no way exhaustive but are the more
    relevant and supported features. In fact, actual implementations in various environments
    (such as Java and .NET) furnish the more relevant `WS-*` services, but no implementation
    supports all the `WS-*` specifications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `WS-*` 规范并非详尽无遗，但它们是更相关且得到支持的特性。实际上，在各个环境（如 Java 和 .NET）中的实际实现提供了更相关的 `WS-*`
    服务，但没有一个实现支持所有的 `WS-*` 规范。
- en: All the XML documents/document parts involved in the SOAP protocol are formally
    defined in XSD documents, which are special XML documents whose content provides
    a description of XML structures. Also, all your custom data structures (classes
    and interfaces in an object-oriented language) must be translated into XSD if
    they are going to be part of a SOAP envelope.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SOAP 协议中涉及的所有 XML 文档/文档部分都在 XSD 文档中正式定义，这些是特殊的 XML 文档，其内容提供了 XML 结构的描述。此外，如果您的自定义数据结构（面向对象语言中的类和接口）要成为
    SOAP 封装的一部分，它们必须被转换为 XSD。
- en: Each XSD specification has an associated `namespace` that identifies the specification
    and a physical location where it can be found. Both the namespace and the physical
    location are URIs. The location URI doesn't need to be publicly accessible if
    the web service is accessible just from within an intranet.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 XSD 规范都有一个相关的 `namespace`，用于标识规范及其物理位置，该位置可以找到它。命名空间和物理位置都是 URI。如果 Web 服务仅从内部网络访问，则位置
    URI 不需要公开访问。
- en: The whole definition of a service is an XSD specification that may contain references
    to other namespaces, that is, to other XSD documents. In a few words, all the
    messages of a SOAP communication must be defined in an XSD specification. Then,
    a server and a client can communicate if they refer to the same XSD specifications.
    This means, for instance, that you need to create a new XSD specification each
    time you add another field to a message. After that, you need to update all the
    XSD files that reference the old message definition to the new message definition
    by creating a new version of them. In turn, these modifications require the creation
    of other versions for other XSD files, and so on. Therefore, simple modifications
    that maintain compatibility with the previous behavior (clients could simply ignore
    the field that was added) may cause an exponential chain of version changes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的整个定义是一个可能包含对其他命名空间的引用的 XSD 规范，即对其他 XSD 文档的引用。简而言之，SOAP 通信的所有消息都必须在 XSD 规范中定义。然后，如果服务器和客户端引用相同的
    XSD 规范，它们就可以进行通信。这意味着，例如，每次您向消息添加另一个字段时，您都需要创建一个新的 XSD 规范。之后，您需要通过创建新版本来更新所有引用旧消息定义的
    XSD 文件到新消息定义。反过来，这些修改需要为其他 XSD 文件创建其他版本，依此类推。因此，保持与先前行为兼容的简单修改（客户端可以简单地忽略添加的字段）可能会导致版本变化的指数级链式反应。
- en: In the last few years, the difficulty in handling modifications, along with
    the complexity of handling the configuration of all the `WS-*` specifications
    and performance problems, caused a gradual move toward the simpler REST services
    that we will describe in the upcoming sections. This move started with services
    that were called from JavaScript due to the difficulty of implementing complete
    SOAP clients that were able to run efficiently in a web browser. Moreover, the
    complex SOAP machinery was oversized for the simple needs of the typical clients
    running in a browser and may have caused a complete waste of development time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，处理修改的难度，处理所有`WS-*`规范配置的复杂性以及性能问题，导致逐渐转向我们将在下一节中描述的更简单的REST服务。这一转变始于从JavaScript调用的服务，因为实现能够在网页浏览器中高效运行的完整SOAP客户端很困难。此外，复杂的SOAP机制对于典型在浏览器中运行的客户端的简单需求来说过大，可能导致了开发时间的完全浪费。
- en: Around 2018, services aimed at non-JavaScript clients started a massive move
    toward REST services, and nowadays the preferred choice is REST services, with
    SOAP being used either for compatibility with legacy systems or when features
    that aren't supported by REST services are needed. A typical application area
    that continues to prefer to SOAP system is that of payment/banking systems because
    these systems need transactional support that is offered by the `WS-Transaction` SOAP
    specification. There is no equivalent in the REST services world.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在2018年左右，针对非JavaScript客户端的服务开始大规模转向REST服务，如今首选的选择是REST服务，SOAP的使用要么是为了与遗留系统兼容，要么是在需要REST服务不支持的功能时。一个继续偏好SOAP系统的典型应用领域是支付/银行系统，因为这些系统需要由`WS-Transaction`
    SOAP规范提供的交易支持。在REST服务世界中没有等效的规范。
- en: REST web services
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST网络服务
- en: REST services were initially conceived to avoid the complex machinery of SOAP
    in simple cases such as calls to a service from the JavaScript code of a web page.
    Then, they gradually became the preferred choice for complex systems. REST services
    use HTTP to exchange data in JSON or, less commonly, in XML format. In a few words,
    they replace the SOAP body with the HTTP body, the SOAP header with the HTTP header,
    and the HTTP response code replaces the fault element and furnishes further auxiliary
    information on the operation that was performed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务最初是为了避免在简单情况下（例如从网页的JavaScript代码调用服务）使用SOAP的复杂机制而构思的。随后，它们逐渐成为复杂系统的首选选择。REST服务使用HTTP以JSON格式或较少情况下以XML格式交换数据。简而言之，它们用HTTP体替换了SOAP体，用HTTP头替换了SOAP头，HTTP响应代码取代了错误元素，并为执行的操作提供了进一步的辅助信息。
- en: 'The main reason for the success of REST services is that HTTP already offers
    most of SOAP''s features natively, which means we can avoid building a SOAP level
    on top of HTTP. Moreover, the whole HTTP machinery is simpler than SOAP: simpler
    to program, simpler to configure, and simpler to implement efficiently.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务成功的主要原因在于HTTP已经提供了SOAP的大部分功能，这意味着我们可以避免在HTTP之上构建SOAP层。此外，整个HTTP机制比SOAP简单：编程更简单，配置更简单，实现效率更高。
- en: Moreover, REST services impose fewer constraints on the clients. In particular,
    type compatibility between servers and clients conforms to the more flexible JavaScript
    type compatibility model because JSON is a subset of JavaScript. Moreover, when
    XML is used in place of JSON, it maintains the same JavaScript type compatibility
    rules. No XML namespaces need to be specified.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，REST服务对客户端的约束更少。特别是，服务器和客户端之间的类型兼容性符合更灵活的JavaScript类型兼容性模型，因为JSON是JavaScript的一个子集。此外，当使用XML代替JSON时，它保持相同的JavaScript类型兼容性规则。不需要指定XML命名空间。
- en: When using JSON and XML, if the server adds some more fields to the response
    while keeping the same semantic of all the other fields compatible with the previous
    client, they can simply ignore the new fields. Accordingly, changes that are made
    to a REST service definition only need to be propagated to previous clients in
    case of breaking changes that cause an actual incompatible behavior in the server.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JSON和XML时，如果服务器在保持所有其他字段与先前客户端兼容的相同语义的同时添加了一些额外的字段，它们可以简单地忽略这些新字段。因此，对REST服务定义所做的更改只有在发生破坏性变更并导致服务器实际不兼容行为的情况下才需要传播到先前客户端。
- en: Moreover, it is likely that changes are self-limited and do not result in an
    exponential chain of changes because type compatibility does not require the reference
    to a specific type to be defined in a unique shared place and simply requires
    that the shape of types is compatible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，变化可能是自我限制的，不会导致指数级的变化链，因为类型兼容性不需要在唯一共享的地方定义特定类型的引用，只需确保类型形状兼容即可。
- en: 'Let''s clarify the REST service''s type compatibility rules with an example.
    Let''s imagine that several services use a `Person` object that contains `Name`,
    `Surname`, and `Address` string fields:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来明确 REST 服务的类型兼容性规则。让我们设想有几个服务使用一个包含 `Name`、`Surname` 和 `Address` 字符串字段的
    `Person` 对象：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Type compatibility is ensured if the service and client refer to different
    copies of the preceding definition. It is also acceptable for the client to use
    a definition with fewer fields, since it can simply ignore all the other fields:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务和客户端引用的是前面定义的不同副本，则类型兼容性得到保证。客户端使用具有较少字段的定义也是可以接受的，因为它可以简单地忽略所有其他字段：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s say that a service, S1, that handles a `Persons` database, replaces
    the `Address` string with a complex object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设一个处理 `Persons` 数据库的服务，S1，将 `Address` 字符串替换为一个复杂对象：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let's say that a service, S2, takes `Persons` from S1 and adds it to the
    responses it returns on some of its methods. After the breaking change of S1,
    it can adapt its communication client that calls S1 to the new format. Then, it
    can convert the new `Person` format into the older one before using `Persons`
    in its responses. This way. S2 avoids propagating the breaking change of S1.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设一个服务，S2，从 S1 中获取 `Persons` 并将其添加到它返回的一些方法上的响应中。在 S1 的破坏性更改之后，它可以调整调用 S1
    的通信客户端以适应新格式。然后，它可以在使用 `Persons` 作为响应之前将新的 `Person` 格式转换为旧格式。这样，S2 就避免了传播 S1 的破坏性更改。
- en: In general, basing type compatibility on the object shape (tree of nested properties),
    instead of a reference to the same formal type definition, increases flexibility
    and modifiability. The price we pay for this increased flexibility is that type
    compatibility can't be computed automatically by comparing the formal definition
    of server and client interfaces. In fact, in absence of a univocal specification,
    each time a new version of the service is released, the developer must verify
    that the semantics of all the fields that the client and server have in common
    remain unchanged from the previous version. The basic idea behind REST services
    is to give up the severity checks and complex protocols for greater flexibility
    and simplicity, while SOAP does exactly the opposite.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，基于对象形状（嵌套属性的树）而不是对同一正式类型定义的引用来建立类型兼容性，这增加了灵活性和可修改性。我们为此增加的灵活性所付出的代价是，类型兼容性不能通过比较服务器和客户端接口的正式定义自动计算。事实上，在没有明确规范的情况下，每次发布新的服务版本时，开发者都必须验证客户端和服务器共有的所有字段的语义与上一个版本保持不变。REST
    服务的背后基本思想是放弃严重性检查和复杂协议，以获得更大的灵活性和简单性，而 SOAP 则恰恰相反。
- en: The REST services manifesto states that REST uses native HTTP features to implement
    all the required service features. So, for instance, authentication will be performed
    directly with the HTTP `Authorization` field, encryption will be achieved with
    HTTPS, exceptions will be handled with an HTTP error status code, and routing
    and reliable messaging will be handled by the machinery the HTTP protocol relies
    on. Addressing is achieved by using URLs to refer to services, their methods,
    and other resources.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: REST 服务宣言指出，REST 使用原生 HTTP 功能来实现所有必需的服务功能。例如，认证将通过 HTTP 的 `Authorization` 字段直接执行，加密将通过
    HTTPS 实现，异常将通过 HTTP 错误状态码处理，路由和可靠消息将通过 HTTP 协议依赖的机制处理。通过使用 URL 来引用服务、它们的方法和其他资源来实现寻址。
- en: There is no native support for asynchronous communication since HTTP is a synchronous
    protocol. There's also no native support for the Publisher/Subscriber pattern,
    but two services can interact with the Publisher/Subscriber pattern by each exposing
    an endpoint to the other. More specifically, the first service exposes a subscription
    endpoint, while the second one exposes an endpoint where it receives its notifications,
    which are authorized through a common secret that's exchanged during the subscription.
    This pattern is quite common. GitHub also allows us to send our REST services
    to repository events.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTTP是同步协议，因此没有对异步通信的原生支持。也没有对发布者/订阅者模式的原生支持，但两个服务可以通过每个向对方公开一个端点来与发布者/订阅者模式交互。更具体地说，第一个服务公开一个订阅端点，而第二个服务公开一个接收其通知的端点，这些通知通过在订阅期间交换的公共密钥进行授权。这种模式相当常见。GitHub还允许我们将我们的REST服务发送到存储库事件。
- en: REST services offer no easy options when it comes to implementing distributed
    transactions, which is why payment/banking systems still prefer SOAP. Luckily,
    most application areas don't need the strong form of consistency that's ensured
    by distributed transactions. For them, lighter forms of consistency, such as *eventual
    consistency*, are enough and are preferred for performance reasons. Please refer
    to [Chapter 7](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml), *How to Choose Your
    Data Storage in the Cloud*, for a discussion on the various types of consistencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务在实现分布式事务方面没有提供简单选项，这也是为什么支付/银行系统仍然更喜欢SOAP。幸运的是，大多数应用领域不需要分布式事务确保的强一致性形式。对于它们，更轻量级的一致性形式，如*最终一致性*，就足够了，并且出于性能原因更受欢迎。请参阅[第7章](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml)，*如何在云中选择您的数据存储*，以了解各种类型的一致性讨论。
- en: 'The REST manifesto not only prescribes the usage of the predefined solutions
    that are already available in HTTP but also the usage of a WEB-like semantic.
    More specifically, all the service operations must be conceived as CRUD operations
    on resources that are identified by URLs (the same resource may be identified
    by several URLs). In fact, REST is an acronym for **Representational State Transfer**,
    meaning that each URL is the representation of some sort of object. Each kind
    of service request needs to adopt the appropriate HTTP verb, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: REST宣言不仅规定了使用HTTP中已预定义的解决方案，还规定了使用类似WEB的语义。更具体地说，所有服务操作都必须被视为对由URL（同一资源可能由多个URL标识）标识的资源进行的CRUD操作。实际上，REST是**表示状态传输**的缩写，意味着每个URL都是某种对象的表示。每种类型的服务请求都需要采用适当的HTTP动词，如下所示：
- en: '`GET` (Read operation): The URL represents the resource that is returned by
    the read operation. Thus, `GET` operations mimic pointer dereferencing. In the
    case of a successful operation, a 200 (ok) status code is returned.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`（读取操作）：URL代表由读取操作返回的资源。因此，`GET`操作模拟指针解引用。在操作成功的情况下，返回一个200（ok）状态码。'
- en: '`POST` (Creation operation): The JSON/XML object that''s contained in the request
    body is added as a new resource to the object represented by the operation URL.
    If the new resource is successfully created immediately, a 201 (created) status
    code is returned, along with a response object that depends on the operation.
    The response object should contain the most specific URL that identifies the created
    resource. If creation is deferred to a later time, a 202 (accepted) status code
    is returned.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`（创建操作）：请求体中包含的JSON/XML对象被添加为操作URL所表示的对象的新资源。如果新资源立即成功创建，则返回一个201（created）状态码，以及一个依赖于操作的响应对象。响应对象应包含标识创建资源的最具体URL。如果创建被延迟到以后的时间，则返回一个202（accepted）状态码。'
- en: '`PUT`: The JSON/XML object contained in the request body replaces the object
    referenced by the request URL. In the case of successful operation, a 200 (ok)
    status code is returned. This operation is idempotent, meaning that repeating
    the same request twice causes the same modification.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：请求体中包含的JSON/XML对象替换由请求URL引用的对象。在操作成功的情况下，返回一个200（ok）状态码。此操作是幂等的，意味着重复相同的请求两次会产生相同的修改。'
- en: '`PATCH`: The JSON/XML object contained in the request body contains instructions
    on how to modify the object referenced by the request URL. This operation is not
    idempotent since the modification may be an increment of a numeric field. In the
    case of successful operation, a 200 (ok) status code is returned.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`: 请求体中包含的 JSON/XML 对象包含了如何修改由请求 URL 引用的对象的说明。由于修改可能是一个数值字段的增量，此操作不是幂等的。在操作成功的情况下，返回
    200 (ok) 状态码。'
- en: '`DELETE`: The resource referenced by the request URL is removed. In the case
    of successful operation, a 200 (ok) status code is returned.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`: 删除由请求 URL 引用的资源。在操作成功的情况下，返回 200 (ok) 状态码。'
- en: 'If the resource has been moved from the request URL to another URL, a redirect
    code is returned:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源已从请求 URL 移动到另一个 URL，则返回重定向代码：
- en: 301 (moved permanently), plus the new URL where we can find the resource
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 301 (永久移动)，以及我们可以找到资源的新的 URL
- en: 307 (moved temporarily), plus the new URL where we can find the resource
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 307 (临时移动)，以及我们可以找到资源的新的 URL
- en: 'If the operation fails, a status code that depends on the kind of failure is
    returned. Some examples of failures codes are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作失败，返回的状态码取决于失败的类型。以下是一些失败代码的示例：
- en: '400 (bad request): The request that was sent to the server is ill-formed.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 400 (错误请求)：发送给服务器的请求格式不正确。
- en: '404 (not found): When the request URL doesn''t refer to any known object.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 404 (未找到)：当请求 URL 不指向任何已知对象时。
- en: '405 (method not allowed): When the request verb is not supported by the resource
    referenced by the URL.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 405 (方法不允许)：当请求动词不支持由 URL 引用的资源时。
- en: '401 (unauthorized): The operation requires authentication, but the client has
    not furnished any valid authorization header.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 401 (未授权)：操作需要认证，但客户端没有提供任何有效的授权头。
- en: '403 (forbidden): The client is correctly authenticated but has no right to
    perform the operation.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 403 (禁止)：客户端已正确认证，但没有执行操作的权限。
- en: The preceding list of status codes is not exhaustive. References to an exhaustive
    list will be provided in the *Further reading* section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的状态码列表并不完整。在 *进一步阅读* 部分将提供完整的列表引用。
- en: It is fundamental to point out that `POST`/`PUT`/`PATCH`/`DELETE` operations
    may have – and usually have – side effects on other resources. Otherwise, it would
    be impossible to code operations that act simultaneously on several resources.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，`POST`/`PUT`/`PATCH`/`DELETE` 操作可能对其他资源有副作用——通常是这样。否则，将无法编写同时作用于多个资源的操作。
- en: In other words, the HTTP verb must conform with the operation that's performed
    on the resource and referenced by the request URL, but the operation might affect
    other resources. The same operation might be performed with a different HTTP verb
    on one of the other involved resources. It is the developer's responsibility to
    choose which way to perform the same operation in order to implement it in the
    service interface.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，HTTP 动词必须符合由请求 URL 引用的操作，但该操作可能影响其他资源。相同的操作可能使用不同的 HTTP 动词在另一个涉及的资源上执行。开发者有责任选择以哪种方式执行相同的操作，以便在服务接口中实现它。
- en: Thanks to the side effects of HTTP verbs, REST services are able to encode all
    of these operations as CRUD operations on resources represented by URLs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 HTTP 动词的副作用，REST 服务能够将这些操作编码为对由 URL 表示的资源进行的 CRUD 操作。
- en: Often, moving an existing service to REST requires us to split the various inputs
    between the request URL and the request body. More specifically, we extract the
    input fields that univocally define one of the objects involved in the method's
    execution and use them to create a URL that univocally identifies that object.
    Then, we decide on which HTTP verb to use based on the operation that's performed
    on the selected object. Finally, we place the remainder of the input in the request
    body.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将现有服务迁移到 REST 需要我们在请求 URL 和请求体之间分割各种输入。更具体地说，我们提取那些唯一定义方法执行中涉及的某个对象的输入字段，并使用它们创建一个唯一标识该对象的
    URL。然后，我们根据对所选对象执行的操作来决定使用哪个 HTTP 动词。最后，我们将输入的其余部分放在请求体中。
- en: If our services were designed with an object-oriented architecture focused on
    the business domain objects (such as DDD, as described in [Chapter 10](2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml),
    *Understanding the Different Domains in Software Solutions*), the REST translation
    of all the service methods should be quite immediate, since services should already be
    organized around domain resources. Otherwise, moving to REST might require some
    service interface redefinitions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的服务是以面向对象架构设计的，该架构专注于业务域对象（例如，如第 10 章所述的 DDD，*理解软件解决方案中的不同域*），那么所有服务方法的
    REST 转换应该相当直接，因为服务应该已经围绕域资源组织。否则，迁移到 REST 可能需要重新定义一些服务接口。
- en: The adoption of full REST semantics has the advantage that services can be extended
    with or without small modifications being made to the preexisting operation definitions.
    In fact, extensions should mainly manifest as additional properties of some objects
    and as additional resources URLs with some associated operations. Therefore, preexisting
    clients can simply ignore them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 采用完整的 REST 语义的优点是，服务可以在不修改现有操作定义的情况下进行扩展，也可以在修改现有操作定义的情况下进行扩展。实际上，扩展应主要表现为某些对象的一些附加属性以及一些相关操作的附加资源
    URL。因此，现有的客户端可以简单地忽略它们。
- en: 'Now, let''s learn how methods can be expressed in the REST language with a
    simple example of an intra-bank money transfer. A bank account can be represented
    by an URL, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个银行内部资金转账的简单示例来学习如何在 REST 语言中表达方法。一个银行账户可以表示为一个 URL，如下所示：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A transfer might be represented as a PATCH request whose body contains an object
    with properties representing the amount of money, time of transfer, description,
    and the account receiving the money. The operation modifies the account mentioned
    in the URL, but also the receiving account as a *side effect*. If the account
    has not enough money, a 403 (Forbidden) status code is returned, along with an
    object with all the error details (an error description, the available funds,
    and so on).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 转账可能表示为一个包含表示金额、转账时间、描述和接收资金的账户的对象的 PATCH 请求。该操作修改了 URL 中提到的账户，但也作为 *副作用* 修改了接收账户。如果账户资金不足，将返回
    403（禁止）状态码，以及包含所有错误详情的对象（错误描述、可用资金等）。
- en: 'However, since all the bank operations are recorded in the account statement,
    the creation and addition of a new transfer object for a *bank account operations* collection
    associated with the bank account is a better way to represent the transfer. In
    this case, the URL might be something like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于所有银行操作都记录在账户报表中，因此为与银行账户关联的 *银行账户操作* 集合创建和添加一个新的转账对象是表示转账的更好方式。在这种情况下，URL
    可能如下所示：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the HTTP verb is `POST` since we are creating a new object. The body content
    is exactly the same and a 403 status code is returned in case there's a lack of
    funds.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，HTTP 动词是 `POST`，因为我们正在创建一个新的对象。正文内容完全相同，如果资金不足，将返回 403 状态码。
- en: Both representations of the transfer cause exactly the same changes in the database.
    Moreover, once the inputs are extracted from the different URLs and from the possibly
    different request bodies, the subsequent processing is exactly the same. In both
    cases, we have exactly the same inputs and the same processing – it's just the
    exterior appearance of the two requests that's different.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 传输的这两种表示在数据库中引起完全相同的变化。此外，一旦从不同的 URL 和可能不同的请求体中提取了输入，后续的处理方式完全相同。在两种情况下，我们都有完全相同的输入和相同的处理过程——只是两个请求的外部外观不同。
- en: 'However, the introduction of the virtual *operations* collection allows us
    to extend the service with several more operations collection-specific methods.
    It is worth pointing out that the operations collection doesn''t need to be connected
    with a database table or with any physical object: it lives in the world of URLs
    and creates a convenient way for us to model the transfer.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虚拟 *操作* 集合的引入使我们能够通过几个更多特定于操作集合的方法来扩展服务。值得注意的是，操作集合不需要与数据库表或任何物理对象连接：它存在于
    URL 的世界中，为我们创建了一种方便的方式来模拟传输。
- en: The increased usage of REST services leads to a description of REST service
    interfaces to be created, similar to the ones developed for SOAP. This standard
    is called **OpenAPI**. We will talk about this in the following subsection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务的使用增加导致需要创建REST服务接口的描述，类似于为SOAP开发的那些。这个标准被称为**OpenAPI**。我们将在下一个子节中讨论这个问题。
- en: The OpenAPI standard
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenAPI标准
- en: OpenAPI is a standard that's used for describing the REST API. It is currently
    version 3\. The whole service is described by a JSON endpoint, that is, an endpoint
    that describes the service with a JSON object. This JSON object has a general
    section that applies to the whole service and contains the general features of
    the services, such as its version and description, as well as shared definitions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI是一个用于描述REST API的标准。它目前是第3版。整个服务由一个JSON端点描述，即一个用JSON对象描述服务的端点。这个JSON对象有一个通用部分，适用于整个服务，并包含服务的一般特性，如其版本和描述，以及共享定义。
- en: Then, each service endpoint has a specific section that describes the endpoint
    URL or URL format (in case some inputs are included in the URL), all its inputs,
    all the possible output types and status codes, and all the authorization protocols.
    Each endpoint-specific section can reference the definitions contained in the
    general section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个服务端点都有一个特定的部分，描述端点URL或URL格式（如果某些输入包含在URL中），所有输入，所有可能的输出类型和状态码，以及所有授权协议。每个端点特定的部分可以引用通用部分中包含的定义。
- en: A description of the OpenAPI syntax is out of the scope of this book, but references
    are provided in the *Further reading* section. Various development frameworks
    automatically generate OpenAPI documentation by processing the REST API code and
    further information is provided by the developer, so your team doesn't need to
    have in-depth knowledge of OpenAPI syntax.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI语法的描述超出了本书的范围，但在*进一步阅读*部分提供了参考。各种开发框架通过处理REST API代码和提供更多信息来自动生成OpenAPI文档，因此您的团队不需要深入了解OpenAPI语法。
- en: The *How does .NET Core deal with SOA?* section explains how we can generate
    automatically OpenAPI documentation in ASP.NET Core REST API projects, while the
    use case at the end of this chapter provides a practical example of its usage.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*“.NET Core如何处理SOA？”*这一节解释了如何在ASP.NET Core REST API项目中自动生成OpenAPI文档，而本章末尾的使用案例提供了一个其实际应用的实例。'
- en: We will end this subsection by talking about how to handle authentication and
    authorization in REST services.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个子节的最后讨论如何在REST服务中处理认证和授权。
- en: REST services authorization and authentication
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST服务的授权和认证
- en: 'Since REST services are sessionless, when authentication is required, the client
    must send an authentication token in every single request. That token is usually
    placed in the HTTP authorization header, but this depends on the type of authentication
    protocol you''re using. The simplest way to authenticate is through the explicit
    transmission of a shared secret. This can be done with the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于REST服务是无状态的，当需要认证时，客户端必须在每个请求中发送一个认证令牌。这个令牌通常放在HTTP认证头中，但这取决于你使用的认证协议类型。最简单的认证方式是通过显式传输共享密钥。这可以通过以下代码实现：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The shared secret is called an API key. Since, at the time of writing, there
    is no standard on how to send it, API keys can also be sent in other headers,
    as shown in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 共享密钥被称为API密钥。由于在撰写本文时，尚无关于如何发送它的标准，API密钥也可以在其他头中发送，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Needless to say, API key-based authentication needs HTTPS to stop shared secrets
    from being stolen. API keys are very simple to use, but they do not convey information
    about user authorizations, so they can be adopted when the operations allowed
    by the client are quite standard and there are no complex authorization patterns.
    Moreover, when exchanged in requests, API keys are susceptible to being attacked
    on the server or client side.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，基于API密钥的认证需要HTTPS来防止共享密钥被盗。API密钥非常易于使用，但它们不传达有关用户授权的信息，因此可以在客户端允许的操作相当标准且没有复杂授权模式的情况下采用。此外，当在请求中交换时，API密钥容易在服务器或客户端端受到攻击。
- en: Safer techniques use shared secrets that are valid for a long period of time,
    just by the user logging in. Then, the login returns a short-life token that is
    used as a shared secret in all the subsequent requests. When the short-life secret
    is going to expire, it can be renewed with a call to a renew endpoint.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 更安全的技巧使用有效的长期共享密钥，只需用户登录即可。然后，登录返回一个短期令牌，该令牌在所有后续请求中用作共享密钥。当短期密钥即将到期时，可以通过调用续订端点来更新它。
- en: The whole login logic is completely decoupled from the short-life token-based
    authorization logic. The login is usually based on login endpoints that receive
    long-term credentials and returns short-life tokens. Login credentials are either
    usual username-password pairs that are passed as input to the login method or
    other kinds of authorization tokens that are converted into short-life tokens
    that are served by the login endpoint. Login can also be achieved with various
    authentication protocols based on X.509 certificates.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 整个登录逻辑与基于短期令牌的授权逻辑完全解耦。登录通常基于接收长期凭证并返回短期令牌的登录端点。登录凭证可以是作为登录方法输入的常规用户名-密码对，或者可以转换为由登录端点提供的短期令牌的其他类型的授权令牌。登录还可以通过基于X.509证书的各种身份验证协议实现。
- en: The most widespread short-life token type is the so-called bearer token. Each
    bearer token encodes information about how long it lasts and a list of assertions,
    called claims, that can be used for authorization purposes. Bearer tokens are
    returned by either login operations or renewal operations. Their characteristic
    feature is that they are not tied to the client that receives them or to any other
    specific client.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的短期令牌类型是所谓的载体令牌。每个载体令牌都编码了有关其持续时间的详细信息以及用于授权目的的声明列表，称为声明。载体令牌由登录操作或续订操作返回。它们的特征是它们与接收它们的客户端或任何其他特定客户端无关。
- en: No matter how a client gets a bearer token, this is all a client needs to be
    granted all the rights implied by its claims. It is enough to transfer a bearer
    token to another client to empower that client with all rights implied by all
    the bearer token claims, since no proof of identity is required by bearer token-based
    authorization.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无论客户端如何获得载体令牌，这都是客户端需要授予其声明的所有隐含权利的全部。只需将载体令牌转移到另一个客户端，就可以赋予该客户端所有由载体令牌声明隐含的权利，因为基于载体令牌的授权不需要身份证明。
- en: Therefore, once a client gets a bearer token, it can delegate some operations
    to third parties by transferring its bearer token to them. Typically, when a bearer
    token must be used for delegation, during the login phase, the client specifies the
    claims to include in order to restrict what operations can be authorized by the
    token.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦客户端获得一个载体令牌，它可以通过将其载体令牌转移给第三方来委托一些操作。通常，当必须使用载体令牌进行委托时，在登录阶段，客户端会指定要包含的声明以限制令牌可以授权的操作。
- en: 'Compared to API key authentication, bearer token-based authentication is disciplined
    by standards. In particular, they must use the following `Authorization` header:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与API密钥身份验证相比，基于载体令牌的身份验证受到标准的约束。特别是，它们必须使用以下`Authorization`头部：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Bearer tokens can be implemented in several ways. REST services typically use
    JWT tokens that are strung with a Base64URL encoding of JSON objects. More specifically,
    JWT creation starts with a JSON header, as well as a JSON payload. The JSON header
    specifies the kind of token and how it is signed, while the payload consists of
    a JSON object that contains all the claims as property/value pairs. The following
    is an example header:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 载体令牌可以以多种方式实现。REST服务通常使用JWT令牌，这些令牌是用JSON对象的Base64URL编码连接起来的。更具体地说，JWT的创建从JSON头部开始，以及一个JSON有效负载。JSON头部指定了令牌的类型及其签名方式，而有效负载由一个包含所有声明作为属性/值对的JSON对象组成。以下是一个示例头部：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is an example payload:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例有效负载：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, the header and payload are BASE64URL-encoded and the corresponding string
    is concatenated, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将头部和有效负载进行BASE64URL编码，并将相应的字符串连接，如下所示：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding string is then signed with the algorithm specified in the header,
    which, in our example, is RSA +SHA256, and the signature string is concatenated
    with the original string as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用头部中指定的算法对前面的字符串进行签名，在我们的例子中是RSA + SHA256，然后将签名字符串与原始字符串连接，如下所示：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code is the final bearer token string. A symmetric signature can
    be used instead of RSA, but, in this case, both the JWT issuer and all the services
    using it for authorization must share a common secret, while, with RSA, the private
    key of the JWT issuer doesn't need to be shared with anyone, since the signature
    can be verified with just the issuer public key.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是最终的载体令牌字符串。可以使用对称签名代替RSA，但在此情况下，JWT发行者和所有使用它进行授权的服务必须共享一个共同的秘密，而使用RSA时，JWT发行者的私钥无需与任何人共享，因为可以使用发行者的公钥来验证签名。
- en: 'Some payload properties are standard, such as the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有效载荷属性是标准的，例如以下内容：
- en: '`iss`: Issuer of the JWT.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iss`：JWT的发行者。'
- en: '`aud`: The audience, that is, the services and/or operations that can use the
    token for authorization. If a service doesn''t see its identifier within this
    list, it should reject the token.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aud`：受众，即可以使用令牌进行授权的服务和/或操作。如果服务没有看到其标识符在此列表中，则应拒绝该令牌。'
- en: '`sub`: A string that identifies the *principal* (that is, the user) to which
    the JWT was issued.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub`：一个字符串，用于标识JWT发行的*主体*（即用户）。'
- en: '`iat`, `exp`, and `nbf`: These are for the time the JWT was issued, its expiration
    time, and, if set, the time after which the token is valid, respectively. All
    the times are expressed as a number of seconds from the 1st of January 1970 midnight
    UTC. Here, all the days are considered as having exactly 86,400 seconds in them.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iat`、`exp`和`nbf`：这些分别表示JWT发行的时间、过期时间和，如果设置，令牌有效的起始时间。所有时间都以自1970年1月1日午夜UTC以来的秒数表示。在这里，所有天都被认为是包含86,400秒。'
- en: Other claims may be defined as public if we represent them with a unique URI;
    otherwise, they are considered private to the issuer and to the services known
    to the issuer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 其他声明可能如果用唯一的URI表示，则可以定义为公共的；否则，它们被认为是发行者及其已知服务的私有。
- en: How does .NET Core deal with SOA?
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core是如何处理SOA的？
- en: .Net Core has excellent support for REST services through ASP.NET Core. In terms
    of SOAP services, classic .NET handles them with WCF technology. In WCF, service
    specifications are defined through .NET interfaces and the actual service code
    is supplied in classes that implement those interfaces.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: .Net Core通过ASP.NET Core对REST服务有出色的支持。在SOAP服务方面，经典.NET使用WCF技术处理。在WCF中，服务规范通过.NET接口定义，实际服务代码由实现这些接口的类提供。
- en: Endpoints, underlying protocols (HTTP and TCP/IP), and any other features are
    defined in a configuration file. In turn, the configuration file can be edited
    with an easy to use configuration tool. Therefore, the developer is responsible
    for providing just the service behavior as a standard .NET class and for configuring
    all the service features in a declarative way. This way, the service configuration
    is completely decoupled from the actual service behavior and each service can
    be reconfigured so that it can be adapted to a different environment without the
    need to modify its code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 端点、底层协议（HTTP和TCP/IP）以及任何其他功能都在配置文件中定义。反过来，配置文件可以使用易于使用的配置工具进行编辑。因此，开发者只需提供标准.NET类中的服务行为，并以声明性方式配置所有服务功能。这样，服务配置与实际服务行为完全解耦，每个服务都可以重新配置，以便能够适应不同的环境，而无需修改其代码。
- en: WCF technology has not been ported to .NET Core and there are no plans to perform
    a complete port of it. Instead, Microsoft is investing in gRPC, Google's open
    source technology.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: WCF技术尚未移植到.NET Core，也没有计划进行完整的移植。相反，微软正在投资于gRPC，这是谷歌的开源技术。
- en: 'The main reasons behind the decision to abandon WCF in .NET core are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃在.NET Core中使用WCF的主要原因是如下：
- en: As we've already discussed, SOAP technology has been overtaken by REST technology
    in most application areas.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，在大多数应用领域，SOAP技术已经被REST技术所取代。
- en: WCF technology is strictly tied to Windows, so it would be very expensive to
    reimplement all its features from scratch in .NET Core. Since support for classic
    .NET will continue, users that need WCF can still rely on classic .NET.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WCF技术与Windows紧密绑定，因此在.NET Core中从头开始重新实现所有功能将非常昂贵。由于对经典.NET的支持将继续，需要WCF的用户仍然可以依赖经典.NET。
- en: As a general strategy, with .NET Core, Microsoft prefers investing in open source
    technologies that can be shared with other competitors. That's why, instead of
    investing in WCF, Microsoft provided a gRPC implementation starting from .NET
    Core 3.0.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一种一般策略，使用 .NET Core，微软更倾向于投资可以与其他竞争对手共享的开源技术。这就是为什么，而不是投资于 WCF，微软从 .NET Core
    3.0 开始提供了 gRPC 实现。
- en: While .NET Core doesn't support SOAP technology, it does support SOAP clients.
    More specifically, it is quite easy to create a SOAP service proxy for an existing
    SOAP service in Visual Studio, starting from the 2017 version (please refer to
    [Chapter 9](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml), *Design Patterns and
    .NET Core Implementation*, for a discussion of what a proxy is and of the proxy
    pattern). In the case of services, a proxy is a class that implements the service
    interface and whose methods perform their job by calling the analogous methods
    of the remote service.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 .NET Core 不支持 SOAP 技术，但它支持 SOAP 客户端。更具体地说，从 2017 版本开始，在 Visual Studio 中创建现有
    SOAP 服务的 SOAP 服务代理相当容易（请参阅 [第 9 章](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml)，*设计模式和
    .NET Core 实现*，以讨论代理是什么以及代理模式）。在服务的情况下，代理是一个实现服务接口的类，其方法通过调用远程服务的类似方法来完成其工作。
- en: To create a service proxy, right-click on the *connected services* node in Visual
    Studio, go to Solution Explores, and then select Add connected service. Then,
    in the form that appears, select Microsoft WCF Service Reference Provider. Here,
    you can specify the URL of the service (where the WSDL service description is
    contained), the namespace where you wish to add the proxy class, and much more.
    At the end of the wizard, Visual Studio automatically adds all the necessary NuGet
    packages and scaffolds the proxy class. This is enough to create an instance of
    this class and to call its methods so that we can interact with the remote SOAP
    service.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个服务代理，请在 Visual Studio 中右键单击 *已连接的服务* 节点，转到解决方案资源管理器，然后选择添加连接服务。然后，在出现的表单中，选择
    Microsoft WCF 服务引用提供程序。在这里，您可以指定服务的 URL（其中包含 WSDL 服务描述），您希望添加代理类的命名空间，以及更多内容。在向导的末尾，Visual
    Studio 自动添加所有必要的 NuGet 包并生成代理类。这足以创建此类的一个实例并调用其方法，以便我们可以与远程 SOAP 服务进行交互。
- en: There are also third parties, such as NuGet packages that provide limited support
    for SOAP services, but at the moment, they aren't very useful, since such limited
    support does not include features that aren't available in REST services.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些第三方，例如 NuGet 包，为 SOAP 服务提供有限的支持，但截至目前，它们并不非常有用，因为这种有限的支持不包括 REST 服务中不可用的功能。
- en: Starting from .NET Core SDK, Visual Studio 2019 supports the gRPC project template,
    which scaffolds both a gRPC server and a gRPC client. At the time of writing, gRPC
    is not a standard and just a Google open source project. However, if both Microsoft
    and Google continue investing in it, it might become a de facto standard. gRPC
    implements a remote procedure call pattern that offers both synchronous and asynchronous
    calls.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET Core SDK 开始，Visual Studio 2019 支持 gRPC 项目模板，该模板生成 gRPC 服务器和 gRPC 客户端。在撰写本文时，gRPC
    不是一个标准，而只是一个 Google 开源项目。然而，如果微软和谷歌继续投资其中，它可能会成为事实上的标准。gRPC 实现了一个远程过程调用模式，它提供了同步和异步调用。
- en: It is configured in a way that is similar to WCF and to .NET remoting, as we
    described at the end of [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*. That is, services
    are defined through interfaces and their code is provided in classes that implement
    those interfaces, while clients interact with those services through proxies that
    implement the same service interfaces.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它的配置方式类似于 WCF 和 .NET 远程处理，正如我们在 [第 5 章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)
    的结尾所描述的，*将微服务架构应用于您的企业应用程序*。也就是说，服务通过接口定义，其代码在实现这些接口的类中提供，而客户端通过实现相同服务接口的代理与这些服务进行交互。
- en: gRPC is a good option for internal communications within a microservices cluster,
    especially if the cluster is not fully based on Service Fabric technology and
    can't rely on .NET remoting. Since there are gRPC libraries for all the main languages
    and development frameworks, it can be used in Kubernetes-based clusters, as well
    as in Service Fabric clusters that host Docker images that have been implemented
    in other frameworks.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 是微服务集群内部通信的良好选择，特别是如果集群不是完全基于 Service Fabric 技术且不能依赖 .NET 远程通信。由于所有主要语言和开发框架都有
    gRPC 库，因此它可以在基于 Kubernetes 的集群中使用，也可以在托管其他框架实现的 Docker 镜像的 Service Fabric 集群中使用。
- en: gRPC is more efficient than the REST services protocol due to its more compact
    representation of data and it being easier to use, since everything to do with
    the protocol is taken care of by the development framework. However, at the time
    of writing, none of its features rely on well-established standards, so it can't
    be used for publicly exposed endpoints – it can only be used for intra-cluster
    communication. For this reason, we will not describe gRPC in detail, but the *Further
    reading* section of this chapter contains references to both gRPC in general and
    to its .NET Core implementation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 gRPC 对数据的紧凑表示以及使用起来更简单，因此它比 REST 服务协议更高效，因为与协议相关的一切都由开发框架处理。然而，在撰写本文时，它的所有功能都不依赖于已建立的标准，因此不能用于公开端点
    – 它只能用于集群内部通信。因此，我们将不会详细介绍 gRPC，但本章的 *进一步阅读* 部分包含了对 gRPC 的一般介绍及其 .NET Core 实现的参考。
- en: Using gRPC is super easy since Visual Studio's gRPC project template scaffolds
    everything so that the gRPC service and its clients are working. The developer
    just needs to define the application-specific C# service interface and a class
    that implements it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 gRPC 非常简单，因为 Visual Studio 的 gRPC 项目模板会自动搭建一切，使得 gRPC 服务及其客户端都能正常工作。开发者只需定义应用程序特定的
    C# 服务接口及其实现类。
- en: The remainder of the section is dedicated to .NET Core support for REST services
    from both the server and client-side.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本节剩余部分致力于介绍 .NET Core 对 REST 服务的服务器端和客户端支持。
- en: A short introduction to ASP.NET Core
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 简介短文
- en: 'ASP.NET Core applications are .NET Core applications based on the *Host* concept
    we described in the *Using generic hosts* subsection of [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*. The `program.cs` file
    of each ASP.NET application creates a Host, builds it, and runs it with the following
    code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 应用程序是基于我们在第 5 章 *将微服务架构应用于您的企业应用程序* 的 *使用通用宿主* 子节中描述的 *Host* 概念的
    .NET Core 应用程序。每个 ASP.NET 应用程序的 `program.cs` 文件创建一个宿主，构建它，并使用以下代码运行它：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`CreatesDefaultBuilder` sets up a standard Host, while `ConfigureWebHostDefaults` configures
    it so that it can handle an HTTP pipeline. More specifically, it does the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreatesDefaultBuilder` 设置了一个标准的宿主，而 `ConfigureWebHostDefaults` 则配置它以处理 HTTP
    管道。更具体地说，它执行以下操作：'
- en: It sets the `ContentRootPath` property of the `IHostingEnvironment` interface
    for the current directory.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它设置了 `IHostingEnvironment` 接口的 `ContentRootPath` 属性为当前目录。
- en: 'It loads the configuration information from `appsettings.json` and `appsettings.[EnvironmentName].json`.
    Once loaded, the configuration information contained in the JSON object properties
    can be mapped to .NET Object properties with the ASP.NET Core options framework.
    More specifically, `appsettings.json` and `appsettings.[EnvironmentName].json`
    are merged and the `appsettings.[EnvironmentName]` file''s environment-specific
    information overrides the corresponding `appsettings.json` settings. `EnvironmentName`
    is taken from the `ASPNETCORE_ENVIRONMENT` environment variable. In turn, `ASPNETCORE_ENVIRONMENT`
    is defined in the `Properties\launchSettings.json` file when the application is
    run in Visual Studio. The following screenshot shows where you can find `launchSettings.json`
    in Visual Studio Solution Explorer:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从 `appsettings.json` 和 `appsettings.[EnvironmentName].json` 加载配置信息。一旦加载，JSON
    对象属性中包含的配置信息可以使用 ASP.NET Core 选项框架映射到 .NET 对象属性。更具体地说，`appsettings.json` 和 `appsettings.[EnvironmentName].json`
    被合并，`appsettings.[EnvironmentName]` 文件的环境特定信息覆盖了相应的 `appsettings.json` 设置。`EnvironmentName`
    从 `ASPNETCORE_ENVIRONMENT` 环境变量中获取。反过来，当应用程序在 Visual Studio 中运行时，`ASPNETCORE_ENVIRONMENT`
    在 `Properties\launchSettings.json` 文件中定义。以下截图显示了在 Visual Studio 解决方案资源管理器中可以找到
    `launchSettings.json` 的位置：
- en: '![](img/e1030042-bb95-469a-9421-648443cea65e.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/e1030042-bb95-469a-9421-648443cea65e.png)'
- en: 'In `launchSettings.json`, you can define several environments that can be selected
    with the dropdown next to Visual Studio''s run button ![](img/27ad6b8b-7341-4dcd-a1bb-20ce544816c4.png).
    By default, the IIS Express setting sets `ASPNETCORE_ENVIRONMENT` to `Development`. The
    following is a typical `launchSettings.json` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `launchSettings.json` 文件中，您可以定义多个环境，这些环境可以通过Visual Studio运行按钮旁边的下拉菜单进行选择 ![图片](img/27ad6b8b-7341-4dcd-a1bb-20ce544816c4.png)。默认情况下，IIS
    Express 设置将 `ASPNETCORE_ENVIRONMENT` 设置为 `Development`。以下是一个典型的 `launchSettings.json`
    文件：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The value to use for `ASPNETCORE_ENVIRONMENT` when the application is published
    can be added to the published XML file after it has been created by Visual Studio.
    This value is `<EnvironmentName>Staging</EnvironmentName>`. It can be also specified
    in your Visual Studio ASP.NET Core project file (`.csproj`):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序发布时，用于 `ASPNETCORE_ENVIRONMENT` 的值可以在 Visual Studio 创建后添加到已创建的发布 XML 文件中。此值为
    `<EnvironmentName>Staging</EnvironmentName>`。它也可以在您的 Visual Studio ASP.NET Core
    项目文件（`.csproj`）中指定：
- en: '`<PropertyGroup> <EnvironmentName>Staging</EnvironmentName></PropertyGroup>`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`<PropertyGroup> <EnvironmentName>Staging</EnvironmentName></PropertyGroup>`.'
- en: It configures Host logging so that it can write to the console and debug output.
    This setting can be changed with further configuration.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它配置了主机日志记录，以便它可以写入控制台和调试输出。此设置可以通过进一步的配置进行更改。
- en: It sets up/connects a web server to the ASP.NET Core pipeline.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它设置/连接一个网络服务器到 ASP.NET Core 管道。
- en: 'When the application runs in Linux, the ASP.NET Core pipeline connects to the
    .NET Core Kestrel web server. Since Kestrel is a minimal web server, you are responsible
    for reverse proxying requests to it from a complete web server, such as Apache
    or Nginx, that adds features that Kestrel doesn''t have. When the application
    runs in Windows, by default, `ConfigureWebHostDefaults` connects the ASP.NET Core
    pipeline directly to **Internet Information Services** (**IIS**). However, you
    can also use Kestrel in Windows and you can reverse proxy IIS requests to Kestrel
    by changing the `AspNetCoreHostingModel` setting of your Visual Studio project
    file like so:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在 Linux 上运行时，ASP.NET Core 管道连接到 .NET Core Kestrel 网络服务器。由于 Kestrel 是一个最小化的网络服务器，您需要负责从具有
    Kestrel 所不具备的功能的完整网络服务器（如 Apache 或 Nginx）反向代理请求到它。当应用程序在 Windows 上运行时，默认情况下，`ConfigureWebHostDefaults`
    将 ASP.NET Core 管道直接连接到 **互联网信息服务**（**IIS**）。但是，您也可以在 Windows 上使用 Kestrel，并且可以通过更改
    Visual Studio 项目文件的 `AspNetCoreHostingModel` 设置来反向代理 IIS 请求到 Kestrel，如下所示：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`UseStartup<Startup>()` lets Host services (see the *Using generic hosts* subsection
    in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying a Microservice
    Architecture to Your Enterprise Application*) and the definition of the ASP.NET
    Core pipeline be taken from the methods of the project''s `Startup.cs` class.
    More specifically, services are defined in its `ConfigureServices(IServiceCollection
    services)` method, while the ASP.NET Core pipeline is defined in the `Configure`
    method. The following code shows the standard `Configure` method scaffolded with
    an API REST project:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseStartup<Startup>()` 允许从项目的 `Startup.cs` 类的方法中获取 Host 服务（参见第 5 章 [49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml]
    中的 *使用通用主机* 子节，*将微服务架构应用于您的企业应用程序*）和 ASP.NET Core 管道的定义。更具体地说，服务在它的 `ConfigureServices(IServiceCollection
    services)` 方法中定义，而 ASP.NET Core 管道在 `Configure` 方法中定义。以下代码显示了使用 API REST 项目生成的标准
    `Configure` 方法框架：'
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each module in the pipeline is defined by an `app.Use<something>` method, which
    often accepts some options. Each module processes the requests and then either
    forwards the modified request to the next module in the pipeline or returns an
    HTTP response. When an HTTP response is returned, it is processed by all the previous
    modules in reverse order.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中的每个模块都由一个 `app.Use<something>` 方法定义，该方法通常接受一些选项。每个模块处理请求，然后将修改后的请求转发到管道中的下一个模块，或者返回一个
    HTTP 响应。当返回 HTTP 响应时，它将按相反的顺序由所有之前的模块处理。
- en: Modules are inserted in the pipeline in the order they are defined by the `app.Use<something>`
    method calls. The preceding code adds an error page if `ASPNETCORE_ENVIRONMENT`
    is `Development`; otherwise, `UseHsts` negotiates a security protocol with the
    client. Finally, `UseEndpoints` adds the MVC controllers that create the actual
    HTTP response. A complete description of the ASP.NET Core pipeline will be given
    in the *Understanding the presentation layers of web applications* section of
    [Chapter 13](003ee8cb-5995-4364-8772-73d73df29cf8.xhtml), *Presenting ASP.NET
    Core MVC*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 模块按照 `app.Use<something>` 方法调用中定义的顺序插入到管道中。前面的代码在 `ASPNETCORE_ENVIRONMENT` 为
    `Development` 时添加错误页面；否则，`UseHsts` 与客户端协商一个安全协议。最后，`UseEndpoints` 添加创建实际 HTTP
    响应的 MVC 控制器。关于 ASP.NET Core 管道的完整描述将在第 13 章 *理解 Web 应用程序的表示层* 节中给出，*展示 ASP.NET
    Core MVC*。
- en: In the next subsection, we will explain how the MVC framework lets you implement
    REST services.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将解释 MVC 框架如何让您实现 REST 服务。
- en: Implementing REST services with ASP.NET Core
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core 实现 REST 服务
- en: In the MVC framework, HTTP requests are processed by classes called Controllers.
    Each request is mapped to the call of a Controller public method. The selected
    controller and controller methods depend on the shape of the request path, and
    they are defined by routing rules, that, for the REST API, are usually provided
    through attributes associated with both the Controller class and its methods.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVC 框架中，HTTP 请求由称为控制器的类处理。每个请求都映射到控制器公共方法的调用。选定的控制器和控制器方法取决于请求路径的形状，并且由路由规则定义，对于
    REST API，通常通过与控制器类及其方法关联的属性提供。
- en: Controller methods that process HTTP requests are called action methods. When
    the controller and action methods are selected, the MVC framework creates a controller
    instance to serve the request. All the parameters of the controller constructors
    are resolved with dependency injection with types defined in the `ConfigureServices`
    method of the `Startup.cs` class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 HTTP 请求的控制器方法被称为操作方法。当选择控制器和操作方法时，MVC 框架会创建一个控制器实例来处理请求。控制器构造函数的所有参数都通过依赖注入与在
    `Startup.cs` 类的 `ConfigureServices` 方法中定义的类型进行解析。
- en: Please refer to the *Using generic hosts* subsection of [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*, for a description
    of how to use dependency injection with .NET Core Hosts, and to the *Dependency
    injection pattern* subsection of [Chapter 10](2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml),
    *Understanding the Different Domains in Software Solutions*, for a general discussion
    of dependency injection.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅第 5 章 *将微服务架构应用于您的企业应用程序* 的 *使用通用宿主* 小节 [49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml]，了解如何使用
    .NET Core 宿主进行依赖注入，以及第 10 章 *理解软件解决方案的不同领域* 的 *依赖注入模式* 小节 [2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml]，了解依赖注入的一般讨论。
- en: 'The following is a typical REST API controller and its controller method definitions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个典型的 REST API 控制器和其控制器方法定义：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `[ApiController]` attribute declares that the controller is a REST API controller.
    `[Route("api/[controller]")]` declares that the controller must be selected on
    paths that start with `api/<controller name>`. The controller name is the name
    of the controller class without the `Controller` postfix. Thus, in this case,
    we have `api/values`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ApiController]` 属性声明控制器是一个 REST API 控制器。`[Route("api/[controller]")]` 声明控制器必须在以
    `api/<controller name>` 开头的路径上选择。控制器名称是控制器类名称，不带 `Controller` 后缀。因此，在这种情况下，我们有
    `api/values`。'
- en: '`[HttpGet("{id}")]` declares that the method must be invoked on GET requests
    of the `api/values/<id>` type, where `id` must be a number that''s passed as an
    argument to the method invocation. This can be done with `Get(int id)`. There''s
    also an `Http<verb>` attribute for each HTTP verb: `HttpPost` and `HttpPatch`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`[HttpGet("{id}")]` 声明该方法必须在 `api/values/<id>` 类型的 GET 请求上调用，其中 `id` 必须是一个作为方法调用参数传递的数字。这可以通过
    `Get(int id)` 实现。对于每个 HTTP 动词，也存在一个 `Http<verb>` 属性：`HttpPost` 和 `HttpPatch`。'
- en: 'We may also have another method defined like so:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可能定义另一个类似的方法：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method is invoked on `GET` requests of the `api/values` type, that is,
    on `GET` requests without `id` after the controller name.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在 `api/values` 类型的 GET 请求上调用，即在没有 `id` 的控制器名称之后的 GET 请求上。
- en: Several action methods can have the same name, but only one should be compatible
    with each request path; otherwise, an exception is thrown. In other words, routing
    rules and `Http<verb>` attributes must univocally define which controller and
    which of its action methods to select for each request.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 几个操作方法可以具有相同的名称，但每个请求路径只能有一个与之兼容；否则，将抛出异常。换句话说，路由规则和`Http<verb>`属性必须唯一地定义每个请求应选择哪个控制器及其哪个操作方法。
- en: 'By default, parameters are passed to the action methods of API controllers
    according to the following rules:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数根据以下规则传递到API控制器的操作方法中：
- en: Simple types (`integers`, `floats`, and `DateTimes`) are taken from the request
    path if routing rules specify them as parameters, as in the case of the previous
    example's `[HttpGet("{id}")]` attribute. If they are not found in the routing
    rules, the MVC framework looks for query string parameters with the same name.
    Thus, for instance, if we replace `[HttpGet("{id}")]` with `[HttpGet]`, the MVC
    framework will look for something like `api/values?id=<an integer>`.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单类型（`整数`、`浮点数`和`DateTimes`）如果路由规则指定它们为参数，则从请求路径中获取，例如上一个示例中的`[HttpGet("{id}")]`属性。如果它们在路由规则中未找到，MVC框架将查找具有相同名称的查询字符串参数。因此，例如，如果我们用`[HttpGet]`替换`[HttpGet("{id}")]`，MVC框架将查找类似`api/values?id=<一个整数>`的内容。
- en: Complex types are extracted from the request body by formatters. The right formatter
    is chosen according to the value of the request's `Content-Type` header. If no
    `Content-Type` header is specified, the JSON formatter is taken. The JSON formatter
    tries to parse the request body as a JSON object and then tries to transform this
    JSON object into an instance of the .NET Core complex type. If either the JSON
    extraction or the subsequent conversion fails, an exception is thrown. By default,
    just the JSON input formatter is supported, but you can also add an XML formatter
    that can be used when `Content-Type` specifies XML content. It is enough to add
    the `Microsoft.AspNetCore.Mvc.Formatters.Xml` NuGet package and replace `services.AddMvc()`
    with `services.AddMvc().AddXmlSerializerFormatters()` in the `ConfigureServices`
    method of `Startup.cs`.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂类型是通过格式化程序从请求体中提取的。根据请求的`Content-Type`头部的值选择正确的格式化程序。如果没有指定`Content-Type`头部，则使用JSON格式化程序。JSON格式化程序尝试将请求体解析为JSON对象，然后尝试将此JSON对象转换为.NET
    Core复杂类型的实例。如果JSON提取或后续转换失败，将抛出异常。默认情况下，仅支持JSON输入格式化程序，但您也可以添加一个XML格式化程序，当`Content-Type`指定XML内容时可以使用。只需添加`Microsoft.AspNetCore.Mvc.Formatters.Xml`
    NuGet包，并在`Startup.cs`的`ConfigureServices`方法中将`services.AddMvc()`替换为`services.AddMvc().AddXmlSerializerFormatters()`即可。
- en: 'You can customize the source that''s used to fill an action method parameter
    by prefixing the parameter with an adequate attribute. The following code shows
    some examples of this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在参数前添加适当的属性来自定义用于填充操作方法参数的源。以下代码显示了此示例的一些示例：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The return type of an `Action` method must be an `IAsyncResult` interface or
    a type that implements that interface. In turn, `IAsyncResult` has just the following
    method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action`方法的返回类型必须是`IAsyncResult`接口或实现该接口的类型。反过来，`IAsyncResult`只有一个以下方法：'
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method is called by the MVC framework at the right time to create the actual
    response and response headers. The `ActionContext` object, when passed to the
    method, contains the whole context of the HTTP request, which includes a request
    object with all the necessary information about the original HTTP requests (headers,
    body, and cookies), as well as a response object that collects all the pieces
    of the response that is being built.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法由MVC框架在正确的时间调用以创建实际响应和响应头。当将`ActionContext`对象传递到方法中时，它包含整个HTTP请求的上下文，包括包含有关原始HTTP请求（头、正文和Cookie）的所有必要信息的请求对象，以及收集正在构建的响应的所有部分的响应对象。
- en: 'You don''t have to create an implementation of `IAsyncResult` manually, since `ControllerBase`
    already has methods to create `IAsyncResult` implementations so that all the necessary
    HTTP responses are generated. Some of these methods are as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您无需手动创建`IAsyncResult`的实现，因为`ControllerBase`已经具有创建`IAsyncResult`实现的方法，以便生成所有必要的HTTP响应。以下是一些这些方法：
- en: '`OK`: This returns a 200 status code, as well as an optional result object.
    It is used either as `return OK()` or as `return OK(myResult)`.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OK`: 这将返回一个200状态码，以及一个可选的结果对象。它可以用作`return OK()`或`return OK(myResult)`。'
- en: '`BadRequest`: This returns a 400 status code, as well as an optional request
    object.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BadRequest`: 这将返回一个400状态码，以及一个可选的请求对象。'
- en: '`Created(string uri, object o)`: This returns a 201 status code, as well as
    a result object and the URI of the created resource.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Created(string uri, object o)`: 这将返回一个201状态码，以及一个结果对象和创建资源的URI。'
- en: '`Accepted`: This returns a 202 status result, as well as an optional result
    object and resource URI.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accepted`: 这将返回一个202状态结果，以及一个可选的结果对象和资源URI。'
- en: '`Unauthorized`: This returns a 401 status result, as well as an optional result
    object.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unauthorized`: 这将返回一个401状态结果，以及一个可选的结果对象。'
- en: '`Forbid`: This returns a 403 status result, as well as an optional list of
    failed permissions.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Forbid`: 这将返回一个403状态结果，以及一个可选的失败权限列表。'
- en: '`StatusCode(int statusCode, object o = null)`: This returns a custom status
    code, as well as an optional result object.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StatusCode(int statusCode, object o = null)`: 这将返回一个自定义状态码，以及一个可选的结果对象。'
- en: An action method can return a result object directly with `return myObject`.
    This is equivalent to returning `OK(myObject)`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个操作方法可以直接使用`return myObject`返回一个结果对象。这相当于返回`OK(myObject)`。
- en: When all the result paths return a result object of the same type, say, `MyType`,
    the action method can be declared as returning `ActionResult<MyType>` to get a
    better type check.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有结果路径都返回相同类型的结果对象，例如`MyType`时，操作方法可以声明为返回`ActionResult<MyType>`以获得更好的类型检查。
- en: By default, result objects are serialized in JSON in the response body. However,
    if an XML formatter has been added to the MVC framework processing pipeline, as
    shown previously, the way the result is serialized depends on the `Accept` header
    of the HTTP request. More specifically, if the client explicitly requires an XML
    format with the `Accept` header, the object will be serialized in XML; otherwise,
    it will be serialized in JSON.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，结果对象在响应体中以JSON格式序列化。然而，如果已向MVC框架处理管道中添加了XML格式化程序，如前所述，结果的序列化方式取决于HTTP请求的`Accept`头。更具体地说，如果客户端明确要求使用`Accept`头以XML格式，对象将以XML格式序列化；否则，将以JSON格式序列化。
- en: 'Complex objects that are passed as input to action methods can be validated
    with validation attributes, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作方法的输入传递的复杂对象可以使用验证属性进行验证，如下所示：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the controller has been decorated with the `[ApiController]` attribute and
    if validation fails, the MVC framework automatically creates a BadRequest response
    containing a dictionary with all the validation errors detected, without executing
    the action method. Therefore, you don't need to add further code to handle validation
    errors.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果控制器已用`[ApiController]`属性装饰，并且验证失败，MVC框架将自动创建一个包含所有检测到的验证错误的BadRequest响应，而不执行操作方法。因此，您不需要添加额外的代码来处理验证错误。
- en: 'Action methods can also be declared as async methods, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 操作方法也可以声明为异步方法，如下所示：
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Practical examples of controllers/action methods will be shown in the use case
    section of this chapter. In the next subsection, we will explain how to handle
    authorization and authentication with JWT tokens.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的使用案例部分将展示控制器/操作方法的实际示例。在下一小节中，我们将解释如何使用JWT令牌处理授权和身份验证。
- en: ASP.NET Core service authorization
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core服务授权
- en: 'When using a JWT token, authorizations are based on the claims contained in
    the JWT token. All the token claims in any action method can be accessed through
    the `User.Claims` controller property. Since `User.Claims` is an `IEnumerable<Claim>`,
    it can be processed with `LinQ` to verify complex conditions on claims. If authorization
    is based on *role* claims, you can simply use the `User.IsInRole` function, as
    shown in the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JWT令牌时，授权基于JWT令牌中包含的声明。任何操作方法中的所有令牌声明都可以通过`User.Claims`控制器属性访问。由于`User.Claims`是一个`IEnumerable<Claim>`，它可以与`LinQ`一起处理以验证声明的复杂条件。如果授权基于*角色*声明，您可以使用`User.IsInRole`函数，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, permissions are not usually checked from within action methods and
    are automatically checked by the MVC framework, according to authorization attributes
    that decorate either the whole controller or a single action method. If an action
    method or the whole controller is decorated with `[Authorize]`, then access to
    the action method is possible only if the request has a valid authentication token,
    which means we don''t have to perform a check on the token claims. It is also
    possible to check whether the token contains a set of roles using the following
    code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常不会在动作方法内部检查权限，而是由 MVC 框架根据装饰整个控制器或单个动作方法的授权属性自动检查。如果一个动作方法或整个控制器被 `[Authorize]`
    装饰，那么只有当请求包含有效的身份验证令牌时，才能访问动作方法，这意味着我们不需要对令牌声明进行检查。还可以使用以下代码检查令牌是否包含一组角色：
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'More complex conditions on claims require that authorization policies are defined
    in the `ConfigureServices` method of `Startup.cs`, as shown in the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的声明条件，需要在 `Startup.cs` 的 `ConfigureServices` 方法中定义授权策略，如下所示代码所示：
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After that, you can decorate the action methods or controllers with `[Authorize(Policy
    = "Father")]`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以使用 `[Authorize(Policy = "Father")]` 装饰动作方法或控制器。
- en: 'Before using JWT-based authorization, you must configure it in `Startup.cs`.
    First of all, you must add the middleware that processes authentication tokens
    in the ASP.NET Core processing pipeline defined in the `Configure` method, as
    shown here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用基于 JWT 的授权之前，必须在 `Startup.cs` 中进行配置。首先，必须将处理身份验证令牌的中间件添加到在 `Configure` 方法中定义的
    ASP.NET Core 处理管道中，如下所示：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, you must configure the authentication services in the `ConfigureServices`
    section. Here, you define the authentication options that will be injected through
    dependency injection into the authentication middleware:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，必须在 `ConfigureServices` 部分配置身份验证服务。在这里，你定义将通过依赖注入注入到身份验证中间件的身份验证选项：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code provides a name to the authentication scheme, that is, a
    default name. Then, it specifies JWT authentication options. Usually, we require
    that the authentication middleware verifies that the JWT token is not expired
    (`ValidateLifetime = true`), that it has the right issuer and audience (see the *REST
    services authorization and authentication* section of this chapter), and that
    its signature is valid.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为身份验证方案提供了一个名称，即默认名称。然后，它指定 JWT 身份验证选项。通常，我们要求身份验证中间件验证 JWT 令牌未过期（`ValidateLifetime
    = true`），它具有正确的发行者和受众（参见本章的 *REST 服务授权和身份验证* 部分），并且其签名有效。
- en: The preceding example uses a symmetric signing key generated from a string.
    This means that the same key is used to sign and to verify the signature. This
    is an acceptable choice if JWT tokens are created by the same website that uses
    them, but it is not an acceptable choice if there is a unique JWT issuer that
    controls access to several Web API sites.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使用从字符串生成的对称签名密钥。这意味着相同的密钥用于签名和验证签名。如果 JWT 令牌由使用它们的同一网站创建，这是一个可接受的选择，但如果有一个唯一的
    JWT 发布者控制对多个 Web API 网站的访问，则这不是一个可接受的选择。
- en: 'Here, we should use an asymmetric key (typically, a RsaSecurityKey), so JWT
    verification requires just the knowledge of the public key associated with the
    actual private signing key. Identity Server 4 can be used to quickly create a
    website that works as an authentication server. It emits a JWT token with the
    usual username/password credentials or converts other authentication tokens. If
    you use an authentication server such as Identity Server 4, you don''t need to
    specify the `IssuerSigningKey` option, since the authorization middleware is able
    to retrieve the required public key from the authorization server automatically.
    It is enough to provide the authentication server URL, as shown here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该使用非对称密钥（通常是 RsaSecurityKey），因此 JWT 验证只需要知道与实际私有签名密钥关联的公钥。Identity Server
    4 可以快速创建一个作为身份验证服务器工作的网站。它使用常规的用户名/密码凭据发出 JWT 令牌或转换其他身份验证令牌。如果你使用身份验证服务器，如 Identity
    Server 4，则不需要指定 `IssuerSigningKey` 选项，因为授权中间件能够自动从授权服务器检索所需的公钥。只需提供身份验证服务器 URL
    即可，如下所示：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On the other hand, if you decide to emit JWT in your Web API''s site, you can
    define a `Login` action method that accepts an object with a username and password,
    and that, while relying on database information, builds the JWT token with code
    similar to the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您决定在您的 Web API 网站上发出 JWT，您可以定义一个接受具有用户名和密码的对象的 `Login` 操作方法，并且该操作方法在依赖数据库信息的同时，使用类似于以下代码的代码构建
    JWT 令牌：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, `JwtSecurityTokenHandler().WriteToken(token)` generates the actual token
    string from the token properties contained in the `JwtSecurityToken` instance.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`JwtSecurityTokenHandler().WriteToken(token)` 从 `JwtSecurityToken` 实例中包含的令牌属性生成实际的令牌字符串。
- en: In the next subsection, we will learn how to empower our Web API with an OpenAPI
    documentation point so that proxy classes for communicating with our services
    can be generated automatically.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将学习如何通过 OpenAPI 文档点增强我们的 Web API，以便可以自动生成与我们的服务通信的代理类。
- en: ASP.NET Core support for OpenAPI
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 对 OpenAPI 的支持
- en: 'Most of the information that''s needed to fill in an OpenAPI JSON document
    can be extracted from Web API controllers through reflection, that is, input types
    and sources (path, request body, and header) and endpoint paths (these can be
    extracted from routing rules). Returned output types and status codes, in general,
    can''t be easily computed since they can be generated dynamically. Therefore,
    the MVC framework provides the `ProducesResponseType` attribute so that we can
    declare a possible return type – a status code pair. It is enough to decorate
    each action method with as many `ProducesResponseType` attributes as there are
    possible types, that is, possible status code pairs, as shown in the following
    code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数需要填充 OpenAPI JSON 文档的信息都可以通过反射从 Web API 控制器中提取，即输入类型和来源（路径、请求体和头部）以及端点路径（这些可以从路由规则中提取）。返回的输出类型和状态码通常不容易计算，因为它们可以动态生成。因此，MVC
    框架提供了 `ProducesResponseType` 属性，以便我们可以声明可能的返回类型——状态码对。只需在每个操作方法上装饰尽可能多的 `ProducesResponseType`
    属性，即可能的类型，也就是可能的状态码对，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If no object is returned along a path, we can just declare the status code,
    as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径上没有返回对象，我们只需声明状态码，如下所示：
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can also specify just the status code when all the paths return the same
    type and when that type is specified in the action method return type as `ActionResult<CommonReturnType>]`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有路径都返回相同类型，并且该类型在操作方法返回类型中指定为 `ActionResult<CommonReturnType>` 时，我们也可以仅指定状态码。
- en: 'Once all the action methods have been documented, in order to generate any
    actual documentation for the JSON endpoints, we must install the `Swashbuckle.AspNetCore`
    NuGet package and place some code in the `Startup.cs` file. More specifically,
    we must add some middleware in the `Configure` method, as shown here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有操作方法都已记录，为了生成针对 JSON 端点的任何实际文档，我们必须安装 `Swashbuckle.AspNetCore` NuGet 包，并在
    `Startup.cs` 文件中放置一些代码。更具体地说，我们必须在 `Configure` 方法中添加一些中间件，如下所示：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we must add some configuration options in the `ConfigureServices` method,
    as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须在 `ConfigureServices` 方法中添加一些配置选项，如下所示：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first argument of the `SwaggerDoc` method is the documentation endpoint
    name. By default, the documentation endpoint is accessible through the `<webroot>//swagger/<endpoint
    name>/swagger.json` path, but this can be changed in several ways. The rest of
    the information contained in the `Info` class is self-explanatory.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwaggerDoc` 方法的第一个参数是文档端点名称。默认情况下，文档端点可以通过 `<webroot>//swagger/<endpoint name>/swagger.json`
    路径访问，但可以通过多种方式更改。`Info` 类中包含的其他信息都是自解释的。'
- en: We can add several `SwaggerDoc` calls to define several documentation endpoints.
    However, by default, all the documentation endpoints will contain the same documentation,
    which includes a description of all the REST services included in the project.
    This default can be changed by calling the `c.DocInclusionPredicate(Func<string,
    ApiDescription> predicate)` method from within `services.AddSwaggerGen(c => {...})`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加多个 `SwaggerDoc` 调用来定义多个文档端点。但是，默认情况下，所有文档端点都将包含相同的文档，其中包括对项目中包含的所有 REST
    服务的描述。此默认值可以通过在 `services.AddSwaggerGen(c => {...})` 内调用 `c.DocInclusionPredicate(Func<string,
    ApiDescription> predicate)` 方法来更改。
- en: '`DocInclusionPredicate` must be passed a function that receives a JSON document
    name and an action method description and must return `true` if the documentation
    of the action must be included in that JSON document.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocInclusionPredicate` 必须传递一个函数，该函数接收一个 JSON 文档名称和一个操作方法描述，并且如果操作必须在那个 JSON
    文档中包含文档，则必须返回 `true`。'
- en: 'To declare that your REST APIs need a JWT token, you must add the following
    code within `services.AddSwaggerGen(c => {...})`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了声明你的 REST API 需要JWT令牌，你必须在 `services.AddSwaggerGen(c => {...})` 内部添加以下代码：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can enrich the JSON documentation endpoint with information that''s been
    extracted from triple-slash comments, which are usually added to generate automatic
    code documentation. The following code shows some examples of this. The following
    snippet shows how we can add a method description and parameter information:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从三斜杠注释中提取信息来丰富 JSON 文档端点，这些注释通常用于生成自动代码文档。以下代码展示了这一过程的几个示例。以下片段展示了如何添加方法描述和参数信息：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following snippet shows how we can add an example of usage:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段展示了如何添加使用示例：
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following snippet shows how we can add parameter descriptions and return
    type descriptions for each HTTP status code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段展示了如何为每个 HTTP 状态码添加参数描述和返回类型描述：
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To enable extraction from triple-slash comments, we must enable code documentation
    creation by adding the following code in our project file (`.csproj`):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用从三斜杠注释的提取，我们必须通过在项目文件（`.csproj`）中添加以下代码来启用代码文档创建：
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we must enable code documentation processing from within `services.AddSwaggerGen(c
    => {...})` by adding the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须在 `services.AddSwaggerGen(c => {...})` 内部启用代码文档处理，通过添加以下代码：
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once our documentation endpoints are ready, we can add some more middleware
    that''s contained in the same `Swashbuckle.AspNetCore` NuGet package to generate
    a friendly user interface that we can test our REST API on:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的文档端点准备就绪，我们可以在同一 `Swashbuckle.AspNetCore` NuGet 包中添加一些中间件来生成一个友好的用户界面，我们可以在该界面上测试我们的
    REST API：
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you have several documentation endpoints, you need to add a `SwaggerEndpoint`
    call for each of them. We will use this interface to test the REST API defined
    in this chapter's use case.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有多个文档端点，你需要为每个端点添加一个 `SwaggerEndpoint` 调用。我们将使用此接口来测试本章用例中定义的 REST API。
- en: 'Once you have a working JSON documentation endpoint, you can automatically
    generate the C# or TypeScript code of a proxy class with one of the following
    methods:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个工作的 JSON 文档端点，你可以使用以下方法之一自动生成代理类的 C# 或 TypeScript 代码：
- en: The NSwagStudio Windows program, which is available at [https://github.com/RicoSuter/NSwag/wiki/NSwagStudio](https://github.com/RicoSuter/NSwag/wiki/NSwagStudio).
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可在 [https://github.com/RicoSuter/NSwag/wiki/NSwagStudio](https://github.com/RicoSuter/NSwag/wiki/NSwagStudio)
    找到的 NSwagStudio Windows 程序。
- en: The `NSwag.CodeGeneration.CSharp` or `NSwag.CodeGeneration.TypeScript` NuGet
    packages if you want to customize code generation.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要自定义代码生成，可以使用 `NSwag.CodeGeneration.CSharp` 或 `NSwag.CodeGeneration.TypeScript`
    NuGet 包。
- en: The `NSwag.MSBuild` NuGet package if you want to tie code generation to Visual
    Studio build operations. The documentation for this can be found at [https://github.com/RicoSuter/NSwag/wiki/MSBuild](https://github.com/RicoSuter/NSwag/wiki/MSBuild).
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要将代码生成与 Visual Studio 构建操作关联起来，可以使用 `NSwag.MSBuild` NuGet 包。有关此包的文档可以在 [https://github.com/RicoSuter/NSwag/wiki/MSBuild](https://github.com/RicoSuter/NSwag/wiki/MSBuild)
    找到。
- en: In the next subsection, you will learn how to invoke a REST API from another
    REST API or from a .NET Core client.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，你将学习如何从一个 REST API 或从 .NET Core 客户端调用 REST API。
- en: .Net Core HTTP clients
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .Net Core HTTP 客户端
- en: 'The `HttpClient` class in the `System.Net.Http` namespace is a .NET standard
    2.0 built-in HTTP client class. While it could be used directly whenever we need
    to interact with a REST service, there are some problems in creating and releasing
    `HttpClient` instances repeatedly, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Net.Http` 命名空间中的 `HttpClient` 类是一个 .NET 标准版 2.0 内置的 HTTP 客户端类。虽然它可以直接在任何需要与
    REST 服务交互时使用，但反复创建和释放 `HttpClient` 实例存在一些问题，如下所示：'
- en: Their creation is expensive.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的创建成本很高。
- en: When an `HttpClient` is released, for instance, in a `using` statement, the
    underlying connection isn't closed immediately but at the first garbage collection
    session, which is a repeated creation. Release operations quickly exhaust the
    maximum number of connections the operating system can handle.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，当 `HttpClient` 被释放时，在 `using` 语句中，底层连接不会立即关闭，而是在第一次垃圾回收会话时关闭，这是一个重复创建的过程。释放操作会迅速耗尽操作系统可以处理的连接最大数量。
- en: Therefore, either a single `HttpClient` instance is reused, such as a singleton,
    or `HttpClient` instances are somehow pooled. Starting from the 2.1 version of
    .NET Core, an `HttpClientFactory` class was introduced to pool HTTP clients. More
    specifically, whenever a new `HttpClient` instance is required for an `HttpClientFactory`
    object, a new `HttpClient` is created. However, the underlying `HttpClientMessageHandler` instances,
    which are expansive to create, are pooled until their maximum lifetime expires.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以重用单个`HttpClient`实例，例如单例，或者以某种方式池化`HttpClient`实例。从.NET Core 2.1版本开始，引入了`HttpClientFactory`类来池化HTTP客户端。更具体地说，每当需要为`HttpClientFactory`对象创建新的`HttpClient`实例时，都会创建一个新的`HttpClient`。然而，底层的`HttpClientMessageHandler`实例，创建成本较高，会池化直到其最大生命周期到期。
- en: '`HttpClientMessageHandler` instances must have a finite duration since they
    cache DNS resolution information that may change over time. The default lifetime
    of `HttpClientMessageHandler` is 2 minutes, but it can be redefined by the developer.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClientMessageHandler`实例必须具有有限的生命周期，因为它们缓存可能随时间变化的DNS解析信息。`HttpClientMessageHandler`的默认生命周期为2分钟，但可以被开发者重新定义。'
- en: Using `HttpClientFactory` allows us to automatically pipeline all the HTTP operations
    with other operations. For instance, we can add a Polly retry strategy to handle
    all the failures of all our HTTP operations automatically. For an introduction
    to Polly, please refer to the *Resilient task execution* subsection of [Chapter
    5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying a Microservice Architecture
    to Your Enterprise Application*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HttpClientFactory`允许我们自动将所有HTTP操作与其他操作一起管道化。例如，我们可以添加Polly重试策略来自动处理所有HTTP操作的失败。有关Polly的介绍，请参阅[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)的*弹性任务执行*小节，*将微服务架构应用于您的企业应用*。
- en: 'The simplest way to exploit the advantages offered by the `HttpClientFactory`
    class is to add the `Microsoft.Extensions.Http` NuGet package and then to follow
    these steps:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 利用`HttpClientFactory`类提供的优势的最简单方法是添加`Microsoft.Extensions.Http` NuGet包，然后按照以下步骤操作：
- en: Define a proxy class, say, `MyProxy`, to interact with the desired REST service.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个代理类，例如`MyProxy`，以与所需的REST服务交互。
- en: Let `MyProxy` accept an `HttpClient` instance in its constructor.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让`MyProxy`在其构造函数中接受一个`HttpClient`实例。
- en: Use the `HttpClient` that was injected into the constructor to implement all
    the necessary operations.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用构造函数中注入的`HttpClient`来实现所有必要的操作。
- en: Declare your proxy in the services configuration method of your Host which,
    in the case of an ASP.NET Core application, is the `ConfigureServices` method
    of the `Startup.cs` class, while, in the case of a client application, this is
    the `ConfigureServices` method of the `HostBuilder` instance. In the simplest
    case, the declaration is something similar to `services.AddHttpClient<MyProxy>()`.
    This will automatically add `MyProxy` to the services that are available for dependency
    injection, so you can easily inject it, for instance, in your controller's constructors.
    Moreover, each time an instance of `MyProxy` is created, an `HttpClient` is returned
    by an `HttpClientFactory` and is automatically injected into its constructor.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的宿主服务的配置方法中声明您的代理，对于ASP.NET Core应用程序，这是`Startup.cs`类中的`ConfigureServices`方法，而对于客户端应用程序，这是`HostBuilder`实例的`ConfigureServices`方法。在最简单的情况下，声明类似于`services.AddHttpClient<MyProxy>()`。这将自动将`MyProxy`添加到可用于依赖注入的服务中，因此您可以轻松地在控制器构造函数中注入它。此外，每次创建`MyProxy`实例时，`HttpClientFactory`都会返回一个`HttpClient`实例，并将其自动注入其构造函数中。
- en: 'In the constructors of the classes that need to interact with a REST service,
    we may also need an interface instead of a specific proxy implementation with
    a declaration of the type:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要与REST服务交互的类的构造函数中，我们可能也需要一个接口，而不是具有特定代理实现的声明：
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A Polly resilient strategy (see the *Resilient task execution* subsection of
    [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying a Microservice
    Architecture to Your Enterprise Application*) can be applied to all the HTTP calls
    issued by our proxy class, as shown here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Polly弹性策略（参见[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)的*弹性任务执行*小节，*将微服务架构应用于您的企业应用*）可以应用于我们代理类发出的所有HTTP调用，如下所示：
- en: '[PRE41]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we can preconfigure some of the properties of all the `HttpClient`
    instances that are passed to our proxy, as shown here:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以预先配置传递给我们的代理的所有`HttpClient`实例的一些属性，如下所示：
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This way, each client that's passed to the proxy is preconfigured so that they
    require a JSON response and have to work with a specific service. Once the base
    address has been defined, each HTTP request needs to specify the relative path
    of the service method to call.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每个传递给代理的客户端都预先配置好，它们需要 JSON 响应，并且必须与特定服务一起工作。一旦定义了基本地址，每个 HTTP 请求都需要指定要调用的服务方法的相对路径。
- en: 'The following code shows how to perform a `POST` to a service. Here, we''re
    stating that the `HttpClient` that was injected into the proxy constructor has
    been stored in the `webClient` private field:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何向服务执行 `POST` 操作。在这里，我们声明注入到代理构造函数中的 `HttpClient` 已被存储在 `webClient`
    私有字段中：
- en: '[PRE43]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you use Polly, you don''t need to intercept and handle communication errors
    since this job is performed by Polly. First, you need to verify the status code
    to decide what to do next. Then, you can parse the JSON string contained in the
    response body to get a .NET instance of a type, that, in general, depends on the
    status code. The code to perform the parsing is based on the `Newtonsoft.Json`
    NuGet package''s `JsonConvert` class and is as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Polly，你不需要拦截和处理通信错误，因为这个任务由 Polly 完成。首先，你需要验证状态码以决定下一步要做什么。然后，你可以解析响应体中包含的
    JSON 字符串，以获取一个 .NET 实例的类型，这通常取决于状态码。执行解析的代码基于 `Newtonsoft.Json` NuGet 包的 `JsonConvert`
    类，如下所示：
- en: '[PRE44]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Performing a GET request is similar but, instead of calling `PostAsJsonAsync`,
    you need to call `GetAsync`, as shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 GET 请求类似，但你需要调用 `GetAsync` 而不是 `PostAsJsonAsync`，如下所示：
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The use of other HTTP verbs is completely analogous.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 HTTP 动词的使用完全类似。
- en: Use case – exposing WWTravelClub packages
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 暴露 WWTravelClub 包
- en: In this section, we will implement an ASP.NET REST service that lists all the
    packages that are available for a given vacation's start and end dates. For didactic
    purposes, we won't structure the application according to the best practices described
    in [Chapter 10](2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml), *Understanding the
    Different Domains in Software Solutions*; instead, we will simply generate the
    results with a LINQ query that will be directly placed in the controller action
    method. A well-structured ASP.NET Core application will be presented in [Chapter
    13](003ee8cb-5995-4364-8772-73d73df29cf8.xhtml), *Presenting ASP.NET Core MVC*,
    which is dedicated to the MVC framework.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个 ASP.NET REST 服务，该服务列出给定假期的开始和结束日期可用的所有包。为了教学目的，我们不会根据第 10 章[2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml]中描述的最佳实践来构建应用程序；相反，我们将简单地使用
    LINQ 查询生成结果，该查询将直接放置在控制器操作方法中。一个结构良好的 ASP.NET Core 应用程序将在第 13 章[003ee8cb-5995-4364-8772-73d73df29cf8.xhtml]中介绍，*展示
    ASP.NET Core MVC*，该章节专门介绍 MVC 框架。
- en: Let's make a copy of the `WWTravelClubDB` solution folder and rename the new
    folder `WWTravelClubREST`. The WWTravelClubDB project was built step by step in
    the various sections of [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml),
    *Interacting with Data in C# - Entity Framework Core*. Let's open the new solution
    and add a new ASP.NET Core API project to it named WWTravelClubREST (the same
    name as the new solution folder). For simplicity, select no authentication. Right-click
    on the newly created project and select Set as StartUp project to make it the
    default project that's launched when the solution is run.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制 `WWTravelClubDB` 解决方案文件夹，并将新文件夹重命名为 `WWTravelClubREST`。WWTravelClubDB
    项目是在第 6 章[8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml]的各个部分中逐步构建的，*在 C# 中与数据交互
    - Entity Framework Core*。让我们打开新的解决方案，并向其中添加一个名为 WWTravelClubREST 的新 ASP.NET Core
    API 项目（与新的解决方案文件夹同名）。为了简单起见，选择不进行身份验证。右键单击新创建的项目，并选择设置为启动项目，以便在运行解决方案时将其作为默认项目启动。
- en: Finally, we need to add a reference to the WWTravelClubDB project.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将 WWTravelClubDB 项目添加为引用。
- en: 'ASP.NET Core projects store configuration constants in the `appsettings.json`
    file. Let''s open this file and add the database connection string for the database
    we created in the WWTravelClubDB project to it, as shown here:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 项目将配置常量存储在 `appsettings.json` 文件中。让我们打开这个文件，并将我们为在 WWTravelClubDB
    项目中创建的数据库添加到其中，如下所示：
- en: '[PRE46]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we must add the WWTravelClubDB entity framework database context to the `ConfigureServices`
    method in `Startup.cs`, as shown here:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将 WWTravelClubDB 实体框架数据库上下文添加到 `Startup.cs` 中的 `ConfigureServices` 方法中，如下所示：
- en: '[PRE47]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The option object settings that are passed to `AddDbContext` specify the usage
    of SQL server with a connection string that is extracted from the `ConnectionStrings`
    section of the `appsettings.json` configuration file with the `Configuration.GetConnectionString("DefaultConnection")`
    method. The `b => b.MigrationsAssembly("WWTravelClubDB")` lambda function declares
    the name of the assembly that contains the database migrations (see [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml), *Interacting
    with Data in C# - Entity Framework Core*) which, in our case, is the DLL that
    was generated by the WWTravelClubDB project. For the preceding code to compile,
    you should add `using Microsoft.EntityFrameworkCore;`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将传递给 `AddDbContext` 的选项对象设置指定了使用 SQL Server，其连接字符串通过 `Configuration.GetConnectionString("DefaultConnection")`
    方法从 `appsettings.json` 配置文件的 `ConnectionStrings` 部分提取。`b => b.MigrationsAssembly("WWTravelClubDB")`
    的 lambda 函数声明了包含数据库迁移的程序的名称（参见 [第 6 章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)，*在
    C# 中与数据交互 - Entity Framework Core*），在我们的例子中，这是由 WWTravelClubDB 项目生成的 DLL。为了使前面的代码能够编译，你应该添加
    `using Microsoft.EntityFrameworkCore;`。
- en: 'Since we want to enrich our REST service with OpenAPI documentation, let''s
    add a reference to the `Swashbuckle.AspNetCore` NuGet package. For .NET 3.0, you
    must select at least version 5.0 RC-4, so, if you don''t see the 5.0 version among
    the search results, please enable the Include prerelease checkbox. Now, we can
    add the following very basic configuration to the `ConfigureServices` method:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要用 OpenAPI 文档丰富我们的 REST 服务，因此让我们添加对 `Swashbuckle.AspNetCore` NuGet 包的引用。对于
    .NET 3.0，你必须选择至少版本 5.0 RC-4，所以，如果你在搜索结果中看不到 5.0 版本，请启用 Include prerelease 复选框。现在，我们可以在
    `ConfigureServices` 方法中添加以下非常基本的配置：
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, we can add the middleware for the OpenAPI endpoint and for adding a user
    interface for our API documentation, as shown here:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加 OpenAPI 端点的中间件以及为我们的 API 文档添加用户界面的功能，如下所示：
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we are ready to encode our service. Let''s delete `ValueController`, which
    is automatically scaffolded by Visual Studio. Then, right-click on the `Controller`
    folder and select Add | Controller. Now, choose an empty API controller called `PackagesController`.
    First, let''s modify the code, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备编码我们的服务。让我们删除由 Visual Studio 自动生成的 `ValueController`。然后，右键单击 `Controller`
    文件夹并选择 Add | Controller。现在，选择一个名为 `PackagesController` 的空 API 控制器。首先，让我们按照以下方式修改代码：
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `Route` attribute declares that the basic path for our service will be `api/packages`.
    The unique action method that we implement is `GetPackagesByDate`, which is invoked
    on `HttpGet` requests on paths of the `bydate/{start}/{stop}` type, where `start`
    and `stop` are the `DateTime` parameters that are passed as input to `GetPackagesByDate`.
    The `ProduceResponseType` attributes declare the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route` 属性声明我们的服务的基本路径将是 `api/packages`。我们实现的唯一操作方法是 `GetPackagesByDate`，它在
    `HttpGet` 请求的 `bydate/{start}/{stop}` 类型的路径上被调用，其中 `start` 和 `stop` 是作为输入传递给 `GetPackagesByDate`
    的 `DateTime` 参数。`ProduceResponseType` 属性声明以下内容：'
- en: When a request is successful, a 200 code is returned, and the body contains
    an IEnumerable of the `PackagesListDTO` (which we will soon define) type containing
    the required package information.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求成功时，会返回一个 200 状态码，并且体包含一个包含所需包信息的 `PackagesListDTO` 类型的 `IEnumerable`（我们很快将定义它）。
- en: When the request is ill-formed, a 400 code is returned. We don't specify the
    type returned since Bad Requests are automatically handled by the MVC framework
    through the `ApiController` attribute.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求格式不正确时，会返回一个 400 状态码。我们未指定返回的类型，因为不良请求会自动通过 `ApiController` 属性由 MVC 框架处理。
- en: In the case of unexpected errors, a 500 code is returned with an empty body.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在出现意外错误的情况下，会返回一个带有空体的 500 状态码。
- en: 'Now, let''s define the `PackagesListDTO` class in a new DTOs folder:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在新的 DTOs 文件夹中定义 `PackagesListDTO` 类：
- en: '[PRE51]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, let''s add the following `using` clauses to our controller code so
    that we can easily refer to our DTO and to Entity Framework LINQ methods:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在我们的控制器代码中添加以下 `using` 语句，以便我们可以轻松地引用我们的 DTO 和 Entity Framework LINQ 方法：
- en: '[PRE52]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we are ready to fill the body of the `GetPackagesByDate` method with the
    following code:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备用以下代码填充 `GetPackagesByDate` 方法的主体：
- en: '[PRE53]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The LINQ query is similar to the one contained in the WWTravelClubDBTest project
    we tested in [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml), *Interacting
    with Data in C# - Entity Framework Core*. Once the result has been computed, it
    is returned with an `OK` call. The method's code handles internal server errors
    by catching exceptions and returning a 500 status code, since Bad Requests are
    automatically handled before the controller method is called by the `ApiController`
    attribute.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 查询类似于我们在第 6 章 [8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml] “使用 C# 与数据交互
    - Entity Framework Core” 中测试的 WWTravelClubDBTest 项目中的查询。一旦计算结果，它将通过 `OK` 调用返回。方法代码通过捕获异常并返回
    500 状态码来处理内部服务器错误，因为 Bad Requests 在由 `ApiController` 属性调用控制器方法之前自动处理。
- en: 'Let''s run the solution. When the browser opens, it''s unable to receive any
    result from our ASP.NET Core website. Let''s modify the browser URL so that it''s
    `https://localhost:<previous port>/swagger`. The user interface of the OpenAPI
    documentation will look as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行解决方案。当浏览器打开时，它无法从我们的 ASP.NET Core 网站接收任何结果。让我们修改浏览器 URL，使其为 `https://localhost:<previous
    port>/swagger`。OpenAPI 文档的用户界面将如下所示：
- en: '![](img/7a2703ef-d1ab-4eb3-8002-3c042dc7336b.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a2703ef-d1ab-4eb3-8002-3c042dc7336b.png)'
- en: '`PackagesListDTO` is the model we defined to list the packages, while `ProblemDetails`
    is the model that''s used to report errors in the case of Bad Requests. By clicking
    the GET button, we can get more details about our `GET` method and we can also
    test it, as shown in the following screenshot:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`PackagesListDTO` 是我们定义的用于列出包的模型，而 `ProblemDetails` 是用于报告错误请求情况下的模型。通过点击 GET
    按钮，我们可以获取更多关于我们的 `GET` 方法的详细信息，我们还可以对其进行测试，如下面的截图所示：'
- en: '![](img/a817823c-098a-4363-aeb0-4f37553a3e6d.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a817823c-098a-4363-aeb0-4f37553a3e6d.png)'
- en: Pay attention when it comes to inserting dates that are covered by packages
    in the database; otherwise, an empty list will be returned. The ones shown in
    the preceding screenshot should work.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入数据库中受包覆盖的日期时请注意；否则，将返回空列表。前面截图中的那些应该可以工作。
- en: 'Dates must be entered in a correct JSON format; otherwise, a 400 Bad Request
    error is returned, like the one shown in the following code:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 日期必须以正确的 JSON 格式输入；否则，将返回 400 错误请求错误，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you insert the correct input parameters, the Swagger UI returns the packages
    that satisfy the query in JSON format.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入正确的输入参数，Swagger UI 将以 JSON 格式返回满足查询的包。
- en: That's all! You have implemented your first API with OpenAPI documentation!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！你已经使用 OpenAPI 文档实现了你的第一个 API！
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced SOA, its design principles, and its constraints.
    Among them, it is worth remembering interoperability.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 SOA、其设计原则和其约束。其中，值得记住的是互操作性。
- en: Then, we focused on well-established standards for business applications that
    achieve the interoperability that's needed for publicly exposed services. Therefore,
    SOAP and REST services were discussed in detail, along with the transition from
    SOAP services to REST services, which has taken place in most application areas
    in the last few years. Then, REST services principles, authentication/authorization,
    and its documentation were described in greater detail.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们关注了商业应用程序中实现公开暴露服务所需互操作性的既定标准。因此，详细讨论了 SOAP 和 REST 服务，以及在过去几年中大多数应用程序领域中发生的从
    SOAP 服务到 REST 服务的转变。然后，详细描述了 REST 服务原则、认证/授权及其文档。
- en: Finally, we looked at the tools that are available in .NET Core that we can
    use to implement and interact with services. We looked at a variety of frameworks
    for intra-cluster communication, such as .NET remoting and gRPC, and tools for
    SOAP and REST-based public services.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了 .NET Core 中可用的工具，我们可以使用这些工具来实现和交互服务。我们探讨了各种集群内通信框架，如 .NET 远程和 gRPC，以及
    SOAP 和基于 REST 的公共服务的工具。
- en: Here, we mainly focused on REST services. Their ASP.NET Core implementations
    were described in detail, along with the techniques we can use in order to authenticate/authorize
    them and their documentation. We also focused on how to implement efficient .NET
    Core proxies so that we can interact with REST services.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们主要关注 REST 服务。它们的 ASP.NET Core 实现被详细描述，包括我们可以用来认证/授权它们的技巧以及它们的文档。我们还关注了如何实现高效的
    .NET Core 代理，以便我们可以与 REST 服务交互。
- en: In the next chapter, we will learn how to use .NET Core 3.0 while building an
    application on ASP .NET Core MVC.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在构建 ASP .NET Core MVC 应用程序的同时使用 .NET Core 3.0。
- en: Questions
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can services use cookie-based sessions?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务可以使用基于cookie的会话吗？
- en: Is it good practice to implement a service with a custom communication protocol?
    Why or why not?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现服务时使用自定义通信协议是好的做法吗？为什么或为什么不？
- en: Can a `POST` request to a REST service cause a delete?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向REST服务发送`POST`请求会导致删除吗？
- en: How many dot-separated parts are contained in a JWT bearer token?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT载体令牌中包含多少个点分隔的部分？
- en: By default, where are the complex type parameters of a REST service's action
    methods taken from?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，REST服务操作方法的复杂类型参数是从哪里获取的？
- en: How is a controller declared as a REST service?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何声明控制器为REST服务？
- en: What are the main documentation attributes of ASP.NET Core services?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core服务的哪些主要文档属性？
- en: How are ASP.NET Core REST service routing rules declared?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core REST服务路由规则是如何声明的？
- en: How should a proxy be declared so that we can take advantage of .NET Core's `HttpClientFactory`
    class features?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应如何声明代理，以便我们可以利用.NET Core的`HttpClientFactory`类功能？
- en: Further reading
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: This chapter mainly focused on the more commonly used REST service. If you are
    interested in SOAP services, a good place to start is the Wikipedia page regarding
    SOAP specifications: [https://en.wikipedia.org/wiki/List_of_web_service_specifications](https://en.wikipedia.org/wiki/List_of_web_service_specifications).
    On the other hand, if you are interested in the Microsoft .NET WCF technology
    for implementing SOAP services, you can refer to WCF's official documentation
    here: [https://docs.microsoft.com/en-us/dotnet/framework/wcf/](https://docs.microsoft.com/en-us/dotnet/framework/wcf/).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注更常用的REST服务。如果您对SOAP服务感兴趣，可以从有关SOAP规范的维基百科页面开始：[https://en.wikipedia.org/wiki/List_of_web_service_specifications](https://en.wikipedia.org/wiki/List_of_web_service_specifications).
    另一方面，如果您对实现SOAP服务的Microsoft .NET WCF技术感兴趣，可以参考WCF的官方文档：[https://docs.microsoft.com/en-us/dotnet/framework/wcf/](https://docs.microsoft.com/en-us/dotnet/framework/wcf/).
- en: This chapter mentioned the AMQP protocol as an option for intra-cluster communication
    without describing it. Detailed information on this protocol is available on AMQP's
    official site: [https://www.amqp.org/](https://www.amqp.org/).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提到了AMQP协议作为集群内部通信的选项，但没有对其进行描述。关于此协议的详细信息可在AMQP的官方网站上找到：[https://www.amqp.org/](https://www.amqp.org/).
- en: 'More information on gRPC is available on Google gRPC''s official site: [https://grpc.io/](https://grpc.io/).
    More information on the Visual Studio gRPC project template can be found here:
    [https://docs.microsoft.com/en-US/aspnet/core/grpc/?view=aspnetcore-3.0](https://docs.microsoft.com/en-US/aspnet/core/grpc/?view=aspnetcore-3.0.).'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 关于gRPC的更多信息可在Google gRPC的官方网站上找到：[https://grpc.io/](https://grpc.io/). 关于Visual
    Studio gRPC项目模板的更多信息可在此处找到：[https://docs.microsoft.com/en-US/aspnet/core/grpc/?view=aspnetcore-3.0](https://docs.microsoft.com/en-US/aspnet/core/grpc/?view=aspnetcore-3.0.).
- en: More details on ASP.NET Core services are available in the official documentation: [https://docs.microsoft.com/en-US/aspnet/core/web-api/?view=aspnetcore-3.0](https://docs.microsoft.com/en-US/aspnet/core/web-api/?view=aspnetcore-3.0).
    More information on .NET Core's HTTP client is available here: [https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests?view=aspnetcore-3.0](https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests?view=aspnetcore-3.0).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于ASP.NET Core服务的详细信息可在官方文档中找到：[https://docs.microsoft.com/en-US/aspnet/core/web-api/?view=aspnetcore-3.0](https://docs.microsoft.com/en-US/aspnet/core/web-api/?view=aspnetcore-3.0).
    更多关于.NET Core HTTP客户端的信息可在此处找到：[https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests?view=aspnetcore-3.0](https://docs.microsoft.com/en-US/aspnet/core/fundamentals/http-requests?view=aspnetcore-3.0).
- en: 'More information on JWT token authentication is available here: [https://jwt.io/](https://jwt.io/).
    If you would like to generate JWT tokens with Identity Serve 4, you may refer
    to its official documentation page: [http://docs.identityserver.io/en/latest/](http://docs.identityserver.io/en/latest/).'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JWT令牌认证的更多信息可在此处找到：[https://jwt.io/](https://jwt.io/). 如果您想使用Identity Serve
    4生成JWT令牌，您可以参考其官方文档页面：[http://docs.identityserver.io/en/latest/](http://docs.identityserver.io/en/latest/).
- en: More information on OpenAPI is available at [https://swagger.io/docs/specification/about/](https://swagger.io/docs/specification/about/),
    while more information on Swashbuckle can be found on its GitHub repository page: [https://github.com/domaindrivendev/Swashbuckle](https://github.com/domaindrivendev/Swashbuckle).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于OpenAPI的信息可在[https://swagger.io/docs/specification/about/](https://swagger.io/docs/specification/about/)找到，而关于Swashbuckle的更多信息可在其GitHub存储库页面上找到：[https://github.com/domaindrivendev/Swashbuckle](https://github.com/domaindrivendev/Swashbuckle).
