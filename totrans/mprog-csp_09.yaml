- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking Advantage of the Dynamic Language Runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# is a statically typed language, which means we take our code in text form
    and run it through a compiler, and it produces a binary that is then executed
    later. The code does not change after the compiler is done. Not all languages
    are like this; languages such as Ruby, Python, and JavaScript are dynamic languages
    and do not compile to binary before execution. They are interpreted at runtime,
    meaning that they can also change gradually during runtime. This is a very powerful
    trait.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look into how we can make use of the dynamic language
    runtime part of the .NET runtime and create code dynamically and differently from
    how we’ve done it thus far.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the DLR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reasoning about a dynamic type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a DynamicObject and providing metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will understand what the dynamic language runtime
    is and how you can make use of it to dynamically create types and reason about
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter9](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter9)),
    and it builds on top of the **Fundamentals** code that is found here: [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the DLR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Dynamic Language Runtime** (**DLR**) was introduced in .NET 4 back in
    2010\. It runs on top of the .NET runtime, **Common Language Runtime** (**CLR**),
    providing language services for dynamic languages such as Python and Ruby through
    the IronPython and IronRuby implementations. With the DLR, it is also possible
    to interop between the different languages, effectively making it possible to
    have C# and Python, Ruby, or any other dynamic language that is supported run
    side by side in the same process.
  prefs: []
  type: TYPE_NORMAL
- en: The CLR at a glance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into the DLR, it’s helpful to understand the constraints it has
    to work with. The CLR is at the heart of everything .NET, which means that everything
    running has to abide by the rules of the CLR. That becomes very interesting when
    looking at the traits of the CLR.
  prefs: []
  type: TYPE_NORMAL
- en: Just-in-Time (JIT) compilation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CLR compiles the **Intermediate Language** (**IL**) code into native code
    for the specific machine and operating system at runtime, using the JIT compiler.
    This process enables better optimization, faster execution, and cross-platform
    compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic memory management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CLR manages memory allocation and deallocation using garbage collection,
    which automatically frees up memory occupied by objects that are no longer in
    use. This helps prevent memory leaks and optimizes memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Type safety
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CLR ensures type safety by enforcing strict rules during code execution.
    This helps prevent invalid memory operations, such as accessing a memory location
    that has not been initialized or using an object of one type as another type.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CLR provides a consistent and robust exception-handling mechanism across
    all .NET languages, allowing developers to handle runtime errors gracefully and
    maintain application stability.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-language Interoperability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CLR supports interoperability between .NET languages, allowing developers
    to use components written in different languages within the same application.
    This promotes code reusability and simplifies the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning and assembly management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CLR manages the versioning of assemblies (compiled code units), helping
    to prevent issues such as “DLL hell,” where conflicting versions of shared libraries
    cause application instability. It also provides features such as side-by-side
    execution, allowing multiple versions of an assembly to coexist on the same system.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CLR enables developers to inspect and interact with metadata about types,
    objects, and assemblies at runtime. This allows dynamic type creation, method
    invocation, and other advanced programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and profiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CLR provides integrated support for debugging and profiling .NET applications,
    enabling developers to diagnose and optimize code efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: The DLR building blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For any of the dynamic languages to work, the DLR needs to support a few things
    that are very different from the more static world of the CLR. The following traits
    are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic type system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A dynamic runtime needs to be able to create types on the fly. A type is never
    static and should be able to be expanded on.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic dispatching of methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A dynamic runtime should allow calling methods that aren’t known beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic code generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A dynamic runtime should allow for code generation at runtime, allowing you
    to add code based on input or the result of other code dynamically. It should
    also allow you to modify code.
  prefs: []
  type: TYPE_NORMAL
- en: From a CLR perspective, these types of traits seem very unaligned. The engineers
    at Microsoft extended the core functionality and put in place a dynamic runtime
    that works well with the CLR.
  prefs: []
  type: TYPE_NORMAL
- en: From a metaprogramming perspective, the traits of a dynamic runtime are perfect.
    As part of the DLR, there is a collection of constructs and APIs that enables
    you to dynamically create types and also reason about any dynamic type that fulfills
    the traits we’re looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Since the .NET runtime itself is a static runtime and relies on well-known types
    with fixed members, the DLR needs to work with this constraint. The DLR, therefore,
    provides a set of classes and interfaces to represent dynamic objects, their properties,
    and operations, such as **IDynamicMetaObjectProvider**, **DynamicMetaObject**,
    **DynamicObject**, and **ExpandoObject**.
  prefs: []
  type: TYPE_NORMAL
- en: For the DLR to work with dynamic languages, it needs a way to represent the
    language semantics. The DLR uses expression trees, which we looked at in more
    detail in [*Chapter 7*](B19418_07.xhtml#_idTextAnchor118), *Reasoning about Expressions*,
    and [*Chapter 8*](B19418_08.xhtml#_idTextAnchor132), *Building and Executing Expressions*.
    With the DLR comes a set of extensions to LINQ expressions that give us control
    flow, assignment, and other language-modeling nodes.
  prefs: []
  type: TYPE_NORMAL
- en: From a compiler perspective, the C# compiler has a keyword called **dynamic**
    that lets you say that a particular variable or argument is of a dynamic type.
    That tells the compiler to not evaluate any member accesses during compile time
    for the instance. Instead, it translates all this into the appropriate **Expression**
    that will execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with leveraging the DLR and its dynamic capabilities, the easiest
    way is to use the **ExpandoObject** type. **ExpandoObject** provides a type that
    can be dynamically expanded on; it will hold anything you tell it to and can expand
    as you proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code creates an instance of **ExpandoObject** and then starts setting values
    on it. **ExpandoObject** does not have **FirstName** or **LastName** as part of
    its type, but by setting them, the values will be there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing these members will be the same; the compiler understands that **ExpandoObject**
    is **dynamic** and will try to bind to the members at runtime rather than at compile
    time. The following code will be completely valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**ExpandoObject** does this by implementing the **IDynamicMetaObjectProvider**
    interface. With **IDynamicMetaObjectProvider**, it provides its own implementation
    of **DynamicMetaObject** that really holds all the magic of doing the actual binding
    of the operations we tell it to do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **ExpandoObject** type also implements the **IDictionary<string, object?>**
    interface, which is how it represents all the members given to it and also how
    it can dynamically grow. Through its implementation of **DynamicMetaObject**,
    it basically just works on the internal dictionary. In fact, it is fully possible
    to work with **ExpandoObject** as a dictionary if you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you’re using **dynamic** for data objects, this can be really handy, as it
    gives you a simple way to reason about an object and its content and, at the same
    time, a convenient programming experience by treating it as a dynamic object with
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Call sites and binders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you want to perform an operation on a dynamic object – for instance,
    a get or set property or a method call – it goes through something called a **call
    site**. A call site is effectively the location at runtime of the code that will
    execute. For compiled C#, this will be the memory location where the IL code typically
    resides. For other languages, such as Ruby or Python, this would be the location
    in the textual code. Every language has its own call site representation.
  prefs: []
  type: TYPE_NORMAL
- en: The big difference between static languages and dynamic languages is that the
    static languages are compiled, and at runtime, they’re either executing some sort
    of intermediate language or actual machine language. Alternatively, a dynamic
    language will interpret code at runtime and execute the result. The benefit of
    a dynamic language then is that it can change its own code dynamically, obviously
    with the downside of a loss in performance.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the location, or the call site, you can bind to the member and
    then perform the operation you want.
  prefs: []
  type: TYPE_NORMAL
- en: There are binders for the typical operations you want to perform on an object
    – the get and set properties, invoke methods, indexing, and so on. Throughout
    the book, we’ve looked at the power of metadata and how we can reason about the
    running code; the DLR poses some challenges with this.
  prefs: []
  type: TYPE_NORMAL
- en: Reasoning about a dynamic type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DLR is very limited in what it is possible to reason about for a dynamic
    type. Primarily, the DLR is built to be able to host dynamic languages. Naturally
    with dynamic languages, you don’t really know what’s going on with a dynamic type,
    and it can change over time, so even though a member is already there, the DLR
    can’t provide you a reflective experience by giving you any details, such as type
    information, about the member.
  prefs: []
  type: TYPE_NORMAL
- en: One thing we can do, however, is ask it what members it has. Every dynamic object
    implements an interface called **IDynamicMetaObjectProvider**. On this, you can
    call the **GetMetaObject()** method to get an object that allows us to interact
    with the dynamic object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at **ExpandoObject** with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since **ExpandoObject** does, in fact, implement **IDynamicMetaObjectProvider**,
    we can ask it for its meta-object and then its members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code will give you the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code itself assumes it is **IDynamicMetaObjectProvider** by casting it to
    a type, in order for us to call **GetMetaObject()**. The **Expression** we create
    represents the instance of the person that we’re getting the meta-object for.
    Then, we call **GetDynamicMemberNames()**, which returns a collection of strings
    with all its member names.
  prefs: []
  type: TYPE_NORMAL
- en: This is the extent of what it is possible to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can dynamically invoke the members, which comes in handy when you
    don’t know the shape of the object. It can be a bit challenging to invoke when
    you don’t really know what the object holds, and if you want to support everything,
    you’ll need fallback mechanisms, as the runtime will throw **RuntimeBinderException**
    if it can’t bind the way you want to.
  prefs: []
  type: TYPE_NORMAL
- en: '**DynamicMetaObject** has a set of methods with all the binding you can do.
    These *bind* methods require an actual binder, which you can get from the call
    site. After bind, you will get a new **DynamicMetaObject**. It is possible to
    use all of these things to get to the actual value, but let’s jump directly to
    the C# binder, get the binder we want, and use that instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Microsoft.CSharp.RuntimeBinder** namespace, there is a class called
    **Binder**. This class holds a set of static methods to get specific binders.
    The types of binders you can use are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **BinaryOperation** | Used for binary operations |'
  prefs: []
  type: TYPE_TB
- en: '| **Convert** | Used to convert to a specific type |'
  prefs: []
  type: TYPE_TB
- en: '| **GetIndex** | Used to get an index |'
  prefs: []
  type: TYPE_TB
- en: '| **GetMember** | Used to get a member’s value |'
  prefs: []
  type: TYPE_TB
- en: '| **Invoke** | Used to invoke a method |'
  prefs: []
  type: TYPE_TB
- en: '| **InvokeConstructor** | Used to invoke/construct a constructor |'
  prefs: []
  type: TYPE_TB
- en: '| **SetIndex** | Used to set an index |'
  prefs: []
  type: TYPE_TB
- en: '| **SetMember** | Used to set a member to a value |'
  prefs: []
  type: TYPE_TB
- en: '| **UnaryOperation** | Used for unary operations |'
  prefs: []
  type: TYPE_TB
- en: 'Since the object we have only has properties, we will use the **GetMember**
    binder to get the property value and, ultimately, the actual value through the
    call site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code builds on the **meta** instance we got from **GetMetaObject()** and
    iterates through the member names returned by **GetDynamicMemberNames()**. For
    each member, you can then get the binder for it – in our case, the **GetMember**
    binder – passing default values to it with **member** and the **person** type.
  prefs: []
  type: TYPE_NORMAL
- en: In the **System.Runtime.CompilerService** namespace, you’ll find a class called
    **CallSite<>**. This is a dynamic site type that can be used to create a call
    site for the binder dynamically. In our case, the dynamic site will be a delegate,
    **Func<>**, that allows us to call it with **person** and get a value back. The
    types going in and out are both **object**, since the actual type is unknown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code should give you this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The code assumes that all members are properties, which can fail with **RuntimeBinder**
    **Exception**. If you need to support more member types, you would need to handle
    that exception and fall back to the ones you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach you could use is to use expressions. The **Expression** class
    has a **Dynamic** method that lets you pass in the binder and then create a **Lambda**
    expression, which gives you a similar **Func<>** delegate that can be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following gives you a method that can be called to create **Func<>**, which
    we can call to get the values of members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code gets the **GetMember** binder and then creates **DynamicExpression**,
    which involves a conversion of the instance we will pass to **object**. Then,
    the code creates a **Lambda** expression, which we then compile for more performant
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This new method can then be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since the DLR itself is limited in discoverability and reasoning about what
    is there, it might be a good idea in some use cases to provide the metadata yourself,
    using other formats and approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Creating DynamicObject and providing metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you don’t have the luxury of having your types represented in code.
    This could be if you’re calling an external API of some sort, be it a REST API,
    SOAP service, or similar. However, the third party you’re calling might have a
    representation of the type in a standard format, such as a WSDL or JSON schema.
  prefs: []
  type: TYPE_NORMAL
- en: Even though dynamic objects can be very flexible, in the real world the shape
    of data tends to be stricter. So, instead of using **ExpandoObject** for everything,
    you could represent these types with a custom dynamic object that gets its metadata
    from a well-known format. It’s very common today to use JSON as a data carrier,
    and it’s also common to represent the shape of data by leveraging JSON schemas.
    Let’s look at how that could be a provider of metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Building a JSON schema type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by creating a folder called **Chapter9**. Change into this folder in
    your command-line interface and create a new console project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will rely on a third-party library, giving us an easy way of working with
    JSON schemas. Add the package to the project by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A JSON schema is a simple structure that describes a type, its properties,
    and the type of every property. It is, however, limited to the types available
    to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, a JSON schema does support a concept of *format* that can be used as
    a sub-type for types. For instance, dates are not part of the JSON type system,
    but having a property of type **string** and a format of type **date** would allow
    you to support any type you want, since strings can hold anything.
  prefs: []
  type: TYPE_NORMAL
- en: JSON schemas can also hold sub-schemas, which makes it possible to have strongly
    typed object definitions within an object.
  prefs: []
  type: TYPE_NORMAL
- en: For this sample, we’re going to keep it very simple and stick with simple types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **person.json** to your project and add the following to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the JSON, you’ll find the **title** property, which is the name of the type,
    and the **type** property is set to **object**, since it describes an object.
    The schema then contains three properties with the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| FirstName | String |'
  prefs: []
  type: TYPE_TB
- en: '| LastName | String |'
  prefs: []
  type: TYPE_TB
- en: '| Birthdate | Date |'
  prefs: []
  type: TYPE_TB
- en: Table 9.1 – A schema for a person
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **JsonSchemaType.cs**, and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code creates a new type called **JsonSchemaType** that inherits from the
    **DynamicObject** type found in the **System.Dynamic** namespace. This particular
    type is a helper type, created to make it easier to implement dynamic objects.
    To represent the actual content of the type, the code adds **Dictionary<string,
    object?>**. This gives you the flexibility of putting anything into it, much like
    **ExpandoObject** does. The reason for **object?** as the value type is to allow
    anything and also make it explicit that we allow null values in it. The constructor
    takes a **JsonSchema** type from the **NJsonSchema** dependency you added earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Validating properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since JSON schemas give you a full description of a type, its properties, and
    the types for the properties, it gives you an opportunity to validate the values
    being set on the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s introduce some basic validation into the object. Start by adding a new
    file that will give us an explicit exception describing the problem that can occur.
    Add a file called **InvalidTypeForProperty.cs**, and add the following code to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The custom exception takes two properties – the name of the type that owns the
    errored property and then the actual property that was wrong. You could also include
    for good measure the type it was trying to set and what was expected, but to keep
    the sample simple, let’s just go with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do the actual validation, you’ll need something that translates from the
    .NET type to **JsonObjectType**. Go back to the **JsonSchemaType.cs** file and
    add a method that does the necessary translations from the .NET type to a **JsonObjectType**.
    Add the following method to the **JsonSchemaType** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code uses a simple pattern matching and converts from the .NET type to **JsonObjectType**.
    It defaults to **JsonObjectType.Object** for anything it doesn’t have an explicit
    conversion for.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This implementation is very simplistic and does not cover all the .NET types,
    and you should probably make it a bit more sophisticated for production. Hopefully,
    though, it gives you a general idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a way of converting from a CLR type to **JsonObjectType**,
    you need a way to actually do the validation. Add the following method to the
    **JsonSchemaType** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code only validates a value if it is not null, since you wouldn’t be able
    to know its type unless it has a value. With the type, it gets the actual schema
    type and then checks whether or not the property has this type. **JsonObjectType**
    is an enum of flags, and combinations are allowed, which is why you have to use
    the **HasFlag** method. If it’s not the correct type, the code throws the **InvalidTypeForProperty**
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A tip here would be to also validate whether null is allowed or not. This information
    is also supported by JSON schemas. Some types also inherently don’t allow nulls,
    such as integers or Booleans, and you should probably not allow that.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing getting and setting properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the constructor and validation in place, you’re now ready to override some
    of the default behavior of the **DynamicObject** type. The **DynamicObject** type
    offers a set of virtual methods that can be overridden for the different operations
    that can be performed, such as getting or setting properties and invoking methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this sample, we will focus primarily on properties. Add the following method
    to the **JsonSchemaType** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The **TrySetMember** signature takes **SetMemberBinder**, which holds the information
    about the property being set. It also gets the value, which can be null. The code
    then first validates whether or not the property actually exists in the schema
    by looking into the **ActualProperties** dictionary. If it does not exist, it
    immediately returns **false**, and if you were to try to set an unknown property,
    you would then get **RuntimeBinderException**. When the property exists, the code
    validates the type of the value. If the type is correct, the code then sets the
    value in its private dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have set a property, you also want to read it. Add the following method
    to the **JsonSchemaType** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the **TrySetMember**, the code adds a check on whether or not the
    schema has the property. However, since this is a **get** operation and the signature
    of the method dictates that the result should be given as an **out** parameter,
    we need to explicitly set it to **null!**. The code then checks whether the private
    dictionary contains a value for the property and returns it if it does or returns
    a **null!** value if not.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In a production system, you would typically not want to return just **null**
    if the value is not set. It should be set to either the default value of the type
    or, if the JSON schema holds additional metadata with a default value, you should
    use that.
  prefs: []
  type: TYPE_NORMAL
- en: As a *nice-to-have* feature, we want to allow this type to be converted to another
    type – in our case, **Dictionary<string, object?>**.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the methods that **DynamicObject** provides that can be overridden is
    the **TryConvert** method. This method will be called if an explicit cast is done
    from the type to a different target type. Add the following method to the **JsonSchemaType**
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The code only allows conversion to **Dictionary<string, object?>**, so it checks
    for this first by looking at the **Type** property of the **ConvertBinder** type
    being passed in. It is a good practice to return values for all properties in
    the schema and not leave out any properties, and since all properties might be
    set, the code creates a new dictionary from the existing **_values** dictionary
    and then finds any properties that are missing. For every property that is missing,
    it sets a default value.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The default values have been simplified. As mentioned earlier, for production
    you should consider a more sophisticated approach to default values and look at
    possible additional metadata in the JSON schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of the puzzle we want to add is the ability for outsiders to
    reason about what members are available. The **DynamicObject** type gives us a
    method that can be overridden for this. Add the following method to the **JsonSchemaType**
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This method will be called by **DynamicMetaObject** that **DynamicObject** produces.
    **DynamicObject** is also **IDynamicMetaObjectProvider** and implements the **GetMetaObject()**
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '**DynamicObject** has more methods that can be overridden to invoke methods,
    perform binary operations, and so on. However, for this sample, we will focus
    on the data aspects with properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the schema infrastructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What you’ve built so far is an infrastructure to work with JSON schemas, together
    with the DLR. Let’s take **JsonSchemaType** out for a spin. Open the **Program.cs**
    file and take out all its content. Add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The code reads the JSON schema from the **person.json** file you created earlier.
    Then, it creates an instance of **JsonSchemaType** and hands it the schema. Since
    **JsonSchemaType** is a dynamic object, it implements **IDynamicMetaObjectProvider**,
    and we can call the **GetMetaObject()** method with the instance of the object
    and then get its members.
  prefs: []
  type: TYPE_NORMAL
- en: 'When run, the code should produce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting and getting properties should work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code should give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the implementation of **JsonSchemaType** supports default values for
    properties that have not been set, you can get a valid property without any problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting this property to a dictionary should also work out of the box through
    an explicit cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the validation, you can try to set the **LastName** property to an
    unsupported type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we can do to verify that all is working as expected is to set
    a property that does not exist in the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Working with the **DynamicObject** helper type eases the development of dynamic
    objects, as you don’t have to worry about the complexity of the moving parts and
    can focus on the actual shape and capabilities of the dynamic object you want
    to provide.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored the dynamic realm of the .NET runtime and how you can
    take advantage of it to create dynamic types that have its types defined outside
    of C# code. When working with third parties through APIs, this approach can be
    very handy. If you look at REST APIs and the OpenAPI standard, you’ll see extensive
    use of JSON schemas, and marrying the approach in this chapter with such standards
    can provide you a powerful mechanism to dynamically integrate with third parties,
    and at the same time, you can be strict about the shape.
  prefs: []
  type: TYPE_NORMAL
- en: The DLR can be a powerful tool in your toolbox. It provides another approach
    to dynamically create types and code. Compared to generating intermediate language
    code, it can come across as more intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: One of the downsides of the DLR is that the types generated can be hard to work
    with in a modern IDE or code editor, as it does not know about the types and can’t
    offer services such as IntelliSense for members.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of using the DLR and a dynamic approach can be performance. It
    will not be as performant as generating intermediate language code. This is one
    of the trade-offs you will have to make, but for specific scenarios, that might
    not be an issue at all.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will shift gears a little bit and look at how we can
    take advantage of some of the techniques we’ve discussed so far in the book and
    start thinking in terms of **convention** **over configuration**.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3:Increasing Productivity, Consistency, and Quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will see how metaprogramming can be used to improve code quality
    and leave you with a more maintainable and consistent code base. At the same time,
    this part gives you ideas on how techniques can improve the productivity of you
    and your developers. The different chapters touch on principles and software design
    patterns and how they can be used in real life.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19418_10.xhtml#_idTextAnchor162), *Convention over Configuration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19418_11.xhtml#_idTextAnchor177), *Applying the Open-Closed
    Principle*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19418_12.xhtml#_idTextAnchor196), *Go Beyond Inheritance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19418_13.xhtml#_idTextAnchor206), *Applying Cross-Cutting Concerns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19418_14.xhtml#_idTextAnchor219), *Aspect-Oriented Programming*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
