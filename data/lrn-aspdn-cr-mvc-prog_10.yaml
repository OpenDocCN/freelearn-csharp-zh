- en: Chapter 10. Building HTTP-based Web Services Using ASP.NET Web API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。使用ASP.NET Web API构建基于HTTP的Web服务
- en: So far, we have learned how to create web applications using ASP.NET Core. But
    there are times when simply creating a web application is not enough. Let's assume
    you are using ASP.NET Core to create a web application that provides weather information
    for all the cities across the world. People access your web application to find
    out weather information, and they are satisfied with the service. But this weather
    information may be needed by many other websites or web applications, such as
    tourism websites, news websites, and many other mobile applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用ASP.NET Core创建Web应用程序。但有时仅仅创建一个Web应用程序是不够的。让我们假设你正在使用ASP.NET
    Core创建一个提供全球所有城市天气信息的Web应用程序。人们访问你的Web应用程序以获取天气信息，并且对服务感到满意。但这个天气信息可能被许多其他网站或Web应用程序需要，例如旅游网站、新闻网站以及许多其他移动应用程序。
- en: Instead of writing the code all over again for their websites, you can create
    and publish the web services and the websites can consume the required web services
    whenever they need to.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为他们的网站重新编写代码，你可以创建和发布Web服务，网站可以在需要时消费所需的Web服务。
- en: 'In this chapter, you are going to learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: What an HTTP-based service is and how it is useful
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于HTTP的服务是什么以及它如何有用
- en: What Fiddler is
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fiddler是什么
- en: How to compose an HTTP request using Fiddler and fire the same in order to get
    an HTTP response
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Fiddler组合HTTP请求并触发以获取HTTP响应
- en: How to design and implement the HTTP service using Web API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Web API设计和实现HTTP服务
- en: 'Microsoft provides ASP.NET Web API for programmers to build HTTP-based services.
    But HTTP is not just used to serve the webpages. You can use HTTP as a platform.
    This brings several advantages:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 微软为程序员提供了ASP.NET Web API来构建基于HTTP的服务。但HTTP不仅仅用于服务网页。你可以将HTTP作为一个平台。这带来了几个优势：
- en: As web services built using ASP.NET Web API use HTTP for communication, these
    web services can be consumed from all kinds of applications from console applications
    to web applications, and from WCF services to mobile applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于使用ASP.NET Web API构建的Web服务使用HTTP进行通信，因此这些Web服务可以从各种应用程序中消费，从控制台应用程序到Web应用程序，以及从WCF服务到移动应用程序
- en: Whenever there is any change in the logic/code of the web services, the clients
    (the websites that consume the services) do not need to change anything. They
    can consume the web services just as they were consuming them earlier
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论何时，只要Web服务的逻辑/代码有任何变化，客户端（使用这些服务的网站）都不需要做任何改变。他们可以像之前一样消费Web服务
- en: HTTP basics
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP基础知识
- en: HTTP is a powerful platform for building services. You can use the existing
    HTTP verbs to build services. For example, you can use the existing HTTP verb
    GET to get the list of products or POST to update information about the product.
    Let's take a quick look at how HTTP works with respect to building the services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是构建服务的强大平台。你可以使用现有的HTTP动词来构建服务。例如，你可以使用现有的HTTP动词GET来获取产品列表或POST来更新产品信息。让我们快速看一下HTTP在构建服务方面的作用。
- en: There is no difference in the underlying mechanism between serving the HTML
    pages in ASP.NET MVC and serving the data in the context of HTTP services. Both
    follow a request-response pattern and the same routing mechanism.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET MVC中服务HTML页面和在HTTP服务上下文中服务数据的基本机制之间没有区别。两者都遵循请求-响应模式以及相同的路由机制。
- en: 'An HTTP request can be sent from any client (desktop, laptop, tablet, mobile,
    and so on) to the server and the server will respond back with an HTTP response.
    An HTTP response can be sent to the client in any format such as JSON or XML.
    This is shown in the following figure:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个HTTP请求可以从任何客户端（桌面、笔记本电脑、平板电脑、手机等等）发送到服务器，服务器将回送一个HTTP响应。HTTP响应可以以任何格式发送到客户端，例如JSON或XML。这将在以下图中展示：
- en: '![HTTP basics](img/Image00194.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP基础知识](img/Image00194.jpg)'
- en: In the preceding diagram, a request is sent from the desktop computer (it could
    equally be sent from a mobile or tablet; it makes no difference) and the server
    sends back the HTTP response for the request. As HTTP is supported in most of
    the devices, it is ubiquitous.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，请求是从桌面计算机发送的（它同样可以从手机或平板电脑发送；没有区别）并且服务器为请求发送HTTP响应。由于HTTP在大多数设备上得到支持，因此它是无处不在的。
- en: HTTP verbs
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP动词
- en: HTTP verbs describe how the request has to be sent. These are the methods defined
    in HTTP that dictate how the HTTP requests are sent from the client to the server
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 动词描述了请求必须如何发送。这些是在 HTTP 中定义的方法，规定了 HTTP 请求从客户端发送到服务器的方式
- en: GET method
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GET 方法
- en: 'When we use an HTTP GET request, the information is passed through the URL
    itself:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 HTTP GET 请求时，信息通过 URL 本身传递：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This `GET` request gets the employee information based on the passed ID. The
    advantage of using the `GET` request is that it is lightweight, and all the required
    information will be passed in the URL or header itself, as shown in the following
    diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `GET` 请求根据传递的 ID 获取员工信息。使用 `GET` 请求的优势在于它轻量级，所有必要的信息都会通过 URL 或头信息本身传递，如下面的图所示：
- en: '![GET method](img/Image00195.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![GET 方法](img/Image00195.jpg)'
- en: PUT method
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PUT 方法
- en: 'The `PUT`  method is used to create a resource or to update it. `PUT` is an
    idempotent operation, meaning that the expected behavior would not change even
    if it is executed multiple times:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT` 方法用于创建资源或更新它。`PUT` 是一个幂等操作，这意味着即使多次执行，预期的行为也不会改变：'
- en: '![PUT method](img/Image00196.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![PUT 方法](img/Image00196.jpg)'
- en: POST method
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POST 方法
- en: 'You can use POST to create or update the resource. Usually, POST is used to
    create the resource rather than update it. As per HTTP standards, whenever you
    create a new resource, you should return a **201 HTTP** status code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 POST 来创建或更新资源。通常，POST 用于创建资源而不是更新它。根据 HTTP 标准，每次创建新资源时，都应该返回一个 **201 HTTP**
    状态码：
- en: '![POST method](img/Image00197.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![POST 方法](img/Image00197.jpg)'
- en: DELETE method
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DELETE 方法
- en: 'The DELETE method is used to delete the resource. Usually, when you delete
    a resource, you would be passing the ID as a parameter, and you would not be passing
    anything in the body of the request:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: DELETE 方法用于删除资源。通常，当你删除资源时，你会传递一个 ID 作为参数，并且你不会在请求体中传递任何内容：
- en: '![DELETE method](img/Image00198.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![DELETE 方法](img/Image00198.jpg)'
- en: Usually, HTTP services would be consumed by other applications and services.
    Applications that consume services are referred to as clients. One of the options
    to test HTTP services is to build the clients. But this would be time-consuming,
    and we may throw away the client code once we test the HTTP services.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，HTTP 服务会被其他应用程序和服务消费。消费服务的应用程序被称为客户端。测试 HTTP 服务的一个选项是构建客户端。但这会耗费时间，一旦测试了
    HTTP 服务，我们可能会丢弃客户端代码。
- en: Another option, which is widely used, is to use applications that enable us
    to fire HTTP requests and monitor the responses. There are many applications available,
    Fiddler being one such widely used application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个广泛使用的选择是使用能够让我们发送 HTTP 请求并监控响应的应用程序。有许多应用程序可供选择，Fiddler 就是其中广泛使用的一个。
- en: Fiddler tool
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fiddler 工具
- en: Fiddler is the proxy server application used to monitor the HTTP and HTTPS traffic.
    You can monitor the requests that are being sent to the server from the client,
    the responses that are sent to the client, and the responses that are being received
    from the server. It is like seeing the traffic in the pipe between the server
    and the client. You can even compose a request, fire it, and analyze the response
    received without ever needing to write the client for the services.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Fiddler 是一个代理服务器应用程序，用于监控 HTTP 和 HTTPS 流量。您可以监控从客户端发送到服务器的请求，发送到客户端的响应，以及从服务器接收到的响应。这就像看到服务器和客户端之间管道中的流量。您甚至可以编写请求，发送它，并分析收到的响应，而无需为服务编写客户端。
- en: 'You can download Fiddler at [http://www.telerik.com/fiddler](http://www.telerik.com/fiddler)
    . You''ll see the following window:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [http://www.telerik.com/fiddler](http://www.telerik.com/fiddler) 下载 Fiddler。您将看到以下窗口：
- en: '![Fiddler tool](img/Image00199.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Fiddler 工具](img/Image00199.jpg)'
- en: Enough theory. Let us create a simple web service using ASP.NET Web API.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够。让我们使用 ASP.NET Web API 创建一个简单的 Web 服务。
- en: 'Fire up Visual Studio 2015:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015：
- en: '![Fiddler tool](img/Image00200.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![Fiddler 工具](img/Image00200.jpg)'
- en: When you click **OK** , a Web API solution will be created. Just as the ASP.NET
    Core application controller inherits from the Controller class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击 **确定** 时，将创建一个 Web API 解决方案。就像 ASP.NET Core 应用程序控制器从 Controller 类继承一样。
- en: '![Fiddler tool](img/Image00201.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Fiddler 工具](img/Image00201.jpg)'
- en: The Web API class will also inherit from the same Controller class. This is
    the difference between ASP.NET Core and earlier versions of ASP.NET MVC. In earlier
    versions, all Web API controller classes inherited from the `ApiController` class.
    In ASP.NET 5, it has been unified, and the same base Controller class is being
    used for both building web applications and services.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Web API类也将继承相同的Controller类。这是ASP.NET Core与早期版本的ASP.NET MVC之间的区别。在早期版本中，所有Web
    API控制器类都继承自`ApiController`类。在ASP.NET 5中，它已经统一，相同的基类Controller被用于构建Web应用程序和服务。
- en: 'The following is the `ValuesController` class that will be created by default
    when you choose the **Web API** template option when creating the project:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在创建项目时选择**Web API**模板选项时默认创建的`ValuesController`类：
- en: '![Fiddler tool](img/Image00202.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Fiddler工具](img/Image00202.jpg)'
- en: Before we create our own custom Controller, let's analyze the default API Controller.
    In the `ValuesController` file, several API methods are already defined.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建自己的自定义Controller之前，让我们分析默认的API Controller。在`ValuesController`文件中，已经定义了几个API方法。
- en: There are two overloaded `GET` methods—one with a parameter and another without
    a parameter. The `GET` method without a parameter returns all the resources of
    the type. In this case, we are returning just a couple of strings. In the real
    world, we would be returning the metadata of the resources. For example, if we
    fire the `GET` request on the movies API Controller, it would return information
    about all the movies. The `GET` method with an `id` parameter returns the resource
    whose ID matches with the passed ID. For example, if you pass a movie ID, it would
    return the information about that movie. The body of the other methods, such as
    `PUT` , `POST` , and `DELETE` , are empty in this Controller, and we will talk
    about these methods later.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个重载的`GET`方法——一个带有参数，另一个不带参数。不带参数的`GET`方法返回该类型的所有资源。在这种情况下，我们只返回几个字符串。在现实世界中，我们会返回资源的元数据。例如，如果我们对电影API控制器发起`GET`请求，它会返回关于所有电影的信息。带有`id`参数的`GET`方法返回与传递的ID匹配的资源。例如，如果你传递一个电影ID，它会返回关于该电影的信息。其他方法（如`PUT`、`POST`和`DELETE`）的正文在这个控制器中为空，我们将在稍后讨论这些方法。
- en: 'When you run the application, you will get the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，你会得到以下输出：
- en: '![Fiddler tool](img/Image00203.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Fiddler工具](img/Image00203.jpg)'
- en: By default, it fires a request to `api/values` , and the values are displayed
    in the browser.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它会向`api/values`发起请求，并在浏览器中显示这些值。
- en: 'Let''s learn how to fire an HTTP request from the Fiddler application. Open
    the Fiddler application. In the bottom left-hand corner, select the **Web Browsers**
    option in the red box. Choosing this option will enable us to view the traffic
    coming from the **Web Browsers** :'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何在Fiddler应用程序中发起HTTP请求。打开Fiddler应用程序。在左下角，选择红色方框中的**Web浏览器**选项。选择此选项将使我们能够查看来自**Web浏览器**的流量：
- en: '![Fiddler tool](img/Image00204.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Fiddler工具](img/Image00204.jpg)'
- en: 'Select the **Composer** tab, enter the URL `http://localhost:49933/api/values`
    , as shown in the following screenshot, and click the **Execute** button in the
    top right-hand corner:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**作曲家**选项卡，输入URL `http://localhost:49933/api/values`，如以下截图所示，然后在右上角点击**执行**按钮：
- en: '![Fiddler tool](img/Image00205.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Fiddler工具](img/Image00205.jpg)'
- en: Once you click the **Execute** button, an HTTP session will be created, visible
    on the left-hand side pane (highlighted in the blue box). Click on the session
    and select the **Inspectors** tab on the top right-hand side pane. Select the
    JSON tab in the bottom right-hand side pane (highlighted by the purple-bordered
    box in the following screenshot).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击**执行**按钮，就会创建一个HTTP会话，在左侧面板中可见（如蓝色方框所示）。点击会话，然后在右上角面板中选择**检查器**选项卡。在右下角面板中选择JSON选项卡（如下面的截图所示，由紫色边框突出显示）。
- en: 'You can see the JSON data returned from the HTTP request— **value1** and **value2**
    in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到HTTP请求返回的JSON数据——以下截图中的**value1**和**value2**：
- en: '![Fiddler tool](img/Image00206.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Fiddler工具](img/Image00206.jpg)'
- en: Now it's our turn to write a custom API.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到我们编写自定义API了。
- en: In this custom API, we are going to provide API methods to create an employee
    object, list all the employee objects, and delete an employee object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个自定义API中，我们将提供创建员工对象、列出所有员工对象以及删除员工对象的API方法。
- en: 'First, let us create a model for the employee. We need to create a folder to
    hold these models. Right-click on the project, select **Add**  | **New folder**
    , and name the folder as `Models` :'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为员工创建一个模型。我们需要创建一个文件夹来存放这些模型。右键单击项目，选择 **添加** | **新建文件夹**，并将文件夹命名为 `Models`：
- en: '![Fiddler tool](img/Image00207.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Fiddler 工具](img/Image00207.jpg)'
- en: 'Right-click on the `Models` folder and select **Add** |  **New Item…**  to
    create an employee model class. This employee model class is just a POCO class.
    See the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击 `Models` 文件夹，选择 **添加** | **新建项…** 来创建一个员工模型类。这个员工模型类只是一个 POCO 类。请看以下代码：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we define the repository interface to handle the model:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义存储库接口来处理模型：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then we implement the interface for this model:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为这个模型实现接口：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are few things to be noted in the implementation class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现类中需要注意以下几点：
- en: We have decided not to use the database as our objective is to create an HTTP
    service using Web API, and not to write the data access code.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们决定不使用数据库，因为我们的目标是使用 Web API 创建一个 HTTP 服务，而不是编写数据访问代码。
- en: We are using an in-memory list to hold the data. All the operations will be
    performed on this list. As a matter of fact, the data could be in any form, ranging
    from relational databases to a simple in-memory list.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用内存中的列表来存储数据。所有操作都将在这个列表上执行。实际上，数据可以是任何形式，从关系型数据库到简单的内存列表。
- en: In the constructor method, we are adding an object to the list. This list will
    be acting as the database for our HTTP service.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造函数方法中，我们正在将一个对象添加到列表中。这个列表将作为我们 HTTP 服务的数据库。
- en: The `GetAllEmployees` API method will return all the employees as the `IEnumerable`
    interface.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetAllEmployees` API 方法将返回所有员工作为 `IEnumerable` 接口。'
- en: The `AddEmployee`  method will add the employee (passed as a parameter) to the
    list.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddEmployee` 方法会将传入的员工（作为参数）添加到列表中。'
- en: The `GetEmployee`  method will return the employee whose ID matches that of
    the parameter.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetEmployee` 方法将返回与参数 ID 匹配的员工。'
- en: The `RemoveEmployee`  method will remove the employee from the list.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveEmployee` 方法将从列表中删除员工。'
- en: The `UpdateEmployee`  method will update the employee information.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateEmployee` 方法将更新员工信息。'
- en: The `GetNextRandomId` method will return the next available random integer.
    This integer value is being used to generate the employee ID.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetNextRandomId` 方法将返回下一个可用的随机整数。这个整数值被用来生成员工 ID。'
- en: Dependency Injection
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: In most real-world projects, we do not instantiate any objects using the `new`
    instance in any of the Controllers, the reason being that we don't want to have
    tight coupling between the dependent components (between the Controller and the
    repository). Instead, we pass an interface to the Controller, and the Dependency
    Injection container (such as **Unity** ) will create an object for us when it
    is needed for the Controller. This design pattern is commonly referred to as **Inversion
    of Control** .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数实际项目中，我们不会在任何一个控制器中使用 `new` 实例化任何对象，原因是我们不希望依赖组件（控制器和存储库之间）之间有紧密耦合。相反，我们向控制器传递一个接口，当需要为控制器创建对象时，依赖注入容器（如
    **Unity**）会为我们创建对象。这种设计模式通常被称为 **控制反转**。
- en: Let's say that a class by the name of *ClassA* uses another class, *ClassB*
    . In this case, it is enough for *ClassA* to know about the behavior, methods,
    and properties of *ClassB* , and it doesn't need the internal implementation details
    of *ClassB* . So, we can abstract *ClassB* and make an interface out of the class,
    and then have that interface as the parameter instead of the concrete class. The
    advantage of this approach is that we can pass any class at runtime as long as
    it implements a commonly agreed contract (interface).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个名为 *ClassA* 的类使用了另一个名为 *ClassB* 的类。在这种情况下，*ClassA* 只需要知道 *ClassB* 的行为、方法和属性，而不需要知道
    *ClassB* 的内部实现细节。因此，我们可以抽象 *ClassB* 并将其转换为接口，然后使用这个接口作为参数，而不是具体的类。这种方法的优点是，只要它实现了一个共同约定的合同（接口），我们就可以在运行时传递任何类。
- en: 'In ASP.NET 5 (including ASP.NET Core and Web API), we have inbuilt support
    for Dependency Injection. In the `ConfigureServices` method, we have added the
    line (highlighted in bold) that performs the Dependency Injection. We instruct
    the inbuilt Dependency Injection container to create the `EmployeeRepository`
     class wherever we are referring to the `IEmployeeRepository`  interface and we
    also instruct it to be a singleton; meaning that the same object (which is to
    be created by the Dependency Injection container) is to be shared for the entire
    lifecycle of the application:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET 5（包括ASP.NET Core和Web API）中，我们内置了对依赖注入的支持。在`ConfigureServices`方法中，我们添加了（以粗体突出显示）执行依赖注入的行。我们指示内置的依赖注入容器在引用`IEmployeeRepository`接口的地方创建`EmployeeRepository`类，并且我们还指示它为单例；这意味着相同的对象（由依赖注入容器创建）将在整个应用程序的生命周期中共享：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we have used the Singleton pattern for the Dependency
    Injection, which creates services only the first time they are requested. There
    are other types of lifetime services such as **Transient** and **Scoped** . Transient
    lifetime services are created each time they are requested and Scoped lifetime
    services are created once per request. The following are code snippets created
    when you use such lifetimes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了单例模式进行依赖注入，它只在第一次请求时创建服务。还有其他类型的生命周期服务，如**Transient**和**Scoped**。瞬态生命周期服务每次请求时都会创建，而作用域生命周期服务每次请求都会创建一次。以下是在使用此类生命周期时创建的代码片段：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now it''s time to get into the meat of the action creating the API controller.
    Right-click on the **Controllers** folder and select **Add |**   **New Item**
    . Then select **Web API Controller Class** from the list, as shown in the following
    screenshot. Name your Controller, and click the **Add** button:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进入创建API控制器的核心操作了。在**Controllers**文件夹上右键单击，然后选择**Add | New Item**。然后从列表中选择**Web
    API Controller Class**，如下所示截图。命名你的控制器，然后点击**Add**按钮：
- en: '![Dependency Injection](img/Image00208.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![依赖注入](img/Image00208.jpg)'
- en: 'Remove the generated code in the Controller and add the following constructor:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从控制器中删除生成的代码，并添加以下构造函数：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding constructor, we are injecting the dependency. At the time of
    calling this constructor, the `EmployeeRepository` object will be created.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的构造函数中，我们正在注入依赖。在调用此构造函数时，将创建`EmployeeRepository`对象。
- en: 'Let us implement a couple of `GET` methods—the first one will return all the
    employees'' details and the second `GET` method will return the employee based
    on the passed employee ID:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现几个`GET`方法——第一个将返回所有员工的详细信息，第二个`GET`方法将根据传递的员工ID返回员工：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let us call these HTTP methods from Fiddler.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Fiddler中调用这些HTTP方法。
- en: Run the solution, open the Fiddler application, and click on the **Composer**
    tab.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行解决方案，打开Fiddler应用程序，并点击**Composer**标签。
- en: Select the HTTP method (we have chosen the `GET` method as we have a GET API
    method) and enter the URL `http://localhost:49933/api/employee` .
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 选择HTTP方法（我们选择了`GET`方法，因为我们有一个GET API方法）并输入URL `http://localhost:49933/api/employee`。
- en: Please note that when I run my application, it runs on port `49933` ; the port
    number will be different in your case, so construct your URL accordingly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我的应用程序运行时，它运行在端口`49933`上；你的端口号码可能会有所不同，因此请相应地构造你的URL。
- en: 'Once you enter the URL and the method is selected, click the **Execute** button
    as shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入了URL并选择了方法，点击以下截图所示的**Execute**按钮：
- en: '![Dependency Injection](img/Image00209.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![依赖注入](img/Image00209.jpg)'
- en: Once you click the **Execute** button, an HTTP session will be created, and
    the request will be fired.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击**Execute**按钮，将创建一个HTTP会话，并发送请求。
- en: 'Click on the session on the left-hand side pane (as shown in the following
    screenshot) and select the **Inspectors** tab in the right-hand side pane. You
    can view the result in the **JSON** tab in the bottom right-hand side pane:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 点击左侧面板上的会话（如下所示截图），然后在右侧面板中选择**Inspectors**标签。你可以在底部右侧面板的**JSON**标签中查看结果：
- en: '![Dependency Injection](img/Image00210.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![依赖注入](img/Image00210.jpg)'
- en: 'Let us fire another HTTP request to get a particular employee''s information,
    say the employee whose ID is 2\. We would construct the URL by appending the ID `http://localhost:49933/api/employee/2`
     as following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再发送一个HTTP请求来获取特定员工的信息，比如说ID为2的员工。我们将通过附加ID来构造URL，如下所示：`http://localhost:49933/api/employee/2`。
- en: '![Dependency Injection](img/Image00211.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![依赖注入](img/Image00211.jpg)'
- en: 'Select the recently created HTTP session and click on it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最近创建的 HTTP 会话并点击它：
- en: You can see the result in JSON format in the right-hand side pane.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在右侧面板中看到以 JSON 格式的结果。
- en: 'Now, we are going to add `Create` , `Update` , and `Delete` operations to our
    service. To start with, we are going to provide the Create functionality to add
    employees'' to our service:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向我们的服务添加 `Create`、`Update` 和 `Delete` 操作。首先，我们将提供创建功能以将员工添加到我们的服务中：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following points should be considered when following the preceding `Add`
    method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循前面的 `Add` 方法时，应考虑以下要点：
- en: 'We are passing the `Employee` object as a parameter. We are instructing the
    `Add` method to take that object from the body of the request by specifying a
    `[FromBody]` attribute:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `Employee` 对象作为参数传递。我们指示 `Add` 方法通过指定 `[FromBody]` 属性从请求体中获取该对象：
- en: If no employee object is passed, we would be returning the bad request to the
    calling client
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有传递员工对象，我们将向调用客户端返回错误请求。
- en: If it is not null, we would be calling the repository method to add the employee
    to our list (in the real world, we would be adding it to the database)
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它不为空，我们将调用存储库方法将员工添加到我们的列表中（在现实世界中，我们会将其添加到数据库中）。
- en: Once we have added the employee, we are returning the *201 status code* (as
    per the HTTP standards) when a new resource is created.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们添加了员工，当创建新资源时，我们将返回 *201 状态码*（根据 HTTP 标准）。
- en: 'Open the Fiddler application and follow these steps to add the employee:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Fiddler 应用程序并按照以下步骤添加员工：
- en: Select the HTTP method as `POST` and enter the URL `http://localhost:54504/api/employee/`
    .
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 HTTP 方法为 `POST` 并输入 URL `http://localhost:54504/api/employee/`。
- en: 'You need to specify the content type as `application/json`  in the request
    header. Please see the following screenshot, where we have added `Content-Type:
    application/json` to the request header.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '你需要在请求头中指定内容类型为 `application/json`。请参阅以下截图，其中我们在请求头中添加了 `Content-Type: application/json`。'
- en: 'As mentioned in the code, we have to pass the employee object in the form of
    JSON in the body of the request. In the following request, we have formed a JSON
    that contains the properties of the `Employee` object with the values in the brackets
    { "FirstName" : "James", "LastName" : "Anderson","Department" : "IT"}:![Dependency
    Injection](img/Image00212.jpg)'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如代码所述，我们必须以 JSON 格式在请求体中传递员工对象。在以下请求中，我们创建了一个包含 `Employee` 对象属性的 JSON，括号内为值
    { "FirstName" : "James", "LastName" : "Anderson","Department" : "IT"}：![依赖注入](img/Image00212.jpg)'
- en: 'Once you have composed the request, you can click the **Execute** button to
    fire the request. This will return the *201 HTTP status code* , which is the standard
    HTTP response for creating a new resource:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你已编写完请求，你可以点击 **执行** 按钮来发送请求。这将返回 *201 HTTP 状态码*，这是创建新资源的标准 HTTP 响应：
- en: '![Dependency Injection](img/Image00213.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![依赖注入](img/Image00213.jpg)'
- en: As soon as we have created the resource in the server, we are redirecting the
    response to get the newly created resource. This occurs when we call the `CreatedAtRoute`
    method with the newly created employee ID passed as a parameter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在服务器上创建了资源，我们将重定向响应以获取新创建的资源。这发生在我们调用 `CreatedAtRoute` 方法并将新创建的员工 ID 作为参数传递时。
- en: 'Click on the session on the left-hand side and select the **Inspector** tab
    in the right-hand side pane. Now you can see the response of the request. The
    response contains the `Employee` object which was newly created in the server.
    We have to note that the ID of the `Employee` object is generated at the server,
    and is available in the following response. In this case, the ID generated for
    the employee is `1771082655` :'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 点击左侧的会话并选择右侧面板中的 **检查器** 选项卡。现在你可以看到请求的响应。响应包含在服务器上新创建的 `Employee` 对象。我们必须注意，`Employee`
    对象的 ID 是在服务器上生成的，并在以下响应中可用。在这种情况下，为员工生成的 ID 是 `1771082655`：
- en: '![Dependency Injection](img/Image00214.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![依赖注入](img/Image00214.jpg)'
- en: In the bottom right-hand side panel in the preceding Fiddler window, we can
    see the complete JSON response of the newly created resource.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个 Fiddler 窗口的右下角面板中，我们可以看到新创建资源的完整 JSON 响应。
- en: Now we are going to add a Web API method to update the resource. The method
    for updating the resource is very similar to that used to create the resource,
    with only a few differences. When we created the resource, we used the `HTTP POST`
    method, whereas when we updated the resource, we used the `HTTP PUT` method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加一个 Web API 方法来更新资源。更新资源的方法与创建资源的方法非常相似，只有一些细微差别。当我们创建资源时，我们使用了 `HTTP
    POST` 方法，而当我们更新资源时，我们使用了 `HTTP PUT` 方法。
- en: If the passed employee ID could not be found in the repository, we return a
    *404 error* response, the HTTP standard error response for a resource that has
    not been found.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递的员工 ID 在存储库中找不到，我们将返回 *404 错误* 响应，这是未找到资源的 HTTP 标准错误响应。
- en: 'The following is the Web API controller method code for updating the resource:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为更新资源而编写的 Web API 控制器方法代码：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is the repository layer code for updating the employee:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为更新员工信息的存储库层代码：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open the Fiddler application, and compose a request of `HTTP PUT` . As we are
    going to pass the `Employee` object in the body of the request, we need to mention
    the content type as `application/json` . In the body of the request, we need to
    supply the `Employee` object in JSON format, as shown in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Fiddler 应用程序，并编写一个 `HTTP PUT` 请求。由于我们将在请求体中传递 `Employee` 对象，因此需要指定内容类型为 `application/json`。在请求体中，我们需要以
    JSON 格式提供 `Employee` 对象，如下截图所示：
- en: '![Dependency Injection](img/Image00215.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![依赖注入](img/Image00215.jpg)'
- en: 'When you click the **Execute** button, the `HTTP PUT` request will be fired
    and our Web API method will get called. Once it succeeds, the  *HTTP 204* response
    will be returned:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击 **执行** 按钮，将触发 `HTTP PUT` 请求，并且我们的 Web API 方法将被调用。一旦成功，将返回 *HTTP 204* 响应：
- en: '![Dependency Injection](img/Image00216.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![依赖注入](img/Image00216.jpg)'
- en: Delete method
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除方法
- en: The `HTTP DELETE` method should be used when deleting a resource. There is no
    need to pass anything in the body of the request.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除资源时，应使用 `HTTP DELETE` 方法。请求体中无需传递任何内容。
- en: The Web API method for deleting a resource
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除资源的 Web API 方法
- en: 'The `Delete` Web API method has a `void` return type, which will return an
    *HTTP 200* response:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delete` Web API 方法有一个 `void` 返回类型，它将返回 *HTTP 200* 响应：'
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Web Repository layer code for deleting the employee data
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除员工数据的 Web 存储库层代码
- en: 'In the following repository layer method, we are removing the employee (whose
    ID matches with that of the parameter passed) from the internal list of employees.
    But in the real world, we would be interacting with the database to delete that
    particular employee. Consider the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下存储库层方法中，我们正在从员工的内部列表中删除（其 ID 与传递的参数匹配）员工。但在现实生活中，我们会与数据库交互以删除该特定员工。考虑以下代码：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Open the Fiddler application, select the `DELETE` HTTP method, pass the URL
    with the parameter, and click on the **Execute** button. Please note that we are
    not passing the content type in the request header as we are not passing any employee
    object in the body of the request:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Fiddler 应用程序，选择 `DELETE` HTTP 方法，传递带有参数的 URL，然后点击 **执行** 按钮。请注意，我们不在请求头中传递内容类型，因为我们没有在请求体中传递任何员工对象：
- en: '![Web Repository layer code for deleting the employee data](img/Image00217.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![删除员工数据的 Web 存储库层代码](img/Image00217.jpg)'
- en: 'As we are returning void, the Web API `DELETE` method returns an *HTTP 200*
    status, as you can see in the left-hand side pane of the Fiddler application:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们返回的是空值，Web API 的 `DELETE` 方法返回 *HTTP 200* 状态，如 Fiddler 应用程序的左侧窗格所示：
- en: '![Web Repository layer code for deleting the employee data](img/Image00218.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![删除员工数据的 Web 存储库层代码](img/Image00218.jpg)'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the HTTP service and its purpose. We discussed
    how to design and implement the HTTP service using Web API. We used the Fiddler
    tool to construct the HTTP request and get the response back. We also learned
    how to write the Web API method to perform CRUD operations end to end, from writing
    the Web API methods to firing the requests and getting the responses back.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 HTTP 服务及其用途。我们讨论了如何使用 Web API 设计和实现 HTTP 服务。我们使用 Fiddler 工具构建 HTTP
    请求并获取响应。我们还学习了如何编写 Web API 方法以执行 CRUD 操作，从编写 Web API 方法到发送请求并获取响应。
- en: 读累了记得休息一会哦~
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
