- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: C4 and Other Approaches
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C4和其他方法
- en: In the previous chapter, we provided an initial idea of the business goal of
    the sample information system (and application software modules) that we are going
    to build as a practical exercise to follow the principles outlined in this book.
    Talking about principles, while introducing the demo system, we also explained
    how the most important principles in object-oriented programming would apply to
    the design of our system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提供了一个关于我们将要构建的示例信息系统（以及应用程序软件模块）的商业目标的初步想法（作为一个实际练习来遵循本书中概述的原则）。谈到原则，在介绍演示系统时，我们还解释了面向对象编程中最重要的原则如何应用于我们系统的设计。
- en: Now that the high-level principles have been set, it is time to go a level deeper
    in understanding our sample information system, and we will take advantage of
    this to show a few different methods professionals use. There exist many architectural
    methods and software representations, as we are going to see, and many overlap
    in lots of ways. In fact, some of them are so close that they really are a way
    for their author to mark their individual approach, rather than bringing some
    additional value to the architectural tools. This is the same situation with the
    JavaScript ecosystem, where there are way too many frameworks. Furthermore, it
    becomes even worse every day, with a new team thinking they can solve a problem
    by proposing yet another one. The same thing happens with architectural methods,
    and we have recently been overwhelmed with **clean architecture**, **hexagonal
    architecture**, **onion architecture**, and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经确定了高级原则，是时候深入理解我们的示例信息系统了，我们将利用这一点来展示专业人士使用的一些不同方法。正如我们将看到的，存在许多架构方法和软件表示，它们在许多方面都有重叠。事实上，其中一些非常接近，以至于它们实际上是作者标记他们个人方法的一种方式，而不是为架构工具带来额外的价值。这与JavaScript生态系统中的情况相同，那里有太多的框架。此外，每天都会变得更糟，因为每天都有新的团队认为他们可以通过提出另一个解决方案来解决问题。同样的事情也发生在架构方法上，我们最近被**清洁架构**、**六边形架构**、**洋葱架构**等等所淹没。
- en: As the choice of one method over the other is really not important, we will
    only quickly show these methods so that you can choose which one adapts better
    to your way of thinking, or simply mix some interesting bits from many methods,
    as these are merely sets of long-known best practices assembled in a new package
    name. In the case of our sample information system, the **C4 approach** sounded
    interesting to provide a first approach on how it is designed, so this is the
    method that I will focus on to provide more details about. The idea behind the
    C4 architectural framework is to focus on IT systems from a context level to a
    container level, then a component level, and finally, a code level. The four levels
    will be explained as we apply them to our sample system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于选择一种方法而不是另一种方法实际上并不重要，我们只会快速展示这些方法，以便您可以选择哪种方法更适合您的思维方式，或者简单地从许多方法中混合一些有趣的片段，因为这些只是一些众所周知的最优实践的新组合。在我们的示例信息系统的情况下，**C4方法**听起来很有趣，可以提供一个如何设计它的初步方法，因此我将重点关注这种方法，以提供更多细节。C4架构框架背后的理念是，从上下文级别到容器级别，然后是组件级别，最后是代码级别，关注IT系统。我们将随着在示例系统中应用它们来解释这四个级别。
- en: Just like with **SOLID principles** in the previous chapter, my goal here is
    not to explain these methods in depth, as there would be no value in writing what
    is already available in more detail on freely available and quality resources.
    My intention is to extract how these methods can be useful to reach a business/IT
    alignment or at least help represent the questions that are related to this same
    subject.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '就像在上一章中提到的**SOLID原则**一样，我的目标不是深入解释这些方法，因为如果已经在免费和高质量的资源中提供了更详细的解释，那么写作就没有价值了。我的意图是提取这些方法如何有助于达到商业/IT一致性，或者至少帮助表示与这个主题相关的问题。 '
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: The C4 approach
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C4方法
- en: Clean architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁架构
- en: Hexagonal architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六边形架构
- en: Onion architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 洋葱架构
- en: The C4 approach
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C4方法
- en: 'The C4 approach is about designing a system (or an application) with four different
    levels of granularity, moving from the context level in which the application
    is placed, to the container level that will show the different processes composing
    the application, to the component layer showing the different parts composing
    the process, and finally, to the code level, where we will find the classes and
    interfaces used to create the application. Here is the diagram for this approach:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C4方法涉及设计一个系统（或应用程序），具有四个不同粒度级别，从应用程序所处的上下文级别开始，到将展示应用程序不同过程的容器级别，再到展示组成过程的各个部分的组件层，最后到代码级别，在那里我们将找到用于创建应用程序的类和接口。以下是该方法的示意图：
- en: '![Figure 7.1 – The levels in the C4 approach](img/B21293_07_1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – C4方法中的级别](img/B21293_07_1.jpg)'
- en: Figure 7.1 – The levels in the C4 approach
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – C4方法中的级别
- en: Each level details the content of the previous level and gives a more detailed
    view of the application. The fact that units of the lower level always have to
    be related to one given unit of the upper layer also helps to correctly share
    responsibilities and maintain a low level of coupling.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个级别都详细说明了上一级的内容，并提供了更详细的应用视图。事实上，低级别的单元总是必须与上层的一个给定单元相关联，这也帮助正确地分担责任并保持低耦合度。
- en: In the following sections, we will draw the four levels for our sample system
    and software modules to show the methods; at the same time, we will start designing
    our demo a bit further than the business requirements in the previous chapter
    allowed us to do. Note that the following diagrams will not necessarily be the
    exact ones that correspond to the system created at the end of the book; I really
    wanted to show the complete and realistic process of design, so I am drawing these
    at the same time as I design the sample application for the book. Drawing the
    schemas after I got a clear and complete view of the final result would – in my
    opinion – not be as pedagogical and, in some way, I would have felt like cheating.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将为我们的示例系统和软件模块绘制四个级别，以展示方法；同时，我们将开始设计我们的演示，比上一章允许的业务需求更深入。请注意，以下图示不一定是书中最后创建的系统所对应的精确图示；我真的很想展示完整和真实的设计过程，因此我会在设计样本应用程序的同时绘制这些图示。在我对最终结果有一个清晰和完整的看法之后再绘制这些图示——在我看来——不会那么具有教育意义，而且在某种程度上，我会感觉像是在作弊。
- en: The context level
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文级别
- en: 'On the **context level**, our system will be used by the three user profiles
    that were detailed before, namely the editors, the salespersons, and the director
    of DemoEditor. We will consider that the list of users is already present in the
    information system as an Active Directory or something equivalent. The same goes
    for a content management system, which will be considered to already exist for
    binary document management. Finally, we will consider that a module responsible
    for the emission of electronic mail is also available in the overall system. It
    is used to send emails to actors of the system, either to validate some data or
    to inform them of something. Of course, the authors will be represented in the
    context, even if they do not use the internal information system directly. Here
    is a diagram of the context level:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文级别上，我们的系统将由之前详细说明的三个用户配置文件使用，即编辑者、销售人员以及DemoEditor的总监。我们将考虑用户列表已经存在于信息系统中的Active
    Directory或类似系统中。对于内容管理系统，我们将考虑它已经存在用于二进制文档管理。最后，我们还将考虑在整个系统中也提供了一个负责电子邮件发送的模块。它用于向系统中的参与者发送电子邮件，无论是验证某些数据还是通知他们某些事情。当然，作者也会在上下文中表示，即使他们没有直接使用内部信息系统。以下是上下文级别的示意图：
- en: '![Figure 7.2 – A context-level diagram](img/Figure_7.2_B21293.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 上下文级别图](img/Figure_7.2_B21293.jpg)'
- en: Figure 7.2 – A context-level diagram
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 上下文级别图
- en: We could be more detailed on the content of the arrows, but for now, the diagram
    is self-explanatory, and the functions used by the different roles were explained
    in the previous chapter. Our most important center of interest in this diagram
    is the **Demo Editor System** box, and this is the one that we will detail in
    the next level of the C4 architecture.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对箭头的内容进行更详细的说明，但到目前为止，这个图示是自解释的，不同角色使用的功能在上一章中已经解释过了。我们在这个图示中最感兴趣的中心是**Demo
    Editor System**框，这是我们将在C4架构的下一级别详细说明的。
- en: The container level
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器级别
- en: At the **container level**, we show what the system uses in terms of building
    blocks. Most of the time, these blocks are separated processes. In our case, since
    we have decided to have completely independent services, we will have as many
    containers as API exposition servers. I anticipate a bit on the technical chapters
    of the book, but we will deploy the system as Docker containers, so there is a
    complete match between “containers” in the C4 architecture and “containers” in
    terms of the units of deployment used in Docker or other such technologies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在**容器级别**，我们展示了系统在构建块方面的使用情况。大多数情况下，这些块是分离的过程。在我们的案例中，由于我们决定拥有完全独立的服务，我们将拥有与
    API 展示服务器一样多的容器。我稍微提前透露一下本书的技术章节，但我们将以 Docker 容器的形式部署系统，因此 C4 架构中的“容器”与 Docker
    或其他类似技术中使用的部署单元的“容器”之间有一个完全匹配。
- en: In the following diagram, the boxes inside the dotted rectangle represent the
    details of the higher-level box corresponding to the Demo Editor system. We can
    still represent the other parts of the Context level, but it’s best practice not
    to detail them, as they are outside the scope of our study. We can detail the
    stream that goes to them (as we did for the **Users directory** arrow, pointing
    from **Single Page Application**), but this is not mandatory, and we can also
    keep arrows that simply point from the system as a whole if we do not want to
    be precise about these streams of data yet (this is what has been done for the
    mail sender and CMS subsystems).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，虚线矩形内的框代表与 Demo Editor 系统对应的更高级别框的详细信息。我们仍然可以表示上下文级别的其他部分，但最佳实践是不详细说明它们，因为它们超出了我们的研究范围。我们可以详细说明流向它们的流（就像我们对**用户目录**箭头所做的那样，指向**单页应用程序**），但这不是强制的，如果我们还不想精确地描述这些数据流，我们也可以保留从整个系统指向的箭头（这就是邮件发送者和
    CMS 子系统所做的那样）。
- en: '![Figure 7.3 – The container level](img/Figure_7.3_B21293.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 容器级别](img/Figure_7.3_B21293.jpg)'
- en: Figure 7.3 – The container level
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 容器级别
- en: By the way, at this level of reflection, we start considering what the content
    of the streams of data could be, and in this particular case, I realized that
    instead of a CMS, electronic document management could possibly be more appropriate.
    If we consider that this is an external system and not part of the one we are
    designing, we would, in reality, not have the ability to change it. However, since
    there is an interoperation with it, we might be able to influence the protocol
    used to communicate with it, and this is what our analysis is about. From a practical
    point of view, I do not know yet, at the time of writing (remember, I want to
    be as realistic as possible and I have not finished the exercise before writing
    the chapters), whether there will be an Alfresco container, an Azure Storage,
    or a SharePoint 365 site to implement this subsystem. All I know is that I will
    need to pass binary documents and retrieve them, which means something such as
    **Content Management Interoperability Services** (**CMIS**) streams will certainly
    be indicated (CMIS is an interoperability standard for electronic documents).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，在这个反思层面，我们开始考虑数据流的内容可能是什么，在这个特定的情况下，我意识到，与其使用 CMS，电子文档管理可能更为合适。如果我们考虑这是一个外部系统，而不是我们正在设计的系统的一部分，那么实际上我们可能没有能力去改变它。然而，由于它与它有交互，我们可能能够影响与其通信所使用的协议，这正是我们的分析所关注的。从实际的角度来看，我在写作的时候还不知道（记住，我希望尽可能现实，我在写章节之前还没有完成练习），是否会有一个
    Alfresco 容器、一个 Azure 存储，或者一个 SharePoint 365 网站来实现这个子系统。我所知道的是，我需要传递二进制文档并检索它们，这意味着像**内容管理互操作性服务**（**CMIS**）这样的流肯定会被指示（CMIS
    是电子文档的互操作性标准）。
- en: For now, we have not expressed what is inside each of the boxes. We only know
    that each of them will have its own life cycle as a software application and represent
    a process and a Docker container (a good practice is, indeed, to have one process
    per container only so that all things align well). If we go a bit into the development
    details, it would then be in the right alignment to have a continuous integration
    pipeline for each of these containers and, logically, a git repository for each
    of them as well. But I am anticipating the “hands-on” part of the book. For now,
    let’s dive deeper into one of the boxes, namely **Books repository**, and show
    what it will be composed with, using the third level of the C4 approach, namely
    the component diagram.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们还没有表达每个框内部的内容。我们只知道每个框都将作为软件应用拥有自己的生命周期，并代表一个过程和一个 Docker 容器（确实是一个好的实践，即每个容器只包含一个进程，以便所有事物都能很好地对齐）。如果我们稍微深入到开发细节中，那么为每个这些容器设置一个持续集成管道，以及逻辑上为每个容器设置一个
    git 仓库，将是正确的。但我正在预测这本书的“动手”部分。现在，让我们深入到一个框中，即 **书籍存储库**，并展示它将如何使用 C4 方法中的第三级，即组件图来组成。
- en: The component level
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件级别
- en: 'At the **component level**, we show the different modules and libraries that
    the executable container will use to accomplish its business requirements. As
    our books repository will expose two contract APIs, we will need a web server
    to support the controllers, a client to call the persistence system, maybe together
    with a repository pattern, a cache component to keep some data locally, and so
    on. This is what is drawn in the following diagram that corresponds to the third
    level in the C4 architecture:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **组件级别**，我们展示了可执行容器将使用哪些不同的模块和库来完成其业务需求。由于我们的书籍库将公开两个合同 API，我们需要一个 Web 服务器来支持控制器，一个客户端来调用持久化系统，可能还会与存储库模式一起使用，一个缓存组件来本地保存一些数据，等等。这就是以下图表所展示的内容，对应于
    C4 架构的第三级：
- en: '![Figure 7.4 – The component level](img/Figure_7.4_B21293_1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 组件级别](img/Figure_7.4_B21293_1.jpg)'
- en: Figure 7.4 – The component level
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 组件级别
- en: A component may correspond to different names of artifacts, depending on the
    platform that is going to be used. In .NET, components may be assemblies, while
    in Java, they will be JAR archives. Anyhow, this decomposition in components exists
    in basically all programming platforms, even if it appears in different forms.
    For example, in some platforms, components will correspond to separate files,
    while in others, they will be more abstract, through the use of namespaces, for
    example. In any case, there will be ways to group code-level content into coherent
    groups, while still with a lower granularity than the higher level of containers,
    which correspond to entire processes made with several components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件可能对应于不同平台上的不同工件名称。在 .NET 中，组件可能是程序集，而在 Java 中，它们将是 JAR 存档。无论如何，这种组件分解在基本上所有编程平台中都存在，即使它们以不同的形式出现。例如，在某些平台上，组件将对应于单独的文件，而在其他平台上，它们将更加抽象，例如通过使用命名空间。无论如何，都存在将代码级别内容分组为连贯组的方法，同时仍然比更高层级的容器具有更低的粒度，这些容器对应于由多个组件组成的整个过程。
- en: The code level
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码级别
- en: As the reference documentation of the C4 method (available at [https://c4model.com/](https://c4model.com/))
    states, it is important to use diagrams only if they add value. This is something
    I also stressed when presenting the `IDbRepository` pattern will be used and maybe
    a `UnitOfWork` pattern, but the class organization is not clear yet, so there
    is no use in trying to draw the diagram yet.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 C4 方法（可在 [https://c4model.com/](https://c4model.com/) 获取）的参考文档所述，只有在它们能增加价值的情况下才应使用图表。这也是我在介绍
    `IDbRepository` 模式将被使用，也许还会使用 `UnitOfWork` 模式时强调的，但类组织结构尚不明确，因此现在尝试绘制图表是没有意义的。
- en: Also, even if it was for pedagogical reasons, drawing such a diagram would not
    bring much value, since the fourth level of the C4 approach is simply the same
    as a class diagram from **UML** or **Unified Modeling Language**. We will use
    these detailed diagrams if we need to in the following chapters, once we progress
    into the actual making of the system. In the meantime, we are done with the C4
    method used to explain the sample system we want to create, and we will now briefly
    discuss the alternative software architectural design methods, using them to better
    express our context under analysis.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使是为了教学目的，绘制这样的图表也不会带来太多价值，因为C4方法的第四级实际上与**UML**或**统一建模语言**中的类图相同。在接下来的章节中，如果我们需要，我们将使用这些详细图表，一旦我们进入实际制作系统的阶段。与此同时，我们已经完成了用于解释我们想要创建的示例系统的C4方法，现在我们将简要讨论其他软件架构设计方法，使用它们更好地表达我们正在分析的环境。
- en: Clean architecture, hexagonal architecture, and other frameworks
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洁架构、六边形架构和其他框架
- en: What comes next may be a surprise for you in the context of software architecture
    – the choice of an architecture method does not matter much, as long as you have
    a method (or several methods used together, by the way, if you maintain control
    of their interactions and know when to choose one over another). Of course, that
    does not mean you do not need to apply some method when designing the architecture
    of an information system. My point of view after many years of experience in the
    field is that you should find and apply *your* method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件架构的背景下，接下来可能对你来说是个惊喜——选择哪种架构方法并不那么重要，只要你有一个方法（或者几个方法一起使用，顺便说一句，如果你能控制它们之间的交互并知道何时选择一个而不是另一个）。当然，这并不意味着在设计信息系统架构时你不需要应用某种方法。我在这个领域多年经验后的观点是，你应该找到并应用**你自己的**方法。
- en: 'Also, if you try many different existing methods such as hexagonal architecture,
    clean architecture, onion architecture, and other domain-centric approaches, you
    will quickly realize that they offer little more than a different visual approach
    to the same basic principles, which are highly related to the business/IT alignment
    we discussed at the beginning of this book and the principles that have been extracted
    from the SOLID approach, namely the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你尝试了许多不同的现有方法，如六边形架构、清洁架构、洋葱架构以及其他以领域为中心的方法，你很快就会意识到，它们提供的不过是将相同的基本原则以不同的视觉方式呈现，这些基本原则与我们在这本书开头讨论的业务/IT对齐以及从SOLID方法中提取的原则高度相关，即以下内容：
- en: The business model (*data structures representing functional concepts* and *business
    rules translated into code*) should be at the core of the architecture. This way,
    it does not depend on anything, which allows easy changes, fast automated testing,
    a lack of external versioning constraints, and lots of other advantages. Most
    importantly, it enables the concentration of the team on the most important thing
    – business alignment.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业模式（*代表功能概念的**数据结构**和*转换成代码的业务规则**）应该是架构的核心。这样，它不依赖于任何东西，这允许轻松更改、快速自动化测试、缺乏外部版本控制约束，以及许多其他优势。最重要的是，它使团队能够专注于最重要的事情——业务对齐。
- en: Everything surrounding this business-aligned core should use some kind of indirection
    to introduce low-coupling and make the evolution of any module of the system easier.
    Everything depends on the business core module, which itself depends on nothing
    else. In addition, these dependencies are easy to modify if necessary.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕这个业务核心的一切都应该使用某种间接方法来引入低耦合，使系统的任何模块的演进都更容易。一切皆依赖于业务核心模块，而它本身不依赖于任何其他东西。此外，如果需要，这些依赖关系很容易修改。
- en: Technical architecture patterns
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术架构模式
- en: One last thing before we dive into the details of the methods – here, I will
    only discuss the architectural methods that can apply to the design of an entire
    information system. There are lots of methods that deal with the technical architecture
    of a single application, how it should be structured, how its source code and
    information flow should be organized, what technical layers should be present,
    and even, in some cases, recommendations on how to name things.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨方法细节之前，还有最后一件事——在这里，我将只讨论可以应用于整个信息系统设计的架构方法。有许多方法涉及单个应用程序的技术架构，它应该如何结构化，其源代码和信息流应该如何组织，应该存在哪些技术层，甚至在某些情况下，如何命名事物的建议。
- en: For example, the **N-tier architectures** (also called **layer-based**) will
    describe how each set of source code should call another set, from the GUI to
    the service to the application to the database. MVC, MVP, and MVVM architectures
    are slightly less linear and describe how each group of source code would talk
    to only some of them, to ease the evolution and maintenance of the application
    (with generally an emphasis on their visual part).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**N 层架构**（也称为**基于层的架构**）将描述每一组源代码应该如何调用另一组，从 GUI 到服务再到应用程序再到数据库。MVC、MVP 和
    MVVM 架构稍微不那么线性，描述了每一组源代码将只与其中的一些进行通信，以简化应用程序的演变和维护（通常侧重于它们的视觉部分）。
- en: These architectures can, theoretically, be used at the level of the entire information
    system, but that does not mean much more than applying them to all applications
    that constitute the information system, since they do not say much about how the
    applications should work together. N-tier architecture recommends that software
    blocks should talk to each other using the application layer, but since it does
    not enforce it, lots of old applications interop at the database level, which
    is a catastrophic coupling in most cases and certainly one of the major reasons
    why a vast majority of legacy systems are nowadays unable to evolve. MVC is supposed
    to be applicable at a higher level than just the visual interface, but despite
    this, it does not reach the level of the entire information system. It may be
    just a question of semantics, but I personally tend to classify these methods
    as patterns rather than architectures, since they come from experience rather
    than pure reflection (and there is absolutely no value judgment in this – we need
    both experimental and intellectual approaches to be complete).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些架构理论上可以在整个信息系统的层面上使用，但这并不意味着更多，因为它们并没有说很多关于应用程序应该如何协同工作。N 层架构建议软件块应该通过应用层相互通信，但由于它没有强制执行，许多旧应用程序在数据库级别进行互操作，这在大多数情况下都是灾难性的耦合，也是当今绝大多数遗留系统无法演变的主要原因之一。MVC
    应该适用于比仅仅视觉界面更高的层面，但尽管如此，它并没有达到整个信息系统的层面。这可能只是一个语义问题，但我个人倾向于将这些方法归类为模式而不是架构，因为它们来自经验而不是纯粹的反思（这里绝对没有价值判断——我们需要实验和智力方法来完整）。
- en: Since this book is about the architecture of a whole information system, I have
    focused on the purpose of architectural methods that naturally are applicable
    at such levels. It happens that domain-centric methods typically respond to this
    because they convey the very notion of a business domain, which has to be the
    very first (and unique) way to decompose an information system if you want to
    get a result that is aligned with a business. All technical approaches can work
    on the software and hardware layers, but what we need is methods that work at
    the business capability map level.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书是关于整个信息系统架构的，我专注于适用于这种级别的架构方法的目的。恰好领域中心的方法通常对此作出回应，因为它们传达了业务领域的概念，如果你想要得到与业务一致的结果，这必须是第一个（也是唯一的）分解信息系统的途径。所有技术方法都可以在软件和硬件层上工作，但我们需要的是在业务能力映射层上工作的方法。
- en: Onion architecture
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 洋葱架构
- en: '**Onion architecture** pictures a software unit as several concentric circles
    containing, right at the center, the business **domain model**! And around it,
    you will find services (persistence, etc.) and then presentation (a GUI, external
    interfaces, tests, etc.):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**洋葱架构**将软件单元描绘为几个同心圆，中心正是业务**领域模型**！围绕它，你会找到服务（持久化等）然后是展示层（GUI、外部接口、测试等）：'
- en: '![Figure 7.5 – Onion architecture](img/Figure_7.5_B21293.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 洋葱架构](img/Figure_7.5_B21293.jpg)'
- en: Figure 7.5 – Onion architecture
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 洋葱架构
- en: One of the main rules in onion architecture is that all dependencies should
    go from the outer side to the inner layers. This way, again, the core business
    model does not depend on anything, which makes it easy to evolve, while outer
    circles can be changed provided that they do not impact the business (which is
    generally much easier than the reverse – imagine basing your entire business model
    on a proprietary relational database procedures language and trying to change
    to another database engine).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在洋葱架构中，一条主要规则是所有依赖都应该从外侧流向内侧层。这样，核心业务模型就不依赖于任何东西，这使得它容易进化，而外侧圈可以改变，前提是它们不影响业务（这通常比反过来更容易
    – 想象一下，如果你的整个业务模型基于专有关系型数据库过程语言，并试图切换到另一个数据库引擎）。
- en: While this method does not insist on levels of indirection, the principle of
    dependency inversion (see the previous chapter for an explanation), together with
    the rule just cited, makes it obvious that interfaces are necessary to implement
    functions such as persistence. And the same goes, of course, for one layer above.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法不坚持间接层的级别，但依赖反转原则（见前一章的解释）以及刚刚提到的规则使得接口对于实现持久化等功能是必要的。当然，对于更高一层也是如此。
- en: Hexagonal architecture
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 六边形架构
- en: '**Hexagonal architecture** represents a software unit in a hexagonal shape,
    hence its name, with the left part of the hexagon containing interfaces consuming
    the inside (such as a GUI or automated tests), the right part containing adapters
    to functional dependencies (such as persistence, notification service, etc.),
    and right in the middle of it, as you may have guessed, the core, containing the
    business entities and business rules!'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**六边形架构**代表一个以六边形形状的软件单元，因此得名，其中六边形的左侧包含消耗内部（如GUI或自动化测试）的接口，右侧包含适配器以处理功能依赖（如持久化、通知服务等），而中间部分，正如你可能猜到的，是核心，包含业务实体和业务规则！'
- en: '![Figure 7.6 – Hexagonal architecture](img/Figure_7.6_B21293.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 六边形架构](img/Figure_7.6_B21293.jpg)'
- en: Figure 7.6 – Hexagonal architecture
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 六边形架构
- en: Hexagonal architecture insists on ports and adapters to organize the communication
    between the different parts of the application, but this is also a rule in the
    onion architecture even if it is not displayed in the same way. This helps us
    remember that interfaces and contracts should always be applied for the dependencies
    not to evolve into hard coupling, which makes it difficult to evolve the system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构强调端口和适配器来组织应用程序不同部分之间的通信，但这也是洋葱架构的一条规则，即使它没有以相同的方式展示。这有助于我们记住，接口和合同应该始终应用于依赖，以防止它们演变成硬耦合，这使得系统难以进化。
- en: As far as the “*hexagonal*” shape goes, it is pure clutter! I intended to draw
    three “clients” of the business domain to stress the point that there is absolutely
    no relationship between the name of the method and a given technical constraint
    or a particular advantage of the technique. In fact, it is explained in the method
    that the hexagonal shape is simply used to preserve enough space to display shapes
    around the central one. How would this be different from circles (used by the
    other approaches cited previously), ovals, or squares? If the hexagonal shape
    does not bring anything conceptually enriching, my personal opinion is that it
    should not be declared in the name of the method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就“*六边形*”形状而言，这只是纯粹的杂乱！我的意图是画出业务域的三个“客户端”来强调方法名称与给定的技术约束或技术优势之间绝对没有关系。实际上，方法中解释说，六边形形状只是用来保留足够的空间来显示围绕中心形状的形状。这与圆圈（如之前提到的其他方法所用的）、椭圆形或正方形有何不同？如果六边形形状在概念上没有带来任何丰富性，那么我个人认为，它不应该出现在方法名称中。
- en: This may sound like a useless rant against methods, but this is only to make
    it clear that their value really lies in what they have in common and not their
    differences. What really matters is the centrality of the core domain, aligned
    to the business, and the control of the dependencies, but all of this is already
    there in the SOLID principles.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来像是对方法的无用抱怨，但这只是为了明确，它们的真正价值在于它们共同拥有的东西，而不是它们的差异。真正重要的是核心域的中心性，与业务对齐，以及依赖的控制，但所有这些已经在SOLID原则中存在。
- en: Clean architecture
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清洁架构
- en: '**Clean architecture** involves basically joining the two approaches presented
    previously while proposing some additional rules. Graphically, it appears very
    similar to the onion architecture, in concentric circles with the business entities
    in the middle, and several layers organized around in the core, evolving to the
    outside in the same direction as dependencies apply.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**清洁架构**基本上是将之前提出的两种方法结合起来，同时提出一些额外的规则。从图形上看，它非常类似于洋葱架构，以同心圆的形式呈现，业务实体位于中间，围绕核心组织了多层，按照依赖关系应用的方向从内向外发展。'
- en: In this method, you will find almost everything that has already been explained
    previously in the two other methods, including the fact that the domain model
    must be clean of any technical dependencies, to address its utmost importance
    in the system and to bring all kinds of other benefits such as testability.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，你将找到之前在另外两种方法中几乎已经解释过的所有内容，包括领域模型必须摆脱任何技术依赖性，以解决其在系统中的极端重要性，并带来各种其他好处，如可测试性。
- en: Inversion of dependency is also recommended, as the separation of concerns.
    The vocabulary slightly differs, but a quick search on the internet will show
    lots of blog articles about the extreme similarities between the three architectures.
    Clean architecture may be a bit more “guiding” than the others, but it is impossible
    – at the time of writing – to find a documented analysis proving one better, or
    even widely different in results, than the other.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖反转也是推荐的，因为它与关注点分离相似。词汇略有不同，但通过在互联网上快速搜索，你会看到很多关于三种架构之间极端相似性的博客文章。清洁架构可能比其他架构更“指导”，但在写作时，不可能找到证明其中一种比另一种更好，甚至在结果上广泛不同的文档分析。
- en: My personal opinion is that these three approaches (onion, hexagonal, and clean
    architecture) are so close to each other in the way they work and in their recommendations
    that you can use one or another without making any real difference in the quality
    of the architecture produced.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人的观点是，这三种方法（洋葱、六边形和清洁架构）在它们的工作方式和推荐方面非常接近，你可以使用其中一种而不影响产生的架构质量。
- en: What will bring quality is the profound understanding of why these methods exist
    and, in particular, the capacity to create modules that are cleanly separated
    and where you keep control of the dependencies. Cutting concerns and responsibilities
    without strict rules on their relationship will end up in a spaghetti-like system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 能够带来质量的是对这些方法存在的原因的深刻理解，特别是创建干净分离的模块并保持对依赖关系的控制的能力。没有对它们之间关系的严格规则来切割关注点和责任，最终会导致像意大利面一样的系统。
- en: Conversely, following strict principles where the business domain (the most
    important part) does not have any dependencies and where everything technical
    is interfaced around it, with an indirection layer in between, is what really
    matters. And all three approaches have this in common. The rest is pure details,
    and if you consider, for example, that the hexagonal shape does not bring anything
    to the method, as explained previously, the existence of several methods really
    gives the impression that some of them are there just because their author wanted
    to have their own method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，遵循严格的原则，其中业务领域（最重要的部分）没有任何依赖，并且所有技术都是围绕它接口的，中间有一个间接层，这才是真正重要的。而且三种方法都有这个共同点。其余的都是纯粹细节，如果你考虑，例如，六边形形状并没有给方法带来任何东西，就像之前解释的那样，那么存在多种方法确实给人一种印象，即其中一些方法的存在仅仅是因为它们的作者想要有自己的方法。
- en: Summary
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The C4 approach was used in this chapter to detail our demo application from
    four points of view, namely the context in which it is used, the containers it
    uses, and the components and code that it is made of. Diagrams following this
    approach have helped us explain what the sample information system we will create
    is about. We also learned that it is not necessary to create a diagram that completely
    covers the domain of study, but only for the bits these diagrams have value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了C4方法从四个角度详细介绍了我们的演示应用程序，即它所使用的上下文、它所使用的容器以及它由哪些组件和代码组成。遵循此方法绘制的图表帮助我们解释了我们将要创建的示例信息系统的内容。我们还了解到，没有必要创建一个完全覆盖研究领域的图表，但只有这些图表具有价值。
- en: Also, lots of architectural methods have emerged in the past decades. Although
    they clearly have value in the design of software applications, and thus in information
    systems, they resemble very much each other in the sense that most recent methods
    are domain-centric; as such, their value can basically be summarized by the two
    principles that we already know, SOLID and business alignment principles, namely
    putting the business functions model first and applying a method to reduce the
    coupling to dependencies. Both of these make the evolution of a system easier.
    I do not have any doubt that these methods may have additional value for software
    organization, and they certainly help you to take a step further than purely technically
    oriented architecture patterns. However, as far as entire systems are concerned,
    the C4 approach explored at the beginning of the chapter should – in my opinion
    – be applied first in a top-down approach, leaving the domain-centric approaches
    as a way of organizing the third level (the components) of the C4 method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在过去几十年中涌现了许多架构方法。尽管它们在软件应用程序的设计中，以及信息系统设计中显然具有价值，但它们在某种意义上非常相似，即最近的方法大多是领域中心的；因此，它们的价值基本上可以总结为我们已经知道的两个原则，即SOLID原则和业务对齐原则，即首先考虑业务功能模型，并应用一种方法来减少对依赖的耦合。这两者都使得系统的演化变得更加容易。我毫不怀疑这些方法可能对软件组织具有额外的价值，并且它们确实可以帮助你超越纯粹技术导向的架构模式。然而，就整个系统而言，我认为在第章开头探讨的C4方法应该首先以自上而下的方式应用，将领域中心的方法作为组织C4方法的第三级（组件）的一种方式。
- en: In [*Chapter 8*](B21293_08.xhtml#_idTextAnchor271), we will start defining more
    precisely the API on which our demonstration system will be based, as these entities
    are definitely the most important technical aspects if you want a freely evolving
    application. In the upcoming chapter, we will start by explaining the concept
    of service orientation and its relation to APIs. In [*Chapter 9*](B21293_09.xhtml#_idTextAnchor318),
    we will use a semantics-based approach to define the business domains of our sample
    application and translate them into actual API contracts. We have talked a lot
    about business domains – in the next two chapters, they will be defined, as well
    as their interactions, for our demonstration system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B21293_08.xhtml#_idTextAnchor271)中，我们将开始更精确地定义我们的演示系统所基于的API，因为这些实体无疑是实现自由发展的应用程序最重要的技术方面。在接下来的章节中，我们将首先解释服务导向的概念及其与API的关系。在[*第9章*](B21293_09.xhtml#_idTextAnchor318)中，我们将采用基于语义的方法来定义我们的示例应用程序的业务领域，并将它们转化为实际的API合约。我们已经对业务领域进行了很多讨论——在接下来的两章中，我们将定义这些领域，以及它们在我们演示系统中的交互。
