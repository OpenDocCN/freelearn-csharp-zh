<html><head></head><body>
<div><h1 class="chapterNumber"><a id="_idTextAnchor022"/>1</h1>
<h1 class="chapterTitle" id="_idParaDest-15"><a id="_idTextAnchor023"/>Demystifying Serverless Applications</h1>
<p class="normal">When it comes to software development, we are living in incredible times. With the evolution of cloud platforms and the rise of modern technologies, being a developer nowadays is both a wonderful way to live and a challenging profession to follow. There are so many ways to deliver an application and so many innovative technologies to explore that we may fall into a vicious circle where we focus more on the technologies rather than the actual solution.</p>
<p class="normal">This chapter aims to present the serverless architecture and explore how you can use this approach to implement a microservices application. To achieve this, it covers the theory behind serverless and provides an understanding of how it can be a viable alternative for microservices implementation.</p>
<p class="normal">The chapter also explores how Microsoft <a id="_idIndexMarker000"/>implements <strong class="keyWord">Function as a Service (FaaS),</strong> using Azure Functions as one of the options for building microservices. Two alternative development platforms will be presented: Visual Studio Code and Visual Studio.</p>
<p class="normal">By the end of this chapter, you will understand the different triggers available in Azure Functions and be ready to create your first function.</p>
<h1 class="heading-1" id="_idParaDest-16"><a id="_idTextAnchor024"/>Technical requirements</h1>
<p class="normal">This chapter requires Visual Studio 2022 free <em class="italic">Community edition </em>or Visual Studio Code. During the chapter, the details about how to debug Azure Functions for each development environment will be presented in the topics. You will also need an Azure account to create the sample environment. You can find the sample code for this chapter at <a href="https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp">https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp</a>.</p>
<h1 class="heading-1" id="_idParaDest-17"><a id="_idTextAnchor025"/>What is serverless?</h1>
<p class="normal">When someone <a id="_idIndexMarker001"/>asks you to develop a solution, the last thing they usually care about is how the infrastructure will work. The truth is, even for developers, the most important thing about infrastructure is that it simply works well.</p>
<p class="normal">Considering this reality, the possibility of having a cloud provider that dynamically manages server allocation and provisioning, leaving the underlying infrastructure to the provider, might be the best scenario.</p>
<p class="normal">That is what serverless architecture promises: a model we can use to build and run applications and services without having to manage the underlying infrastructure ourselves! This approach abstracts server management entirely, allowing developers to focus on their code.</p>
<p class="normal">The first cloud solution provider that presented this concept was <a id="_idIndexMarker002"/>Amazon, with the launch of AWS Lambda<a id="_idIndexMarker003"/> in 2014. After that, Microsoft and Google also provided similar solutions with Microsoft Azure Functions and Google Cloud Functions. As we mentioned before, the focus of this book will <a id="_idIndexMarker004"/>be Azure Functions.</p>
<p class="normal">There are many advantages that we can consider for using serverless computing. The fact that you do not have to worry about scaling can be considered the main one. Additionally, the cloud solution provider maintains the reliability and security of the environment. Besides that, with this approach, you have the option to pay as you go, so you only pay for what you use, enabling a sustainable model of growth.</p>
<p class="normal">Serverless can also be <a id="_idIndexMarker005"/>considered a good approach for accelerating software development since you only focus on the code needed to deliver that program. On the other hand, you may have difficulty overseeing a considerable number of functions, so this organization needs to be well handed to not cause problems while creating a solution with many functions.</p>
<p class="normal">Since the introduction of serverless, various kinds of functions have been created. These functions act as triggers that are used to start processing. As soon as the function is triggered, the execution can be done in different programming languages.</p>
<p class="normal">Now, let us check whether functions can be considered microservices or not.</p>
<h1 class="heading-1" id="_idParaDest-18"><a id="_idTextAnchor026"/>Is serverless a way to deliver microservices?</h1>
<p class="normal">If you look at the definition<a id="_idIndexMarker006"/> of microservices, you will find the concept of delivering an application as loosely coupled components that represent the implementation of a business capability. You can build something like that with a couple of functions, so yes, serverless is a way to deliver <a id="_idIndexMarker007"/>microservices.</p>
<p class="normal">Some specialists even consider serverless architecture an evolution of microservices, since the focus of serverless architecture is to deliver scalability in a safe environment, enabling the possibility of a set of functions to independently be developed, tested, and deployed, which brings a lot of flexibility to the software architecture. That is exactly the main philosophy of microservices.</p>
<p class="normal">Let us imagine, as an example, a <a id="_idIndexMarker008"/>microservice responsible for authenticating users. You may<a id="_idIndexMarker009"/> create specific functions for registering, logging, and resetting passwords. Considering that this set of functions can be created in a single serverless project, you have both the flexibility of creating separated functions and the possibility of defining the purpose of the microservice.</p>
<p class="normal">The serverless project will naturally support integration with databases, messaging queues, OpenAPI specifications, and other APIs, enabling the design patterns typically needed for a robust microservice architecture. It is also important to mention that keeping microservices isolated, small, and preferably reusable is a best practice worth following.</p>
<p class="normal">Now that you understand that you can write microservices using serverless approaches, let us understand how Microsoft Azure presents serverless in its platform.</p>
<h1 class="heading-1" id="_idParaDest-19"><a id="_idTextAnchor027"/>How does Microsoft Azure present serverless?</h1>
<p class="normal">In 2016, Microsoft introduced <a id="_idIndexMarker010"/>Azure Functions as a Platform-as-a-Service (PaaS) offering designed to deliver FaaS capabilities. This option enables innovation at a scale for business transformation. Today, Azure Functions gives us the opportunity to power up applications using multiple programming languages, including C#, JavaScript, F#, Java, and Python.</p>
<p class="normal">One of the standout features of Azure Functions is its seamless integration with other Azure services and third-party APIs. For instance, it can easily connect to different Azure databases (from Azure SQL Server to Azure Cosmos DB), Azure Event Grid for event-based architecture, and Azure Logic Apps for workflow automation. This connectivity simplifies the process of building complex, enterprise-grade applications that leverage multiple services.</p>
<p class="normal">Over the years, the possibilities with Azure Functions have evolved. Today, we can even manage stateful workflows and long-running operations, using Azure Durable Functions. With this, you can orchestrate complex processes that can be executed in multiple function executions.</p>
<p class="normal">But Microsoft has not only created an environment for coding functions. They have also created a complete pipeline for developers, following the DevSecOps process that’s now widely discussed and used in enterprise solutions. Developers can use tools such as Azure Pipelines, GitHub Actions, and other CI/CD services to automate the deployment process. You can also monitor and diagnose events in these functions using Azure Monitor and Application Insights, which facilitate troubleshooting and optimization.</p>
<p class="normal">The PaaS solution also <a id="_idIndexMarker011"/>enables different setups to adjust scalability and security aspects. Depending on the hosting plan you decide to set, you can have different scaling opportunities, as you can check here:</p>
<ul>
<li class="bulletList">Consumption plan: The basic and most cost-effective option to get started with Azure Functions. Ideal for event-driven workloads with automatic scaling.</li>
<li class="bulletList">Flex Consumption plan: Offers rapid, elastic scaling combined with support for private networking (VNet integration).</li>
<li class="bulletList">Dedicated plan (App Service plan): Suitable for long-running functions and scenarios requiring more predictable performance and resource allocation.</li>
<li class="bulletList">Azure Container Apps plan: A solid choice for microservices-based architectures that use multiple technology stacks or require greater flexibility.</li>
<li class="bulletList">Premium plan: Designed for high-performance scenarios with the ability to scale on demand, providing support for advanced features such as VNet, longer execution times, and pre-warmed instances.</li>
</ul>
<p class="normal">In summary, Microsoft Azure delivers serverless FaaS through Azure Functions, offering a powerful, flexible, and scalable platform that enhances the development and deployment of serverless applications. By using Azure Functions, developers can build and maintain responsive, cost-effective solutions. Now, let us explore how to create an Azure function in the Azure portal.</p>
<h1 class="heading-1" id="_idParaDest-20"><a id="_idTextAnchor028"/>Creating your first serverless app in Azure</h1>
<p class="normal">There <a id="_idIndexMarker012"/>are not many steps for creating your first serverless app in Azure. You can <a id="_idIndexMarker013"/>do it in a straightforward process when using the Azure portal. Follow these steps to get started:</p>
<ol>
<li class="numberedList" value="1">Log in to the Azure portal. To do so, open your web browser and navigate to the Azure portal at <a href="https://portal.azure.com/">https://portal.azure.com/</a>. Sign in with your Azure account credentials.</li>
<li class="numberedList">In the Azure portal, click on the <strong class="screenText">Create a resource</strong> button located in the upper-left corner.</li>
</ol>
<figure class="mediaobject"><img alt="Figure 1.1: Creating a resource in the Azure portal" src="img/B31916_01_1.png"/></figure>
<p class="packt_figref">Figure 1.1: Creating a resource in the Azure portal</p>
<ol>
<li class="numberedList" value="3">In the <strong class="screenText">Search services and marketplace</strong> window, search for <strong class="screenText">Function App</strong> and select it from the search results. This service will also be presented in the <strong class="screenText">Popular Azure services</strong> section.</li>
<li class="numberedList">Click the <strong class="screenText">Create</strong> button to start the creation process.</li>
</ol>
<figure class="mediaobject"><img alt=" Figure 1.2: Selecting Function App for creation" src="img/B31916_01_2.png"/></figure>
<p class="packt_figref"> Figure 1.2: Selecting Function App for creation</p>
<p class="normal-one">As soon as <a id="_idIndexMarker014"/>you select <strong class="screenText">Function App</strong>, you will be prompted to select <a id="_idIndexMarker015"/>the required hosting plan. Today, we have five options for hosting plans using Azure Functions. These plans vary according to the scaling behavior, cold start, the possibility of usage of a virtual network, and, obviously, pricing. The <em class="italic">Consumption</em> plan is exactly what serverless is all about, where you have no idea of where and how your code is running, and you only pay for the execution of the code. On the other hand, when you select the <em class="italic">App Service</em> or <em class="italic">Container Apps environment</em> plans, you will have more control over the hardware and consumption of resources, which means you get the flexibility of using Azure Functions in your solution, along with the management needed for larger applications.</p>
<p class="normal-one">The following screen will be presented to you as soon as you select to create an Azure function app. As we described previously, you will need to decide on the hosting plan according to your needs.</p>
<figure class="mediaobject"><img alt="Figure 1.3: Function App hosting plans" src="img/B31916_01_3.png"/></figure>
<p class="packt_figref">Figure 1.3: Function App hosting plans</p>
<p class="normal-one">For the<a id="_idIndexMarker016"/> purpose of this chapter, we will select the <strong class="screenText">Consumption</strong> plan. Once you select this option, you will find a wizard to help you create the<a id="_idIndexMarker017"/> service. In this service, you will need to fill in the following information:</p>
<ul>
<li class="bulletList level-2"><strong class="screenText">Basics</strong>: Fill in the required fields such as <strong class="screenText">Subscription</strong>, <strong class="screenText">Resource Group</strong>, <strong class="screenText">Function App name</strong>, <strong class="screenText">Region</strong>, and <strong class="screenText">Operating System</strong>. Ensure that the name you choose is unique. In <strong class="screenText">Runtime stack</strong>, select the programming language of your functions. We will select <strong class="screenText">.NET 8 Isolated</strong> worker model, but there are other options, as we presented before. It is worth mentioning that in-process models will be retired in 2026, so do not start projects using this approach.</li>
<li class="bulletList level-2"><strong class="screenText">Storage</strong>: The function app needs an Azure storage account by default.</li>
<li class="bulletList level-2"><strong class="screenText">Networking</strong>: This is where you will define whether the Azure function will be available for public access or not.</li>
<li class="bulletList level-2"><strong class="screenText">Monitoring</strong>: Enable Application Insights to monitor your Function App for better diagnostics and performance tracking. Don’t forget that Azure Monitor logs will cause a cost increase.</li>
<li class="bulletList level-2"><strong class="screenText">Deployment</strong>: It is also possible to initiate the setup of the deployment desired for the function app. This is interesting for enabling continuous deployment using GitHub Actions as default.</li>
<li class="bulletList level-2"><strong class="screenText">Tags</strong>: Tagging the<a id="_idIndexMarker018"/> function app is considered a good<a id="_idIndexMarker019"/> practice for facilitating FinOps activity in professional environments.</li>
</ul>
<div><p class="normal">In <a href="Chapter_2.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Demystifying Microservices Applications</em>, we will discuss the best way to interface microservices with the external world. For security reasons, it is not recommended that you provide functions directly to the public. You may decide to deliver them using an application gateway, such as Azure Application Gateway, or you can use Azure API Management as the entry for the APIs you develop using Azure Functions.</p>
</div>
<p class="normal-one">Once you click on <strong class="screenText">Review and create</strong>, you will be able to check all the settings. Review your configuration and click the <strong class="screenText">Create</strong> button again to deploy your function app:</p>
<figure class="mediaobject"><img alt="Figure 1.4: Reviewing the function app setup" src="img/B31916_01_4.png"/></figure>
<p class="packt_figref">Figure 1.4: Reviewing the function app setup</p>
<p class="normal">Once the<a id="_idIndexMarker020"/> deployment is complete, navigate to your new function app by <a id="_idIndexMarker021"/>clicking on the <strong class="screenText">Go to resource</strong> button. You will find the function app running properly there:</p>
<figure class="mediaobject"><img alt="Figure 1.5: Function app running" src="img/B31916_01_5.png"/></figure>
<p class="packt_figref">Figure 1.5: Function app running</p>
<p class="normal">Now, it is time to understand the possibilities for development using Azure Functions and start coding.</p>
<h1 class="heading-1" id="_idParaDest-21"><a id="_idTextAnchor029"/>Understanding the triggers available in Azure Functions</h1>
<p class="normal">The basic idea of <a id="_idIndexMarker022"/>Azure Functions is that each function requires a trigger to start its <a id="_idIndexMarker023"/>execution. Once the trigger is fired, the execution of your code will start shortly afterward. However, the time it takes for execution to begin can vary depending on the selected hosting plan. For instance, in the Consumption plan, functions may experience cold starts – that is, a delay that occurs when the platform needs to initialize resources. It is also important to understand that the function can trigger more than once at the same time, which enables execution in parallel.</p>
<p class="normal">Azure Functions offers a variety of triggers that allow developers to execute code in response to different events. Here we have the most used triggers:</p>
<ul>
<li class="bulletList">HTTP Trigger: This trigger <a id="_idIndexMarker024"/>allows the function to be executed via an HTTP<a id="_idIndexMarker025"/> request. It is useful for creating APIs and <a id="_idIndexMarker026"/>webhooks, where the function can be called using standard HTTP methods.</li>
<li class="bulletList">Timer Trigger: This <a id="_idIndexMarker027"/>trigger runs the function on a schedule based on the NCRONTAB model. It <a id="_idIndexMarker028"/>is ideal for tasks that need to be performed at regular intervals, such as cleanup operations, data processing, or sending out periodic reports. It is important to mention that the same timer trigger function does not run again until its first execution is done. This behavior helps prevent overlapping executions and potential conflicts.</li>
<li class="bulletList">Blob Storage Trigger: This <a id="_idIndexMarker029"/>trigger runs the function when a new blob is created or updated in an Azure Blob Storage<a id="_idIndexMarker030"/> container. It is useful for processing or transforming files, such as images or logs, as they are uploaded.</li>
<li class="bulletList">Queue Storage Trigger: This<a id="_idIndexMarker031"/> trigger runs the function in response to <a id="_idIndexMarker032"/>messages added to Azure Queue Storage. It is useful for building scalable and reliable background processing systems.</li>
<li class="bulletList">Event Grid Trigger: This <a id="_idIndexMarker033"/>trigger runs the function in response to events published to Azure Event Grid. It is <a id="_idIndexMarker034"/>useful for reacting to events from various Azure services, such as resource creation, modification, or deletion.</li>
<li class="bulletList">Service Bus Trigger: This trigger runs the function when messages are received in an Azure <a id="_idIndexMarker035"/>Service Bus<a id="_idIndexMarker036"/> queue or topic. It is ideal for handling inter-application messaging and building complex workflows.</li>
<li class="bulletList">Cosmos DB Trigger: This trigger runs the function in response to creation and updates in<a id="_idIndexMarker037"/> Azure Cosmos DB. It is<a id="_idIndexMarker038"/> useful for processing data changes in real time, such as updating a search index or triggering additional data processing.</li>
</ul>
<p class="normal">These triggers offer <a id="_idIndexMarker039"/>flexibility and scalability, allowing developers to build event-driven applications that can respond to distinct types of events seamlessly. It is important to say that there are other triggers available in Azure Functions, and we will discuss them in more detail in the next chapters.</p>
<h1 class="heading-1" id="_idParaDest-22"><a id="_idTextAnchor030"/>Coding with Azure Functions</h1>
<p class="normal">The focus of this topic is to rapidly present some ways to develop Azure functions. During the other chapters of the book, we will present a use case related to car sharing. As you will see in detail in <a href="Chapter_2.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Demystifying Microservices Applications</em>, each microservice must have a health check endpoint. Let us develop a sample of this health check API.</p>
<h1 class="heading-1" id="_idParaDest-23"><a id="_idTextAnchor031"/>Coding Azure functions using VS Code</h1>
<p class="normal">Creating an<a id="_idIndexMarker040"/> HTTP trigger Azure function using VS Code involves <a id="_idIndexMarker041"/>several well-defined steps. Here is a detailed guide to help you through the process.</p>
<p class="normal">There are some prerequisites to enable the development of Azure functions using VS Code, as follows:</p>
<ul>
<li class="bulletList">Ensure you have VS Code installed on your machine. The use of VS Code will help you not only develop the Azure functions needed but also manage your Azure account using <a id="_idIndexMarker042"/>the <strong class="keyWord">Azure Tools</strong> extension.</li>
<li class="bulletList">It is recommended that you sign in to your Azure account to create the new function. The <strong class="keyWord">C# Dev Kit</strong> may<a id="_idIndexMarker043"/> also be installed.</li>
<li class="bulletList"><strong class="keyWord">The GitHub Copilot extension</strong> can also <a id="_idIndexMarker044"/>be installed to help you solve coding problems and, at the same time, guide you while writing code.</li>
<li class="bulletList">Install the Azure <a id="_idIndexMarker045"/>Functions extension for VS Code. This <a id="_idIndexMarker046"/>VS Code extension will facilitate the development of functions, giving you wizards for each function trigger desired.</li>
<li class="bulletList">Install the Azurite extension for VS Code. This VS Code extension is an open source Azure Storage API-compatible server for debugging Azure Functions locally.</li>
<li class="bulletList">Make sure you have <a id="_idIndexMarker047"/>the <strong class="keyWord">Azure Functions Core Tools,</strong> and the <strong class="keyWord">.NET SDK</strong> installed if <a id="_idIndexMarker048"/>you are using C#.</li>
</ul>
<p class="normal-one">Once you have set up your environment, you will h<a id="_idTextAnchor032"/>ave something like the following figure:</p>
<figure class="mediaobject"><img alt="Figure 1.6: VS Code ready to write Azure functions" src="img/B31916_01_6.png"/></figure>
<p class="packt_figref">Figure 1.6: VS Code ready to write Azure functions</p>
<ul>
<li class="bulletList">Once all the <a id="_idIndexMarker049"/>prerequisites are set, in the <strong class="screenText">Azure</strong> tab, go<a id="_idIndexMarker050"/> to <strong class="screenText">WORKSPACE</strong> and select <strong class="screenText">Create Function Project…</strong>. Next, perform the following steps:<ol class="numberedList level-2" style="list-style-type: decimal;">
<li class="numberedList level-2" value="1">Choose a location for your project and select your preferred programming language.</li>
<li class="numberedList level-2">Follow the prompts to create a new HTTP trigger function. You can name it <code class="inlineCode">Health</code> and call the namespace <code class="inlineCode">CarShare.Function.</code></li>
<li class="numberedList level-2">You will need to decide on the <strong class="keyWord">access rights</strong> for <a id="_idIndexMarker051"/>this function. For this example, you can choose <strong class="screenText">Anonymous</strong>. We will discuss each of the security options later.</li>
<li class="numberedList level-2">Open the newly created function file. You will see a template code for an HTTP trigger function.</li>
<li class="numberedList level-2">Modify the function to meet your specific requirements, which, in this case, means to respond if the function is working properly. Notice that this is a <code class="codeHighlighted" style="font-weight: bold;">GET</code> and <code class="codeHighlighted" style="font-weight: bold;">POST</code> function. For the purpose we have defined, you can change the code to only be an HTTP <code class="codeHighlighted" style="font-weight: bold;">GET</code> function.</li>
<li class="numberedList level-2">Save<a id="_idIndexMarker052"/> your<a id="_idIndexMarker053"/> changes.</li>
</ol>
</li>
</ul>
<p class="normal">For running and debugging locally, you just need to press <em class="italic">F5</em> or navigate to <strong class="screenText">Run</strong> &gt; <strong class="screenText">Start Debugging</strong>. VS Code will start the Azure Functions host, and you will see the function URL in the output window. Then, you can use tools such as <strong class="keyWord">Postman</strong> or <a id="_idIndexMarker054"/>your browser to send HTTP requests to your function endpoint.</p>
<div><p class="normal"> It is worth mentioning that for running Azure Functions locally, you will need to allow PowerShell scripts to run without being digitally signed. This can be a problem depending on the security policies provided by your company.</p>
</div>
<p class="normal">Once the function is running, you can consider it the same as when you work on other types of software projects, and even the debugging will work properly. The trigger will depend on the function you set. The following figure shows the code of the function program, where you can see the response to the caller with a status of <code class="codeHighlighted" style="font-weight: bold;">200</code> by using <code class="inlineCode">OkObjectResult</code> with the message “Yes! The function is live!” and the UTC time.</p>
<figure class="mediaobject"><img alt="Figure 1.7: Azure Functions running locally" src="img/B31916_01_7.png"/></figure>
<p class="packt_figref">Figure 1.7: Azure Functions running locally</p>
<p class="normal">As you have<a id="_idIndexMarker055"/> created a function app connected to a GitHub repository <a id="_idIndexMarker056"/>with the deployment process handled by GitHub Actions, once you commit and pull the code to GitHub, GitHub Actions will automatically build the function and deploy it as a function app.</p>
<figure class="mediaobject"><img alt="Figure 1.8: Function app deployed using GitHub Actions" src="img/B31916_01_8.png"/></figure>
<p class="packt_figref">Figure 1.8: Function app deployed using GitHub Actions</p>
<p class="normal">It is not the <a id="_idIndexMarker057"/>purpose of this book to discuss CI/CD strategies, but you<a id="_idIndexMarker058"/> will certainly need to think about them when it comes to professional development.</p>
<p class="normal">The result of this deployment can be checked in the Azure portal, where the function developed will be available in the list of functions. It is worth noting that a function app can handle more than one function at the same time.</p>
<figure class="mediaobject"><img alt="Figure 1.9: Health function available in the function app" src="img/B31916_01_9.png"/></figure>
<p class="packt_figref">Figure 1.9: Health function available in the function app</p>
<p class="normal">The function<a id="_idIndexMarker059"/> can be executed as soon as it is published to Azure. As<a id="_idIndexMarker060"/> a result of the sample function, as this was developed as a <code class="codeHighlighted" style="font-weight: bold;">GET</code> HTTP trigger, we can check that the function is working by accessing the API in the web browser.</p>
<figure class="mediaobject"><img alt="Figure 1.10: Health function running properly" src="img/B31916_01_10.png"/></figure>
<p class="packt_figref">Figure 1.10: Health function running properly</p>
<p class="normal">As you don’t have a live CI/CD pipeline, you can also publish your Azure function directly from the VS Code IDE. To do so, you may use the Azure Functions extension provided by VS Code.</p>
<p class="normal">There are a <a id="_idIndexMarker061"/>few steps to follow in this case. The first one is to select the <a id="_idIndexMarker062"/>action to deploy the function in the VS Code prompt:</p>
<figure class="mediaobject"><img alt="Figure 1.11: Deploying to Azure using VS Code" src="img/B31916_01_11.png"/></figure>
<p class="packt_figref">Figure 1.11: Deploying to Azure using VS Code</p>
<p class="normal">After that, you will need to select the corresponding subscription and the name of the new function app you want to deploy, considering a new function:</p>
<figure class="mediaobject"><img alt="Figure 1.12: Creating a new function app" src="img/B31916_01_12.png"/></figure>
<p class="packt_figref">Figure 1.12: Creating a new function app</p>
<p class="normal">The current<a id="_idIndexMarker063"/> process proposed by the extension is to deploy an Azure<a id="_idIndexMarker064"/> function in the Flex Consumption plan. There are some specific locations where this option is available:</p>
<figure class="mediaobject"><img alt="Figure 1.13: Defining the location for the new function app" src="img/B31916_01_13.png"/></figure>
<p class="packt_figref">Figure 1.13: Defining the location for the new function app</p>
<p class="normal">The definition of the runtime stack is also important to get the most out of your Azure function. In the case of the Flex Consumption plan, you will also be asked for the memory usage in the instance and the maximum number of instances available for parallel calls.</p>
<figure class="mediaobject"><img alt="Figure 1.14: Defining the runtime stack for the new function app" src="img/B31916_01_14.png"/></figure>
<p class="packt_figref">Figure 1.14: Defining the runtime stack for the new function app</p>
<p class="normal">Once these sets<a id="_idIndexMarker065"/> are defined, your Azure function will be deployed<a id="_idIndexMarker066"/> correctly. You can also redeploy functions using the same technique later, without needing to recreate the Azure function app every single time.</p>
<figure class="mediaobject"><img alt="Figure 1.15: Function app properly deployed" src="img/B31916_01_15.png"/></figure>
<p class="packt_figref">Figure 1.15: Function app properly deployed</p>
<p class="normal">Last, but not<a id="_idIndexMarker067"/> least, the Azure portal also gives you the possibility to<a id="_idIndexMarker068"/> monitor and manage the functions deployed. Once this process is done, you can monitor your function’s performance and log. By using the <strong class="screenText">Monitoring</strong> section of your function app, you can view execution details, track failures, and analyze performance metrics.</p>
<h1 class="heading-1" id="_idParaDest-24"><a id="_idTextAnchor033"/>Coding Azure functions using Visual Studio</h1>
<p class="normal">Visual Studio is one of the <a id="_idIndexMarker069"/>best options for developing Azure functions. To <a id="_idIndexMarker070"/>do so, you must set <strong class="screenText">Azure Development Workload</strong>, which will help enable Azure functions development natively on the platform.</p>
<p class="normal">Once you have done this, the same project you created using VS Code will be available for you to use at Visual Studio. The difference between VS Code and Visual Studio in this case is that Visual Studio will provide an easier setup environment for debugging and a lot of visual dialogs that can facilitate your decisions.</p>
<figure class="mediaobject"><img alt="Figure 1.16: Creating a new Azure function for the function app" src="img/B31916_01_16.png"/></figure>
<p class="packt_figref">Figure 1.16: Creating a new Azure function for the function app</p>
<p class="normal">These dialogs<a id="_idIndexMarker071"/> simplify the development process, so if you have the <a id="_idIndexMarker072"/>opportunity to use Visual Studio, this will be the best option.</p>
<figure class="mediaobject"><img alt="Figure 1.17: Defining the Azure function trigger type" src="img/B31916_01_17.png"/></figure>
<p class="packt_figref">Figure 1.17: Defining the Azure function trigger type</p>
<p class="normal">Once again, when<a id="_idIndexMarker073"/> you create a Function Apps project, you can add <a id="_idIndexMarker074"/>more than one function to this project, which is extremely useful for microservices solutions. In the following example, we have added a second HTTP trigger function called <code class="inlineCode">Status</code> to help you understand this possibility and to let you see how these functions work together in a single function app.</p>
<figure class="mediaobject"><img alt="Figure 1.18: Function app with more than one function" src="img/B31916_01_18.png"/></figure>
<p class="packt_figref">Figure 1.18: Function app with more than one function</p>
<p class="normal">It is important to <a id="_idIndexMarker075"/>mention that the same code developed initially using<a id="_idIndexMarker076"/> VS Code can continue to be maintained using Visual Studio, and vice versa. This is great because you can have different developers in the same team using the two environments and this will not cause a problem, at least not with Function Apps projects.</p>
<p class="normal">Visual Studio is an excellent option for developing Azure functions due to its comprehensive setup environment for debugging and integrated visual dialogs, which make development easier. Developers can switch between VS Code and Visual Studio without compatibility issues, facilitating team collaboration. Multiple functions, such as HTTP triggers, can be in a single Function Apps project, supporting microservices solutions.</p>
<h1 class="heading-1" id="_idParaDest-25"><a id="_idTextAnchor034"/>Summary</h1>
<p class="normal">This chapter explored the evolution of cloud platforms and the rise of modern technologies, emphasizing the importance of focusing on solutions rather than just technologies. The chapter highlighted the advantages of serverless computing, such as scalability, reliability, security, and cost-effectiveness, while also addressing potential challenges. It discussed how serverless architecture can deliver microservices and the benefits of using Microsoft Azure Functions for building and deploying serverless applications. The chapter also provided practical guidance on creating and managing Azure functions using tools such as VS Code and Visual Studio.</p>
<p class="normal">In the next chapter, we will discuss how microservices applications can be defined and designed in enterprise scenarios.</p>
<h1 class="heading-1" id="_idParaDest-26"><a id="_idTextAnchor035"/>Questions</h1>
<ol>
<li class="numberedList" value="1">What are the main advantages of using serverless computing as mentioned in the chapter?</li>
</ol>
<p class="normal-one">Serverless computing provides several advantages, including automatic scaling, cost-efficiency through a pay-as-you-go model, and reduced infrastructure management. Developers do not need to worry about provisioning or maintaining servers, which allows them to focus on delivering solutions faster and more efficiently.</p>
<p class="normal-one">It also promotes software development acceleration by letting developers focus solely on the code. Additionally, the environment’s reliability and security are managed by the cloud provider, enabling scalable and sustainable solutions without sacrificing performance or safety.</p>
<ol>
<li class="numberedList" value="2">How can serverless architecture be used to deliver microservices?</li>
</ol>
<p class="normal-one">Serverless architecture supports the microservices model by allowing developers to create independent, small, and reusable functions that represent distinct business capabilities. These functions can be deployed, tested, and scaled independently, following the core principles of microservices.</p>
<p class="normal-one">The chapter gave an example of a user authentication microservice, where separate functions such as registration, login, and password reset were implemented within a single serverless project. This flexibility enhances the modularity and maintainability of applications built using microservices principles.</p>
<ol>
<li class="numberedList" value="3">What are the key triggers available in Azure Functions and their purposes?</li>
</ol>
<p class="normal-one">Azure Functions can be triggered by a variety of events. The main triggers are HTTP trigger (for web requests), timer trigger (scheduled tasks), Blob Storage trigger (file uploads or changes), Queue Storage trigger (message processing), Event Grid trigger (event handling from Azure services), Service Bus trigger (messaging between applications), and Cosmos DB trigger (database change processing).</p>
<p class="normal-one">Each trigger allows developers to build event-driven applications with flexibility and scalability. For example, timer triggers are ideal for recurring tasks, while HTTP triggers are commonly used for APIs and webhooks. This variety of triggers supports the development of diverse and responsive solutions.</p>
<ol>
<li class="numberedList" value="4">What steps are necessary to create a serverless application in the Azure portal?</li>
</ol>
<p class="normal-one">To create a serverless application in Azure, the developer must log in to the Azure portal and create a new Function App resource. During the setup, they need to choose the hosting plan (e.g., Consumption plan), define project details such as region, runtime stack, storage account, and networking options, and enable monitoring via Application Insights.</p>
<p class="normal-one">After reviewing the configurations, the developer clicks <strong class="screenText">Create</strong> to deploy the function app. Once deployed, they can navigate to the resource, start coding, and manage it directly from the portal or via development tools such as Visual Studio or VS Code.</p>
<ol>
<li class="numberedList" value="5">How does Azure Functions integrate with other Azure services and third-party APIs?</li>
</ol>
<p class="normal-one">Azure Functions integrates seamlessly with various Azure services such as Azure SQL, Cosmos DB, Event Grid, Service Bus, and Logic Apps. This enables developers to build complex workflows, automate tasks, and create highly responsive applications using existing Azure infrastructure.</p>
<p class="normal-one">Additionally, Azure Functions can connect to third-party APIs and services, supporting hybrid architectures. This integration capability allows developers to extend their applications across platforms, enhancing the flexibility and scalability of cloud-native solutions.</p>
<h1 class="heading-1" id="_idParaDest-27"><a id="_idTextAnchor036"/>Further reading</h1>
<ul>
<li class="bulletList">Azure Functions documentation: <a href="https://learn.microsoft.com/en-us/azure/azure-functions/">https://learn.microsoft.com/en-us/azure/azure-functions/</a></li>
<li class="bulletList">Azure API Management documentation: <a href="https://learn.microsoft.com/en-us/azure/api-management/">https://learn.microsoft.com/en-us/azure/api-management/</a></li>
<li class="bulletList">Azure Application Gateway documentation: <a href="https://learn.microsoft.com/en-us/azure/application-gateway/overview">https://learn.microsoft.com/en-us/azure/application-gateway/overview</a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-28"><a id="_idTextAnchor037"/>Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/PSMCSharp">https://packt.link/PSMCSharp</a></p>
<p class="normal"><img alt="A qr code with black squares  AI-generated content may be incorrect." src="img/B31916_Discord-QR-Code.png"/></p>
</div>
</body></html>