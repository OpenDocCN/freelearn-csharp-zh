<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-236"><a id="_idTextAnchor237"/>11</h1>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor238"/>The One with the Debugging Dances</h1>
			<p><em class="italic">Debugging and Profiling </em><em class="italic">System Applications</em></p>
			<p><strong class="bold">Debugging</strong> is the<a id="_idIndexMarker818"/> art of finding errors in your code and ensuring you have all the knowledge to fix them. That sounds simple enough, doesn’t it? Well, think again. Debugging can get complicated quickly, and you need good strategies to recover. Luckily, I am here to help you! In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>What is debugging? What is <strong class="bold">profiling</strong>?</li>
				<li>How do we use <strong class="bold">breakpoints</strong>?</li>
				<li>What other debugging tools do we have in Visual Studio?</li>
				<li>How do we deal with multithreaded and asynchronous systems?</li>
				<li>How do we profile and benchmark our code to ensure it runs as fast as possible?</li>
			</ul>
			<p>Debugging can get quite time-intensive. So, let’s not waste any time and get started.</p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor239"/>Technical requirements</h1>
			<p>As always, you can find the source code for all samples in this chapter in the GitHub repository at <a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter11">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter11</a>.</p>
			<p>I only use Visual Studio in this chapter; I am not referring to any of the third-party tools that might do the same job. However, I will provide you with a list of alternative tools at the end of this chapter.</p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor240"/>Introducing debugging</h1>
			<p>True story: I once worked for a manager who claimed he wanted to lay off the testers in my team. He said, “If your team performs better, they will not produce bugs, and therefore we can save on the testers.” Obviously, he was wrong. I left that company shortly after this happened.</p>
			<p>Developing software is a creative job. People think software development is an exact science that is close to mathematics and physics, but it is not. Sure, the roots look mathematical, but what we, as software developers, do is something else. We take an idea, think of something that does not yet exist, and then turn those ideas into something that can help others. We create something out of thin air by our imagination and ingenuity.</p>
			<p>However, the creative mind is sloppy. We cut corners when we are in the flow. We make mistakes trying to realize our vision. Testers and QA professionals are our safety net; they are there to catch the things we forget about. But having a safety net does not mean you can do whatever you want and wing it. Once you have the first outline of your code ready, it is time to switch from being the creative developer to the pensive, analytical developer – the one who looks at their code and notices areas of improvement; and still then you will miss things. So, you test yourself. That is when you find issues. Or, you see the system does not run as smoothly as you expected. Maybe you find the results are not what they are supposed to be. That is when the debugging dance starts: you run the system, you try to pinpoint the area where things go wrong, you fix things, and repeat the whole cycle.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Debugging<a id="_idIndexMarker819"/> can be a fun journey, or it can be an extremely frustrating experience. I am here to help you move your debugging experiences into a more fun one. If debugging means fixing bugs, then developing means creating bugs. There is nothing wrong with that, as long as you realize this is the case and you can resolve the issues before shipping. Let me help you with that!</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor241"/>Debugging and profiling – an overview</h1>
			<p>I remember when they taught me how to write Cobol code on the university mainframe. It was a challenge, to be honest. The mainframe was a costly machine with many terminals attached. If you do not know what that means, imagine you have one computer with multiple keyboards and monitors connected to it, where each user can use their session to do their work, isolated from the others.</p>
			<p>This worked fine when you had to do some simple stuff, such as working on a document or a spreadsheet; the mainframe could handle multiple sessions well. However, compiling code is something else: that takes a lot of CPU power. They fixed that by having the students submit their code to the compiler, which would then run sequentially at night. You could see what you did wrong when you returned the next day. Imagine forgetting a semicolon somewhere, meaning you have to wait another 24 hours before you can see the results of your fix. That way of working taught me to think about my code very thoroughly.</p>
			<p>These days, when I enter C# code, I see the compiler working for me constantly. Visual Studio immediately tells me when I make a mistake.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor242"/>Debugging</h2>
			<p><strong class="bold">Debugging</strong> was <a id="_idIndexMarker820"/>out of the question. All we could do was stuff the code with logging messages, run the program, and see the output. Then, we could try to deduce the errors in our code from the log files.</p>
			<p>Nowadays, it’s so much easier: you can step through your code, see the statements as they are executed, and inspect variables, memory, threads, and so on.</p>
			<p>Of course, the requirements of the software have also become much more complex, so writing software in itself hasn’t gotten any easier.</p>
			<p>But modern debugging tools help – a lot.</p>
			<p><em class="italic">Debugging is the process of identifying, isolating, and fixing problems or “bugs” in software. These bugs can be anywhere from simple syntax errors to more elusive logic errors that produce the wrong output </em><em class="italic">or flow.</em></p>
			<p>The compiler helps us fix the most obvious mistakes: a typo in a statement is caught immediately. However, code that compiles does not result in a flawless program. Debugging can help remedy that.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor243"/>Profiling</h2>
			<p><strong class="bold">Profiling</strong> is the twin of<a id="_idIndexMarker821"/> debugging. <em class="italic">While debugging aims to find logical errors, profiling is meant to help you find performance errors.</em> Performance errors can indicate that the system runs too slow, uses too much memory, or other things that stop the software from running as efficiently as possible.</p>
			<p>Profiling helps you improve the efficiency of your software. It shows you where the bottlenecks are. Profiling can help you pinpoint where your memory usage goes up and where your logic fails when encountering performance issues.</p>
			<p>Profiling can be as simple as logging some timing information or as complex as gathering 24 hours of activities of all your threads and performing a statistical analysis of that data. It all depends on your needs.</p>
			<p>Debugging<a id="_idIndexMarker822"/> and profiling<a id="_idIndexMarker823"/> go hand in hand. With a profile session, you gather the evidence that something is not going as you want it to. You then use debugging techniques to find and fix the errors in your code.</p>
			<p>Of course, this process is more like a cycle. You debug, then you profile, then debug to find the issues, fix them, then debug the fixes, then profile the fixes, and so on. It’s a never-ending dance. However, it can be quite satisfying: in the end, you have much better code and a better-performing system, and that must make it all worth it!</p>
			<p>So, let’s investigate the tools we have to do all this magic!</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor244"/>Debugging 101</h1>
			<p><strong class="bold">Visual Studio</strong> is a <a id="_idIndexMarker824"/>great tool. It has many features that help you during development and the debugging process. So, it is natural to start by looking at Visual Studio first. I will not spend much time on debugging basics in Visual Studio. Still, I think revisiting the most apparent tools we have is immensely clarifying.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor245"/>Debug builds versus Release builds</h2>
			<p>Let’s talk about that <a id="_idIndexMarker825"/>dropdown at the top in Visual Studio, where you can choose between <strong class="bold">Debug</strong> and <strong class="bold">Release</strong>. I am <a id="_idIndexMarker826"/>sure you have a feeling about what this is all about. You pick <strong class="bold">Debug</strong> when you are still writing the code, and want to debug your software. You choose <strong class="bold">Release</strong> when you are ready to release your product.</p>
			<p>However, there is a bit more you should know about those options. Let me start by saying that you can still debug your code if it is built in Release mode. It’s just a bit harder.</p>
			<p>Let me compare the results of a Debug setting and a Release setting. The following table shows the main differences:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-10">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><strong class="bold">Debug</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Release</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Purpose</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Primarily <a id="_idIndexMarker827"/>for development.</p>
						</td>
						<td class="No-Table-Style">
							<p>Primarily<a id="_idIndexMarker828"/> for production.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Optimization</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Minimal or no optimization.</p>
						</td>
						<td class="No-Table-Style">
							<p>Highly optimized for performance and efficiency. The compiler removes unused code and applies various optimizations.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Symbols</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Includes debugging symbols (<code>.pdb</code> files), which provide detailed information about the code (e.g., variable names, line numbers, and so on).</p>
						</td>
						<td class="No-Table-Style">
							<p>No or limited symbols. You can still get a <code>.pdb</code> file, but it will have much less information.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Assertions</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Debug assertions are enabled.</p>
						</td>
						<td class="No-Table-Style">
							<p>Debug assertions are disabled.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Performance</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Generally slower because there is no optimization.</p>
						</td>
						<td class="No-Table-Style">
							<p>Generally faster and more efficient.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Size</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Larger files due to extra debugging information.</p>
						</td>
						<td class="No-Table-Style">
							<p>Smaller because of optimizations and removal of debugging information.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.1: Comparing Debug and Release builds</p>
			<p>I suggest you use Debug builds when debugging. That is what it is for.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor246"/>Breakpoints</h2>
			<p>The best tool Visual Studio offers is the <a id="_idIndexMarker829"/>mighty <strong class="bold">breakpoint</strong>. It is a straightforward construct, but it can help us a lot when trying to understand what is happening inside our application.</p>
			<p>In the simplest form, a breakpoint is a code point that stops the program when the application reaches the code statement to which the breakpoint is attached. You can add breakpoints to all sorts of things as long as they are statements. You cannot add a breakpoint to a code comment.</p>
			<p>You cannot set a breakpoint on a method declaration, but you can set it on the first <code>{</code> that marks the beginning of the method.</p>
			<p>Also, declarations of variables are not a valid target for a breakpoint unless you do an assignment simultaneously.</p>
			<p>For instance, look at the following two lines:</p>
			<pre class="source-code">
int x; // Cannot add a breakpoint
int j = 0; // Can add a breakpoint</pre>			<p>We cannot add a breakpoint to the line where we declare <code>i</code>. We can add a breakpoint to the second line. Technically, that line consists of two parts: the declaration and the assignment; the breakpoint is set on the assignment part.</p>
			<p>Namespace declarations and <code>using</code> statements are also invalid targets. Interfaces cannot have breakpoints, just as attribute declarations are excluded.</p>
			<p>However, besides these obvious cases, you can place them wherever you want.</p>
			<h3>What happens when a breakpoint is hit?</h3>
			<p>We have some software, placed a <a id="_idIndexMarker830"/>breakpoint, and ran the software. At one point, the execution point reaches our breakpoint. The question is: what happens then?</p>
			<p>First, the execution stops. The program is frozen in time. In Visual Studio, some additional tools come to life:</p>
			<ul>
				<li><strong class="bold">Locals</strong>: This window opens or updates, showing all variables reachable in the current scope</li>
				<li><strong class="bold">Autos</strong>: This window displays variables used in the current line and the surrounding context</li>
				<li><strong class="bold">Watch</strong>: This window shows any variables you might have added to the Watch</li>
				<li><strong class="bold">Call Stack</strong>: This window displays a series of method calls that led up to the current breakpoint</li>
				<li><strong class="bold">Immediate</strong>: This window allows you to type commands, evaluate expressions, or change variable values on the fly</li>
			</ul>
			<p>With the program paused, you can inspect or modify variable values if necessary.</p>
			<p>This helps you understand what happens in your program. However, it can lead to weird situations if you are not careful.</p>
			<p>Let’s have a look at what I mean. Imagine you have this code somewhere:</p>
			<pre class="source-code">
int sum = 0;
for (int i = 1; i &lt;= 10; i++)
{
    sum += i;
}
$"The sum of the numbers from 0 to 9 is {sum}".Dump(ConsoleColor.Cyan);</pre>			<p>This code iterates over the <code>i</code> variable, increasing it and adding its value to the <code>sum</code> variable. If you run this, you get the result of <code>55</code>. Now, place a breakpoint inside the loop. Run the code again, but after the ninth iteration, you decide you want to see what happens in that loop one more time. So, you change the value of <code>i</code> from <code>9</code> back to <code>0</code>. The <code>sum</code> variable will <a id="_idIndexMarker831"/>not make any sense anymore: the outcome is a vastly different value.</p>
			<p>This sample is simple, but these side effects can happen quite quickly. Changing variables might have unintended consequences. So, be aware of that.</p>
			<h3>Threads and breakpoints</h3>
			<p>Later in this chapter, we <a id="_idIndexMarker832"/>will discuss debugging multithreaded applications, but I want to discuss one item here. I said that when the code hits a breakpoint, the debugger stops execution.</p>
			<p>Look at this code:</p>
			<pre class="source-code">
ThreadPool.QueueUserWorkItem(_ =&gt;
{
    int inThreadCounter = 0;
    while (true)
    {
        $"In the thread with counter {inThreadCounter++}".Dump(ConsoleColor.Yellow);
        Thread.Sleep(100);
    }
});
int outThreadCounter = 0;
while (true)
{
    $"In the main thread with counter {outThreadCounter++}".Dump(ConsoleColor.Cyan);
    await Task.Delay(200);
}</pre>			<p>The code is straightforward enough. First, we get a <code>thread</code> from <code>ThreadPool</code>. An infinite loop logs a message in <code>thread</code>, increases a <code>counter</code>, and waits for 100 milliseconds.</p>
			<p>In the main part of the code, we do something similar but at a different time. Running this program shows that we get two messages from the inner thread for each message from the outer thread. Now, place a breakpoint on the last <code>Task.Delay()</code> statement. Run the code, let the debugger hit the breakpoint, wait for a few seconds, and continue the run.</p>
			<p>Suppose you do that a couple of times. In that case, you will notice that although the sequence of the messages to the console is slightly different, we still get twice as many messages from the inner thread. In other words, if we pause the outer thread, the inner thread is also paused.</p>
			<p>That is good, of course. You<a id="_idIndexMarker833"/> do not want other threads to continue, wreaking havoc on the program flow. But let’s change things a bit: replace the code where we create the thread with the following:</p>
			<pre class="source-code">
var inThreadCounter = 0;
var timer = new Timer(100);
timer.Elapsed +=
    (_, _) =&gt;
    {
        $"In the timer call with counter {inThreadCounter++}".Dump(ConsoleColor.Yellow);
    };
timer.Start();</pre>			<p>Instead of having a <code>thread</code>, we now have a <code>timer</code>. This code achieves the same effect as our previous code: the <code>timer</code> works on a separate <code>thread</code> when the time has passed. If that happens, we will log the message and increase the counter.</p>
			<p>However, if we repeat the little trick we did with the breakpoint on the code in the last loop, you will notice a completely different behavior. The number of messages from the timer is no longer double the number we get from the main loop; it is much more than that.</p>
			<p>A breakpoint does not stop timers. Neither does it stop classes such as <code>Stopwatch</code>. Time-based events still happen, so you have a different outcome than expected. Be mindful of that when you use timers!</p>
			<h3>Features of breakpoints</h3>
			<p>Breakpoints <a id="_idIndexMarker834"/>are more than <a id="_idIndexMarker835"/>just markers to show the debugger where to stop the execution. They have some properties that can be helpful if you use them correctly. Most of these settings are accessed by clicking the breakpoint in the <strong class="bold">Breakpoints</strong> window and selecting <strong class="bold">Settings</strong>. That window looks like this:</p>
			<div><div><img alt="Figure 1﻿1.1: The Breakpoint Settings window in Visual Studio" src="img/B20924_12_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1: The Breakpoint Settings window in Visual Studio</p>
			<p>You can also get this window by clicking on one of the settings you get when you right-click the breakpoint bullet in the code editor.</p>
			<h4>Active and inactive breakpoints</h4>
			<p>Breakpoints <a id="_idIndexMarker836"/>by default are active, meaning<a id="_idIndexMarker837"/> that if the debugger comes to the statement containing the breakpoint, the execution stops. But you can also disable the breakpoint: this <a id="_idIndexMarker838"/>means the <a id="_idIndexMarker839"/>breakpoint is still there, but it does not do anything. This option can be handy if you are debugging some code but want to skip a specific breakpoint at this time but do not want to delete it.</p>
			<h4>Conditional breakpoints</h4>
			<p>A conditional breakpoint<a id="_idIndexMarker840"/> only breaks when a particular condition<a id="_idIndexMarker841"/> has been met. The condition can be a single condition or a set of conditions, all of which must be true. The condition can include variables from the code as well. Let’s imagine I want a breakpoint in the previous code sample. I want the breakpoint to be on the line with the <code>Task.Delay()</code>code. However, I only want that breakpoint to be active if the <code>outThreadCounter</code> variable is larger than <code>5</code> and only if that breakpoint has been hit 6 times. In our code, that should be the same (every time we go through that loop, <code>outThreadCounter</code> is increased), but if this doesn’t happen, you can verify it using this technique.</p>
			<p>You can specify <a id="_idIndexMarker842"/>this by placing a <a id="_idIndexMarker843"/>breakpoint, right-clicking on it, and then choosing <strong class="bold">Conditions</strong>.</p>
			<h4>Action breakpoints or tracepoints</h4>
			<p><strong class="bold">Action breakpoints</strong> can be real<a id="_idIndexMarker844"/> breakpoints or breakpoints that do not <a id="_idIndexMarker845"/>break. But besides breaking (or not), you <a id="_idIndexMarker846"/>can also specify that the debugger should write something in the <strong class="bold">Output</strong> window. In other words, this is a very lightweight and temporary log system. You can output a static text or the contents of a variable. Underneath the option where you specify the output, you can place a checkmark in the box saying <strong class="bold">Continue code execution</strong>. If you check that box, the debugger does not stop at this breakpoint and only displays the required information in the Output window. When you do not stop executing the code and<a id="_idIndexMarker847"/> only display <a id="_idIndexMarker848"/>some information, we call these breakpoints <strong class="bold">tracepoints</strong>.</p>
			<h4>One-time breakpoint</h4>
			<p>A <strong class="bold">one-time breakpoint</strong> only <a id="_idIndexMarker849"/>works once. It stops code execution when the<a id="_idIndexMarker850"/> breakpoint is hit and then disables itself. If you want to use it again, you must manually enable it. You create this breakpoint by selecting <strong class="bold">Disable breakpoint </strong><strong class="bold">once hit</strong>.</p>
			<h4>Dependent breakpoint</h4>
			<p>The <strong class="bold">dependent breakpoint</strong> is <a id="_idIndexMarker851"/>only enabled after another breakpoint <a id="_idIndexMarker852"/>has been hit. This is particularly useful if you have a method that is called from different places in your code. Still, you only want to debug a particular path. In that case, you create a breakpoint in the flow you are interested in (you might even make it non-breakable so that it only acts as a trigger) and then connect the breakpoint in the method you are interested in into that first breakpoint.</p>
			<p>The effect is that the <a id="_idIndexMarker853"/>breakpoint is disabled until that first breakpoint is hit.</p>
			<p>To see this in action, take our last example. Increase the time for the <code>1</code> second (1000 milliseconds). Then, add a breakpoint to the line where we write the message to the console. Tick the <strong class="bold">Action</strong> box in the properties of this breakpoint, but do not add anything to the <strong class="bold">Message</strong> dialog. However, make sure you tick the <strong class="bold">Continue code execution</strong> box. The settings should look like this:</p>
			<div><div><img alt="Figure 1﻿1.2: Trigger breakpoint" src="img/B20924_12_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2: Trigger breakpoint</p>
			<p>Then, add<a id="_idIndexMarker854"/> another breakpoint <a id="_idIndexMarker855"/>to the line where we write the console the value of <code>outThreadCounter</code>. This time, change the settings to enable the <strong class="bold">Only enable when the following breakpoint is hit</strong> option and select the other breakpoint in the corresponding drop-down menu. That should look like this:</p>
			<div><div><img alt="Figure 1﻿1.3: Depend﻿ent breakpoint" src="img/B20924_12_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3: Dependent breakpoint</p>
			<p>If you run the <a id="_idIndexMarker856"/>program, the debugger ignores the last breakpoint during the first second. Then, the execution stops since our first breakpoint has been hit.</p>
			<p>Of course, you can combine these settings at will.</p>
			<p class="callout-heading">Adding other breakpoints quickly</p>
			<p class="callout">You probably know that you can add breakpoints to your code by clicking in what is known as <strong class="bold">the gutter</strong> to the left of the source code. If you do that, a red bullet appears in that gutter to indicate you have added a breakpoint at that position. But did you know you can also right-click in that gutter? If you do that, you get a pop-up menu to quickly add the breakpoints that were previously mentioned. In the long run, this might save you some mouse clicks!</p>
			<h3>Some other features</h3>
			<p>Breakpoints have <a id="_idIndexMarker857"/>some other<a id="_idIndexMarker858"/> nice features that might be helpful. You usually access these in the <strong class="bold">Breakpoints</strong> window in Visual Studio by right-clicking the chosen breakpoint. Here are some of them:</p>
			<ul>
				<li><strong class="bold">Breakpoints can have labels</strong>: This way, you can give more meaningful names to the breakpoints.</li>
				<li><strong class="bold">You can group breakpoints</strong>: If you create a breakpoint group, you can add breakpoints to them. This way, you can quickly turn a large group of breakpoints on or off instead of going through them individually.</li>
				<li><strong class="bold">You can search for breakpoints</strong>: In the breakpoints window, you can search for class names, line numbers, output, labels, and so on. This feature might be helpful if you have a large group of breakpoints.</li>
				<li><strong class="bold">You can sort breakpoints by name, condition, hit count, label, and more</strong>: If you still can’t find <a id="_idIndexMarker859"/>what you need, you might want to <a id="_idIndexMarker860"/>reconsider your breakpoint strategy!</li>
			</ul>
			<p>Most developers I encounter never come near all these options: all they do is toggle a breakpoint on a line of code to stop execution. But I hope you begin to appreciate the power these tools can bring you.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor247"/>Debug windows</h2>
			<p>Visual Studio has a lot of windows<a id="_idIndexMarker861"/> that can help you get a grip on what is happening when you debug. Most of these windows are useless when editing code but come to life once the debugger starts. Let’s see what we have!</p>
			<h3>Breakpoints</h3>
			<p>We already discussed<a id="_idIndexMarker862"/> breakpoints, but I want to point out<a id="_idIndexMarker863"/> the <strong class="bold">Breakpoints</strong> window. This window is where you see all the breakpoints in your application. It also shows additional information about those breakpoints. You can add columns to the window if you need more information. This is an example of what might look like:</p>
			<div><div><img alt="Figure 1﻿1.4: The Breakpoints window" src="img/B20924_12_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4: The Breakpoints window</p>
			<p>You can customize this window to fit your needs.</p>
			<h3>Locals, autos, and watches</h3>
			<p>When debugging, you probably want to see the values of the variables in your code. To see the value, you can hover the mouse over a variable in the code editor window. However, there are windows in Visual Studio dedicated to giving you access to that data. Let’s explore these.</p>
			<p>The <strong class="bold">Locals</strong> window<a id="_idIndexMarker864"/> shows all <a id="_idIndexMarker865"/>the variables in the current scope. That can be pretty useful: you see all variables in the current block without being distracted by other variables.</p>
			<p>The <strong class="bold">Autos</strong> window<a id="_idIndexMarker866"/> is even better: it tries to guess which variables interest <a id="_idIndexMarker867"/>you when you break in the code and show them and their values.</p>
			<p>Let’s have a look at this. We have the following class:</p>
			<pre class="source-code">
internal class MyClass
{
    public int Counter { get; set; }
}</pre>			<p>We use it in the following code (I added line numbers so I can refer to the lines later on):</p>
			<pre class="source-code">
1: MyClass myClass = new MyClass();
2: int myNumber = 0;
3: while (true)
4: {
5:     myClass.Counter++;
6:     Console.WriteLine($"Counter {myClass.Counter++}");
7: }</pre>			<p>Now, add a breakpoint on <em class="italic">line 3</em>. Run the code and see whether your output matches mine. I will step through all lines from <em class="italic">3</em> up until <em class="italic">7</em> and show you what the <strong class="bold">Autos</strong> window tells me.</p>
			<p>The first breakpoint is on <em class="italic">line 3</em>, so the debugger stops there. It breaks on <em class="italic">line 3</em>, with the following result in the <strong class="bold">Autos</strong> window:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-8">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">Value</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">Type</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>myNumber</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>0</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Int</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.2</p>
			<p>Now, step to the<a id="_idIndexMarker868"/> following line. Then we get, if we stop on <em class="italic">line 4</em>, we get the<a id="_idIndexMarker869"/> following results:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003-6">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Value</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Type</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style"/>
						<td class="No-Table-Style"/>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.3</p>
			<p>As you can see, we get no results. We stopped on <code>{</code>, and no variables can influence the path of the code now. So, there is nothing to show. Let’s continue and step to the following line, <em class="italic">line 5</em>.</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table004-4">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Value</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Type</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>myClass</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>{</code><code>myClass}</code></p>
						</td>
						<td class="No-Table-Style">
							<p>MyClass</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>    <code>Counter</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>0</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Int</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>myClass.Counter</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>0</code></p>
						</td>
						<td class="No-Table-Style">
							<p>int</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.4</p>
			<p>If you step to that line, you will see two items. The top one, <code>myClass</code>, can be expanded so you can see properties that might interest you. In our case, this is <code>myClass.Counter</code>. We also see the <code>myClass.Counter</code> variable separately since the compiler is smart enough to see this is significant in our code.</p>
			<p>Let’s move to the next line, <em class="italic">line 6</em>.</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table005-3">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Value</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Type</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>MyClass.Counter.get returned</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>0</code></p>
						</td>
						<td class="No-Table-Style">
							<p>int</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>myClass</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>{</code><code>myClass}</code></p>
						</td>
						<td class="No-Table-Style">
							<p>MyClass</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>    </code><code>Counter</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>1</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Int</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>myClass.Counter</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>1</code></p>
						</td>
						<td class="No-Table-Style">
							<p>int</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.5</p>
			<p>That is interesting: the <code>MyClass.Counter.get</code>) and got <a id="_idIndexMarker871"/>a result. There is also an icon to show you that this is indeed the return value. The “get” returned zero, but then we applied the <code>++</code> operator to change the value locally.</p>
			<p>The next line, <em class="italic">line 7</em>, produces this:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table006-2">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Value</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Type</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>MyClass.Counter.get returned</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>1</code></p>
						</td>
						<td class="No-Table-Style">
							<p>int</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToStringAndClear returned</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>Counter 1</code></p>
						</td>
						<td class="No-Table-Style">
							<p>string</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.6</p>
			<p>We printed the line of text to the console and did that with the <code>$</code> interpolation command in front of the string. Now, you can see that doing that caused the <code>System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToStringAndClear()</code> method to be called, returning the resulting <code>Counter 1</code> string. Oh, and we lost <code>myClass</code> (well, it’s not lost; it’s just not shown any more since we will not use it in this scope anymore). As you can see, the <strong class="bold">Locals</strong> window is good at showing values of local variables and helping you figure out implicit method calls, such as the string interpolation and property getters!</p>
			<p>The <strong class="bold">Locals</strong> window<a id="_idIndexMarker872"/> is pretty clever at figuring out what you need to see. Of <a id="_idIndexMarker873"/>course, if you disagree, there is always the <strong class="bold">Watch</strong> window.</p>
			<p>The <strong class="bold">Watch</strong> window<a id="_idIndexMarker874"/> does the same as the previous two debug windows, but it only shows <a id="_idIndexMarker875"/>you what you ask it to show. Once the debugger stops the flow of your program, you can right-click on a variable and select <strong class="bold">Add to Watch</strong>. The variable will then pop up in the <strong class="bold">Watch</strong> window, where you can do the same things as you can do with <strong class="bold">Locals</strong> and <strong class="bold">Autos</strong>: inspect the variables and <a id="_idIndexMarker876"/>change<a id="_idIndexMarker877"/> the values if needed.</p>
			<p>However, this time, the variables stay there until you remove them. Suppose they go out of scope or are unreachable. In that case, you get an error in the <strong class="bold">Watch</strong> window telling you the variable does not exist in the current context. That doesn’t harm your experience, though: it will stay there as long as you need it, and if the variable comes back into context (in this or in a subsequent debugging session), it will be back again.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor248"/>Diagnostic Tools</h2>
			<p>The <strong class="bold">Diagnostic Tools</strong> window<a id="_idIndexMarker878"/> almost deserves its very own book. It does many things for us! Let’s dive into it.</p>
			<p>As with most other debugging tools in Visual Studio, you cannot use the <strong class="bold">Diagnostic Tools</strong> until you are at a breakpoint in your code while debugging. We will use a very silly program to show you some of <strong class="bold">Diagnostic Tools</strong>’ possibilities. It’s a <strong class="bold">console application</strong>, and the code looks like this:</p>
			<pre class="source-code">
var memoryBlock = new Dictionary&lt;int, byte[]&gt;();
var passCounter = 0;
while (true)
{
    passCounter++;
    var newBlock = new byte[1024 * 1024];
    memoryBlock.Add(passCounter, newBlock);
}</pre>			<p>I also place a conditional breakpoint on the line with <code>passCounter++</code> (so, the first statement is in the while-loop). That condition looks like this:</p>
			<pre class="source-code">
passCounter % 100 == 0</pre>			<p>In other words, the breakpoint stops every 100 passes.</p>
			<p>If we run this, the application will break on the first pass. That makes sense: 0 % of 100 equals 0. You can<a id="_idIndexMarker879"/> then open the <strong class="bold">Diagnostic Tools</strong> window (if it doesn’t show up automatically, you can open it by going to the <strong class="bold">Debug</strong> menu, then choosing <strong class="bold">Windows</strong>, followed by selecting <strong class="bold">Show Diagnostic Tools</strong>). I suggest you make the window bigger than usual so you can see all the goodies it gives us. Mine looks like this:</p>
			<div><div><img alt="Figure 1﻿1.5: The Diagnostic Tools window" src="img/B20924_12_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5: The Diagnostic Tools window</p>
			<p>At the top of the <a id="_idIndexMarker880"/>window, there are some charts. Since nothing has happened yet in our program, these are not very interesting. But that will change! Below the charts, there are some tabs. Initially, you see the <strong class="bold">Summary</strong> tab, which summarizes the contents of the other tabs.</p>
			<p>In the <strong class="bold">Summary</strong> tab, click <strong class="bold">Take Snapshot</strong> under the <strong class="bold">Memory Usage</strong> title. You can also do that in the <strong class="bold">Memory Usage</strong> tab itself. Doing this saves the current memory usage and allows it to be compared to a later point in time. Since our application hasn’t done much, this could give us a baseline. So, click on <strong class="bold">Take Snapshot</strong>. Then, continue running the program.</p>
			<p>If you click <strong class="bold">Take Snapshot</strong>, the window <a id="_idIndexMarker881"/>should show you the <strong class="bold">Memory Usage</strong> tab, which shows the snapshot. Since we continued the program, we are not on the 100th iteration, so we can take another snapshot. Do that. That results in my system in this view:</p>
			<div><div><img alt="Figure 1﻿1.6: Second pass in the Diagnostic Tools window" src="img/B20924_12_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6: Second pass in the Diagnostic Tools window</p>
			<p>This is getting more interesting. We can see in the <strong class="bold">Process Memory (MB)</strong> chart that we have started to allocate a lot more memory. But the real exciting stuff happens in the <strong class="bold">Memory Usage</strong> tab below. You can see a lot here: in the second snapshot, we can see that we have allocated more objects and memory.</p>
			<p>You can click on most<a id="_idIndexMarker882"/> values, such as <code>Count Diff.</code> column to sort on that.)</p>
			<div><div><img alt="Figure 1﻿1.7: Memory snapshot" src="img/B20924_12_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7: Memory snapshot</p>
			<p>We have 99 more <code>Byte[]</code> objects in memory, resulting in an increase of 104,858,955 bytes of memory.</p>
			<p>You can do all sorts of things here. You can click on the line you want to learn more about and then drill down into the source code of that object. That way, you can probably discover why your memory usage is increasing.</p>
			<p>A lot is going on in <strong class="bold">Diagnostic Tools</strong>. I suggest you play around with it and see what it can tell you about your system!</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor249"/>Debugging multithreaded and asynchronous code</h1>
			<p>Let’s join the league of super debuggers. We are about to embark on a journey into the depths of multithreaded systems and where they go wrong.</p>
			<p>Multithreaded code<a id="_idIndexMarker883"/> is notoriously hard to debug. Imagine you have two threads that interact with each other, and then things go wrong. However, if you step through the methods in Visual Studio, things work just fine, and that makes sense: some bugs appear only when certain timing conditions happen.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor250"/>Parallel Watch</h2>
			<p>What about this: you have multiple<a id="_idIndexMarker884"/> threads, and something goes wrong. You want to inspect what happens in that thread. But if you set a breakpoint, how do you know you are in the correct thread?</p>
			<p>Fear not: Visual Studio can help with this. Let’s start with the following code:</p>
			<pre class="source-code">
var rnd = new Random();
for (int i = 0; i &lt; 10; i++)
{
    int threadNumber = i;
    ThreadPool.QueueUserWorkItem(_ =&gt;
    {
        var counter = 0;
        while (true)
        {
            $"Thread {threadNumber} with counter {counter++}".Dump(ConsoleColor.Yellow);
            Task.Delay(rnd.Next(1000)).Wait();
        }
    });
}</pre>			<p>This code creates 10 threads. Each thread has an infinite loop, displaying some text and counting up. However, each thread does this at a different speed: they all wait for a random time between each iteration.</p>
			<p>Place a conditional <a id="_idIndexMarker885"/>breakpoint somewhere in that loop, with the condition saying it should break with this condition: <code>counter % 10 == 0</code>. Now, run the program.</p>
			<p>You see the <code>counter</code> value in the <strong class="bold">Autos</strong> or <strong class="bold">Locals</strong> windows. That can be helpful; that variable is local to the thread you are currently in. Visual Studio did pause all other threads for us, but we have no idea what the state of the data is in those threads. How can we find out?</p>
			<p>The answer to that question is this: open the <strong class="bold">Parallel Watch</strong> window. Again, you can find this in the <strong class="bold">Debug</strong> | <strong class="bold">Windows</strong> menu. On my system, after breaking in my breakpoint, it looks like this:</p>
			<div><div><img alt="Figure 1﻿1.8: The Parallel Watch window" src="img/B20924_12_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8: The Parallel Watch window</p>
			<p>In this particular case, I have apparently stopped execution in thread 14628. That doesn’t tell me much.</p>
			<h3>Add a Parallel Watch</h3>
			<p>But as you can <a id="_idIndexMarker886"/>see, on the top of the window, it says <code>counter</code> variable there. As soon as I do that, the <strong class="bold">Watch</strong> window shows me the value of that variable, but it does that for each thread:</p>
			<div><div><img alt="Figure 1﻿1.9: Parallel Watch with counter added" src="img/B20924_12_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9: Parallel Watch with counter added</p>
			<p>As you can see in the screenshot, all threads have their version of the <code>counter</code>, each with a different value. This is helpful!</p>
			<h3>Jumping to frames</h3>
			<p>Although this <a id="_idIndexMarker887"/>window is primarily a <strong class="bold">Watch</strong> window, meaning it shows the variables you are interested in and their values, there are other things you can do here as well.</p>
			<p>Since we stopped somewhere in the loop, you can hover over the variables in your code to see the values. However, as we discovered, those values only apply to that thread. You can add all the variables you are interested in into the <strong class="bold">Parallel Watch</strong> window, but what if you just want to see a variable once? Well, the <strong class="bold">Parallel Watch</strong> window can help you. Select one of the other threads in that window and right-click on that line, and you will see a context menu. One of the options is <strong class="bold">Switch To Frame</strong>. If you do that, the debugger makes the chosen thread the current one, allowing you to investigate the values of all variables in scope for that particular thread.</p>
			<p>This way, you can jump between all active threads and inspect all values of all variables in scope per thread.</p>
			<h3>Freezing and thawing threads</h3>
			<p>The ability to inspect variables in different threads is a potent tool. You can probably imagine that certain variables affect other threads. Finding issues usually requires a lot of logging and inspections of those logs to determine the results of unwanted behavior. Being able to break the code and see what is happening saves you from a lot of that work.</p>
			<p>But sometimes, all<a id="_idIndexMarker888"/> those threads running simultaneously can get in the way. In those cases, you might want to focus on one or some threads in isolation. The <strong class="bold">Freeze</strong> and <strong class="bold">Thaw</strong> options<a id="_idIndexMarker889"/> can help in this situation.</p>
			<p>Freezing a thread is nothing more than pausing it during debugging. You temporarily halt the execution of one or more threads so you can focus on what is important to you. When you have all the information you need, you can thaw the frozen threads and let them resume their regular work. You can use the <strong class="bold">Thread</strong> window, but you can also do that in the <strong class="bold">Parallel Watch</strong> window. All you have to do is right-click on the thread you want to freeze and select <strong class="bold">Freeze</strong> from the context menu. If you resume the program, the thread you have chosen to freeze will not do anything anymore.</p>
			<p>To see that behavior in action, change the number of threads in our code to 2 instead of 2. Rerun the program and see which thread is active when the breakpoint hits. Obviously, one of the threads will cause the breakpoints condition (the <code>counter</code> variable in that thread must be a multiple of 10) to be satisfied. If you then resume the program, the other thread will likely be the following thread to stop: it is probably also close to satisfying the condition (I say “probably,” since the random behavior of the <code>Wait()</code> statement might, in theory, make it possible to act otherwise).</p>
			<p>Restart the program and wait for the first time the breakpoint becomes active. This time, right-click on the other thread and select <strong class="bold">Freeze</strong>. Resume the program.</p>
			<div><div><img alt="Figure 1﻿1.10: Freezing threads in Parallel Watch" src="img/B20924_12_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10: Freezing threads in Parallel Watch</p>
			<p>A pause <a id="_idIndexMarker890"/>symbol should be in front of the chosen thread. Resume the program. When the program breaks again, it will be on the same thread as the first<a id="_idIndexMarker891"/> time it did this. If you resume, the third time will also be on that thread. That makes sense: the other thread is not doing anything and thus never satisfies the breakpoint conditions.</p>
			<p>Now, you can work on that one working thread to make sure you get what is going on. When you are ready to have the thread join the rest of the program, wait until the breakpoint happens again. Then, you can right-click the frozen thread and “thaw” it. Resume the program and see whether everything is back to normal: the debugger will break as soon as the condition is met in any of the threads.</p>
			<p class="callout-heading">Freeze and Thaw: a word of warning</p>
			<p class="callout">As you probably saw, the program continues after thawing the thread without adjusting anything. Typically, the <code>counter</code> variable values in both threads should be close to each other. However, after freezing one thread, it falls behind, and it doesn’t catch up on that lag anymore. Freezing and thawing threads can have an unpredictable side effect: if the rest of your code somehow relies on that thread running, you might have inadvertently changed the logic flow. So, be aware of that!</p>
			<p>Freezing and thawing can be a lovely addition to your tool belt. So, use them if needed, but use them wisely!</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor251"/>Debugging deadlocks with Parallel Stacks and Thread windows</h2>
			<p>Deadlocks are pretty<a id="_idIndexMarker892"/> nasty. Simply put, a <strong class="bold">deadlock</strong> is when two threads wait for each other and thus cannot continue. It’s like driving your car on a narrow road and seeing someone coming from the other side. One of you will have to back off, or you will never leave that road. Deadlocks are like that, but your application freezes since neither of the involved threads is willing to drive back. I think it is obvious that you would not want that in your code.</p>
			<p>However, as simple as the issue sounds, it can be challenging to debug and fix. But Visual Studio is here to help!</p>
			<p>Let’s begin with <a id="_idIndexMarker893"/>a simple program. This is the code:</p>
			<pre class="source-code">
"Starting the threads".Dump(ConsoleColor.Cyan);
var lockA = new object();
var lockB = new object();
ThreadPool.QueueUserWorkItem(_ =&gt;
{
    lock (lockA)
    {
        "Thread 1 acquired lock A".Dump(ConsoleColor.Yellow);
        Thread.Sleep(1000);
        lock (lockB)
        {
            "Thread 1 acquired lock B".Dump(ConsoleColor.Yellow);
        }
    }
});
ThreadPool.QueueUserWorkItem(_ =&gt;
{
    lock (lockB)
    {
        "Thread 2 acquired lock B".Dump(ConsoleColor.Blue);
        Thread.Sleep(1000);
        lock (lockA)
        {
            "Thread 2 acquired lock A".Dump(ConsoleColor.Blue);
        }
    }
});
"Waiting for all threads to finish".Dump(ConsoleColor.Cyan);
Console.ReadLine();</pre>			<p>What do we do <a id="_idIndexMarker894"/>here? Simply put, we create two threads. They each use a <code>lock</code> statement. This means no other thread can enter that scope until the thread that owns the <code>lock</code> statement is done. That is not an issue in this code: both threads use a different <code>lock</code>. However, we also tried to use the other <code>lock</code> object in the thread. Because we have a <code>Thread.Sleep(1000)</code> in each thread, both threads have enough time to acquire the <code>lock</code> before accessing the other <code>lock</code>. But that never happens. No thread can release the <code>lock</code> since it waits for the other thread – and vice versa.</p>
			<p>Run it. You will see that both threads print out their initial statements about acquiring their <code>lock</code>s. And then: nothing. The program is completely frozen. It doesn’t do anything anymore. We have a deadlock on our hands.</p>
			<p>In this case, what is going on is obvious. Still, I am sure you can imagine these situations can be tricky to find in typical programs. The good news is that Visual Studio usually knows what is happening and can tell us.</p>
			<p>Stop the <a id="_idIndexMarker895"/>program execution by going to the <strong class="bold">Debug</strong> menu, and then clicking on <strong class="bold">Break All</strong>. When Visual Studio has the focus, you can also press <em class="italic">Ctrl</em> + <em class="italic">Alt</em> + <em class="italic">Break</em>.</p>
			<p>Breaking like this stops all threads as if the debugger has hit a breakpoint. Visual Studio stops at one of the three threads (the main thread or one of the bad-behaving ones), and you get a warning like this one:</p>
			<div><div><img alt="Figure 1﻿1.11: Deadlock detected by Visual Studio" src="img/B20924_12_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11: Deadlock detected by Visual Studio</p>
			<p>So, at least know what caused the freezing: we have a deadlock. It is time to find out what is going on.</p>
			<h3>Parallel Stacks</h3>
			<p>In <em class="italic">Figure 11</em><em class="italic">.12</em>, you see <a id="_idIndexMarker896"/>the <strong class="bold">Show Parallel Stacks</strong> option in that dialog <a id="_idIndexMarker897"/>box. You can also get the <strong class="bold">Parallel Stacks</strong> window through the <strong class="bold">Debug</strong> | <strong class="bold">Windows</strong> menu option. Doing that gives you a nice visual representation of all currently known threads. On my machine, that looks like this:</p>
			<div><div><img alt="Figure 1﻿1.12: Parallel Stacks in action" src="img/B20924_12_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12: Parallel Stacks in action</p>
			<p>Since we have very few threads running, spotting the issue is straightforward. The offending threads are marked with a red circle with a white line: the symbol globally known as a stop sign. This symbol indicates the threads that are currently deadlocked. To make it even more apparent, the information box below says <strong class="bold">[Deadlocked, double-click or press enter to view]</strong>. You can double-click on the <strong class="bold">Waiting on lock</strong> line to jump to the source code for this thread.</p>
			<p>This window helps you identify thread issues very quickly. You can see which threads are running, if there are any issues, and where those threads originated from.</p>
			<p>But if that is not enough, you can go deeper by looking at the <strong class="bold">Threads</strong> window.</p>
			<h3>Threads window</h3>
			<p>As you might have<a id="_idIndexMarker898"/> guessed from the name, the <strong class="bold">Threads</strong> window <a id="_idIndexMarker899"/>shows you all the threads you might be interested in. Let’s continue with our deadlock example. You have looked at <strong class="bold">Parallel Stacks</strong>, but you cannot find what is happening.</p>
			<p>So, you open the <strong class="bold">Threads</strong> window. On my machine, it looks like this:</p>
			<div><div><img alt="Figure 1﻿1.13: The Threads window" src="img/B20924_12_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13: The Threads window</p>
			<p>These are all the threads currently known in my application. They are all up and running, and the current thread has an ID of <code>95264</code> (or managed thread ID <code>10</code>). It is a thread from the thread pool since the name is <code>.NET TP Worker</code>. You can also see the location: it is in my application.</p>
			<p>If you click on <a id="_idIndexMarker900"/>the down arrow next to the name, you get more <a id="_idIndexMarker901"/>details:</p>
			<div><div><img alt="Figure 1﻿1.14: The Thread window with more details" src="img/B20924_12_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14: The Thread window with more details</p>
			<p>As you can see in the screenshot, this gives me more information, including the text that this thread is deadlocked and is waiting on a lock owned by thread <code>14840</code>. The <strong class="bold">Thread</strong> window also shows information about that particular thread, so you can open that one if you want to. Double-clicking on the location brings you to the source code, where you can investigate what you were doing before the whole thing came crashing.</p>
			<p>Debugging threading issues is not easy. But without these tools, they can be found more easily than ever before. Of course, the best course of action is not to make mistakes in the first place, but as I explained to my manager all those years ago, we do not live in that kind of world.</p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor252"/>Profiling application performance</h1>
			<p>By now, we have established that system programmers care about speed. Applications need to be as efficient and as fast as possible. But what if you think your application can go faster but do not know where or what to improve? That is where profiling and benchmarking can help.</p>
			<p>Profiling is<a id="_idIndexMarker902"/> measuring and analyzing the performance of your application in terms of factors such as CPU usage, memory pressure, network performance, and so on. It’s like putting your app under a microscope. Things we look at during profiling are, amongst others, the following:</p>
			<ul>
				<li><strong class="bold">CPU usage</strong>: Identify which parts of your application are using the most processing power</li>
				<li><strong class="bold">Memory usage</strong>: Track how much memory is used and finding memory leaks or excessive allocations</li>
				<li><strong class="bold">Function call frequency</strong>: See which methods are called the most and how long they take</li>
				<li><strong class="bold">Performance hotspots</strong>: Pinpoint areas of code that are slower than they should be</li>
			</ul>
			<p><strong class="bold">Benchmarking</strong> is related, but<a id="_idIndexMarker903"/> it is different. Benchmarking is measuring the performance of your code under different circumstances or comparing different approaches. This process involves running predefined tests and capturing metrics. Some of the metrics are the following:</p>
			<ul>
				<li><strong class="bold">Execution time</strong>: Measuring how long it takes for a piece of code to run</li>
				<li><strong class="bold">Throughput</strong>: Assessing how many operations or transactions can be processed in a given period</li>
				<li><strong class="bold">Latency</strong>: Determining the delay between the initiation and the execution of a task</li>
			</ul>
			<p>Profiling and <a id="_idIndexMarker904"/>benchmarking <a id="_idIndexMarker905"/>go hand in hand and are often used together to improve your application.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor253"/>The prime application</h2>
			<p>To investigate<a id="_idIndexMarker906"/> how we might do this, let’s start with a program we want to improve performance. It is a simple program that calculates all the primes in the range 0 – 100,000 and sums them up. It’s nothing fancy or helpful, but it requires the CPU to do much work. We also want to see whether we can make things better. So, let’s start by looking at the code. First, we create a class called <code>PrimeCalculator</code>. That’s easy enough. The main method of this class is the <code>Run</code> method. It looks like this:</p>
			<pre class="source-code">
public void Run()
{
    var limit = 100000;
    var stopwatch = Stopwatch.StartNew();
    var sum = SumOfPrimes(limit);
    stopwatch.Stop();
    $"Sum of primes up to {limit}: {sum}".Dump();
    $"Time taken: {stopwatch.ElapsedMilliseconds} ms".Dump();
}</pre>			<p>There is nothing special going on here. We create a <code>Stopwatch</code> to time the duration, then call the <code>SumOfPrimes()</code> method that does all the actual work. Finally, we display the results and the duration.</p>
			<p>Let’s look at <code>SumOfPrimes()</code> next:</p>
			<pre class="source-code">
private long SumOfPrimes(int limit)
{
    long sum = 0;
    for (var i = 2; i &lt;= limit; i++)
        if (IsPrime(i))
            sum += i;
    return sum;
}</pre>			<p>This code is also <a id="_idIndexMarker907"/>pretty basic. We loop for all values between <code>2</code> and the given limit (<code>2</code> since <code>1</code> is technically not a prime number) and check whether that number is a prime. If it is, we add it to the sum. Let’s move to <code>IsPrime()</code>:</p>
			<pre class="source-code">
private bool IsPrime(int number)
{
    if (number &lt; 2) return false;
    for (var i = 2; i &lt;= Math.Sqrt(number); i++)
        if (number % i == 0)
            return false;
    return true;
}</pre>			<p>This method is a lousy implementation to see whether a number is a prime, but it is simple enough to follow. We do this by checking whether the number we give it is divisible by any number that is less than the square root of that number. If it is divisible, it is not a prime.</p>
			<p>For example, if I run this on the machine I am writing this text on, I get the sum of 454, 396, 537 and a total duration of 21 milliseconds. I have no idea if that sum is correct; I have no intention of calculating it by hand on my calculator app on my phone. It doesn’t matter: we are here to see whether we can spot bottlenecks.</p>
			<p>21 milliseconds<a id="_idIndexMarker908"/> sounds like a short amount of time, but in reality, it is pretty long. After all, computers are fast these days, so I am sure I can improve on it. We can use the profiling tools from Visual Studio to see where the bottlenecks are.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor254"/>Profiling in Visual Studio</h2>
			<p>In Visual Studio, under<a id="_idIndexMarker909"/> the main <strong class="bold">Debug</strong> menu, you find the <strong class="bold">Performance Profile</strong> option. The default shortcut key for that is <em class="italic">Alt</em> + <em class="italic">F2</em>, which might be helpful if you repeatedly run this (and you will!)</p>
			<p>If you select that option, you see the following screen:</p>
			<div><div><img alt="Figure 1﻿1.15: Start of a profiling session" src="img/B20924_12_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15: Start of a profiling session</p>
			<p>Profiling can be done <a id="_idIndexMarker910"/>on many different levels. However, the most crucial choice is what you want to profile. By default, this tool chooses the current application. As you can see, in my case, that is the <code>11_Profiling</code> project. You can select other projects or running processes, browse for an application, and so on. Click that large <strong class="bold">Change Target</strong> button to change if necessary. There is also a warning underneath that button: we might want to switch from a Debug profile to a Release profile. Release is more closely related to what you run in production, so the figures you get are more like the ones you expect to see when you have deployed your application. However, Release mode optimizes your code, making it harder to find programming mistakes. So, I tend to leave it to Debug during development.</p>
			<p>Then, you have to decide what you want to see. There are many options here: you might want to see async/awaits, or maybe you are interested in database communications. In my case, I want to know about <strong class="bold">CPU Usage</strong>. I also leave <strong class="bold">.NET Counters</strong> and <strong class="bold">Memory Usage</strong> checked; they might be helpful.</p>
			<p>If you click the <strong class="bold">Start</strong> button, your program will build and run. In the background, Visual Studio starts collecting the information.</p>
			<p>In our case, the program<a id="_idIndexMarker911"/> runs and ends, signaling Visual Studio to stop collecting. If your application keeps running, you must stop the program manually or click the <strong class="bold">stop collecting</strong> button in Visual Studio.</p>
			<p>Once you have done that, Visual Studio shows you an overview of what it has collected.</p>
			<div><div><img alt="Figure 1﻿1.16: First results from a profiling session" src="img/B20924_12_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16: First results from a profiling session</p>
			<p>The results are not that impressive since we have a straightforward program. However, you can see in the <code>_11_Profiling.PrimeCalculator.IsPrime(int)</code> method takes a lot of time: 10 microseconds, or 10.64% of the total time.</p>
			<p>That is good to know, but we want to see whether we can get more information. Click on that line, and you will get another view. You can select what you want to see at the top of that view. By default, you see all data grouped by <strong class="bold">Functions</strong>, but I want to see the call path. If you do that, you get this result:</p>
			<div><div><img alt="Figure 1﻿1.17: The hot path leading to the slowest function" src="img/B20924_12_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17: The hot path leading to the slowest function</p>
			<p>You can<a id="_idIndexMarker912"/> click <strong class="bold">Show Hot Path</strong> and <strong class="bold">Expand Hot Path</strong> to see how the process came to the slowest function.</p>
			<p>Finally, you can double-click on a line to see the source code. So, if you double-click on the <code>IsPrime()</code> method, you get this:</p>
			<div><div><img alt="Figure 1﻿1.18: The slowest lines of code highlighted" src="img/B20924_12_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18: The slowest lines of code highlighted</p>
			<p>Now, it becomes clear that the loop is the slowest part of the <code>IsPrime()</code> function. That makes sense: to make this loop work, the CPU has to calculate <code>Math.Sqrt(number)</code> every time. That takes time. How to improve that is obvious: pre-calculate that square root and use that variable in the <code>for</code> statement. That should speed things up!</p>
			<p>As you can see, with the<a id="_idIndexMarker913"/> proper tooling, you can identify the bottlenecks in your application. Once you find them, you can restructure your code or replace parts with something faster. But how do you know which algorithm to use to speed things up? The answer to that is this: benchmark them!</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor255"/>Benchmarking different solutions</h2>
			<p>I know that the <code>number % i ==0</code> line is not the fastest way to see whether a number is divisible by another number. However, I am not really sure how much quicker other ways are. To find out, I <a id="_idIndexMarker914"/>can use some benchmarking to figure it out.</p>
			<p>There are several ways you can start with benchmarking, but in a case such as this, where I have several options for a specific algorithm, I like to use the <code>Benchmarkdotnet</code> NuGet package. This free package makes benchmarking simple.</p>
			<p>To do this, start a<a id="_idIndexMarker915"/> new console application. Add the <code>Benchmarkdotnet</code> package to the project. Then, create a new class. I call this class <code>ModuloTesters</code> since I want to test the performance of the <code>Module</code> operator and any alternatives I can find.</p>
			<p>I added a method called <code>TestModulo</code>. That method looks like this:</p>
			<pre class="source-code">
[Benchmark]
public void TestModulo()
{
    var numberOfMatches = 0;
    for (var i = 3; i &lt; numberOfLoopCount; i++)
        if (testNumber % i == 0)
            numberOfMatches++;
}</pre>			<p>As you can see, it is pretty simple. I just go through several iterations (<code>numberOfLoopCount</code> is defined as a constant in my class, and I have set it to 100,000) and calculate the modulo (<code>testNumber</code> is again a constant; it doesn’t really matter what it is, but I have set it to 400). The only thing that makes this method stand out from a typical method is the <code>[Benchmark]</code> attribute. This tells the benchmark tool that this method needs to be measured.</p>
			<p>In the main program file, we need to kickstart the benchmarking. That is extremely easy: just add this line of code:</p>
			<pre class="source-code">
var summary = BenchmarkRunner.Run&lt;ModuloTesters&gt;();</pre>			<p>Set the build mode to <code>Release</code>, and run without debugging. The <code>Benchmark</code> tool will run the methods marked with <code>Benchmark</code> a couple of times (well, more than just a couple) and present you with the results.</p>
			<p>But before we look at those<a id="_idIndexMarker916"/> results, we need to add something. Benchmarking is meant to compare solutions to a problem. Right now, we have one solution: the modulo operator. So, there is nothing to compare against. Let’s fix that. Add a new method to the <code>ModuloTesters</code> class that looks like this:</p>
			<pre class="source-code">
Benchmark]
public void TestMultiplicationAndDivision()
{
    var numberOfMatches = 0;
    for (var i = 3; i &lt; numberOfLoopCount; i++)
        if (testNumber - i * (testNumber / i) == 0)
            numberOfMatches++;
}</pre>			<p>This is another way of calculating a module. But is it faster? There is only one way to find out: run the benchmark! If you do that, you see the results. On my machine, it looks like this:</p>
			<div><div><img alt="Figure 1﻿1.19: Benchmark results" src="img/B20924_12_19.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19: Benchmark results</p>
			<p>So, the new algorithm is<a id="_idIndexMarker917"/> quicker: it takes 316.4 microseconds instead of 316.7 microseconds. Ok, I admit it is not that much faster. Maybe we can do better. You know what? We can. Let’s add a third benchmark:</p>
			<pre class="source-code">
[Benchmark]
public void TestMultiplicationAndDivisionInParallel()
{
    var numberOfMatches = 0;
    var localNumberOfLoopCount = numberOfLoopCount;
    var localTestNumber = testNumber;
    var lockObj = new object();
    Parallel.For(3, localNumberOfLoopCount, i =&gt;
    {
        var div = localTestNumber / i;
        if (localTestNumber == i * div)
            lock (lockObj)
            {
                numberOfMatches++;
            }
    });
}</pre>			<p>Since all the calculations<a id="_idIndexMarker918"/> can be done independently, we can probably do them in parallel. So, that is what I am doing here: I use the <code>Parallel.For()</code> statement to divide the work into jobs that run simultaneously. I need a lock to update <code>numberOfMatches</code>, which might slow down the loop. But that is a guess: let’s test this. Run the benchmark. This is what I get:</p>
			<div><div><img alt="Figure 1﻿1.20: New benchmark results" src="img/B20924_12_20.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.20: New benchmark results</p>
			<p>Now, that is interesting. The addition of <code>Parallel.For()</code> made a massive difference in the time spent on that method.</p>
			<p>If you think that could benefit your code, you can apply the findings to the actual application you are working on. Of course, I would profile it first, make the changes, and then profile again to see whether you have not added new bottlenecks. But all in all, I think we have made our prime calculator a lot faster!</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor256"/>Other tools</h1>
			<p>Visual Studio<a id="_idIndexMarker919"/> is an excellent tool for debugging and profiling your system. However, it is not the only one. There are many other solutions out there that can help you debug and profile your code. Some of them are paid, others are free. Some are easy to use, some are pretty hard to get to know. I will not discuss the other tools, but I want to give you a small list so you can investigate them for yourself.</p>
			<p>Please look at what Visual Studio gives you first. Chances are, what you need is already there!</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor257"/>Debugging tools</h2>
			<p>There are many debugging tools<a id="_idIndexMarker920"/> out there. This is just a sample of what you can try out.</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table007">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Tool Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Company</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Visual </strong><strong class="bold">Studio Debugger</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Integrated<a id="_idIndexMarker921"/> into Visual Studio, supports .NET, C++, and <a id="_idIndexMarker922"/>other languages with breakpoints, watch variables, and more.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">WinDbg</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A <a id="_idIndexMarker923"/>multipurpose debugger for Windows, useful for debugging <a id="_idIndexMarker924"/>user-mode and kernel-mode code and analyzing crash dumps.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Visual Studio </strong><strong class="bold">Code Debugger</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Built into <a id="_idIndexMarker925"/>Visual Studio Code, supports various languages and platforms through extensions, with breakpoints <a id="_idIndexMarker926"/>and variable inspection.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Managed </strong><strong class="bold">Debugger (MDbg)</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A simple<a id="_idIndexMarker927"/> command-line debugger<a id="_idIndexMarker928"/> for .NET applications, offering basic debugging capabilities for managed code.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Debug Diagnostic </strong><strong class="bold">Tool (DebugDiag)</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Assists<a id="_idIndexMarker929"/> in troubleshooting application crashes, hangs, memory leaks, and performance <a id="_idIndexMarker930"/>issues in user-mode processes.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">ProcDump</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Command-line<a id="_idIndexMarker931"/> utility to monitor applications for CPU spikes<a id="_idIndexMarker932"/> and generate crash dumps for analysis.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Microsoft Performance </strong><strong class="bold">Tools (PerfView)</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Performance <a id="_idIndexMarker933"/>analysis tool for collecting and analyzing ETW data, valuable for .NET application performance and<a id="_idIndexMarker934"/> memory issues.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Son of Strike (SOS) Debugging </strong><strong class="bold">Extension</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>An extension<a id="_idIndexMarker935"/> for WinDbg that provides<a id="_idIndexMarker936"/> insights into .NET runtime internals, aiding in-depth debugging of .NET applications.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Windows Performance </strong><strong class="bold">Recorder (WPR)</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Tools <a id="_idIndexMarker937"/>for recording and analyzing performance data on Windows systems, capturing detailed <a id="_idIndexMarker938"/>system and application behavior.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Remote </strong><strong class="bold">Debugging Tools</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Tools for <a id="_idIndexMarker939"/>debugging applications running on<a id="_idIndexMarker940"/> different machines or environments, supporting both managed and native code.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">GNU </strong><strong class="bold">Debugger (GDB)</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A powerful debugger for <a id="_idIndexMarker941"/>various programming languages, especially C and C++, to see <a id="_idIndexMarker942"/>what is happening inside a program.</p>
						</td>
						<td class="No-Table-Style">
							<p>GNU Project</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">LLVM </strong><strong class="bold">Debugger (LLDB)</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A <a id="_idIndexMarker943"/>modern, high-performance debugger part of <a id="_idIndexMarker944"/>the LLVM project, supporting languages such as C, C++, and Objective-C.</p>
						</td>
						<td class="No-Table-Style">
							<p>LLVM Project</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Valgrind</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A<a id="_idIndexMarker945"/> programming tool for memory debugging, memory leak <a id="_idIndexMarker946"/>detection, and profiling, including tools such as Memcheck.</p>
						</td>
						<td class="No-Table-Style">
							<p>Valgrind Developers</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Strace</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A <a id="_idIndexMarker947"/>diagnostic, debugging, and instructional utility for Linux that<a id="_idIndexMarker948"/> traces system calls and signals.</p>
						</td>
						<td class="No-Table-Style">
							<p>Open Source</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.7: Debugging tools</p>
			<p>I do not endorse any of these products; I have merely listed them here for your convenience.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor258"/>Profiling tools</h2>
			<p>Profiling tools<a id="_idIndexMarker949"/> are also easy to find. A lot of companies next to Microsoft offer solutions for this. They each have their own strengths and weaknesses. So, please look at the following table as a guideline to help you find what is best for you.</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table008">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Tool Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Company</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Visual </strong><strong class="bold">Studio Profiler</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Integrated <a id="_idIndexMarker950"/>into Visual Studio, provides detailed <a id="_idIndexMarker951"/>performance and memory usage data for .NET and C++ applications.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">WPR</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Captures<a id="_idIndexMarker952"/> detailed performance data on Windows systems for<a id="_idIndexMarker953"/> in-depth analysis.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Windows Performance </strong><strong class="bold">Analyzer (WPA)</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Analyzes <a id="_idIndexMarker954"/>performance data <a id="_idIndexMarker955"/>collected by WPR, helping to identify performance issues.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">PerfView</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Collects <a id="_idIndexMarker956"/>and analyzes ETW data, useful for investigating <a id="_idIndexMarker957"/>performance and memory issues in .NET applications.</p>
						</td>
						<td class="No-Table-Style">
							<p>Microsoft</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">.NET </strong><strong class="bold">Memory Profiler</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A powerful<a id="_idIndexMarker958"/> tool for finding memory leaks and <a id="_idIndexMarker959"/>optimizing memory usage in .NET applications.</p>
						</td>
						<td class="No-Table-Style">
							<p>SciTech Software</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">ANTS Performance </strong><strong class="bold">Profiler</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Provides .NET <a id="_idIndexMarker960"/>code profiling to find <a id="_idIndexMarker961"/>performance bottlenecks, including memory usage and execution time analysis.</p>
						</td>
						<td class="No-Table-Style">
							<p>Redgate</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">JetBrains </strong><strong class="bold">dotTrace</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A .NET<a id="_idIndexMarker962"/> profiler for performance, memory, and <a id="_idIndexMarker963"/>coverage analysis, integrated with Visual Studio.</p>
						</td>
						<td class="No-Table-Style">
							<p>JetBrains</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">VTune </strong><strong class="bold">Profiler</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Performance <a id="_idIndexMarker964"/>analysis tool for C, C++, and Fortran <a id="_idIndexMarker965"/>applications, offering deep insights into CPU and GPU performance.</p>
						</td>
						<td class="No-Table-Style">
							<p>Intel</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Valgrind</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Includes a <a id="_idIndexMarker966"/>suite of tools such as Cachegrind for cache<a id="_idIndexMarker967"/> profiling and Massif for heap profiling, primarily for C and C++ programs.</p>
						</td>
						<td class="No-Table-Style">
							<p>Valgrind Developers</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Google Performance </strong><strong class="bold">Tools (gperftools)</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A suite of <a id="_idIndexMarker968"/>utilities for performance <a id="_idIndexMarker969"/>profiling and heap analysis, providing insights into CPU and memory usage.</p>
						</td>
						<td class="No-Table-Style">
							<p>Google</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">YourKit </strong><strong class="bold">Profiler</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A profiler <a id="_idIndexMarker970"/>for Java and .NET applications, offering <a id="_idIndexMarker971"/>comprehensive CPU and memory profiling features.</p>
						</td>
						<td class="No-Table-Style">
							<p>YourKit</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Perf</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A <a id="_idIndexMarker972"/>performance analyzing tool in Linux that provides detailed <a id="_idIndexMarker973"/>information on CPU performance, helping identify bottlenecks.</p>
						</td>
						<td class="No-Table-Style">
							<p>Linux Community</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">GlowCode</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A <a id="_idIndexMarker974"/>performance and memory profiler for Windows, focusing<a id="_idIndexMarker975"/> on C++ and .NET applications.</p>
						</td>
						<td class="No-Table-Style">
							<p>Electric Software Inc.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">AQtime</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>An<a id="_idIndexMarker976"/> advanced performance and memory profiling tool for <a id="_idIndexMarker977"/>various programming languages, integrated with Visual Studio.</p>
						</td>
						<td class="No-Table-Style">
							<p>SmartBear</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Perfino</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>A <a id="_idIndexMarker978"/>Java profiler for production environments, focusing on <a id="_idIndexMarker979"/>performance monitoring and problem resolution.</p>
						</td>
						<td class="No-Table-Style">
							<p>EJ Technologies</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.8: Profiling tools</p>
			<p>These tables do not contain all the tools available. New tools are added regularly, while others go away. I suggest you try some of them and stick to what works best for you. Maybe you prefer a CLI solution. Perhaps you want to work with a graphical tool. Whatever your preference is, there is always a tool that fits your needs.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor259"/>Next steps</h1>
			<p>Writing code inevitably means making mistakes. That is part of the fun of the job, I believe. Coming up with new ideas, making something out of nothing, and then making it work and improve is a great process. However, you can only do that when you have the right tools and know how to use them.</p>
			<p>In this chapter, we have looked at the debugging tools that Visual Studio provides. We looked at what debugging and profiling actually are, discovered the possibilities with breakpoints, and looked at the other helpful debug windows.</p>
			<p>We also investigated how to deal with multithreaded applications and the debug challenges they give us. We looked at the windows that could help us and investigated deadlocks.</p>
			<p>To top it off, we talked about profiling and benchmarking to uncover performance bottlenecks and how to solve them.</p>
			<p>So, we now know how to tackle most of the issues in our code. However, we have one more important thing to discuss: how do we secure our code? What does that even mean? That is a big topic. It is so big that I have a complete chapter about it, and that is what is next. Please, follow along!</p>
		</div>
	</body></html>