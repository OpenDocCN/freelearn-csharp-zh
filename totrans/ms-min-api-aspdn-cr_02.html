<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer019">
<h1 class="chapter-number" id="_idParaDest-24"><a id="_idTextAnchor023"/>2</h1>
<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Exploring Minimal APIs and Their Advantages</h1>
<p>In this chapter of the book, we will introduce some of the basic themes related to minimal APIs in .NET 6.0, showing how they differ from the controller-based web APIs that we have written in the previous version of .NET. We will also try to underline both the pros and the cons of this new approach of writing APIs.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>Routing</li>
<li>Parameter binding</li>
<li>Exploring responses</li>
<li>Controlling serialization</li>
<li>Architecting a minimal API project</li>
</ul>
<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Technical requirements</h1>
<p>To follow the descriptions in this chapter, you will need to create an ASP.NET Core 6.0 Web API application. You can either use one of the following options:</p>
<ul>
<li><strong class="bold">Option 1</strong>: Click on the <strong class="bold">New</strong> | <strong class="bold">Project</strong> command in the <strong class="bold">File</strong> menu of Visual Studio 2022 – then, choose the <strong class="bold">ASP.NET Core Web API</strong> template. Select a name and the working directory in the wizard and be sure to uncheck the <strong class="bold">Use controllers (uncheck to use minimal APIs)</strong> option in the next step.</li>
<li><strong class="bold">Option 2</strong>: Open your console, shell, or Bash terminal, and change to your working directory. Use the following command to create a new Web API application:<p class="source-code"><strong class="bold">dotnet new webapi -minimal -o Chapter02</strong></p></li>
</ul>
<p>Now, open the project in Visual Studio by double-clicking the project file, or in Visual Studio Code, by typing the following command in the already open console:</p>
<p class="source-code"><strong class="bold">cd Chapter02</strong></p>
<p class="source-code"><strong class="bold">code.</strong></p>
<p>Finally, you can safely remove all the code related to the <strong class="source-inline">WeatherForecast</strong> sample, as we don’t need it for this chapter.</p>
<p>All the code samples in this chapter can be found in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter02">https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter02</a>.</p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Routing</h1>
<p>According<a id="_idIndexMarker021"/> to the official Microsoft documentation available at <a href="https://docs.microsoft.com/aspnet/core/fundamentals/routing">https://docs.microsoft.com/aspnet/core/fundamentals/routing</a>, the following definition is given for routing:</p>
<p class="author-quote">Routing is responsible for matching incoming HTTP requests and dispatching those requests to the app’s executable endpoints. Endpoints are the app’s units of executable request-handling code. Endpoints are defined in the app and configured when the app starts. The endpoint matching process can extract values from the request’s URL and provide those values for request processing. Using endpoint information from the app, routing is also able to generate URLs that map to endpoints.</p>
<p>In<a id="_idIndexMarker022"/> controller-based <a id="_idIndexMarker023"/>web APIs, routing is defined via the <strong class="source-inline">UseEndpoints()</strong> method in <strong class="source-inline">Startup.cs</strong> or using data annotations such as <strong class="source-inline">Route</strong>, <strong class="source-inline">HttpGet</strong>, <strong class="source-inline">HttpPost</strong>, <strong class="source-inline">HttpPut</strong>, <strong class="source-inline">HttpPatch</strong>, and <strong class="source-inline">HttpDelete</strong> right over the action methods.</p>
<p>As mentioned in <a href="B17902_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a><em class="italic">, Introduction to Minimal APIs</em> in minimal APIs, we define the<a id="_idIndexMarker024"/> route patterns using the <strong class="source-inline">Map*</strong> methods of the <strong class="source-inline">WebApplication</strong> object. Here’s an example:</p>
<pre class="source-code">
app.MapGet("/hello-get", () =&gt; "[GET] Hello World!");
app.MapPost("/hello-post", () =&gt; "[POST] Hello World!");
app.MapPut("/hello-put", () =&gt; "[PUT] Hello World!");
app.MapDelete("/hello-delete", () =&gt; "[DELETE] Hello
                World!");</pre>
<p>In this code, we have defined four <a id="_idIndexMarker025"/>endpoints, each with a different routing and method. Of course, we can use the same route pattern with different HTTP verbs.</p>
<p class="callout-heading">Note</p>
<p class="callout">As soon as we add an endpoint to our application (for example, using <strong class="source-inline">MapGet()</strong>), <strong class="source-inline">UseRouting()</strong> is automatically added at the start of the middleware pipeline and <strong class="source-inline">UseEndpoints()</strong> at the end of the pipeline.</p>
<p>As shown here, ASP.NET Core 6.0 provides <strong class="source-inline">Map*</strong> methods for the most common HTTP verbs. If we need to use other verbs, we can use the generic <strong class="source-inline">MapMethods</strong>:</p>
<pre class="source-code">
app.MapMethods("/hello-patch", new[] { HttpMethods.Patch }, 
    () =&gt; "[PATCH] Hello World!");
app.MapMethods("/hello-head", new[] { HttpMethods.Head }, 
    () =&gt; "[HEAD] Hello World!");
app.MapMethods("/hello-options", new[] { 
    HttpMethods.Options }, () =&gt; "[OPTIONS] Hello World!");</pre>
<p>In the following sections, we will show in detail how routing works effectively and how we can control its behavior.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Route handlers</h2>
<p>Methods that execute when a<a id="_idIndexMarker026"/> route URL matches (according to parameters and constraints, as described in the following sections) are called <strong class="bold">route handlers</strong>. Route handlers can be a lambda expression, a local function, an instance method, or a static method, whether synchronous or asynchronous:</p>
<ul>
<li>Here’s an example of a lambda expression (inline or using a variable):<p class="source-code">app.MapGet("/hello-inline", () =&gt; "[INLINE LAMBDA] </p><p class="source-code">             Hello World!");</p><p class="source-code">var handler = () =&gt; "[LAMBDA VARIABLE] Hello World!";</p><p class="source-code">app.MapGet("/hello", handler);</p></li>
<li>Here’s an example of a local function:<p class="source-code">string Hello() =&gt; "[LOCAL FUNCTION] Hello World!";</p><p class="source-code">app.MapGet("/hello", Hello);</p></li>
<li>The following is an example of an instance method:<p class="source-code">var handler = new HelloHandler();</p><p class="source-code">app.MapGet("/hello", handler.Hello);</p><p class="source-code">class HelloHandler</p><p class="source-code">{</p><p class="source-code">    public string Hello()</p><p class="source-code">      =&gt; "[INSTANCE METHOD] Hello </p><p class="source-code">           World!";</p><p class="source-code">}</p></li>
<li>Here, we can see an example of a static method:<p class="source-code">app.MapGet("/hello", HelloHandler.Hello);</p><p class="source-code">class HelloHandler</p><p class="source-code">{</p><p class="source-code">    public static string Hello()</p><p class="source-code">      =&gt; "[STATIC METHOD] Hello World!";</p><p class="source-code">}</p></li>
</ul>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Route parameters</h2>
<p>As with the previous versions of .NET, we can create<a id="_idIndexMarker027"/> route patterns with parameters that will be automatically captured by the handler:</p>
<pre class="source-code">
app.MapGet("/users/{username}/products/{productId}", 
          (string username, int productId) 
         =&gt; $"The Username is {username} and the product Id 
              is {productId}");</pre>
<p>A route can contain an arbitrary number of parameters. When a request is made to this route, the parameters will be captured, parsed, and passed as arguments to the corresponding handler. In this way, the handler will always receive typed arguments (in the preceding sample, we are sure that the username is <strong class="source-inline">string</strong> and the product ID is <strong class="source-inline">int</strong>).</p>
<p>If the route values cannot be casted to the specified types, then an exception of the <strong class="source-inline">BadHttpRequestException</strong> type will be thrown, and the API will respond with a <strong class="source-inline">400 Bad Request</strong> message.</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Route constraints</h2>
<p>Route constraints are used to<a id="_idIndexMarker028"/> restrict valid types for route parameters. Typical constraints allow us to specify that a parameter must be a number, a string, or a GUID. To specify a route constraint, we simply need to add a colon after the parameter name, then specify the constraint name:</p>
<pre class="source-code">
app.MapGet("/users/{id:int}", (int id) =&gt; $"The user Id is 
                                            {id}");
app.MapGet("/users/{id:guid}", (Guid id) =&gt; $"The user Guid 
                                              is {id}");</pre>
<p>Minimal APIs support all <a id="_idIndexMarker029"/>the route constraints that were already available in the previous versions of ASP.NET Core. You can find the full list of route constraints at the following link: <a href="https://docs.microsoft.com/aspnet/core/fundamentals/routing#route-constraint-reference">https://docs.microsoft.com/aspnet/core/fundamentals/routing#route-constraint-reference</a>.</p>
<p>If, according to the constraints, no route matches the specified path, we don’t get an exception. Instead we obtain a <strong class="source-inline">404 Not Found</strong> message, because, in fact, if the constraints do not fit, the route itself isn’t reachable. So, for example, in the following cases we get 404 responses:</p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<img alt="Table 2.1 – Examples of an invalid path according to the route constraints " height="190" src="image/Table_2.01_B17902.jpg" width="708"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.1 – Examples of an invalid path according to the route constraints</p>
<p>Every other argument in the handler that is not declared as a route constraint is expected, by default, in the query string. For example, see the following:</p>
<pre class="source-code">
// Matches hello?name=Marco
app.MapGet("/hello", (string name) =&gt; $"Hello, {name}!"); </pre>
<p>In the next section, <em class="italic">Parameter binding</em>, we’ll go deeper into how to use binding to further customize routing by specifying, for example, where to search for routing arguments, how to change their names, and how to have optional route parameters.</p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Parameter binding</h1>
<p><strong class="bold">Parameter binding</strong> is the <a id="_idIndexMarker030"/>process that converts request data (i.e., URL paths, query strings, or the body) into strongly typed parameters that can be consumed by route handlers. ASP.NET Core minimal APIs support the following binding sources:</p>
<ul>
<li>Route values</li>
<li>Query strings</li>
<li>Headers</li>
<li>The body (as JSON, the only format supported by default)</li>
<li>A service provider (dependency injection)</li>
</ul>
<p>We’ll talk in detail about dependency injection in <a href="B17902_04.xhtml#_idTextAnchor061"><em class="italic">Chapter 4</em></a>, <em class="italic">Implementing Dependency Injection</em>.</p>
<p>As we’ll see later in this chapter, if necessary, we can customize the way in which binding is performed for a particular input. Unfortunately, in the current version, binding from <strong class="source-inline">Form</strong> is not natively supported in minimal APIs. This means that, for example, <strong class="source-inline">IFormFile</strong> is not supported either.</p>
<p>To better understand how <a id="_idIndexMarker031"/>parameter binding works, let’s take a look at the following API:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddScoped&lt;PeopleService&gt;();
var app = builder.Build();
app.MapPut("/people/{id:int}", (int id, bool notify, Person 
             person, PeopleService peopleService) =&gt; { });
app.Run();
public class PeopleService { }
public record class Person(string FirstName, string 
                           LastName);</pre>
<p>Parameters that are <a id="_idIndexMarker032"/>passed to the <a id="_idIndexMarker033"/>handler are resolved in the following ways:</p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<img alt="Table 2.2 – Parameter binding sources " height="326" src="image/Table_2.02_B17902.jpg" width="1104"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.2 – Parameter binding sources</p>
<p>As we can see, ASP.NET Core is able to automatically understand where to search for parameters for binding, based on the route pattern and the types of the parameters themselves. For example, a complex type such as the <strong class="source-inline">Person</strong> class is expected in the request body.</p>
<p>If needed, as in the previous versions of ASP.NET Core, we can use attributes to explicitly specify where parameters are bound from and, optionally, use different names for them. See the following endpoint:</p>
<pre class="source-code">
app.MapGet("/search", string q) =&gt; { });</pre>
<p>The API can be invoked with <strong class="source-inline">/search?q=text</strong>. However, using <strong class="source-inline">q</strong> as the name of the argument isn’t a good idea, because its meaning is not self-explanatory. So, we can modify the handler using <strong class="source-inline">FromQueryAttribute</strong>:</p>
<pre class="source-code">
app.MapGet("/search", ([FromQuery(Name = "q")] string 
             searchText) =&gt; { });</pre>
<p>In this way, the <a id="_idIndexMarker034"/>API still expects a query string parameter named <strong class="source-inline">q</strong>, but in the handler its value is now bound to the <strong class="source-inline">searchText</strong> argument.</p>
<p class="callout-heading">Note</p>
<p class="callout">According to the standard, the <strong class="source-inline">GET</strong>, <strong class="source-inline">DELETE</strong>, <strong class="source-inline">HEAD</strong>, and <strong class="source-inline">OPTIONS</strong> HTTP options should never have a body. If, nevertheless, you want to use it, you need to explicitly add the <strong class="source-inline">[FromBody]</strong> attribute to the handler argument; otherwise, you’ll get an <strong class="source-inline">InvalidOperationException</strong> error. However, keep in mind that this is a bad practice.</p>
<p>By default, all the parameters in route handlers are required. So, if, according to routing, ASP.NET Core finds a valid route, but not all the required parameters are provided, we will get an error. For example, let’s look at the following method:</p>
<pre class="source-code">
app.MapGet("/people", (int pageIndex, int itemsPerPage) =&gt; { });</pre>
<p>If we call the endpoint without the <strong class="source-inline">pageIndex</strong> or <strong class="source-inline">itemsPerPage</strong> query string values, we will obtain a <strong class="source-inline">BadHttpRequestException</strong> error, and the response will be <strong class="source-inline">400 Bad Request</strong>. </p>
<p>To make the parameters optional, we just need to declare them as nullable or provide a default value. The latter case is the most common. However, if we adopt this solution, we cannot use a lambda expression for the handler. We need another approach, for example, a local function:</p>
<pre class="source-code">
// This won't compile
//app.MapGet("/people", (int pageIndex = 0, int 
                         itemsPerPage = 50) =&gt; { });
string SearchMethod(int pageIndex = 0, 
                    int itemsPerPage = 50) =&gt; $"Sample 
                    result for page {pageIndex} getting 
                    {itemsPerPage} elements";
app.MapGet("/people", SearchMethod);</pre>
<p>In this case, we <a id="_idIndexMarker035"/>are dealing with a query string, but the same rules apply to all the binding sources.</p>
<p>Keep in mind that if we <a id="_idIndexMarker036"/>use <strong class="bold">nullable reference types</strong> (which are enabled by default in .NET 6.0 projects) and we have, for example, a string parameter that could be <strong class="source-inline">null</strong>, we need to declare it as <strong class="bold">nullable</strong> – otherwise, we’ll get a <strong class="source-inline">BadHttpRequestException</strong> error again. The following example correctly defines the <strong class="source-inline">orderBy</strong> query string parameter as optional:</p>
<pre class="source-code">
app.MapGet("/people", (string? orderBy) =&gt; $"Results ordered by {orderBy}");</pre>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Special bindings</h2>
<p>In controller-based web APIs, a controller<a id="_idIndexMarker037"/> that inherits from <strong class="source-inline">Microsoft.AspNetCore.Mvc.ControllerBase</strong> has access to some properties that allows it to get the context of the request and response: <strong class="source-inline">HttpContext</strong>, <strong class="source-inline">Request</strong>, <strong class="source-inline">Response</strong>, and <strong class="source-inline">User</strong>. In minimal APIs, we don’t have a base class, but we can still access this information because it is treated as a special binding that is always available to any handler:</p>
<pre class="source-code">
app.MapGet("/products", (HttpContext context, HttpRequest req, HttpResponse res, ClaimsPrincipal user) =&gt; { });</pre>
<p class="callout-heading">Tip</p>
<p class="callout">We can also access all these objects using the <strong class="source-inline">IHttpContextAccessor</strong> interface, as we did in the previous ASP.NET Core versions.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Custom binding</h2>
<p>In some cases, the default way in which <a id="_idIndexMarker038"/>parameter binding works isn’t enough for our purpose. In minimal APIs, we don’t have support for the <strong class="source-inline">IModelBinderProvider</strong> and <strong class="source-inline">IModelBinder</strong> interfaces, but we have two alternatives to implement custom model binding.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The <strong class="source-inline">IModelBinderProvider</strong> and <strong class="source-inline">IModelBinder</strong> interfaces in controller-based projects allow us to define the mapping between the request data and the application model. The default model binder provided by ASP.NET Core supports most of the common data types, but, if necessary, we can extend the system by creating our own providers. We can find more <a id="_idIndexMarker039"/>information at the following link: <a href="https://docs.microsoft.com/aspnet/core/mvc/advanced/custom-model-binding">https://docs.microsoft.com/aspnet/core/mvc/advanced/custom-model-binding</a>.</p>
<p>If we want to bind a <a id="_idIndexMarker040"/>parameter that comes from a route, query string, or header to a custom type, we can add a static <strong class="source-inline">TryParse</strong> method to the type:</p>
<pre class="source-code">
// GET /navigate?location=43.8427,7.8527
app.MapGet("/navigate", (Location location) =&gt; $"Location: 
            {location.Latitude}, {location.Longitude}");
public class Location
{
    public double Latitude { get; set; }
    public double Longitude { get; set; }
    public static bool TryParse(string? value, 
      IFormatProvider? provider, out Location? location)
    {
          if (!string.IsNullOrWhiteSpace(value))
          {
               var values = value.Split(',', 
               StringSplitOptions.RemoveEmptyEntries);
               if (values.Length == 2 &amp;&amp; double.
                   TryParse(values[0],
                   NumberStyles.AllowDecimalPoint, 
                   CultureInfo.InvariantCulture, 
                   out var latitude) &amp;&amp; double.
                   TryParse(values[1], NumberStyles.
                   AllowDecimalPoint, CultureInfo.
                   InvariantCulture, out var longitude))
               {
                       location = new Location 
                       { Latitude = latitude, 
                       Longitude = longitude };
                       return true;
               }
          }
          location = null;
          return false;
    }
}</pre>
<p>In the <strong class="source-inline">TryParse</strong> method, we can try<a id="_idIndexMarker041"/> to split the input parameter and check whether it contains two decimal values: in this case, we parse the numbers to build the <strong class="source-inline">Location</strong> object and we return <strong class="source-inline">true</strong>. Otherwise, we return <strong class="source-inline">false</strong> because the <strong class="source-inline">Location</strong> object cannot be initialized.</p>
<p class="callout-heading">Important note</p>
<p class="callout">When the minimal API finds that a type contains a static <strong class="source-inline">TryParse</strong> method, even if it is a complex type, it assumes that it is passed in the route or the query string, based on the routing template. We can use the <strong class="source-inline">[FromHeader]</strong> attributes to change the binding source. In any case, <strong class="source-inline">TryParse</strong> will never be invoked for the body of the request.</p>
<p>If we need to completely control<a id="_idIndexMarker042"/> how binding is performed, we can implement a static <strong class="source-inline">BindAsync</strong> method on the type. This isn’t a very common solution, but in some cases, it can be useful:</p>
<pre class="source-code">
// POST /navigate?lat=43.8427&amp;lon=7.8527
app.MapPost("/navigate", (Location location) =&gt; 
   $"Location: {location.Latitude}, {location.Longitude}");
public class Location
{
    // ...
    public static ValueTask&lt;Location?&gt; BindAsync(HttpContext 
    context, ParameterInfo parameter)
    {
        if (double.TryParse(context.Request.Query["lat"], 
            NumberStyles.AllowDecimalPoint, CultureInfo.
            InvariantCulture, out var latitude)&amp;&amp; double.
            TryParse(context.Request.Query["lon"], 
            NumberStyles.AllowDecimalPoint, CultureInfo.
            InvariantCulture, out var longitude))
        {
                var location = new Location 
                { Latitude = latitude, Longitude = longitude };
                return ValueTask.
                  FromResult&lt;Location?&gt;(location);
        }
        return ValueTask.FromResult&lt;Location?&gt;(null);
    }
}</pre>
<p>As we can see, the <strong class="source-inline">BindAsync</strong> method takes the whole <strong class="source-inline">HttpContext</strong> as an argument, so we can read all the information we need to create the actual <strong class="source-inline">Location</strong> object that is passed to the route <a id="_idIndexMarker043"/>handler. In this example, we read two query string parameters (<strong class="source-inline">lat</strong> and <strong class="source-inline">lon</strong>), but (in the case of <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, or <strong class="source-inline">PATCH</strong> methods) we can also read the entire body of the request and manually parse its content. This can be useful, for instance, if we need to handle requests that have a format other than JSON (which, as said before, is the only one supported by default).</p>
<p>If the <strong class="source-inline">BindAsync</strong> method returns <strong class="source-inline">null</strong>, while the corresponding route handler parameter cannot assume this value (as in the previous example), we will get an <strong class="source-inline">HttpBadRequestException</strong> error, which. as usual, will be wrapped in a <strong class="source-inline">400 Bad Request</strong> response.</p>
<p class="callout-heading">Important note</p>
<p class="callout">We shouldn’t define both the <strong class="source-inline">TryParse</strong> and <strong class="source-inline">BindAsync</strong> methods using a type; if both are present, <strong class="source-inline">BindAsync</strong> always has precedence (that is, <strong class="source-inline">TryParse</strong> will never be invoked).</p>
<p>Now that we have looked at parameter binding and understood how to use it and customize its behavior, let’s see how to work with responses in minimal APIs.</p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Exploring responses</h1>
<p>As <a id="_idIndexMarker044"/>with controller-based projects, with route handlers of minimal APIs as well, we can directly return a string or a class (either synchronously or asynchronously):</p>
<ul>
<li>If we return a string (as in the examples of the previous section), the framework writes the string directly to the response, setting its content type to <strong class="source-inline">text/plain</strong> and the status code to <strong class="source-inline">200 OK</strong></li>
<li>If we use a class, the object is serialized into the JSON format and sent to the response with the <strong class="source-inline">application/json</strong> content type and a <strong class="source-inline">200 OK</strong> status code</li>
</ul>
<p>However, in a real application, we typically need to control the response type and the status code. In this case, we can use the static <strong class="source-inline">Results</strong> class, which allows us to return an instance of the <strong class="source-inline">IResult</strong> interface, which in minimal APIs acts how <strong class="source-inline">IActionResult</strong> does for controllers. For instance, we can use it to return a <strong class="source-inline">201 Created</strong> response rather than a <strong class="source-inline">400 Bad Request</strong> or a<strong class="bold"> </strong><strong class="source-inline">404 Not Found</strong> message. L et’s look at some<a id="_idIndexMarker045"/> examples:</p>
<pre class="source-code">
app.MapGet("/ok", () =&gt; Results.Ok(new Person("Donald", 
                                              "Duck")));
app.MapGet("/notfound", () =&gt; Results.NotFound());
app.MapPost("/badrequest", () =&gt;
{
    // Creates a 400 response with a JSON body.
    return Results.BadRequest(new { ErrorMessage = "Unable to
                                    complete the request" });
});
app.MapGet("/download", (string fileName) =&gt; 
             Results.File(fileName));
record class Person(string FirstName, string LastName);</pre>
<p>Each method of the <strong class="source-inline">Results</strong> class is responsible for setting the response type and status code that correspond to the meaning of the method itself (e.g., the <strong class="source-inline">Results.NotFound()</strong> method returns a <strong class="source-inline">404 Not Found</strong> response). Note that even if we typically need to return an object in the case of a <strong class="source-inline">200 OK</strong> response (with <strong class="source-inline">Results.Ok()</strong>), it isn’t the only method that allows this. Many other methods allow us to include a custom response; in all these cases, the response type will be set to <strong class="source-inline">application/json</strong> and the object will automatically be JSON-serialized.</p>
<p>The current version of minimal APIs does not support content negotiation. We only have a few methods that allow us to explicitly set the content type, when getting a file with <strong class="source-inline">Results.Bytes()</strong>, <strong class="source-inline">Results.Stream()</strong>, and <strong class="source-inline">Results.File()</strong>, or when using <strong class="source-inline">Results.Text()</strong> and <strong class="source-inline">Results.Content()</strong>. In all other cases, when we’re dealing with complex objects, the response will be in JSON format. This is a precise design choice since most developers rarely need to support other media types. By supporting only JSON without performing content negotiation, minimal APIs can be very efficient.</p>
<p>However, this <a id="_idIndexMarker046"/>approach isn’t enough in all scenarios. In some cases, we may need to create a custom response type, for example, if we want to return an HTML or XML response instead of the standard JSON. We can manually use the <strong class="source-inline">Results.Content()</strong> method (which allows us to specify the content as a simple string with a particular content type), but, if we have this requirement, it is better to implement a custom <strong class="source-inline">IResult</strong> type, so that the solution can be reused.</p>
<p>For example, let’s suppose that we want to serialize objects in XML instead of JSON. We can then define an <strong class="source-inline">XmlResult</strong> class that implements the <strong class="source-inline">IResult</strong> interface: </p>
<pre class="source-code">
public class XmlResult : IResult
{
   private readonly object value;
   public XmlResult(object value)
   {
       this.value = value;
   }
   public Task ExecuteAsync(HttpContext httpContext)
   {
       using var writer = new StringWriter();
          
       var serializer = new XmlSerializer(value.GetType());
       serializer.Serialize(writer, value);
       var xml = writer.ToString();
       httpContext.Response.ContentType = MediaTypeNames.
       Application.Xml;
       httpContext.Response.ContentLength = Encoding.UTF8
      .GetByteCount(xml);
       return httpContext.Response.WriteAsync(xml);
   }
}</pre>
<p>The <strong class="source-inline">IResult</strong> interface <a id="_idIndexMarker047"/>requires us to implement the <strong class="source-inline">ExecuteAsync</strong> method, which receives the current <strong class="source-inline">HttpContext</strong> as an argument. We serialize the value using the <strong class="source-inline">XmlSerializer</strong> class and then write it to the response, specifying the correct response type.</p>
<p>Now, we can directly use the new <strong class="source-inline">XmlResult</strong> type in our route handlers. However, best practices suggest that we create an extension method for the <strong class="source-inline">IResultExtensions</strong> interface, as with the following one:</p>
<pre class="source-code">
public static class ResultExtensions
{
    public static IResult Xml(this IResultExtensions 
    resultExtensions, object value) =&gt; new XmlResult(value);
}</pre>
<p>In this way, we have a new <strong class="source-inline">Xml</strong> method available on the <strong class="source-inline">Results.Extensions</strong> property:</p>
<pre class="source-code">
app.MapGet("/xml", () =&gt; Results.Extensions.Xml(new City { Name = "Taggia" }));
public record class City
{
    public string? Name { get; init; }
}</pre>
<p>The benefit of<a id="_idIndexMarker048"/> this approach is that we can reuse it everywhere we need to deal with XML without having to manually handle the serialization and the response type (as we should have done using the <strong class="source-inline">Result.Content()</strong> method instead).</p>
<p class="callout-heading">Tip</p>
<p class="callout">If we want to perform content validation, we need to manually check the <strong class="source-inline">Accept</strong> header of the <strong class="source-inline">HttpRequest</strong> object, which we can pass to our handlers, and then create the correct response accordingly.</p>
<p>After analyzing how to properly handle responses in minimal APIs, we’ll see how to control the way our data is serialized and deserialized in the next section.</p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Controlling serialization</h1>
<p>As described in the previous<a id="_idIndexMarker049"/> sections, minimal APIs only provide built-in support for the JSON format. In particular, the framework uses <strong class="source-inline">System.Text.Json</strong> for serialization and deserialization. In controller-based APIs, we can change this default and use JSON.NET instead. This is not possible when working with minimal APIs: we can’t replace the serializer at all.</p>
<p>The built-in serializer uses the following options:</p>
<ul>
<li>Case-insensitive property names during serialization</li>
<li>Camel case property naming policy</li>
<li>Support for quoted numbers (JSON strings for number properties)</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">We can find more information about the <strong class="source-inline">System.Text.Json</strong> namespace<a id="_idIndexMarker050"/> and all the APIs it provides at the following link: <a href="https://docs.microsoft.com/dotnet/api/system.text.json">https://docs.microsoft.com/dotnet/api/system.text.json</a>.</p>
<p>In controller-based APIs, we<a id="_idIndexMarker051"/> can customize these settings by calling <strong class="source-inline">AddJsonOptions()</strong> fluently after <strong class="source-inline">AddControllers()</strong>. In minimal APIs, we can’t use this approach since we don’t have controllers at all, so we need to explicitly call the <strong class="source-inline">Configure</strong> method for <strong class="source-inline">JsonOptions</strong>. So, let’s consider this handler:</p>
<pre class="source-code">
app.MapGet("/product", () =&gt;
{
    var product = new Product("Apple", null, 0.42, 6);
    return Results.Ok(product); 
});
public record class Product(string Name, string? Description, double UnitPrice, int Quantity)
{
    public double TotalPrice =&gt; UnitPrice * Quantity;
}</pre>
<p>Using the default JSON options, we get this result:</p>
<pre class="source-code">
{
    "name": "Apple",
    "description": null,
    "unitPrice": 0.42,
    "quantity": 6,
    "totalPrice": 2.52
}</pre>
<p>Now, let’s configure <strong class="source-inline">JsonOptions</strong>:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.Configure&lt;Microsoft.AspNetCore.Http.Json.
JsonOptions&gt;(options =&gt;
{
    options.SerializerOptions.DefaultIgnoreCondition = 
    JsonIgnoreCondition.WhenWritingNull;
    options.SerializerOptions.IgnoreReadOnlyProperties 
    = true;
});</pre>
<p>Calling the <strong class="source-inline">/product</strong> endpoint <a id="_idIndexMarker052"/>again, we’ll now get the following:</p>
<pre class="source-code">
{
    "name": "Apple",
    "unitPrice": 0.42,
    "quantity": 6
}</pre>
<p>As expected, the <strong class="source-inline">Description</strong> property hasn’t been serialized because it is <strong class="source-inline">null</strong>, as well as <strong class="source-inline">TotalPrice</strong>, which isn’t included in the response because it is read-only.</p>
<p>Another typical use case for <strong class="source-inline">JsonOptions</strong> is when we want to add converters that will be automatically applied for each serialization or deserialization, for example, <strong class="source-inline">JsonStrinEnumConverter</strong> to convert enumeration values into or from strings.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Be aware that the <strong class="source-inline">JsonOptions</strong> class used by minimal APIs is the one available in the <strong class="source-inline">Microsoft.AspNetCore.Http.Json</strong> namespace. Do not confuse it with the one that is defined in the <strong class="source-inline">Microsoft.AspNetCore.Mvc</strong> namespace; the name of the object is the same, but the latter is valid only for controllers, so it has no effect if set in a minimal API project.</p>
<p>Because of the<a id="_idIndexMarker053"/> JSON-only support, if we do not explicitly add support for other formats, as described in the previous sections (using, for example, the <strong class="source-inline">BindAsync</strong> method on a custom type), minimal APIs will automatically perform some validations on the body binding source and handle the following scenarios:</p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<img alt="Table 2.3 – The response status codes for body binding problems " height="200" src="image/Table_2.03_B17902.jpg" width="1422"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.3 – The response status codes for body binding problems</p>
<p>In these cases, because body validation fails, our route handlers will never be invoked, and we will get the response status codes shown in the preceding table directly.</p>
<p>Now, we have covered all the pillars that we need to start developing minimal APIs. However, there is another important thing to talk about: the correct way to design a real project to avoid common mistakes within the architecture.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Architecting a minimal API project</h1>
<p>Up to now, we<a id="_idIndexMarker054"/> have written route handlers directly in the <strong class="source-inline">Program.cs</strong> file. This is a perfectly supported scenario: with minimal APIs, we can write all our code inside this single file. In fact, almost all the samples show this solution. However, while this is allowed, we can easily imagine how this approach can lead to unstructured and therefore unmaintainable projects. If we have fewer endpoints, it is fine – otherwise, it is better to organize our handlers in separate files.</p>
<p>Let’s suppose that we have the following code right in the <strong class="source-inline">Program.cs</strong> file because we have to handle CRUD operations:</p>
<pre class="source-code">
app.MapGet("/api/people", (PeopleService peopleService) =&gt; 
            { });
app.MapGet("/api/people/{id:guid}", (Guid id, PeopleService 
             peopleService) =&gt; { });
app.MapPost("/api/people", (Person Person, PeopleService 
              people) =&gt; { });
app.MapPut("/api/people/{id:guid}", (Guid id, Person 
             Person, PeopleService people) =&gt; { });
app.MapDelete("/api/people/{id:guid}", (Guid id, 
                PeopleService people) =&gt; { });</pre>
<p>It’s easy to imagine that, if <a id="_idIndexMarker055"/>we have all the implementation here (even if we’re using <strong class="source-inline">PeopleService</strong> to extract the business logic), this file can easily explode. So, in real scenarios, the inline lambda approach isn’t the best practice. We should use the other methods that we have covered in the <em class="italic">Routing</em> section to define the handlers instead. So, it is a good idea to create an external class to hold all the<a id="_idIndexMarker056"/> route handlers:</p>
<pre class="source-code">
public class PeopleHandler
{
   public static void MapEndpoints(IEndpointRouteBuilder 
   app)
   {
       app.MapGet("/api/people", GetList);
       app.MapGet("/api/people/{id:guid}", Get);
       app.MapPost("/api/people", Insert);
       app.MapPut("/api/people/{id:guid}", Update);
       app.MapDelete("/api/people/{id:guid}", Delete);
   }
         
   private static IResult GetList(PeopleService    
   peopleService) { /* ... */ }
   private static IResult Get(Guid id, PeopleService 
   peopleService) { /* ... */ }
   private static IResult Insert(Person person, 
   PeopleService people) { /* ... */ }
   private static IResult Update(Guid id, Person 
   person, PeopleService people) { /* ... */ }
   private static IResult Delete(Guid id) { /* ... */ }
}</pre>
<p>We have grouped all the endpoint definitions inside the <strong class="source-inline">PeopleHandler.MapEndpoints</strong> static method, which takes the <strong class="source-inline">IEndpointRouteBuilder</strong> interface as an argument, which in turn is implemented by the <strong class="source-inline">WebApplication</strong> class. Then, instead of using lambda expressions, we have created separate methods for each handler, so that the code is much cleaner. In this way, to register all these <a id="_idIndexMarker057"/>handlers in our minimal API, we just need the following code in <strong class="source-inline">Program.cs</strong>:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
// ..
var app = builder.Build();
// ..
PeopleHandler.MapEndpoints(app);
app.Run();</pre>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Going forward</h2>
<p>The approach just shown allows us to better organize a minimal API project, but still requires that we explicitly add a line to <strong class="source-inline">Program.cs</strong> for every handler we want to define. Using an interface and <a id="_idIndexMarker058"/>a bit of <strong class="bold">reflection</strong>, we can create a straightforward and reusable solution to simplify our work with minimal APIs.</p>
<p>So, let’s start by defining the following interface:</p>
<pre class="source-code">
public interface IEndpointRouteHandler
{
   public void MapEndpoints(IEndpointRouteBuilder app);
}</pre>
<p>As the name implies, we need to make all our handlers (as with <strong class="source-inline">PeopleHandler</strong> previously) implement it:</p>
<pre class="source-code">
public class PeopleHandler : IEndpointRouteHandler
{
       public void MapEndpoints(IEndpointRouteBuilder app)
         {
                // ...
         }
         // ...
}</pre>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline">MapEndpoints</strong> method isn’t static anymore, because now it is the implementation of the <strong class="source-inline">IEndpointRouteHandler</strong> interface.</p>
<p>Now we need a new extension method that, using<a id="_idIndexMarker059"/> reflection, scans an assembly for all the classes that implement this interface and automatically calls their <strong class="source-inline">MapEndpoints</strong> methods:</p>
<pre class="source-code">
public static class IEndpointRouteBuilderExtensions
{
    public static void MapEndpoints(this
    IEndpointRouteBuilder app, Assembly assembly)
    {
        var endpointRouteHandlerInterfaceType = 
          typeof(IEndpointRouteHandler);
        var endpointRouteHandlerTypes = 
        assembly.GetTypes().Where(t =&gt;
        t.IsClass &amp;&amp; !t.IsAbstract &amp;&amp; !t.IsGenericType
        &amp;&amp; t.GetConstructor(Type.EmptyTypes) != null
        &amp;&amp; endpointRouteHandlerInterfaceType
        .IsAssignableFrom(t));
        foreach (var endpointRouteHandlerType in 
        endpointRouteHandlerTypes)
        {
            var instantiatedType = (IEndpointRouteHandler)
              Activator.CreateInstance
                (endpointRouteHandlerType)!;
            instantiatedType.MapEndpoints(app);
        }
    }
}</pre>
<p class="callout-heading">Tip</p>
<p class="callout">If you want to go into further detail about<a id="_idIndexMarker060"/> reflection and how it works in .NET, you can start by browsing the following page: <a href="https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/reflection">https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/reflection</a>.</p>
<p>With all these pieces in place, the last thing to do is to call the extension method in the <strong class="source-inline">Program.cs</strong> file, before the <strong class="source-inline">Run()</strong> method:</p>
<pre class="source-code">
app.MapEndpoints(Assembly.GetExecutingAssembly());
app.Run();</pre>
<p>In this way, when we add new handlers, we should only need to create a new class that implements the <strong class="source-inline">IEndpointRouteHandler</strong> interface. No other changes will be required in <strong class="source-inline">Program.cs</strong> to add the new endpoints to the routing engine.</p>
<p>Writing route handlers in external files and thinking about a way to automate endpoint registrations so that <strong class="source-inline">Program.cs</strong> won’t grow for each feature addition is the right way to architect a minimal API project.</p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Summary</h1>
<p>ASP.NET Core minimal APIs represent a new way of writing HTTP APIs in the .NET world. In this chapter, we covered all the pillars that we need to start developing minimal APIs, how to effectively approach them, and the best practices to take into consideration when deciding to follow this architecture.</p>
<p>In the next chapter, we’ll focus on some advanced concepts such as documenting APIs with Swagger, defining a correct error handling system, and integrating a minimal API with a single-page application.</p>
</div>
</div></body></html>