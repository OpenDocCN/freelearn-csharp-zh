<html><head></head><body>
<div id="_idContainer061">
<h1 class="chapter-number" id="_idParaDest-219"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-220"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.2.1">Push Your Application with Performance</span></h1>
<p><span class="koboSpan" id="kobo.3.1">With each new release</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.4.1"> of </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">ASP.NET</span></strong><span class="koboSpan" id="kobo.6.1">, the ASP.NET team continues to make performance a priority. </span><span class="koboSpan" id="kobo.6.2">When ASP.NET Core introduced a different way of building web applications with streamlined enhancements (including </span><strong class="bold"><span class="koboSpan" id="kobo.7.1">middleware</span></strong><span class="koboSpan" id="kobo.8.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">Razor Pages</span></strong><span class="koboSpan" id="kobo.10.1">) the focus was continually on improving the C# language as well. </span><span class="koboSpan" id="kobo.10.2">These technologies are what give ASP.NET its spark </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">and speed.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">ASP.NET is cross-platform, has built-in support for dependency injection, is open source, and is one of the fastest-performing frameworks in </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">the industry.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">While this is an ASP.NET book with a chapter on performance, there will be additional aspects of web development that are equally as important. </span><span class="koboSpan" id="kobo.14.2">We’ll stay focused on ASP.NET and C# performance as much </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.18.1">Why </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Performance Matters</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Establishing Baselines</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Applying Performance </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Best Practices</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.23.1">By the end of this chapter, you’ll understand the importance of performance in your application, how to establish client-side and server-side baselines and techniques on how to optimize the client-side resources for faster delivery, and finally, how to deliver content faster with server-side performance techniques such as optimizing HTML, implementing various caching techniques, and identifying </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">slow queries.</span></span></p>
<h1 id="_idParaDest-221"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">When creating baselines and testing performance for your web application, there is a need for an IDE or editor you feel comfortable with for writing code. </span><span class="koboSpan" id="kobo.26.2">We recommend using your favorite editor to view the GitHub repository. </span><span class="koboSpan" id="kobo.26.3">Our recommendations include </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.28.1">Visual Studio</span></strong><span class="koboSpan" id="kobo.29.1"> (preferably the </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">latest version)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.31.1">Visual </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.32.1">Studio Code</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.33.1">JetBrains Rider</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">The code for this chapter is located in Packt Publishing’s GitHub repository, located </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">at </span></span><a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.38.1">Why Performance Matters</span></h1>
<p><span class="koboSpan" id="kobo.39.1">Performance </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.40.1">takes many shapes and forms in web development since there are so many moving pieces to make a website always ready and available to our users. </span><span class="koboSpan" id="kobo.40.2">As a developer, if someone asked for help regarding a website being slow, what advice would you recommend? </span><span class="koboSpan" id="kobo.40.3">It’s a tough question to answer verbally without examining the website. </span><span class="koboSpan" id="kobo.40.4">With websites, there may be times when performance isn’t just one technology; the problem may be more than </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">one bottleneck.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">For instance, when loading a web page in the browser, do you see content appear, but images take a long time and paint row by row? </span><span class="koboSpan" id="kobo.42.2">How about accessing the database? </span><span class="koboSpan" id="kobo.42.3">Do you have slow queries where the server takes a minute to retrieve records? </span><span class="koboSpan" id="kobo.42.4">Are web APIs performing at more than two seconds for </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">each request?</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">As you can see, performance is an analysis of an entire website including browser, server, C#, API, </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">and database.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">Amazon published a study calculating that if a page load slowed down by even 1 second on their website, it could cost them $1.6B </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">in sales.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.48.1">How one second could cost Amazon $1.6 billion in sales</span></p>
<p class="callout"><span class="koboSpan" id="kobo.49.1">The research was</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.50.1"> reported by Fast Company and is located </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">at </span></span><a href="https://fastcompany.com/1825005/how-one-second-could-cost-amazon-16-billion-sales"><span class="No-Break"><span class="koboSpan" id="kobo.52.1">https://fastcompany.com/1825005/how-one-second-could-cost-amazon-16-billion-sales</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.53.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">While this is a head-turner, there is a more recent article on how Netflix replaced React with plain JavaScript (more commonly called Vanilla JavaScript). </span><span class="koboSpan" id="kobo.54.2">This provided huge gains in performance. </span><span class="koboSpan" id="kobo.54.3">In the case study, it reported one page had 300 KB of JavaScript, which is a lot. </span><span class="koboSpan" id="kobo.54.4">However, compared to other websites such as </span><a href="http://CNN.com"><span class="koboSpan" id="kobo.55.1">CNN.com</span></a><span class="koboSpan" id="kobo.56.1"> (4.4 MB of JavaScript) and </span><a href="http://USAToday.com"><span class="koboSpan" id="kobo.57.1">USAToday.com</span></a><span class="koboSpan" id="kobo.58.1"> (1.5 MB of JavaScript), 300 KB of JavaScript is </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">considered minimal.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.60.1">A Netflix web performance case study</span></p>
<p class="callout"><span class="koboSpan" id="kobo.61.1">Google Chrome </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.62.1">Engineering Lead </span><em class="italic"><span class="koboSpan" id="kobo.63.1">Addy Osmani</span></em><span class="koboSpan" id="kobo.64.1"> wrote an article about the performance gains Netflix experienced through optimizations. </span><span class="koboSpan" id="kobo.64.2">The case study can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">at </span></span><a href="https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9"><span class="No-Break"><span class="koboSpan" id="kobo.66.1">https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.67.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">With these specific scenarios and case studies, many companies took notice and focused primarily on performance. </span><span class="koboSpan" id="kobo.68.2">Even Microsoft focused its efforts on performance by submitting its results to TechEmpower’s industry framework benchmark results. </span><span class="koboSpan" id="kobo.68.3">As a result of the constant</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.69.1"> improvement, ASP.NET is now ranked as one of the fastest platforms for </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">the web.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.71.1">TechEmpower framework benchmark results</span></p>
<p class="callout"><span class="koboSpan" id="kobo.72.1">Every year, TechEmpower</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.73.1"> updates its results in a chart that can be found at </span><a href="https://techempower.com/benchmarks/"><span class="koboSpan" id="kobo.74.1">https://techempower.com/benchmarks/</span></a><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">As of July 19, 2022, ASP.NET is ranked #9 </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">in performance.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Finally, with Google as the most dominant player in the search engine industry, it attached how fast a page loads </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.78.1">to your </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">search engine result pages</span></strong><span class="koboSpan" id="kobo.80.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.81.1">SERPs</span></strong><span class="koboSpan" id="kobo.82.1">). </span><span class="koboSpan" id="kobo.82.2">Translation: the speed of your site is one of the ranking factors for how high you are in the search results (which we’ll discuss in the </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">next section).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.84.1">Google using site speed in web search ranking</span></p>
<p class="callout"><span class="koboSpan" id="kobo.85.1">On Google’s blog, they mentioned that page speed is another factor taken into account when ranking your website. </span><span class="koboSpan" id="kobo.85.2">The post is found </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">at </span></span><a href="https://developers.google.com/search/blog/2010/04/using-site-speed-in-web-search-ranking"><span class="No-Break"><span class="koboSpan" id="kobo.87.1">https://developers.google.com/search/blog/2010/04/using-site-speed-in-web-search-ranking</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.88.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">Performance is one of my favorite topics. </span><span class="koboSpan" id="kobo.89.2">The idea of making small changes that lead to large performance gains is definitely exciting. </span><span class="koboSpan" id="kobo.89.3">It also can be visually apparent as well. </span><span class="koboSpan" id="kobo.89.4">This chapter is meant to assist in using techniques and tools to identify those performance issues on </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">any website.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">The good news is, in past chapters, we’ve already mentioned specific ways to improve performance that we’ll refer back to when relevant. </span><span class="koboSpan" id="kobo.91.2">As I’ve said in </span><a href="B19493_04.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.92.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.93.1">, performance should be the top priority when building ASP.NET web applications, with security running a </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">close second.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">Performance has always been a mix between an art and a science as you’ll see in some of the sections in this chapter. </span><span class="koboSpan" id="kobo.95.2">There is </span><em class="italic"><span class="koboSpan" id="kobo.96.1">perceived</span></em><span class="koboSpan" id="kobo.97.1"> performance and then there’s </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.98.1">actual</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1"> performance.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">Actual performance is a measurement when an activity or task immediately responds and notifies the user that it’s finished. </span><span class="koboSpan" id="kobo.100.2">An immediate response is a goal. </span><span class="koboSpan" id="kobo.100.3">Perceived performance is a subjective measurement where users experience an activity or task as quick, even when it isn’t. </span><span class="koboSpan" id="kobo.100.4">One example of perceived performance is when the user requests a web page and the browser renders the page immediately. </span><span class="koboSpan" id="kobo.100.5">The content continues to load in the background while keeping the user’s focus by allowing them to scroll through the page waiting for the additional content. </span><span class="koboSpan" id="kobo.100.6">As a result, users think the site is “fast” because it responded immediately. </span><span class="koboSpan" id="kobo.100.7">Spinners and progress bars are other ways to achieve perceived performance while something </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">is processing.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">While perceived performance is a way to divert a user’s attention while waiting for a process to complete, this</span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.103.1"> chapter will focus more on </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">actual performance.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">In the next section, we’ll learn how to create baselines for client-side and server-side code using </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.106.1">public </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.107.1">web tools and</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.108.1"> specific server tools such as </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">Visual Studio Performance Profiler</span></strong><span class="koboSpan" id="kobo.110.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">Benchmark.net</span></strong><span class="koboSpan" id="kobo.112.1">, and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.113.1">Application Insights</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">.</span></span></p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.115.1">Establishing Baselines</span></h1>
<p><span class="koboSpan" id="kobo.116.1">So, how do you know </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.117.1">you’re experiencing</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.118.1"> a slowdown on a website? </span><span class="koboSpan" id="kobo.118.2">Is it because of a recent release of a software product, or a new NuGet package installed causing </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">the slowdown?</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">While identifying an issue, you may be asking yourself, “what changed?” </span><span class="koboSpan" id="kobo.120.2">But the question everyone </span><em class="italic"><span class="koboSpan" id="kobo.121.1">should</span></em><span class="koboSpan" id="kobo.122.1"> be asking is “how do you measure performance?” </span><span class="koboSpan" id="kobo.122.2">In order to measure it, there needs to be a baseline of what’s expected when it comes </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">to performance.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">Each part of your application should include performance tests. </span><span class="koboSpan" id="kobo.124.2">Whether it’s the frontend, a C# subsystem, a web API, or the database, the proper systems should be in place to notify the team when a system isn’t performing </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">as expected.</span></span></p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.126.1">Using Client-Side Tools</span></h2>
<p><span class="koboSpan" id="kobo.127.1">Issues on the client side are </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.128.1">mostly due to load times, delivery of </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.129.1">resources not found (such as HTML pages, images, CSS, and JavaScript), or JavaScript errors in general. </span><span class="koboSpan" id="kobo.129.2">However, this doesn’t mean the entire problem is on </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">Creating a baseline for your client-side code should be conducted through a testing tool such as </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">Cypress</span></strong><span class="koboSpan" id="kobo.133.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.134.1">Selenium</span></strong><span class="koboSpan" id="kobo.135.1"> during development and recording the duration of tests. </span><span class="koboSpan" id="kobo.135.2">Compare </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.136.1">the latest</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.137.1"> scenarios with previous test results to see where there is a </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">time difference.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Another approach for determining a baseline is to use various tools on the web such as the tools listed in this section. </span><span class="koboSpan" id="kobo.139.2">Think of these tools as like taking your car to the mechanic for maintenance. </span><span class="koboSpan" id="kobo.139.3">These tools scan your public website, analyze all aspects of the site, and provide a report on how to fix each </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">issue found.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">Some of the tools to give you insights into the performance of a website include </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.143.1">Google P</span><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.144.1">ageSpeed Insights</span></strong><span class="koboSpan" id="kobo.145.1"> (</span><a href="https://pagespeed.web.dev"><span class="koboSpan" id="kobo.146.1">https://pagespeed.web.dev</span></a><span class="koboSpan" id="kobo.147.1">): Google uses its search </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.148.1">engine to rank your site and provides an exceptional tool to help with </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">website problems.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.150.1">Lighthouse</span></strong><span class="koboSpan" id="kobo.151.1"> (</span><a href="https://developer.chrome.com/docs/lighthouse/"><span class="koboSpan" id="kobo.152.1">https://developer.chrome.com/docs/lighthouse/</span></a><span class="koboSpan" id="kobo.153.1">): If your site isn’t </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.154.1">publicly accessible to analyze from one of these tools, you can use the Lighthouse extension to run tests on the site in-house. </span><span class="koboSpan" id="kobo.154.2">Lighthouse produces a full report of recommendations on how to make your site </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">perform </span></span><span class="No-Break"><a id="_idIndexMarker574"/></span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">better.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.157.1">GTMetrix</span></strong><span class="koboSpan" id="kobo.158.1"> (</span><a href="https://gtmetrix.com"><span class="koboSpan" id="kobo.159.1">https://gtmetrix.com</span></a><span class="koboSpan" id="kobo.160.1">): GTMetrix is</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.161.1"> a tool I’ve been using over the years and it continues to impress and improve each year. </span><span class="koboSpan" id="kobo.161.2">It provides a performance summary, speed visualization, </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">and recommendations.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.163.1">Google Search Console</span></strong><span class="koboSpan" id="kobo.164.1"> (</span><a href="https://search.google.com/search-console"><span class="koboSpan" id="kobo.165.1">https://search.google.com/search-console</span></a><span class="koboSpan" id="kobo.166.1">): Google</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.167.1"> created this for administrators of websites to identify performance issues along with other general maintenance tools, such as what people are typing into Google to find </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">your website.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.169.1">DevTools</span></strong><span class="koboSpan" id="kobo.170.1">: DevTools is a</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.171.1"> panel of web developer tools located inside of Google Chrome, Mozilla Firefox, Apple Safari, and Microsoft Edge to help web developers analyze web pages, and it’s becoming the IDE of the internet. </span><span class="koboSpan" id="kobo.171.2">Pressing F12 in the browser will open </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">the panel.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.173.1">These tools are great for gauging how well your site performs on the internet and how it performs based on the last revision. </span><span class="koboSpan" id="kobo.173.2">If your last release takes 0.5 seconds to load and the latest </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.174.1">release </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.175.1">now takes three seconds, it’s time to examine what changed. </span><span class="koboSpan" id="kobo.175.2">What better way to check this than to automate the process (refer to </span><a href="B19493_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.176.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.177.1">) by reporting on the performance issue before deploying </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">the site?</span></span></p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.179.1">Using Server-Side Tools</span></h2>
<p><span class="koboSpan" id="kobo.180.1">With ASP.NET, creating</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.181.1"> baselines for your code is just as easy</span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.182.1"> with a number of tools at </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">your disposal.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">In this section, we’ll review some of the tools available for creating a baseline for your code such as Visual Studio, Benchmark.net, Application Insights, and other tools such </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">as NDepend.</span></span></p>
<h3><span class="koboSpan" id="kobo.186.1">Visual Studio Performance Tools</span></h3>
<p><span class="koboSpan" id="kobo.187.1">With Visual</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.188.1"> Studio being a solid IDE in</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.189.1"> the industry, the ability to gauge C# performance was becoming more prevalent because if code was slow, developers wanted a way to locate </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">the bottleneck.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.191.1"><img alt="Figure 10.1 – Performance Profiler in Visual Studio 2022" src="image/B19493_10_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.192.1">Figure 10.1 – Performance Profiler in Visual Studio 2022</span></p>
<p><span class="koboSpan" id="kobo.193.1">When starting </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">Performance Profiler</span></strong><span class="koboSpan" id="kobo.195.1">, you’re presented with a list </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">of options:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.197.1"><img alt="Figure 10.2 – List of available options before running Performance Profiler" src="image/B19493_10_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.198.1">Figure 10.2 – List of available options before running Performance Profiler</span></p>
<p><span class="koboSpan" id="kobo.199.1">As you can see, there are a vast number of options crossing multiple touchpoints. </span><span class="koboSpan" id="kobo.199.2">For example, there is a </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">Database</span></strong><span class="koboSpan" id="kobo.201.1"> option to look at how your queries are performing in </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">The metrics for databases are</span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.204.1"> similar to the </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">Entity Framework</span></strong><span class="koboSpan" id="kobo.206.1"> details explaining the duration it took to execute the query. </span><span class="koboSpan" id="kobo.206.2">Another option is identifying where async/await problems can </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.207.1">occur as well as memory usage </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.208.1">and </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">object allocation.</span></span></p>
<h3><span class="koboSpan" id="kobo.210.1">Benchmark.net</span></h3>
<p><span class="koboSpan" id="kobo.211.1">If there are</span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.212.1"> smaller, self-contained methods required to test, one</span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.213.1"> of the best tools around for micro-benchmarking is </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">Benchmark.net (</span></span><a href="https://benchmarkdotnet.org/"><span class="No-Break"><span class="koboSpan" id="kobo.215.1">https://benchmarkdotnet.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.216.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Benchmark.net takes specific methods and tests them with different scenarios. </span><span class="koboSpan" id="kobo.217.2">The one caveat to this is that the Benchmark project </span><em class="italic"><span class="koboSpan" id="kobo.218.1">must</span></em><span class="koboSpan" id="kobo.219.1"> be a </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">console application.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">As an example, if we wanted to test the age-old debate as to which is faster between string concatenation or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">StringBuilder</span></strong><span class="koboSpan" id="kobo.223.1"> class, we would write two benchmark tests to determine which was faster, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.225.1">
public class Benchmarks
{
    [Benchmark(Baseline = true)]
    public void StringConcatenationScenario()
    {
        var input = string.Empty;
        for (int i = 0; i &lt; 10000; i++)
        {
            input += «a»;
        }
    }
    [Benchmark]
    public void StringBuilderScenario()
    {
        var input = new StringBuilder();
        for (int i = 0; i &lt; 10000; i++)
        {
            input.Append(«a»);
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.226.1">In the preceding code, we created a string in one scenario and an instance of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">StringBuilder()</span></strong><span class="koboSpan" id="kobo.228.1"> class in another. </span><span class="koboSpan" id="kobo.228.2">To accomplish the same goal, we add 10,000 ‘a’s and start </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">the benchmark.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">Based on the results in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.231.1">Figure 10</span></em></span><em class="italic"><span class="koboSpan" id="kobo.232.1">.3</span></em><span class="koboSpan" id="kobo.233.1">, the obvious choice is to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">StringBuilder()</span></strong><span class="koboSpan" id="kobo.235.1"> for performing large </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">string concatenations:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.237.1"><img alt="Figure 10.3 – Comparing the performance of a string concatenation versus a StringBuilder() class" src="image/B19493_10_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.238.1">Figure 10.3 – Comparing the performance of a string concatenation versus a StringBuilder() class</span></p>
<p><span class="koboSpan" id="kobo.239.1">In regards to creating a baseline, we added an additional parameter to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">[Benchmark]</span></strong><span class="koboSpan" id="kobo.241.1"> attribute in our first scenario, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">Baseline</span></strong><span class="koboSpan" id="kobo.243.1">, and set it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">true</span></strong><span class="koboSpan" id="kobo.245.1">. </span><span class="koboSpan" id="kobo.245.2">This tells Benchmark.net to use this as our baseline when measuring the performance of our other methods. </span><span class="koboSpan" id="kobo.245.3">You can have any number of methods to achieve the same result, but </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.246.1">everything </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.247.1">will be compared to the one method with </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">Baseline=true</span></strong><span class="koboSpan" id="kobo.249.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">Benchmark attribute.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">For small, compact methods, Benchmark.net is definitely a great tool for providing insight into ways to create faster code </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">using micro-optimizations.</span></span></p>
<h3><span class="koboSpan" id="kobo.253.1">Application Insights</span></h3>
<p><span class="koboSpan" id="kobo.254.1">Microsoft’s Application</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.255.1"> Insights is meant to be a general-purpose</span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.256.1"> analysis tool for collecting telemetry about everything your application does. </span><span class="koboSpan" id="kobo.256.2">Once set up, Application Insights can collect data about </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.258.1">Requests – web pages and </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">API calls</span></span></li>
<li><span class="koboSpan" id="kobo.260.1">Dependencies – what is your application loading behind </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">the scenes?</span></span></li>
<li><span class="koboSpan" id="kobo.262.1">Exceptions – every exception your </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">application throws</span></span></li>
<li><span class="koboSpan" id="kobo.264.1">Performance counters – automatically </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">identifying slowdowns</span></span></li>
<li><span class="koboSpan" id="kobo.266.1">Heartbeats – is the application still up </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">and running?</span></span></li>
<li><span class="koboSpan" id="kobo.268.1">Logs – a centralized location for collecting all types of logs for </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">your application</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.270.1">When adding</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.271.1"> Application Insights, Application</span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.272.1"> Insights </span><em class="italic"><span class="koboSpan" id="kobo.273.1">does</span></em><span class="koboSpan" id="kobo.274.1"> require an </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">Azure subscription.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.276.1">Application Insights additional material</span></p>
<p class="callout"><span class="koboSpan" id="kobo.277.1">There are various ways to set up Application Insights and way too many to cover in this chapter. </span><span class="koboSpan" id="kobo.277.2">For more information on Application Insights and how to set it up for your application, navigate </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">to </span></span><a href="https://learn.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core"><span class="No-Break"><span class="koboSpan" id="kobo.279.1">https://learn.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.280.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">Some other recommendations for creating baselines and identifying bottlenecks include </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.283.1">JetBrains dotTrace/dotMemory</span></strong><span class="koboSpan" id="kobo.284.1"> – dotTrace is a performance profiler tool, and dotMemory is a memory profiler tool. </span><span class="koboSpan" id="kobo.284.2">Both are exceptional tools and perform deep dives into how well your application performs. </span><span class="koboSpan" id="kobo.284.3">dotTrace and dotMemory give you the ability to compare a baseline of results against another set of results (“</span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">comparing snapshots”).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.286.1">RedGate ANTS Performance Profiler/Memory Profiler</span></strong><span class="koboSpan" id="kobo.287.1"> – With the ability to profile .NET code and memory allocations, the ANTS Performance and Memory Profiler demonstrates a similar approach to performance and memory profiling while conducting a deep-dive analysis while your code </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">is running.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.289.1">NDepend</span></strong><span class="koboSpan" id="kobo.290.1"> – The first time you run NDepend against your code, you immediately create a baseline of your code. </span><span class="koboSpan" id="kobo.290.2">The next time you run NDepend, it compares your baseline to the new code you wrote and, as an example, can provide data on “too many exceptions raised” or cyclomatic complexity (which is how complex your code is based on conditional branching, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">if..else</span></strong><span class="koboSpan" id="kobo.292.1"> or switches). </span><span class="koboSpan" id="kobo.292.2">These can be user-defined as well to meet your code quality requirements </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.293.1">using </span><strong class="bold"><span class="koboSpan" id="kobo.294.1">Code Query for LINQ</span></strong><span class="koboSpan" id="kobo.295.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.296.1">CQLinq</span></strong><span class="koboSpan" id="kobo.297.1">). </span><span class="koboSpan" id="kobo.297.2">NDepend also has capabilities to integrate into your CI/CD pipeline to automate </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">the process.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.299.1">Build-it-yourself metrics</span></strong><span class="koboSpan" id="kobo.300.1"> – Back in </span><a href="B19493_07.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.301.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.302.1">, we explained how to “identify slow integration tests.” </span><span class="koboSpan" id="kobo.302.2">Using the diagnostic Stopwatch on your unit, integration, and APIs, you can perform and report on these metrics even before sending out </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">a release.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.304.1">When these tools examine your application, they perform analysis on how to optimize your code by</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.305.1"> finding hotspots. </span><span class="koboSpan" id="kobo.305.2">If the hotspot is called</span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.306.1"> enough times, your application’s performance will suffer. </span><span class="koboSpan" id="kobo.306.2">The path to get to this hotspot is</span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.307.1"> called the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.308.1">hot path</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">.</span></span></p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.310.1">Databases</span></h2>
<p><span class="koboSpan" id="kobo.311.1">While you can </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.312.1">create a baseline with databases, most optimizations are done at the database level by analyzing stored procedures, index management, and schema definitions. </span><span class="koboSpan" id="kobo.312.2">Each database type has its own performance tools for finding bottlenecks. </span><span class="koboSpan" id="kobo.312.3">For now, we’ll focus</span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.313.1"> specifically on </span><strong class="bold"><span class="koboSpan" id="kobo.314.1">SQL </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.315.1">Server</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.316.1"> tools.</span></span></p>
<h3><span class="koboSpan" id="kobo.317.1">SQL Server Management Studio (SSMS) Profiler</span></h3>
<p><span class="koboSpan" id="kobo.318.1">With </span><strong class="bold"><span class="koboSpan" id="kobo.319.1">SSMS</span></strong><span class="koboSpan" id="kobo.320.1"> using a </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.321.1">profiler </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.322.1">interface, developers have the ability to identify whether a particular ad-hoc query, stored procedure, or table isn’t performing </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">SQL Server Profiler is located under the </span><strong class="bold"><span class="koboSpan" id="kobo.325.1">Tools</span></strong><span class="koboSpan" id="kobo.326.1"> option as the first menu item, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.327.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.328.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.330.1"><img alt="Figure 10.4 – SQL Server Profiler in SSMS" src="image/B19493_10_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.331.1">Figure 10.4 – SQL Server Profiler in SSMS</span></p>
<p><span class="koboSpan" id="kobo.332.1">On running SQL Server profiler, every request sent to the database is logged along with how long it</span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.333.1"> took, how many</span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.334.1"> reads and writes are necessary, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">results returned.</span></span></p>
<h3><span class="koboSpan" id="kobo.336.1">Query Store</span></h3>
<p><span class="koboSpan" id="kobo.337.1">One of the latest</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.338.1"> features of SQL Server 2016 is the </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">Query Store</span></strong><span class="koboSpan" id="kobo.340.1">. </span><span class="koboSpan" id="kobo.340.2">The Query </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.341.1">Store provides you with insight into how to improve performance on </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">SQL Server.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">Once enabled (right-click on database | </span><strong class="bold"><span class="koboSpan" id="kobo.344.1">Properties</span></strong><span class="koboSpan" id="kobo.345.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">Query Store</span></strong><span class="koboSpan" id="kobo.347.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.348.1">Operation Mode: On</span></strong><span class="koboSpan" id="kobo.349.1">), it’ll begin analyzing your SQL Server workload when actively being used and make recommendations on how to </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">improve performance.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">Once the data is collected, the metrics are available using stored procedures to identify </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">slow-performing queries.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.353.1">Query Store additional material</span></p>
<p class="callout"><span class="koboSpan" id="kobo.354.1">For additional material on Microsoft’s Query Store, navigate to </span><a href="https://learn.microsoft.com/en-us/sql/relational-databases/performance/manage-the-query-store"><span class="koboSpan" id="kobo.355.1">https://learn.microsoft.com/en-us/sql/relational-databases/performance/manage-the-query-store</span></a><span class="koboSpan" id="kobo.356.1">. </span><span class="koboSpan" id="kobo.356.2">For performance tuning using Query Store, navigate </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">to </span></span><a href="https://learn.microsoft.com/en-us/sql/relational-databases/performance/tune-performance-with-the-query-store"><span class="No-Break"><span class="koboSpan" id="kobo.358.1">https://learn.microsoft.com/en-us/sql/relational-databases/performance/tune-performance-with-the-query-store</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.359.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">In this section, we covered why establishing baselines is important while listing various client-side tools such as Google Page Speed Insights, Lighthouse, GTMetrix, Google Search Console, and Chrome DevTools for gauging performance. </span><span class="koboSpan" id="kobo.360.2">We also looked at server-side tools such as Visual Studio Performance Profiler, Benchmark.net, Application Insights, JetBrains dotMemory and dotTrace, RedGate ANTS Performance Profiler/Memory Profiler, and NDepend for identifying issues with codebases. </span><span class="koboSpan" id="kobo.360.3">With databases, we mentioned two tools to identify performance bottlenecks: SQL Server Management Studio Profiler and Query Store. </span><span class="koboSpan" id="kobo.360.4">We also mentioned hotspots, or hot paths, where</span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.361.1"> frequently called, unoptimized code could cause </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.362.1">performance issues in </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">The next section will cover the best practices for some client-side and server-side techniques, but will mostly focus on server-side optimizations </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">using C#.</span></span></p>
<h1 id="_idParaDest-227"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.366.1">Applying Performance Best Practices</span></h1>
<p><span class="koboSpan" id="kobo.367.1">As mentioned at the beginning of this chapter, the content in this chapter applies to client </span><em class="italic"><span class="koboSpan" id="kobo.368.1">and</span></em><span class="koboSpan" id="kobo.369.1"> server</span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.370.1"> techniques to get the most out of your </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">ASP.NET websites.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">In this section, we’ll first focus on optimizing the client by applying image optimization, minimizing your requests, using CDNs, and other tips to improve client-side performance. </span><span class="koboSpan" id="kobo.372.2">Then we’ll focus on server-side techniques such as optimizing your HTML, caching, and </span><strong class="bold"><span class="koboSpan" id="kobo.373.1">Entity Framework Core</span></strong><span class="koboSpan" id="kobo.374.1"> performance </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.375.1">techniques along with identifying </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">slow queries.</span></span></p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.377.1">Optimizing client-side performance</span></h2>
<p><span class="koboSpan" id="kobo.378.1">In this section, we’ll learn </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.379.1">about image optimizations, identifying</span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.380.1"> Google’s </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">Core Web Vitals</span></strong><span class="koboSpan" id="kobo.382.1"> metrics, using a CDN when applicable, how to minimize requests, and where to place scripts </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">and styles.</span></span></p>
<h3><span class="koboSpan" id="kobo.384.1">Fixing Image Optimization</span></h3>
<p><span class="koboSpan" id="kobo.385.1">According </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.386.1">to the Web Almanac (</span><a href="https://almanac.httparchive.org/en/2022/media#bytesizes"><span class="koboSpan" id="kobo.387.1">https://almanac.httparchive.org/en/2022/media#bytesizes</span></a><span class="koboSpan" id="kobo.388.1">), image optimization is </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.389.1">one of </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.390.1">the worst problems on the web. </span><span class="koboSpan" id="kobo.390.2">The number of devices required to support it doesn’t make this any easier. </span><span class="koboSpan" id="kobo.390.3">Let’s see how we can optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">this experience.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">Here’s the basic usage of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">img&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.395.1"> tag</span></span><span class="No-Break"><span class="Annotation-reference"><span class="koboSpan" id="kobo.396.1">:</span></span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
&lt;img width="100" height="100"
     src="/images/logo.jpg"
     alt="Buck's Coffee Shop Logo"</span></pre> <p><span class="koboSpan" id="kobo.398.1">However, for responsive layouts, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">&lt;img&gt;</span></strong><span class="koboSpan" id="kobo.400.1"> tag has an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">srcset</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.402.1"> attribute:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.403.1">
&lt;img src="/images/logo-400.jpg" 
alt="Buck›s Coffee Shop Logo" 
width="100"
height="100" 
loading="lazy"
srcset="logo-400.jpg 400w, 
logo-800.jpg 800w, 
logo-1024.jpg 1024w"
sizes="(max-width: 640px) 400px, 800px, 1024px"&gt;</span></pre> <p><span class="koboSpan" id="kobo.404.1">The preceding code identifies the size of the viewport (the web page) and loads the appropriate image. </span><span class="koboSpan" id="kobo.404.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">max-width</span></strong><span class="koboSpan" id="kobo.406.1"> media condition says that if the viewport is 640px, use the 400px image. </span><span class="koboSpan" id="kobo.406.2">If the max-width is over 640px and less than 800px, use the </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">800px image.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">This allows you to support a number of different responsive layouts. </span><span class="koboSpan" id="kobo.408.2">Once you define the layout for your site, images should complement the layout size as well. </span><span class="koboSpan" id="kobo.408.3">What does this mean? </span><span class="koboSpan" id="kobo.408.4">For every image, you should have an image created for each responsive layout. </span><span class="koboSpan" id="kobo.408.5">For example, the preceding default image logo should have three images: </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">logo-400.jpg</span></strong><span class="koboSpan" id="kobo.410.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">logo-800.jpg</span></strong><span class="koboSpan" id="kobo.412.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">logo-1024.jpg</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">Also, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">loading="lazy"</span></strong><span class="koboSpan" id="kobo.418.1"> tells the browser to defer loading the images until the browser can determine the size of the viewport to display the </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">proper image.</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">Finally, images can become extremely large and can contain encoded data such as GPS data when a picture is taken. </span><span class="koboSpan" id="kobo.420.2">Compressing an image is the process of removing the extra data, making the image smaller and quicker to load in a browser. </span><span class="koboSpan" id="kobo.420.3">This is a server-side task and can be included as a task in your client-side task runner (previously discussed in </span><a href="B19493_06.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.421.1">Chapter 6</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.422.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">The minimum steps for image optimization should look like </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">the following:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.425.1">Determine the site’s responsive layouts</span></strong><span class="koboSpan" id="kobo.426.1"> – Identify the sizes you need for your images (400px, </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">800px, etc.)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.428.1">Create the images based on the layouts</span></strong><span class="koboSpan" id="kobo.429.1"> – There should be a resized image for each </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">layout size.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.431.1">Optimize the images</span></strong><span class="koboSpan" id="kobo.432.1"> – For each image on your site, compress the images so they are smaller and load faster by removing the extra data attached to each image. </span><span class="koboSpan" id="kobo.432.2">Use image services such as Optimazilla (</span><a href="https://imagecompressor.com/"><span class="koboSpan" id="kobo.433.1">https://imagecompressor.com/</span></a><span class="koboSpan" id="kobo.434.1">) or </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">TinyPNG (</span></span><a href="https://tinypng.com/"><span class="No-Break"><span class="koboSpan" id="kobo.436.1">https://tinypng.com/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.437.1">).</span></span></li>
<li> <strong class="bold"><span class="koboSpan" id="kobo.438.1">Add the new &lt;img&gt; attributes</span></strong><span class="koboSpan" id="kobo.439.1"> – Each image tag should include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">srcset</span></strong><span class="koboSpan" id="kobo.441.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">sizes</span></strong><span class="koboSpan" id="kobo.443.1"> attributes so the browser can determine the best image to display based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">viewport size.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.445.1">Image</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.446.1"> optimization </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.447.1">is too big a topic for a small chapter, but this quick overview should be enough to provide a better experience for </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">website users.</span></span></p>
<h3><span class="koboSpan" id="kobo.449.1">Minimizing requests</span></h3>
<p><span class="koboSpan" id="kobo.450.1">Most of the aforementioned </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.451.1">client-side tools for creating baselines can be used to identify where multiple requests are made for resources. </span><span class="koboSpan" id="kobo.451.2">On average, websites have 58 requests for JavaScript and CSS (that’s </span><em class="italic"><span class="koboSpan" id="kobo.452.1">not</span></em><span class="koboSpan" id="kobo.453.1"> counting images). </span><span class="koboSpan" id="kobo.453.2">Each request causes latency and depending on the resource, it’ll take longer than a user is willing </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">to wait.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">We’ve already learned how to use a better approach when structuring your JavaScript and CSS back in </span><a href="B19493_06.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.456.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.457.1">, eliminating a large number of requests for your JavaScript and </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">CSS files.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">Finally, if there’s a large number of consistent-sized images and you’re calling each one separately, a better approach would be to create one large image (sprite sheet) containing all of the images and use CSS to display them. </span><span class="koboSpan" id="kobo.459.2">Instead of your browser requesting 15 social network logos, make one call to an image and split them out using CSS, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.460.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.461.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.463.1"><img alt="Figure 10.5 – Sprite sheet of 32x32 social network icons" src="image/B19493_10_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.464.1">Figure 10.5 – Sprite sheet of 32x32 social network icons</span></p>
<p><span class="koboSpan" id="kobo.465.1">To use this sprite sheet, the CSS would look like </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.467.1">
.bg-YouTube_32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -1px -1px;
}
.bg-facebook_32x32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -35px -1px;
}
.bg-github_32x32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -1px -35px;
}
.bg-Instagram_32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -35px -35px;
}
.bg-LinkedIn_32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -69px -1px;
}
.bg-quora_32x32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -69px -35px;
}
.bg-RSS_32x32 {
    width: 32px; height: 3</span><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.468.1">2px;
    background: url('css_sprites.png') -1px -69px;
}
.bg-Twitter_32 {
    width: 32px; height: 32px;
    background: url('css_sprites.png') -35px -69px;
}</span></pre> <p><span class="koboSpan" id="kobo.469.1">The background identifies </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.470.1">which image to use as a background by using the offset top and left positions. </span><span class="koboSpan" id="kobo.470.2">To display the RSS icon in HTML, it would be presented as </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.472.1">
&lt;div class="bg-RSS_32x32"&gt;&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.473.1">Such services to create sprites include CodeShack’s Images to Sprite Sheet Generator (</span><a href="https://codeshack.io/images-sprite-sheet-generator/"><span class="koboSpan" id="kobo.474.1">https://codeshack.io/images-sprite-sheet-generator/</span></a><span class="koboSpan" id="kobo.475.1">) and </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.476.1">Toptal’s CSS Sprites </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">Generator (</span></span><a href="https://www.toptal.com/developers/css/sprite-generator"><span class="No-Break"><span class="koboSpan" id="kobo.478.1">https://www.toptal.com/developers/css/sprite-generator</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.479.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.480.1">Using CDNs</span></h3>
<p><span class="koboSpan" id="kobo.481.1">If a site uses a</span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.482.1"> large number of static files, using a </span><strong class="bold"><span class="koboSpan" id="kobo.483.1">content delivery network</span></strong><span class="koboSpan" id="kobo.484.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.485.1">CDN</span></strong><span class="koboSpan" id="kobo.486.1">) provides a</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.487.1"> much-needed service of delivering content based on location. </span><span class="koboSpan" id="kobo.487.2">These geographically based servers cache files so they’re delivered quicker based on where a user </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">is located.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">For example, if someone in California requests a file from Nevada, it’s quicker than someone requesting the file from England. </span><span class="koboSpan" id="kobo.489.2">The closer the content, the quicker the user </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">receives it.</span></span></p>
<h3><span class="koboSpan" id="kobo.491.1">Final thoughts on client-side performance</span></h3>
<p><span class="koboSpan" id="kobo.492.1">While there are a ton</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.493.1"> of client-side tips we could cover, let’s close this section out with some final thoughts on making the </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">client quicker:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.495.1">Scripts at the bottom, styles at the top</span></strong><span class="koboSpan" id="kobo.496.1"> – Avoid placing scripts in the header, but absolutely place the styles in the header. </span><span class="koboSpan" id="kobo.496.2">Placing scripts at the bottom confirms </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.497.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.498.1">Document Object Model</span></strong><span class="koboSpan" id="kobo.499.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.500.1">DOM</span></strong><span class="koboSpan" id="kobo.501.1">) is completely loaded and, if immediately executed, JavaScript is able to find the DOM elements because they’ve already </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">been rendered.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.503.1">Apply Google’s Core Web Vitals to your site</span></strong><span class="koboSpan" id="kobo.504.1"> – If you’re using either Lighthouse or Google’s Page Speed Insights, you’ll notice the following acronyms for identifying your site’s performance: FCP (First Contentful Paint), LCP (Largest Contentful Paint), CLS (Cumulative Layout Shift), and FID (First Input Delay). </span><span class="koboSpan" id="kobo.504.2">Review these terms at </span><a href="https://web.dev/vitals"><span class="koboSpan" id="kobo.505.1">https://web.dev/vitals</span></a><span class="koboSpan" id="kobo.506.1"> to provide a better web experience for </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">your users.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.508.1">Replace JavaScript with HTML</span></strong><span class="koboSpan" id="kobo.509.1"> – Sometimes, using simple HTML is better than loading a full-blown JavaScript framework. </span><span class="koboSpan" id="kobo.509.2">Case in point, if you need an accordion, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">&lt;details&gt;</span></strong><span class="koboSpan" id="kobo.511.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">&lt;summary&gt;</span></strong><span class="koboSpan" id="kobo.513.1"> HTML tags may be enough. </span><span class="koboSpan" id="kobo.513.2">Also, browsers are becoming even more modern and evolved with new tags such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">&lt;dialog&gt;</span></strong><span class="koboSpan" id="kobo.515.1"> tag where JavaScript isn’t necessary. </span><span class="koboSpan" id="kobo.515.2">Refer to </span><a href="https://caniuse.com/"><span class="koboSpan" id="kobo.516.1">https://caniuse.com/</span></a><span class="koboSpan" id="kobo.517.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">browser support.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.519.1">In this section, you learned how to optimize the client side by optimizing your images, along with how CDNs improve the loading of your static content and how to minimize your requests to lower latency issues. </span><span class="koboSpan" id="kobo.519.2">For our final notes, we examined some tips such as placing scripts at the bottom and styles at the top, applying Google’s Core Web Vitals to websites, providing sites that are responsive regardless of device, and using HTML instead of </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.520.1">JavaScript where it </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">makes sense.</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">In the next section, we’ll shift our focus from the client to the server side and look at some of the common practices when optimizing C# and Entity </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">Framework Core.</span></span></p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.524.1">Common Server-side Practices</span></h2>
<p><span class="koboSpan" id="kobo.525.1">With C# being such a </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.526.1">robust language, there are so many ways to create a web application. </span><span class="koboSpan" id="kobo.526.2">As you saw in </span><a href="B19493_05.xhtml#_idTextAnchor114"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.527.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.528.1"> with Entity Framework Core, each design pattern fit a certain need but worked the same regardless of the pattern. </span><span class="koboSpan" id="kobo.528.2">The good news with these performance techniques is they apply to web standards and design patterns already used in the industry. </span><span class="koboSpan" id="kobo.528.3">One such example is ETags. </span><span class="koboSpan" id="kobo.528.4">At one point, they were considered a separate web concept requiring specific code. </span><span class="koboSpan" id="kobo.528.5">Now, when using static files, these ETags are integrated into websites without any additional coding. </span><span class="koboSpan" id="kobo.528.6">They’re considered a web standard </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">with browsers.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">What we’re going to address in this section is how to improve performance by adding these web standards and design patterns to our own web application to make it </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">even faster.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">In this section, we’ll learn about the various performance enhancements we can apply to your code using C#, including quick performance gains you can apply immediately to your own website, and we’ll learn how to add a middleware component to optimize your HTML, improve Entity Framework Core performance with only four letters, and identify slow Entity Framework </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">Core queries.</span></span></p>
<h3><span class="koboSpan" id="kobo.534.1">Applying quick performance wins</span></h3>
<p><span class="koboSpan" id="kobo.535.1">While some of these</span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.536.1"> quick hits are </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.537.1">well-known (and some have been covered in previous chapters), it doesn’t hurt to review them to get the most performance out of </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">your website:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.539.1">Turn Debug Off</span></strong><span class="koboSpan" id="kobo.540.1"> – When you run your application with debug mode, additional information is compiled into each assembly for debugging purposes. </span><span class="koboSpan" id="kobo.540.2">When changed to release mode, you are getting an optimized version of your assemblies </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">for deployment.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.542.1">Use async/await</span></strong><span class="koboSpan" id="kobo.543.1"> – As mentioned in previous chapters, using async/await provides performance benefits and should be used for tasks involving file I/O, database, and </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">API calls.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.545.1">Use the database</span></strong><span class="koboSpan" id="kobo.546.1"> – When using Entity Framework Core, try to assess the goal and evaluate the best approach: whether it’s an Entity Framework Core simple data access method or whether a stored procedure would provide </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">faster performance.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.548.1">Use .AsNoTracking()</span></strong><span class="koboSpan" id="kobo.549.1"> – As mentioned in </span><a href="B19493_05.xhtml#_idTextAnchor114"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.550.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.551.1">, if you have an Entity Framework query not requiring </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">ChangeState</span></strong><span class="koboSpan" id="kobo.553.1"> management such as updating an entity, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">.AsNoTracking()</span></strong><span class="koboSpan" id="kobo.555.1"> to reduce the Entity </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">Framework overhead.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.557.1">While these are some tips to give a web application a quick lift in performance, we’re now ready to dive into more involved </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">code-based techniques.</span></span></p>
<h3><span class="koboSpan" id="kobo.559.1">Optimizing the HTML</span></h3>
<p><span class="koboSpan" id="kobo.560.1">Since we learned about </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.561.1">optimizing images (in the last section) and</span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.562.1"> optimizing JavaScript and CSS (in </span><a href="B19493_06.xhtml#_idTextAnchor137"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.563.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.564.1">), we now need to focus on the </span><em class="italic"><span class="koboSpan" id="kobo.565.1">other</span></em><span class="koboSpan" id="kobo.566.1"> client-side </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">resource: HTML.</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">When you “view source” in the browser, you’d like to see this beautifully formatted document that everyone can understand. </span><span class="koboSpan" id="kobo.568.2">But when the browser receives this document, it doesn’t care how big it is or even how “pretty” it is. </span><span class="koboSpan" id="kobo.568.3">The browser simply parses and renders the HTML as it </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">comes in.</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">Have you noticed how much space is wasted in this document for the sake of formatting? </span><span class="koboSpan" id="kobo.570.2">For example, let’s load the “Buck’s Coffee Shop” </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">web page.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.573.1">Network</span></strong><span class="koboSpan" id="kobo.574.1"> tab in Chrome DevTools, we see it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">4.1 KB:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.576.1"><img alt="Figure 10.6 – Approximate size of Buck’s Coffee Shop with spaces (4.1 KB)" src="image/B19493_10_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.577.1">Figure 10.6 – Approximate size of Buck’s Coffee Shop with spaces (4.1 KB)</span></p>
<p><span class="koboSpan" id="kobo.578.1">Since the browser doesn’t care, wouldn’t it be better if we could reduce the size of </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">the HTML?</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">Middleware can assist with this. </span><span class="koboSpan" id="kobo.580.2">If we use our standard middleware template from </span><a href="B19493_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.581.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.582.1">, we</span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.583.1"> can </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.584.1">create an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">HtmlShrink</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.586.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.587.1">
public class HtmlShrinkMiddleware
{
    private readonly RequestDelegate _next;
    public HtmlShrinkMiddleware(RequestDelegate next) =&gt; _next = next;
    public async Task InvokeAsync(HttpContext context)
    {
        using var buffer = new MemoryStream();
        </span><strong class="bold"><span class="koboSpan" id="kobo.588.1">// Replace the context response with our buffer</span></strong><span class="koboSpan" id="kobo.589.1">
        var stream = context.Response.Body;
        context.Response.Body = buffer;
        </span><strong class="bold"><span class="koboSpan" id="kobo.590.1">// Invoke the rest of the pipeline</span></strong><span class="koboSpan" id="kobo.591.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.592.1">// if there are any other middleware components</span></strong><span class="koboSpan" id="kobo.593.1">
        await _next(context);
        </span><strong class="bold"><span class="koboSpan" id="kobo.594.1">// Reset and read out the contents</span></strong><span class="koboSpan" id="kobo.595.1">
        buffer.Seek(0, SeekOrigin.Begin);
        </span><strong class="bold"><span class="koboSpan" id="kobo.596.1">// Adjust the response stream to remove whitespace.</span></strong><span class="koboSpan" id="kobo.597.1">
        var compressedHtmlStream = new HtmlShrinkStream(stream);
        </span><strong class="bold"><span class="koboSpan" id="kobo.598.1">// Reset the stream again</span></strong><span class="koboSpan" id="kobo.599.1">
        buffer.Seek(0, SeekOrigin.Begin);
        </span><strong class="bold"><span class="koboSpan" id="kobo.600.1">// Copy our content to the original stream and put it back</span></strong><span class="koboSpan" id="kobo.601.1">
        await buffer.CopyToAsync(compressedHtmlStream);
        context.Response.Body = compressedHtmlStream;
    }
}
public static class HtmlShrinkMiddlewareExtensions
{
    public static IApplicationBuilder UseHtmlShrink(
        this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&lt;HtmlShrinkMiddleware&gt;();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.602.1">The preceding code contains our familiar middleware scaffolding. </span><span class="koboSpan" id="kobo.602.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">HtmlShrinkMiddleware</span></strong><span class="koboSpan" id="kobo.604.1"> component now instantiates an </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">HtmlShrinkStream</span></strong><span class="koboSpan" id="kobo.606.1"> class to perform our compression, removing any whitespace in the HTML. </span><span class="koboSpan" id="kobo.606.2">Also, we created the standard extension at the bottom of </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">HtmlShrinkStream</span></strong><span class="koboSpan" id="kobo.610.1"> class is </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.611.1">shown</span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.612.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.614.1">
public class HtmlShrinkStream: Stream
{
    private readonly Stream _responseStream;
    public HtmlShrinkStream(Stream responseStream)
    {
        ArgumentNullException.ThrowIfNull(responseStream);
        _responseStream = responseStream;
    }
    public override bool CanRead =&gt; _responseStream.CanRead;
    public override bool CanSeek =&gt; _responseStream.CanSeek;
    public override bool CanWrite =&gt; _responseStream.CanWrite;
    public override long Length =&gt; _responseStream.Length;
    public override long Position
    {
        get =&gt; _responseStream.Position;
        set =&gt; _responseStream.Position = value;
    }
    public override void Flush() =&gt; _responseStream.Flush();
    public override int Read(byte[] buffer, int offset, int count) =&gt;
        _responseStream.Read(buffer, offset, count);
    public override long Seek(long offset, SeekOrigin origin) =&gt;
        _responseStream.Seek(offset, origin);
    public override void SetLength(long value) =&gt;
        _responseStream.SetLength(value);
    public override void Write(byte[] buffer, int offset, int count)
    {
        var html = Encoding.UTF8.GetString(buffer, offset, count);
         var removeSpaces = new Regex(@"(?&lt;=\s)\s+(?![^&lt;&gt;]*&lt;/pre&gt;)", RegexOptions.Multiline);
        html = removeSpaces.Replace(html, string.Empty);
var removeCrLf = new Regex(@"(\r\n|\r|\n)", RegexOptions.Multiline);
html = removeCrLf.Replace(html, string.Empty);
        buffer = Encoding.UTF8.GetBytes(html);
        _responseStream.WriteAsync(buffer, 0, buffer.Length);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.615.1">In</span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.616.1"> our </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">HtmlShrinkStream</span></strong><span class="koboSpan" id="kobo.618.1"> class, our efforts </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.619.1">are concentrated on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">Write()</span></strong><span class="koboSpan" id="kobo.621.1"> method. </span><span class="koboSpan" id="kobo.621.2">We look at the buffer received, turn it into an HTML string, replace all whitespace by using a RegEx, and finally, write the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">buffer</span></strong><span class="koboSpan" id="kobo.623.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">responseStream</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.627.1">We can now add our </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">HtmlShrink</span></strong><span class="koboSpan" id="kobo.629.1"> middleware extension to our pipeline by adding the following line to our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.631.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
app.UseHtmlShrink();</span></pre> <p><span class="koboSpan" id="kobo.633.1">Once added, any HTML received in the browser will be stripped of any whitespace. </span><span class="koboSpan" id="kobo.633.2">If we look at Buck’s Coffee Shop home page, we can see everything works, but if we view the source, we can see everything is a little </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">more compact:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.635.1"><img alt="Figure 10.7 – Viewing the source of Buck’s Coffee Shop home page" src="image/B19493_10_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.636.1">Figure 10.7 – Viewing the source of Buck’s Coffee Shop home page</span></p>
<p><span class="koboSpan" id="kobo.637.1">It may not look</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.638.1"> pretty, but if we look at the </span><strong class="bold"><span class="koboSpan" id="kobo.639.1">Network</span></strong><span class="koboSpan" id="kobo.640.1"> tab in</span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.641.1"> Chrome DevTools, we can see a difference in what was sent to </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">the browser:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.643.1"><img alt="Figure 10.8 – Size of Buck’s Coffee Shop home page without spaces (3.3 KB)" src="image/B19493_10_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.644.1">Figure 10.8 – Size of Buck’s Coffee Shop home page without spaces (3.3 KB)</span></p>
<p><span class="koboSpan" id="kobo.645.1">That’s almost 20% smaller than the </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">original size.</span></span></p>
<h3><span class="koboSpan" id="kobo.647.1">Enabling DbContext pooling</span></h3>
<p><span class="koboSpan" id="kobo.648.1">Connection</span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.649.1"> pooling </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.650.1">is the ability to reuse a connection for multiple users. </span><span class="koboSpan" id="kobo.650.2">By default, database connections already use connection pooling through a </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">SqlConnection</span></strong><span class="koboSpan" id="kobo.652.1">. </span><span class="koboSpan" id="kobo.652.2">This concept was applied to Entity Framework </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">Core’s </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">DbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">If a web application uses Entity Framework Core heavily, you want the best performance available. </span><span class="koboSpan" id="kobo.656.2">All it takes is to update your middleware </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">DbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.658.1"> connection.</span></span></p>
<p><span class="koboSpan" id="kobo.659.1">For example, I might have the following line in </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">my middleware:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.661.1">
services.AddDbContext&lt;MyDbContext&gt;(options =&gt;
    options.UseSqlServer(connectionString));</span></pre> <p><span class="koboSpan" id="kobo.662.1">We can immediately improve our performance by adding four letters to </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">this line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.664.1">
services.AddDbContextPool&lt;MyDbContext&gt;(options =&gt;
    options.UseSqlServer(connectionString));</span></pre> <p><span class="koboSpan" id="kobo.665.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">AddDbContextPool&lt;&gt;()</span></strong><span class="koboSpan" id="kobo.667.1"> method contains the same syntax, but after a </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">DbContext</span></strong><span class="koboSpan" id="kobo.669.1"> is done, it will reset its state and store it for later when a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">DbContext</span></strong><span class="koboSpan" id="kobo.671.1"> is required. </span><span class="koboSpan" id="kobo.671.2">We are recycling </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">our </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">DbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">s!</span></span></p>
<p><span class="koboSpan" id="kobo.675.1">Depending on how large your </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">DbContext</span></strong><span class="koboSpan" id="kobo.677.1"> is, every time a new instance is created, the creation of the DbContext takes time. </span><span class="koboSpan" id="kobo.677.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">.AddDbContextPool&lt;&gt;()</span></strong><span class="koboSpan" id="kobo.679.1"> method gives us the </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.680.1">performance</span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.681.1"> boost </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">we need.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.683.1">Entity Framework Core DbContext pooling benchmarks</span></p>
<p class="callout"><span class="koboSpan" id="kobo.684.1">Microsoft performed benchmarks with and without DbContext pooling. </span><span class="koboSpan" id="kobo.684.2">With DbContext pooling implemented, the performance increased by over 50%. </span><span class="koboSpan" id="kobo.684.3">Microsoft even included the source code to the benchmark code. </span><span class="koboSpan" id="kobo.684.4">The results can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">at </span></span><a href="https://learn.microsoft.com/en-us/ef/core/performance/advanced-performance-topics#benchmarks"><span class="No-Break"><span class="koboSpan" id="kobo.686.1">https://learn.microsoft.com/en-us/ef/core/performance/advanced-performance-topics#benchmarks</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.687.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.688.1">Identifying slow queries</span></h3>
<p><span class="koboSpan" id="kobo.689.1">The ability to identify </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.690.1">slow queries is sometimes difficult, since we are in Visual Studio and may not see what’s happening behind the scenes when sending a query to the database. </span><span class="koboSpan" id="kobo.690.2">So, how do we find these slow queries in our </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">web application?</span></span></p>
<p><span class="koboSpan" id="kobo.692.1">In the DbContext’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">OnConfiguring()</span></strong><span class="koboSpan" id="kobo.694.1"> method, add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">.LogTo()</span></strong><span class="koboSpan" id="kobo.696.1"> method to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">DbContextOptionsBuilder</span></strong><span class="koboSpan" id="kobo.698.1"> and you’ll see every database call and the time it took to </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">execute it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.700.1">
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    if (!optionsBuilder.IsConfigured)
    {
        var connString = _configuration.GetConnectionString(«DefaultConnection»);
        if (!string.IsNullOrEmpty(connString))
        {
            optionsBuilder.UseSqlServer(connString)
                .LogTo(Console.WriteLine, LogLevel.Information);
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.701.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">.LogTo()</span></strong><span class="koboSpan" id="kobo.703.1"> method </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.704.1">will produce the following </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">log entry:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.706.1">
Microsoft.EntityFrameworkCore.Database.Command: Information: Executed DbCommand (46ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
SELECT [a].[ID], [a].[LocationID], [a].[Name], [l].[ID], [l].[Name]
FROM [Attractions] AS [a]
INNER JOIN [Locations] AS [l] ON [a].[LocationID] = [l].[ID]</span></pre> <p><span class="koboSpan" id="kobo.707.1">For this particular query, it took </span><em class="italic"><span class="koboSpan" id="kobo.708.1">46ms</span></em><span class="koboSpan" id="kobo.709.1"> to execute. </span><span class="koboSpan" id="kobo.709.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">.LogTo()</span></strong><span class="koboSpan" id="kobo.711.1"> method provides an easy way to identify whether a query is performing to the best of its ability or is a likely candidate </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">for optimization.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">In this section, we learned some bite-sized optimizations along with a new middleware to shrink your HTML, how to speed up Entity Framework Core using DbContext pooling, and how to locate slow queries throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">In the next</span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.716.1"> section, we’ll focus on the various types of caching and how each one is different and can work collectively to improve the overall performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">your application.</span></span></p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.718.1">Understanding caching</span></h2>
<p><span class="koboSpan" id="kobo.719.1">Since caching is extremely </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.720.1">important to a web application, it’s only fitting it gets its own </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.721.1">section to cover all of the possible types of caching available. </span><span class="koboSpan" id="kobo.721.2">In the industry, there’s a saying: “the best database call is no call at all.” </span><span class="koboSpan" id="kobo.721.3">They’re likely referring </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">to caching.</span></span></p>
<p><span class="koboSpan" id="kobo.723.1">In this section, we’ll learn the different types of caching that include response and output caching, data caching, and caching </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">static files.</span></span></p>
<h3><span class="koboSpan" id="kobo.725.1">Using response caching and output caching</span></h3>
<p><span class="koboSpan" id="kobo.726.1">Whether </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.727.1">making a </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.728.1">call to a web page or an API, the ability to cache data is extremely important. </span><span class="koboSpan" id="kobo.728.2">Implementing a simple caching strategy to immediately return data </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">is efficient.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">ResponseCaching</span></strong><span class="koboSpan" id="kobo.731.1"> is a middleware extension that is best suited for GET or HEAD API requests from a client. </span><span class="koboSpan" id="kobo.731.2">When utilizing response caching, .NET uses the standard HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">caching semantics.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.733.1">RFC 9111: HTTP caching</span></p>
<p class="callout"><span class="koboSpan" id="kobo.734.1">For additional </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.735.1">material on HTTP caching, navigate </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">to </span></span><a href="https://www.rfc-editor.org/rfc/rfc9111"><span class="No-Break"><span class="koboSpan" id="kobo.737.1">https://www.rfc-editor.org/rfc/rfc9111</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.738.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.739.1">To add response caching, the builder must add it to the services and the application (app) must “use” it, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.741.1">
Var builder = WebApplication.CreateBuilder(args);
builder.Services.AddResponseCaching();
var app = builder.Build();
app.UseHttpsRedirection();
</span><strong class="bold"><span class="koboSpan" id="kobo.742.1">// If using Cors, UseCors must be placed before the UseResponseCaching</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.743.1">// app.UseCors();</span></strong><span class="koboSpan" id="kobo.744.1">
app.UseResponseCaching();</span></pre> <p><span class="koboSpan" id="kobo.745.1">Once in place, any</span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.746.1"> API</span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.747.1"> call would provide the cached data from the browser </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">by default.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.749.1">ResponseCaching middleware</span></p>
<p class="callout"><span class="koboSpan" id="kobo.750.1">For more </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.751.1">details on </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">ResponseCaching</span></strong><span class="koboSpan" id="kobo.753.1">, navigate </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">to </span></span><a href="https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware"><span class="No-Break"><span class="koboSpan" id="kobo.755.1">https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.756.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.757.1">However, for most web UIs such as Razor Pages, </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">OutputCaching</span></strong><span class="koboSpan" id="kobo.759.1"> is the better option because browsers set request headers to prevent caching. </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">OutputCaching</span></strong><span class="koboSpan" id="kobo.761.1">’s configuration is similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">ResponseCaching</span></strong><span class="koboSpan" id="kobo.763.1">, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.765.1">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddOutputCache();
</span><strong class="bold"><span class="koboSpan" id="kobo.766.1">// Add services to the container.</span></strong><span class="koboSpan" id="kobo.767.1">
builder.Services.AddRazorPages();
var app = builder.Build();
</span><strong class="bold"><span class="koboSpan" id="kobo.768.1">// Configure the HTTP request pipeline.</span></strong><span class="koboSpan" id="kobo.769.1">
If (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    // The default HSTS value is 30 days. </span><span class="koboSpan" id="kobo.769.2">You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
</span><span class="koboSpan" id="kobo.769.3">    App.UseHsts();
}
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
</span><strong class="bold"><span class="koboSpan" id="kobo.770.1">// if using Cors, UseOutputCache must be placed AFTER useCors().</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.771.1">//app.UseCors();</span></strong><span class="koboSpan" id="kobo.772.1">
app.UseOutputCache();</span></pre> <p><span class="koboSpan" id="kobo.773.1">In the</span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.774.1"> middleware </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.775.1">configuration, we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">AddOutputCache()</span></strong><span class="koboSpan" id="kobo.777.1"> method to the services collection and place the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">UseOutputCache()</span></strong><span class="koboSpan" id="kobo.779.1"> method after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">UseRouting()</span></strong><span class="koboSpan" id="kobo.781.1"> method and, if it’s used, after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">UseCors()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.783.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.784.1">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">OutputCache</span></strong><span class="koboSpan" id="kobo.786.1"> is added to the middleware, this doesn’t mean we are automatically caching our UI pages. </span><span class="koboSpan" id="kobo.786.2">We also need to identify which pages are cached by adding an </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">[OutputCache]</span></strong><span class="koboSpan" id="kobo.788.1"> attribute to the Razor </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">Page class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.790.1">
[OutputCache]
public class IndexModel : PageModel
{
    private readonly ILogger&lt;IndexModel&gt; _logger;
    public IndexModel(ILogger&lt;IndexModel&gt; logger)
    {
        _logger = logger;
    }
    public void OnGet() { }
}</span></pre> <p><span class="koboSpan" id="kobo.791.1">If no parameters are defined in the attribute, the default policy for caching pages is </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.793.1">HTTP 200 status codes </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">are cached</span></span></li>
<li><span class="koboSpan" id="kobo.795.1">HTTP GET or HEAD requests </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">are cached</span></span></li>
<li><span class="koboSpan" id="kobo.797.1">Responses where cookies are set are </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.798.1">not</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.799.1"> cached</span></span></li>
<li><span class="koboSpan" id="kobo.800.1">Responses to authenticated requests are </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.801.1">not</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.802.1"> cached</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.803.1">Response caching is meant for caching on the client side or through the browser and output caching is cached on the server. </span><span class="koboSpan" id="kobo.803.2">If two users access the same page from two different browsers, response caching won’t help since each browser will cache the page in each browser. </span><span class="koboSpan" id="kobo.803.3">However, if </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.804.1">output caching was </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.805.1">implemented, this would cache the page on the server and quickly deliver the page to </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">both users.</span></span></p>
<p><span class="koboSpan" id="kobo.807.1">Caching your pages gives users a better experience when coupled with data caching, which we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">discuss next.</span></span></p>
<h3><span class="koboSpan" id="kobo.809.1">Implementing data caching</span></h3>
<p><span class="koboSpan" id="kobo.810.1">When a user visits a </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.811.1">website, they are shown a certain amount of data based on who they are. </span><span class="koboSpan" id="kobo.811.2">For example, when the first user visits a blog, they could be presented with the same data as the next visitor to the site. </span><span class="koboSpan" id="kobo.811.3">If the data doesn’t change that often, it doesn’t make sense to travel all the way back to the database to retrieve the same data again. </span><span class="koboSpan" id="kobo.811.4">Data caching helps us solve this problem. </span><span class="koboSpan" id="kobo.811.5">Data caching is taking commonly used data and storing it for a period </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">of time.</span></span></p>
<p><span class="koboSpan" id="kobo.813.1">Let’s look at an example to show the approach. </span><span class="koboSpan" id="kobo.813.2">Since we’re using Entity Framework Core, we’ll have an existing service (</span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">CoffeeService</span></strong><span class="koboSpan" id="kobo.815.1">) containing a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">.GetAll()</span></strong><span class="koboSpan" id="kobo.817.1"> method returning all of the coffees. </span><span class="koboSpan" id="kobo.817.2">We can wrap a new caching class around the service called </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">CacheCoffeeService</span></strong><span class="koboSpan" id="kobo.819.1">, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.821.1">
public class CacheCoffeeService : CoffeeService, ICachedCoffeeService
{
    private const string keyCoffeeList = «EntireCoffeeList»;
    private readonly IMemoryCache _cache;
    public CacheCoffeeService(IBucksDbContext dbContext,
        IMemoryCache cache)
        : base(dbContext)
    {
        _cache = cache;
    }
    public List&lt;Coffee&gt; GetAll(bool reload = false)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.822.1">// If we can't find it in the cache or want to reload...</span></strong><span class="koboSpan" id="kobo.823.1">
        if (!_cache.TryGetValue(keyCoffeeList, out List&lt;Coffee&gt;         coffees) || reload)
        {
            coffees = base.GetAll();
            _cache.Set(keyCoffeeList, coffees,
                new MemoryCacheEntryOptions()
                    .SetSlidingExpiration(TimeSpan.FromSeconds(60))                     // 1min
                    .SetAbsoluteExpiration(TimeSpan.FromSeconds(3600))                     // 6min
                    .SetPriority(CacheItemPriority.Normal)
            );
        }
        return coffees;
    }
}
public interface ICachedCoffeeService
{
    List&lt;Coffee&gt; GetAll(bool reload = false);
}</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">CacheCoffeeService</span></strong><span class="koboSpan" id="kobo.825.1"> inherits </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.826.1">from </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">CoffeeService</span></strong><span class="koboSpan" id="kobo.828.1"> and uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">ICachedCoffeeService</span></strong><span class="koboSpan" id="kobo.830.1"> interface. </span><span class="koboSpan" id="kobo.830.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">ICachedCoffeeService</span></strong><span class="koboSpan" id="kobo.832.1"> interface should be </span><em class="italic"><span class="koboSpan" id="kobo.833.1">exactly</span></em><span class="koboSpan" id="kobo.834.1"> the same as </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">CoffeeService</span></strong><span class="koboSpan" id="kobo.836.1"> except for one minor detail: a reload parameter added to each call with a default </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">of false.</span></span></p>
<p><span class="koboSpan" id="kobo.838.1">If we can’t find the entire list of coffees in the cache or we decide we want to reload the entire coffee list, we make a call to the base class (</span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">CoffeeService.GetAll())</span></strong><span class="koboSpan" id="kobo.840.1">), save the new list to the cache, and return the </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">entire list.</span></span></p>
<p><span class="koboSpan" id="kobo.842.1">By default, when you call </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">CachedCoffeeService.GetAll()</span></strong><span class="koboSpan" id="kobo.844.1"> with no parameters, you’ll get the cached version of the list. </span><span class="koboSpan" id="kobo.844.2">Pass a </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">true</span></strong><span class="koboSpan" id="kobo.846.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">.GetAll()</span></strong><span class="koboSpan" id="kobo.848.1"> and you’ll refresh your cache and receive the latest list </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">of coffees.</span></span></p>
<p><span class="koboSpan" id="kobo.850.1">This approach provides the benefit of combining a caching layer with standard data access, giving us the best of both worlds. </span><span class="koboSpan" id="kobo.850.2">When creating these data caches, the benefit is immediately obvious: gaining performance by using memory as your database, which is thread-safe. </span><span class="koboSpan" id="kobo.850.3">However, be wary of how many tables or how much data you are storing in </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">the cache.</span></span></p>
<p><span class="koboSpan" id="kobo.852.1">While it may seem like a trade-off using memory as a database, another caching option is using a distributed cache. </span><span class="koboSpan" id="kobo.852.2">A distributed cache is a cache shared across multiple app servers and provides the </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">following benefits:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.854.1">It is coherent/aware of requests </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">across servers</span></span></li>
<li><span class="koboSpan" id="kobo.856.1">If the power goes out for a server, the cached data </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">is persisted</span></span></li>
<li><span class="koboSpan" id="kobo.858.1">As mentioned, a distributed cache doesn’t use </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">local memory</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.860.1">Some of the best</span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.861.1"> candidates for data caching are small lookup tables (&lt; 100 records) and rarely-accessed </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">table data.</span></span></p>
<h3><span class="koboSpan" id="kobo.863.1">Caching static files</span></h3>
<p><span class="koboSpan" id="kobo.864.1">With all of these</span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.865.1"> static files such as images, CSS, and JavaScript available to our web application, you’d think there would be a way to cache these files </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.867.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">.UseStaticFiles()</span></strong><span class="koboSpan" id="kobo.869.1"> method, there is a context parameter containing an </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">HttpContext</span></strong><span class="koboSpan" id="kobo.871.1">, so we can use the response object to change the cache-control headers for our </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">static files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.873.1">
app.UseStaticFiles(new StaticFileOptions
{
    OnPrepareResponse = ctx =&gt;
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.874.1">// Cached for 24 hours.</span></strong><span class="koboSpan" id="kobo.875.1">
        var response = ctx.Context.Response;
        var duration = 60 * 60 * 24; // 24h duration.
</span><span class="koboSpan" id="kobo.875.2">        response.Headers[HeaderNames.CacheControl] =
        "public,max-age="+duration;
    }
});</span></pre> <p><span class="koboSpan" id="kobo.876.1">The preceding code takes our static files middleware component and allows a </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">StaticFileOptions</span></strong><span class="koboSpan" id="kobo.878.1"> instance, which also has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">OnPrepareResponse</span></strong><span class="koboSpan" id="kobo.880.1"> event available to us. </span><span class="koboSpan" id="kobo.880.2">For our cache duration, we set every static file header’s cache duration to </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">24 hours.</span></span></p>
<p><span class="koboSpan" id="kobo.882.1">If we wanted to </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.883.1">disable caching, we would modify the response to change the </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">following headers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.885.1">
app.UseStaticFiles(new StaticFileOptions
{
    OnPrepareResponse = ctx =&gt;
    {
        var response = ctx.Context.Response;
        </span><strong class="bold"><span class="koboSpan" id="kobo.886.1">// disable all caching</span></strong><span class="koboSpan" id="kobo.887.1">
        response.Headers[HeaderNames.CacheControl] = "no-cache,             no-store";
        response.Headers[HeaderNames.Pragma] = "no-cache";
        response.Headers[HeaderNames.Expires] = "-1";
    }
});</span></pre> <p><span class="koboSpan" id="kobo.888.1">The preceding code sample disables caching for every </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">static file.</span></span></p>
<p><span class="koboSpan" id="kobo.890.1">Again, while these files are cached on the server’s local memory, keep in mind that when the power goes down, so does </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">the cache.</span></span></p>
<p><span class="koboSpan" id="kobo.892.1">If you wanted to cache a certain folder or file type, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">ctx</span></strong><span class="koboSpan" id="kobo.894.1"> parameter contains not only a </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">Context</span></strong><span class="koboSpan" id="kobo.896.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">HttpContext</span></strong><span class="koboSpan" id="kobo.898.1"> type, but a </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">File</span></strong><span class="koboSpan" id="kobo.900.1"> property containing an </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">IFileInfo</span></strong><span class="koboSpan" id="kobo.902.1"> type</span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.903.1"> that includes </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">FileInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.905.1"> data.</span></span></p>
<h1 id="_idParaDest-231"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.906.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.907.1">While we covered a lot in this chapter, there are additional ways to achieve performance in web applications using more advanced techniques. </span><span class="koboSpan" id="kobo.907.2">The methods covered in this chapter are the best approaches for achieving performance in ASP.NET web applications. </span><span class="koboSpan" id="kobo.907.3">More than ever, performance is now considered one of the more important features in web applications, since it’s now usually tied to a </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">company’s finances.</span></span></p>
<p><span class="koboSpan" id="kobo.909.1">In this chapter, we first learned why performance matters by showing the effects of a slow website, how minor adjustments can produce large dividends, and how search engines reward websites for </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">performance improvements.</span></span></p>
<p><span class="koboSpan" id="kobo.911.1">We learned how to create baselines to identify possible bottlenecks using performance tools to analyze the client and server-side code with </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">various tools.</span></span></p>
<p><span class="koboSpan" id="kobo.913.1">Then, we learned about client-side techniques to optimize images, using CDNs to improve the loading of static content, and how to minimize your requests to lower latency issues. </span><span class="koboSpan" id="kobo.913.2">We also examined some quick tips such as placing scripts at the bottom and styles at the top, reviewing Google’s Core Web Vitals to understand how they gauge website performance, and using HTML instead of JavaScript where </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">it’s relevant.</span></span></p>
<p><span class="koboSpan" id="kobo.915.1">Finally, we focused on the server side by reviewing some small, immediate optimizations along with improving performance by optimizing HTML before it’s sent back to the client. </span><span class="koboSpan" id="kobo.915.2">From there, we learned how to speed up Entity Framework Core by adding DbContext pooling and identifying slow queries. </span><span class="koboSpan" id="kobo.915.3">The final piece to our performance chapter was implementing caching, which included learning about response caching, output caching, data caching, and how to cache </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">static files.</span></span></p>
<p><span class="koboSpan" id="kobo.917.1">In the appendix, we’ll examine some programming guidelines, along with what ASP.NET 8 projects look </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">like nowadays.</span></span></p>
</div>
</body></html>