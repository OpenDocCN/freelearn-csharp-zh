<html><head></head><body>
		<div id="_idContainer077">
			<h1 id="_idParaDest-138" class="chapter-number"><a id="_idTextAnchor137"/>6</h1>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Microsoft Azure for Hosting Applications</h1>
			<p>After creating Docker images with the previous chapters, and running the complete application using Docker containers locally, let’s move over to run the solution with <span class="No-Break">Microsoft Azure.</span></p>
			<p>In this chapter, you’ll learn how to push Docker images to an Azure container registry, run Docker containers with Azure Container Apps, access a database using Azure Cosmos DB, and configure environment variables and secrets with Azure <span class="No-Break">Container Apps.</span></p>
			<p>Using Bicep scripts, you learn how to create multiple Azure resources <span class="No-Break">at once.</span></p>
			<p>In this chapter, you’ll learn about the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Experiencing <span class="No-Break">Microsoft Azure</span></li>
				<li>Creating <span class="No-Break">Azure resources</span></li>
				<li>Creating an Azure <span class="No-Break">Cosmos database</span></li>
				<li>Pushing <a id="_idIndexMarker331"/>images to the <strong class="bold">Azure Container Registry</strong> (<span class="No-Break"><strong class="bold">ACR</strong></span><span class="No-Break">) instance</span></li>
				<li>Creating Azure <span class="No-Break">container apps</span></li>
				<li>Creating <a id="_idIndexMarker332"/>Azure resources using .NET Aspire and the <strong class="bold">Azure Developer </strong><span class="No-Break"><strong class="bold">CLI</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">azd</strong></span><span class="No-Break">)</span></li>
			</ul>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Technical requirements</h1>
			<p>For this chapter, you need to have Docker Desktop installed. You also need a Microsoft Azure subscription. You <a id="_idIndexMarker333"/>can activate Microsoft Azure for free at <a href="https://azure.microsoft.com/free">https://azure.microsoft.com/free</a>, which gives you an amount of about USD 200, Azure credits that are available for the first 30 days, and several services that can be used for free for the <span class="No-Break">time after.</span></p>
			<p>What many developers miss: if you have a Visual Studio Professional or Enterprise subscription, you also have a free amount of Azure resources every month. You just need to <a id="_idIndexMarker334"/>activate this with your Visual Studio <span class="No-Break">subscription: </span><a href="https://visualstudio.microsoft.com/subscriptions/"><span class="No-Break">https://visualstudio.microsoft.com/subscriptions/</span></a><span class="No-Break">.</span></p>
			<p>To work through the samples of this chapter, besides Docker Desktop, the Azure CLI and <strong class="source-inline">azd</strong> <span class="No-Break">are needed.</span></p>
			<p>To create and manage resources, install the Azure CLI <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">azd</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
winget install microsoft.azureCLI
winget install microsoft.azd</pre>
			<p>These tools <a id="_idIndexMarker335"/>are available on Mac and Linux as well. To install the Azure CLI on different platforms, see <a href="https://learn.microsoft.com/cli/azure/install-azure-cli">https://learn.microsoft.com/cli/azure/install-azure-cli</a>, and for <strong class="source-inline">azd</strong>, <span class="No-Break">see </span><a href="https://learn.microsoft.com/azure/developer/azure-developer-cli/install-azd"><span class="No-Break">https://learn.microsoft.com/azure/developer/azure-developer-cli/install-azd</span></a><span class="No-Break">.</span></p>
			<p>An easy way <a id="_idIndexMarker336"/>to use the Azure Cloud Shell is from a web browser. As you log in to the Azure portal at <a href="https://portal.azure.com">https://portal.azure.com</a> using your Microsoft Azure account, on the top button bar, you’ll see an icon for <em class="italic">Cloud Shell</em>. Clicking on this button, a terminal opens. Here, the Azure CLI is already installed – along with many other tools such as <strong class="source-inline">wget</strong> to download files, <strong class="source-inline">git</strong> to work with repositories, <strong class="source-inline">docker</strong>, the .NET CLI, and more. You can also use a Visual Studio Code editor (just run <strong class="source-inline">code</strong> from the terminal) to edit files. All the files you create and change are persisted within an Azure Storage account that is automatically created when you start the Cloud Shell. For a <a id="_idIndexMarker337"/>fullscreen Cloud Shell, you can <span class="No-Break">open </span><a href="https://shell.azure.com"><span class="No-Break">https://shell.azure.com</span></a><span class="No-Break">.</span></p>
			<p>The code for this chapter can be found in the following GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure"><span class="No-Break">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</span></a><span class="No-Break">.</span></p>
			<p>In the <strong class="source-inline">ch06</strong> folder, these are the <span class="No-Break">important projects:</span></p>
			<ul>
				<li><strong class="source-inline">Codebreaker.GameAPIs</strong> – The <strong class="source-inline">gamesAPI</strong> project we used in the previous chapter. There’s one change: instead of including the projects with the database access code and the models, NuGet packages <span class="No-Break">are referenced.</span></li>
				<li><strong class="source-inline">Codebreaker.Bot</strong> – The bot service calling the <span class="No-Break">game APIs.</span></li>
				<li><strong class="source-inline">Codebreaker.AppHost</strong> – This project contains important changes in this chapter to define the app model with <span class="No-Break">Azure resources.</span></li>
				<li><strong class="source-inline">Codebreaker.ServiceDefaults</strong> – This project is unchanged in <span class="No-Break">this chapter.</span></li>
			</ul>
			<p>You can start with the results from the previous chapter to work on your own through <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Experiencing Microsoft Azure</h1>
			<p>Microsoft Azure <a id="_idIndexMarker338"/>offers cloud services from many different <a id="_idIndexMarker339"/>categories. You can create <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>), which belong to the <strong class="bold">Infrastructure as a Service</strong> (<strong class="bold">IaaS</strong>) category, where you <a id="_idIndexMarker340"/>are in control of the machines but also need to manage them as you do in on-premises environments, up to ready-to-use software <a id="_idIndexMarker341"/>such as Office 365 from the <strong class="bold">Software as a Service</strong> (<strong class="bold">SaaS</strong>) category. Something <a id="_idIndexMarker342"/>in between is <strong class="bold">Platform as a Service</strong> (<strong class="bold">PaaS</strong>), where you don’t have full control over the VMs but instead get many functionalities out of <span class="No-Break">the box.</span></p>
			<p>The focus here is on PaaS services. With the PaaS category, there’s also a category named <strong class="bold">serverless</strong>. This category allows for easy scaling, starting from zero, where no or low costs are associated, up to a maximum amount of automatic scaling based on the needs. Many Azure services have offerings in <span class="No-Break">this category.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Cost</h2>
			<p>When <a id="_idIndexMarker343"/>creating resources in a cloud environment, there’s always a question about the cost. Many are afraid of the need to pay unexpected amounts, but this fear is not necessary. Some subscriptions (such as a Visual Studio subscription) are limited to the amount available every month. If this amount is reached, resources are automatically stopped (unless you explicitly allow the cost to go above the limits), so no additional <span class="No-Break">cost applies.</span></p>
			<p>With subscriptions and also just with resource groups, you can specify a budget to specify the <a id="_idIndexMarker344"/>amount that’s planned to be spent. To do this, open the Azure portal and select a resource group. Within a resource group, you’ll see the <strong class="bold">Cost Management</strong> category with the <strong class="bold">Budgets</strong> option. By creating a budget (see <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.1</em>), you can define limits month by month. Before this limit is reached, you specify alerts where you can be informed. With an alert, you can specify to receive a notification via email, SMS, push, or voice notification, and in addition to that, you can define an action that should be invoked to call an Azure function, a logic app, an Automation runbook, or other Azure resources where custom functionality can be implemented. Based on usage and requirements, stopping services could be <span class="No-Break">an option:</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B21217_06_01.jpg" alt="Figure 6.1 – Specifying budgets"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Specifying budgets</p>
			<p>To get price <a id="_idIndexMarker345"/>information about services, at <a href="https://azure.microsoft.com">https://azure.microsoft.com</a>, you can select <strong class="bold">Azure pricing</strong>, search for products, or select a product from a category to get details of different offerings available. You will also see a pricing calculator where you select multiple products and get complete price information based on <span class="No-Break">selections made.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>Naming conventions and more</h2>
			<p>When creating resources within Azure, we should think about some important foundations <a id="_idIndexMarker346"/>to easily find resources based on the needs of IT but also based on the needs of business organizations. Which resources are for production, and which are for testing environments? Which resources are used by different organizations in the company? Which resources are used by one product? What are the resources potentially being impacted by a technical issue? For all these scenarios, these <span class="No-Break">features help:</span></p>
			<ul>
				<li>Every resource <a id="_idIndexMarker347"/>needs to be put into one <strong class="bold">resource group</strong>. For the <strong class="source-inline">codebreaker</strong> solution, resource groups will be created for the test and <span class="No-Break">production environments.</span></li>
				<li>It should also <a id="_idIndexMarker348"/>be easy to find multiple resources across resource groups. <strong class="bold">Resource tags</strong> can be <span class="No-Break">used here.</span></li>
				<li>Define a convention for how you name your resources. The number of resources will grow over time! You might create multiple instances for scaling, run the same services around the globe in different regions for better latency, run services in different environments… there are many reasons the number of resources grows. To deal with this, a good naming strategy used from the start can help <span class="No-Break">a lot!</span></li>
			</ul>
			<p>With the <strong class="source-inline">codebreaker</strong> application, we can use <strong class="source-inline">rg-codebreaker-dev</strong>, <strong class="source-inline">rg-codebreaker-test</strong>, and <strong class="source-inline">rg-codebreaker-prod</strong> resource groups for <em class="italic">development</em>, <em class="italic">test</em>, and <span class="No-Break"><em class="italic">production</em></span><span class="No-Break"> environments.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Besides separating the environments with different resource groups, it’s a good practice to separate the development and production environments into different subscriptions. As there’s an Azure subscription with some free amount available with a Visual Studio subscription, this subscription can be used with the <span class="No-Break">development environment.</span></p>
			<p>Some resources are used across different resource groups. For example, you might use a central Azure DNS resource. You might also share resources across different applications. You can share an Azure app service that hosts many small websites. With every Azure resource, you can add custom tags and search for resources using different tags and their values. For example, you can specify a tag named <strong class="source-inline">cc</strong> (for cost center), and the value specifies the <span class="No-Break">cost center.</span></p>
			<p>To define a <a id="_idIndexMarker349"/>naming convention for resources, Microsoft not only has a guideline (available at <a href="https://learn.microsoft.com/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming">https://learn.microsoft.com/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming</a>), but also an Excel template you can use (available at https://raw.githubusercontent.com/microsoft/CloudAdoptionFramework/master/ready/naming-and-tagging-conventions-tracking-template.xlsx), and even a Blazor application that you can host on-premises (or in the cloud) for your administrators to manage naming conventions with a simple user <span class="No-Break">interface: </span><span class="No-Break">https://github.com/mspnp/AzureNamingTool</span><span class="No-Break">.</span></p>
			<p>Components that can be part of the name of resources include <span class="No-Break">the following:</span></p>
			<ul>
				<li>The <em class="italic">resource type</em>. Microsoft has a list of proposed abbreviations; for example, <strong class="source-inline">rg</strong> for resource group, <strong class="source-inline">cosmos</strong> for an Azure Cosmos DB database, <strong class="source-inline">cr</strong> for ACR, <strong class="source-inline">ca</strong> for container apps, and <strong class="source-inline">cae</strong> for Container <span class="No-Break">Apps environments.</span></li>
				<li>The project, application, or service name. We’ll use <strong class="source-inline">codebreaker</strong> for the <span class="No-Break">application name.</span></li>
				<li>The environment where the resource is used; for example, <strong class="source-inline">prod</strong> for production, <strong class="source-inline">dev</strong> for development, and <strong class="source-inline">test</strong> <span class="No-Break">for testing.</span></li>
				<li>The location of the Azure resource; for example, <strong class="source-inline">eastus2</strong> for the second East US region, and <strong class="source-inline">westeu</strong> for West Europe. Creating resources in multiple regions can be useful for failover scenarios, for better performance for customers around the globe, and because of <span class="No-Break">data regulations.</span></li>
			</ul>
			<p>Now, we are ready to create <span class="No-Break">Azure resources.</span></p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Creating Azure resources</h1>
			<p>Using <a id="_idIndexMarker350"/>Microsoft Azure, there are different ways to create and manage Azure resources. Azure resources are accessible via a REST API. You can send <strong class="source-inline">GET</strong> requests to read information about resources and <strong class="source-inline">POST</strong> requests to create new resources, but of course, there’s an easier way to do it. The Azure portal (<a href="https://portal.azure.com">https://portal.azure.com</a>) is a great way to learn and see the different options you have. To automatically create Azure resources, you can use the Azure CLI, PowerShell scripts, and many more options to use. In this book, we’ll use the Azure portal, Bicep scripts, .NET Aspire, and <strong class="source-inline">azd</strong>. Bicep scripts give you a simple syntax from Microsoft to easily recreate Azure resources. .NET Aspire offers to define Azure resources using .NET code and directly create <span class="No-Break">the resources.</span></p>
			<p>Within company environments, there are different ways Azure resources are created and how teams are organized. .NET Aspire, together with <strong class="source-inline">azd</strong>, offers great functionality for creating Azure <a id="_idIndexMarker351"/>resources, but this might not (yet?) fit into your environment. You can also decide to use parts of .NET Aspire that fit into your company environment, or use all that .NET Aspire and <strong class="source-inline">azd</strong> offer. The second option is the easiest one. To better understand the options, and for you to map it into your environment, we’ll start using the Azure CLI and the Azure portal. With this, you can easily see what options a resource offers for configuration. Later in this chapter, we’ll use .NET Aspire and <strong class="source-inline">azd</strong>. Specifying Azure resources with .NET code just needs a few statements to create all the resources needed with <span class="No-Break">the solution.</span></p>
			<p>What are the resources we create? In this section, we’ll do <span class="No-Break">the following:</span></p>
			<ol>
				<li>Create a resource group that groups all Azure <span class="No-Break">resources together.</span></li>
				<li>Create an Azure Cosmos DB database that is added to the previously created resource group and used by the EF Core context we created in <a href="B21217_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">.</span></li>
				<li>Create an Azure container registry to publish the Docker images we created in <a href="B21217_05.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">.</span></li>
				<li>Create two Azure container apps to run the <strong class="source-inline">gamesAPI</strong> service and the <span class="No-Break">bot service.</span></li>
			</ol>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>Creating a resource group</h2>
			<p>Resource <a id="_idIndexMarker352"/>groups are used to manage Azure resources together. With a resource group, you can specify permissions for who is allowed to create or manage resources within the resource group. From a price standpoint, you easily can see the cost of the complete resource group and which resources of this resource group were responsible for which cost. You can also delete a resource group, which deletes all resources within <span class="No-Break">the group.</span></p>
			<p>To create a resource group, let’s use the <span class="No-Break">Azure CLI.</span></p>
			<p>To log in to Azure, use the <span class="No-Break">following command:</span></p>
			<pre class="console">
az login</pre>
			<p>This command opens the default browser to authenticate <span class="No-Break">the user.</span></p>
			<p>If you have multiple Azure subscriptions, you can check these with <strong class="source-inline">az account list</strong>. The current active subscription where you create resources is shown with <strong class="source-inline">az </strong><span class="No-Break"><strong class="source-inline">account show</strong></span><span class="No-Break">.</span></p>
			<p>To create <a id="_idIndexMarker353"/>a resource group, use the <strong class="source-inline">az </strong><span class="No-Break"><strong class="source-inline">group</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
az group create -l westeurope -n rg-codebreaker-test</pre>
			<p>The <strong class="source-inline">create</strong> subcommand creates a resource group. With <strong class="source-inline">-l</strong>, we specify the location of this Azure resource. Here, I’m using <strong class="source-inline">westeurope</strong> because this region is near my location. With the <strong class="source-inline">-n</strong> value, the name of the resource group <span class="No-Break">is set.</span></p>
			<p>The location of the resource group is independent of the location of the resources within the resource group. Resources within the resource group can have other regions. A resource group is just metadata. The location for the resource group specifies the primary location for the resource group. In a fatal case where the location is not available, you cannot make changes to the <span class="No-Break">resource group.</span></p>
			<p>To get the regions available with your subscription, you can use <strong class="source-inline">az account list-locations -</strong><span class="No-Break"><strong class="source-inline">o table</strong></span><span class="No-Break">.</span></p>
			<p>After the resource group is created, we can create resources within this <span class="No-Break">resource group.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>Creating an Azure Cosmos DB account</h2>
			<p>In <a href="B21217_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we used the Azure Cosmos DB emulator to store games and moves. Now, let’s change <a id="_idIndexMarker354"/>this to the real database in the Azure cloud. First, we’ll use the Azure portal to create an Azure Cosmos <span class="No-Break">DB account.</span></p>
			<p>Within the Azure portal, by clicking on <strong class="bold">Create a Resource</strong>, you can select <strong class="bold">Databases</strong> from a list of categories, or just enter a search term, <strong class="source-inline">Azure Cosmos DB</strong>. When you click <strong class="bold">Create</strong> with the Azure Cosmos DB resource, this does not immediately create the resource. Instead, you need to do some <span class="No-Break">configuration beforehand.</span></p>
			<p>With the <a id="_idIndexMarker355"/>Azure Cosmos DB resource, you first need to select one of the APIs available. Read back to <a href="B21217_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> for the different APIs available and what they offer. Now, select <strong class="bold">Azure Cosmos DB for NoSQL</strong>, and click the <strong class="bold">Create</strong> button. This opens the configuration, as shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B21217_06_02.jpg" alt="Figure 6.2 – Creating an Azure Cosmos DB account"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Creating an Azure Cosmos DB account</p>
			<p>You have some pages for configuration before you can click the <strong class="bold">Create</strong> button one last time. With the basic configurations, you need to specify the subscription in which the resource will be created, the resource group name, the name of the account (I used <strong class="source-inline">cosmos-codebreaker-test</strong> for the test environment, but be aware this name needs to be globally unique), and the capacity. Azure Cosmos DB offers one free tier with a subscription. In case you haven’t used this yet with your subscription, you can choose this <a id="_idIndexMarker356"/>option. This gives you 1,000 <strong class="bold">request units per second</strong> (<strong class="bold">RU/s</strong>) and 25 GB of storage for free. Using provisioned throughput, you define a RU/s limit by database or by database container, at least 400 RU/s. The serverless <a id="_idIndexMarker357"/>option starts with a higher minimum limit but automatically scales to the RU/s needed. With serverless, you need to be aware of some limits. With serverless, the maximum database container size is 1 TB; there’s no limit with the provisioned configuration. Serverless also doesn’t support geo-distribution, which is available with the <span class="No-Break">provisioned setting.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Creating an Azure Cosmos DB account registers a DNS name, thus the name needs to be globally unique. For your account, you can add a number following the account name, and check by clicking <strong class="bold">Review + create</strong> if your selected name <span class="No-Break">is available.</span></p>
			<p>With the next configurations, you can configure the global distribution of a database, networking, a policy to automatically create backups, encryption with a service-managed key or a customer-managed key, and tags (which are available with every resource). You can use the default values with all the settings other than the basic configuration. Upon clicking on the <strong class="bold">Review + create</strong> button, final checks are made, and you can click the final <strong class="bold">Create</strong> button. Now, you just need to wait for a few minutes until the database account <span class="No-Break">is created.</span></p>
			<p>Using the Azure CLI, you can use the <strong class="source-inline">az cosmosdb </strong><span class="No-Break"><strong class="source-inline">create</strong></span><span class="No-Break"> command.</span></p>
			<p>The database account is created! Next, we’ll create an Azure <span class="No-Break">container registry.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">In <a href="B21217_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we not only created a library to write to Azure Cosmos DB but also to SQL Server. With Microsoft Azure, you can also configure Azure SQL Database. Just be aware of the low <a id="_idIndexMarker358"/>cost in the development environment; select a <strong class="bold">Database Transaction Unit</strong> (<strong class="bold">DTU</strong>) tier instead of the vCore tier. With 5 Basic DTUs, there’s just a cost lower than USD 5, for a month for 2 GB storage (at the time of this writing) compared to USD 400,- where a VM with 2 vCores <span class="No-Break">is allocated.</span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>Creating an Azure container registry</h2>
			<p>In the previous chapter, we created Docker images and used them locally. You can publish <a id="_idIndexMarker359"/>Docker images to the Docker hub, or any container <a id="_idIndexMarker360"/>registry. ACR offers a registry for Docker images that greatly integrates with <span class="No-Break">Microsoft Azure.</span></p>
			<p>While creating an ACR instance, three different tiers <span class="No-Break">are available:</span></p>
			<ul>
				<li><strong class="bold">Basic</strong>: For the purpose of the <strong class="source-inline">codebreaker</strong> application, the Basic tier (SKU) fits the <a id="_idIndexMarker361"/>purpose and is a lot cheaper than the other options. You just need to be aware of <span class="No-Break">the limits.</span></li>
				<li><strong class="bold">Standard</strong>: The Standard <a id="_idIndexMarker362"/>tier offers more storage (the Basic tier is limited to 10 GB storage) and <span class="No-Break">image throughput.</span></li>
				<li><strong class="bold">Premium</strong>: The Premium <a id="_idIndexMarker363"/>tier adds some features, such as geo-replication replicates images across different regions and private <span class="No-Break">access points.</span></li>
			</ul>
			<p><span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.3</em> shows how to create an ACR instance via the portal. Clicking on <strong class="bold">Create a resource</strong>, <strong class="bold">Container Registry</strong> is available in the <strong class="bold">Containers</strong> category. Instead, you can also enter <strong class="source-inline">Container Registry</strong> in the search box. Selecting the <strong class="bold">Azure services only</strong> checkbox doesn’t show the many <span class="No-Break">third-party offerings:</span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B21217_06_03.jpg" alt="Figure 6.3 – Creating a container registry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Creating a container registry</p>
			<p>With the <a id="_idIndexMarker364"/>configuration, we just need the <a id="_idIndexMarker365"/>name of the resource group, the name of the registry, the location, and the SKU. Availability zones, where the images are stored in different data centers in the same region, are only available with the Premium tier. Other configurations to change the networking and encryption require the Premium tier <span class="No-Break">as well.</span></p>
			<p>Filling out this form, after clicking <strong class="bold">Review + create</strong>, you still can verify all the options before clicking <strong class="bold">Create</strong> to create <span class="No-Break">the resources.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The name of the registry is a globally available DNS name (with the <strong class="source-inline">azurecr.io</strong> extension) and thus needs to be unique. Choose your own name where creating the resource succeeds with an <span class="No-Break">available name.</span></p>
			<p>We now <a id="_idIndexMarker366"/>have a database and a registry for container <a id="_idIndexMarker367"/>images running. With the first resources created, all we need to run the application in the cloud is a compute service where we can run the Docker images. We will use Azure <span class="No-Break">Container Apps.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>Creating an Azure Container Apps environment</h2>
			<p>Microsoft Azure has several compute offerings to run Docker containers. You can publish <a id="_idIndexMarker368"/>a Docker image <a id="_idIndexMarker369"/>to an <strong class="bold">Azure app service</strong>, and use a <a id="_idIndexMarker370"/>Windows or Linux server to run your APIs. Another option is <a id="_idIndexMarker371"/>to use <strong class="bold">Azure Container Instances</strong> (<strong class="bold">ACI</strong>), which allows you to host a group of Docker containers, including one frontend container (the API service) and multiple backend containers. While Azure app services offer automatic scaling to create multiple instances based on rules, this feature is not available with ACI. ACI is great with a fast startup – you spin up a VM where just the smaller Docker image needs to be uploaded, but it doesn’t offer orchestration and <span class="No-Break">scaling features.</span></p>
			<p>For full-blown <a id="_idIndexMarker372"/>orchestration and scaling of Docker containers, Azure offers <strong class="bold">Azure Kubernetes Service</strong> (<strong class="bold">AKS</strong>), where we can deploy and manage Docker images using the well-known Kubernetes tool, <strong class="source-inline">kubectl</strong>. To remove the complexity of Kubernetes, defining an Ingress controller is just a matter of changing <a id="_idIndexMarker373"/>some settings; <strong class="bold">Azure Container Apps</strong> instances are available. This service makes use of Kubernetes behind the scenes but removes a lot of <span class="No-Break">its complexity.</span></p>
			<p>Let’s get into creating an Azure <span class="No-Break">container app.</span></p>
			<h3>Creating a Log Analytics workspace</h3>
			<p>When <a id="_idIndexMarker374"/>creating an <a id="_idIndexMarker375"/>Azure container app, having space for logging is a good idea. With previous versions of Azure Container Apps, it was a requirement to have a <strong class="bold">Log Analytics workspace</strong>. This is no longer a requirement, as you can <a id="_idIndexMarker376"/>also use Azure Monitor to log to an Azure storage account, an Azure event hub, or a third-party monitoring solution. Azure Monitor can also be configured to route logs to <span class="No-Break">Log Analytics.</span></p>
			<p>A Log Analytics workspace is a storage unit for log data to analyze data and metrics. In <a href="B21217_10.xhtml#_idTextAnchor239"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Logging</em>, we’ll dive into logging and metrics with microservices, and make use of Log Analytics, Azure Monitor, and Application Insights to get information about <span class="No-Break">running services.</span></p>
			<p>To create a <a id="_idIndexMarker377"/>Log Analytics workspace, we will use the <span class="No-Break">Azure CLI:</span></p>
			<pre class="console">
az monitor log-analytics workspace create -g rg-codebreaker-test -n logs-codebreaker-test-westeu</pre>
			<p>Log <a id="_idIndexMarker378"/>Analytics belongs to Azure Monitor, thus the <strong class="source-inline">az monitor log-analytics</strong> command is used to create and manage Log Analytics. With the <strong class="source-inline">workspace create</strong> subcommand, a Log Analytics workspace is created. This command requires the resource group and the name of the workspace. If the location is not supplied with the command, the workspace uses the same location as the <span class="No-Break">resource group.</span></p>
			<h3>Creating a container app environment</h3>
			<p>Creating a container app environment uses a Kubernetes cluster behind the scenes. You can <a id="_idIndexMarker379"/>create this environment to create a Log Analytics workspace automatically. Using an existing <a id="_idIndexMarker380"/>workspace (we created one in the previous step), we need the customer ID and a key from the workspace. Get the customer ID using the <span class="No-Break">following command:</span></p>
			<pre class="console">
az monitor log-analytics workspace show -g rg-codebreaker-test -n logs-codebreaker-test-westeu --query customerId</pre>
			<p>Without supplying <strong class="source-inline">--query customerId</strong>, you get more complete information about the workspace, including the <strong class="source-inline">customerId</strong> value. Using the <strong class="source-inline">--query</strong> command, we can <a id="_idIndexMarker381"/>supply a <strong class="bold">JMESPath</strong> query. Check <a href="https://jmespath.org">https://jmespath.org</a> for more information on this query syntax. Using <strong class="source-inline">customerId</strong> with the query, just the unique identifier of this id (a GUID) is returned. Copy this GUID as well as the key from the next command as we’ll need these values when creating <span class="No-Break">the environment.</span></p>
			<p>This command returns keys to connect to the <span class="No-Break">log workspace:</span></p>
			<pre class="console">
az monitor log-analytics workspace get-shared-keys -g rg-codebreaker-test -n logs-codebreaker-test-westeu</pre>
			<p>The <a id="_idIndexMarker382"/>output returns primary and secondary shared keys. Copy the primary <span class="No-Break">shared key.</span></p>
			<p>Using <a id="_idIndexMarker383"/>the customer ID as well as the key from the Log Analytics workspace, we can create a container <span class="No-Break">app environment:</span></p>
			<pre class="console">
az containerapp env create -g rg-codebreaker-test -n cae-codebreaker-test-westeu --logs-workspace-id &lt;customer-id&gt; --logs-workspace-key &lt;logs-key&gt; --location westeurope</pre>
			<p>To create the environment, you need to specify the resource group, the name of the environment, information to connect log analytics, as well as the location of the newly created resource. This command does not use the location of the resource group if the location is not supplied. Be aware that this command might take several minutes. But think about how many minutes you would need to create a Kubernetes <span class="No-Break">cluster manually.</span></p>
			<h3>Creating a hello container app</h3>
			<p>After creating <a id="_idIndexMarker384"/>the environment, let’s create our first app <a id="_idIndexMarker385"/>within <span class="No-Break">this environment:</span></p>
			<pre class="console">
az containerapp create -n ca-hello-westeu -g rg-codebreaker-test --environment cae-codebreaker-test-westeu --image mcr.microsoft.com/azuredocs/containerapps-helloworld:latest --ingress external --target-port 80 --min-replicas 0 --max-replicas 2 --cpu 0.5 --memory 1.0Gi</pre>
			<p>Using the <strong class="source-inline">create</strong> command creates a new app. The name of this app is specified with the <strong class="source-inline">-n</strong> parameter. The environment is specified with the resource group (<strong class="source-inline">-g</strong>) and the <strong class="source-inline">--environment</strong> parameter. The image referenced with the <strong class="source-inline">--image</strong> parameter is a sample Docker image from Microsoft that hosts a web server with a static page. To access the web server running on port 80 within the container, the Ingress service is configured with the <strong class="source-inline">--ingress</strong> and <strong class="source-inline">--target-port</strong> parameters. Using the <strong class="source-inline">--min-replicas</strong> and <strong class="source-inline">--max-replicas</strong> parameters, scaling is defined to scale from 0 up to 2 instances. With 0 instances, the first user accessing the service needs to wait until the container is started. With the supplied configuration, the application scales up to 2 running containers. One container allocates 0.5 CPUs and 1.0 <span class="No-Break">Gi memory.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout"><em class="italic">Chapters 9</em> to <em class="italic">11</em> will give you information about scaling services. In <a href="B21217_09.xhtml#_idTextAnchor216"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, you’ll create load tests to stress-test services, in <a href="B21217_10.xhtml#_idTextAnchor239"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, we’ll use these load tests to monitor metrics information, and in <a href="B21217_11.xhtml#_idTextAnchor263"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, we’ll configure scaling with information learned in the previous <span class="No-Break">two chapters.</span></p>
			<p>When <a id="_idIndexMarker386"/>the app is created, a link for the app service is shown. You <a id="_idIndexMarker387"/>can also get the URL using <span class="No-Break">this command:</span></p>
			<pre class="console">
az containerapp show -n ca-hello-westeu -g rg-codebreaker-test --query properties.configuration.ingress.fqdn</pre>
			<p>The <strong class="source-inline">containerapp show</strong> command shows properties of the Azure container app. Using <a id="_idIndexMarker388"/>the <strong class="source-inline">properties.configuration.ingress.fqdn</strong> JMESPath query returns the <strong class="bold">fully qualified domain name</strong> (<strong class="bold">FQDN</strong>) of the Ingress service. Using the returned domain name with a prefixed <strong class="source-inline">https://</strong> instance shows the running application (see <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B21217_06_04.jpg" alt="Figure 6.4 – Accessing the hello Azure container app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Accessing the hello Azure container app</p>
			<p>Now, opening the <strong class="source-inline">rg-codebreaker-test</strong> resource group with the Azure portal, we can see <a id="_idIndexMarker389"/>the Azure Cosmos DB, ACR, and Azure Container <a id="_idIndexMarker390"/>Apps environments, the Log Analytics workspace, and the container app, as shown in <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.5</em>. Just check the options you have with the categories on the left side of the <strong class="bold">Resource group</strong> view. The <strong class="bold">Overview</strong> view shows the resources, as shown here. Clicking on <strong class="bold">Access control</strong>, you can configure who has access to the resources of this group. The <em class="italic">activity log</em> shows who created, updated, and deleted resources within this group. The <em class="italic">resource visualizer</em> gives a graphical view of resources and how they relate to each other. The <strong class="bold">Cost Management</strong> category might also be <span class="No-Break">of interest.</span></p>
			<p>You might need to wait for a day before seeing the detailed cost of each resource. With the tiers we used, the cost will be within a few cents. But you can also click on <strong class="bold">Recommendations</strong> to see what should be changed and configured with a production environment. Some of these recommendations require different tiers where you need to check into the cost changes. In case your company already experienced hacking into the company’s site, the cost of turning security features on with Microsoft Azure is really low compared to the cost of a <span class="No-Break">hacking attack:</span></p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B21217_06_05.jpg" alt="Figure 6.5 – Resource group with Azure resources"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Resource group with Azure resources</p>
			<p>Now, as <a id="_idIndexMarker391"/>the Azure <a id="_idIndexMarker392"/>resources are created, let’s publish the <strong class="source-inline">codebreaker</strong> services to <span class="No-Break">Microsoft Azure.</span></p>
			<p>Let’s start with creating an Azure Cosmos database within an Azure Cosmos <span class="No-Break">DB account.</span></p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Creating an Azure Cosmos database</h1>
			<p>From the <a id="_idIndexMarker393"/>Azure portal, you can open the page for your Azure Cosmos DB account, open <strong class="bold">Data Explorer</strong>, and from there, click on <strong class="bold">New Database</strong> to create a new database, and <strong class="bold">New Container</strong> to create a container within the database. Here, we’ll use the Azure <span class="No-Break">CLI instead:</span></p>
			<pre class="console">
az cosmosdb sql database create --account-name &lt;your cosmos account name&gt; -n codebreaker -g rg-codebreaker-test --throughput 400</pre>
			<p>This command creates a database named <strong class="source-inline">codebreaker</strong> in the existing account. Setting the throughput option with this command defines the scale of the database. Here, all containers within this database share the 400 RU/s throughput. 400 is the smallest value that can be set. Instead of supplying this value when creating the database, scaling can also be configured with every container. In case some containers should not take away scaling from other containers, configure the RU/s with every container – but here, the minimum value to be used with each container is 400 <span class="No-Break">as well.</span></p>
			<p>After creating the database, let’s create <span class="No-Break">a container:</span></p>
			<pre class="console">
az cosmosdb sql container create -g rg-codebreaker-test -a &lt;your cosmos account name&gt; -d codebreaker -n GamesV3, --partition-key-path "/PartitionKey"</pre>
			<p>The implementation of the <strong class="source-inline">gamesAPI</strong> service uses a container named <strong class="source-inline">GamesV3</strong>. This container is <a id="_idIndexMarker394"/>created within the previously created database, using the <strong class="source-inline">/PartitionKey</strong> partition key, as was specified with the EF Core context in <a href="B21217_03.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">.</span></p>
			<p>After this command is completed, check <strong class="bold">Data Explorer</strong> in the Azure portal, as shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B21217_06_06.jpg" alt="Figure 6.6 – Data Explorer"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Data Explorer</p>
			<p>You can see the database, the container, and, with the container, the configured <span class="No-Break">partition key.</span></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>Configuring replication with Azure Cosmos DB</h2>
			<p>A great <a id="_idIndexMarker395"/>feature of Azure Cosmos DB is global data replication. Within the Azure portal, in the <strong class="bold">Settings</strong> category, click on <strong class="bold">Replicate data globally</strong>. <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.7</em> shows the <span class="No-Break">replication view:</span></p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B21217_06_07.jpg" alt="Figure 6.7 – Replication with Azure Cosmos DB"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Replication with Azure Cosmos DB</p>
			<p>You just need to click on the Azure regions that are available with your subscription to replicate data within the selected regions. You can also configure it to write to <span class="No-Break">multiple regions.</span></p>
			<p>With the <strong class="source-inline">codebreaker</strong> application where users around the world can play, for faster performance for users in the US, Europe, Asia, and Africa, writing to multiple regions can be configured. For this option to be available, automatic scaling cannot be configured. For the best scalability across the globe, we also need to think about the partition key. By using different partition key values for every game that’s stored, games can be stored within <span class="No-Break">different partitions.</span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>Configuring consistency</h2>
			<p>With <a id="_idIndexMarker396"/>the <strong class="bold">Settings</strong> category in the Azure portal of Azure Cosmos DB, we can configure the default consistency level. The outcomes are shown using music notes, reading, and writing from multiple regions, as shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B21217_06_08.jpg" alt="Figure 6.8 – Outcome shown using music notes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Outcome shown using music notes</p>
			<p>The default setting is <strong class="bold">Session consistency</strong> – the data is consistent within the same session. With this setting, write latencies, availability, and read throughput are comparable to <strong class="bold">Eventual consistency</strong>. Using the Azure Cosmos DB API, a session can be created and distributed within <span class="No-Break">the application.</span></p>
			<p>The <strong class="bold">Strong consistency</strong> option is not available if multiple regions are configured. With <a id="_idIndexMarker397"/>multiple regions, <strong class="bold">Bounded staleness</strong> can be configured, which specifies a maximum lag time and a number of maximum lag operations before the data is <span class="No-Break">consistently replicated.</span></p>
			<p>The database is now ready to use, so let’s publish Docker images to <span class="No-Break">the registry!</span></p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Pushing images to the ACR instance</h1>
			<p>The ACR instance is ready, and we created Docker images in the previous chapter – now, let’s publish <a id="_idIndexMarker398"/>the images to <span class="No-Break">this registry.</span></p>
			<p>After <a id="_idIndexMarker399"/>you’ve logged in to Microsoft Azure (using <strong class="source-inline">az login</strong>), to log in to the ACR instance, you can use <strong class="source-inline">az acr login</strong>. Make sure to use the name you defined with the <span class="No-Break">ACR instance:</span></p>
			<pre class="console">
az login
az acr login -n &lt;the name of your azure container registry&gt;</pre>
			<p>This command needs to have Docker Desktop installed <span class="No-Break">and running.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Referencing the ACR instance using the Azure CLI, just the name of the registry is needed (such as <strong class="source-inline">codebreakertest</strong>). The <strong class="source-inline">docker</strong> and <strong class="source-inline">dotnet</strong> commands support different registries, thus with these commands, the complete domain name is needed, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">codebreakertest.azurecr.io</strong></span><span class="No-Break">.</span></p>
			<p>Next, let’s <a id="_idIndexMarker400"/>build the images. With <a id="_idIndexMarker401"/>the game APIs, we created a Dockerfile in the previous chapter. With the Windows terminal, make sure to set the current directory to the <strong class="source-inline">ch06</strong> folder and build the game <span class="No-Break">image locally:</span></p>
			<pre class="console">
docker build -f Codebreaker.GameAPIs\Dockerfile . -t codebreaker/gamesapi:3.5.1</pre>
			<p>This command – as in the previous chapter – builds the Docker image locally, referencing the Dockerfile, setting the context for <strong class="source-inline">docker build</strong>, and setting <span class="No-Break">the tag.</span></p>
			<p>To publish the image to ACR, we need to tag the <span class="No-Break">local images:</span></p>
			<pre class="console">
docker tag codebreaker/gamesapi:3.5.1 &lt;full DNS name of your ACR&gt;/codebreaker/gamesapi:3.5.1
docker tag codebreaker/gamesapi:3.5.1 &lt;full DNS name of your ACR&gt;/codebreaker/gamesapi:latest</pre>
			<p>The images are tagged with a link to the ACR instance. The same image is tagged with the version number as well as the <strong class="source-inline">latest</strong> tag. The <strong class="source-inline">latest</strong> tag is a convention where the newest version is stored and is always overridden in <span class="No-Break">the repository.</span></p>
			<p>Next, push the image to the registry with <span class="No-Break"><strong class="source-inline">docker push</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
docker push &lt;full DNS name of your ACR&gt;/codebreaker/gamesapi:3.5.1
docker push &lt;full DNS name of your ACR&gt;/codebreaker/gamesapi:latest</pre>
			<p>Make sure you are already logged in to the ACR instance; otherwise, the push <span class="No-Break">will fail.</span></p>
			<p>With a successful push, you can see the images in the Azure portal within the <strong class="bold">Repositories</strong> menu, as shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B21217_06_09.jpg" alt="Figure 6.9 – Repositories in ACR"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Repositories in ACR</p>
			<p>With the <a id="_idIndexMarker402"/>bot service, we didn’t create <a id="_idIndexMarker403"/>a Dockerfile in the previous chapter and used the dotnet CLI instead. Using <strong class="source-inline">dotnet publish</strong>, we just need to add this <strong class="source-inline">PropertyGroup</strong> instance to the <span class="No-Break">project file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Bot/Codebreaker.Bot.csproj project file</p>
			<pre class="source-code">
&lt;PropertyGroup&gt;
<strong class="bold">  </strong><strong class="bold">&lt;ContainerRegistry&gt;add your registry</strong>
<strong class="bold">  &lt;/ContainerRegistry&gt;</strong>
<strong class="bold">  &lt;ContainerRepository&gt;codebreaker/bot</strong>
<strong class="bold">  &lt;/ContainerRepository&gt;</strong>
<strong class="bold">  &lt;ContainerImageTags&gt;3.5.3;latest&lt;/ContainerImageTags&gt;</strong>
&lt;/PropertyGroup&gt;</pre>
			<p>The <strong class="source-inline">dotnet publish</strong> command uses <strong class="source-inline">ContainerRegistry</strong>, <strong class="source-inline">ContainerRepository</strong>, and <strong class="source-inline">ContainerImageTags</strong> elements to create the image and publish it to the registry. Pay attention to configuring your own registry with the <span class="No-Break"><strong class="source-inline">ContainerRegistry</strong></span><span class="No-Break"> element.</span></p>
			<p>All that needs to be done with the current directory is to set the directory of the project file of the bot and run <span class="No-Break"><strong class="source-inline">dotnet publish</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
cd Codebreaker.Bot
dotnet publish --os linux --arch x64 /t:PublishContainer -c Release</pre>
			<p>This <a id="_idIndexMarker404"/>command builds the image and <a id="_idIndexMarker405"/>directly publishes it to the registry, as specified with the <strong class="source-inline">ContainerRegistry</strong> element. Just make sure to enter the link to your registry, and be logged in using <span class="No-Break"><strong class="source-inline">docker login</strong></span><span class="No-Break">.</span></p>
			<p>As the images are ready, let’s continue using them with Azure <span class="No-Break">container apps!</span></p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Creating Azure container apps</h1>
			<p>Let’s create a <strong class="source-inline">gamesAPI</strong> service running with an Azure container app. This one needs a configuration containing a secret to the Azure <span class="No-Break">Cosmos database.</span></p>
			<p>With the <a id="_idIndexMarker406"/>Azure Cosmos database, in the Azure portal, go to the <strong class="bold">Settings</strong> category and open <strong class="bold">Keys</strong>. From this page, copy the primary or the secondary <span class="No-Break">connection string.</span></p>
			<p>With such keys, it’s useful to regenerate them from time to time – that’s why pairs are available. When you use the primary key from apps, regenerate the secondary key. After the regeneration, use the secondary key from within the apps, and regenerate the primary key. With this, you have some time to configure all the apps for the <span class="No-Break">new key.</span></p>
			<p>When creating an Azure container app for game APIs, there are quite some values to configure. While you can pass all the configuration values to the <strong class="source-inline">az containerapp create</strong> command, let’s start creating this with the Azure portal. Opening the resource of the Azure container app environment, click on <strong class="bold">Apps</strong>, and create a new app. <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.10</em> shows the <span class="No-Break">basic settings:</span></p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B21217_06_10.jpg" alt="Figure 6.10 – Basic settings for the Azure container app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Basic settings for the Azure container app</p>
			<p>With the <a id="_idIndexMarker407"/>basic settings, these values need to <span class="No-Break">be configured:</span></p>
			<ul>
				<li>The subscription for <span class="No-Break">the resource.</span></li>
				<li>The resource <span class="No-Break">group (</span><span class="No-Break"><strong class="source-inline">rg-codebreaker-test</strong></span><span class="No-Break">).</span></li>
				<li>The name of the container app. We use <strong class="source-inline">cae-codebreaker-gamesapi-3</strong>. The suffix 3 names version 3 of this API. You can run different versions of this app <span class="No-Break">in parallel.</span></li>
				<li>The region – select the region that best fits <span class="No-Break">your location.</span></li>
				<li>The container app environment. Select the environment <span class="No-Break">created earlier.</span></li>
			</ul>
			<p>The configuration screen for the container app is shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B21217_06_11.jpg" alt="Figure 6.11 – Container settings for the Azure container app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Container settings for the Azure container app</p>
			<p>Here, we select <a id="_idIndexMarker408"/>the image that will be published by selecting the ACR instance and the image name and tag, the CPU and memory resources that should be allocated for one running instance, and environment variables. Setting the <strong class="source-inline">DataStorage</strong> environment variable to <strong class="source-inline">Cosmos</strong> overrides the values defined in the <span class="No-Break"><strong class="source-inline">appsettings.json</strong></span><span class="No-Break"> file.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.12</em> shows the <span class="No-Break"><strong class="bold">Ingress</strong></span><span class="No-Break"> configuration:</span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B21217_06_12.jpg" alt="Figure 6.12 – Ingress settings for the Azure container app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Ingress settings for the Azure container app</p>
			<p>We need <a id="_idIndexMarker409"/>to enable <strong class="bold">Ingress</strong> and accept traffic from anywhere to make the service available from the outside. The target port of the Docker container is <strong class="source-inline">8080</strong>, as defined by the .NET <span class="No-Break">8 images.</span></p>
			<p>Clicking on <strong class="bold">Create</strong> creates the Azure container app by getting the image from the ACR instance. Be aware that starting the app will fail, as the connection string to the Cosmos database still needs to be configured. We will do this after creating the app for the <span class="No-Break">bot service.</span></p>
			<p>To create the app for the bot service, open the newly created container app in the Azure portal, and copy the <em class="italic">application URL</em> from the <strong class="bold">Overview</strong> view. This URL is needed for the configuration of <span class="No-Break">the bot.</span></p>
			<p>When creating <a id="_idIndexMarker410"/>an app for the bot service, you can configure it similarly to the game APIs. The <strong class="bold">Ingress</strong> configuration needs to be the same as before to have the bot accessible via its REST interface. With the container configuration, select the <strong class="source-inline">codebreaker/bot</strong> image. Create an environment variable with the name <strong class="source-inline">ApiBase</strong>, and the value with the application URL from the <span class="No-Break">game APIs.</span></p>
			<p>We still need to add some configuration values, which we’ll <span class="No-Break">do next.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Configuring secrets and environment variables</h2>
			<p>Defining <a id="_idIndexMarker411"/>secrets for the application is not directly possible with the portal when creating the app. This would be possible directly using the <strong class="source-inline">az containerapp </strong><span class="No-Break"><strong class="source-inline">create</strong></span><span class="No-Break"> command.</span></p>
			<p>With the portal, the secret can be configured afterward. When opening the container app within the Azure portal, in the <strong class="bold">Settings</strong> category, you can click on <strong class="bold">Secrets</strong>. One secret that was already stored on creating the app is the password for the ACR instance. For a successful connection to the Azure Cosmos DB instance, create a new secret named <strong class="source-inline">cosmosconnectionstring</strong>, as shown in <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.13</em>, and copy the connection string you copied from Azure Cosmos DB to <span class="No-Break">the value:</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <a id="_idIndexMarker412"/>screenshot in <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.13</em> shows another option where secrets can be stored: a Key Vault reference. In <a href="B21217_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, we’ll discuss using other options to use configurations, which include <strong class="bold">Azure </strong><span class="No-Break"><strong class="bold">Key Vault</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B21217_06_13.jpg" alt="Figure 6.13 – Secret configuration with the Azure container app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Secret configuration with the Azure container app</p>
			<p>To create an environment variable that references the secret, we can use the <span class="No-Break">Azure CLI:</span></p>
			<pre class="console">
az containerapp update -n cae-codebreaker-gamesapi-3 -g rg-codebreaker-test --set-env-vars ConnectionStrings__GamesCosmosConnection=secretref:cosmosconnectionstring</pre>
			<p>Using <a id="_idIndexMarker413"/>the <strong class="source-inline">az containerapp update</strong> command, we need to reference the container app and the resource group and set environment variables using <strong class="source-inline">--set-env-vars</strong>. Contrary to passing hierarchical configuration values to the command line where <strong class="source-inline">:</strong> is used as a separator, such as <strong class="source-inline">ConnectionStrings:GamesCosmosConnection</strong>, with environment variables, using <strong class="source-inline">:</strong> is not possible. Instead, here, <strong class="source-inline">__</strong> maps values. The key that’s specified for the connection to the Azure Cosmos DB instance is <strong class="source-inline">ConnectionStrings__GamesCosmosConnection</strong>. The value for this is stored in a secret. A secret is referenced with <strong class="source-inline">secretref</strong>, followed by the <span class="No-Break">secret key.</span></p>
			<p>The application should be running now, but let’s make sure to <span class="No-Break">configure scaling.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>Configuring scaling with Azure Container Apps</h2>
			<p>The <a id="_idIndexMarker414"/>default scaling configured with Azure Container Apps is scaling from 0 to 10. If no load is on the app, it scales down to 0 where CPU and memory costs are reduced to zero. However, scaling to 0 also means that the first user accessing the service needs to wait for a few seconds before the service returns results. With the bot service that’s running in the background and doesn’t need some user interaction after the first invocation, this can be fast enough. With app jobs that are triggered from messages or events, this is also OK. However, with the <strong class="source-inline">gamesAPI</strong> service, this should be responsive for the first user accessing <span class="No-Break">the service.</span></p>
			<p>Configuring the minimum scale to 1 has a reduced price for the CPU if there’s no load. With idle pricing, the memory doesn’t have a price difference, but the CPU is about 10% of the cost compared to a <span class="No-Break">running service.</span></p>
			<p>Let’s <a id="_idIndexMarker415"/>configure the <strong class="source-inline">gamesAPI</strong> service to scale from 1 to 3 replicas, and the bot service to scale from 0 to 3. Within the Azure portal, select the container app, the <strong class="bold">Applications</strong> category, and the <strong class="bold">Scale and replicas</strong> menu. Click the <strong class="bold">Edit and deploy</strong> menu, select <strong class="bold">Scale</strong>, and change the replicas to 1 to 3 and to 0 to 3 depending on the app. In case the UI elements are not easily movable to change the values accordingly, you can use the arrow keys to change the values one by one. The maximum scale count (at the time of this writing) <span class="No-Break">is 300.</span></p>
			<p>Clicking on <strong class="bold">Create</strong> does a redeploy and creates a new revision of the app. By default, only one revision is active at a time. As soon as the new revision successfully starts up, the load balancer moves 100% of the traffic to the new revision. With the <strong class="bold">Applications</strong> | <strong class="bold">Revisions</strong> menu, you can see active and inactive revisions. There, you also can configure the revision mode. The default revision mode is <strong class="bold">Single</strong>, where just one revision is active. You can change this to <strong class="bold">Multiple</strong>, where several revisions are running concurrently, and you can configure how much percentage of the traffic should be distributed to which revision. This can be useful to test different versions running on a <span class="No-Break">user load.</span></p>
			<p>With this in place, let’s try to run the application. You can open the Swagger page of the bot to let the bot play some games. You can also use a client you created in <a href="B21217_04.xhtml#_idTextAnchor092"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, configure the address with the Container App game API’s URL, and play a game. Check into the <strong class="bold">Data Explorer</strong> section of Cosmos DB to see the <span class="No-Break">games stored.</span></p>
			<p>As you now know all the Azure services used in the first place, you can delete Azure resources and recreate them easily in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor155"/>Creating Azure resources with .NET Aspire and azd</h1>
			<p>Here, we’ll <a id="_idIndexMarker416"/>look into how to easily create <a id="_idIndexMarker417"/>Azure resources from the development system. First, we <a id="_idIndexMarker418"/>use some <a id="_idIndexMarker419"/>resources from the Azure cloud, while most of the projects are running locally on the development system, before we publish the complete solution <span class="No-Break">to Azure.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>Provisioning Azure resources while debugging</h2>
			<p>When creating API services and using databases, you might not need any Azure resources <a id="_idIndexMarker420"/>when debugging the application locally. The API can run locally; even building Docker images is not required here. To run the database, a Docker image can be used easily, as you’ve already seen in <a href="B21217_05.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. However, for some Azure resources that you might also use during development, creating and connecting Azure resources is required. One example is Azure Application Insights (which is covered in detail in <a href="B21217_08.xhtml#_idTextAnchor183"><span class="No-Break"><em class="italic">Chapter 8</em></span></a><span class="No-Break">).</span></p>
			<p>To use Azure resources with the application map in the <strong class="source-inline">AppHost</strong> project, you need to add the <strong class="source-inline">A</strong><strong class="source-inline">spire.Hosting.Azure.* packages</strong>. To use Azure resources to define the app model, packages such as <strong class="source-inline">Aspire.Hosting.Azure</strong> and <strong class="source-inline">Aspire.Hosting.Azure.cosmosDB</strong> <span class="No-Break">are available.</span></p>
			<p>Provisioning of Azure resources happens automatically when the Azure resources are specified with the <span class="No-Break">app model:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = DistributedApplication.CreateBuilder(args);
string dataStore = builder.Configuration["DataStore"] ?? "InMemory";
<strong class="bold">var cosmos = builder.AddAzureCosmosDB("codebreakercosmos")</strong>
<strong class="bold">  .AddDatabase("codebreaker");</strong>
// code removed for brevity</pre>
			<p>The <strong class="source-inline">AddAzureProvisioning</strong> method creates Azure resources or retrieves the connection string when starting the application. Before this can successfully run, you need to specify your subscription ID and the location where the resources <span class="No-Break">are created:</span></p>
			<pre class="source-code">
{
  "Azure": {
    "SubscriptionId": "your subscription id",
    "Location": "westeurope",
    "CredentialSource":"AzureCli"
  }
}</pre>
			<p>This <a id="_idIndexMarker421"/>information should not be part of the source code repository, thus add it to the user secrets. The <strong class="source-inline">SubscriptionId</strong> and <strong class="source-inline">Location</strong> keys need to be specified within the <strong class="source-inline">Azure</strong> category. Adding a <em class="italic">CredentialSource</em> is optional. The user to create the resources is selected using the DefaultAzureCredential (see <a href="B21217_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> for details). In case this is not working in your environment, you can configure AzureCli which uses the account you are logged in with the <span class="No-Break">Azure CLI.</span></p>
			<p>To get the subscription ID, you can use the <span class="No-Break">following command:</span></p>
			<pre class="console">
az account show -–query id</pre>
			<p>You need to be logged in to your subscription not only to see the subscription ID but also to deploy the resources automatically. After running the application, you can see the deployed resources are written to the user secrets <span class="No-Break">as well.</span></p>
			<p>This app model defines provisioning and using the Azure Cosmos DB database without using <span class="No-Break">the emulator:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = DistributedApplication.CreateBuilder(args);
string dataStore = builder.Configuration["DataStore"] ?? "InMemory";
<strong class="bold">var cosmos = builder.AddAzureCosmosDB("codebreakercosmos")</strong>
<strong class="bold">  .AddDatabase("codebreaker");</strong>
var gameAPIs = builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis")
<strong class="bold">  </strong>.WithExternalHttpEndpoints()
<strong class="bold">  .WithReference(cosmos)</strong>
  .WithEnvironment("DataStore", dataStore);
builder.AddProject&lt;Projects.CodeBreaker_Bot&gt;("bot")
.WithExternalHttpEndpoints()
  .WithReference(gameAPIs);
<strong class="bold">builder.AddProject&lt;Projects.Codebreaker_CosmosCreate&gt;("cosmoscreate")</strong>
<strong class="bold">  .WithReference(cosmos);</strong>
builder.Build().Run();</pre>
			<p>To avoid the need to install and run the local Azure Cosmos DB emulator, and to get rid of some <a id="_idIndexMarker422"/>issues using Azure Cosmos DB in the Docker image, we can use Azure Cosmos DB in the cloud. Not using the <strong class="source-inline">RunAsEmulator</strong> method with <strong class="source-inline">AddAzureCosmosDB</strong>, we use the resource running in Azure. The <strong class="source-inline">AddDatabase</strong> method adds the <strong class="source-inline">codebreaker</strong> database to the account. The <strong class="source-inline">Codebreaker.CosmosCreate</strong> project is used to run once, invoking the <strong class="source-inline">EnsureCreatedAsync</strong> method of the EF Core context to create a container with the partition key. The <strong class="source-inline">WithReference</strong> method used both with the <strong class="source-inline">gamesAPI</strong> service and the <strong class="source-inline">CosmosCreate</strong> project passes the newly created Azure Cosmos DB connection string to these resources. The <strong class="source-inline">WithExternalEndpoints</strong> method configures the Ingress controller of the Azure App Configuration to make this service <span class="No-Break">external available.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.14</em> shows the .NET Aspire dashboard with the <span class="No-Break">application running:</span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B21217_06_14.jpg" alt="Figure 6.14 – .NET Aspire dashboard with deployed Azure resources"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – .NET Aspire dashboard with deployed Azure resources</p>
			<p>The <strong class="source-inline">codebreakercosmos</strong> resource shows an endpoint with the <strong class="source-inline">deployment</strong> link text. This is a resource deployed to Azure. Clicking this link, you are directly navigated to this cloud resource and can check the database and container name are created. The <strong class="source-inline">cosmoscreate</strong> reference is in the <strong class="bold">Finished</strong> state, thus the creation of the container <span class="No-Break">is done.</span></p>
			<p>Now let’s <a id="_idIndexMarker423"/>start the bot and let it run some games, then open <strong class="bold">Data Explorer</strong> with Azure Cosmos DB, and you’ll see the games created. You can debug the solution locally while using some of the resources in the cloud, just by adding one <span class="No-Break">API method.</span></p>
			<p>The resource group created here uses the name <strong class="source-inline">rg-aspire-{yourhost}-codebreaker.apphost</strong>. If multiple developers use the same Azure subscription, resources are created independently of each other to not get into conflicts. Make sure to delete resources when <span class="No-Break">not needed.</span></p>
			<p>Next, let’s create the complete solution to run <span class="No-Break">with Azure.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>Provisioning the complete solution with azd up</h2>
			<p>For <a id="_idIndexMarker424"/>this, we use <strong class="source-inline">azd</strong>. First, in the directory of the solution, use the <span class="No-Break">following command:</span></p>
			<pre class="console">
azd init</pre>
			<p>This initializes an application to be used with <strong class="source-inline">azd</strong>. You can use a template to create a new solution or analyze an existing application. As we already have a running application, select <strong class="source-inline">Use code in the current directory</strong> to analyze the application. The application needs to be stopped because <strong class="source-inline">azd</strong> also starts the compilation. With a successful scan, <strong class="source-inline">azd</strong> informs to host the app using <strong class="bold">Azure Container Apps</strong>. Confirm this to continue the initialization. Next, projects are listed where you need to select which of these should be accessible on the internet (the Ingress service will be configured accordingly). Select the <strong class="source-inline">bot</strong> and <strong class="source-inline">gamesAPI</strong> services. Then, define an environment (for example, <strong class="source-inline">codebreaker-06</strong>) using a <span class="No-Break">chapter suffix.</span></p>
			<p>What happened? This command created a <strong class="source-inline">.azure</strong> folder and <strong class="source-inline">azure.yaml</strong> and <strong class="source-inline">next-steps.md</strong> files. <strong class="source-inline">next-steps.md</strong> gives information about what you can do next. <strong class="source-inline">azure.yaml</strong> is a short file containing information that references the <strong class="source-inline">AppHost</strong> project running with a <strong class="source-inline">containerapp</strong>. The most interesting generated information can <a id="_idIndexMarker425"/>be found in the <strong class="source-inline">.azure</strong> folder. This folder is excluded from the source code repository as it can contain secrets. In this folder, you can see the environments that are configured, as well as the configuration about which services should <span class="No-Break">be public.</span></p>
			<p>To publish the complete solution to Azure, just use the <span class="No-Break">following command:</span></p>
			<pre class="console">
azd up</pre>
			<p>With the first run, you need to select the Azure subscription to deploy the resources to, and the location for the Azure region. Next, you just need to wait several minutes until all the resources have <span class="No-Break">been deployed.</span></p>
			<p>In the provisioning phase, these resources <span class="No-Break">are deployed:</span></p>
			<ul>
				<li>A <span class="No-Break">resource group</span></li>
				<li>A <span class="No-Break">container registry</span></li>
				<li>A <span class="No-Break">key vault</span></li>
				<li>A Log <span class="No-Break">Analytics workspace</span></li>
				<li>A Container <span class="No-Break">Apps environment</span></li>
			</ul>
			<p>After the provisioning phase, the deployment phase starts with <span class="No-Break">these actions:</span></p>
			<ul>
				<li>Pushing Docker images to the <span class="No-Break">ACR instance</span></li>
				<li>Creating container apps in the Container Apps environment using the images from the <span class="No-Break">ACR instance</span></li>
			</ul>
			<p>As you make any changes to the source code or the configuration, you just need to use <strong class="source-inline">azd up</strong> again to deploy the updates. As the created environment is no longer needed, use <strong class="source-inline">azd down</strong> to delete all the resources again. Make sure to wait until you are asked for verification as to whether the number of resources should really <span class="No-Break">be deleted.</span></p>
			<p>Checking <a id="_idIndexMarker426"/>the resource group within the Azure portal, you can see all resources created, as shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.15</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B21217_06_15.jpg" alt="Figure 6.15 – Resources created from azd up"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – Resources created from azd up</p>
			<p>Now, you can check the resources deployed, the images published to the container registry, the applications published to the container apps environment, the key vault containing a secret, and the Azure Cosmos DB account with the database and the configured container. Let the bot play games and verify if everything <span class="No-Break">is running.</span></p>
			<p>Next, let’s get into the details of what happened with <span class="No-Break"><strong class="source-inline">azd up</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/>Diving into azd up stages</h2>
			<p>Running <a id="_idIndexMarker427"/>the <strong class="source-inline">AppHost</strong> project, command-line arguments can be passed to create a manifest file describing all <span class="No-Break">the resources:</span></p>
			<pre class="console">
dotnet run --project Codebreaker.AppHost/Codebreaker.AppHost.csproj -- --publisher manifest --output-path aspire-manifest.json</pre>
			<p>When using <strong class="source-inline">dotnet run</strong>, command-line arguments can be passed to the application by using <strong class="source-inline">--</strong> to differentiate from the arguments of <strong class="source-inline">dotnet run</strong>. Using the -<strong class="source-inline">–publisher manifest</strong> option creates an Aspire manifest describing the app model of the application. This manifest specifies all resources with the resource type, bindings, environment variables, and paths to the projects. This information is used by <strong class="source-inline">azd</strong> to create Azure resources and can be used from other tools to, for example, deploy the solution <span class="No-Break">to Kubernetes.</span></p>
			<p>Next, <strong class="source-inline">azd provision</strong> is used. In case you just want to provision Azure resources without pushing Docker images and deploying the Azure container apps, use the <span class="No-Break">following command:</span></p>
			<pre class="console">
azd provision</pre>
			<p><strong class="source-inline">azd provision</strong> uses the manifest file to create Bicep files in memory and creates <span class="No-Break">Azure resources.</span></p>
			<p>You can <a id="_idIndexMarker428"/>use this command when any Azure resources are added to the app model, then just these resources <span class="No-Break">are created.</span></p>
			<p>The next step is <span class="No-Break">the following:</span></p>
			<pre class="console">
azd deploy</pre>
			<p><strong class="source-inline">azd deploy</strong> pushes the container images to the ACR instance using <strong class="source-inline">dotnet publish</strong>, and then creates or updates Azure resources using <span class="No-Break">these images.</span></p>
			<p><strong class="source-inline">azd up</strong> creates Bicep scripts in memory. It’s also possible to create Bicep scripts on disk to use them to create Azure resources, as we’ll <span class="No-Break">do next.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor159"/>Creating Bicep files using azd</h2>
			<p>Bicep is <a id="_idIndexMarker429"/>a domain-specific language using <a id="_idIndexMarker430"/>declarative syntax. Before Bicep was available, we created <strong class="bold">Azure Resource Manager</strong> (<strong class="bold">ARM</strong>) templates to create Azure resources. ARM templates are defined using JSON. Bicep is simpler to write than ARM templates. During deployment, Bicep files are converted to <span class="No-Break">ARM templates.</span></p>
			<p>Here, we use <strong class="source-inline">azd infra</strong> to create Bicep files for <span class="No-Break">the solution.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">At the time of this writing, <strong class="source-inline">azd infra</strong> is in an early stage. Check the README file of this chapter <span class="No-Break">for updates.</span></p>
			<p>Start this command from the directory of <span class="No-Break">the solution:</span></p>
			<pre class="console">
azd infra synth</pre>
			<p>This <a id="_idIndexMarker431"/>command creates an <strong class="source-inline">infra</strong> folder with <span class="No-Break">these files:</span></p>
			<ul>
				<li><strong class="source-inline">main.bicep</strong> – The main bicep file that creates a resource group and references modules to create <span class="No-Break">more resources.</span></li>
				<li><strong class="source-inline">main.parameters.json</strong> – A parameters file that is used to pass parameters such as the environment name and the location to the <span class="No-Break"><strong class="source-inline">main.bicep</strong></span><span class="No-Break"> file.</span></li>
				<li><strong class="source-inline">resources.bicep</strong> – This file is referenced by <strong class="source-inline">main.bicep</strong> and contains resources such as the ACR instance, the Log Analytics workspace, the Container Apps environment, and the Azure key vault that <span class="No-Break">are created.</span></li>
				<li><strong class="source-inline">codebreakercosmos/codebreakercosmos.bicep</strong> – This file is referenced from <strong class="source-inline">main.bicep</strong> as well and contains resource information for Azure Cosmos DB, as well as an Azure Key Vault secret that’s written to the Azure key vault. The secret itself is not part of this file; the secret is retrieved dynamically from the Azure Cosmos DB account when creating <span class="No-Break">this resource.</span></li>
			</ul>
			<p>In case you customize these generated Bicep files, the customized files are used by <strong class="source-inline">azd up</strong> or <strong class="source-inline">azd provision</strong> on creating the <span class="No-Break">Azure resources.</span></p>
			<p>With the <strong class="source-inline">bot</strong> and <strong class="source-inline">gamesAPI</strong> projects, <strong class="source-inline">azd infra</strong> also creates an infra folder with template files in the AppHost project; for example <strong class="source-inline">gameapis.tmpl.yaml</strong>. With these files, the Azure Container Apps instances can be customized; for example, by changing CPU and memory sizes or changing the number of replicas that should be used. Changing these values, <strong class="source-inline">azd up</strong> or <strong class="source-inline">azd deploy</strong> makes use of <span class="No-Break">these files.</span></p>
			<p>When you open the resource group you previously created with <strong class="source-inline">azd up</strong>, open <strong class="bold">Deployments</strong> in the <strong class="bold">Settings</strong> category. This shows deployments of the resource group, as shown in <span class="No-Break"><em class="italic">Figure 6</em></span><span class="No-Break"><em class="italic">.16</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B21217_06_16.jpg" alt="Figure 6.16 – Deployments"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – Deployments</p>
			<p>The deployments match the Bicep files used. When you open <strong class="bold">Related events</strong>, you can see all the steps that have been done with <span class="No-Break">these deployments.</span></p>
			<p>After you don’t need the resources anymore, use this command to delete all the <span class="No-Break">resources again:</span></p>
			<pre class="console">
azd down</pre>
			<p>This tool <a id="_idIndexMarker432"/>retrieves the number of Azure resources to delete and asks if this should be done – thus, make sure to wait until you can answer yes. After the deletion of the resources is complete, which usually takes more than 10 minutes, another question is asked if the data from the key vault should be purged. If you don’t answer yes to this question, this data can be recovered for 90 days, and during that time you cannot create the resource with the same name again until the end of this <span class="No-Break">recovery time.</span></p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Summary</h1>
			<p>In this chapter, you learned to create Microsoft Azure resources using the Azure CLI, the Azure portal, and .NET Aspire with <strong class="source-inline">azd</strong>. The <strong class="source-inline">gamesAPI</strong> service is now running with Microsoft Azure resources using ACR, Azure Container Apps, and the Azure Cosmos DB database. When using <strong class="source-inline">azd</strong> together with .NET Aspire, just one command was needed to deploy all <span class="No-Break">the services.</span></p>
			<p>Before moving on to the next chapter, let’s configure the client application you used in previous chapters to now use the URL from the Azure container app instead of the local services, and play <span class="No-Break">some games.</span></p>
			<p>In this chapter, the Azure key vault was already created. In the next chapter, we look into the configuration of the backend services, which includes Azure Key Vault, and use Azure App Configuration as a central place for the configuration of all <span class="No-Break"><strong class="source-inline">codebreaker </strong></span><span class="No-Break">services.</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor161"/>Further reading</h1>
			<p>To learn more about the topics discussed in this chapter, you can refer to the <span class="No-Break">following links:</span></p>
			<ul>
				<li>Azure round-trip latency statistics with Azure <span class="No-Break">regions: </span><a href="https://learn.microsoft.com/azure/networking/azure-network-latency"><span class="No-Break">https://learn.microsoft.com/azure/networking/azure-network-latency</span></a></li>
				<li>Azure Cosmos DB – databases, containers, and <span class="No-Break">items: </span><a href="https://learn.microsoft.com/azure/cosmos-db/resource-model"><span class="No-Break">https://learn.microsoft.com/azure/cosmos-db/resource-model</span></a></li>
				<li>Stored procedures, triggers, and user-defined <span class="No-Break">functions: </span><span class="No-Break">https://learn.microsoft.com/azure/cosmos-db/nosql/how-to-write-stored-procedures-triggers-udfs</span></li>
				<li>Azure Container <span class="No-Break">Apps: </span><a href="https://learn.microsoft.com/azure/container-apps/"><span class="No-Break">https://learn.microsoft.com/azure/container-apps/</span></a></li>
				<li><span class="No-Break">Bicep: </span><span class="No-Break">https://learn.microsoft.com/azure/azure-resource-manager/bicep</span></li>
				<li><strong class="source-inline">azd</strong> <span class="No-Break">reference: </span><a href="https://learn.microsoft.com/en-gb/azure/developer/azure-developer-cli/reference"><span class="No-Break">https://learn.microsoft.com/en-gb/azure/developer/azure-developer-cli/reference</span></a></li>
			</ul>
		</div>
	</body></html>