<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-131">
    <a id="_idTextAnchor132">
    </a>
    
     8
    
   </h1>
   <h1 id="_idParaDest-132">
    <a id="_idTextAnchor133">
    </a>
    
     Enhancing Applications with Middleware in ASP.NET Core 9
    
   </h1>
   <p>
    
     ASP.NET Core 9 offers a robust and flexible framework designed to handle high-demand web applications.
    
    
     A key component of this framework
    
    <a id="_idIndexMarker636">
    </a>
    
     is middleware, which allows developers to interact directly with the request and response pipeline.
    
    
     Understanding and leveraging middleware can significantly enhance your application’s capabilities.
    
    
     This chapter will dive deep into middleware, exploring its structure, implementation, and practical applications, such as global error handling, request limiting,
    
    
     
      and more.
     
    
   </p>
   <p>
    
     In this chapter, we will focus on the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Knowing the
     
     
      
       middleware pipeline
      
     
    </li>
    <li>
     
      Implementing
     
     
      
       custom middleware
      
     
    </li>
    <li>
     
      Working with
     
     
      
       factory-based middleware
      
     
    </li>
    <li>
     
      Adding capabilities to applications
     
     
      
       using middleware
      
     
    </li>
    <li>
     
      Creating an extension method for
     
     
      
       middleware registration
      
     
    </li>
   </ul>
   <p>
    
     In this chapter, we will explore essential best practices for developing applications with ASP.NET Core 9, covering the correct use of asynchronous mechanisms, HTTP requests, and application instrumentation
    
    
     
      through logs.
     
    
   </p>
   <h1 id="_idParaDest-133">
    <a id="_idTextAnchor134">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To support the learning of this chapter, the following tools must be present in your development
    
    
     
      environment:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Docker
      
     </strong>
     
      : The Docker engine must be installed on your operating system and have an SQL Server container running.
     
     
      You can find more details about Docker and SQL Server containers in
     
     <a href="B21788_05.xhtml#_idTextAnchor078">
      
       <em class="italic">
        
         Chapter 5
        
       </em>
      
     </a>
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       Postman
      
     </strong>
     
      : This tool will be used to execute requests to APIs of the
     
     
      
       developed application.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Redis Insight
      
     </strong>
     
      : This tool is used to connect to a Redis Server
     
     
      
       database (
      
     
     <a href="https://redis.io/insight/">
      
       
        https://redis.io/insight/
       
      
     </a>
     
      
       ).
      
     
    </li>
   </ul>
   <p>
    
     The code examples used in this chapter can be found in the book’s GitHub
    
    
     
      repository:
     
    
    <a href="https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter08">
     
      
       https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter08
      
     
    </a>
   </p>
   <h1 id="_idParaDest-134">
    <a id="_idTextAnchor135">
    </a>
    
     Knowing the middleware pipeline
    
   </h1>
   <p>
    
     During the previous chapters, we used several features of ASP.NET Core 9,
    
    
     
      including middleware.
     
    
   </p>
   <p>
    
     Middleware is a
    
    <a id="_idIndexMarker637">
    </a>
    
     pipeline model used during the execution flow of an ASP.NET Core 9 web application to handle requests and responses, and the applications developed in this book already use some standard middleware
    
    <a id="_idIndexMarker638">
    </a>
    
     from the .NET platform, such
    
    <a id="_idIndexMarker639">
    </a>
    
     as
    
    <strong class="bold">
     
      Authentication
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Authorization
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Cross-Origin Resource Sharing
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CORS
     
    </strong>
    
     ), and
    
    
     
      so
     
    
    
     <a id="_idIndexMarker640">
     </a>
    
    
     
      on.
     
    
   </p>
   <p>
    
     The ASP.NET Core request pipeline consists of a sequence of request delegates, called one after the other.
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     demonstrates
    
    
     
      the concept:
     
    
   </p>
   <div><div><img alt="Figure 8.1 – ASP.NET Core 9 middleware pipeline" src="img/B21788_08_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.1 – ASP.NET Core 9 middleware pipeline
    
   </p>
   <p>
    
     Request delegates are configured using the
    
    <strong class="source-inline">
     
      Run
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Map
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      Use
     
    </strong>
    
     extension methods typically configured in the
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     Each extension
    
    <a id="_idIndexMarker641">
    </a>
    
     method has a template for registering a
    
    
     
      request delegate:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       Run
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       app.Run
      
     </strong>
     
      method is used to define an inline middleware that handles the request and completes the response, as in the following example code that implements an
     
     
      
       inline
      
     
     
      <a id="_idIndexMarker642">
      </a>
     
     
      
       middleware:
      
     
     <pre class="source-code">
<strong class="bold">app.Run(</strong>async context =&gt;
{
  await context.Response.WriteAsync("Hello Inline middleware!");
});</pre>
    </li>
    <li>
     <strong class="source-inline">
      
       Map
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       app.Map
      
     </strong>
     
      method is used to create a branch in the middleware pipeline.
     
     
      In the following code, requests to
     
     <strong class="source-inline">
      
       /SomeRoute
      
     </strong>
     
      are handled by this middleware branch.
     
     
      The middleware in the branch writes a message to
     
     
      
       the response:
      
     
     <pre class="source-code">
<strong class="bold">app.Map("/SomeRoute"</strong>, someRouteApp =&gt;
{
  someRouteApp.Use(async (context, next) =&gt;
  {
    Console.WriteLine("In SomeRoute middleware");
    await context.Response.WriteAsync("Hello from the SomeRoute middleware!");
  });
});</pre>
    </li>
    <li>
     <strong class="source-inline">
      
       Use
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       app.Use
      
     </strong>
     
      method is used to add middleware to the pipeline.
     
     
      The following code uses a middleware to log the request method and path before calling the next middleware in the pipeline.
     
     
      After the next middleware completes, it logs the response
     
     
      
       status code:
      
     
     <pre class="source-code">
<strong class="bold">app.Use</strong>(async (context, next) =&gt;
{
  // Log the request
  Console.WriteLine($"Request:
    {context.Request.Method}
    {context.Request.Path}");
  await next.Invoke();
  // Log the response
  Console.WriteLine($"Response:
    {context.Response.StatusCode}");
});</pre>
    </li>
   </ul>
   <p>
    
     The use of
    
    <a id="_idIndexMarker643">
    </a>
    
     middleware brings constant benefits to applications; we will understand in greater detail the use of different approaches, such as the creation of
    
    
     
      middleware classes.
     
    
   </p>
   <p>
    
     Now, let’s learn about how the middleware execution
    
    
     
      flow works.
     
    
   </p>
   <h2 id="_idParaDest-135">
    <a id="_idTextAnchor136">
    </a>
    
     Understanding middleware flow
    
   </h2>
   <p>
    
     When the application
    
    <a id="_idIndexMarker644">
    </a>
    
     receives a request, it goes through each middleware component in the order they are registered, and the following cases can
    
    
     
      be executed:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Process the request and pass it to the next piece of middleware
      
     </strong>
     
      : It’s like a relay race where each runner passes the baton to the next.
     
     
      Each piece of middleware does its part and then calls the next one in line to continue processing
     
     
      
       the request.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Process the request and break the chain, preventing other middleware from running
      
     </strong>
     
      : Imagine a security checkpoint at an airport.
     
     
      If security finds a problem, they may stop you for additional checks, preventing you from proceeding.
     
     
      Likewise, the middleware may decide to handle the request completely and stop
     
     
      
       further processing.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Process the response as it moves up the chain
      
     </strong>
     
      : This is like sending a package through multiple stages of inspection.
     
     
      Once the package reaches the final stage, it is inspected again at each stage on the way back, ensuring that everything is in order before
     
     
      
       being delivered.
      
     
    </li>
   </ul>
   <p>
    
     The layered approach allows for powerful and flexible handling of HTTP requests and responses.
    
    
     Middleware
    
    <a id="_idIndexMarker645">
    </a>
    
     can be used for a variety of tasks, such as logging, authentication, error handling,
    
    
     
      and more.
     
    
   </p>
   <p>
    
     Furthermore, the order in which you register middleware is crucial, as it defines the flow of the request and response pipeline.
    
    
     We can see a representation of the middleware execution flow in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    
     <em class="italic">
      
       .2
      
     </em>
    
    
     
      :
     
    
   </p>
   <p class="IMG---Figure">
   </p>
   <div><div><img alt="Figure 8.2 – Middleware execution flow" src="img/B21788_08_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.2 – Middleware execution flow
    
   </p>
   <p>
    
     Let’s see how the
    
    <a id="_idIndexMarker646">
    </a>
    
     flow works
    
    
     
      in detail:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Request arrival
      
     </strong>
     
      : When a request arrives at the server, it enters the pipeline and reaches the first
     
     
      
       middleware component
      
     
    </li>
    <li>
     <strong class="bold">
      
       Middleware execution
      
     </strong>
     
      : Each middleware can do
     
     
      
       the following:
      
     
     <ul>
      <li>
       <strong class="bold">
        
         Modify the request
        
       </strong>
       
        : Middleware can change aspects of the request, such as adding headers or changing the
       
       
        
         request path
        
       
      </li>
      <li>
       <strong class="bold">
        
         Move to next middleware
        
       </strong>
       
        : After processing, the middleware can call the next middleware in the pipeline using
       
       <strong class="source-inline">
        
         await next
        
       </strong>
       
        , which we’ll discuss in the
       
       <em class="italic">
        
         Implementing custom
        
       </em>
       
        <em class="italic">
         
          middleware
         
        </em>
       
       
        
         section
        
       
      </li>
     </ul>
    </li>
    <li>
     <strong class="bold">
      
       Short-circuiting the pipeline
      
     </strong>
     
      : The middleware may decide not to call the next middleware, effectively ending request
     
     
      
       processing early
      
     
    </li>
    <li>
     <strong class="bold">
      
       Response handling
      
     </strong>
     
      : When the request reaches the end of the pipeline, the response goes back through the middleware components in
     
     
      
       reverse order
      
     
    </li>
    <li>
     <strong class="bold">
      
       Modifying the response
      
     </strong>
     
      : The middleware can change the response, such as adding headers, changing
     
     <a id="_idIndexMarker647">
     </a>
     
      the status code, or
     
     
      
       logging information
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Middleware order
    
   </p>
   <p class="callout">
    
     ASP.NET Core 9 has, by
    
    <a id="_idIndexMarker648">
    </a>
    
     default, some middleware available to handle requests and responses.
    
    
     However, the order in which this middleware is inserted completely changes the application’s execution flow and, in some cases, can cause malfunctions.
    
    
     For example, it is important to add middleware authentication before middleware authorization; otherwise, how can you validate authorization without
    
    
     
      being authenticated?
     
    
   </p>
   <p class="callout">
    
     In any case, in addition to standard middleware, there is an order of execution for
    
    
     
      customized middleware.
     
    
   </p>
   <p class="callout">
    
     To learn more about
    
    <a id="_idIndexMarker649">
    </a>
    
     middleware order, see the following
    
    
     
      link:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#middleware-order">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#middleware-order
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     By working on the middleware execution flow, we have the ability to add several powerful possibilities to our applications, and we will learn some more benefits in the
    
    
     
      next section.
     
    
   </p>
   <h2 id="_idParaDest-136">
    <a id="_idTextAnchor137">
    </a>
    
     Benefits of middleware and best practices
    
   </h2>
   <p>
    
     Middleware plays a key role in ASP.NET Core 9 applications, offering a number of benefits that contribute to the robustness, maintainability, and extensibility of your application.
    
    
     Understanding these
    
    <a id="_idIndexMarker650">
    </a>
    
     benefits allows you to use this resource effectively, so let’s look at this in
    
    
     
      more detail:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Modularity
      
     </strong>
     
      : Modularity means that middleware is an independent unit of functionality that can be easily added, removed, or replaced without affecting the rest of the application.
     
     
      This modularity allows developers to create reusable middleware components that can be shared between different projects or in different parts of the
     
     
      
       same project.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Composition
      
     </strong>
     
      : Middleware can be composed in multiple orders to achieve different behaviors.
     
     
      This compositional nature allows you to tailor the request and response pipeline to the specific needs of
     
     
      
       your application.
      
     
     <p class="list-inset">
      
       Let’s say you have three middleware components: one for logging, one for authentication, and one for handling errors.
      
      
       You can compose these middleware components in the
      
      
       
        desired order:
       
      
     </p>
     <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
<strong class="bold">app.UseMiddleware&lt;ErrorHandlingMiddleware&gt;();</strong>
<strong class="bold">app.UseMiddleware&lt;AuthenticationMiddleware&gt;();</strong>
<strong class="bold">app.UseMiddleware&lt;RequestLoggingMiddleware&gt;();</strong>
<strong class="bold">app.Run(async context =&gt;</strong>
{
    await context.Response.WriteAsync("Hello,
      World!");
});
app.Run();</pre>
     <p class="list-inset">
      
       As you can see in
      
      <a id="_idIndexMarker651">
      </a>
      
       the preceding code, the
      
      <strong class="source-inline">
       
        app.UseMiddleware
       
      </strong>
      
       method adds middleware to handle errors, authentication, and logging in the application.
      
      
       The
      
      <strong class="source-inline">
       
        app.Run
       
      </strong>
      
       method just creates a standard request response, returning a
      
      <strong class="source-inline">
       
        Hello
       
      </strong>
      
       <strong class="source-inline">
        
         World
        
       </strong>
      
      
       
        message.
       
      
     </p>
     <p class="list-inset">
      
       It is important to consider the
      
      
       
        following factors:
       
      
     </p>
     <ul>
      <li>
       
        If you want to rearrange the order of these middleware components, the way requests are processed and errors are handled will
       
       
        
         be different.
        
       
      </li>
      <li>
       <strong class="bold">
        
         SoC (Separation of concerns)
        
       </strong>
       
        : Middleware allows for a clear separation of different concerns, enabling the
       
       <a id="_idIndexMarker652">
       </a>
       
        definition of a clear execution context in a pipeline and facilitating a clearer, extensible, and maintainable
       
       
        
         code base.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Extensibility
        
       </strong>
       
        : You can develop a custom middleware to extend the application’s functionality – for example, by adding validation capabilities to requests or modifying responses globally within
       
       
        
         the application.
        
       
      </li>
     </ul>
     <p class="list-inset">
      
       Suppose you need custom middleware to validate an API key in request headers.
      
      
       You can create this middleware
      
      
       
        as follows:
       
      
     </p>
     <pre class="source-code">public class ApiKeyCheckMiddleware
{
    private readonly RequestDelegate _next;
    <strong class="bold">private const string API_KEY = "X-API-KEY";</strong>
<strong class="bold">    private const string VALID_API_KEY = "XYZ123";</strong>
    public ApiKeyCheckMiddleware(RequestDelegate next)
    {
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        if (!context.Request.Headers
          .TryGetValue(API_KEY,
          out var extractedApiKey) ||
          extractedApiKey != VALID_API_KEY)
        {
            <strong class="bold">context.Response.StatusCode = 401;</strong>
<strong class="bold">            await context.Response</strong>
<strong class="bold">              .WriteAsync("Unauthorized");</strong>
            return;
        }
        await _next(context);
    }
}</pre>
     <p class="list-inset">
      
       The preceding
      
      <a id="_idIndexMarker653">
      </a>
      
       code aims to create a customized middleware that checks the existence of an API key that must be provided in the header of a request, where the header key is
      
      <strong class="source-inline">
       
        X-API-KEY
       
      </strong>
      
       and the expected value is,
      
      
       
        exactly,
       
      
      
       <strong class="source-inline">
        
         XYZ123
        
       </strong>
      
      
       
        .
       
      
     </p>
     <p class="list-inset">
      
       When performing validation, if the header and value are not part of the request, then the user receives an
      
      <strong class="source-inline">
       
        unauthorized
       
      </strong>
      
       return message with HTTP status
      
      
       
        code
       
      
      
       <strong class="source-inline">
        
         401
        
       </strong>
      
      
       
        .
       
      
     </p>
    </li>
   </ul>
   <p>
    
     In fact, middleware is a powerful feature that allows you to have greater control over the flow of requests and responses in an application developed in ASP.NET
    
    
     
      Core 9.
     
    
   </p>
   <p>
    
     Don’t worry about the details related to the preceding code examples.
    
    
     We will learn about the structure of a middleware class in the
    
    <em class="italic">
     
      Implementing custom
     
    </em>
    
     <em class="italic">
      
       middleware
      
     </em>
    
    
     
      section.
     
    
   </p>
   <p>
    
     Despite the great
    
    <a id="_idIndexMarker654">
    </a>
    
     benefits of applications using middleware, it is important to be aware of good practices; otherwise, what could be a benefit could become a
    
    
     
      major problem.
     
    
   </p>
   <p>
    
     Let’s look at some
    
    <a id="_idIndexMarker655">
    </a>
    
     
      best practices:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Order matters
      
     </strong>
     
      : The order in which middleware components are added is crucial as it affects how requests and responses
     
     
      
       are processed.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Keep it simple
      
     </strong>
     
      : Middleware should do one thing and do it well.
     
     
      Complex logic should be avoided
     
     
      
       in middleware.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Error handling
      
     </strong>
     
      : Make sure your middleware components handle exceptions and errors in the same way as other classes in
     
     
      
       your application.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Performance
      
     </strong>
     
      : Be aware of the impact of middleware on performance, especially in high-load scenarios.
     
     
      As it operates in request and response processes, avoid large amounts of processing during these stages to avoid causing problems for users and
     
     
      
       the application.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Reuse existing middleware
      
     </strong>
     
      : Use built-in middleware whenever possible to reduce the need for custom implementations.
     
     
      As we have already learned, there is some middleware available in ASP.NET
     
     
      
       Core 9.
      
     
    </li>
   </ul>
   <p>
    
     Now that we understand the principles, benefits, and best practices of middleware, let’s implement our first custom middleware and learn the details of
    
    
     
      this approach.
     
    
   </p>
   <h1 id="_idParaDest-137">
    <a id="_idTextAnchor138">
    </a>
    
     Implementing custom middleware
    
   </h1>
   <p>
    
     Custom middleware
    
    <a id="_idIndexMarker656">
    </a>
    
     allows you to encapsulate functionality and reuse it in different parts of
    
    
     
      your application.
     
    
   </p>
   <p>
    
     Creating custom middleware in
    
    <a id="_idIndexMarker657">
    </a>
    
     ASP.NET Core 9 involves several steps, such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Middleware
     
     
      
       class definition
      
     
    </li>
    <li>
     
      The implementation of the
     
     <strong class="source-inline">
      
       Invoke
      
     </strong>
     
      or
     
     
      <strong class="source-inline">
       
        InvokeAsync
       
      </strong>
     
     
      
       method
      
     
    </li>
    <li>
     
      Middleware registration in the
     
     
      
       request pipeline
      
     
    </li>
   </ul>
   <p>
    
     Let’s analyze the following code, which represents a
    
    
     
      customized middleware:
     
    
   </p>
   <pre class="source-code">
public class BeforeAfterRequestMiddleware
{
<strong class="bold">  private readonly RequestDelegate _next;</strong>
  public <strong class="bold">BeforeAfterRequestMiddleware(RequestDelegate next)</strong>
  {
  _next = next;
  }
<strong class="bold">  public async Task InvokeAsync(HttpContext context)</strong>
  {
    // Logging request information
    Console.WriteLine($"Request:
      {context.Request.Method}
      {context.Request.Path}");
    // Call the next middleware in the pipeline
<strong class="bold">    await _next(context);</strong>
    // Logging response information
    Console.WriteLine($"Response:
      {context.Response.StatusCode}");
  }
}</pre>
   <p>
    
     This custom middleware
    
    <a id="_idIndexMarker658">
    </a>
    
     code aims to just write a string to the console at the beginning and in the response of
    
    
     
      the request.
     
    
   </p>
   <p>
    
     However, it is important to understand the structure of the
    
    
     
      preceding code:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       RequestDelegate
      
     </strong>
     
      : This is a delegate that represents the next middleware in the pipeline.
     
     
      This delegate is stored in a field called
     
     <strong class="source-inline">
      
       _next
      
     </strong>
     
      for use in the context of
     
     
      
       the class.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Constructor
      
     </strong>
     
      : The class constructor receives an instance of the
     
     <strong class="source-inline">
      
       RequestDelegate
      
     </strong>
     
      class as a parameter, representing the next middleware in the
     
     
      
       execution flow.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Invoke
      
     </strong>
     
      or
     
     <strong class="source-inline">
      
       InvokeAsync
      
     </strong>
     
      method: Contains the logic for processing HTTP requests.
     
     
      The difference between the methods is that one is executed asynchronously and the other is not.
     
     
      The
     
     <strong class="source-inline">
      
       InvokeAsync
      
     </strong>
     
      method receives an
     
     <strong class="source-inline">
      
       HttpContext
      
     </strong>
     
      object as a parameter.
     
     
      The
     
     <strong class="source-inline">
      
       HttpContext
      
     </strong>
     
      object allows you to access request and response information.
     
     
      It is a good practice to use the
     
     <strong class="source-inline">
      
       InvokeAsync
      
     </strong>
     
      method to improve performance
     
     
      
       and scalability.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       await _next(context)
      
     </strong>
     
      : Execution of the
     
     <strong class="source-inline">
      
       _next
      
     </strong>
     
      delegate, which receives the
     
     <strong class="source-inline">
      
       HttpContext
      
     </strong>
     
      object as a parameter.
     
     
      In this example, we are just writing a string containing request information before propagating the execution of the next middleware, and then another string is written with response information after executing
     
     
      
       the middleware.
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Dependency injection (DI) in middleware
    
   </p>
   <p class="callout">
    
     Custom middleware
    
    <a id="_idIndexMarker659">
    </a>
    
     classes must use the
    
    <strong class="bold">
     
      Explicit Dependencies Principle
     
    </strong>
    
     (
    
    <strong class="bold">
     
      EDP
     
    </strong>
    
     ), as
    
    <a id="_idIndexMarker660">
    </a>
    
     we have already learned in previous chapters, where the dependencies of a class are defined in
    
    
     
      the constructor.
     
    
   </p>
   <p class="callout">
    
     As middleware is built during application initialization, it is not possible to inject services added to a scoped lifetime as is done with each request in a
    
    <strong class="source-inline">
     
      Controller
     
    </strong>
    
     class,
    
    
     
      for example.
     
    
   </p>
   <p class="callout">
    
     So, if you want to use any services available in DI control in a middleware class, add these services to the signature of the
    
    <strong class="source-inline">
     
      InvokeAsync
     
    </strong>
    
     method, which can accept additional parameters resolved
    
    
     
      by DI.
     
    
   </p>
   <p>
    
     The previous code example, although simple, demonstrates the basic structure of a middleware, which requires a
    
    <strong class="source-inline">
     
      RequestDelegated
     
    </strong>
    
     field, a constructor that depends on an instance of
    
    <strong class="source-inline">
     
      RequestDelegated
     
    </strong>
    
     , and the implementation of the
    
    <strong class="source-inline">
     
      Invoke
     
    </strong>
    
     or
    
    
     <strong class="source-inline">
      
       InvokeAsync
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <p>
    
     For the customized middleware to be used in the application, it is necessary to register it in the ASP.NET Core 9 execution pipeline through the
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
<strong class="bold">app.UseMiddleware&lt;BeforeAfterRequestMiddleware&gt;();</strong>
app.Run(async context =&gt;
{
    await context.Response.WriteAsync("Hello, World!");
});
app.Run();</pre>
   <p>
    
     The preceding code has been shortened to make it easier to read and learn.
    
    
     For the middleware to be registered, the
    
    <strong class="source-inline">
     
      UseMiddleware
     
    </strong>
    
     extension method is used, which is a generic method, where we define the previously executed custom middleware as
    
    
     
      the type.
     
    
   </p>
   <p>
    
     During the application
    
    <a id="_idIndexMarker661">
    </a>
    
     startup flow, all custom or non-customized middleware is created, forming part of the application lifecycle, and not by request, as is generally done in scoped services.
    
    
     This behavior prevents other dependencies from being added to the constructor of a custom middleware class but allows the addition of dependencies with parameters through the
    
    <strong class="source-inline">
     
      Invoke
     
    </strong>
    
     and
    
    
     <strong class="source-inline">
      
       InvokeAsync
      
     </strong>
    
    
     
      methods.
     
    
   </p>
   <p class="callout-heading">
    
     Obtaining HTTP context objects in middleware
    
   </p>
   <p class="callout">
    
     As an alternative to using
    
    <a id="_idIndexMarker662">
    </a>
    
     DI in the
    
    <strong class="source-inline">
     
      InvokeAsync
     
    </strong>
    
     method, it is possible to use the
    
    <strong class="source-inline">
     
      context.RequestService
     
    </strong>
    
     property (
    
    <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.requestservices?view=aspnetcore-9.0">
     
      https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.requestservices?view=aspnetcore-9.0
     
    </a>
    
     ), as shown in the
    
    
     
      following code:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      public async Task
     
    </strong>
    
     <strong class="source-inline">
      
       InvokeAsync(HttpContext context)
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      var logger =
     
    </strong>
    
     <strong class="source-inline">
      
       context.RequestServices
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      .
     
    </strong>
    
     <strong class="source-inline">
      
       GetRequiredService&lt;Ilogger
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      &lt;
     
    </strong>
    
     <strong class="source-inline">
      
       BeforeAfterRequestMiddleware &gt;&gt;();
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
     
    </strong>
    
     <strong class="source-inline">
      
       logger.LogInformation($"Request:{context.Request.Method}
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
    
     <strong class="source-inline">
      
       context.Request.Path}");
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
     
    </strong>
    
     <strong class="source-inline">
      
       await _next(context);
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
     
    </strong>
    
     <strong class="source-inline">
      
       logger.LogInformation($"Response:
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
    
     <strong class="source-inline">
      
       context.Response.StatusCode}");
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    
     However, this somewhat decreases dependency visibility
    
    
     
      in code.
     
    
   </p>
   <p>
    
     However, ASP.NET Core 9 offers an approach to enabling the use of custom middleware on a per-request basis using factory-based middleware, which we will discuss in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-138">
    <a id="_idTextAnchor139">
    </a>
    
     Working with factory-based middleware
    
   </h1>
   <p>
    
     Another way
    
    <a id="_idIndexMarker663">
    </a>
    
     to create custom middleware is by using the factory-based approach, which offers better performance and flexibility
    
    
     
      using DI.
     
    
   </p>
   <p>
    
     This approach is particularly useful when the middleware requires
    
    
     
      scoped services.
     
    
   </p>
   <p>
    
     Factory-based middleware uses the
    
    <strong class="source-inline">
     
      IMiddleware
     
    </strong>
    
     interface, which allows the middleware to be activated by
    
    <a id="_idIndexMarker664">
    </a>
    
     the
    
    <strong class="bold">
     
      DI
     
    </strong>
    
     <strong class="bold">
      
       container
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       DIC
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      IMiddleware
     
    </strong>
    
     interface has only one
    
    <strong class="source-inline">
     
      InvokeAsync
     
    </strong>
    
     method that must be implemented in the class.
    
    
     The structure of a customized middleware that uses the factory-based approach is very similar to the traditional approach learned in the
    
    
     
      previous section.
     
    
   </p>
   <p>
    
     Let’s look at a
    
    
     
      code example:
     
    
   </p>
   <pre class="source-code">
public class RequestLimitingMiddleware : IMiddleware
{
  private readonly ILogger
    &lt;RequestLimitingMiddleware&gt; _logger;
  <strong class="bold">public RequestLimitingMiddleware</strong>
<strong class="bold">    (ILogger&lt;RequestLimitingMiddleware&gt; logger)</strong>
  {
    _logger = logger;
  }
  public async Task InvokeAsync(HttpContext context,
    <strong class="bold">RequestDelegate next</strong>)
  {
    // Logic to limit the number of requests
    _logger.LogInformation("Processing request");
    await next(context);
  }
}</pre>
   <p>
    
     The big difference with the factory-based approach is the definition of a dependency in the class constructor instead of declaring it as a parameter in the
    
    <strong class="source-inline">
     
      InvokeAsync
     
    </strong>
    
     method.
    
    
     In the preceding code example, the constructor has a dependency on an
    
    
     <strong class="source-inline">
      
       ILogger
      
     </strong>
    
    
     
      interface.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      InvokeAsync
     
    </strong>
    
     method must only have two parameters,
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       RequestDelegate
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Now, let’s look at custom middleware registration, using the factory-based approach, by analyzing
    
    <a id="_idIndexMarker665">
    </a>
    
     the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     
      class code:
     
    
   </p>
   <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
<strong class="bold">builder.Services.AddScoped&lt;RequestLimitingMiddleware&gt;();</strong>
var app = builder.Build();
<strong class="bold">app.UseMiddleware&lt;RequestLimitingMiddleware&gt;();</strong>
app.Run(async context =&gt;
{
    await context.Response.WriteAsync("Hello, World!");
});
app.Run();</pre>
   <p>
    
     Middleware registration is done using the
    
    <strong class="source-inline">
     
      app.UseMiddleware
     
    </strong>
    
     method, as we have already learned.
    
    
     However, note that the
    
    <strong class="source-inline">
     
      RequestLimitingMiddleware
     
    </strong>
    
     class is added to the scoped lifetime through the
    
    <strong class="source-inline">
     
      builder.Services.AddScoped&lt;RequestLimitingMiddleware&gt;()
     
    </strong>
    
     code with the lifecycle managed
    
    
     
      per request.
     
    
   </p>
   <p class="callout-heading">
    
     Service lifetimes
    
   </p>
   <p class="callout">
    
     ASP.NET Core 9 offers different types of
    
    <a id="_idIndexMarker666">
    </a>
    
     service lifetimes; you can learn more
    
    
     
      at
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#service-lifetimes">
     
      
       https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#service-lifetimes
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     As we can see, the factory-based approach allows us to use DIC resources and manage the middleware lifecycle
    
    
     
      by request.
     
    
   </p>
   <p>
    
     Whether to use a
    
    <a id="_idIndexMarker667">
    </a>
    
     factory-based or the traditional approach depends, of course, on the application requirements.
    
    
     However, both are powerful solutions that add precious features to
    
    
     
      our applications.
     
    
   </p>
   <p>
    
     In the next section, we will create and use some common middleware used in
    
    
     
      many applications.
     
    
   </p>
   <h1 id="_idParaDest-139">
    <a id="_idTextAnchor140">
    </a>
    
     Adding capabilities to applications using middleware
    
   </h1>
   <p>
    
     Now that we have knowledge about the features and possibilities of middleware, we will work on some capabilities that will bring greater quality to our
    
    
     
      web applications.
     
    
   </p>
   <p>
    
     There is no strict standard directory structure or namespace for creating middleware classes.
    
    
     However, it is good practice to organize classes into
    
    
     
      well-defined namespaces.
     
    
   </p>
   <p>
    
     For this example, we will default to creating a folder called
    
    <strong class="source-inline">
     
      Middlewares
     
    </strong>
    
     in the root of your
    
    
     
      application project.
     
    
   </p>
   <p>
    
     In this section, we will focus on the
    
    
     
      following middleware:
     
    
   </p>
   <ul>
    <li>
     
      Global
     
     
      
       error handling
      
     
    </li>
    <li>
     
      Adding request logging – logging
     
     
      
       request information
      
     
    </li>
    <li>
     
      Rate limiting – defining request limits in
     
     
      
       your application
      
     
    </li>
   </ul>
   <p>
    
     The project containing the classes mentioned in the preceding list is available in the book repository, the link to which can be found in the
    
    <em class="italic">
     
      Technical
     
    </em>
    
     <em class="italic">
      
       requirements
      
     </em>
    
    
     
      section.
     
    
   </p>
   <p>
    
     Let’s create a new application.
    
    
     Open the terminal, and in a folder of your choice, create a project with the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet new mvc -n CommonMiddlewares</pre>
   <p>
    
     Then, in the root of the directory, create a folder
    
    
     
      called
     
    
    
     <strong class="source-inline">
      
       Middlewares
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Now, we will start creating the first middleware: global
    
    
     
      error handling.
     
    
   </p>
   <h2 id="_idParaDest-140">
    <a id="_idTextAnchor141">
    </a>
    
     Global error handling
    
   </h2>
   <p>
    
     During the execution flow of an
    
    <a id="_idIndexMarker668">
    </a>
    
     application, errors or exceptions may arise
    
    <a id="_idIndexMarker669">
    </a>
    
     that, if not handled correctly, may cause inconvenience
    
    
     
      to users.
     
    
   </p>
   <p>
    
     In this case, we must handle errors in our code to prevent exceptions from causing applications
    
    
     
      to malfunction.
     
    
   </p>
   <p>
    
     To achieve this, a good practice is to use a global error-handling middleware that makes it possible to manage the application’s exception flow in a centralized manner, even allowing it to extend its functionality by adding logs in different monitoring tools, which is essential for
    
    
     
      error corrections.
     
    
   </p>
   <p>
    
     Create a file called
    
    <strong class="source-inline">
     
      ErrorHandlingMiddleware.cs
     
    </strong>
    
     in the
    
    <strong class="source-inline">
     
      Middlewares
     
    </strong>
    
     folder you created earlier and add the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
public class ErrorHandlingMiddleware
{
  private readonly RequestDelegate _next;
  public ErrorHandlingMiddleware(RequestDelegate next)
  {
    _next = next;
  }
  public async Task InvokeAsync(HttpContext context)
  {
    try
    {
      await _next(context);
    }
    catch (Exception ex)
    {
      <strong class="bold">await HandleExceptionAsync(context, ex);</strong>
    }
  }
  private Task <strong class="bold">HandleExceptionAsync(HttpContext context,</strong>
<strong class="bold">    Exception exception)</strong>
  {
    context.Response.ContentType = "application/json";
    context.Response.StatusCode = (int)HttpStatusCode
      .InternalServerError;
    return context.Response.WriteAsync(new <strong class="bold">ErrorDetails()</strong>
    {
      StatusCode = context.Response.StatusCode,
      Message = "Internal Server Error from the custom middleware."
    }.ToString());
  }
}
public class ErrorDetails
{
  public int StatusCode { get; set; }
  public string Message { get; set; }
  public override string ToString()
  {
    return JsonSerializer.Serialize(this);
  }
}</pre>
   <p>
    
     We can see in the
    
    <a id="_idIndexMarker670">
    </a>
    
     preceding code the common structure of a middleware.
    
    
     The
    
    <a id="_idIndexMarker671">
    </a>
    
     great functionality of this global error-handling middleware is the use of the
    
    <strong class="source-inline">
     
      try
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      catch
     
    </strong>
    
     block, in the body of the
    
    
     <strong class="source-inline">
      
       InvokeAsync
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      await _next(context)
     
    </strong>
    
     command is executed in a
    
    <strong class="source-inline">
     
      try
     
    </strong>
    
     block so that if there is an exception in the application, it will be handled globally.
    
    
     Exception handling is done through the
    
    <strong class="source-inline">
     
      HandleExceptionAsync
     
    </strong>
    
     method, called in the
    
    
     <strong class="source-inline">
      
       catch
      
     </strong>
    
    
     
      block.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      HandleExceptionAsync
     
    </strong>
    
     method modifies the request response by changing the
    
    <strong class="source-inline">
     
      StatusCode
     
    </strong>
    
     property to Internal Server Error,
    
    <strong class="bold">
     
      HTTP status code 500
     
    </strong>
    
     , in addition to returning an object in the request body.
    
    
     This object is
    
    <a id="_idIndexMarker672">
    </a>
    
     represented by the
    
    <strong class="source-inline">
     
      ErrorDetails
     
    </strong>
    
     class, which has the
    
    <strong class="source-inline">
     
      StatusCode
     
    </strong>
    
     and
    
    
     
      Message properties.
     
    
   </p>
   <p>
    
     Therefore, in addition to guaranteeing the handling of any exception in the application, there is a customized, but common, return that can be used appropriately for handling in a UI, allowing a better experience for the developers and also for the users of
    
    
     
      the application.
     
    
   </p>
   <p class="callout-heading">
    
     Problems Details in ASP.NET Core 9
    
   </p>
   <p class="callout">
    
     ASP.NET Core 9 provides built-in support for Problem Details, a standardized format for error responses based on RFC 7807 (https://datatracker.ietf.org/doc/html/rfc7807).
    
    
     By incorporating Trace ID into the response, developers can enhance debugging and
    
    
     
      error tracking.
     
    
   </p>
   <p class="callout">
    
     A Problem Details response with a Trace ID looks
    
    
     
      like this:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      "
     
    </strong>
    
     <strong class="source-inline">
      
       type": "https://example.com/probs/server-error",
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      "title": "An unexpected
     
    </strong>
    
     <strong class="source-inline">
      
       error occurred.",
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      "
     
    </strong>
    
     <strong class="source-inline">
      
       status": 500,
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      "detail": "The system encountered
     
    </strong>
    
     <strong class="source-inline">
      
       an issue.",
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      "
     
    </strong>
    
     <strong class="source-inline">
      
       instance": "/example-path",
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      "
     
    </strong>
    
     <strong class="source-inline">
      
       traceId": "00-abcdef1234567890abcdef1234567890-1234567890abcdef-01"
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      ProblemDetails
     
    </strong>
    
     class can be used in conjunction with the Middleware following the following implementation example, changing the
    
    <strong class="source-inline">
     
      HandleExceptionAsync
     
    </strong>
    
     method of the
    
    
     <strong class="source-inline">
      
       ErrorHandlingMiddleware
      
     </strong>
    
    
     
      class:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      private static Task HandleExceptionAsync(HttpContext context,
     
    </strong>
    
     <strong class="source-inline">
      
       Exception exception)
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      var traceId = Activity.Current?.Id ??
     
    </strong>
    
     <strong class="source-inline">
      
       context.TraceIdentifier;
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      var problemDetails =
     
    </strong>
    
     <strong class="source-inline">
      
       new ProblemDetails
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      Type = "
     
    </strong>
    
     <strong class="source-inline">
      
       server-error",
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      Title = "An unexpected
     
    </strong>
    
     <strong class="source-inline">
      
       error occurred.",
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      Status =
     
    </strong>
    
     <strong class="source-inline">
      
       StatusCodes.Status500InternalServerError,
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      Detail = “Internal Server Error from the
     
    </strong>
    
     <strong class="source-inline">
      
       custom middleware.”,
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      Instance =
     
    </strong>
    
     <strong class="source-inline">
      
       context.Request.Path
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      };
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      // Include the Trace ID in the
     
    </strong>
    
     <strong class="source-inline">
      
       Problem Details.
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      problemDetails.Extensions["traceId"] =
     
    </strong>
    
     <strong class="source-inline">
      
       traceId;
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      context.Response.ContentType = "
     
    </strong>
    
     <strong class="source-inline">
      
       application/problem+json";
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      context.Response.StatusCode =
     
    </strong>
    
     <strong class="source-inline">
      
       StatusCodes.Status500InternalServerError;
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
     
    </strong>
    
     <strong class="source-inline">
      
       return context.Response.WriteAsJsonAsync(problemDetails);
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    
     The preceding code is a customization of the Global Error Handler implemented through Middleware.
    
    
     In addition to using the
    
    <strong class="source-inline">
     
      ProblemDetails
     
    </strong>
    
     class, code is added to obtain the trace
    
    
     
      id value:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      var traceId = Activity.Current?.Id ??
     
    </strong>
    
     <strong class="source-inline">
      
       context.TraceIdentifier;
      
     </strong>
    
   </p>
   <p class="callout">
    
     Then, the trace ID is added to the extensions of the
    
    
     
      object ProblemdDetails&gt;:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      problemDetails.Extensions["traceId"] =
     
    </strong>
    
     <strong class="source-inline">
      
       traceId;
      
     </strong>
    
   </p>
   <p class="callout">
    
     The trace ID is excellent information that should be part of the application Log, facilitating the correlation between error responses to
    
    
     
      resolve issues.
     
    
   </p>
   <p class="callout">
    
     ASP.NET Core 9 also has alternatives for error handling that you can learn more about at the following
    
    
     
      URL:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors?view=aspnetcore-9.0">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors?view=aspnetcore-9.0
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Using global
    
    <a id="_idIndexMarker673">
    </a>
    
     error handling brings an excellent benefit to applications, and, in
    
    <a id="_idIndexMarker674">
    </a>
    
     addition, some log writing strategies could be used in cloud monitoring tools, in the terminal, or even in files, facilitating
    
    
     
      problem resolution.
     
    
   </p>
   <p>
    
     The log functionality can be used for other purposes, not just to handle errors.
    
    
     Let’s analyze another middleware approach for
    
    
     
      logging requests.
     
    
   </p>
   <h2 id="_idParaDest-141">
    <a id="_idTextAnchor142">
    </a>
    
     Adding request logging
    
   </h2>
   <p>
    
     Every web application has a
    
    <a id="_idIndexMarker675">
    </a>
    
     constant flow of communication and processing of
    
    <a id="_idIndexMarker676">
    </a>
    
     requests that generate different types of information, as well as exceptions that must be handled, and we took care of this scenario when creating global error-handling middleware in the
    
    
     
      previous section.
     
    
   </p>
   <p>
    
     In addition to handling errors and exceptions, we must log this information to be able to carry out effective troubleshooting.
    
    
     However, in many cases, it is necessary to log information processed during the request and response flow of an application.
    
    
     This approach offers
    
    
     
      several benefits:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Centralized logging
      
     </strong>
     
      : Centralize logging logic, ensuring all requests are logged consistently in a single location in
     
     
      
       the pipeline
      
     
    </li>
    <li>
     <strong class="bold">
      
       Request tracking
      
     </strong>
     
      : The ability to trace all requests is useful for monitoring application performance, debugging issues, and understanding
     
     
      
       user behavior
      
     
    </li>
    <li>
     <strong class="bold">
      
       Security and auditing
      
     </strong>
     
      : By logging requests, you can maintain an audit trail of access to your application, which is essential for
     
     
      
       security compliance
      
     
    </li>
    <li>
     <strong class="bold">
      
       Error diagnosis
      
     </strong>
     
      : When problems arise, logs can help you diagnose and troubleshoot problems by providing a detailed history of the request activity that led to
     
     
      
       an error
      
     
    </li>
    <li>
     <strong class="bold">
      
       Performance monitoring
      
     </strong>
     
      : Logging the time it takes to process requests can help identify performance bottlenecks and optimize
     
     
      
       application performance
      
     
    </li>
    <li>
     <strong class="bold">
      
       Flexibility
      
     </strong>
     
      : The middleware can be configured to log only certain types of requests or responses, providing flexibility in how logging
     
     
      
       is implemented
      
     
    </li>
   </ul>
   <p>
    
     Let’s look at an example of middleware responsible for logging request data into the application.
    
    
     To do this, create a class called
    
    <strong class="source-inline">
     
      PerformanceLoggingMiddleware.cs
     
    </strong>
    
     in
    
    <a id="_idIndexMarker677">
    </a>
    
     the
    
    <strong class="source-inline">
     
      Middlewares
     
    </strong>
    
     folder and
    
    <a id="_idIndexMarker678">
    </a>
    
     add the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
public class PerformanceLoggingMiddleware
{
  private readonly RequestDelegate _next;
  public PerformanceLoggingMiddleware(RequestDelegate next)
  {
    _next = next;
  }
  public async Task InvokeAsync(HttpContext context,
    <strong class="bold">ILogger&lt;PerformanceLoggingMiddleware&gt; logger</strong>)
  {
    <strong class="bold">var timestamp = Stopwatch.GetTimestamp();</strong>
    await _next(context);
    var elapsedMilliseconds = Stopwatch
      .GetElapsedTime(timestamp).TotalMilliseconds;
    <strong class="bold">logger.LogInformation("Request {Method} {Path}</strong>
<strong class="bold">      took {ElapsedMilliseconds} ms",</strong>
<strong class="bold">      context.Request.Method, context.Request.Path,</strong>
<strong class="bold">      elapsedMilliseconds)</strong>;
  }
}</pre>
   <p>
    
     The preceding code
    
    <a id="_idIndexMarker679">
    </a>
    
     aims to record the execution time of a request.
    
    
     This is an
    
    <a id="_idIndexMarker680">
    </a>
    
     interesting approach to measuring the limits of your application and allowing you to improve the performance of
    
    
     
      your implementation.
     
    
   </p>
   <p>
    
     When analyzing the code, we have
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       DI
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       InvokeAsync
      
     </strong>
     
      method accepts an
     
     <strong class="source-inline">
      
       ILogger&lt;PerformanceLoggingMiddleware&gt;
      
     </strong>
     
      parameter, which is provided
     
     
      
       by DI
      
     
    </li>
    <li>
     <strong class="bold">
      
       Log request metrics
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       InvokeAsync
      
     </strong>
     
      method uses the
     
     <strong class="source-inline">
      
       ILogger
      
     </strong>
     
      instance to log the HTTP method, request path, and time taken to process
     
     
      
       the request
      
     
    </li>
    <li>
     <strong class="bold">
      
       Collecting the request execution time
      
     </strong>
     
      : Before executing the request, use the
     
     <strong class="source-inline">
      
       GetTimestamp()
      
     </strong>
     
      static method of the
     
     <strong class="source-inline">
      
       Stopwatch
      
     </strong>
     
      object to get the
     
     
      
       initial timestamp
      
     
     <p class="list-inset">
      
       After executing the request through the
      
      <strong class="source-inline">
       
        _await _next(context)
       
      </strong>
      
       request delegation, the
      
      <strong class="source-inline">
       
        Stop
       
      </strong>
      
       method of the
      
      <strong class="source-inline">
       
        Stopwatch
       
      </strong>
      
       object is used to end
      
      
       
        the timer.
       
      
     </p>
     <p class="list-inset">
      
       A log is then created containing information about the request, such as the method, path, and execution time in milliseconds, obtained from the
      
      <strong class="source-inline">
       
        Stopwatch
       
      </strong>
      
       class throughout the
      
      
       <strong class="source-inline">
        
         GetElapsedTime(timestamp).TotalMilliseconds
        
       </strong>
      
      
       
        method.
       
      
     </p>
    </li>
   </ul>
   <p class="callout-heading">
    
     The Stopwatch class
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      Stopwatch
     
    </strong>
    
     class in .NET is a high-resolution timer provided by the
    
    <strong class="source-inline">
     
      System.Diagnostics
     
    </strong>
    
     namespace.
    
    
     It is used to measure elapsed time with great precision, making it ideal for performance measurement and benchmarking tasks.
    
    
     Get more information about the features available in
    
    <strong class="source-inline">
     
      Stopwatch
     
    </strong>
    
     through the
    
    
     
      documentation:
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.stopwatch?view=net-9.0">
     
      
       https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.stopwatch?view=net-9.0
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     As we can see when
    
    <a id="_idIndexMarker681">
    </a>
    
     implementing customized logs such as
    
    <strong class="source-inline">
     
      PerformanceLoggingMiddleware
     
    </strong>
    
     , creating customized middleware enhances the
    
    <a id="_idIndexMarker682">
    </a>
    
     functionalities of our applications, helping both the experience of users who consume quality applications and supporting teams in maintenance processes, diagnostics, and also
    
    
     
      application evolution.
     
    
   </p>
   <p>
    
     However, ASP.NET Core 9 provides some middleware capable of dealing with several other important aspects of an application’s execution flow, such as rate limiting, which we will understand in the
    
    
     
      next section.
     
    
   </p>
   <h2 id="_idParaDest-142">
    <a id="_idTextAnchor143">
    </a>
    
     Rate limiting
    
   </h2>
   <p>
    
     The rate-limiting
    
    <a id="_idIndexMarker683">
    </a>
    
     middleware
    
    <a id="_idIndexMarker684">
    </a>
    
     in ASP.NET Core 9 is a powerful feature that is essential for protecting applications from abuse and improving overall performance and reliability.
    
    
     This middleware controls the number of requests a client can make to a server within a specified period
    
    
     
      of time.
     
    
   </p>
   <p>
    
     Using the rate-limiting middleware in ASP.NET Core 9 is done by adding the configuration in the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file.
    
    
     The following is a
    
    
     
      step-by-step guide:
     
    
   </p>
   <ol>
    <li>
     
      Add the required
     
     
      
       NuGet packages.
      
     
    </li>
    <li>
     
      Register the middleware in the HTTP
     
     
      
       request pipeline.
      
     
    </li>
    <li>
     
      Add rate-limiting middleware to the pipeline.
     
     
      Rate-limiting middleware is included
     
     
      
       in
      
     
     
      <strong class="source-inline">
       
        Microsoft.AspNetCore.RateLimiting
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     Let’s see an example of implementation in a Razor Pages-type application using the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
<strong class="bold">using Microsoft.AspNetCore.RateLimiting;</strong>
using System.Threading.RateLimiting;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddRazorPages();
// Configure rate limiting policies
<strong class="bold">builder.Services.AddRateLimiter(</strong>options =&gt;
{
  options.AddPolicy("fixed", context =&gt;
    RateLimitPartition.GetFixedWindowLimiter(new
    RateLimitPartitionKey(context.Request
    .Headers["X-Forwarded-For"].ToString(),
    PartitionKeyKind.ClientIP), partition =&gt;
      new FixedWindowRateLimiterOptions
      {
        PermitLimit = 5,
        Window = TimeSpan.FromMinutes(1),
        QueueProcessingOrder = QueueProcessingOrder
          .OldestFirst,
          QueueLimit = 2
      }));
  options.AddPolicy("sliding", context =&gt;
    RateLimitPartition.GetSlidingWindowLimiter(new
    RateLimitPartitionKey(context.Request
    .Headers["X-Forwarded-For"].ToString(),
    PartitionKeyKind.ClientIP), partition =&gt;
      new SlidingWindowRateLimiterOptions
      {
        PermitLimit = 5,
        Window = TimeSpan.FromMinutes(1),
          SegmentsPerWindow = 3,
        QueueProcessingOrder = QueueProcessingOrder
          .OldestFirst,
          QueueLimit = 2
      }));
  options.AddPolicy("tokenBucket", context =&gt;
    RateLimitPartition.GetTokenBucketLimiter(new
    RateLimitPartitionKey(context.Request
    .Headers["X-Forwarded-For"].ToString(),
    PartitionKeyKind.ClientIP), partition =&gt;
      new TokenBucketRateLimiterOptions
      {
        TokenLimit = 10,
        TokensPerPeriod = 5,
        ReplenishmentPeriod = TimeSpan.FromSeconds(10),
        QueueProcessingOrder = QueueProcessingOrder
          .OldestFirst,
          QueueLimit = 2
      }));
});
var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
// Use rate limiting middleware
<strong class="bold">app.UseRateLimiter();</strong>
app.MapRazorPages();
app.Run();</pre>
   <p>
    
     Now, let’s analyze the
    
    <a id="_idIndexMarker685">
    </a>
    
     important aspects of the
    
    
     
      preceding
     
    
    
     <a id="_idIndexMarker686">
     </a>
    
    
     
      code:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       builder.Services.AddRateLimiter
      
     </strong>
     
      : Required to define the rate limit policies that will be used in this application.
     
     
      Each policy uses a unique client identifier, adding the
     
     <strong class="source-inline">
      
       X-Forwarded-For
      
     </strong>
     
      HTTP header, to enforce limits per client IP address.
     
     
      In the previous code, we configured three policies – namely,
     
     
      
       the following:
      
     
     <ul>
      <li>
       <strong class="bold">
        
         Fixed window
        
       </strong>
       
        : Limits requests to 5 per minute.
       
       
        Once the limit is reached, no further requests will be allowed until the window
       
       
        
         is reset.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Sliding window
        
       </strong>
       
        : Similar to the fixed window policy, but divides the window into segments, allowing for a more distributed request margin
       
       
        
         per minute.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Token bucket
        
       </strong>
       
        : Allows you to make up to 10 tokens (requests) available, with 5 new tokens replenished every 10 seconds.
       
       
        If tokens run out, incoming requests will
       
       
        
         be queued.
        
       
      </li>
     </ul>
    </li>
    <li>
     <strong class="source-inline">
      
       app.UseRateLimiter()
      
     </strong>
     
      : This line adds the rate-limiting middleware to the request pipeline, enabling the configured rate-limiting policies to take effect.
     
     
      Unlike the traditional way of adding middleware where the
     
     <strong class="source-inline">
      
       UseMiddleware&lt;&gt;
      
     </strong>
     
      method is used, rate limiting has an exclusive extension method.
     
     
      We will learn how to create extension methods to add middleware in the
     
     
      
       next section.
      
     
    </li>
   </ul>
   <p>
    
     Rate limiting is
    
    <a id="_idIndexMarker687">
    </a>
    
     an important
    
    <a id="_idIndexMarker688">
    </a>
    
     feature that should be considered when developing ASP.NET Core 9 applications, bringing some benefits such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Overload protection
      
     </strong>
     
      : Prevents the server from being overloaded by too many requests, ensuring
     
     
      
       stable performance
      
     
    </li>
    <li>
     <strong class="bold">
      
       Fair use
      
     </strong>
     
      : Ensures that no client can monopolize server resources, promoting equitable access for
     
     
      
       all users
      
     
    </li>
    <li>
     <strong class="bold">
      
       Security:
      
     </strong>
     
      Mitigates certain types of attacks, such as
     
     <strong class="bold">
      
       Distributed Denial-of-Service
      
     </strong>
     
      (
     
     <strong class="bold">
      
       DDoS
      
     </strong>
     
      ) attacks, by limiting
     
     <a id="_idIndexMarker689">
     </a>
     
      the rate at which clients can
     
     
      
       make requests
      
     
    </li>
    <li>
     <strong class="bold">
      
       Improved user experience
      
     </strong>
     
      : By preventing server overload, rate limiting helps maintain consistent response times and
     
     
      
       service availability
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Learning more about rate-limiting middleware
    
   </p>
   <p class="callout">
    
     Rate limiting has several other features that can add to your strategy for using this middleware.
    
    
     See the documentation for more
    
    <a id="_idIndexMarker690">
    </a>
    
     
      details:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit?view=aspnetcore-9.0">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit?view=aspnetcore-9.0
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     In addition to rate-limiting middleware, ASP.NET Core 9 offers different other middleware that are widely used in different types of applications, such as authentication and authorization middleware, discussed in
    
    <a href="B21788_06.xhtml#_idTextAnchor093">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     .
    
    
     Depending on your application requirements, you can combine the capabilities of middleware to create powerful, high-quality
    
    <a id="_idIndexMarker691">
    </a>
    
     solutions
    
    <a id="_idIndexMarker692">
    </a>
    
     that run in
    
    
     
      modern environments.
     
    
   </p>
   <p class="callout-heading">
    
     ASP.NET Core 9 built-in middleware
    
   </p>
   <p class="callout">
    
     Consult the documentation to analyze the
    
    <a id="_idIndexMarker693">
    </a>
    
     different middleware available on the ASP.NET Core 9 platform at the following
    
    
     
      URL:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#built-in-middleware">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#built-in–middleware
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Now that we have created customized middleware and learned how to use the rate-limiting middleware available in ASP.NET Core 9, it is time to learn a good practice for registering middleware using
    
    
     
      extension methods.
     
    
   </p>
   <h1 id="_idParaDest-143">
    <a id="_idTextAnchor144">
    </a>
    
     Creating an extension method for middleware registration
    
   </h1>
   <p>
    
     With the
    
    <a id="_idIndexMarker694">
    </a>
    
     exception of middleware
    
    <a id="_idIndexMarker695">
    </a>
    
     built into ASP.NET Core 9, which have their respective extension methods for registration in the HTTP pipeline, each custom middleware must be registered using extension methods, such as
    
    <strong class="source-inline">
     
      UseMiddleware&lt;&gt;
     
    </strong>
    
     , already used in several code examples from
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     However, the addition of different middleware to the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file can create complexity in reading and maintaining these resources in
    
    
     
      the application.
     
    
   </p>
   <p>
    
     A good practice is to create extension methods in order to centralize the registration of middleware and have the benefit of abstracting the complexity of configuring these mechanisms, in addition to centralizing
    
    
     
      responsibilities appropriately.
     
    
   </p>
   <p>
    
     Let’s create an
    
    <a id="_idIndexMarker696">
    </a>
    
     extension method to centralize
    
    <a id="_idIndexMarker697">
    </a>
    
     the configurations of the previously created middleware.
    
    
     To do this, in the
    
    <strong class="source-inline">
     
      Middlewares
     
    </strong>
    
     folder, create a new class
    
    
     
      called
     
    
    
     <strong class="source-inline">
      
       CommonMiddlewareExtension.cs
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Add the following code to
    
    
     
      this class:
     
    
   </p>
   <pre class="source-code">
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.AspNetCore.RateLimiting;
using System.Threading.RateLimiting;
public static class CommonMiddlewareExtensions
{
  public static IServiceCollection AddCustomRateLimiting
    (this IServiceCollection services)
  {
    services.AddRateLimiter(options =&gt;
    {
      options.AddPolicy("fixed", context =&gt;
        RateLimitPartition.GetFixedWindowLimiter(new
        RateLimitPartitionKey(context.Request
        .Headers["X-Forwarded-For"].ToString(),
        PartitionKeyKind.ClientIP), partition =&gt;
          new FixedWindowRateLimiterOptions
          {
            PermitLimit = 5,
            Window = TimeSpan.FromMinutes(1),
            QueueProcessingOrder = QueueProcessingOrder
              .OldestFirst,
              QueueLimit = 2
          }));
      options.AddPolicy("sliding", context =&gt;
        RateLimitPartition.GetSlidingWindowLimiter(new
        RateLimitPartitionKey(context.Request
        .Headers["X-Forwarded-For"].ToString(),
        PartitionKeyKind.ClientIP), partition =&gt;
          new SlidingWindowRateLimiterOptions
          {
            PermitLimit = 5,
            Window = TimeSpan.FromMinutes(1),
            SegmentsPerWindow = 3,
            QueueProcessingOrder = QueueProcessingOrder
              .OldestFirst,
              QueueLimit = 2
            }));
      options.AddPolicy("tokenBucket", context =&gt;
        RateLimitPartition.GetTokenBucketLimiter(new
        RateLimitPartitionKey(context.Request
        .Headers["X-Forwarded-For"].ToString(),
        PartitionKeyKind.ClientIP), partition =&gt;
          new TokenBucketRateLimiterOptions
          {
            TokenLimit = 10,
            TokensPerPeriod = 5,
            ReplenishmentPeriod = TimeSpan.FromSeconds(10),
            QueueProcessingOrder = QueueProcessingOrder
              .OldestFirst,
              QueueLimit = 2
          }));
    });
    return services;
  }
  public static void UseCommonApplicationMiddleware
    (this IApplicationBuilder app)
  {
    builder.UseMiddleware&lt;ErrorHandlingMiddleware&gt;();
    builder.UseMiddleware&lt;PerformanceLoggingMiddleware&gt;();
    app.UseRateLimiter();
  }
}</pre>
   <p>
    
     The preceding
    
    <a id="_idIndexMarker698">
    </a>
    
     code contains all the rate-limiting
    
    <a id="_idIndexMarker699">
    </a>
    
     middleware settings, in addition to the use of global error-handling and request performance
    
    
     
      measurement middleware.
     
    
   </p>
   <p>
    
     This
    
    <a id="_idIndexMarker700">
    </a>
    
     extension method class exposes two
    
    <strong class="source-inline">
     
      AddCustomRateLimiting
     
    </strong>
    
     methods, responsible for adding the rate-limiting policies, and
    
    <a id="_idIndexMarker701">
    </a>
    
     the
    
    <strong class="source-inline">
     
      UseCommonApplicationMiddleware
     
    </strong>
    
     method, responsible for adding the previously created custom middleware and the rate-limiting middleware to the
    
    
     
      HTTP pipeline.
     
    
   </p>
   <p>
    
     After creating the class, we will change the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file, which will have the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddRazorPages();
<strong class="bold">builder.Services.AddCustomRateLimiting();</strong>
var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
// Use custom rate limiting middleware
<strong class="bold">app.UseCommonApplicationMiddleware();</strong>
app.MapRazorPages();
app.Run();</pre>
   <p>
    
     As we
    
    <a id="_idIndexMarker702">
    </a>
    
     can see in the highlighted code, the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     class uses the previously created extension methods, making
    
    <a id="_idIndexMarker703">
    </a>
    
     it more readable and easier
    
    
     
      to maintain.
     
    
   </p>
   <p>
    
     The extension method approach is a good practice for grouping a set of configurations in your application flow in order to correctly
    
    
     
      separate responsibilities.
     
    
   </p>
   <p>
    
     Use these features in your web application deployment flow with ASP.NET Core 9 and combine different middleware to create more
    
    
     
      powerful applications.
     
    
   </p>
   <p>
    
     In the next chapters of the book, we will cover other different techniques to further add possibilities to your ASP.NET Core 9 applications, such as secure
    
    
     
      configuration management.
     
    
   </p>
   <h1 id="_idParaDest-144">
    <a id="_idTextAnchor145">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we learned how to use the power of middleware to customize the execution flow of ASP.NET Core 9 applications, understanding how the middleware pipeline works.
    
    
     In addition, we learned how to implement custom middleware, work with factory-based middleware, and add capabilities to applications by working with global error handling approaches, information logging, and request limit settings.
    
    
     In the next chapter, we will explore how to manage application
    
    
     
      configurations securely.
     
    
   </p>
  </div>
 </body></html>