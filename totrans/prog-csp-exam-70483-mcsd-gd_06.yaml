- en: Managing and Implementing Multithreading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理和实现多线程
- en: What happens when a long-running program starts executing on a client's computer?
    How do operating systems handle such long-running processes? Does the operating
    system notify the user about their progress? How does the operating system let
    the user know when it has finished with these processes? Threading is the way
    in which the operating system handles the responsiveness of your program while
    managing other system resources. This is achieved using multiple threads of execution,
    which is one of the most powerful ways to keep your application responsive while
    using the processor for other events.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个长时间运行程序在客户端计算机上开始执行时会发生什么？操作系统如何处理这样的长时间运行进程？操作系统会通知用户其进度吗？操作系统如何让用户知道这些进程已经完成？线程是操作系统处理程序响应性的方式，同时管理其他系统资源。这是通过使用多个执行线程实现的，这是保持应用程序响应性并使用处理器处理其他事件的最强大方式之一。
- en: An operating system organizes each running application as a process. Each process
    may contain one or more threads. A thread allows the operating system to allocate
    processor time as required. Each thread holds scheduling priority and a set of
    structures that are used by the system to pause or execute the thread. This is
    called **thread context**. In other words, the thread context holds all the information
    that's required by the system to seamlessly resume execution. As we've already
    mentioned, a process can contain multiple threads, all of which share the same
    virtual address space of the process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统将每个运行中的应用程序组织为一个进程。每个进程可能包含一个或多个线程。线程允许操作系统根据需要分配处理器时间。每个线程都有调度优先级和一组系统用于暂停或执行线程的结构。这被称为**线程上下文**。换句话说，线程上下文包含系统无缝恢复执行所需的所有信息。正如我们之前提到的，一个进程可以包含多个线程，所有这些线程都共享进程的同一虚拟地址空间。
- en: In this chapter, we will focus on creating and managing threads, synchronizing
    data across threads, and multithreading. We'll also look at how the operating
    system uses this concept to keep the responsiveness of the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于创建和管理线程，同步线程间的数据，以及多线程。我们还将探讨操作系统如何使用这一概念来保持应用程序的响应性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding threads and the threading process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解线程和线程过程
- en: Synchronizing data in multithreading
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程中的数据同步
- en: Multithreading
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The exercises in this chapter can be practiced using Visual Studio 2012 or above
    with .NET Framework 2.0 or above. However, any new C# features from C# 7.0 and
    above require that you have Visual Studio 2017 installed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习可以使用Visual Studio 2012或更高版本以及.NET Framework 2.0或更高版本进行练习。然而，任何从C# 7.0及更高版本的新C#功能都需要您安装Visual
    Studio 2017。
- en: If you don't have a license for any of the aforementioned products, you can
    download the community version of Visual Studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有上述任何产品的许可证，您可以从[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)下载Visual
    Studio 2017的社区版。
- en: The sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter06](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter06).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter06](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter06)。
- en: Understanding threads and the threading process
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解线程和线程过程
- en: A primary thread is started whenever a .NET program is started. Additional threads
    are created by this primary thread to execute the application login either concurrently
    or in parallel. These threads are called **worker threads**. These threads can
    execute any part of the program code, which may include parts that are executed
    by another thread. As these threads are free to cross application boundaries,
    .NET Framework provides a way to isolate these threads within a process using
    application domains (not available in .NET Core).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每当启动.NET程序时，都会启动一个主线程。这个主线程会创建额外的线程来并发或并行地执行应用程序登录。这些线程被称为**工作线程**。这些线程可以执行程序代码的任何部分，这可能包括由其他线程执行的部分。由于这些线程可以自由跨越应用程序边界，.NET
    Framework提供了一种方法，通过应用程序域（在.NET Core中不可用）在进程内隔离这些线程。
- en: If our program can perform multiple operations in parallel, it will drastically
    decrease the total execution time. This can be achieved by utilizing multiple
    threads with multiprocessors or the multicore environment. The Windows operating
    system, when used alongside .NET Framework, ensures that these threads complete
    their respective tasks. Managing these tasks does have overhead, however. The
    OS allocates each thread a certain period of CPU time so that they can execute.
    After this period, a thread switch happens, which is called context switching.
    This context is saved and restored for each switch. To do this, Windows uses CPU
    registers and state data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的程序可以并行执行多个操作，这将极大地减少总执行时间。这可以通过利用多处理器或多核环境中的多个线程来实现。当与.NET Framework一起使用时，Windows操作系统确保这些线程完成它们各自的任务。然而，管理这些任务确实有开销。操作系统为每个线程分配一定量的CPU时间，以便它们可以执行。在这段时间之后，发生线程切换，这被称为上下文切换。这个上下文在每次切换时都会被保存和恢复。为了做到这一点，Windows使用CPU寄存器和状态数据。
- en: In an environment where multiple processors and multicore systems are available,
    we can take advantage of these resources and increase the throughput of the application.
    Consider a Windows application in which one thread (the primary thread) is handling
    the user interface by responding to user actions and other threads (worker threads)
    perform operations that require more time and processing. If the primary thread
    completes all of these operations, the user interfaces won't be responsive.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在有多个处理器和多核系统可用的环境中，我们可以利用这些资源来提高应用程序的吞吐量。考虑一个Windows应用程序，其中一个线程（主线程）通过响应用户操作来处理用户界面，而其他线程（工作线程）执行需要更多时间和处理的操作。如果主线程完成了所有这些操作，用户界面将不会响应用户操作。
- en: Because of this overhead, we need to carefully determine when to use multithreading.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种开销，我们需要仔细确定何时使用多线程。
- en: In the upcoming sections, we will focus on how we can create and manage threads,
    understand different thread properties, how we can create and pass parameters
    to threads, the difference between foreground and background threads, how to destroy
    threads, and more.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将关注如何创建和管理线程，了解不同的线程属性，如何创建和传递参数给线程，前台线程和后台线程之间的区别，如何销毁线程，以及更多内容。
- en: Managing threads
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程管理
- en: Threads can be created by creating a new instance of the `System.Threading`
    thread class and providing the name of the method that you want to execute on
    a new thread to the constructor. Using this class gives us more control and configuration
    of the program; for example, you can set the priority of the thread and whether
    it is a long-running thread, abort it, put it to sleep, and implement advanced
    configuration options. The `Thread.Start` method is used to create a thread call,
    while the `Thread.Abort` method is used to terminate the execution of a thread.
    The abort method raises `ThreadAbortException` when invoked. `Thread.Sleep` can
    be used to pause the execution of the thread for a certain amount of time. Finally,
    the `Thread.Interrupt` method is used to interrupt a blocked thread.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过创建`System.Threading`线程类的新实例，并将你希望在新的线程上执行的方法名称传递给构造函数来创建线程。使用这个类给我们提供了更多的程序控制和配置；例如，你可以设置线程的优先级，以及它是否是一个长时间运行的线程，终止它，让它休眠，并实现高级配置选项。`Thread.Start`方法用于创建线程调用，而`Thread.Abort`方法用于终止线程的执行。当调用中止方法时，会引发`ThreadAbortException`。`Thread.Sleep`可以用来暂停线程的执行一段时间。最后，`Thread.Interrupt`方法用于中断一个阻塞的线程。
- en: Let's understand these concepts by looking at a few examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个示例来理解这些概念。
- en: 'In the following code, `ThreadSample` is the primary thread, which starts the
    worker thread. The worker thread loops 10 times and writes to the console, letting
    the process know it has completed. After starting the worker thread, the primary
    thread loops four times. Note that the output depends on the environment you are
    running this program on. Try to change the seconds in the `thread.sleep` statement
    and observe the output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，`ThreadSample`是主线程，它启动了工作线程。工作线程循环10次并向控制台写入，让进程知道它已经完成。在启动工作线程后，主线程循环4次。请注意，输出取决于你运行此程序的环境。尝试更改`thread.sleep`语句中的秒数并观察输出：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s check the output of our program. `ThreadOne` starts its execution first
    and initiates 10 different worker threads and then the primary thread is executed.
    If you delay the execution of `ThreadOne` by using sleep, you will see the primary
    thread wait until `ThreadOne` returns:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们程序的输出。`ThreadOne` 首先开始执行并启动 10 个不同的工作线程，然后执行主线程。如果你通过使用 sleep 延迟 `ThreadOne`
    的执行，你会看到主线程会等待直到 `ThreadOne` 返回：
- en: '![](img/fca1f269-d3ff-4f46-8c44-8455d1ac33a3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fca1f269-d3ff-4f46-8c44-8455d1ac33a3.png)'
- en: When the program is executed, a foreground thread is created automatically to
    execute the code. This primary thread then creates worker threads as required
    to execute the sections of the code from the same process. As you can see, the
    thread takes a delegate in its constructor.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行时，会自动创建一个前台线程来执行代码。然后，这个主线程根据需要创建工作线程来执行来自同一进程的代码部分。正如你所看到的，线程在其构造函数中接受一个委托。
- en: In the preceding program, we used `thread.join`, which lets the primary thread
    wait until all the worker threads have completed their execution. Also, `Thread.Sleep(0)`
    tells Windows that the current thread has finished its execution so that a context
    switch can happen instead of Windows having to wait for the allocated time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们使用了 `thread.join`，这允许主线程等待直到所有工作线程完成它们的执行。此外，`Thread.Sleep(0)` 告诉
    Windows 当前线程已经完成了它的执行，以便发生上下文切换，而不是 Windows 必须等待分配的时间。
- en: Thread properties
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程属性
- en: 'Each thread carries certain properties. The following table details each of
    them:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程携带某些属性。以下表格详细说明了每一个：
- en: '| `IsAlive` | Returns `true` if the thread is in a started state. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `IsAlive` | 如果线程处于已启动状态，则返回 `true`。 |'
- en: '| `IsBackground` | Gets or sets this property to let the system know how to
    execute the thread. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `IsBackground` | 获取或设置此属性以让系统知道如何执行线程。 |'
- en: '| `Name` | Name of the thread. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `Name` | 线程的名称。 |'
- en: '| `Priority` | Gets or sets thread priority. The default is `Normal`. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `Priority` | 获取或设置线程优先级。默认为 `Normal`。 |'
- en: '| `ThreadState` | Gets the thread''s current state. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `ThreadState` | 获取线程的当前状态。 |'
- en: 'In the following code sample, we will call a method that will display information
    about some thread properties. We will also understand how we can pause a thread
    and terminate it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们将调用一个方法来显示有关某些线程属性的信息。我们还将了解如何暂停线程并终止它：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you execute the program, you will see the properties of each thread. You
    will also observe that although the primary thread has completed, the worker threads
    are still executing:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行程序时，你会看到每个线程的属性。你也会观察到尽管主线程已经完成，但工作线程仍在执行：
- en: '![](img/aca30cc8-553f-4a9a-8a8f-e5bc29f52fa6.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aca30cc8-553f-4a9a-8a8f-e5bc29f52fa6.png)'
- en: You might have observed that only one thread is writing to the console at a
    time. This is known as **synchronization**. In this case, it is handled by the
    console class for us. Synchronization allows no two threads to execute the same
    code block at the same time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，一次只有一个线程写入控制台。这被称为 **同步**。在这种情况下，它由控制台类为我们处理。同步允许没有两个线程同时执行相同的代码块。
- en: Parameterized threads
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化线程
- en: 'Here, we will look at how we can pass arguments to the `ThreadStart` method.
    To achieve this, we will be using the `ParameterizedThreadStart` delegate on the
    constructor. The signature of this delegate is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将探讨如何向 `ThreadStart` 方法传递参数。为了实现这一点，我们将在构造函数中使用 `ParameterizedThreadStart`
    委托。此委托的签名如下：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you pass a parameter as an object to the `ThreadStart` method, it will
    cast the parameter to the appropriate type. The following sample program uses
    the same logic that we used previously, except that we pass the interval as an
    argument via the `ThreadStart` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将参数作为对象传递给 `ThreadStart` 方法时，它将参数转换为适当的数据类型。以下示例程序使用了我们之前使用的相同逻辑，除了我们通过 `ThreadStart`
    方法传递间隔作为参数：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot shows the output of the preceding code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面代码的输出：
- en: '![](img/f28de47d-495f-4785-a190-8d100e291557.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f28de47d-495f-4785-a190-8d100e291557.png)'
- en: Now, let's look at foreground and background threads.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看前台和后台线程。
- en: Foreground and background threads
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前台和后台线程
- en: By default, when a thread is created, it is created as a foreground thread.
    You can use the `IsBackground` property to make a thread a background thread.
    The main difference between foreground and background threads is that a background
    thread does not run if all the foreground threads are terminated. The runtime
    aborts all the background threads when foreground threads are stopped. If a thread
    is created using a thread pool, then these threads are executed as background
    threads. Note that when an unmanaged thread enters the managed execution environment,
    it is executed as a background thread.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当创建一个线程时，它会被创建为一个前台线程。你可以使用`IsBackground`属性将一个线程设置为后台线程。前台线程和后台线程的主要区别在于，如果所有前台线程都终止了，后台线程将不会运行。当前台线程停止时，运行时会终止所有后台线程。如果使用线程池创建线程，则这些线程将以后台线程的方式执行。请注意，当非托管线程进入托管执行环境时，它将以后台线程的方式执行。
- en: 'Let''s jump into an example to understand the difference between foreground
    and background threads:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解前台线程和后台线程之间的区别：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot shows the output of the preceding code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面代码的输出：
- en: '![](img/67377582-684b-4fc3-ac09-29a9b7eb8ac8.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67377582-684b-4fc3-ac09-29a9b7eb8ac8.png)'
- en: As you can see, the primary thread was created as a foreground thread while
    the worker thread was created as a background thread. When we stopped the primary
    thread, it stopped the background thread. This is why the elapsed time statement
    was not displayed through the loop, which is running for 5 seconds (`while(sw.ElapsedMilliseconds
    <=5000)`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，主线程被创建为一个前台线程，而工作线程被创建为一个后台线程。当我们停止主线程时，它也停止了后台线程。这就是为什么在运行5秒（`while(sw.ElapsedMilliseconds
    <=5000)`）的循环中，没有显示经过的时间语句。
- en: Thread states
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程状态
- en: 'When a thread is created, it will be in an **Unstarted** state until the **Start**
    method is invoked. A thread is always in at least one state and sometimes it may
    be in multiple states at the same time. In the following diagram, each oval represents
    a state. The text on each line represents the action that is performed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个线程时，它将处于**未开始**状态，直到调用**Start**方法。线程始终处于至少一个状态，有时它可能同时处于多个状态。在以下图中，每个椭圆形代表一个状态。每行上的文本代表执行的动作：
- en: '![](img/575bba21-2b4f-4c23-8c09-30d501edae13.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/575bba21-2b4f-4c23-8c09-30d501edae13.png)'
- en: A thread can be in two different states at the same time. For example, if a
    thread is in a waiting state and another thread aborts, it can be in both the
    **Wait/Join Sleep** and **Abort Requested** states. When the thread returns to
    the wait call, it will receive a `ThreadAbortException`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以同时处于两种不同的状态。例如，如果一个线程处于等待状态，而另一个线程被终止，它可以同时处于**等待/加入睡眠**和**终止请求**状态。当线程返回到等待调用时，它将接收到一个`ThreadAbortException`。
- en: Destroying threads
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁线程
- en: The `Thread.Abort` method is used to stop a thread. Once aborted, it cannot
    be restarted. However, when you invoke `Thread.Abort`, it doesn't terminate the
    thread immediately since the `Thread.Abort` statement throws a `ThreadAbortException`,
    which needs to be caught. Then, the cleanup code should be executed. If you call
    the `Thread.Join` method, this will make sure the thread waits until the other
    thread's execution is completed. The `join` method depends on the timeout interval,
    so if it's not specified, then the wait is not guaranteed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.Abort`方法用于停止一个线程。一旦终止，它就不能重新启动。然而，当你调用`Thread.Abort`时，它不会立即终止线程，因为`Thread.Abort`语句抛出一个`ThreadAbortException`，这需要被捕获。然后，应该执行清理代码。如果你调用`Thread.Join`方法，这将确保线程等待直到其他线程的执行完成。`join`方法依赖于超时间隔，所以如果没有指定，等待是不确定的。'
- en: When your own code aborts a thread and you don't want to rethrow it, use the
    `ResetAbort` method. You will learn more about how to rethrow exceptions in [Chapter
    7](7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml), *Implementing Exception Handling*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你自己的代码终止一个线程，并且你不想重新抛出它时，请使用`ResetAbort`方法。你将在[第7章](7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml)，*实现异常处理*中了解更多关于如何重新抛出异常的信息。
- en: Thread pools
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池
- en: A thread pool provides a pool of threads that can be used as worker threads
    and are managed by the system. This allows us to focus on application logic instead
    of managing threads. This is an easy way for us to use multiple threads. From
    .NET Framework 4 onward, it became easy to use thread pools as they allowed us
    to create tasks and perform asynchronous tasks. The **Task Parallel Library**
    (**TPL**) and asynchronous method calls are mainly dependent on the thread pool.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池提供了一组线程，这些线程可以用作工作线程并由系统管理。这使我们能够专注于应用程序逻辑而不是管理线程。这是我们使用多线程的简单方法。从 .NET 框架
    4 开始，使用线程池变得容易，因为它们允许我们创建任务并执行异步任务。**任务并行库**（**TPL**）和异步方法调用主要依赖于线程池。
- en: Threads that are created from a thread pool are background threads. Each thread
    uses default properties. When a thread completes its task, it is returned to a
    queue of waiting threads so that they can be reused. In turn, this reduces the
    cost of creating new threads for every task. You can have one thread pool per
    process.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从线程池创建的线程是后台线程。每个线程使用默认属性。当线程完成任务时，它将返回到等待线程的队列中，以便可以重用。反过来，这减少了为每个任务创建新线程的成本。每个进程可以有一个线程池。
- en: .NET Framework allows us to set and get `MaxThread` for a thread pool, though
    the number of threads that can be queued is limited by available memory. Once
    the thread pool threads are busy, other tasks are queued until the threads are
    available.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架允许我们为线程池设置和获取 `MaxThread`，尽管可以排队的线程数量受可用内存限制。一旦线程池中的线程忙碌，其他任务将排队，直到线程可用。
- en: It is important to understand that any unhandled exception in a thread pool
    will terminate this process. More information on thread pools can be found at
    [https://docs.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool](https://docs.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，线程池中任何未处理的异常都将终止此进程。有关线程池的更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool](https://docs.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool)。
- en: 'The following example shows how we can create multiple threads using a thread
    pool:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何使用线程池创建多个线程：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows the output of running the preceding code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行前面代码的输出：
- en: '![](img/edce518e-f26b-4179-8b24-7f39e97f9179.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/edce518e-f26b-4179-8b24-7f39e97f9179.png)'
- en: Her, we created five worked threads using the thread pool. If you uncomment
    `Thread.CurrentThread.Join` in the preceding code, the primary thread won't exit
    until all of the threads have been processed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用线程池创建了五个工作线程。如果你在前面代码中取消注释 `Thread.CurrentThread.Join`，主线程将不会退出，直到所有线程都已被处理。
- en: Thread storage
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程存储
- en: Thread-relative static fields and data slots are the two ways in which we can
    store data that is unique to the thread and application domain. Thread-relative
    static fields are defined at compile time and provide the best performance. Another
    benefit is that they do compile-time type checking. These fields are used when
    the requirement about what kind of data to be stored is clear beforehand.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 线程相关的静态字段和数据槽是我们存储线程和应用域唯一数据的两种方式。线程相关的静态字段在编译时定义，并提供最佳性能。另一个好处是它们在编译时进行类型检查。当事先明确需要存储哪种类型的数据时，使用这些字段。
- en: Thread-relative static fields can be created using `ThreadStaticAttribute`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `ThreadStaticAttribute` 创建线程相关的静态字段。
- en: There are scenarios where these storage requirements may arise at runtime. In
    such scenarios, we can opt for data slots. These are a bit slower than static
    fields. Since these are created at runtime, they store information as an object
    type. It is important for us to convert these objects into their respective types
    before using them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，这些存储需求可能在运行时出现。在这种情况下，我们可以选择数据槽。这些比静态字段慢一些。由于它们是在运行时创建的，因此它们以对象类型存储信息。在使用它们之前，将对象转换为它们相应的类型对我们来说很重要。
- en: '.NET Framework allows us to create two types of data slots: named data slots
    and unnamed data slots. Named data slots use the `GetNamedDataSlot` method so
    that we can retrieve it as and when required. However, one disadvantage of `NamedDataslot`
    is when two threads from the same application domain use the same data slot in
    two different components of code and execute them at the same time. When this
    happens, they can corrupt each other''s data.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架允许我们创建两种类型的数据槽：命名数据槽和未命名数据槽。命名数据槽使用 `GetNamedDataSlot` 方法，这样我们就可以在需要时检索它。然而，`NamedDataslot`
    的一个缺点是，当来自同一应用程序域的两个线程在两个不同的代码组件中使用相同的数据槽并在同一时间执行时，它们可能会互相破坏数据。
- en: '`ThreadLocal<T>` can be used to create local data storage.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadLocal<T>` 可以用来创建局部数据存储。'
- en: 'These two ways of storing data can be referred to as **thread-local storage**
    (**TLS**). A couple of the benefits of managed TLS are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种存储数据的方式可以被称为 **线程局部存储**（**TLS**）。管理 TLS 的几个好处如下：
- en: Within an application domain, one thread cannot modify data from another thread,
    even when both threads use the same field or slot
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个应用程序域内，一个线程不能修改另一个线程的数据，即使两个线程使用相同的字段或槽位。
- en: When a thread accesses the same field or slot from multiple application domains,
    a separate value is maintained in each application domain
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个线程从多个应用程序域访问相同的字段或槽位时，每个应用程序域都维护一个单独的值。
- en: 'Now, we will jump into an example and look at how the `ThreadStatic` attribute
    can be used. In the following example, a static variable is being defined and
    decorated with the `ThreadStatic` attribute. This ensures that each thread has
    its own copy of the variable. When you execute the following program, you will
    observe that `_intvariable` goes up to 6 for each thread:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进入一个示例，看看如何使用 `ThreadStatic` 属性。在下面的示例中，定义了一个静态变量，并用 `ThreadStatic` 属性进行了装饰。这确保了每个线程都有自己的变量副本。当你执行以下程序时，你会观察到
    `_intvariable` 对每个线程都增加到 6：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the output of running the preceding program.
    Comment the `ThreadStatic` attribute and run the program again—you will find that
    the `_intvariable` value goes up to 18 as each thread updates its value:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行前面程序的结果。注释掉 `ThreadStatic` 属性并再次运行程序——你会发现 `_intvariable` 的值增加到 18，因为每个线程都会更新其值：
- en: '![](img/f843c56b-b2b7-4ab2-9fd3-998b1398a21c.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f843c56b-b2b7-4ab2-9fd3-998b1398a21c.png)'
- en: 'Let''s see how we can use `ThreadLocal<T>` to create local storage:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `ThreadLocal<T>` 来创建局部存储：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/8d01b785-5fbc-4c3a-a685-ca0dcaeb507e.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d01b785-5fbc-4c3a-a685-ca0dcaeb507e.png)'
- en: Now that we've understood how to manage threads, let's look at how to synchronize
    data in multithreading.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何管理线程，让我们看看如何在多线程中同步数据。
- en: Synchronizing data in multithreading
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程中的数据同步
- en: Multiple threads can invoke the methods or properties of an object, which can
    make the state of an object invalid. It is possible to make conflicting changes
    regarding two or more threads on the same object. This makes it important to synchronize
    these calls, which will allow us to avoid such issues. When the members of a class
    are protected from conflicting changes, they are known to be **thread-safe**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程可以调用一个对象的方法或属性，这可能会使对象的状态无效。对同一对象进行两个或更多线程的冲突更改是可能的。这使得同步这些调用变得很重要，这将使我们能够避免此类问题。当一个类的成员受到冲突更改的保护时，它们被认为是
    **线程安全的**。
- en: 'The CLR provides multiple ways in which we can synchronize access to the object
    instance and static members:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 提供了多种方式，我们可以通过这些方式同步对对象实例和静态成员的访问：
- en: Synchronize code regions
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步代码区域
- en: Manual synchronization
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动同步
- en: Synchronize context
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步上下文
- en: Thread-safe collection
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程安全集合
- en: By default, there is no synchronization for objects, which means any thread
    can access methods and properties at any time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，对象没有同步，这意味着任何线程都可以在任何时候访问方法和属性。
- en: Synchronizing code regions allows us to synchronize blocks of code, methods,
    and static methods. However, synchronizing static fields is not supported. Synchronizing
    is possible if we use a `Monitor` class or a keyword. C# supports the `lock` keyword,
    which can be used to mark blocks of code for synchronization.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同步代码区域允许我们同步代码块、方法和静态方法。然而，不支持同步静态字段。如果我们使用 `Monitor` 类或关键字，则可以进行同步。C# 支持使用
    `lock` 关键字来标记需要同步的代码块。
- en: When applied, the threads attempt to acquire the lock while executing the code.
    If another thread has already been acquired by the lock on this block, then the
    thread blocks until the lock is available. The lock is released when the thread
    has executed the code block or exits in any other way.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用时，线程在执行代码时会尝试获取锁。如果另一个线程已经获取了此代码块的锁，则该线程会阻塞，直到锁可用。当线程执行代码块或以其他方式退出时，锁会被释放。
- en: '`MethodImplAttribute` and `MethodImplOptions.Synchronized` give us the same
    results as using `Monitor` or keywords to lock the code block.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`MethodImplAttribute` 和 `MethodImplOptions.Synchronized` 与使用 `Monitor` 或关键字锁定代码块得到相同的结果。'
- en: Let's look at an example to understand lock statements with tasks. We will learn
    more about tasks in the upcoming sections.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来了解使用任务进行锁定语句。在接下来的章节中，我们将了解更多关于任务的内容。
- en: 'For the purpose of this example, we created an `Account` class that synchronizes
    its private field balance amount by locking it to an instance. This ensures that
    no two threads update this field at the same time:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本例的目的，我们创建了一个 `Account` 类，通过将其锁定到实例来同步其私有字段余额。这确保了没有两个线程同时更新此字段：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `TestLockStatements(``)` method looks as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestLockStatements( )` 方法如下所示：'
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are creating two tasks, and each task invokes `UpdateMethod`. This method
    loops 10 times and updates the account balance using either credit or debit methods.
    Because we are using the `lock(obj)` field at the instance level, the balance
    amount field won't be updated at the same time.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个任务，每个任务都调用 `UpdateMethod`。此方法循环10次，并使用信用或借记方法更新账户余额。因为我们使用的是实例级别的 `lock(obj)`
    字段，所以余额字段不会同时更新。
- en: 'The following code shows the desired output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了所需的输出：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Accessing shared variables across multiple threads may cause data integrity
    issues. Such issues can be addressed by using a synchronization primitive. These
    are derived by the `System.Threading.WaitHandle` class. While performing manual
    synchronization, a primitive can protect access to shared resources. Different
    synchronization primitive instances are used to protect access to a resource or
    some parts of code access, which allows multiple threads to access a resource
    concurrently.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个线程之间访问共享变量可能会导致数据完整性问题。这些问题可以通过使用同步原语来解决。这些原语由 `System.Threading.WaitHandle`
    类派生。在执行手动同步时，原语可以保护对共享资源的访问。不同的同步原语实例用于保护对资源或某些代码访问部分的访问，这允许多个线程并发访问资源。
- en: You can read more about synchronization primitives at [https://docs.microsoft.com/en-us/dotnet/standard/threading/overview-of-synchronization-primitives](https://docs.microsoft.com/en-us/dotnet/standard/threading/overview-of-synchronization-primitives).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://docs.microsoft.com/en-us/dotnet/standard/threading/overview-of-synchronization-primitives](https://docs.microsoft.com/en-us/dotnet/standard/threading/overview-of-synchronization-primitives)
    上了解更多关于同步原语的信息。
- en: The `System.Collections.Concurrent` namespace was introduced by .NET Framework
    and can be used without additional synchronization in the user code. This namespace
    includes several collection classes that are both thread-safe and scalable. This
    allows multiple threads to add or remove items from these collections.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`.NET Framework` 引入了 `System.Collections.Concurrent` 命名空间，可以在用户代码中无需额外同步的情况下使用。此命名空间包括几个线程安全和可扩展的集合类。这允许多个线程向这些集合添加或从中删除项目。'
- en: More information on these thread-safe collections can be found at [https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/index](https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/index).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于这些线程安全集合的信息可以在 [https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/index](https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/index)
    上找到。
- en: Multithreading
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程
- en: 'Developers are allowed to create multiple threads within a process and manage
    them throughout the program''s execution. This allows us to focus on the application
    logic instead of managing threads. However, starting with .NET Framework 4, we
    can create multithreaded programs using the following methods:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以在进程内创建多个线程，并在整个程序执行过程中管理它们。这使我们能够专注于应用程序逻辑，而不是管理线程。然而，从 .NET Framework
    4 开始，我们可以使用以下方法创建多线程程序：
- en: TPL
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TPL
- en: '**Parallel Language-Integrated Query**(**PLINQ**)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行语言集成查询**（**PLINQ**）'
- en: To understand both of these features, we need to talk about parallel programming.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这两个功能，我们需要讨论并行编程。
- en: Parallel programming
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行编程
- en: '**Parallel programming** helps the developer take advantage of the hardware
    on workstations where multiple CPU cores are available. They allow multiple threads
    to be executed in parallel.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行编程**帮助开发者利用工作站上的硬件，这些工作站拥有多个CPU核心。它们允许多个线程并行执行。'
- en: In previous versions, parallelization required low-level manipulation of threads
    and locks. From .NET Framework 4 onward, enhanced support for parallel programming
    was provided in the form of the runtime, class library types, and diagnostic tools.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的版本中，并行化需要低级线程和锁的操作。从.NET Framework 4开始，提供了对并行编程的增强支持，形式为运行时、类库类型和诊断工具。
- en: 'The following diagram shows the high-level architecture of parallel programming:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了并行编程的高级架构：
- en: '![](img/955ad58e-8fd8-4cce-9825-93e9914c6db6.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/955ad58e-8fd8-4cce-9825-93e9914c6db6.png)'
- en: In the upcoming sections, we will talk about some of the components listed in
    the preceding architecture diagram.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论前面架构图中列出的一些组件。
- en: TPL
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TPL
- en: 'TPL makes developers more productive by creating parallel and concurrent applications.
    These are available as public types in the `System.Threading` and `System.Threading.Tasks`
    namespaces. TPL allows us to maximize code performance while focusing on program
    work. TPL is based on tasks, which represent a thread or thread pool. When one
    or more tasks are run concurrently, this is known as task parallelism. A task
    has a couple of benefits: being scalable and efficient, and having more programmatic
    control than threads.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: TPL通过创建并行和并发应用程序，使开发者更加高效。这些类型作为`System.Threading`和`System.Threading.Tasks`命名空间中的公共类型提供。TPL允许我们在关注程序工作的同时，最大化代码性能。TPL基于任务，代表一个线程或线程池。当一个或多个任务并发运行时，这被称为任务并行。任务有几个好处：可扩展性和效率，以及比线程更多的程序控制能力。
- en: Because TPL handles the partitioning of the work, scheduling, cancellation,
    state, and other low-level details, it can scale the degree of concurrency dynamically
    and use the system resources or processors that are available.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为TPL处理工作的分割、调度、取消、状态和其他底层细节，它可以动态地调整并发程度，并使用可用的系统资源或处理器。
- en: It is important to be aware of when to apply parallel programming, otherwise
    the overhead of parallelization decreases the speed of code execution. A basic
    understanding of threading concepts such as locks and deadlocks is important so
    that we can use TPL effectively.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 了解何时应用并行编程很重要，否则并行化的开销会降低代码执行速度。对线程概念如锁和死锁的基本理解很重要，这样我们才能有效地使用TPL。
- en: Data parallelism
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据并行
- en: When an operation can be performed concurrently on source collection elements,
    it is referred to as data parallelism. In this process, the source collection
    is partitioned into multiple threads and executed in parallel. .NET Framework
    supports data parallelism via the `System.Threading.Tasks.Parallel` class. Methods
    such as `Parallel.For` and `Parallel.ForEach` are defined in this class. When
    you use these methods, the framework manages all the low-level work for us.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作可以在源集合元素上并发执行时，这被称为数据并行。在这个过程中，源集合被分割成多个线程并行执行。.NET Framework通过`System.Threading.Tasks.Parallel`类支持数据并行。`Parallel.For`和`Parallel.ForEach`等方法定义在这个类中。当你使用这些方法时，框架会为我们管理所有底层工作。
- en: A task represents an asynchronous operation and does not return a value. These
    are defined in the `System.Threading.Tasks` class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 任务代表一个可能返回也可能不返回值的异步操作，并在`System.Threading.Tasks`类中定义。
- en: Using tasks
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用任务
- en: A task represents an operation that may or may not return a value and executes
    asynchronously. Since they are executed asynchronously, they are executed as worker
    threads from the thread pool rather than the primary thread. This allows us to
    use the `isCanceled` and `IsCompleted` properties to understand the state of the
    task. You can also make a task run synchronously, which will be executed on the
    main or primary thread.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 任务代表一个可能返回也可能不返回值的操作，并异步执行。由于它们是异步执行的，因此它们作为线程池中的工作线程而不是主线程来执行。这允许我们使用`isCanceled`和`IsCompleted`属性来了解任务的状态。您还可以使任务同步运行，这将执行在主线程或主要线程上。
- en: 'A task can implement the `IAsyncResult` and `IDisposable` interfaces like so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以实现`IAsyncResult`和`IDisposable`接口，如下所示：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s look at an example so that we can understand how we can create and initiate
    a task in different ways. In this example, we will use an action delegate that
    takes an argument of the `object` type:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来了解我们如何以不同的方式创建和启动任务。在这个例子中，我们将使用一个接受`object`类型参数的操作委托：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we create four different tasks. For the first task, we used start methods,
    while for the second task, we used a task `factory.startnew` method. The third
    task was started using the `run(Action)` method, while the fourth task was executed
    synchronously on the main thread using the run synchronously method. Here, tasks
    1, 2, and 3 are worker threads that are using a thread pool, while task 4 is executing
    on the primary thread.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了四个不同的任务。对于第一个任务，我们使用了启动方法，而对于第二个任务，我们使用了`task.factory.startnew`方法。第三个任务使用`run(Action)`方法启动，而第四个任务使用同步运行方法在主线程上同步执行。在这里，任务1、2和3是使用线程池的工人线程，而任务4在主线程上执行。
- en: 'The following screenshot shows the output of running the preceding code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行前面代码的输出：
- en: '![](img/2796ffa5-1d98-4b42-b575-49621395d9e5.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2796ffa5-1d98-4b42-b575-49621395d9e5.png)'
- en: The `Wait` method is similar to `Thread.Join`, which waits until the task completes.
    This is useful when synchronizing the execution of calling threads and asynchronous
    tasks since we can wait for one or more threads to complete. The `Wait` method
    also accepts certain parameters that allow us to conditionally wait for a task
    to complete.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wait`方法类似于`Thread.Join`，它等待任务完成。这在同步调用线程和异步任务执行时很有用，因为我们可以等待一个或多个线程完成。`Wait`方法还接受某些参数，允许我们有条件地等待任务完成。'
- en: 'The following table shows the different options that are available for a thread
    when it comes to waiting:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了线程在等待时可以使用的不同选项：
- en: '| `Wait` | Waits for the task''s execution to complete. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `Wait` | 等待任务执行完成。|'
- en: '| `Wait(int32)` | Makes the tasks wait for a specified number of milliseconds
    before executing. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `Wait(int32)` | 使任务在执行前等待指定数量的毫秒。|'
- en: '| `Wait(Timespan)` | Waits for the task''s execution to complete within a specified
    time interval. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `Wait(Timespan)` | 在指定的时间间隔内等待任务执行完成。|'
- en: '| `Wait(CancellationToken)` | Waits for the task''s execution to complete.
    The wait is terminated if `cancellationToken` is issued before the task''s execution
    is completed. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `Wait(CancellationToken)` | 等待任务执行完成。如果`cancellationToken`在任务执行完成前发出，则等待终止。|'
- en: '| `Wait(Int32, CancellationToken)` | Waits for the task''s execution to complete.
    The wait terminates on timeout or when a cancellation token is issued before the
    task completes. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `Wait(Int32, CancellationToken)` | 等待任务执行完成。等待在超时或任务完成前发出取消令牌时终止。|'
- en: '| `WaitAll` | Waits for all the provided tasks to complete their execution.
    Similar to the `Wait` method, `WaitAll` tasks multiple parameters and performs
    them accordingly. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `WaitAll` | 等待所有提供的任务完成其执行。类似于`Wait`方法，`WaitAll`接受多个参数并相应地执行它们。|'
- en: '| `WaitAny` | Waits for the provided task to complete its execution. Similar
    to the `Wait` method, `WaitAll` tasks multiple parameters and performs them accordingly.
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `WaitAny` | 等待提供的任务完成其执行。类似于`Wait`方法，`WaitAny`接受多个参数并相应地执行它们。|'
- en: 'Tasks support two other methods: `WhenAll` and `WhenAny`. Now, `WhenAll` is
    used to create a task that will complete its execution when all the provided tasks
    have been completed. Similarly, `WhenAny` creates tasks and completes when the
    provided task completes its execution.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 任务支持另外两种方法：`WhenAll`和`WhenAny`。现在，`WhenAll`用于创建一个任务，当所有提供的任务都完成时，该任务将完成其执行。同样，`WhenAny`创建任务并在提供的任务完成其执行时完成。
- en: 'A task can also return a value. However, reading the result of a task means
    waiting until its execution has completed. Without completing its execution, it
    isn''t possible to use the result object. The following is an example of this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 任务也可以返回一个值。然而，读取任务的输出意味着等待其执行完成。在没有完成执行的情况下，无法使用结果对象。以下是一个示例：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'By executing the preceding code, you will see that the main thread waits until
    the task returns a value. Then, it displays a `Press any key to exit` message:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行前面的代码，您将看到主线程会等待任务返回一个值。然后，它显示一个`按任意键退出`的消息：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s also possible to add a continuation task. .NET Framework provides a keyword
    called `ContinueWith`, which allows you to create a new task and execute it once
    the previous tasks have finished executing. In the following code, we are instructing
    the task to continue with the result from the parent task:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以添加一个后续任务。.NET Framework提供了一个名为`ContinueWith`的关键字，它允许你在前一个任务执行完毕后创建并执行一个新任务。在以下代码中，我们指示任务使用父任务的结果继续执行：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When task `t` has completed its execution, the result is used in the second
    task, `t1`, and the final result is displayed:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务`t`完成其执行时，结果被用于第二个任务`t1`，并显示最终结果：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ContinueWith` has a couple of overload methods that allow us to configure
    when the continuation task should execute, such as when a task is canceled or
    completed successfully. To make this configuration work, we will use `TaskContinuationOptions`.
    You can find more of the options that are available at [https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions?view=netframework-4.7.2).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContinueWith`有几个重载方法，允许我们配置后续任务何时执行，例如在任务取消或成功完成后。为了使此配置生效，我们将使用`TaskContinuationOptions`。更多可用的选项可以在[https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions?view=netframework-4.7.2)找到。'
- en: 'The following code block shows how we can use `continuationOptions`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块展示了如何使用`continuationOptions`：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`TaskFactory` supports creating and scheduling tasks. It also allows us to
    do the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskFactory`支持创建和调度任务。它还允许我们执行以下操作：'
- en: Create a task and start it immediately using the `StartNew` method
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`StartNew`方法创建一个任务并立即启动它
- en: Create a task that starts when any one of the tasks in an array has completed
    by calling the `ContinueWhenAny` method
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`ContinueWhenAny`方法创建一个任务，该任务将在数组中的任何一个任务完成时启动
- en: Create a task that starts when all the tasks in an array have completed by calling
    the `ContinueWhenAll` method
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`ContinueWhenAll`方法创建一个任务，该任务将在数组中的所有任务完成时启动
- en: Further reading on `TaskFactory` can be found at [https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskfactory?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskfactory?view=netframework-4.7.2).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`TaskFactory`的阅读资料可以在[https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskfactory?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskfactory?view=netframework-4.7.2)找到。
- en: Using the Parallel class
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Parallel类
- en: The `System.Threading` class has another class named `Parallel`. This class
    provides parallel implementations for `For` and `ForEach` loops. Their implementation
    is similar to the sequential loop. When you use `ParallelFor` or `ParallelForEach`,
    the system automatically splits the process into multiple tasks and acquires locks
    if required. All of this low-level work is handled by TPL.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Threading`类中还有一个名为`Parallel`的类。这个类为`For`和`ForEach`循环提供了并行实现。它们的实现与顺序循环类似。当你使用`ParallelFor`或`ParallelForEach`时，系统会自动将过程分割成多个任务，并在需要时获取锁。所有这些底层工作都由TPL处理。'
- en: 'A sequential loop may look as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序循环可能看起来如下：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The same loop can be represented using `Parallel` as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的循环可以使用`Parallel`表示如下：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: TPL manages the data source and creates partitions so that the loop can operate
    on multiple parts in parallel. Each task will be partitioned by the task scheduler
    as per system resources and workload. Then, if the workload becomes unbalanced,
    the work will be redistributed into multiple threads and processes by the task
    scheduler.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: TPL管理数据源并创建分区，以便循环可以并行操作多个部分。每个任务将由任务调度器根据系统资源和负载进行分区。然后，如果负载变得不平衡，任务调度器将通过多个线程和进程重新分配工作。
- en: Parallel programming can increase performance when you have a lot of work to
    be done in parallel. If this isn't the case, it can become a costly affair.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有大量并行工作要做时，并行编程可以提高性能。如果不是这种情况，它可能会变得成本高昂。
- en: It is important to understand how parallelism works in a scenario given. In
    the following example, we'll look at how we can use `Parallel.For` and make a
    time comparison between sequential and parallel loops.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的场景中理解并行工作方式非常重要。在以下示例中，我们将探讨如何使用`Parallel.For`，并在顺序循环和并行循环之间进行时间比较。
- en: 'Here, we are defining an array of integers and calculating the sum and product
    of each element of the array. In the main program, we invoke this method using
    sequential and parallel loops and calculate how much time each loop takes to complete
    the process:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个整数数组，并计算数组中每个元素的求和和乘积。在主程序中，我们使用顺序和并行循环调用此方法，并计算每个循环完成过程所需的时间：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code, we executed two loops: one using a parallel loop and
    the other using a sequential loop. The results show the time each operation took:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们执行了两个循环：一个使用并行循环，另一个使用顺序循环。结果显示了每个操作所花费的时间：
- en: '![](img/2683561f-3fd8-40d0-855f-e7275065851f.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2683561f-3fd8-40d0-855f-e7275065851f.png)'
- en: '`System.Threading.Tasks.Parallel` comes with multiple helper classes, such
    as `ParallelLoopResult`, `ParallelLoopState`, and `ParallelOptions`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks.Parallel` 包含多个辅助类，例如 `ParallelLoopResult`、`ParallelLoopState`
    和 `ParallelOptions`。'
- en: '`ParallelLoopResult` provides the completion status of the parallel loop, as
    shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelLoopResult` 提供并行循环的完成状态，如下所示：'
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`ParallelLoopState` allows iterations of parallel loops to interact with other
    iterations. Finally, `LoopState` allows you to identify any exceptions in iterations,
    break from an iteration, stop an iteration, identify if any iteration has invoked
    break or stop, and break long-running iterations.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelLoopState` 允许并行循环的迭代与其他迭代交互。最后，`LoopState` 允许您识别迭代中的任何异常，从迭代中退出，停止迭代，识别是否有任何迭代调用了退出或停止，以及退出长时间运行的迭代。'
- en: PLINQ
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PLINQ
- en: '**Language-Integrated Query** (**LINQ**) was introduced in .NET Framework 3.5\.
    It allows us to query in-memory collections such as `List<T>`. You will learn
    more about LINQ in [Chapter 15](75481977-f6a3-41af-ab1e-e3b112dd9aad.xhtml), *Using
    LINQ Queries*. However, if you want to find out more sooner, more information
    can be found at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/index).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言集成查询** (**LINQ**) 在 .NET Framework 3.5 中引入。它允许我们对内存中的集合，如 `List<T>` 进行查询。您将在第
    15 章 [使用 LINQ 查询](75481977-f6a3-41af-ab1e-e3b112dd9aad.xhtml)中了解更多关于 LINQ 的信息。然而，如果您想早点了解更多，更多信息可以在
    [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/index)
    找到。'
- en: PLINQ is the parallel implementation of the LINQ pattern. They resemble LINQ
    queries and operate on any in-memory collections but differ in terms of execution.
    PLINQ uses all the available processors in the system. However, the processors
    are limited to 64 bits. This is achieved by partitioning the data source into
    smaller tasks and executing each task on separate worker threads on multiple processors.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ 是 LINQ 模式的并行实现。它们类似于 LINQ 查询，并操作任何内存中的集合，但在执行方面有所不同。PLINQ 使用系统中的所有可用处理器。然而，处理器限制在
    64 位。这是通过将数据源分区成更小的任务，并在多个处理器的单独工作线程上执行每个任务来实现的。
- en: 'Most of the standard query operators are implemented in the `System.Linq.ParallelEnumerable`
    class. The following table lists the various parallel execution-specific methods:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数标准查询运算符都实现在 `System.Linq.ParallelEnumerable` 类中。以下表格列出了各种并行执行特定的方法：
- en: '| `AsParallel` | When you want a system to perform parallel execution on an
    enumerable collection, the `AsParallel` instruction can be provided to the system.
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `AsParallel` | 当您希望系统在可枚举集合上执行并行执行时，可以向系统提供 `AsParallel` 指令。|'
- en: '| `AsSequential` | Instructing the system to run sequentially can be achieved
    by using `AsSequential`. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `AsSequential` | 使用 `AsSequential` 指示系统顺序运行。|'
- en: '| `AsOrdered` | To maintain the order on the result set, use `AsOrdered`. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `AsOrdered` | 要在结果集中保持顺序，请使用 `AsOrdered`。|'
- en: '| `AsUnordered` | To not maintain the order on the result set, use `AsUnordered`.
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `AsUnordered` | 要在结果集中不保持顺序，请使用 `AsUnordered`。|'
- en: '| `WithCancellation` | A cancellation token carries the user''s request to
    cancel the execution. This has to be monitored so that execution can be canceled
    at any time. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `WithCancellation` | 取消标记携带用户的取消执行请求。这必须被监控，以便可以在任何时候取消执行。|'
- en: '| `WithDegreeofParallelism` | Controls the number of processors to be used
    in a parallel query. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `WithDegreeofParallelism` | 控制并行查询中使用的处理器数量。|'
- en: '| `WithMergeOptions` | Provides options so that we can merge results to the
    parent task/thread/result set. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `WithMergeOptions` | 提供选项，以便我们可以将结果合并到父任务/线程/结果集中。|'
- en: '| `WithExecutionMode` | Forces the runtime to use either parallel or sequential
    modes. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `WithExecutionMode` | 强制运行时使用并行或顺序模式。|'
- en: '| `ForAll` | Allows results to be processed in parallel by not merging to the
    parent thread. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `ForAll` | 允许通过不合并到父线程来并行处理结果。|'
- en: '| `Aggregate` | A unique PLINQ overload to enable intermediate aggregation
    over thread-local partitions. Also allows us to merge the final aggregation to
    combine the results of all partitions. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `Aggregate` | 一个独特的PLINQ重载，用于在线程局部分区上启用中间聚合。同时允许我们将最终聚合合并以组合所有分区的结果。|'
- en: 'Let''s try to use some of these methods so that we can understand them in more
    detail. The `AsParallel` extension method binds query operators such as `where`
    and `select` to the `parallelEnumerable` implementation. By simply specifying
    `AsParallel`, we tell the compiler to execute the query in parallel:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用其中一些方法，以便我们可以更详细地理解它们。`AsParallel`扩展方法将`where`和`select`等查询运算符绑定到`parallelEnumerable`实现。通过简单地指定`AsParallel`，我们告诉编译器并行执行查询：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When executed, the preceding code block identifies all even numbers and prints
    them on the screen:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，前面的代码块识别所有偶数并在屏幕上打印它们：
- en: '![](img/ac50e5c7-f5b7-4416-9ae0-d113a7fa112a.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac50e5c7-f5b7-4416-9ae0-d113a7fa112a.png)'
- en: As you can see, the even numbers weren't printed in order. One thing to remember
    regarding parallel processing is that it does not guarantee any particular order.
    Try executing the code block multiple times and observe the output. It will differ
    each time since it is based on the number of processors that are available at
    the time of execution.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，偶数并没有按顺序打印。关于并行处理，有一点需要记住的是，它不保证任何特定的顺序。尝试多次执行代码块并观察输出。由于它基于执行时的处理器数量，所以每次都会有所不同。
- en: 'By using the `AsOrdered` operator, the code block accepts a range of numbers
    between 1 and 20\. However, using `AsOrdered` will order the numbers:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`AsOrdered`运算符，代码块接受1到20之间的数字范围。然而，使用`AsOrdered`将排序数字：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This example shows how we can maintain the order of the result set when using
    `Parallel`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了我们如何在使用`Parallel`时保持结果集的顺序：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you execute a code block using PLINQ, the runtime analyzes whether it is
    safe to parallelize the query. If it is, it partitions the query into tasks and
    then runs them concurrently. If it isn't safe to parallelize the query, it executes
    the query in a sequential pattern. In terms of performance, using a sequential
    algorithm is better than using a parallel algorithm, so by default, PLINQ selects
    the sequential algorithm. Using `ExecutionMode` will allow us to instruct PLINQ
    to select the parallel algorithm.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用PLINQ执行代码块时，运行时会分析查询是否可以并行化。如果是，它会将查询分区成任务然后并发运行。如果不安全并行化查询，它会以顺序模式执行查询。在性能方面，使用顺序算法比使用并行算法更好，因此默认情况下，PLINQ选择顺序算法。使用`ExecutionMode`将允许我们指示PLINQ选择并行算法。
- en: The following code block shows how we can use `ExecutionMode`**:**
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块展示了我们如何使用`ExecutionMode`：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we mentioned previously, PLINQ uses all the processors by default. However,
    by using the `WihtDegreeofParallelism` method, we can control the number of processors
    to be used:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，PLINQ默认使用所有处理器。然而，通过使用`WithDegreeofParallelism`方法，我们可以控制要使用的处理器数量：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Execute the preceding code block by changing the number of processors and observe
    the output. In the first scenario, we left the system to use the available cores/processors,
    but in the second one, we instructed the system to use three cores. You will see
    that the difference in performance is based on your system's configuration.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改处理器数量来执行前面的代码块并观察输出。在第一种情况下，我们让系统使用可用的核心/处理器，但在第二种情况下，我们指示系统使用三个核心。您将看到性能差异取决于您的系统配置。
- en: PLINQ also comes with a method called `AsSequential`. This is used to instruct
    PLINQ to execute queries sequentially until `AsParallel` is called.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ还提供了一个名为`AsSequential`的方法。这是用来指示PLINQ在调用`AsParallel`之前以顺序方式执行查询。
- en: '`forEach` can be used to iterate through all the results of a PLINQ query and
    merges the output from each task to the parent thread. In the preceding examples,
    we used `forEach` to display even numbers.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach`可以用来遍历PLINQ查询的所有结果并将每个任务的输出合并到父线程。在先前的示例中，我们使用`forEach`来显示偶数。'
- en: '`forEach` can be used to preserve the order of the PLINQ query results. So,
    when order preservation is not required and we want to achieve faster query execution,
    we can use the `ForAll` method. `ForAll` does not perform the final merge step;
    instead, it parallelizes the processing of results. The following code block is
    using `ForAll` to print output to the screen:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `forEach` 来保留 PLINQ 查询结果的顺序。因此，当不需要保留顺序并且我们想要实现更快的查询执行时，我们可以使用 `ForAll`
    方法。`ForAll` 不执行最终的合并步骤；相反，它并行化处理结果。以下代码块正在使用 `ForAll` 将输出打印到屏幕上：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this scenario, the I/O is being used by multiple tasks, so the numbers will
    appear in a random order:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，I/O 正被多个任务使用，因此数字将以随机顺序出现：
- en: '![](img/5d0ec129-6fe0-48d5-a435-dd2e500666d9.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d0ec129-6fe0-48d5-a435-dd2e500666d9.png)'
- en: 'When PLINQ executes in multiple threads, as the code runs, the application
    logic may fail in one or more threads. PLINQ uses the `Aggregate` exception to
    encapsulate all the exceptions that are thrown by a query and sends them back
    to the calling thread. When doing this, you need to have one `try..catch` block
    on the calling thread. When you get the results from the query, the developer
    can traverse through all the exceptions encapsulated in `AggregatedException`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PLINQ 在多个线程中执行时，随着代码的运行，应用程序逻辑可能在一个或多个线程中失败。PLINQ 使用 `Aggregate` 异常来封装查询抛出的所有异常，并将它们发送回调用线程。在这样做的时候，你需要在调用线程上有一个
    `try..catch` 块。当你从查询中获取结果时，开发者可以遍历 `AggregatedException` 中封装的所有异常：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code block is writing all the details from an exception that
    was thrown in a PLINQ. Here, we are traversing and showcasing all six exceptions:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块正在从 PLINQ 中抛出的异常中写入所有详细信息。在这里，我们正在遍历并展示所有六个异常：
- en: '![](img/a0f88c43-4592-4dbc-9f2e-836dd9016e98.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0f88c43-4592-4dbc-9f2e-836dd9016e98.png)'
- en: You can loop through the `InnerExceptions` property and take necessary actions.
    We will look at inner exceptions in more detail in [Chapter 7](7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml),
    *Implementing Exception Handling*. However, in this case, when a PLINQ is executed,
    instead of terminating the execution on an exception, it will run through all
    the iterations and provide the final results.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过遍历 `InnerExceptions` 属性并采取必要的行动。我们将在 [第 7 章](7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml)
    中更详细地探讨内部异常，*实现异常处理*。然而，在这种情况下，当 PLINQ 执行时，它不会在异常上终止执行，而是会运行所有迭代并提供最终结果。
- en: Asynchronous programming with async and await
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 async 和 await 进行异步编程
- en: '**Asynchronous programming** can help you enhance the responsiveness and performance
    of an application. In a traditional approach, it is difficult to write and maintain
    asynchronous code. However, C# 5 introduced two new keywords that simplify asynchronous
    programming: `async` and `await`. When encountered, the C# compiler does all the
    difficult work for you. It resembles synchronous code. `Task` and `Task<T>` are
    at the core of asynchronous programming.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步编程**可以帮助你提高应用程序的响应性和性能。在传统方法中，编写和维护异步代码比较困难。然而，C# 5 引入了两个新的关键字，简化了异步编程：`async`
    和 `await`。当遇到这些关键字时，C# 编译器会为你完成所有困难的工作。它类似于同步代码。`Task` 和 `Task<T>` 是异步编程的核心。'
- en: Any I/O-bound or CPU-bound code can utilize asynchronous programming. In the
    case of IO-bound code, when you want to return a task from an `async` method,
    we use the `await` operation, whereas in CPU-bound code we wait for the operation
    that started a background thread using `Task.Run`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 I/O 密集型或 CPU 密集型代码都可以利用异步编程。在 I/O 密集型代码的情况下，当你想从 `async` 方法返回一个任务时，我们使用 `await`
    操作，而在 CPU 密集型代码中，我们使用 `Task.Run` 等待启动后台线程的操作。
- en: When the `await` keyword is used, it returns control to the calling methods,
    thus allowing the UI to be responsive.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `await` 关键字时，它将控制权返回给调用方法，从而允许 UI 保持响应。
- en: 'Internally, when the compiler encounters the `async` keyword, it splits the
    method into tasks, and each task is marked with the `await` keyword. The `await`
    keyword generates code that will check whether the asynchronous operation has
    already completed; that is, the C# compiler transforms the code into a state machine
    that keeps track of the metadata related to each task/thread so that it can resume
    execution when the background task has finished executing:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，当编译器遇到 `async` 关键字时，它会将方法分割成任务，并且每个任务都会被标记上 `await` 关键字。`await` 关键字生成代码，用于检查异步操作是否已经完成；也就是说，C#
    编译器将代码转换成一个状态机，它跟踪与每个任务/线程相关的元数据，以便在后台任务执行完毕后恢复执行：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code block, we are trying to find how many times a specific
    word has been used on a website. The output of the previous code is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们正在尝试找出一个特定单词在网站上被使用了多少次。前一个代码的输出如下：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we used the `async` keyword on the `GetDotnetCountAsync` method. Although
    the method is executed synchronously, the `await` keyword allows us to return
    to the calling method and wait until the `async` method has finished executing,
    which is when it returns the result.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `GetDotnetCountAsync` 方法上使用了 `async` 关键字。尽管方法是以同步方式执行的，但 `await` 关键字允许我们返回到调用方法并等待直到
    `async` 方法完成执行，此时它返回结果。
- en: It is important to understand that an `async` method body should always have
    an `await`, otherwise this method will never yield. No error is raised by the
    compiler either.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，异步方法体应该始终包含一个 `await`，否则此方法永远不会释放。编译器也不会引发错误。
- en: When writing asynchronous methods, you should always use `async` as the suffix.
    Note that `async` must be used for event handlers. This is the only method that
    allows `async` events handlers to work as events do not have return types.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写异步方法时，你应该始终使用 `async` 作为后缀。请注意，`async` 必须用于事件处理器。这是唯一允许 `async` 事件处理器像事件一样工作的方法，因为事件没有返回类型。
- en: You can read more about the **Task-Based Asynchronous Pattern** (**TAP**) from
    MSDN at [https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 MSDN 在 [https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)
    上了解更多关于**基于任务的异步模式**（**TAP**）的信息。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at threads, their properties, how we can use parameterized
    threads, and the difference between foreground and background threads with detailed
    examples. We also learned about thread states and how threads store and share
    data across multiple threads. This is where we discussed different synchronization
    methods. We focused on parallel programming, tasks and asynchronous programming
    using tasks, how to use parallel classes, and PLINQ.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了线程、它们的属性、如何使用参数化线程，以及通过详细示例说明了前台线程和后台线程之间的区别。我们还学习了线程状态以及线程如何在多个线程之间存储和共享数据。这就是我们讨论不同同步方法的地方。我们重点介绍了并行编程、任务以及使用任务的异步编程，如何使用并行类，以及
    PLINQ。
- en: In the next chapter, we will explore exception handling in C#. Exception handling
    helps us deal with any unexpected or exceptional situations that occur during
    program execution. Exception handling uses the `try`, `catch`, and `finally` blocks.
    These help developers try out actions that may or may not succeed, handle failures
    if they occur, and clean up unwanted resources, respectively.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 C# 中的异常处理。异常处理帮助我们处理程序执行过程中出现的任何意外或异常情况。异常处理使用 `try`、`catch` 和 `finally`
    块。这些块分别帮助开发者尝试可能成功或失败的操作，处理如果发生失败的情况，以及清理不需要的资源。
- en: Questions
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: By default, the main method of your code block runs as which of the following?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，你的代码块的主方法以以下哪种方式运行？
- en: Worker thread
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作线程
- en: Primary thread
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主线程
- en: Background thread
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后台线程
- en: None of the above
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非
- en: What action needs to be performed to move a thread to the run state when suspended?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当线程被暂停时，需要执行什么操作才能将其移动到运行状态？
- en: Interrupt
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中断
- en: Resume
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复
- en: Abort
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中断
- en: Suspended
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停
- en: What is the correct keyword to use while working on synchronization code regions?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写同步代码区域时，应该使用哪个正确的关键字？
- en: Lock
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁
- en: Release
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放
- en: Getlock
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取锁
- en: Unlock
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解锁
- en: A task may or may not return a value.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个任务可能返回或不返回值。
- en: 'True'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
- en: When working with PLINQ, the results are returned in order.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用 PLINQ 时，结果将按顺序返回。
- en: 'True'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
- en: Answers
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '**Primary thread**'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**主线程**'
- en: '**Resume**'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**恢复**'
- en: '**Lock**'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**锁**'
- en: '**True**'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**真**'
- en: '**False**'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**假**'
- en: Further reading
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In this chapter, we talked about many features that .NET Framework offers that
    we can use in our applications. However, we didn''t cover this topic in detail.
    Therefore, it may be useful for you to go through a couple of MSDN articles so
    that you can understand more about these concepts. Take a look at the following
    links:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 .NET Framework 提供的许多功能，这些功能我们可以用于我们的应用程序。然而，我们没有详细涵盖这个主题。因此，你可能需要阅读几篇
    MSDN 文章，以便更好地理解这些概念。查看以下链接：
- en: More on application domains can be found at [https://docs.microsoft.com/en-us/dotnet/framework/app-domains/application-domains#application-domains-and-threads](https://docs.microsoft.com/en-us/dotnet/framework/app-domains/application-domains#application-domains-and-threads).
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于应用程序域的信息可以在[https://docs.microsoft.com/en-us/dotnet/framework/app-domains/application-domains#application-domains-and-threads](https://docs.microsoft.com/en-us/dotnet/framework/app-domains/application-domains#application-domains-and-threads)找到。
- en: More on threads and processes can be found at [https://docs.microsoft.com/en-us/windows/desktop/procthread/processes-and-threads](https://docs.microsoft.com/en-us/windows/desktop/procthread/processes-and-threads).
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于线程和进程的信息可以在[https://docs.microsoft.com/en-us/windows/desktop/procthread/processes-and-threads](https://docs.microsoft.com/en-us/windows/desktop/procthread/processes-and-threads)找到。
- en: 'The following documentation on parallel programming will help you understand
    some of the topics that we didn''t cover in this chapter: [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/for-further-reading-parallel-programming](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/for-further-reading-parallel-programming).'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下关于并行编程的文档将帮助你理解本章未涉及的一些主题：[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/for-further-reading-parallel-programming](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/for-further-reading-parallel-programming).
- en: 'One of the concepts that you''ll need to understand while working with tasks
    is task schedulers: [https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler?view=netframework-4.7.2).'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理任务时，你需要理解的一个概念是任务调度器：[https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks/taskscheduler?view=netframework-4.7.2).
- en: 'The following article about async provides more information about all the moving
    pieces that are used when asynchronous operations are performed: [https://docs.microsoft.com/en-us/dotnet/standard/async-in-depth](https://docs.microsoft.com/en-us/dotnet/standard/async-in-depth).'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下关于异步的文章提供了更多关于在执行异步操作时使用的所有移动部件的信息：[https://docs.microsoft.com/en-us/dotnet/standard/async-in-depth](https://docs.microsoft.com/en-us/dotnet/standard/async-in-depth).
