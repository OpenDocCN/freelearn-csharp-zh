- en: Introduction to Reactive Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式微服务的介绍
- en: 'We have now gained a clear understanding of microservices-based architecture
    and how to harness its power. Up until now, we''ve discussed various aspects of
    this architecture, such as communication, deployment, and security, in detail.
    We also looked at how microservices collaborate when required. Now let''s take
    the effectiveness of microservices to the next level by introducing the reactive
    programming aspect within them. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经清楚地理解了基于微服务的架构以及如何利用其力量。到目前为止，我们已经详细讨论了该架构的各个方面，例如通信、部署和安全。我们还研究了微服务在需要时如何协作。现在，通过在它们中引入反应式编程方面，让我们将微服务的有效性提升到下一个层次。我们将涵盖以下主题：
- en: Understanding reactive microservices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解反应式微服务
- en: Mapping processes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程映射
- en: Communication in reactive microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式微服务的通信
- en: Handling security
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理安全
- en: Managing data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理数据
- en: The microservice ecosystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务生态系统
- en: Understanding reactive microservices
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解反应式微服务
- en: Before we dive into reactive microservices, let's see what the word *reactive* means.
    There are certain fundamental attributes that a piece of software must possess
    in order to be considered reactive. These attributes are responsiveness, resilience,
    elasticity, and above all, being message-driven. We'll discuss these attributes
    in detail and look at how they can make microservices stronger candidates for
    most enterprise requirements.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入反应式微服务之前，让我们看看“反应式”这个词的含义。为了被认为是反应式的，一个软件组件必须具备某些基本属性。这些属性包括响应性、弹性、可伸缩性，最重要的是，以消息驱动。我们将详细讨论这些属性，并探讨它们如何使微服务成为满足大多数企业需求更强的候选者。
- en: Responsiveness
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应性
- en: It wasn't long ago when one of the key requirements of business sponsors, discussed
    in requirement gathering sessions, was a guaranteed response time of a few seconds.
    For example, a T-shirt custom print e-shop where you could upload images and then
    have it rendered onto the chosen piece of apparel. Move forward a few years and—I
    can vouch for this myself—we will close the browser window if any web page takes
    longer than a couple of seconds to load.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不久前，业务赞助商在需求收集会议中讨论的一个关键要求是保证几秒钟的响应时间。例如，一个T恤定制打印网店，你可以上传图片，然后将其渲染到所选的服装上。向前推进几年——我可以为此作证——如果任何网页加载时间超过几秒钟，我们将关闭浏览器窗口。
- en: Users today expect near instantaneous response. But this is not possible unless
    the code that you write follows certain standards to deliver the expected performance.
    There will always be so many different components cooperating and coordinating
    to solve some business problem. The time that each component is expected to return
    the results in has therefore reduced to milliseconds today. Also, the system has
    to exhibit consistency along with performance when it comes to response time.
    If you have a service that exhibits variable response times over a defined period,
    then it is a sign of an impending problem in your system. You will have to, sooner
    or later, deal with this baggage. And there is no doubt that in most cases, you
    will manage to solve it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 用户今天期望几乎瞬间的响应。但除非你编写的代码遵循某些标准以提供预期的性能，否则这是不可能的。总会有许多不同的组件协同合作和协调以解决某些业务问题。因此，每个组件预期返回结果的时间已经减少到现在的毫秒级。此外，当涉及到响应时间时，系统必须表现出一致性和性能。如果你有一个在定义时间段内表现出可变响应时间的服务，那么这是你系统中即将出现问题的迹象。你迟早必须处理这个负担。毫无疑问，在大多数情况下，你将设法解决这个问题。
- en: However, the challenge is much bigger than what is visible on the surface. Any
    such trait needs to be probed for the possibility of an issue in the design. It
    could be some kind of dependency on another service, too many functions performing
    at the same time within the service, or synchronous communication blocking the
    workflow at some point.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，挑战比表面上的更大。任何这样的特性都需要检查设计中可能存在的问题。这可能是对另一个服务的某种依赖，服务中同时执行太多功能，或者同步通信在某些时候阻塞了工作流程。
- en: Resilience
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: With all the buzz around distributed computing, what does a user expect from
    such a system in the event of the failure of one or more components? Does a single
    failure result in a catastrophic domino effect, resulting in the failure of the
    entire system? Or does the system bounce back from such an event with grace and
    within expected timelines? The end user shouldn't be affected at all in such scenarios,
    or the system should at least minimize the impact to an extent, ensuring that
    user experience is not affected.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式计算的喧嚣声中，当系统的一个或多个组件出现故障时，用户期望从这样的系统中得到什么？单个故障会导致灾难性的多米诺骨牌效应，导致整个系统失败吗？或者系统会优雅地、在预期的时限内从这种事件中恢复过来？在这种情况下，最终用户不应受到影响，或者系统至少应将影响降至最低，确保用户体验不受影响。
- en: Reactive microservices take the concept of microservices to the next level.
    As the number of microservices grows, so does the need for communication between
    them. It won't be very long before the task of tracking a list of a dozen other
    services, orchestrating a cascading transaction between them, or just generating
    a notification across a set of services, becomes a challenge. In the scope of
    this chapter, the concept of cascading is more important than the transaction
    itself. Instead of the transaction, it could very well be just the need to notify
    some external system based on some filtering criteria.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式微服务将微服务的概念提升到了新的水平。随着微服务数量的增加，它们之间的通信需求也在增加。不久，跟踪一打其他服务的列表、在它们之间编排级联事务，或者只是向一组服务生成通知的任务，将变得具有挑战性。在本章的范围内，级联的概念比事务本身更重要。它可能不仅仅是通知外部系统的需求，而是基于某些过滤标准。
- en: The challenge arises as an enterprise-level microservice-based system would
    always extend far beyond a handful of microservices. The sheer size and complexity
    of this cannot be pictured fully here in a chapter. In such a scenario, the need
    to track a set of microservices and communicate with them can quickly become nightmarish.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于企业级基于微服务的系统通常会远远超出几个微服务。这种规模和复杂性的全面图景在这里的章节中无法完全展现。在这种情况下，跟踪一组微服务并与它们通信的需求可能会迅速变得令人头疼。
- en: What if we could take away the responsibility of communicating an event to other
    microservices from individual microservices? The other aspect of this could very
    well be freedom for the services in the ecosystem from being tracked. To do this,
    you will have to keep track of their whereabouts. Just add authentication to this
    and you could very easily be tangled in a mess you never signed up for.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能从单个微服务中移除向其他微服务传达事件的职责呢？这个问题的另一个方面可能是生态系统中的服务从跟踪中获得的自由。为了做到这一点，你需要跟踪它们的位置。只需添加认证，你就能轻易陷入一个你从未签约的混乱之中。
- en: The solution lies in a design change, where the responsibility of tracking microservices
    for an event or communicating an event to others is taken away from individual
    microservices.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案在于设计上的改变，即将跟踪事件或向他人传达事件的职责从单个微服务中移除。
- en: While transitioning from a monolithic application to a microservice-style architecture,
    we learned that they are isolated. Using seam identification, we isolated modules
    into independent sets of services that own their data and don't allow other microservices/processes
    to access them directly. We achieved autonomy by catering to a single business
    functionality and taking care of aspects such as its data and encapsulated business
    functionality. Asynchronous was another characteristic that we achieved for our
    microservices in order to make non-blocking calls to them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在从单体应用过渡到微服务风格的架构时，我们了解到它们是隔离的。通过接口识别，我们将模块隔离成独立的服务集合，这些服务拥有自己的数据，并且不允许其他微服务/进程直接访问它们。我们通过满足单一业务功能并关注其数据和封装的业务功能等方面实现了自治。异步性是我们为微服务实现的另一个特性，以便能够进行非阻塞调用。
- en: Autonomous
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自主
- en: All along, we have been strongly advocating the correct isolation of microservices.
    Seam identification was a concept we briefly touched on in Chapter 2, *Implementing
    Microservices*. There were numerous benefits that we derived while successfully
    implementing the microservice-style architecture. We can safely state that isolation
    is one of the fundamental requirements here. However, the benefits of successful
    implementation of isolation go far beyond that.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，我们就强烈倡导正确地隔离微服务。在第二章“实现微服务”中，我们简要提到了一个概念——接口识别。在成功实施微服务风格的架构时，我们从中获得了许多好处。我们可以安全地断言，隔离是这里的基本要求之一。然而，成功实施隔离的好处远不止于此。
- en: It is very important for microservices to be autonomous, or else our work will
    be incomplete. Even after implementing the microservice architecture, if one microservice
    failure results in a delay for other services or a domino effect, it means we
    missed something in our design. However, if microservice isolation is done right,
    along with the right breakdown of the functionality to be performed by this particular
    microservice, it would mean that the rest of the design would fall into place
    itself to handle any kind of resolution conflict, communication, or coordination.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务来说，实现自主性非常重要，否则我们的工作将是不完整的。即使实现了微服务架构，如果某个微服务的故障导致其他服务延迟或产生多米诺效应，这意味着我们在设计中遗漏了某些内容。然而，如果微服务隔离做得正确，再加上对特定微服务要执行的功能的正确分解，那么其余的设计就会自行到位，以处理任何类型的解决冲突、通信或协调。
- en: The information required to perform such an orchestration would depend primarily
    on the well-defined behavior of the service itself. So, the consumer of a microservice
    that is well-defined doesn't need to worry about the microservice failing or throwing
    an exception. If there is no response within the stipulated period of time, just
    try again.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此类编排所需的信息主要取决于服务本身的良好定义的行为。因此，对定义良好的微服务的消费者来说，不需要担心微服务失败或抛出异常。如果在规定的时间内没有响应，只需再次尝试即可。
- en: 'Message-driven: a core of reactive microservices'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息驱动：反应式微服务的核心
- en: Being message-driven is the core of reactive microservices. All reactive microservices
    define, as part of their behavior, any event that they might be generating. These
    events may or may not have additional information payloads within them, depending
    on the design of the individual event. The microservice that is the generator
    of this event would not be bothered about whether the event generated was acted
    upon or not. Within the scope of this specific service, there is no behavioral
    definition for the action beyond the generation of this event. The scope ends
    there. It is now, in terms of the rest of the system, comprising other microservices
    to act upon this information based on their individual scope.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 成为消息驱动是反应式微服务的核心。所有反应式微服务都将它们可能生成的事件定义为它们行为的一部分。这些事件可能包含或不包含额外的信息负载，这取决于单个事件的设计。生成此事件的微服务不会关心生成的事件是否被处理。在这个特定服务的范围内，没有关于生成此事件之外的行为定义。范围到此为止。现在，从整个系统的角度来看，其他微服务将根据它们各自的范围来处理这些信息。
- en: The difference here is that all these events being generated could be captured
    asynchronously by listening to them. No other service is waiting in blocking mode
    for any of these services. Anyone listening to these events is called a subscriber,
    and the action of listening for the events is called subscribing. The services
    that subscribe to these events are called **observers**, and the source service
    of the events generated is called **observable**. This pattern is known as the
    **Observer Design Pattern**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的区别在于，所有这些生成的事件都可以通过监听它们来异步捕获。没有其他服务在等待阻塞模式下的任何这些服务。任何监听这些事件的人被称为订阅者，监听事件的行为被称为订阅。订阅这些事件的称为**观察者**，生成这些事件的源服务称为**可观察者**。这种模式被称为**观察者设计模式**。
- en: However, the very exercise of a concrete implementation on each of the observers
    is somewhat inconsistent with our motto of designing loosely coupled microservices.
    If this is what you are thinking, then you have the right thinking cap on and
    we are on the right track. In a short while, when mapping our processes as reactive
    microservices, we will see how we can achieve this purpose in the world of reactive
    microservices.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在每个观察者上具体实现的练习与我们的设计松耦合微服务的座右铭有些不一致。如果你这样想，那么你戴上了正确的思考帽，我们正走在正确的轨道上。在不久的将来，当我们将我们的流程映射为响应式微服务时，我们将看到如何在响应式微服务的世界中实现这一目标。
- en: Before we go on with mapping our processes, it is important that we briefly
    discuss the pattern with respect to our topic here. In order to act upon a message,
    you first need to show your intent to watch the message of that type. At the same
    time, the originator of the message must have an intent to publish such a message
    to the interested observers. So there would be at least one observable to be observed
    by one or more observers. To add some spice to it, the observable can publish
    more than one type of message, and the observers can observe one or more of the
    messages they intend to act upon.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续映射我们的流程之前，简要讨论一下与我们的主题相关的模式是很重要的。为了对一条消息采取行动，你首先需要表明你想要观察该类型消息的意图。同时，消息的发起者必须有意向向感兴趣的观察者发布此类消息。因此，至少有一个可观察对象将被一个或多个观察者观察。为了增加一些趣味性，可观察对象可以发布多种类型的信息，而观察者可以观察他们打算采取行动的一个或多个信息。
- en: The pattern doesn't restrict observers from unsubscribing when they want to
    stop listening for these messages. So, it sounds pretty, but is it as easily implemented?
    Let's move ahead and look at this for ourselves.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式并不限制观察者在想要停止监听这些消息时取消订阅。所以，听起来很美，但它的实现是否同样容易？让我们继续前进，亲自看看。
- en: Let's make code reactive
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们编写响应式代码
- en: 'Let''s examine our application and see how it would look with the reactive
    style of programming. The following diagram depicts the flow of the application
    that is reactive in nature and is completely event-driven. In this diagram, services
    are depicted by hexagons, and events are represented by square boxes. Here''s the
    entire flow in detail:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们的应用程序，看看它将以响应式编程风格看起来如何。以下图显示了具有响应性且完全由事件驱动的应用程序的流程。在这个图中，服务以六边形表示，事件以方形框表示。以下是整个流程的详细说明：
- en: '![](img/d6ac2cf0-9c5d-4f19-b41c-08ee4fc70e68.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d6ac2cf0-9c5d-4f19-b41c-08ee4fc70e68.png)'
- en: The flow depicted in the diagram describes the scenario of a customer placing
    an order after having searched for the items he/she is looking for. The **Place
    order** event is raised to **Order service**. In response to this event, our service
    analyzes arguments, such as order item and quantity, and raises the **Item **available event
    to **Product service**. From here on, there are two possible outcomes: either
    the requested product is available and has the required quantity or it is not
    available or doesn't have the required quantity. If the items are available, **Product
    service** raises an event called generate invoice to **Invoice service**. Since
    raising the invoice means confirming the order, the items on the invoice would
    no longer be available in stock; we need to take care of this and update the stock
    accordingly. To handle this, our invoice service further raises an event called **Update
    Product Quantity** to **Product service** and takes care of this requirement.
    For the sake of simplicity, we will not go into the details of who will handle
    the event of **Mail invoice**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图中描述的流程描述了客户在搜索到他们想要的商品后下订单的场景。**下订单**事件被触发到**订单服务**。对此事件的响应，我们的服务分析诸如订单项目和数量等参数，并将**项目可用**事件触发到**产品服务**。从现在开始，有两种可能的结局：要么请求的产品可用且有足够的数量，要么不可用或没有足够的数量。如果项目可用，**产品服务**会向**发票服务**触发一个名为生成发票的事件。由于开出发票意味着确认订单，发票上的项目将不再有库存；我们需要注意这一点并相应地更新库存。为了处理这个问题，我们的发票服务进一步向**产品服务**触发一个名为**更新产品数量**的事件，并处理这一需求。为了简化，我们不会深入探讨谁将处理**邮寄发票**事件的细节。
- en: Event communication
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件通信
- en: 'The preceding discussion may have left you thinking about how the event being
    raised maps the call of the respective microservice perfectly; let''s discuss
    this in further detail. Think of all the events being raised as being stored in
    an event store. The event stored has an associated delegate function that is called
    to cater to the respective event. Although it is shown that the store has just
    two columns, it stores much more information, such as details of the publisher,
    subscriber, and so on. Each event contains the complete information that is required
    to trigger the corresponding service. So event delegation might be a service to
    be called or a function within the application itself. It doesn''t matter to this
    architecture:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的讨论可能让你在思考被引发的事件如何完美地映射到相应的微服务的调用；让我们进一步详细讨论这个问题。想象一下，所有被引发的事件都存储在一个事件存储中。存储的事件有一个关联的委托函数，用于处理相应的事件。尽管显示存储只有两列，但它存储了更多信息，例如发布者、订阅者等的详细信息。每个事件都包含触发相应服务所需的全部信息。因此，事件委托可能是一个要调用的服务或应用程序内的一个函数。对于这个架构来说，这并不重要：
- en: '![](img/29962310-822b-4399-9140-311aacc3da72.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29962310-822b-4399-9140-311aacc3da72.jpg)'
- en: Security
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: There are numerous ways in which security can be handled while implementing
    reactive microservices. However, given the limited scope that we have here, we
    will restrict our discussion to one type only. Let's go on and discuss message-level
    security here and see how it is done.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现反应式微服务时，有无数种处理安全性的方法。然而，鉴于我们有限的范围，我们将只讨论一种类型。让我们继续讨论消息级安全，看看它是如何实现的。
- en: Message-level security
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息级安全
- en: Message-level security is the most fundamental method available to secure your
    individual request messages. After the initial authentication is performed, the
    request message itself may contain the OAuth bearer token or the JWTs, based on
    the implementation. This way, each and every request is authenticated, and the
    information related to the user can be embedded within these tokens. The information
    could be as simple as a username along with an expiration timestamp indicating
    token validity. After all, we don't want to allow a token to be utilized beyond
    a certain time frame.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 消息级安全是保护你单个请求消息的最基本方法。在初始认证执行后，根据实现方式，请求消息本身可能包含OAuth承载令牌或JWT。这样，每个请求都会被认证，并且与用户相关的信息可以嵌入到这些令牌中。这些信息可能很简单，比如一个用户名，以及一个表示令牌有效期的过期时间戳。毕竟，我们不想允许令牌在某个时间框架之外被使用。
- en: However, it is important to note here that you are free to implement it in such
    a manner so that a lot more information can be embedded and utilized for different
    uses.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里重要的是要注意，你可以自由地以这种方式实现它，以便可以嵌入和利用更多信息用于不同的用途。
- en: Scalability
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性
- en: There is another aspect you need to consider here as well. Within this token,
    we could also embed authorization information apart from authentication information.
    Note that having all of this information within a token that is being passed around
    frequently could soon become an overhead. We can make the necessary changes to
    ensure that the information pertaining to the authorization is a one-time activity
    and is later persisted with the services as required.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个方面你需要考虑。在这个令牌中，我们还可以嵌入除了认证信息之外的授权信息。请注意，所有这些信息都包含在频繁传递的令牌中，可能会很快成为负担。我们可以进行必要的更改，确保与授权相关的信息是一次性活动，并且随后根据需要与服务持久化。
- en: When we decide to persist authorization-related information with individual
    services, we make them elastic in a way. The task of persisting authorization
    information with individual services does away with the requirement of reaching
    out to the authentication service each time for authorization-related data. This
    means we can scale our services quite easily.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们决定与各个服务持久化授权相关信息时，我们以这种方式使它们变得灵活。使用各个服务持久化授权信息的任务消除了每次都需要从认证服务获取授权相关数据的需要。这意味着我们可以非常容易地扩展我们的服务。
- en: Communication resilience
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信弹性
- en: What would happen if the authentication service that contains all the user authentication
    data and authorization data became unavailable? Does this mean that the entire
    microservice ecosystem would come down to its knees, as all the actions—or a big
    percentage of them—would need to be authorized for the user attempting the action?
    This does not fit in the domain of the microservice architecture. Let's see how
    we could deal with this.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含所有用户认证数据和授权数据的认证服务变得不可用，会发生什么？这是否意味着整个微服务生态系统都会崩溃，因为所有动作——或者大部分动作——都需要对尝试执行动作的用户进行授权？这不符合微服务架构的领域。让我们看看我们如何处理这种情况。
- en: One way would be to replicate user authorization data within each service that
    requires it. When the authorization data is already available with the respective
    services, it will reduce the data being transferred through the JWTs being moved
    around. What this would achieve is that in the event our Auth service becomes
    unavailable, the users who are authenticated and have accessed the system would
    not be affected. With all of the authorization data already available within the
    individual services that need to verify it, the business can continue as usual
    without any hindrances.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在每个需要它的服务中复制用户授权数据。当授权数据已经与相应服务可用时，将减少通过JWT（JSON Web Tokens）传输的数据量。这将实现的是，如果我们的Auth服务变得不可用，已经认证并访问系统的用户将不会受到影响。由于所有授权数据已经存在于需要验证的各个服务中，业务可以继续进行，没有任何阻碍。
- en: However, this approach comes with a price of its own. It will become a challenge
    to maintain this data, as it is updated all the time with all the services. The
    replication required for each service would be an exercise in itself. There is
    a way out of this specific challenge as well, though.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法也有其自身的代价。由于数据需要随时更新以适应所有服务，维护这些数据将变得具有挑战性。为每个服务所需的复制本身就是一个挑战。尽管如此，也有解决这个特定挑战的方法。
- en: Instead of making this data available in all the microservices, we could simply
    store it in a central store and have the services validate/access authorization-related
    data from this central store. This would enable us to build resilience beyond
    the authentication service.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在所有微服务中提供这些数据，我们可以在一个中心存储中简单地存储它，并让服务从这个中心存储验证/访问授权相关数据。这将使我们能够构建超出认证服务的弹性。
- en: Managing data
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理数据
- en: Tracking a single order being placed is easy. However, multiply that number
    with the million orders being placed and canceled every hour; it could quickly
    become a challenge in the reactive microservices domain. The challenge is how
    you would perform a transaction across multiple services. Not only is it difficult
    to track such a transaction, but it poses other challenges, such as persisting
    such a transaction that spans the database and message broker. The task of reversing
    such an operation in the likelihood of the transaction breaking somewhere in the
    middle due to a service failure could be even more daunting.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪单个订单的下单过程是容易的。然而，将这个数字乘以每小时数百万个订单的下单和取消，在反应式微服务领域可能会迅速成为一个挑战。挑战在于如何在多个服务之间执行事务。不仅跟踪此类事务很困难，而且它还带来了其他挑战，例如持久化跨越数据库和消息代理的事务。如果在中间某个服务失败导致事务中断的情况下，这种操作的撤销任务可能会更加艰巨。
- en: In such a scenario, we can utilize the event sourcing pattern. This is a strong
    candidate, especially since we are not looking for a two-phase commit, generally
    referred to as 2PC. Instead of storing a transaction, we persist all the state-changing
    events of our entities. In other words, we store all the events that change their
    states in the form of entities, such as order and product. When a client places
    an order, then under regular circumstances, we would persist the order to the
    order table as a row. However, here we will persist the entire sequence of events,
    up to the final stage of the order being accepted or rejected.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以利用事件溯源模式。这是一个强有力的候选方案，尤其是因为我们不寻求通常称为2PC（两阶段提交）的两阶段提交。我们不是存储事务，而是持久化我们实体的所有状态改变事件。换句话说，我们以实体的形式存储所有改变它们状态的事件，例如订单和产品。当客户端下单时，在正常情况下，我们会将订单持久化到订单表作为一行。然而，在这里我们将持久化整个事件序列，直到订单被接受或拒绝的最终阶段。
- en: 'Refer to the preceding diagram, where we analyzed the sequence of events that
    are generated while creating an order. Look at how those events will be stored
    in this pattern and how a transaction would be deduced from that set of events.
    First, let''s see how the data will be stored. As seen in the following diagram,
    individual records are saved as rows. Data consistency is confirmed after the
    transaction:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前图，我们分析了创建订单时生成的事件序列。看看这些事件将如何在这个模式中存储，以及如何从这些事件集中推导出事务。首先，让我们看看数据将如何存储。如以下图所示，单个记录作为行保存。数据一致性在事务后得到确认：
- en: '![](img/ca2d4397-ca55-4e7f-885a-13b3b13361e1.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca2d4397-ca55-4e7f-885a-13b3b13361e1.png)'
- en: 'As seen in the preceding diagram, the **Product service** can subscribe to
    the order events and update itself accordingly. There are numerous benefits to
    be derived from this approach, such as:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，**产品服务**可以订阅订单事件并相应地更新自己。从这个方法中可以衍生出许多好处，例如：
- en: Since the events are being persisted, the challenge of recognizing a transaction
    is separated from the task of maintaining database integrity
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于事件正在持久化，识别事务的挑战与维护数据库完整性的任务分离了
- en: It is possible to find the exact state of the system at any given point in time
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有可能在任何给定时间点找到系统的确切状态
- en: It is easier to migrate a monolith with this approach
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这种方法更容易迁移单体应用
- en: It is possible to move back in time to a specific set of events and identify
    any possible problems
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有可能回到过去，识别任何可能的问题
- en: 'The following image is depicting our **Order** and **Order Details** table(s)
    in view of **Order service**:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了我们的**订单**和**订单详情**表（s）在**订单服务**视图下的情况：
- en: '![](img/8cc3dc4a-12d7-43fe-9d19-86f35c3706be.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8cc3dc4a-12d7-43fe-9d19-86f35c3706be.png)'
- en: Apart from all the benefits, it has some drawbacks as well. The most important
    one is how to query the event store. To reconstruct the state of a given business
    entity at a given point in time would require some complex queries. Apart from
    this, there would be a learning curve involved to grasp the concept of an event
    store replacing the database and then deducing the state of an entity. Query complexity
    can be handled with the help of the CQRS pattern easily. However, this will be
    outside the scope of this chapter. It is worthwhile to note that the event sourcing
    pattern and CQRS deserve separate chapters in the wake of reactive microservices.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有的好处之外，还有一些缺点。其中最重要的一点是如何查询事件存储。要重建给定业务实体在特定时间点的状态，需要一些复杂的查询。除此之外，还需要一个学习曲线来掌握事件存储替代数据库并推导实体状态的概念。查询复杂性可以通过CQRS模式轻松处理。然而，这超出了本章的范围。值得注意的是，事件源模式和CQRS在响应式微服务之后值得有单独的章节。
- en: The microservice ecosystem
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务生态系统
- en: As discussed in the initial chapters, we need to get ready for big changes when
    embracing microservices. The discussions we've presented on deployment, security,
    and testing so far would have had you thinking by now about accepting this fact.
    Unlike monoliths, the adoption of microservices requires you to prepare beforehand
    so that you start building the infrastructure along with it and not after it.
    In a way, microservices thrive in a complete ecosystem where everything is worked
    out, from deployment to testing, security, and monitoring. The returns associated
    with embracing such a change are huge. There is definitely a cost involved to
    make all these changes. However, instead of having a product that doesn't get
    on the market, it is better to incur some costs and design and develop something
    that thrives and does not die out after the first few rollouts.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所讨论的，当我们采用微服务时，我们需要为即将到来的大变化做好准备。到目前为止，我们关于部署、安全和测试的讨论可能会让你现在开始考虑接受这个事实。与单体应用不同，采用微服务需要你事先做好准备，以便你开始构建与之相关的基础设施，而不是在之后。从某种意义上说，微服务在一个完整生态系统中蓬勃发展，从部署到测试、安全性和监控，一切都已安排妥当。接受这种变化的回报是巨大的。当然，要做出所有这些改变肯定会有成本。然而，与其有一个无法上市的产品，不如承担一些成本，设计和开发出能够茁壮成长并在最初几轮发布后不会消亡的东西。
- en: Coding reactive microservices
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码响应式微服务
- en: Now, let's try to sum up everything and see how it actually looks in the code.
    We will use Visual Studio 2017 for this. The first step is to create a reactive
    microservice, and then we will move onto creating a client for consuming the service
    created by us.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试总结一下，看看它在代码中实际上看起来如何。我们将使用Visual Studio 2017来完成此操作。第一步是创建一个反应式微服务，然后我们将继续创建一个客户端来消费我们创建的服务。
- en: Creating the project
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'We will now go ahead and create our reactive microservice example. In order
    to do this, we need to create a project of the ASP.NET web application type. Just
    follow these steps and you should be able to see your first reactive microservice
    in action:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续创建我们的反应式微服务示例。为了做到这一点，我们需要创建一个ASP.NET Web应用程序类型的项目。只需按照以下步骤操作，你应该能够看到你的第一个反应式微服务在行动：
- en: Start Visual Studio.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio。
- en: Create a new project by navigating to File | New | Project.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到文件 | 新建 | 项目创建一个新的项目。
- en: From the installed templates, select .NET Core | ASP.NET Core Web Application.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从已安装的模板中，选择.NET Core | ASP.NET Core Web应用程序。
- en: 'Name it `FlixOne.BookStore.ProductService` and click on OK:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`FlixOne.BookStore.ProductService`并点击确定：
- en: '![](img/b057fc3c-85ba-40a0-b9f7-51641480ac89.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b057fc3c-85ba-40a0-b9f7-51641480ac89.png)'
- en: 'From the New ASP.NET Core Web Application screen, select .NET Core and ASP.NET
    Core 2.0 and then select Web Application (Model-View-Controller) and click on OK:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“新建ASP.NET Core Web应用程序”窗口中，选择.NET Core和ASP.NET Core 2.0，然后选择Web应用程序（模型-视图-控制器），然后单击确定：
- en: '![](img/8cf49cfa-2873-4e9f-b57f-01422029d466.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8cf49cfa-2873-4e9f-b57f-01422029d466.png)'
- en: You can enable Docker support for Windows if you enable the container.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启用了容器，你可以为Windows启用Docker支持。
- en: 'Make sure you have selected C#7.1; to do so, right-click on the project from
    the solution explorer and click on Properties. From the project properties screen,
    click on the Build tab and then scroll down to Advance. Click on Advance, and
    then select C# 7.1:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已选择C#7.1；为此，在解决方案资源管理器中右键单击项目，然后单击属性。在项目属性窗口中，单击生成选项卡，然后滚动到高级。单击高级，然后选择C#
    7.1：
- en: '![](img/fbc7aaf8-5dc7-4167-965c-ebf0b885a8b7.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fbc7aaf8-5dc7-4167-965c-ebf0b885a8b7.png)'
- en: 'Open NuGet Manager and add the System.Reactive.Core NuGet package to the project.
    Make sure you select Include prerelease on the screen:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开NuGet管理器，并将System.Reactive.Core NuGet包添加到项目中。确保在屏幕上选择包含预发布版本：
- en: '![](img/fad91898-4d26-4241-bd49-8e5f128706c0.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fad91898-4d26-4241-bd49-8e5f128706c0.png)'
- en: You are also required to add a package for EF core; to do so, refer to the *EF
    Core migrations* section in Chapter 2, *Implementing Microservices*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须添加一个EF core包；要这样做，请参阅第2章“实现微服务”中的*EF Core迁移*部分。
- en: 'Add the `Product.cs` model to the `Models` folder with the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Product.cs`模型代码添加到`Models`文件夹中，如下所示：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the `Category.cs` model to the `Models` folder with the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Category.cs`模型代码添加到`Models`文件夹中，如下所示：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Add `context` and `persistence` folders to the project. Add `ProductContext` to the `context` folder,
    and add the `IProductRepository` interface and the `ProductRepository` class to
    the `persistence` folder.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`context`和`persistence`文件夹添加到项目中。将`ProductContext`添加到`context`文件夹中，并将`IProductRepository`接口和`ProductRepository`类添加到`persistence`文件夹中。
- en: 'Consider the following code snippet, showing our context and persistence classes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，展示了我们的上下文和持久化类：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have created our models. Our next step is to add the code for interacting
    with the database. These models help us project data from a data source into our
    models.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了我们的模型。我们的下一步是添加与数据库交互的代码。这些模型帮助我们将数据源中的数据投影到我们的模型中。
- en: For database interaction, we have already created a context, namely `ProductContext`,
    deriving it from `DbContext`. In one of the preceding steps, we created a folder
    named `Context`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库交互，我们已创建了一个上下文，即`ProductContext`，它从`DbContext`派生而来。在之前的某个步骤中，我们创建了一个名为`Context`的文件夹。
- en: The Entity Framework Core context helps query the database. Also, it helps us
    collate all the changes that we perform on our data and execute them on the database
    in one go. We will not go into detail about Entity Framework Core or the contexts
    here, because they are not part of the scope of this chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core上下文有助于查询数据库。它还帮助我们汇总我们在数据上执行的所有更改，并一次性在数据库上执行它们。在这里，我们不会详细介绍Entity
    Framework Core或上下文，因为它们不属于本章的范围。
- en: The context picks the connection string from the `appsettings.json` file in
    the `connectionStrings` section—a key named `ProductConnectionString`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文从`appsettings.json`文件中的`connectionStrings`部分选择连接字符串——键名为`ProductConnectionString`。
- en: You are required to update the `startup.cs` file to make sure you're using a
    correct database. We have already discussed modifying the `appsettings.json` and
    `Statrup.cs` files in [Chapter 2](047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml),
    *Implement Microservices*. You need to add the `Swashbuckle.AspNetCore` NuGet
    package for Swagger support in the project while updating the `Startup.cs` class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要更新`startup.cs`文件以确保您使用的是正确的数据库。我们已经在[第2章](047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml)，*实现微服务*中讨论了修改`appsettings.json`和`Startup.cs`文件。在更新`Startup.cs`类时，您需要为项目添加`Swashbuckle.AspNetCore`
    NuGet包以支持Swagger。
- en: 'You could name it anything shown in the following code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其命名为以下代码片段中显示的任何名称：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Communication between the application and the database
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序与数据库之间的通信
- en: With our context in place, and taking care of the communication between our
    application and the database, let's go ahead and add a repository for facilitating
    interaction between our data models and our database. Please refer to the code
    for our repository, as discussed in step 10 of the *Creating the project* section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置好上下文，并处理应用程序与数据库之间的通信后，让我们继续添加一个仓库以促进我们的数据模型与数据库之间的交互。请参考我们在*创建项目*部分的第10步中讨论的仓库代码。
- en: Marking our result from `GetAll` as `IObservable` adds the reactive functionality
    we are looking for. Also, pay special attention to the return statement.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将`GetAll`的结果标记为`IObservable`添加了我们寻找的响应式功能。同时，请注意返回语句。
- en: 'With this observable model, it becomes possible for us to handle streams of
    asynchronous events with the same ease we are used to when handling other, simpler
    collections:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个可观察模型，我们可以像处理其他更简单的集合一样轻松地处理异步事件的流：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We are now ready to expose the functionality through our controllers. Right-click
    on the folder controller, click on Add New Item, and then select ASP.NET Core,
    Web API Controller class. Name it `ProductController`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好通过我们的控制器公开功能。在控制器文件夹上右键单击，点击添加新项，然后选择ASP.NET Core，Web API控制器类。将其命名为`ProductController`：
- en: '![](img/247eb9fe-30fa-454b-9f67-d32fb4b55410.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/247eb9fe-30fa-454b-9f67-d32fb4b55410.png)'
- en: 'Here is what our controller will look like:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制器将看起来如下：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The final structure looks similar to the following screenshot of the Solution
    explorer:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结构看起来与以下解决方案资源管理器截图相似：
- en: '![](img/96684d1a-efe5-41b0-96b2-e6c1984d3245.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96684d1a-efe5-41b0-96b2-e6c1984d3245.png)'
- en: To create the database, you can refer to the *EF Core migrations* section in Chapter
    2, *Implementing Microservices*, or simply call the Get API of our newly deployed
    service. When the service finds out that the database doesn't exist, the entity
    framework core code-first approach, in this case, will ensure that the database
    is created.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数据库，您可以参考[第2章](Implementing%20Microservices)，*实现微服务*中的*EF Core迁移*部分，或者简单地调用我们新部署的服务中的Get
    API。当服务发现数据库不存在时，在这种情况下，Entity Framework Core代码优先的方法将确保数据库被创建。
- en: We can now go ahead and deploy this service to our client. With our reactive
    microservice deployed, we now need a client to call it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续部署这项服务到我们的客户那里。随着我们的反应式微服务部署完成，我们现在需要一个客户来调用它。
- en: Client – coding it down
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端 – 编码实现
- en: 'We will create a web client for consuming our newly deployed reactive microservice
    with the help of AutoRest. Let''s create a console application for it and add
    these NuGet packages: `Reactive.Core`, `WebApi.Client`, `Microsoft.Rest.ClientRuntime`,
    and `Newtonsoft.Json`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用AutoRest的帮助创建一个用于消费我们新部署的反应式微服务的Web客户端。让我们为它创建一个控制台应用程序，并添加以下NuGet包：`Reactive.Core`、`WebApi.Client`、`Microsoft.Rest.ClientRuntime`和`Newtonsoft.Json`：
- en: AutoRest will add a folder named `Models` to the main project and create copies
    of the model's product and category, as in the service that we just created. It
    will have the necessary deserialization support built into it.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AutoRest将为主项目添加一个名为`Models`的文件夹，并创建模型的产品和类别的副本，就像我们刚刚创建的服务一样。它将内置必要的反序列化支持。
- en: '`ProductOperations.cs` and `ProductServiceClient.cs` contain the main plumbing
    required for all the calling.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductOperations.cs`和`ProductServiceClient.cs`包含了所有调用所需的主要管道。'
- en: 'In the `Main` function of the `Program.cs` file, change the `Main` function
    as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件的`Main`函数中，按照以下方式更改`Main`函数：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, if the database is not created, then it will be created as required
    by the Entity Framework.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果数据库尚未创建，那么它将根据Entity Framework的要求自动创建。
- en: We need to know how this list, which is returned from our microservice, differs
    from the regular list. The answer is that if this were a non-reactive scenario
    and you were to make any changes to the list, it would not be reflected in the
    server. In the case of reactive microservices, changes that are made to such a
    list would be persisted to the server without having to go through the process
    of tracking and updating the changes manually.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解从我们的微服务返回的这个列表与常规列表有何不同。答案是，如果这是一个非响应式场景，并且你对列表进行了任何更改，这些更改将不会反映在服务器上。在响应式微服务的情况下，对这样一个列表所做的更改将自动持久化到服务器，而无需手动跟踪和更新更改的过程。
- en: You can use any other client to make the Web API call (for example, RestSharp,
    or HttpClient).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何其他客户端来执行Web API调用（例如，RestSharp或HttpClient）。
- en: 'You may have noticed that we had to do very little or no work at all when it
    came to messy callbacks. This helps keep our code clean and easier to maintain.
    With an observable, it is the producer that pushes the values when they are available.
    Also, there is a difference here that the client is not aware of: whether your
    implementation is blocking or non-blocking. To the client, it all seems asynchronous.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在处理混乱的回调时，我们几乎不需要做任何工作，或者根本不需要做。这有助于保持我们的代码干净且易于维护。在使用可观察者时，当值可用时，是生产者推动这些值。此外，还有一个客户不意识到的区别：你的实现是阻塞的还是非阻塞的。对于客户来说，这一切似乎都是异步的。
- en: You can now focus on important tasks rather than figuring out what calls to
    make next or which ones you missed altogether.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以专注于重要任务，而不是试图弄清楚下一步要调用什么或者完全错过了哪些调用。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added the aspect of reactive programming to our microservice-based
    architecture. There are trade-offs with this message-driven approach of microservices
    communicating with each other. However, at the same time, this approach tends
    to solve some of the fundamental problems when we advance our microservice architecture
    further. The event sourcing pattern comes to our rescue and lets us get past the
    limitation of an ACID transaction or a two-phase commit option. This topic requires
    a separate book altogether, and restricting it to a single chapter does not do
    it justice. We used our sample application to understand how to restructure our
    initial microservice in a reactive way.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将响应式编程的方面添加到了我们的基于微服务的架构中。这种微服务之间通信的消息驱动方法有其权衡。然而，同时，这种方法在进一步推进我们的微服务架构时，往往能解决一些基本问题。事件溯源模式出现并帮助我们克服了ACID事务或两阶段提交选项的限制。这个主题需要一本书来专门讨论，将其限制在一个章节中是不公正的。我们使用我们的示例应用程序来了解如何以响应式的方式重构我们的初始微服务。
- en: In the next chapter, we will have the entire application ready for us to explore,
    and we will put together everything that we have discussed so far in this book.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将有一个完整的应用程序供我们探索，并将我们在本书中迄今为止讨论的所有内容整合在一起。
