- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices for SaaS Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are a powerful architectural pattern that is becoming increasingly
    popular in modern software development. Microservices are a way of organizing
    a large application into smaller, more manageable, and independent services that
    can communicate with each other using well-defined interfaces. This approach has
    gained popularity over the years as companies seek to build more scalable and
    robust software systems. With the increasing complexity of modern applications,
    it has become clear that the traditional monolithic approach to building software
    is no longer adequate. Microservices offer a way to break down complex applications
    into smaller, more manageable pieces that can be developed, deployed, and maintained
    independently.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing microservices requires a shift in the way that we think about building
    and deploying software. With microservices, we move away from the monolithic approach
    of building everything in a single application and instead build a series of smaller,
    independent services that can be deployed and scaled independently. This shift
    in approach allows us to build more flexible and resilient systems, as we can
    update, test, and deploy individual services independently. At the same time,
    we need to ensure that our microservices can communicate with each other efficiently
    and that we have mechanisms in place to handle errors and failures in our distributed
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore the important considerations when building microservices,
    and provide a guide to help you get started with implementing microservices in
    your software development projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following main topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices and their uses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for building performant and secure microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the skills we learned for RESTful APIs with microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common pitfalls when building microservices and how to avoid them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some practical advice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All code from this chapter can be found at [https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-6](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-6).
  prefs: []
  type: TYPE_NORMAL
- en: What are microservices and why use them?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are a software architecture style that structures an application
    as a collection of loosely coupled services. Unlike a traditional monolithic architecture,
    where all the functionality of the application is bundled into a single code base,
    microservices break down the functionality into smaller, independent services
    that can be developed, deployed, and scaled independently.
  prefs: []
  type: TYPE_NORMAL
- en: The microservices architecture was first introduced in the early 2000s and has
    gained popularity in recent years due to the increasing demand for faster development
    and deployment cycles, flexible scaling, and improved application resilience.
    Microservices are seen as a way to deliver value to customers more quickly and
    with greater agility, making them ideal for organizations that are looking to
    rapidly iterate and innovate.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices also have several benefits for organizations. By breaking down
    an application into smaller, focused services, organizations can increase the
    speed and efficiency of their development process. Teams can work on smaller,
    independent services in parallel, reducing the risk of delays and helping ensure
    that each service is delivered with high quality. Additionally, microservices
    can be deployed and scaled independently, allowing organizations to respond more
    quickly to changes in demand and optimize the performance of their applications.
  prefs: []
  type: TYPE_NORMAL
- en: When learning about microservices, it’s important to appreciate the underlying
    concepts of loose and tight coupling.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between loose and tight coupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a tightly coupled system, components are strongly dependent on one another
    and have a close relationship with each other. This means that changes in one
    component can have a significant and often breaking impact on other components
    in the system. Tightly coupled systems can quickly become very complex and difficult
    to maintain. Changes in one part of the system can cause unintended consequences
    elsewhere. If there is limited automated testing, this can be very difficult to
    detect and can result in bugs in production code.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, a loosely coupled system has components that are independent and
    have minimal dependencies on one another. This allows components to be developed,
    deployed, and maintained independently, with little or no impact on other components
    in the system. Loose coupling enables teams to work more efficiently and with
    greater agility, as changes to one component can be made with little or no impact
    on other parts of the system. It may sound like loose coupling is an obvious choice,
    but in practice, a lot of additional work is required to design a loosely coupled
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The microservices architecture is based on the principles of loose coupling,
    where an application is broken down into smaller, focused services that can be
    developed, deployed, and scaled independently. This allows organizations to respond
    more quickly to changes in demand, optimize the performance of their applications,
    and increase the speed and efficiency of their development process.
  prefs: []
  type: TYPE_NORMAL
- en: SaaS applications are typically quite complex. There will often be quite large
    teams working on the project, each of which will have areas of specialization.
    By breaking down an application into smaller, focused services, teams can work
    on them in parallel, reducing the risk of delays and increasing the speed of delivery.
    This helps organizations respond more quickly to changes in demand and deliver
    value to customers more rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of microservices is better scalability. Leaning on cloud-based
    infrastructure, each service can be deployed and scaled independently, allowing
    organizations to respond more quickly to changes in demand and optimize the performance
    of their applications. This is particularly important for SaaS applications, which
    often experience fluctuations in usage patterns. This can benefit the performance
    of the application, by provisioning more resources when the usage is high. When
    usage is low, some resources can be turned off, helping the organization manage
    its cloud compute costs and optimize the use of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices should also be designed to be highly resilient, meaning that even
    if one service fails, the impact on the overall system is minimal. This makes
    microservices ideal for SaaS applications, where downtime can have a significant
    impact on customer satisfaction and an according impact on the revenue of the
    company delivering the application. By breaking down an application into smaller,
    focused services, organizations can reduce the risk of unintended consequences
    when making changes to the system, making maintenance and modification easier
    and reducing the risk of downtime.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are a valuable tool for organizations looking to develop SaaS
    applications. They offer increased agility, better scalability, improved resilience,
    easier maintenance, and better cost management, making them an ideal choice for
    organizations looking to rapidly iterate and innovate.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `GoodHabits` service, we have been using Docker to run a `devcontainer`
    that encompasses the development environment, and the SQL server database. This
    is only one way that Docker can be used. At its core, Docker is a tool that can
    be used to run a process in a container. You can think of a container as a very
    lightweight virtual machine, typically running a Linux distro.
  prefs: []
  type: TYPE_NORMAL
- en: Docker often becomes a very important tool when building with microservices.
    A microservice app will typically have many different components that must be
    running for the overall system to run. This could involve running code in different
    programming languages, and running against multiple different database platforms.
    Attempting to get everything running reliably on a dev machine, and in several
    cloud environments, can quickly become a nightmare!
  prefs: []
  type: TYPE_NORMAL
- en: Docker provides an efficient and reliable way to run your microservices in a
    set of networked containers. By containerizing your microservices, you can isolate
    them from each other, making them easier to build and run.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Docker allows you to easily package your microservices and their
    dependencies, making it simpler to deploy your services in different environments,
    including running them in a development environment. This helps ensure that your
    microservices will work consistently across different systems, which is essential,
    and also challenging when building microservices.
  prefs: []
  type: TYPE_NORMAL
- en: While Docker is not strictly necessary for building microservices, it is highly
    recommended as a best practice to improve the efficiency and reliability of your
    microservices deployment. We’ll cover some more best practices in detail in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for building microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building microservices, it’s important to think about best practices to
    ensure that you get the benefits from the additional work required to build a
    microservice application. The system should be scalable, maintainable, and resilient
    – payback for the extra effort! Here are some of the most important best practices
    or “principles” to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Design for failure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices should be “designed for failure.” If they are going to fail (and
    all software will fail!), they should fail gracefully, with redundancy built in
    to ensure that the system continues to function even if one service fails.
  prefs: []
  type: TYPE_NORMAL
- en: One of the essential steps when designing for failure is *adding redundancy
    to your system*. This can be achieved by having multiple instances of each service
    running in parallel so that if one fails, others can continue to operate. Note
    that this will incur some additional costs, such as cloud hosting costs. Load
    balancing helps distribute the load evenly across multiple instances of a service,
    reducing the risk of a single instance becoming overwhelmed, and also helps redirect
    the load to another instance if one instance fails.
  prefs: []
  type: TYPE_NORMAL
- en: '*Circuit breakers* are another useful tool when designing for failure. These
    can be used to automatically detect and isolate failing services, preventing them
    from affecting the rest of the system. This makes it more likely that the overall
    system will continue to operate, even if one service fails.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Idempotence* is also crucial when embracing the “design for failure” principle.
    This involves ensuring that each service is idempotent, meaning that it can be
    executed multiple times with the same result. This allows you to retry requests
    if a service fails, reducing the risk of data loss or inconsistent results. You
    will remember that we encountered this topic in the previous chapter when learning
    about certain HTTP verbs. The principle is the same here.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Health checks* should be used to periodically test each service and determine
    whether it is operating correctly. This information can then be used to automatically
    redirect requests to other instances of the service if the original instance fails
    (leaning on the redundancy principle). These health checks should run automatically
    or on a defined schedule and can alert the team immediately if any issues arise.'
  prefs: []
  type: TYPE_NORMAL
- en: Focus on decoupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices should be (by definition) loosely coupled, with minimal dependencies
    between services. This allows services to be developed, deployed, and modified
    independently, reducing the risk of unintended consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling is a central tenet and is an important aspect of building a microservices-based
    system. Decoupling refers to separating the concerns between different services,
    allowing them to operate independently and reducing the risk of cascading failures.
  prefs: []
  type: TYPE_NORMAL
- en: There must be *clear service boundaries* – each service should have a specific
    responsibility and purpose, without overlapping with other services. Doing so
    will help ensure that each service can be developed and deployed independently,
    reducing the interdependencies between services.
  prefs: []
  type: TYPE_NORMAL
- en: '*Asynchronous communication* is an important aspect of decoupling services.
    Instead of direct communication, messages can be sent between services and processed
    at a later time. This allows each service to operate independently, reducing the
    risk of blocking and cascading failures.'
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to *implement some form of versioning* when decoupling
    services. Each service should have a version number, which can allow multiple
    versions of a service to coexist in the system. This allows for changes to be
    made to a service without them affecting other services, reducing the interdependencies
    between services. We looked at versioning in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '*Using an event-driven architecture* is another important part of decoupling
    services. Events can trigger actions in other services, reducing the need for
    direct communication. This allows each service to operate independently, reducing
    the interdependencies between services. This is often seen with event-based message
    queues facilitating communication between the various services in the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, *service discovery* is a useful tool for decoupling services. If you
    consider a system that has maybe 20 different loosely coupled services hosted
    in the cloud in a constellation of Docker containers, and perhaps multiple versions
    of some of them, keeping track of where they are all running can become very challenging.
    Using some form of service discovery allows the system to detect and connect to
    other services automatically, reducing the need for hardcoded connections.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing the “focus on decoupling” principle helps in building a robust microservices-based
    system. By defining clear service boundaries, using asynchronous communication,
    implementing versioning, using event-driven architecture, and considering service
    discovery, you can ensure that your system is scalable, flexible, and resilient.
  prefs: []
  type: TYPE_NORMAL
- en: Embrace automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automation is critical for the efficient operation of microservices as it helps
    ensure consistency and reliability across services. Automation should be used
    as much as possible to improve testing (with an automated test suite), deployment
    (CI/CD), and scaling (perhaps with Terraform).
  prefs: []
  type: TYPE_NORMAL
- en: Automation is a very important principle in all types of software development,
    but this is doubly true when building a SaaS application that makes use of a microservice
    architecture. Automating deployment and testing processes helps in reducing manual
    efforts and increases the speed of delivering new features to users. Automated
    deployment and testing processes ensure that services are deployed consistently,
    and any issues can be detected early in the development cycle. This helps in reducing
    downtime and increasing the overall efficiency of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '*Implementing CI/CD* helps ensure that code changes are automatically built,
    tested, and deployed. This helps in reducing the manual efforts involved in testing
    new features and gets them into the hands of the users as quickly as possible.
    CI/CD also helps in ensuring that code changes are deployed consistently and any
    issues are detected early in the development cycle. Using pipelines to automatically
    build, test, and deploy microservices will make managing the project as it starts
    to grow considerably easier!'
  prefs: []
  type: TYPE_NORMAL
- en: It is also useful to automate monitoring and logging. Automating monitoring
    and logging helps in detecting issues early and reduces downtime. Automated monitoring
    and logging processes ensure that the system is monitored consistently and that
    any issues are detected early, reducing manual efforts and increasing the overall
    efficiency of the system.
  prefs: []
  type: TYPE_NORMAL
- en: When in production, a SaaS application can experience rapid fluctuations in
    the demands being placed on various parts of the system. Automation can facilitate
    automatic scaling to ensure that the system can handle increased traffic without
    manual intervention. Automated scaling processes ensure that the system can scale
    up or down based on the traffic, reducing manual efforts and increasing the overall
    efficiency of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing the “embrace automation” principle helps in building a robust and
    efficient microservices-based system. Automating deployment and testing processes,
    implementing CI/CD, automating monitoring and logging, and automating scaling
    processes help in streamlining the processes, reducing manual efforts, and increasing
    the efficiency of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Use contract-driven development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices should have well-defined contracts that define the interface between
    services. This allows services to evolve independently, while still ensuring compatibility.
    In this context, a “contract” means an agreement that specifies the interactions
    between services, including details about the inputs and outputs of each service,
    communication protocols, and data formats. This contract can be represented in
    various forms, such as API specifications, message formats, or documentation,
    and should be agreed upon by all the teams involved in building and maintaining
    the services.
  prefs: []
  type: TYPE_NORMAL
- en: Contract-driven development requires that clear contracts between services are
    defined. These contracts should define the inputs and outputs for each service
    and ensure that the services operate as expected. This helps in reducing the risk
    of breaking changes and increases the overall stability of the system.
  prefs: []
  type: TYPE_NORMAL
- en: As with many parts of the application, testing is very important. *Contract
    testing* ensures that the contracts between services are tested and adhered to,
    reducing the risk of breaking changes and increasing the overall stability of
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: The “use contract-driven development” principle helps in building a robust and
    stable microservices-based system. Defining clear contracts between services,
    testing contracts, implementing contract testing, and automating contract testing
    help in ensuring that the services are operating as expected and adhering to the
    defined interface, reducing the risk of breaking changes and increasing the overall
    stability of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Monitor and log aggressively
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices systems generate a large amount of data, and it’s important to
    have a robust monitoring and logging strategy in place. This will help you detect
    and diagnose issues – hopefully, before they have an impact on your user!
  prefs: []
  type: TYPE_NORMAL
- en: The system should be continuously and automatically monitored, with the monitoring
    covering the overall health of the service, the response times of the whole system
    and each microservice, and resource utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Alongside the monitoring solution, there should also be a logging mechanism.
    Logging helps in tracking the activities of the system, detecting issues, and
    troubleshooting any problems. This logging should include logging requests, response
    times, and any error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Using centralized logging and monitoring helps in reducing manual efforts and
    increases the efficiency of the system. Centralized logging and monitoring ensure
    that the logs and the monitoring data are stored in a single place, making it
    easier to detect issues and troubleshoot problems.
  prefs: []
  type: TYPE_NORMAL
- en: There is no point in doing this monitoring and logging if the system never reports
    any issues! Automated alerting processes ensure that any issues are detected early
    and the appropriate team is notified, reducing manual efforts and increasing the
    overall efficiency of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring, logging, and alerting help ensure the system is robust and efficient.
    While they do add a little bit of additional work to the development process,
    which is not seen when the system is running smoothly, they are very much worth
    the time invested when things inevitably go wrong!
  prefs: []
  type: TYPE_NORMAL
- en: Implement security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It does somewhat go without saying, but microservices should be secure, with
    appropriate authentication, authorization, and encryption protocols in place.
    It’s also important to have a security strategy that covers the entire system,
    including the network, the infrastructure, and the services themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The nature of microservices is such that security can be challenging. There
    will often be multiple containers running all sorts of different software, each
    with its own set of attack vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing the “implement security” principle is an essential aspect of building
    a microservices-based system. Security helps in protecting sensitive information,
    reducing the risk of security breaches, and ensuring the confidentiality and integrity
    of data. We must follow some steps to embrace this principle.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing authentication and authorization is the first step toward embracing
    the “implement security” principle. Authentication and authorization help in ensuring
    that only authorized users can access sensitive information, reducing the risk
    of security breaches. The authentication and authorization process should be robust
    and secure to ensure the confidentiality and integrity of data and must encompass
    every part of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '*Encrypting sensitive data* is a crucial aspect of embracing the “implement
    security” principle. Encryption helps in protecting sensitive information, reducing
    the risk of security breaches, and ensuring the confidentiality and integrity
    of data. The encryption should be applied to all sensitive data, including data
    at rest and data in transit.'
  prefs: []
  type: TYPE_NORMAL
- en: Because there are so many moving parts in a SaaS/microservice-based system,
    security should be implemented at a network level to encompass every part of the
    system. The security measures at the network level should include firewalls, intrusion
    detection and prevention systems, and network segmentation.
  prefs: []
  type: TYPE_NORMAL
- en: Security is extremely important in any application. SaaS applications typically
    have complex security requirements. Embracing the “implement security” principle
    from the very start of the project helps in building a secure and reliable microservices-based
    SaaS application. Implementing authentication and authorization, encrypting sensitive
    data, and implementing security at the network level help in reducing the risk
    of security breaches and ensuring the confidentiality and integrity of data.
  prefs: []
  type: TYPE_NORMAL
- en: Focus on scalability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices should be designed to be scalable, both horizontally (by adding
    more instances) and vertically (by adding more resources to existing instances).
    This will allow you to respond quickly to changes in demand and ensure that the
    system continues to perform well under heavy load.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing the “focus on scalability” principle is another important aspect of
    building a microservices-based SaaS application. Scalability helps in ensuring
    that the system can handle increased traffic, reduce downtime, and improve the
    overall performance of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for scalability is the first step toward embracing the “focus on scalability”
    principle. Scalable design helps in ensuring that the system can handle increased
    traffic, reduce downtime, and improve the overall performance of the system. The
    design should take into account the expected traffic and resource utilization
    and should include provisions for increasing the resources as needed.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, containerization helps in improving the scalability
    of the system by packaging the services and their dependencies, making it easier
    to deploy and scale the services as needed.
  prefs: []
  type: TYPE_NORMAL
- en: To get the most benefit from a containerized application, you should include
    a load balancer. Load balancing helps in distributing the traffic evenly across
    the available resources, reducing downtime and improving the overall performance
    of the system.
  prefs: []
  type: TYPE_NORMAL
- en: With containers and a load balancer, it is possible to automate scaling in the
    application. Implementing auto-scaling helps in ensuring that the system can handle
    increased traffic, reduce downtime, and improve the overall performance of the
    system. Auto-scaling automatically increases or decreases the resources as needed,
    based on the traffic and resource utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for scalability, embracing containerization, implementing load balancing,
    and implementing auto-scaling help in ensuring that the system can handle increased
    traffic, reduce downtime, and improve the overall performance of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Separate data stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most applications have a single database that stores all of the information
    associated with the application. While this approach can be taken in a microservices
    application, you can also implement a database on a per-service basis. There are
    pros and cons to this approach, and you don’t necessarily need to use a separate
    data store per service. The choice of using a separate data store per service
    or a shared data store depends on the requirements and constraints of your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having separate data stores for each service can provide benefits such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved scalability**: Each service can scale its data store independently,
    allowing for better resource utilization and reducing the likelihood of resource
    contention'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved resilience**: Each service can continue to function, even if one
    of the data stores experiences an issue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved data isolation**: Each service has complete control over its data,
    making it easier to maintain data consistency and integrity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, separate data stores can also introduce challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased operational complexity**: Managing multiple data stores can be
    more complex than managing a single data store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased latency**: Communication between services to access data in different
    data stores can introduce latency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased data duplication**: The same data may need to be stored in multiple
    data stores, increasing storage costs and the risk of data inconsistency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shared data store, on the other hand, can simplify the architecture and reduce
    operational complexity, but it can also introduce constraints on scalability,
    resilience, and data isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the choice between separate data stores and a shared data store
    depends on the specific requirements and constraints of your system and should
    be made based on a careful evaluation of the trade-offs involved.
  prefs: []
  type: TYPE_NORMAL
- en: Designing microservice applications is hard. There is a lot to think about to
    make sure that you can realize the benefits of this approach! These best practices
    will help you build microservices that are scalable, maintainable, and resilient.
    By following them, you can ensure that your microservices-based system is optimized
    for performance, efficiency, and reliability!
  prefs: []
  type: TYPE_NORMAL
- en: Mixing microservices and RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a microservices-based architecture, REST is often used as the
    communication protocol between the different services. **REST**, or **Representational
    State Transfer**, is a commonly used and widely adopted web service architecture
    that provides a standardized way for clients and servers to communicate with each
    other. Microservices and REST are a natural fit, as REST provides the necessary
    communication infrastructure for microservices to communicate and exchange data
    with each other. We discussed contract-based development previously; the surface
    of the REST API can be seen as the contract for communication between services.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key advantages of using REST in a microservices-based system is that
    it provides a clear and standard way for services to communicate with each other.
    REST defines a set of rules for how services should exchange data, including the
    use of HTTP methods such as GET, POST, and DELETE, and the use of HTTP status
    codes to indicate success or failure. This makes it easy for developers to build
    and maintain microservices, as they know exactly what to expect when communicating
    with other services.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of using REST in a microservices-based system is that it provides
    a scalable and flexible way for services to communicate with each other. REST
    is platform-agnostic, typically communicating over HTTP, which means that it can
    be used with a variety of programming languages and technologies, making it an
    ideal choice for building microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using REST in a microservices-based system provides a secure way for
    services to communicate with each other. REST uses standard web security measures
    such as SSL/TLS encryption, which helps protect data in transit, and HTTP authentication,
    which helps ensure that only authorized clients can access the data.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices and REST are a natural fit, and using REST as the communication
    protocol between microservices provides a clear, scalable, and secure way for
    services to communicate and exchange data with each other. By using REST, developers
    can build and maintain microservices-based systems with confidence, knowing that
    they have a reliable and widely adopted communication infrastructure in place.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting up a single REST API into microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you think of a “typical” RESTful API, you will probably be thinking of
    a system with several controllers, each grouping several related methods or endpoints.
    It is not uncommon for an enterprise system with a single **monolithic** API to
    have dozens of controllers and hundreds of endpoints. Splitting this up into a
    contract-driven microservice-based system is not easy. There is no one correct
    way to approach this, and it can be more art than science.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few approaches that can be taken for splitting up a monolithic REST
    API into microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functionality-based**: This approach involves breaking down the monolithic
    API into smaller services based on the functionality they provide. For example,
    a service could be created to handle user authentication, while another could
    handle product management. This approach makes it easier to manage and maintain
    the services, as each one is focused on a specific task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data-driven**: In this approach, the monolithic API is broken down into services
    based on the data they manage. For example, a service could be created to manage
    customer information, while another could manage order information. This approach
    is useful when there are different data access patterns, security requirements,
    or performance requirements for different datasets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain-driven**: This approach involves breaking down the monolithic API
    into services based on the domain it represents. For example, a service could
    be created to manage information about customers, while another could manage information
    about products. This approach is useful when there are complex business domains
    that can be broken down into smaller, manageable pieces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Micro frontends**: This approach involves breaking down the monolithic API
    into microservices and using a micro frontend architecture to combine the services
    into a single user interface. This approach provides a way to scale the frontend
    and the backend independently, while still providing a seamless user experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of the approach used, it is important to consider the complexity
    of the API, the dependencies between the different parts of the API, and the skills
    and resources of the development team when determining the best way to split up
    a monolithic API into microservices. Additionally, it is important to continuously
    evaluate and refactor the microservices as needed to ensure that they continue
    to meet the needs of the application and the business.
  prefs: []
  type: TYPE_NORMAL
- en: An often-asked question when discussing REST and microservices is, “*Should
    each controller in an API be its* *own microservice?*”
  prefs: []
  type: TYPE_NORMAL
- en: The answer is not straightforward and depends on the specific requirements of
    your system and the size and complexity of each controller. In general, each microservice
    should represent a single, self-contained business capability, and multiple controllers
    can be part of a single microservice if they work together to provide a single
    business function.
  prefs: []
  type: TYPE_NORMAL
- en: If the controllers are tightly coupled and cannot be separated, it might make
    sense to have them in a single microservice. On the other hand, if each controller
    has separate business logic and data storage, and can be deployed and scaled independently,
    it might be a better fit to have each controller in its own microservice.
  prefs: []
  type: TYPE_NORMAL
- en: The key is to determine the business functions that need to be performed and
    to decompose the system into a set of self-contained microservices that can be
    developed, deployed, and scaled independently. When in doubt, it is better to
    start with smaller microservices and consolidate them later if needed. This allows
    for easier testing and debugging, as well as more rapid development and deployment
    cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Each controller in an API doesn’t necessarily have to be its own microservice,
    but the decision should be based on the specific requirements of your system and
    the size and complexity of each controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'When combining microservices and REST, there are several important topics to
    cover to build a robust and scalable system, which play a crucial role in building
    a microservices-based system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Designing RESTful APIs**: RESTful APIs should be designed to be scalable,
    flexible, and easy to consume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API documentation**: API documentation should be clear, concise, and easy
    to understand, and should provide clear instructions on how to consume the APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API versioning**: API versioning helps in ensuring that the system can evolve,
    without breaking existing integrations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API security**: API security should be implemented to protect against unauthorized
    access, data theft, and other security risks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling**: Error handling should be implemented to ensure that the
    system can handle and respond to errors consistently and predictably.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data consistency**: Data consistency is a crucial aspect of building a microservices-based
    system. Data consistency should be maintained across the microservices, to ensure
    that the system behaves as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When combining microservices and REST, it is important to focus on designing
    RESTful APIs, providing clear API documentation, implementing API versioning,
    securing the APIs, handling errors, and maintaining data consistency. These topics
    help in building a robust and scalable system that can handle increased traffic
    and provide a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Common pitfalls and how to avoid them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building SaaS apps is hard. Building a microservice application is hard. Combining
    the two is really hard, and there are several common pitfalls that you should
    avoid!
  prefs: []
  type: TYPE_NORMAL
- en: The first, most common, and most important one to avoid is building the microservices
    too early. It is often easier to start with a monolith and slowly break off small
    sections of the app into small, self-contained services when the need arises and
    not before.
  prefs: []
  type: TYPE_NORMAL
- en: So, perhaps the best advice I can give about microservices is to not use them...
    until you have to! But, given that this is a chapter about microservices, here
    are some common traps that should be avoided if you have decided to go down this
    route!
  prefs: []
  type: TYPE_NORMAL
- en: '**Over-complication**: One of the most common pitfalls when building microservices
    is over-complicating the architecture. This can result in additional bugs, increased
    maintenance costs, and longer development times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of communication and coordination**: When building microservices, it
    is important to ensure that there is effective communication and coordination
    between teams. Without this, there can be delays and misunderstandings, which
    can result in problems with the overall architecture, which will inevitably manifest
    as a degraded experience for the users of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inconsistent data**: When using microservices, it is important to ensure
    that data is consistent across all services. Otherwise, it can lead to problems
    with data integrity and accuracy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased deployment complexity**: Microservices can increase deployment
    complexity as each service must be deployed and managed individually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging complexity**: Debugging complex microservice architectures can
    be more difficult than debugging a monolithic architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s how to avoid the common pitfalls when building microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Over-complicated microservice architecture**: This can be avoided by keeping
    the architecture simple, focusing on the single responsibility principle, and
    defining clear boundaries for each microservice. It is also important to prioritize
    the microservices that need to be built and make sure they align with business
    goals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of communication and collaboration between teams**: This can be mitigated
    by creating a culture of collaboration and having clear communication channels
    between teams. It’s also important to have regular meetings between teams to ensure
    that everyone is on the same page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Underestimating the complexity of data management**: To avoid this, it’s
    important to properly plan out the data management strategy for each microservice.
    This includes defining the data sources, data ownership, and data consistency.
    Using a data management solution, such as a data management platform or event
    sourcing, can also help.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Not adequately monitoring microservices**: To avoid this pitfall, it’s important
    to have a solid monitoring strategy in place. This includes setting up logging
    and monitoring for each microservice and having alerting mechanisms in place for
    when things go wrong.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of security considerations**: To avoid this, it’s important to have
    a solid security strategy in place. This includes considering security at every
    stage of the microservice development process, including architecture, design,
    development, and deployment. It’s also important to regularly review the security
    strategy and make changes as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some practical advice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are a huge and complex topic – rather than trying to give a demonstration
    of a full microservice application here, I will instead offer some practical advice
    using the demo app we have been building as the basis for this advice. The implementation
    is left up to you!
  prefs: []
  type: TYPE_NORMAL
- en: A microservice architecture example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is worth reiterating that in many cases, the best approach when planning
    a new application is to start with a single monolith app and carve off sections
    of the app into microservices when the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, I will assume that the Good Habits app has grown to the point
    where it is necessary to start thinking about separating it into microservices.
    I think that a useful way to split this up might be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Suggested microservice architecture](img/B19343_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Suggested microservice architecture
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss the components in this diagram a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: User interfaces and clients
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very common these days for an application to have both a web client app
    and a mobile app – and sometimes, a desktop application as well. All of these
    clients will be communicating with the same backend and the same microservices.
    It is common to build a single **gateway** API that manages all external communication
    between the various microservices.
  prefs: []
  type: TYPE_NORMAL
- en: API gateway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it’s possible to enable user interface applications to directly communicate
    with microservices, managing this can become incredibly complex. The diagram only
    displays three microservices, but there could easily be 20 or more. Consider the
    added complexity of orchestrating communication between more than 20 microservices
    and three or more types of client UI – the situation becomes even more difficult
    to visualize and much harder to manage in practice!
  prefs: []
  type: TYPE_NORMAL
- en: Using an API gateway in a microservice architecture provides several benefits.
    Firstly, an API gateway acts as a single entry point for clients, allowing for
    easier management of requests, authentication, and authorization. It also enables
    the composition of different microservices into a unified API, which can simplify
    the client’s interaction with the system. The API gateway can also provide load
    balancing and failover capabilities, which are important for high-availability
    systems. Another important benefit is the ability to enforce security and traffic
    policies, as well as to monitor and log requests. By using an API gateway, developers
    can more easily manage and evolve a microservice architecture, while maintaining
    a high level of security and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Message broker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A message broker is used to facilitate communication between the various backend
    microservices. This performs much the same function on the backend as the API
    gateway does for the frontend. It detangles all of the communication between the
    services. Again, while we only have three services in the diagram, we should keep
    in mind that a real-world system may have many more, and inter-service communication
    can quickly become extremely complex and inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: Using a message broker in a microservice architecture provides many benefits.
    One of the main advantages is that it allows services to communicate with each
    other asynchronously, decoupling the sender from the receiver. This can improve
    reliability and scalability as services can process messages at their own pace
    and are not blocked by the performance of other services. A message broker can
    also act as a buffer between services, which can be particularly useful if one
    service is temporarily unavailable. It can help avoid message loss by persisting
    messages until they can be delivered to the appropriate service. A message broker
    can also provide a centralized way to monitor and manage the flow of messages
    between services, making it easier to track and debug issues. Finally, by separating
    the communication concerns from the business logic, services can be more easily
    tested and deployed independently.
  prefs: []
  type: TYPE_NORMAL
- en: Using a message broker (and an API gateway) leans into a number of the microservice
    good design principles that we discussed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several message brokers are commonly used in .NET microservice applications,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RabbitMQ**: An open source message broker that supports multiple messaging
    protocols, including AMQP, MQTT, and STOMP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache Kafka**: A distributed streaming platform that is optimized for handling
    high-volume and high-velocity data streams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Service Bus**: A fully-managed messaging service provided by Microsoft
    Azure that supports both traditional messaging patterns and pub/sub scenarios'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Simple Queue Service (SQS)**: A fully-managed message queue service provided
    by Amazon Web Services that decouples and scales microservices, distributed systems,
    and serverless applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NServiceBus**: A messaging framework for .NET that provides a unified programming
    model for building distributed systems using a variety of messaging patterns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these tools provide reliable message delivery, scalability, and fault
    tolerance, and they can help simplify the communication between microservices
    in a distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: The services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To give an example, I have laid out three services:'
  prefs: []
  type: TYPE_NORMAL
- en: A user service, which will handle everything related to the users. This includes
    authentication, password management, and keeping personal information up to date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A habit service, which deals with everything related to the habits that the
    users are trying to track.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A feed service. In this more advanced version of the Good Habits app, I have
    assumed that there will be the ability to see your friends’ progress in a social
    media-style feed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that I have chosen to also separate the data stores into individual
    databases. This allows us to treat each data store slightly differently. I have
    also decided to use a relational database for the User and the Habit service,
    but a document (NoSQL) database for the Feed service. This is a superpower of
    microservices – you can use different types of data storage based on the use case
    for individual microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The User service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have specifically broken this out because storing users’ private data should
    be taken very seriously. This data may include banking information (if the service
    has a paid tier) and may include personal information. It is easy to understand
    that the data that is stored in the User service may have to be treated more securely
    than the data in the Habit service.
  prefs: []
  type: TYPE_NORMAL
- en: We should also consider that users in many jurisdictions have the right to be
    forgotten. By grouping all of the personal data in one place, we make this easier
    to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: The User service would probably not be subject to particularly high demand.
    Users would be expected to update their details infrequently, so this service
    could have fewer resources allocated to it.
  prefs: []
  type: TYPE_NORMAL
- en: The Habit service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Good Habits application, it would be expected that the Habit service
    would do most of the heavy lifting in the application, and so would have additional
    resources allocated to it. This service should also be designed to scale easily
    so that more development time can be put into the performance, and perhaps less
    attention is paid to security than for the User service. (Of course, security
    is still important!!)
  prefs: []
  type: TYPE_NORMAL
- en: The type of data in this service would be highly relational, so a relational
    store is the most appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The Feed service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we envisage a much more advanced version of the Good Habits app, we may have
    expanded to the point where we have a social network-type sets of features, which
    allows users to see their friends' progress and celebrate their success with them.
  prefs: []
  type: TYPE_NORMAL
- en: This type of service is usually modeled using a document store, or something
    like GraphQL. A relational store is not appropriate. Using a microservice architecture
    allows us to choose the most appropriate type of data store!
  prefs: []
  type: TYPE_NORMAL
- en: All of the information in the feed will have been selected by the users to make
    publicly available, so data security is less important in this service. We can
    be sure that there is no private data in this service, as the user data stores
    are not accessible from this service.
  prefs: []
  type: TYPE_NORMAL
- en: Overall architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The architecture in *Figure 6**.1* shows one way that we could use microservices
    to break up the application. But there are many possible ways to do this, and
    it is more art than science.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing is to be guided by your users, and mindful of how the
    choices you make in splitting up the monolith will impact the users.
  prefs: []
  type: TYPE_NORMAL
- en: A practical example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it is outside the scope of this chapter to provide a complete example
    of a microservices project, we can build out some of the principles in the `GoodHabits`
    project to cement our understanding of the preceding advice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a very basic `UserService`, to show how we can interact with multiple microservices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an API gateway that serves as a single point of entry to all of the microservices
    from any clients interacting with the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UserService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the following script to add the project and files for the User service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will configure how to start the Users microservices. Set up the `launchSettings.json`
    file so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the following code to the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That is all that is required to set up a very simple User service. You can start
    this up independently and see how it works with Swagger. The provided functionality
    is very basic, and it would be a fantastic exercise to try to build this service
    out a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: API gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As described previously, an API gateway gives a client using the application
    a single point of entry into the application. All they need to do is talk to the
    gateway, and the complexity of the microservice implementation is kept hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a package called Ocelot, which provides most of the functionality
    that we will need out of the box. To get started, execute the following script
    to set up the `ApiGateway` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did with `UserService`, we will need to modify the `launchsettings.json`
    file to configure how the API gateway starts. Set up the file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make the `Program.cs` file look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see the key lines for the `Ocelot` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, configure `Ocelot` by adding the following config to `Ocelot.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you look through the config file, you will see that we are simply mapping
    from one URL in the gateway to another URL in the two microservices that we have
    created, `HabitService` and `UserService`. This may seem like a needless complication,
    but if you consider that many more microservices might be added to the overall
    application, it makes sense to give a single point of entry.
  prefs: []
  type: TYPE_NORMAL
- en: Running the combined application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run the complete application, we need to start all four projects (`HabitService`,
    `UserService`, `APIGateway`, and `Client`) individually. This can become challenging,
    so we will set up tasks and launch configurations to manage this for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `.vscode` folder, add the following code to `tasks.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same folder, add the following code to `launch.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also in `launch.json`, add the following compound tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration will allow VSCode to start all four projects by
    hitting the *F5* key, or by using the build and run menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is much more that we could do at this point with the demo application.
    Some suggestions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Build out the User service so that it includes a lot more functionality that
    would be required for a real app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add additional routes to the `Ocelot` config
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a message queue (hint – try RabbitMQ)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope that we have managed to illustrate most of the key learnings from this
    chapter and provided a foundation for you to build upon.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are a huge and complex topic, much too large to tackle in one
    chapter of a SaaS book! In this chapter, we provided a brief introduction to microservices,
    covering what they are and why they are important. We discussed the benefits of
    using microservices, including improved scalability, fault tolerance, and flexibility.
    We also talked about the challenges and pitfalls of implementing a microservices
    architecture, such as increased complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explored the common patterns for designing microservices, including
    service discovery, API gateways, and message brokers. We also looked at the role
    of containers and container orchestration systems, such as Docker, in deploying
    and managing microservices. Finally, we provided a set of pointers on how to implement
    a microservices architecture using C#, .NET, and various supporting tools. While
    this is only a small glimpse into the world of microservices, we hope that it
    has helped provide a foundation for your further exploration of this important
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to build a user interface with Blazor.
    We’ll interface this UI with the Good Habits backend that we have been building
    in previous chapters!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How to build .NET Core microservices: [https://www.altkomsoftware.com/blog/microservices-service-discovery-eureka/](https://www.altkomsoftware.com/blog/microservices-service-discovery-eureka/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating a simple data-driven CRUD microservice: [https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/data-driven-crud-microservice](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/data-driven-crud-microservice)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '8 Ways to Secure Your Microservices Architecture: [https://www.okta.com/resources/whitepaper/8-ways-to-secure-your-microservices-architecture/](https://www.okta.com/resources/whitepaper/8-ways-to-secure-your-microservices-architecture/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow 6 key steps to deploy microservices in production: [https://www.techtarget.com/searchitoperations/tip/Follow-these-6-steps-to-deploy-microservices-in-production](https://www.techtarget.com/searchitoperations/tip/Follow-these-6-steps-to-deploy-microservices-in-production)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microservices with .NET: [https://dotnet.microsoft.com/en-us/apps/aspnet/microservices](https://dotnet.microsoft.com/en-us/apps/aspnet/microservices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between a monolithic and microservices architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of an API gateway in microservices architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a message broker facilitate communication between microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does using a microservices architecture impact database design and management?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some common challenges or pitfalls to consider when implementing microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 3: Building the Frontend'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After learning about the backend in the previous section, we will move on to
    the frontend. In this section, we will build a simple **user interface** (**UI**)
    using Blazor and connect this to the backend from the previous section. As well
    as the practical skills, this section will also introduce a lot of the theory
    around frontend development and building excellent UIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19343_07.xhtml#_idTextAnchor169), *Building a User Interface*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19343_08.xhtml#_idTextAnchor200), *Authentication and Authorization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
