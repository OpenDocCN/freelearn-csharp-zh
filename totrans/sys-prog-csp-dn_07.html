<html><head></head><body>
		<div id="_idContainer031">
			<h1 class="chapter-number" id="_idParaDest-158"><a id="_idTextAnchor159"/>7</h1>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor160"/>The One with the Operating System Tango</h1>
			<p><em class="italic">Working with Operating </em><span class="No-Break"><em class="italic">System Services</em></span></p>
			<p>Computers are complex machines. They can have many different forms, different peripherals, and different functions. Yet, a lot of different machines can run the same software. As long as the hardware fits in a pretty broad set of boundaries (for instance, running a specific CPU architecture), your software does not care what the underlying machine <span class="No-Break">looks like.</span></p>
			<p>The reason this all works is that we have abstraction. You hardly ever deal with the actual hardware. There are always layers of software to go through, each layer adding a level of abstraction. That sounds complicated, but it is a good thing. Without this, we would have to rewrite our software for all possible combinations of hardware. Imagine a user swapping out an old-style hard drive with spinning discs for a more modern, faster SSD. Then, they have to come to you so you can recompile your system to accommodate that. I am sure you do not want to spend your time on that <span class="No-Break">if possible.</span></p>
			<p>The lowest level of software, the one running closest to the hardware, is the <strong class="bold">Basic Input/Output System</strong> (<strong class="bold">BIOS</strong>). This <a id="_idIndexMarker523"/>system interfaces between the actual hardware and the levels above. The BIOS knows how to access a particular area on a storage medium. It knows how to reach a network card and get the bits and bytes to the levels on top of it. It is the gatekeeper to the <span class="No-Break">actual hardware.</span></p>
			<p>In short, the next level of abstraction is the <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>). These days, the difference between the OS and user programs is not very well defined anymore. Windows, for instance, is an OS. however, it also comes with many user programs, such as a photo viewer and a calculator. However, the OS does come with many utilities we, as systems programmers, can use. These utilities or systems in the OS help us do tasks without worrying about the little details while still being able to run on many different machines. This chapter explains some of the more handy utilities Windows <span class="No-Break">offers us.</span></p>
			<p>This chapter looks at some of the services Windows makes available to us. These are the items we will learn about in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>The <span class="No-Break">Windows Registry</span></li>
				<li><span class="No-Break">Worker Services</span></li>
				<li>Windows Management <span class="No-Break">Instrumentation (WMI)</span></li>
				<li>Registry and WMI – risks and how to <span class="No-Break">avoid them</span></li>
			</ul>
			<p>We also will look at the risks involved and how to minimize them. After all, we are probing deep into Windows, and when things go wrong, they usually go wrong <span class="No-Break">very badly.</span></p>
			<p>Let’s begin with the <span class="No-Break">Registry first!</span></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor161"/>Technical requirement</h1>
			<p>You can find all the sources and complete samples for all the things we discuss here in the GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter07"><span class="No-Break">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter07</span></a><span class="No-Break">.</span></p>
			<p>If you, however, want to build the samples from scratch, you need to install some <span class="No-Break">NuGet packages.</span></p>
			<p>For the WMI samples, you need to install the <span class="No-Break"><strong class="source-inline">System.Management</strong></span><span class="No-Break"> package.</span></p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor162"/>The Windows Registry</h1>
			<p>Almost all <a id="_idIndexMarker524"/>systems have settings. These settings persist; they are still there after a system shutdown, reboot, or whatever reason. The contents of these settings vary; they could be anything your system needs. It could be a connection string to a database, a location where you can store files, the font used to generate reports, and so on. Anything you cannot know in advance while writing the software or that a user or system administrator might want to change should be in a separate location from <span class="No-Break">your system.</span></p>
			<p>In the past, Windows applications and<a id="_idIndexMarker525"/> systems used <strong class="bold">INI files</strong>. An INI file is an elementary file structure. They consist of sections, each with a key/value pair of data. A section is part of the file that is surrounded by the <strong class="source-inline">[</strong> and <strong class="source-inline">]</strong> characters. The key/value data is a line such as <strong class="source-inline">mykey=myvalue</strong>. Each section or data line is on a separate line, and that <span class="No-Break">is it.</span></p>
			<p>We placed the INI file <a id="_idIndexMarker526"/>in a known location, usually in the same directory as the main <span class="No-Break">application files.</span></p>
			<p>These days, we do not use INI files that much anymore. The .NET BCL does not have classes for them, although third-party NuGet packages can help you if you decide to go with <span class="No-Break">INI files.</span></p>
			<p>The most obvious alternative for the INI file is the settings file. The settings file is usually in a JSON format, making it easy to work with. You can find them in the same place we used to put INI files: we usually place them alongside the <span class="No-Break">main application.</span></p>
			<p>JSON allows for a much more complex structure with a hierarchy in your settings. JSON is still much readable for humans, just as the INI files were. That might be useful if a system administrator needs to change <span class="No-Break">the settings.</span></p>
			<p>However, a JSON file is not always the best way to store settings. There are downsides to this approach. One of the alternatives to the file-based settings is using the Windows Registry. Allow me to explain what that is and how to use that first, and then I will outline both options’ pros <span class="No-Break">and cons.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor163"/>What is the Windows Registry?</h2>
			<p>The Registry is a<a id="_idIndexMarker527"/> hierarchical database in Windows where systems can read and write all sorts of data. The data itself is a collection of key/value pairs. The keys are strings; the values can be strings, numeric, <span class="No-Break">or binary.</span></p>
			<p class="callout-heading">Binary data in the Windows Registry</p>
			<p class="callout">Yes, you <a id="_idIndexMarker528"/>can store binary data in the Registry. However, that doesn’t mean it is a good idea. The theoretical limit is 1 MB per value, but I vigorously recommend not doing that. If you only have a couple of bytes, then storing and reading binary data is a great idea, but if you want to store larger amounts of data, you are better off using a different mechanism. Having large amounts of binary data in your Registry might slow down the complete machine, not just your application. Microsoft recommends using a maximum of 1 or 2 KB per entry for your binary data. Above that, you should move your data away to <span class="No-Break">another location.</span></p>
			<p>The Registry is organized in a tree-like structure. Each entry can be a key, a subkey, or an entry. The entry is the lowest level in the Registry: an entry cannot have <span class="No-Break">a sub-entry.</span></p>
			<p>Maybe I can clarify this by showing you a bit of the Registry on <span class="No-Break">my machine.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer025">
					<img alt="" role="presentation" src="image/B20924_08_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: The Windows Registry</p>
			<p><span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.1</em> shows a<a id="_idIndexMarker529"/> small part of the Windows Registry on my machine. On the left-hand side, you see the tree structure with all the keys; on the right-hand side are the contents of the currently selected key. This image shows the settings for the colors used in the Control Panel. These are the default settings; you can have different settings <span class="No-Break">per user.</span></p>
			<p>That is one of the big advantages of the Registry: you can store settings per user and have the system figure out which to use when. You do not have to deal <span class="No-Break">with that.</span></p>
			<p>There are 5 top-level keys. I explain these in the <span class="No-Break">following table.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-7">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Key</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">HKEY_CLASSES_ROOT</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>This mainly connects files to applications: for instance, what application should Windows start if you double-click a file <span class="No-Break">in Explorer?</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">HKEY_CURRENT_CONFIG</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>This contains information about the hardware profile used by the local computer <span class="No-Break">at startup.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">HKEY_CURRENT_USER</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>All information about the current users and their preferences is stored here. If you change the theme of Windows, this is where it <span class="No-Break">ends up.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">HKEY_LOCAL_MACHINE</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Contains configuration information particular to this computer, as shared by <span class="No-Break">all users.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">HKEY_USERS</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Here, you will find all user profiles known on this computer. For each user, their preferences and info <span class="No-Break">are stored.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.1: Top-level Registry keys</p>
			<p>I am not <a id="_idIndexMarker530"/>being truthful here. Some top-level keys I just mentioned are handy shortcuts to other keys. For instance, <strong class="source-inline">HKEY_CURRENT_USER</strong> maps the currently logged-in user in <strong class="source-inline">HKEY_USERS</strong>, and <strong class="source-inline">HKEY_CLASSES_ROOT</strong> is a subkey of <strong class="source-inline">HKEY_LOCAL_MACHINE\Software</strong>. But these root keys are there to help you. For instance, instead of looking up the ID of the current user and then finding that entry in <strong class="source-inline">HKEY_USERS</strong>, you can open the <strong class="source-inline">HKEY_CURRENT_USER</strong> key and be assured you get the <span class="No-Break">correct data.</span></p>
			<p>Each top-level key can have sub-keys. Each sub-key can have its own sub-keys. In total, you can go to 512 levels deep. Each top-level and sub-level key can have one or more key/value <span class="No-Break">data pairs.</span></p>
			<p>This data has a <a id="_idIndexMarker531"/>data type. The following table shows the available <span class="No-Break">data types.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-6">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">Win </strong><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">32 type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">C# type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">REG_NONE</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">None</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>No <span class="No-Break">data type</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">REG_SZ</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">String</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A <span class="No-Break">null-terminated string</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">REG_EXPAND_SZ</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ExpandString</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A string containing unexpanded references to <span class="No-Break">environment variables</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">REG_BINARY</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">Binary</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Binary data in <span class="No-Break">any form</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">REG_DWORD</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Dword</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A 32-bit <span class="No-Break">binary number</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">REG_MULTI_SZ</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">MultiString</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>An array of null-terminated strings, terminated by a double <span class="No-Break">null character</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">REG_QWORD</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">Qword</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A 64-bit <span class="No-Break">binary number</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline" lang="en-US" xml:lang="en-US">-</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">Unknown</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>An unsupported registry <span class="No-Break">data type</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.2: .NET Registry data types</p>
			<p><em class="italic">Table 7.2</em>, however, could <a id="_idIndexMarker532"/>use a <span class="No-Break">little explanation.</span></p>
			<p>The Win32 API supports many data types. However, the CLR has fewer of them available. The ones we can use are part of an enum called <strong class="source-inline">RegistryValueKind</strong>. These enums defined are the ones I list in the C# <span class="No-Break">type column.</span></p>
			<p>The types that are provided should be enough for you. However, sometimes, you need to use specialized ones. For instance, the Win32 API supports a datatype named <strong class="source-inline">REG_RESOURCE_LIST</strong>. You use this type to store resource-related data. Unfortunately, the C# enum does not provide an equivalent for that. In those cases, you can use the <span class="No-Break"><strong class="source-inline">Unknown</strong></span><span class="No-Break"> type.</span></p>
			<p><strong class="source-inline">ExpandString</strong> can be pretty valuable. If you want to store information about the location of a file, you can use a macro such as <strong class="source-inline">%PATH%</strong>. This macro is the current path in your system. However, the path is stored like that string: <strong class="source-inline">%PATH%</strong>. If you specify <strong class="source-inline">ExpandString</strong> as the type, the OS translates that string into the actual value if you read <span class="No-Break">that data.</span></p>
			<p>But honestly, you probably use <strong class="source-inline">String</strong>, <strong class="source-inline">Binary</strong>, and <strong class="source-inline">DWord</strong> the most. The others are there in case you need <span class="No-Break">them, though.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor164"/>How to access and store data with the Windows Registry</h2>
			<p>When <a id="_idIndexMarker533"/>writing to the Registry, you must first decide where to store that data. For instance, if you want to store something specific for the current user, you would probably use <strong class="source-inline">HKEY_CURRENT_USER</strong> as your root key. As systems programmers, we are more likely to choose a key such as <strong class="source-inline">HKEY_LOCAL_MACHINE</strong> or <strong class="source-inline">HKEY_CURRENT_CONFIG</strong>. These locations are independent of the current user, which is a more likely scenario for us. But, of course, if your use case warrants it, use any key <span class="No-Break">you want.</span></p>
			<p>Since the <a id="_idIndexMarker534"/>Registry is a hierarchical database, you must specify a hierarchy. In other words, you must think of a tree-like structure to store <span class="No-Break">your data.</span></p>
			<p>I see several subkeys in my machine’s root key: <strong class="source-inline">HKEY_LOCAL_MACHINE</strong>: <strong class="source-inline">HARDWARE</strong>, <strong class="source-inline">SAM</strong>, <strong class="source-inline">SECURITY</strong>, <strong class="source-inline">SOFTWARE</strong>, and <strong class="source-inline">SYSTEM</strong>. In the <strong class="source-inline">SOFTWARE</strong> subkey, I see a lot of sub-subkeys, many of which are names of software vendors on <span class="No-Break">my machine.</span></p>
			<p>If you want to write to the Registry, you have to think about this: the location does not matter much, but for administrators who are maintaining the machines our software runs on, it has to be logical where you <span class="No-Break">put things.</span></p>
			<p>Let’s assume we want to store the first time our software runs on a particular machine. If it has never run before, we store the current date-time. If it has run before, we retrieve that data: we never change the <span class="No-Break"><strong class="source-inline">first-run</strong></span><span class="No-Break"> date.</span></p>
			<p>To store that information, we need to take the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Find the <span class="No-Break"><strong class="source-inline">HKEY_LOCAL_MACHINE\SOFTWARE</strong></span><span class="No-Break"> key.</span></li>
				<li>Create a subkey <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">SystemProgrammers</strong></span><span class="No-Break">.</span></li>
				<li>Create another subkey <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">Usage</strong></span><span class="No-Break">.</span></li>
				<li>Store the date-time in binary, in a key <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">FirstAccess</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Of course, we can only take the last step if that key doesn’t exist yet. If it does, the software has run already. In that case, we retrieve the value belonging to that key and show that <span class="No-Break">the user.</span></p>
			<p>This is what that all <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
var key = Registry.LocalMachine.CreateSubKey(@"Software\SystemsProgrammers\Usage");
var retrievedKey = key.GetValue("FirstAccess");
if (retrievedKey == null)
{
    // create the value
    key.SetValue(
        name: "FirstAccess",
        value: DateTime.UtcNow.ToBinary(),
        valueKind: RegistryValueKind.QWord);
    "First access recorded now".Dump(ConsoleColor.Cyan);
}
else
{
    if (retrievedKey is long firstAccessAsString)
    {
        var retrievedFirstAccess =
            DateTime.FromBinary(firstAccessAsString);
        $"Retrieved first access:
              {retrievedFirstAccess}".Dump(ConsoleColor.Cyan);
    }
}</pre>			<p>First, we<a id="_idIndexMarker535"/> create the subkey. If it already exists, we get a reference to it. We don’t have to specify each subkey individually; we can give this method the whole path. In our case, <strong class="source-inline">Software\SystemsProgrammers\Usage</strong>, which we store in the <strong class="source-inline">LocalMachine</strong> <span class="No-Break">root key.</span></p>
			<p>Then, we try <a id="_idIndexMarker536"/>to read the value belonging to the <strong class="source-inline">FirstAccess</strong> key. If that is <strong class="source-inline">null</strong>, we haven’t created it yet. So, we do that by calling <strong class="source-inline">key.SetValue</strong>. I specify the type to be <strong class="source-inline">QWord</strong>, but the API is smart enough to figure that out by itself: you can omit that if you want to. I like to be clear in my intentions, so I specify <span class="No-Break">it anyway.</span></p>
			<p>If the key does exist, we retrieve it. We have to do some casting from <strong class="source-inline">long</strong> before we get to <strong class="source-inline">DateTime</strong>, but after that casting, we can show <span class="No-Break">the results.</span></p>
			<p class="callout-heading">Running this sample</p>
			<p class="callout">Working with the Registry usually means you have to run with elevated privileges. This code only works if you run Visual Studio as Admin. But don’t worry: the OS informs you soon enough if you forget that. You cannot write to the Registry on this level as a <span class="No-Break">regular user.</span></p>
			<p>If you want to be more careful with the data you store in the Registry, you can apply some security. After all, since anybody can open the Registry by using the Registry Editor application, you might want to limit access to specific keys. Fortunately, the people who designed the Registry thought of the same thing. So, they enabled security features <span class="No-Break">on it.</span></p>
			<p>If we want our key to only be accessible to the current user, we can add some <span class="No-Break">security info.</span></p>
			<p>So, in our sample code, after creating the key, add the <span class="No-Break">following snippet:</span></p>
			<pre class="source-code">
var currentUser = Environment.UserName;
var security = new RegistrySecurity();
var rule= new RegistryAccessRule(
          currentUser,
          RegistryRights.FullControl,
          InheritanceFlags.None,
          PropagationFlags.None,
          AccessControlType.Allow);
security.AddAccessRule(rule);
key.SetAccessControl(security);</pre>			<p>First, we get the name <a id="_idIndexMarker537"/>of the current user, which we store in the appropriately named <strong class="source-inline">currentUser</strong> variable. We need this to tell the Registry whom we want to give access to (or deny access from) <span class="No-Break">our key.</span></p>
			<p>We create a new instance of the <strong class="source-inline">RegistrySecurity</strong> class. Then, we create a new <strong class="source-inline">RegistryAccessRule</strong>, giving it the name of the user, and decide we want this rule to apply to everything (complete control), that it is not going to be inherited by child classes, not propagated to child classes, and that we want to allow this user to take complete control (the other option is to <span class="No-Break">deny access).</span></p>
			<p>Then, we add the access rule to the security object, which is applied to the key. There you go – a <span class="No-Break">secured key!</span></p>
			<p class="callout-heading">A word of advice – limit what you store in the Registry</p>
			<p class="callout">Working with the Registry is straightforward. However, I want to stress something: do not fill out the Registry if you do not need to. Also, if you have an installer of your service, make sure that the uninstaller removes all keys you have created. A cluttered Registry is one of the best ways to slow down Windows. There is a reason companies make money selling Registry cleaner apps. Don’t be one of those developers who mess up their <span class="No-Break">users’ Registry!</span></p>
			<p>Of course, the Registry is not the only place we can store our values. Sometimes, the overhead is just too much and we do need that to achieve our goal. Let’s have a look at the difference between using the Registry and using plain JSON <span class="No-Break">settings files.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor165"/>Comparing the Windows Registry to JSON settings files</h2>
			<p>You might <a id="_idIndexMarker538"/>be surprised how easy it is to work with the Registry. With only a couple of lines of code, you can store and retrieve the information you need. You can easily distinguish between current and other users’ data. Or, more likely in our case, you can ensure the data is accessible for all services on the <span class="No-Break">current machine.</span></p>
			<p>However, there is nothing wrong with having a local file with settings. After all, there is a reason Microsoft gives you a <strong class="source-inline">settings.json</strong> file if you create a new project. That’s the best way to<a id="_idIndexMarker539"/> isolate your settings. The settings you use in your application are right next to your executable. Anyone who needs to change them can go to that folder and make changes <span class="No-Break">if needed.</span></p>
			<p>What do you choose? Which one do you <span class="No-Break">use when?</span></p>
			<p>Well, let’s <span class="No-Break">compare them.</span></p>
			<h3>Windows Registry</h3>
			<p>The <a id="_idIndexMarker540"/>Windows Registry has a couple of specific features that make it a good choice for certain scenarios. This is what <span class="No-Break">they are:</span></p>
			<ul>
				<li><strong class="bold">Centralized storage</strong>: The Registry is centralized and controlled by Windows. This location is where people tend to look <span class="No-Break">for settings.</span></li>
				<li><strong class="bold">User and machine-specific settings</strong>: With the Registry, you can have specific settings for the current user, all users, the local machine, or everybody. You can place your settings in one or more of these locations and have the OS figure out when to use <span class="No-Break">which one.</span></li>
				<li><strong class="bold">Security features</strong>: Adding rights or revoking rights is built in the Registry. You can specify on a very granular level what users can and cannot do with <span class="No-Break">your keys.</span></li>
				<li><strong class="bold">Performance</strong>: Reading from the Registry can be faster than reading files, especially if the data you are working with <span class="No-Break">is small.</span></li>
				<li><strong class="bold">Support for complex types</strong>: The Registry can handle more than just strings and numbers. If your use case demands a more exotic data type, chances are the Registry has got <span class="No-Break">you covered.</span></li>
			</ul>
			<h3>Local JSON files</h3>
			<p>JSON files are used a lot. There are several reasons people like this structure. Here are some <span class="No-Break">of them:</span></p>
			<ul>
				<li><strong class="bold">Simplicity and portability</strong>: JSON files are straightforward. They are easy to write to <a id="_idIndexMarker541"/>and read from. Another bonus is that these files are easy to transfer <span class="No-Break">between systems.</span></li>
				<li><strong class="bold">Human readable and editable</strong>: You can easily edit the JSON files: they are just text files, and the structure is <span class="No-Break">easily understood.</span></li>
				<li><strong class="bold">No dependencies on Windows</strong>: The Registry is Windows only. JSON files <span class="No-Break">are everywhere.</span></li>
				<li><strong class="bold">Version control-friendly</strong>: Since JSON files are text, systems such as Git can handle and <span class="No-Break">version them.</span></li>
				<li><strong class="bold">Avoiding system corruption</strong>: If you mess up the Registry, you risk bringing Windows to a complete halt. Or, in a slightly less lousy case, wreak havoc on other applications. With JSON files, the worst that could happen is that you render your <span class="No-Break">application useless.</span></li>
			</ul>
			<p>So, if your app is Windows only, and you need security and want to benefit from centralized, multi-user settings, go for <span class="No-Break">the Registry.</span></p>
			<p>If you value simplicity, cross-platform compatibility, and easy version control, local JSON files are a <span class="No-Break">better choice.</span></p>
			<p>Just make a decision based on what <span class="No-Break">you need.</span></p>
			<p>To summarize, most applications need to have access to settings. You could store them in local JSON files or go for the more versatile but slightly more <span class="No-Break">complex Registry.</span></p>
			<p>We have looked at what the Registry does, how to read data from it, and how to write data to it. We compared the Registry to local JSON files, and we can now decide when to use <span class="No-Break">which one.</span></p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor166"/>Worker Services</h1>
			<p>So far, all <a id="_idIndexMarker542"/>of the samples I gave you are console apps; straightforward but aimed at you, the reader, so you can see what happened. However, in real life, systems programmers do not need a console to write output or read input. We deal with software that talks and listens to other software. Systems software usually does not have a user interface. A <strong class="bold">console window</strong> is a <a id="_idIndexMarker543"/>form of user interface, which we do <span class="No-Break">not need.</span></p>
			<p>I will continue<a id="_idIndexMarker544"/> to use the console since that is a straightforward way to show you what happens, and in those applications, we can focus on the core of what I am trying to <span class="No-Break">show you.</span></p>
			<p>However, in the real world, our applications work mainly behind the scenes. One of the ways to do that is to <span class="No-Break">build services.</span></p>
			<p>A <strong class="bold">service</strong> is a <a id="_idIndexMarker545"/>standalone application that has no user interface. It does the work quietly behind the scenes. It does communicate with the outside world, but it does so through one of the many ways described in previous chapters: through network connections, files, pipes, and <span class="No-Break">so on.</span></p>
			<p>Traditionally, if you wanted a service, you had to create a <strong class="bold">Windows Service</strong>. Before you say: “Well, duh, of course,” let me explain that a Windows Service is a different type of application and project in Visual Studio. Just as a console application differs from a WPF application, a Windows Service is its <span class="No-Break">own type.</span></p>
			<p>A Windows Service is an application that runs without a user interface. Starting and operating them is not something a user does. Windows is responsible for that. There are dozens of services running on a Windows machine at all times, controlling your system and providing the background services <span class="No-Break">you need.</span></p>
			<p>The following image shows a part of the list of services running on my machine. As you can see by the scrollbar, this is just a tiny part of the total amount <span class="No-Break">of services.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer026">
					<img alt="Figure﻿7.2: Running Windows Services" src="image/B20924_08_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure7.2: Running Windows Services</p>
			<p>As you<a id="_idIndexMarker546"/> can see, the services have a name, a description, a status, a startup type, and a specific kind of user that <span class="No-Break">controls them.</span></p>
			<p>The name and description are self-explanatory. The status can be one of a set of possibilities, but in most cases, they are either running or stopped. There are other statuses, but you hardly ever <span class="No-Break">see those.</span></p>
			<p>The startup type tells us how the service is started. It can be done automatically as soon as Windows starts. It can be done automatically but with a delay, so Windows waits a bit before starting them. This allows you to have other services up and running first. It can also be manual: Windows doesn’t start them at all. There are some other options as well. Last, we see the <strong class="bold">Log On As</strong> column. This column defines under what security principle the service runs. The security principle defines what rights the <span class="No-Break">service has.</span></p>
			<p>Windows Services are powerful, and they are still around. However, in Visual Studio, you can’t create them anymore. That’s not entirely true but bear with me for <span class="No-Break">a moment.</span></p>
			<p>The current way to write service-like applications is by using the Worker <span class="No-Break">Service template.</span></p>
			<p>Worker Services<a id="_idIndexMarker547"/> are the cross-platform equivalent of Windows Services. If you run a Worker Service on Windows, you can still benefit from the features of Windows Services. That’s why I said it wasn’t entirely true that you cannot create them anymore. The CLR has incorporated the Windows Services into the <span class="No-Break">Worker Service.</span></p>
			<p>A Worker Service is much easier to build and debug than a Windows Service. Since Windows controls the Windows Service, you had to perform tricks and magic to debug them. However, a Worker Service can run like a console application, albeit with <span class="No-Break">added benefits.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor167"/>Docker support</h2>
			<p>If you <a id="_idIndexMarker548"/>create a new <strong class="source-inline">Worker Service Project</strong> in Visual Studio, you first get the standard dialog asking you about the name of the project, the location of the project, and the name of the solution. That is hardly surprising; you get that with every type of project. However, if you enter those details and click <strong class="bold">Next</strong>, you get a different version of the following dialog. For a console application, Visual Studio wants to know which version of the runtime you want (and whether you want to use top-level statements or not). With a Worker Service, Visual Studio asks you whether you want a Docker container. Your screen probably looks like the <span class="No-Break">following image:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer027">
					<img alt="Figure ﻿7.3: Extra information needed to create a Worker Service" src="image/B20924_08_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: Extra information needed to create a Worker Service</p>
			<p>If you check the box before <strong class="bold">Enable Docker</strong>, you can select the OS you want to use. This is usually a choice between Windows and Linux if you have WSL2 installed. Visual Studio creates a docker file for you, and you can now run your service in a container. Isn’t <span class="No-Break">that awesome?</span></p>
			<p>Developing<a id="_idIndexMarker549"/> your services and running them on Docker is extremely powerful. Visual Studio allows you to write your source files on your Windows machine, then deploy them to a Docker image and spin up a container with your code running. The debugger even allows you to debug your service from Visual Studio while running in the <span class="No-Break">Docker container.</span></p>
			<p>Unfortunately, I shall not be covering that here in this book. That topic warrants a book on its own. However, to show you your options, we will write a bare-bones worker service and run it on a Docker if you have that installed. If you haven’t, that’s also fine: the worker runs the same on Windows as on Linux in a Docker container. So, you pick the strategy you think works best <span class="No-Break">for you.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor168"/>Dissecting the Worker Service</h2>
			<p>In <a id="_idIndexMarker550"/>Visual Studio, you can select Worker Service as a template. If you do that, you get asked the question we already discussed: what version of the framework do you want, and do you want Docker support? If you do, what OS should it <span class="No-Break">run on?</span></p>
			<p>In my example, I have enabled Docker support and chosen Linux as the OS. It does not matter what you decide to do: the C# code is the same no <span class="No-Break">matter what.</span></p>
			<p>The bare minimum of a Worker Service has a bit more code than a regular console application, but the main files are <strong class="source-inline">Program.cs</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Worker.cs</strong></span><span class="No-Break">.</span></p>
			<p>My application looks like this in the Visual Studio <span class="No-Break">solution window:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer028">
					<img alt="Figure ﻿7.4: The layout of the Worker Service in Visual Studio" src="image/B20924_08_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4: The layout of the Worker Service in Visual Studio</p>
			<p>The <strong class="source-inline">Program</strong> class is not even that interesting. It contains, next to the namespace declaration, the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
var builder = Host.CreateApplicationBuilder(args);
builder.Services.AddHostedService&lt;Worker&gt;();
var host = builder.Build();
host.Run();</pre>			<p>Let me outline the steps I took to get to <span class="No-Break">these results:</span></p>
			<p>First, we create an instance of the <strong class="source-inline">HostApplicationBuilder</strong> class. We do that by calling <strong class="source-inline">CreateApplicationBuilder</strong> on the static <span class="No-Break"><strong class="source-inline">Host</strong></span><span class="No-Break"> class.</span></p>
			<p>The <strong class="source-inline">builder</strong> instance allows us to register classes. That way, we can use dependency injection. The template adds one service for us: the <span class="No-Break"><strong class="source-inline">Worker</strong></span><span class="No-Break"> class.</span></p>
			<p>Next, we build <strong class="source-inline">host</strong> (of the <strong class="source-inline">IHost</strong> type), and finally, we <span class="No-Break">run it.</span></p>
			<p>The <a id="_idIndexMarker551"/>more exciting code is in the <strong class="source-inline">Worker</strong> class. As the name implies, that’s where all the work happens. We do not call it a Worker Service <span class="No-Break">for nothing!</span></p>
			<p>Let’s take a look at that <span class="No-Break"><strong class="source-inline">Worker</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
public class Worker : BackgroundService
{
    private readonly ILogger&lt;Worker&gt; _logger;
    public Worker(ILogger&lt;Worker&gt; logger)
    {
        _logger = logger;
    }
    protected override async Task ExecuteAsync(CancellationToken       stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            if (_logger.IsEnabled(LogLevel.Information))
            {
                _logger.LogInformation("Worker running at: {time}",                   DateTimeOffset.Now);
            }
            await Task.Delay(1000, stoppingToken);
        }
    }
}</pre>			<p>If you want to rename this class, you can do that, of course, as long as you also change the registered class in the <strong class="source-inline">Program</strong> class. Also, if you want to build multiple classes next to <strong class="source-inline">Worker</strong>, you can also do that. Again, do not forget to add them to <strong class="source-inline">builder</strong> in the <span class="No-Break"><strong class="source-inline">Program</strong></span><span class="No-Break"> class.</span></p>
			<p>So, what is going <span class="No-Break">on here?</span></p>
			<p>The <a id="_idIndexMarker552"/>base class is <strong class="source-inline">BackgroundService</strong>. This class takes care of all the plumbing. It is an abstract class with the <strong class="source-inline">ExecuteAsync(CancellationToken stoppingToken)</strong> abstract method. So, you must write that method yourself (or let the template do that, as we <span class="No-Break">did here.)</span></p>
			<p>The constructor of our class gets a default instance of <strong class="source-inline">logger</strong> that allows us to write things to the console when running. This <strong class="source-inline">logger</strong> is available to us through the magic of <span class="No-Break">dependency injection.</span></p>
			<p>In the <strong class="source-inline">ExecuteAsync</strong> method, we keep looping until <strong class="source-inline">CancellationToken</strong> signals we want to stop. In the loop, we output a message and wait for a second before going to the <span class="No-Break">next iteration.</span></p>
			<p>If you run this, you will see the output. If you have Docker Desktop running, you can also run it on Docker. Just select Docker as what you want to run instead of your application. Visual Studio builds the image, deploys it, starts a container, and hooks the debugger to <span class="No-Break">allow debugging.</span></p>
			<p>In the output window of Visual Studio and Docker Desktop itself, you can see the results: the output of our loop is <span class="No-Break">printed there.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor169"/>Controlling the lifetime of the service</h2>
			<p>A Worker Service is <a id="_idIndexMarker553"/>meant to run forever. Well, maybe not forever, but at least as long as your machine runs. It is in there in the background, doing its job. It might be doing something worthwhile or waiting for incoming messages over a file, network, or any other way we discussed. It does its job and then returns to waiting for the <span class="No-Break">next assignment.</span></p>
			<p>But what if you want to stop the service when it has fulfilled its purpose? Let’s rewrite the code a bit. Add a private variable to our Worker Service <strong class="source-inline">call _counter</strong> of the <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> type.</span></p>
			<p>Then, change the loop in <strong class="source-inline">ExecuteAsync</strong> to look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    while (!stoppingToken.IsCancellationRequested)
    {
        if (_logger.IsEnabled(LogLevel.Information))
        {
            _logger.LogInformation("Worker running at: {time}",               DateTimeOffset.Now);
        }
        await Task.Delay(1000, stoppingToken);
        if (_counter++ &gt;= 9)
        {
            break;
        }
    }
    _logger.LogInformation("Worker stopped at: {time}",       DateTimeOffset.Now);
}</pre>			<p>After <a id="_idIndexMarker554"/>waiting one second, we checked to see whether the loop had been run 10 times. If it has, we break out of the loop. Then, we print a message to tell you it has <span class="No-Break">done so.</span></p>
			<p>Run it and watch. You notice that it works as expected but that Visual Studio does not return to normal: it keeps debugging. However, there is nothing to debug! If you break, you see that Visual Studio still executes the call to <strong class="source-inline">Host.Run()</strong> in <strong class="source-inline">Program</strong>. Apparently, there is no <span class="No-Break">way out!</span></p>
			<p>Well, of course, there is. In this case, all we have to do is tell <strong class="source-inline">Host</strong> that we want it to stop working. We can do that <span class="No-Break">quite easily.</span></p>
			<p>We use<a id="_idIndexMarker555"/> dependency injection again. One of the services available to us is an instance of a class that implements the <strong class="source-inline">IHostApplicationLifetime</strong> interface. Let’s add that to the constructor of the <span class="No-Break"><strong class="source-inline">Worker</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
private readonly IHostApplicationLifetime _hostApplicationLifetime;
public Worker(
    ILogger&lt;Worker&gt; logger,
    IHostApplicationLifetime hostApplicationLifetime)
{
    _logger = logger;
    _hostApplicationLifetime = hostApplicationLifetime;
}</pre>			<p>We get that instance and store it in a <span class="No-Break">local field.</span></p>
			<p>Then, in the <strong class="source-inline">ExecuteAsync</strong> method, just after where we log that we have finished the loop, add the <span class="No-Break">following line:</span></p>
			<pre class="source-code">
_hostApplicationLifetime.StopApplication();</pre>			<p>That’s all there is to it. The <strong class="source-inline">Host</strong> instance now gets the message telling it to stop working and return to <span class="No-Break">the OS.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor170"/>Wrapping up Worker Services</h2>
			<p>Worker Services <a id="_idIndexMarker556"/>are excellent if you want a piece of code running in the background without any user interface, only meant to be called by other software. Does that sound familiar? That is precisely what systems programmers strive for. Worker Services are your best bet here. They can do anything you want. They can open ports on a TCP connection, watch folders for files, have named pipes to wait for data and process it, wait for network connections, and <span class="No-Break">much more.</span></p>
			<p>In short, they are a much better place to do all that work than the console applications we have been writing so far. You can still register them as services in Windows, so they start up automatically as soon as <span class="No-Break">Windows starts.</span></p>
			<p>The code is<a id="_idIndexMarker557"/> simple enough. Ensure your code is initiated from the <strong class="source-inline">Worker</strong> class, and you are good <span class="No-Break">to go.</span></p>
			<p>We will stick with the console applications in the rest of this book. Not because they are a better way to do systems programming (they are not) but because they are so easy and do not get in the way when I am working on explaining new topics. But now you know: everything you can do in a console application can (and should) be done in a Worker Service. You can deploy your code on Linux machines or Docker platforms if it is cross-platform and does not use Windows-only APIs. It is all up <span class="No-Break">to you!</span></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor171"/>WMI</h1>
			<p>System <a id="_idIndexMarker558"/>programmers work closer to the OS than other, more user-oriented programmers. We often need to know more about the state of the OS than others do. We might need to keep track of the memory used, the hardware state, and other lower-level items. Luckily, Windows allows us to do just that. We can have a window (no pun intended) into the engine room, so <span class="No-Break">to speak.</span></p>
			<p>WMI is the tool to use. It’s like the Swiss Army knife for managing items in Windows. WMI is part of the Windows OS that allows you to access and manipulate all sorts of system information and settings. This is Windows only, of course. In Linux, there is no built-in, out-of-the-box alternative to WMI. If you want to do this on a Linux machine, use external libraries <span class="No-Break">and tools.</span></p>
			<p>What can you do with WMI? You’d better ask, “What can’t you do with WMI?” Let me show you some of the more common uses <span class="No-Break">of WMI:</span></p>
			<ul>
				<li><strong class="bold">Monitoring system health</strong>: You can check on CPU load, available memory, disk usage, and <span class="No-Break">so on.</span></li>
				<li><strong class="bold">Managing hardware and software</strong>: You can get information about installed software, manage printers, and even play around with <span class="No-Break">BIOS settings.</span></li>
				<li><strong class="bold">Automating tasks</strong>: You can use WMI to automate tasks, such as monitoring and restarting a service <span class="No-Break">if necessary.</span></li>
				<li><strong class="bold">Event notifications</strong>: We already saw the possibility of watching a folder or a file, but we can do much more. We can get notifications for almost anything that happens on <span class="No-Break">the system.</span></li>
			</ul>
			<p>There are many <a id="_idIndexMarker559"/>more things you can do with WMI. However, let’s focus on these first. Before we begin looking at some samples, you need to install a NuGet package: <strong class="source-inline">System.Management</strong> from Microsoft. This package replaces the older <strong class="source-inline">System.Management</strong> assembly that was part of the .<span class="No-Break">NET Framework.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor172"/>How to use WMI</h2>
			<p>The primary <a id="_idIndexMarker560"/>way of interacting with Windows is by querying it. The <strong class="source-inline">System.Management</strong> NuGet package gives us access to a class named <strong class="source-inline">ManagementObjectSearcher</strong>. This class allows us to create queries and run them against Windows. The searcher usually returns a collection of <strong class="source-inline">ManagementObject</strong> instances, which you can interact with. These <strong class="source-inline">ManagementObject</strong> instances reflect something in your system. This class has an indexer, so you can query that object to get the information you <span class="No-Break">are searching.</span></p>
			<p><strong class="source-inline">ManagementObjectSearcher</strong> can search over a lot of different types of data providers. That means you might have to limit the search by giving it a <span class="No-Break">scope first.</span></p>
			<p>The query itself is a string that starts with <strong class="source-inline">SELECT</strong>. It is just like <span class="No-Break">a database.</span></p>
			<p>Be careful what you do, though; we are opening the hood of the engine and poking around in places we are usually not meant to be poking around in. Most of the queries run on WMI require elevated privileges. You need to be a local administrator to make some changes or see some of the data. That means that all safeguards are out of the window. You are on your own. With great power comes great <span class="No-Break">responsibility, right?</span></p>
			<p>All of the following samples only run on Windows. Visual Studio is smart enough to see that: if you follow along, you will see many warnings about that. To be specific, you get the <strong class="source-inline">CA1416</strong> warning a lot. This warning says <strong class="source-inline">This call is reachable on all platforms. ManagementObjectSearcher is only supported </strong><span class="No-Break"><strong class="source-inline">on: Windows</strong></span><span class="No-Break">.</span></p>
			<p>To get rid of that, add a pragma to the top of <span class="No-Break">the file:</span></p>
			<pre class="source-code">
#pragma warning disable CA1416</pre>			<p>This instruction tells the compiler not to bother: we know what we are doing. Now, the compiler gets out of your way and lets you be responsible for all damages that might occur if <a id="_idIndexMarker561"/>you still try to run this <span class="No-Break">on Linux.</span></p>
			<p>But enough of the scaremongering. Before we get into a heated debate on the pros and cons of being a local admin, we have to measure the heat a bit. Let’s measure the temperature of <span class="No-Break">our CPU!</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor173"/>Reading the CPU temperature</h2>
			<p>Most of the<a id="_idIndexMarker562"/> BIOS implementations allow the system to read the current CPU temperature. Other vendors of motherboards might have other ways of reading temperatures in the system, one of which might be the CPU. It all depends on the vendor. However, if your system supports it, you can easily read the current temperature. You could use that information to scale down your work in your system if you notice you are making the CPU work too hard. But how do we get that temperature? The code is <span class="No-Break">relatively simple:</span></p>
			<pre class="source-code">
public void ReadTemperaturesUsingMsAcpi()
{
    var scope = "root\\WMI";
    var query = "SELECT * FROM MSAcpi_ThermalZoneTemperature";
    var searcher = new ManagementObjectSearcher(scope, query);
    try
    {
        foreach (var o in searcher.Get())
        {
            var obj = (ManagementObject)o;
            var temperature = Convert.              ToDouble(obj["CurrentTemperature"]) / 10 - 273.15;
            $"CPU Temperature: {temperature}°C".Dump();
        }
    }
    catch (ManagementException)
    {
        "Unfortunately, your BIOS does not support this             API.".Dump(ConsoleColor.Red);
    }
}</pre>			<p>First, I <a id="_idIndexMarker563"/>identify the scope of the query. In this case, it is <strong class="source-inline">root\\WMI</strong>. Then, I create the query string, where we select everything from the <strong class="source-inline">MCAcpi_ThermalZoneTemperature</strong> class. As I said before, this results in a collection of <strong class="source-inline">ManagementObject</strong> instances. In this case, the collection consists of one item. This item has an indexer, and if we request the <strong class="source-inline">CurrentTemperature</strong> field, we get the current temperature of the CPU in tenths of Kelvin. We multiply that result by ten to get to the actual Kelvin value and then convert that to degrees Celsius. If you want to go to Fahrenheit, be <span class="No-Break">my guest.</span></p>
			<p>As I said, not all vendors supply this option. I use an older laptop from 2018 quite frequently, but it does not give me this information. I see <strong class="source-inline">ManagementException</strong> on that machine when I try to get the results. However, I got the results on my beefy desktop machine <span class="No-Break">as expected.</span></p>
			<p>There is another class you can use to query for the temperature. The query for that is <strong class="source-inline">SELECT * FROM Win32_TemperatureProbe</strong>, and the scope for that query <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">root\\CIMV2</strong></span><span class="No-Break">.</span></p>
			<p>However, there can be multiple probes in your machine. Some motherboards also support measuring the temperature of other components, such as the GPU. To be honest, <strong class="source-inline">Win32_TemperatureProbe</strong> is even less commonly implemented <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">MCAcpi_ThermalZoneTemperature</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor174"/>Reading the BIOS</h2>
			<p>The<a id="_idIndexMarker564"/> BIOS is the lowest level of abstraction on your machine. This level is where all the logic gets translated into voltages fed into the hardware. Wouldn’t it be nice to see what is going on there? Well, you can, with the power <span class="No-Break">of WMI!</span></p>
			<p>Let’s get some basic information out of the BIOS and display that. Here <span class="No-Break">we go:</span></p>
			<pre class="source-code">
public void ReadBIOSDetails()
{
    // Create a management scope object
    ManagementScope scope = new ManagementScope("\\\\.\\ROOT\\cimv2");
    scope.Connect();
    // Query object for BIOS information
    ObjectQuery query = new ObjectQuery("SELECT * FROM Win32_BIOS");
    using ManagementObjectSearcher searcher = new       ManagementObjectSearcher(scope, query);
    foreach (var o in searcher.Get())
    {
        var queryObj = (ManagementObject)o;
        "----------------------------------
            ".Dump(ConsoleColor.Yellow);
        "BIOS Information".Dump(ConsoleColor.Yellow);
        "----------------------------------
            ".Dump(ConsoleColor.Yellow);
        $"Manufacturer:
            {queryObj["Manufacturer"]}".Dump(ConsoleColor.Yellow);
        $"Name:
            {queryObj["Name"]}".Dump(ConsoleColor.Yellow);
        $"Version:
            {queryObj["Version"]}".Dump(ConsoleColor.Yellow);
    }
}</pre>			<p>For this <a id="_idIndexMarker565"/>example, I have used a different constructor. Instead of passing in the scope and query as strings, I construct these two items first using the managed <strong class="source-inline">ManagementScope</strong> and <strong class="source-inline">ObjectQuery</strong> wrapper classes. This way of working achieves the same result but might be more readable to future developers working on <span class="No-Break">this code.</span></p>
			<p>The structure is similar to the previous example. We create an instance of a <strong class="source-inline">ManagmentObjectSearchers</strong> class, feed it the scope and query, and then query the results. In our example, we get the manufacturer, name, <span class="No-Break">and version.</span></p>
			<p>You can read many more properties from the BIOS, such as the capabilities. These describe what hardware is supported on that machine. As a systems programmer, you probably can imagine how this could be handy <span class="No-Break">to know.</span></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor175"/>Controlling the Windows Update service</h2>
			<p>We<a id="_idIndexMarker566"/> discussed Worker Services earlier in this chapter. However, wouldn’t it be nice if we could write software that allows us to monitor the state of those services and act upon them if needed? Well, we can <span class="No-Break">with WMI.</span></p>
			<p>In the following sample, we look at the status of a generic service: the Windows Update service. This service is part of the OS and is responsible for dealing with updates: monitoring, downloading, and installing them. Ideally, that service should always be up and running. Let’s see what we can do with WMI to <span class="No-Break">achieve that:</span></p>
			<pre class="source-code">
public void ControlService()
{
    // Define the service. In this case,
    // we're using the Windows Update service
    string serviceName = "wuauserv";
    // Define the query to get the service
    string queryString = $"SELECT * FROM Win32_Service WHERE Name =     '{serviceName}'";
    // Create a query to get the specified service
    ManagementObjectSearcher searcher =
        new ManagementObjectSearcher(queryString);
    // Execute the query
    foreach (var o in searcher.Get())
    {
        var service = (ManagementObject)o;
        // Check the service state before trying to stop it
        if (service["State"].ToString().ToLower() == "running")
        {
            // Stop the service
            service.InvokeMethod("StopService", null);
            // Wait a bit for the service to stop
           System.Threading.Thread.Sleep(2000);
            // Start the service again
            service.InvokeMethod("StartService", null);
            $"{serviceName} service restarted                  successfully.".Dump(ConsoleColor.Cyan);
        }
    }
}</pre>			<p>In this example, I do<a id="_idIndexMarker567"/> not specify a scope. Windows then assumes the default scope of <strong class="source-inline">root\CIMV2</strong>, as we saw before. Generally, it would be best if you used a scope. Specifying a scope limits the areas where WMI executes your query, which improves the speed tremendously. I just wanted to show you this approach here so you know it is <span class="No-Break">an option.</span></p>
			<p>We are looking for a service with the name of <strong class="source-inline">wuauserv</strong>, the Windows Update service. If we find it, we get the current state. It should be “running.” If it is, we stop it, wait for two seconds and <span class="No-Break">restart it.</span></p>
			<p>There you have it: you can now control services inside <span class="No-Break">your code!</span></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor176"/>Watching USB devices</h2>
			<p>Sometimes, you <a id="_idIndexMarker568"/>might be depending on specific hardware. Let’s assume you are reading data from a USB device. Wouldn’t it be nice to be informed when the user removes the device? That would prevent embarrassing errors in your code, right? Again, we have WMI coming to <span class="No-Break">our aid!</span></p>
			<p>This is the code to do <span class="No-Break">just that:</span></p>
			<pre class="source-code">
public void StartListening()
{
    string wmiQuery = "SELECT * FROM __InstanceDeletionEvent WITHIN 2 " +
      "WHERE TargetInstance ISA'Win32_USBHub'";
    ManagementEventWatcher watcher = new       ManagementEventWatcher(wmiQuery);
    watcher.EventArrived += new EventArrivedEventHandler(USBRemoved);
    // Start listening for events
    watcher.Start();
    "Unplug a USB device to see the event.\nPress ENTER to        exit.".Dump(ConsoleColor.Cyan);
    Console.ReadLine();
    // Stop listening for events
    watcher.Stop();
}</pre>			<p>The query <a id="_idIndexMarker569"/>tells the system to look at an event called <strong class="source-inline">__InstanceDeletionEvent</strong>. This is the event that Windows raises once something is deleted on the computer. In this case, we look for something in the list of devices registered in <strong class="source-inline">ISA'Win32_USBHub'</strong>. In other words, we want to be notified if a USB device is deleted from the system. <strong class="source-inline">WITHIN 2</strong> means we want to check every 2 seconds. So, there might be <span class="No-Break">a delay.</span></p>
			<p>This time, we create a new object. The watcher is a new instance of the <strong class="source-inline">ManagementEventWatcher</strong> class. We give it the query, set up a callback in case the event happens, and start watching. When we are done, we stop <span class="No-Break">watching again.</span></p>
			<p>The event handler looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
private void USBRemoved(object sender, EventArrivedEventArgs e)
{
    // Get the instance of the removed device
    ManagementBaseObject instance = (ManagementBaseObject)        e.NewEvent["TargetInstance"];
    // Extract some properties
    string deviceID = (string)instance["DeviceID"];
    string pnpDeviceID = (string)instance["PNPDeviceID"];
    string description = (string)instance["Description"];
    var message =
        $"USB device removed:" +
        $"\n\t\tDeviceID={deviceID}" +
        $"\n\t\tPNPDeviceID={pnpDeviceID}" +
        $"\n\t\tDescription={description}";
    message.Dump(ConsoleColor.Yellow);
}</pre>			<p>As <a id="_idIndexMarker570"/>soon as the event occurs, this code gets called. <strong class="source-inline">eventargs</strong> of the <strong class="source-inline">EventArrivedEventArgs</strong> type contains much information. Amongst others, it has <strong class="source-inline">TargetInstance</strong> in it. <strong class="source-inline">TargetInstance</strong> has all sorts of information we <span class="No-Break">can display.</span></p>
			<p>We could have used another approach: we could have queried the <strong class="source-inline">Win32_DeviceChangedEvent</strong> class. That would have been a bit easier, but that gives us less information than our current solution. This is typical for WMI: there is usually more than one way to get the <span class="No-Break">desired results.</span></p>
			<p>Play around with it; start the code and unplug several devices from your machine. See <span class="No-Break">what happens!</span></p>
			<p class="callout-heading">Final words about WMI</p>
			<p class="callout">WMI is <a id="_idIndexMarker571"/>very powerful. You can do all sorts of things that are typically unavailable to a regular .NET application. However, there are downsides: WMI is highly resource intensive. We set the event watcher in the last sample to only run once every two seconds to mitigate that a <span class="No-Break">little bit.</span></p>
			<p class="callout">WMI is somewhat obscure. You have to figure out the queries yourself; there is not much information that teaches you all the available options. Of course, the Microsoft documentation has plenty to say about this topic, but it is not as straightforward as you might be used to. There is quite a steep learning curve if you want to dive into this. That leads to another risk: you can quickly get <span class="No-Break">things wrong.</span></p>
			<p class="callout">WMI allows you to interact with lower parts of the system, which can cause catastrophic results. Another risk is that it unadvertly displays security-sensitive information. So, be careful what <a id="_idIndexMarker572"/>you do with it. As always, test what happens if you use <span class="No-Break">this technique.</span></p>
			<p class="callout">However, if you are careful, you can do many <span class="No-Break">cool things!</span></p>
			<p>We have seen some really nice things here. You might be tempted to sprinkle a lot of Registry and WMI code over your systems. However, before you do that, let’s take a peek into the downsides: there are potential risks we should <span class="No-Break">talk about!</span></p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor177"/>Registry and WMI – risks and how to avoid them</h1>
			<p>Nothing comes for free. That also applies to OS services: there is a price to pay. The complexity of the code isn’t too high; I am sure you could follow along. No, the price you have to pay lies elsewhere: mistakes can be hard to spot and even harder to fix. The risks are pretty high: an error could lead to unpredictable behavior of the machine. You could bring down a complete server if you do <span class="No-Break">things wrong.</span></p>
			<p>Of course, we are all brilliant developers. We do not make mistakes, right? However, just in case we have a moment of weakness (we all know that 14 hours of developing software in one sitting is not the best idea), I want to tell you about the risks and how to avoid them as much <span class="No-Break">as possible.</span></p>
			<p>But before I do that, we have a whole chapter (<a href="B20924_12.xhtml#_idTextAnchor237"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, to be exact) about debugging. That’s where we will dive into the nitty gritty details of that topic. But here, I want to focus on what might go wrong when working with the Registry <span class="No-Break">and WMI.</span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/>The Windows Registry</h2>
			<p>As <a id="_idIndexMarker573"/>mentioned before, the Windows Registry is where the OS and most applications running on it store and read their settings. These could range from simple values about the user preferences to details about <span class="No-Break">installed peripherals.</span></p>
			<p>Making a mistake here could result in an application not working as expected. However, it could also result in the machine breaking down completely. So, you’d better be careful when dabbling around in <span class="No-Break">the Registry!</span></p>
			<p>There are several steps you can take to mitigate the risks. Let’s go <span class="No-Break">through them.</span></p>
			<h3>Backup</h3>
			<p>If you start <a id="_idIndexMarker574"/>experimenting with the Registry, the best tip I can give you is to back up your current settings. You can export and import keys and <a id="_idIndexMarker575"/>subkeys in the Registry Editor tool (<strong class="source-inline">regedit.exe</strong> in your Windows directory). That means you can easily roll back your changes when you make a mistake. If you are doing this in your application, you might consider reading your app’s settings and storing them before applying changes. Of course, you do not do that when storing simple settings, but this might save you when you need it for more <span class="No-Break">threatening situations.</span></p>
			<h3>Proper tools</h3>
			<p>In the end, the <a id="_idIndexMarker576"/>Registry itself is a collection of files on the storage medium of your computer. After all, the data needs to be stored somewhere. It is no secret where these files are stored. For instance, you can find the <strong class="source-inline">HKEY_LOCAL_USER</strong> settings in the <strong class="source-inline">UsrClass.dat</strong> file in the <strong class="source-inline">%UserProfile%\Local Settings\Application Data\Microsoft\Windows</strong> folder. However, I would not recommend messing around with these files yourself. Use the tools. The aforementioned Registry Editor is a great way to read and change settings. If you want to do this in your software, use the tools the BCL and the Win32 API give you. If you are curious about what happens to the Registry in run time, the free Process Monitor tool from SysInternals is invaluable. It can give you a live view of all processes working with the Registry. It might surprise you how often the Registry <span class="No-Break">is used!</span></p>
			<h3>Keep it minimal</h3>
			<p>The Registry is not meant to store large amounts of data. It is for smaller items, such as settings and preferences. Use it wisely: do not store too much data there. A good solution would be to have larger amounts of data stored in a file and store the location of that file in the Registry in a well-known place. This way, you can differentiate between different users (since the Registry keeps track of the user and presents you with the correct <strong class="source-inline">HKEY_LOCAL_USER</strong> instance) but still have a place to store <span class="No-Break">more data.</span></p>
			<h3>Logging is your friend</h3>
			<p>Loggings is always a great tool when debugging your code, but this is especially true when<a id="_idIndexMarker577"/> dealing<a id="_idIndexMarker578"/> with the Registry. When something goes wrong, logs can be a lifesaver. Next to that, logs can help you understand your software’s flow and clarify why specific paths in your code were taken. When developing, you can never have too many log files. However, you might want to turn down the amount and verbosity of your logs when you go <span class="No-Break">into production.</span></p>
			<h3>Error handling</h3>
			<p>Error handling <a id="_idIndexMarker579"/>should be a no-brainer. Use try-catch blocks as much as you can. Do not catch the generic <strong class="source-inline">Exception</strong> class, but be specific. After all, the <em class="italic">only catch the exceptions you can handle</em> rule is <span class="No-Break">still valid.</span></p>
			<p>Software that works with the Registry might encounter exceptions such as <strong class="source-inline">SecurityException</strong>, <strong class="source-inline">IOException</strong>, and <strong class="source-inline">UnauthorizedAccessException</strong>. Be mindful of those. Catch them and return your software in a known state before continuing <span class="No-Break">the flow.</span></p>
			<p>Also, please log <span class="No-Break">these instances!</span></p>
			<h3>Test in an isolated environment</h3>
			<p>When <a id="_idIndexMarker580"/>dealing with the more risky areas of the Registry, you might want to do that on a different machine than your daily device. You do not need to switch to a different machine but can use other techniques. You can quickly deploy a <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) locally or in the cloud. With Azure, making a VM and deploying and running your code is extremely easy. If it all works, that’s fine. If it doesn’t, all you have to do is delete the VM and <span class="No-Break">try again.</span></p>
			<p>Another good approach is to use Docker. If you switch Docker from Linux containers to Windows containers, you can deploy your Worker Services to Docker and then work on the isolated, local Registry in that container. If it goes wrong, no harm is done. If you also log to a persistent file stored outside the container so that it lives on after the container crashes, you can do a <span class="No-Break">post-mortem conveniently.</span></p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor179"/>Potential risks when dealing with WMI</h2>
			<p>WMI <a id="_idIndexMarker581"/>can be very powerful. You can query your system without having to resort to the Registry. You can also change settings, start services, configure network settings, and <span class="No-Break">much more.</span></p>
			<p>However, WMI is not easy. The documentation is out there, but you must look for it and piece it together yourself. However, there are some tips and tricks I can give you to get up to speed with WMI and use it to <span class="No-Break">your advantage.</span></p>
			<h3>Start with the basics</h3>
			<p>Know<a id="_idIndexMarker582"/> your <strong class="bold">WMI Query Language</strong> (<strong class="bold">WQL</strong>). It is a bit like SQL for the WMI system. Since you often pass in the queries to the WMI in strings, you should be careful not to make typos. They are notoriously hard to spot. Knowing the syntax of WQL can help in <span class="No-Break">those cases.</span></p>
			<p>One often-made mistake is not using the correct namespace when querying the system. Although most queries run against the <strong class="source-inline">ROOT\CMIV2</strong> namespace, not all do. Make sure you use the <span class="No-Break">correct namespace.</span></p>
			<h3>Use the right tools</h3>
			<p>When learning about WMI, you might want to play around with it first. There is an almost unknown tool that comes with Windows called <strong class="source-inline">WBEMTest</strong>. You can start that by entering that term into the <strong class="bold">Search</strong> field <span class="No-Break">in Windows.</span></p>
			<p>This tool is a quick entry into the WMI. The user interface looks like it comes straight out of Windows 95, but it is a nice way to investigate WMI. For instance, if I want to know more about my BIOS vendor, I can use the code we looked at before or enter that in <strong class="source-inline">WBEMTest</strong>. That looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer029">
					<img alt="Figure ﻿﻿7.5: WBEMTest querying the BIOS" src="image/B20924_08_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: WBEMTest querying the BIOS</p>
			<p>This<a id="_idIndexMarker583"/> image shows <strong class="source-inline">WBEMTest</strong> in action. In the top left corner, I connected the app to the <strong class="source-inline">ROOT\CMIV2</strong> namespace. Then, I clicked on <strong class="bold">Query</strong> and entered the <strong class="source-inline">SELECT * FROM Win32_BIOS</strong> query. I got the results you see in the bottom <span class="No-Break">right window.</span></p>
			<p>Powershell is also a great way to interact with WMI before incorporating WMI into your system. You can use the <strong class="source-inline">Get-WMIObject</strong> cmdlets to interrogate the system. For instance, getting the information about the BIOS results in <span class="No-Break">the following:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer030">
					<img alt="Figure ﻿7.6: Get-WMIObject in PowerShell" src="image/B20924_08_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6: Get-WMIObject in PowerShell</p>
			<p>As you can see, I can enter <strong class="source-inline">Get-WMIObject</strong>, then pass the name of the object I want to interrogate (<strong class="source-inline">Win32_Bios</strong>), and I get all results <span class="No-Break">nicely formatted.</span></p>
			<h3>Improve your code</h3>
			<p>The tips <a id="_idIndexMarker584"/>I gave you for handling the Registry also apply here: catch the right exceptions and log as much <span class="No-Break">as possible.</span></p>
			<p>The most seen exception when working with WMI is <strong class="source-inline">ManagementException</strong>. Of course, we also saw queries not supported on specific platforms. Be aware of those issues and handle <span class="No-Break">them appropriately.</span></p>
			<p>Logging is also a great way to debug your WMI code. Log as much as you can during development to know what is happening when things <span class="No-Break">go south.</span></p>
			<h3>Performance and memory considerations</h3>
			<p>As systems programmers, we care deeply about performance and memory usage. WMI can significantly slow down your app. Especially when polling too often, you will see a degradation of your performance. Avoid frequent polling. You do not need to check the temperature every <span class="No-Break">millisecond, anyway.</span></p>
			<p>Also, do not forget to dispose of all CLR classes dealing with the WMI properly. If handles to those classes remain open too long, you might exhaust the available resources. That is a great way to bring your system to a screeching halt. Let’s not <span class="No-Break">do that!</span></p>
			<p>One final note: WMI relies on the WMI service. Yes, that is a Windows Service. If that service is not<a id="_idIndexMarker585"/> running, WMI does not work. That will not likely ever happen, but that situation might occur. So, if things do not work as you expect, please also check <span class="No-Break">that service.</span></p>
			<p>Of course, all other tips and tricks I gave you throughout this book also apply. There is nothing magical about WMI, Worker Services, and the Registry. It is just that they might need a bit more attention to avoid getting into <span class="No-Break">weird situations.</span></p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor180"/>Next steps</h1>
			<p>Windows gives you many tools to use. These tools are deeply integrated into the system. Most of them are never used by applications used by users. But for us, as systems programmers, this is different. We are working closer to the metal, so it is good to know what that metal <span class="No-Break">offers us.</span></p>
			<p>I suggest you play with the Registry Editor and see what hidden gems you can find there. Next to that, learn WQL. Many tools offer a nice interface to the WMI, but in the end, you will have WQL strings in your application. You might as well start to learn <span class="No-Break">about them.</span></p>
			<p>Finally, learn Docker. Docker is a great way to package your applications and a valuable debugging tool. You can use Docker to isolate your potentially dangerous code. If things go wrong, all you need to do is delete the running container and start again. Of course, everything we discussed in this chapter is only available on Windows, so you must use Windows containers on Docker. When you are sure your code works fine, you can use it on real <span class="No-Break">Windows machines.</span></p>
			<p>In this chapter, we looked at all the tools that Windows give us; tools we can use in our code to do things that are hard to do if we had to write everything ourselves. We learned about the centralized settings storage mechanism called <span class="No-Break">the Registry.</span></p>
			<p>We also learned about the ways we can query the OS and even the underlying hardware through the use of WMI. We talked about how to use them and we talked about how to avoid some of the <span class="No-Break">risks involved.</span></p>
			<p>Now, with these skills under our belt, it is time to escape the confinement of the single machine and venture into the land of networking. Systems these days rarely run in isolation on one machine. They communicate. They talk to each other. We should be looking into networking next. So, hook up your dial-up modem and follow along for the road down the <span class="No-Break">network protocols!</span></p>
		</div>
	</body></html>