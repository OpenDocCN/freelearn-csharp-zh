- en: 'Chapter 7: Coding Efficiently with AI and Code Views'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Artificial intelligence is a vast and interesting field that allows us to improve
    our lifestyle in one way or another. We see, hear, and use it every day, and if
    you don't believe it, ask yourself how many times you use the Google search engine
    throughout the day. Other places where you can find it are in photo-editing programs,
    where it is possible to remove, for example, the background of an image in an
    almost perfect way. Social networks are another perfect example of the use of
    artificial intelligence, as they are constantly processing the best recommendations
    for you to stay on them as long as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, artificial intelligence has even reached new software development
    tools, through predictive code integration, which allows us to choose the pieces
    of code we need at the right time. In Visual Studio, we have a powerful feature
    called **Visual Studio IntelliCode** that does this.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we have different visual tools and windows that can help us find
    relationships in our code and navigate through them efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CodeLens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with code views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Visual Studio IntelliCode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use IntelliCode, Visual Studio 2022 with the web development workload must
    be installed. Because this chapter focuses more on showing auto-completion and
    class display features, no changes have been made to the code repositories. You
    can use the repository hosted at the following URL: [https://github.com/PacktPublishing/Hands-On-Visual-Studio-2022/tree/main/Chapter07](https://github.com/PacktPublishing/Hands-On-Visual-Studio-2022/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: Also, to be able to perform the procedure of the *Code maps* section, it is
    required to use the Enterprise version of Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, the **Code Map** and **Live Dependency Validation** tools must be
    installed by the Visual Studio Installer, selecting them as shown in *Figure 7.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Installation of the Code Map and Live Dependency Validation
    features'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Installation of the Code Map and Live Dependency Validation features
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the technical requirements, let's learn how to work with them
    to get the most out of Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CodeLens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CodeLens is a powerful set of tools that is useful for finding references in
    code, relationships between your different components, seeing the history of changes
    in the code, linked bugs, code reviews, unit tests, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will analyze the most important tools of this feature. Let's
    start by seeing how we can find references in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Finding references in code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CodeLens is presented in our code files from the first time we use Visual Studio.
    We can check this by going to any class, method, or property and verifying that
    a sentence appears, indicating the number of references in the project about it.
    In *Figure 7.2*, we can see that we have opened the `WeatherForecastController.cs`
    file, which shows us that three references have been found for the `WeatherForecastController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – References for the WeatherForecastController class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.02_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – References for the WeatherForecastController class
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the `WeatherForecastController` class is being used in three
    places in our project. If we proceed by clicking on the legend titled `WeatherForecastController`
    class – specifically in the **14** and **16** lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The location in the code of the references in the WeatherForecastController
    class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.03_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – The location in the code of the references in the WeatherForecastController
    class
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only that, but we can also position over on any of the lines found, which
    will show us a section of the four closest lines of code surrounding the reference.
    This way, we can get a better idea of the purpose of using it, as shown in *Figure
    7.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – A preview of a found code reference'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.4_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – A preview of a found code reference
  prefs: []
  type: TYPE_NORMAL
- en: This is quite useful if we are in a new project and need to quickly know what
    certain parts of the code do.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see a utility belonging to CodeLens that will allow you to see relationships
    between code visually.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, even if the number of references equals zero, there may be references
    to other GUI files, such as `.xaml` and `.aspx` files.
  prefs: []
  type: TYPE_NORMAL
- en: Code maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code maps are a way to visualize relationships in code in a fast and efficient
    way. This tool allows the creation, as its name indicates, of visual maps from
    the code. With this tool, we will be able to see the structure of the entities,
    their different properties, and relationships, which lets us know how much impact
    a change we make can have.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to create code maps. The first one is by selecting the
    option `.dgml` extension, in which we will be instructed to drag files from the
    solution explorer, class view, or object browser, as shown in *Figure 7.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The empty code map file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.05_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – The empty code map file
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a test – click on the `SPAProject.Controllers` namespace. This will
    show you the `WeatherForecastController` class, as shown in *Figure 7.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – A visualization of the WeatherForecastController class, about
    to be dragged into the code map file](img/Figure_7.06_B17873.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – A visualization of the WeatherForecastController class, about to
    be dragged into the code map file
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, drag the `WeatherForecastController` class into the code map file. This
    will automatically generate a graph where we can see the dragged `class`, `namespace`
    that contains it, and finally, `.dll` in which it is hosted, as shown in *Figure
    7.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – The WeatherForecastController class in the code map'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.07_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – The WeatherForecastController class in the code map
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if we expand the `WeatherForecastController` class in the diagram,
    we will see the members that are part of the class, such as its attributes and
    behavior, as well as the relationships that can be found as part of the same class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – The relationships found through the code map'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.08_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – The relationships found through the code map
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7.8*, we can see in action a code map of the `WeatherForecastController`
    class with all its members expanded. This shows us quickly how the fields, properties,
    and methods are related.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to create a map code from the source code is to go to the file
    where the member we are interested in is located, such as the `WeatherForecast.cs`
    file. Once we have opened the file, we can position the cursor on a class, method,
    property, or field and right-click, which will show us the **Code Map** | **Show
    on Code Map** option, as shown in *Figure 7.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – The option to add a class to a code map from the context menu
    of a class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.09_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – The option to add a class to a code map from the context menu of
    a class
  prefs: []
  type: TYPE_NORMAL
- en: This option will create a new `.dgml` file or, if you have already created one,
    as in our case, add the reference with its respective relations in the previously
    opened file.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to center the code map diagram, at any time you can click on any
    empty area of the diagram to center it. Likewise, if you double-click on any of
    the entities or members of the diagram, the corresponding code will open to view
    it next to the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result of adding the new class to the diagram, we can see that the `WeatherForecast`
    class is being used in the `Get` method of the `WeatherForecastController` class,
    as shown in *Figure 7.10*. This way, we have discovered this relationship very
    easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – The relationships between classes by code map'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – The relationships between classes by code map
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The arrows indicating relationships between entities in the code map diagram
    appear and disappear as entities are selected, allowing more space and understanding
    of the diagram. I encourage you to select each of the elements in the diagram
    so that you can see the complete relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if we want to be able to see the relationships in our solution without
    having to add entity by entity, from the **Architecture** menu, we can select
    the **Generate Code Map for Solution** option, as we can see in *Figure 7.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – The option in the menu to generate a code map at a solution
    level'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – The option in the menu to generate a code map at a solution level
  prefs: []
  type: TYPE_NORMAL
- en: This will start the process of generating the respective code map for the entire
    solution. Depending on the number of references in your code, the process may
    take more or less time.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Although code maps can only be created in Visual Studio Enterprise Edition,
    it is possible to view them from any version of Visual Studio, including the Community
    version, but it is not possible to edit them from any version except the Enterprise
    Edition.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how CodeLens can help us understand our code better and
    faster, let's look at the windows available in Visual Studio, which will allow
    us to work with our code easily.
  prefs: []
  type: TYPE_NORMAL
- en: Working with code views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to CodeLens, there are several windows that can help us to examine
    the classes of a project and its members in a quicker way. In this section, you
    are going to learn about them and how they can help you in breaking down code
    of a project in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Class view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The class view is a window that allows you to see the elements of a Visual Studio
    project, such as namespaces, types, interfaces, enumerations, and classes, allowing
    you to access each of these elements quickly. Perhaps if you have worked with
    small projects in Visual Studio, you might not see it as being of much use. But
    if, like me, you work with solutions that can have up to 20 projects or more,
    then it is an excellent option to examine code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access this window, you must select the **View** | **Class View** option
    from the menu, which will display the **Class View** window, showing all the elements
    of the solution that is currently open, as shown in *Figure 7.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – The Class View window with a loaded project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.12_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – The Class View window with a loaded project
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we can get a very quick idea of the structure of our project
    by seeing at a glance the namespaces into which the project has been divided.
    If we expand the nodes of each of the namespaces, we can also see the different
    classes that are part of these namespaces, as shown in *Figure 7.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – The Class View window displaying the members of the WeatherForecastController
    class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.13_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.13 – The Class View window displaying the members of the WeatherForecastController
    class
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if we select any element of our project, such as a class, we will
    be able to see the properties and methods that compose it in the lower part of
    the window (as shown in *Figure 7.13*).
  prefs: []
  type: TYPE_NORMAL
- en: Another great advantage of this window is that you don't even have to recompile
    the project to see the changes, as they will be made automatically and instantly.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the window in *Figure 7.13*, we can also see a series of buttons
    that we can use to create new folders, navigate between the selected elements,
    configure the display options, and possibly add a class to a code map file.
  prefs: []
  type: TYPE_NORMAL
- en: It is certainly an excellent window to navigate between the classes of our project,
    but what if we want to navigate between classes that are not part of our project?
    In this case, the object browser can help us, which we will examine next.
  prefs: []
  type: TYPE_NORMAL
- en: The object browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The object browser is a very useful window that has been present since the beginning
    of Visual Studio. This window contains information about all the assemblies that
    are used in your project and allows you to examine them in depth. To access this
    window, we can do it from the **View** | **Object Browser** menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we select the **Object Browser** option, it will open and load the assemblies
    that are used as part of our solution. We can see that the list of assemblies
    is quite long, and this is because we can examine assemblies that are part of
    the framework we are using and also the assemblies that we have created ourselves,
    as shown in *Figure 7.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – The Object Browser window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.14_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.14 – The Object Browser window
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 7.15*, at the top there is a filter, which we can deploy
    to choose which framework or set of libraries we want to examine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Displaying the object browser options to navigate between the
    different classes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.15_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.15 – Displaying the object browser options to navigate between the
    different classes
  prefs: []
  type: TYPE_NORMAL
- en: This list (in the preceding screenshot) will vary, according to the workloads
    picked in the Visual Studio installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also have a powerful search engine available, in which you can enter
    a search term, and it will return all possible matches, including any type of
    data that has been found, as shown in *Figure 7.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Performing a search in the object browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.16_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.16 – Performing a search in the object browser
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if you select any item from the list, you will see a second list on
    the right panel, as shown in *Figure 7.17*, which will contain all the members
    of the selected type, such as their methods, properties, structures, enumerations,
    among other available types, and at the bottom, a description of the selected
    member:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Showing the members of a class in the object browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.17_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.17 – Showing the members of a class in the object browser
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this window is quite helpful, not only to see members of your
    own project but also of the whole framework in general.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at a new feature called IntelliCode, which will allow us to
    write code more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual IntelliCode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IntelliCode is the tool integrated into Visual Studio 2022, which allows you
    to write code faster, thanks to artificial intelligence. It is a tool that has
    been trained with thousands of popular open source projects hosted on GitHub,
    and although it was already beginning to show a little of its potential in Visual
    Studio 2019, it is in this version where all the features have been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'IntelliCode can suggest patterns and styles while you write code, giving you
    accurate suggestions according to the context in which you find yourself, so you
    can complete lines of code. IntelliCode is also able to show you the methods and
    properties you are most likely to use and supports completion in multiple programming
    languages, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Basic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's examine how this amazing tool works in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Whole line completions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IntelliCode can be extremely useful in helping you complete entire lines of
    code. Best of all, code predictions are displayed according to different entries
    in your code, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntelliSense options used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries used in the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two ways to receive entire line completion hints in Visual Studio
    2022:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is given automatically while you are writing code. In *Figure
    7.18*, we can see this in action, as we start writing a new property in the `WeatherForecast.cs`
    file of type `string`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.18 – IntelliCode suggesting a full line completion'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.18_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.18 – IntelliCode suggesting a full line completion
  prefs: []
  type: TYPE_NORMAL
- en: According to everything learned by the IntelliCode model, it suggests a new
    property called `Description`, which we can accept by pressing the *tab* key or
    reject by continuing to write code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method of line completion through the use of IntelliCode is by selecting
    an item from the IntelliSense suggestion list. For example, if we create a constructor
    for the `WeatherForecast` class and type the letter `S`, a list of IntelliSense
    suggestions will appear. We can scroll through each of them, and in most cases,
    IntelliCode will show us auto-completion suggestions, as shown in *Figure 7.19*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.19 – IntelliCode recommending the completion of an IntelliSense
    element'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.19_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.19 – IntelliCode recommending the completion of an IntelliSense element
  prefs: []
  type: TYPE_NORMAL
- en: We can accept the line by pressing the *tab* key twice or continue writing code
    to ignore the suggestion.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the two methods of full line completion, let's see how
    IntelliCode can help us write code based on its suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: IntelliCode suggestions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IntelliCode suggestions are an assisted way to carry out similar code edits
    in our projects. Basically, IntelliCode keeps track of code we are writing, and
    if it detects code repetition that could be applied to our code, it will let us
    know through suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: A surprising thing about IntelliCode is that it is based on the semantic structure
    of code, so it can also help us to detect changes that we might have missed, such
    as changes in formulas.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we have some methods that allow us to calculate some static
    values, such as the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the calculation follows the same structure, and the only thing
    that changes is the value of the `minValue` variable, so we decide to create a
    new method called `Calculate`, which will perform the same operation by receiving
    a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Subsequently, we decided to replace code of the `Calculate1` method to invoke
    the newly created `Calculate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go to the `Calculate2` method and start typing the name of the `Calculate`
    method, an IntelliCode hint will appear, as shown in *Figure 7.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – IntelliCode suggesting an implementation of the code repetition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.20_B17873.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.20 – IntelliCode suggesting an implementation of the code repetition
  prefs: []
  type: TYPE_NORMAL
- en: The suggestion made by IntelliCode tells us that we can apply the same invocation
    to the new method, which we can apply by pressing the *tab* key, or we can ignore
    the suggestion and continue writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to note that IntelliCode suggestions are only available
    during the development session. This means that if you restart Visual Studio,
    the previous hints will not appear again.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw, IntelliCode provides a way to write code much faster through suggestions,
    which can save you several minutes a day.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio contains a set of tools and windows that can help us a lot while
    we are developing our projects.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how CodeLens can help us find references and relationships, both
    through code and visually. Likewise, we have studied the different code windows
    that help to examine class members in projects. Finally, we have seen how IntelliCode
    is a new addition to the IDE, which through artificial intelligence helps us to
    write code quickly through various suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B17873_08_ePub.xhtml#_idTextAnchor100), *Web Tools and Hot
    Reload*, we will see several tools focused on web development for the development
    of web applications, and a new functionality included in Visual Studio 2022 that
    helps us to reload a web project after making a change.
  prefs: []
  type: TYPE_NORMAL
