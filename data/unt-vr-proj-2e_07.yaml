- en: Locomotion and Comfort
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动和舒适度
- en: Up to this point in this book, the player's point-of-view camera has been stationary.
    In this chapter, we'll start to move around as we consider various techniques
    for locomotion and teleportation. First, we'll dig deeper into the Unity standard
    character components, and then we move ourselves into a controllable first-person
    character and explore techniques to move around in the virtual world. We'll also
    discuss practices for managing motion sickness and sense of self within VR.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中玩家的视角摄像头一直是静止的。在本章中，我们将开始移动，考虑各种移动和传送技术。首先，我们将深入了解Unity标准角色组件，然后我们将自己变成一个可控制的第一人称角色，并探索在虚拟世界中移动的技术。我们还将讨论管理VR中的运动病感和自我意识的方法。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Unity's character objects and components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity的角色对象和组件
- en: Glide locomotion
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑行移动
- en: Comfort mode locomotion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 舒适模式移动
- en: Teleportation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传送
- en: Issues around VR motion sickness
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VR运动病问题
- en: Note that the projects in this chapter are separate and not directly required
    by the other chapters in this book. If you decide to skip any of it or not save
    your work, that's OK.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中的项目是独立的，并不直接需要本书其他章节。如果你决定跳过其中任何部分或未保存你的工作，那没有问题。
- en: Understanding Unity characters
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Unity角色
- en: A first-person character is such a key asset in a VR project that we really
    should understand its components inside out. So, before we go about building one
    for our project, it would be a good idea to take a close look at the built-in
    components and standard assets that Unity provides.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第一人称角色在VR项目中是一个关键资产，我们真的应该彻底了解其组件。因此，在我们为项目构建一个角色之前，仔细查看Unity提供的内置组件和标准资产是个好主意。
- en: Unity components
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity组件
- en: As you probably know, each Unity game object contains a set of associated **components**.
    Unity includes many types of built-in components, which you can see by browsing
    the Component menu in the main menu bar. Each component adds properties and behaviors
    to the object that it belongs to. A component's properties are accessible via
    the Unity editor's Inspector panel and scripts. A script attached to a game object
    is also a type of a component and may have properties that you can set in the
    Inspector panel.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，每个Unity游戏对象都包含一组相关联的**组件**。Unity包含许多内置组件类型，你可以在主菜单栏中的组件菜单中浏览它们。每个组件都会为其所属对象添加属性和行为。组件的属性可以通过Unity编辑器的检查器面板和脚本访问。附加到游戏对象上的脚本也是一种组件，你可以在检查器面板中设置其属性。
- en: The component types used to implement first-person characters include the **Camera**,
    **Character Controller**, and/or **Rigidbody**, and various scripts. Let's review
    each of these standard components.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 用于实现第一人称角色的组件类型包括**摄像头**、**角色控制器**和/或**刚体**，以及各种脚本。让我们回顾一下这些标准组件。
- en: The Camera component
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像头组件
- en: The Camera component specifies the viewing parameters that are used to render
    the scene on each frame update. Any object with a Camera component is considered
    a `camera` object. Naturally, we've been using a camera in our scenes since we
    started, and we've been accessing it in the scripts that we've written.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头组件指定了用于在每一帧更新时渲染场景的视图参数。任何具有摄像头组件的对象都被视为一个`摄像头`对象。自然地，自从我们开始使用场景以来，我们一直在脚本中访问它。
- en: A stereographic VR camera object renders two views, one for each eye. In VR,
    the camera controller scripts read data from the headset's motion sensors and
    positional tracking to determine the current head pose (position, direction, and
    rotation) and set the camera's transform appropriately.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 立体声VR摄像头对象渲染两个视图，每个眼睛一个。在VR中，摄像头控制器脚本从头戴式设备的运动传感器和位置跟踪中读取数据，以确定当前的头姿（位置、方向和旋转）并适当地设置摄像机的变换。
- en: The Rigidbody component
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚体组件
- en: When you add a Rigidbody component to any Unity game object, it will benefit
    from the calculations that are performed by the **physics engine**. Rigidbody
    components have parameters for gravity, mass, and drag, among others. During gameplay,
    the physics engine calculates each rigid object's *momentum* (mass, speed, and
    direction).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将刚体组件添加到任何Unity游戏对象时，它将受益于**物理引擎**执行的运算。刚体组件具有重力、质量和阻力等参数。在游戏过程中，物理引擎计算每个刚体对象的*动量*（质量、速度和方向）。
- en: Rigid objects interact with other rigid objects. For example, if they collide,
    they'll bounce off each other and the parameters of the interaction can be controlled
    with a **physic material** with properties such as friction and bounciness factors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 刚性物体与其他刚性物体相互作用。例如，如果它们发生碰撞，它们会相互弹开，并且可以通过具有摩擦和弹跳系数等属性的**物理材质**来控制交互参数。
- en: Rigidbodies can be flagged as *kinematic*, which is usually only used when the
    object is driven by animation or scripts. Collisions will not affect kinematic
    objects, but they will still affect the motion of other rigidbodies. It's mostly
    used when objects are chained together with *joints*, like the ones connecting
    a humanoid's bones or a swinging pendulum.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Rigidbodies可以被标记为**运动学**，这通常只在对象由动画或脚本驱动时使用。碰撞不会影响运动学对象，但它们仍然会影响其他刚性物体的运动。它主要用于将对象通过**关节**连接在一起，例如连接人类骨骼或摆动的摆锤。
- en: Any rigid object, given a child camera object, becomes a rigid first-person
    character. Then, you can add scripts to handle user input to move, jump, look
    around, and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 任何刚性物体，一旦赋予子相机对象，就变成了一个刚性的第一人称角色。然后，你可以添加脚本以处理用户输入，实现移动、跳跃、环顾四周等功能。
- en: The Character Controller component
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Character Controller组件
- en: Like a Rigidbody, the **Character Controller** (**CC**) is used for *collision
    detection* and c*haracter movement*. It needs scripts to handle the user input
    to move, jump, and look around, too. However, it doesn't automatically have the
    physics built in.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与Rigidbody一样，**Character Controller**（**CC**）用于**碰撞检测**和**角色移动**。它也需要脚本来处理用户输入以实现移动、跳跃和环顾四周。然而，它并没有内置物理特性。
- en: The CC component is specifically designed for character objects because characters
    in a game often are not really expected to behave the same as other physics-based
    objects. It can be used instead of, or in addition to, a Rigidbody.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CC组件专门为角色对象设计，因为在游戏中，角色通常并不期望与其他基于物理的对象表现出相同的动作。它可以替代Rigidbody，或者与Rigidbody一起使用。
- en: The CC component has a built-in **Capsule Collider** behavior to detect collisions.
    However, it doesn't automatically use the physics engine to *respond* to the collision.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CC组件内置了**胶囊碰撞器**行为以检测碰撞。然而，它不会自动使用物理引擎来**响应**碰撞。
- en: For example, if a CC object hits a rigid object such as a wall, it will just
    stop. It won't bounce. If a rigid object, such as a flying brick, hits a CC object,
    the brick will get deflected (bounce) based on its own properties, but the CC
    object will not be affected. Of course, if you want to include behavior like this
    on the CC object, you can program that in your own scripts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个CC对象撞击到一个刚性物体，如墙壁，它将只是停止，而不会弹跳。如果一个刚性物体，如飞行的砖块，撞击到一个CC对象，砖块将根据其自身属性被弹开（弹跳），但CC对象将不受影响。当然，如果你想在CC对象上包含这种行为，你可以在自己的脚本中编程实现。
- en: The CC component does have an especially good support for one force in its scripting
    API-*gravity*. Built-in parameters are specifically related to keeping the object's
    feet on the ground. For example, the Step Offset parameter defines how tall a
    step the character can hop onto rather than being an obstacle that blocks his
    way. Similarly, the Slope Limit parameter says how big an incline is too steep
    and whether it should be treated like a wall. In your scripts, you can use the
    `Move()` method and the `IsGrounded` variable to implement character behavior.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CC组件在其脚本API中特别支持一种力——**重力**。内置参数专门与保持对象脚部在地面上有关。例如，步进偏移参数定义了角色可以跳上的步子的高度，而不是成为阻碍其前进的障碍物。同样，斜率限制参数说明了多大的斜率是过于陡峭的，以及它是否应该被视为墙壁。在你的脚本中，你可以使用`Move()`方法和`IsGrounded`变量来实现角色行为。
- en: Unless you script it, a CC object has no momentum and can stop on a dime. It
    feels very precise, but this could also lead to a jerky movement. The opposite
    is true for Rigidbody objects, which feel more fluid because they have momentum,
    acceleration/deceleration, and obey the laws of physics. In VR, we'd ideally like
    some combination of the two, if we use it at all.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你编写脚本，否则CC对象没有动量，可以立即停止。这感觉非常精确，但也可能导致动作生硬。而对于Rigidbody对象来说，情况正好相反，它们感觉更流畅，因为它们具有动量、加速度/减速度，并遵循物理定律。在VR中，如果我们使用它的话，我们理想情况下希望两者结合。
- en: Using physics to move yourself through a VR scene is not always best. As we'll
    see, alternative locomotion techniques may not use physics at all, such as *teleportation*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用物理在VR场景中移动并不总是最佳选择。正如我们将看到的，替代的移动技术可能根本不使用物理，例如**传送**。
- en: Unity Standard Assets
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity标准资产
- en: 'The Characters package in Unity Standard Assets comes with a number of third-
    and first-person character prefab objects. These prefab objects are compared in
    the following table:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 标准资产中的 Characters 包含了许多第三人称和第一人称角色预制件。以下表格中比较了这些预制件：
- en: '| Prefab | Components |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 预制件 | 组件 |'
- en: '| ![](img/d0940b8a-38a4-4b13-969a-4b1b5cac138b.png) | ![](img/a8740890-7967-42fd-af07-5609c393eac4.png)
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](img/d0940b8a-38a4-4b13-969a-4b1b5cac138b.png) | ![图片](img/a8740890-7967-42fd-af07-5609c393eac4.png)
    |'
- en: '| ![](img/490989ab-841b-495a-9204-5646b413ac21.png) | ![](img/1032403f-6ec8-4c8b-b24f-aa129728c7a5.png)
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](img/490989ab-841b-495a-9204-5646b413ac21.png) | ![图片](img/1032403f-6ec8-4c8b-b24f-aa129728c7a5.png)
    |'
- en: '| ![](img/bfab0187-3824-4c3b-a5f7-a48911127869.png) | ![](img/85e9a57d-f56a-445a-889c-a68517db4061.png)
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](img/bfab0187-3824-4c3b-a5f7-a48911127869.png) | ![图片](img/85e9a57d-f56a-445a-889c-a68517db4061.png)
    |'
- en: '| ![](img/44832510-485f-43ea-a8e5-6752cd33d34f.png) | ![](img/569cf22a-f936-4118-aa06-9b2b11755af7.png)
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](img/44832510-485f-43ea-a8e5-6752cd33d34f.png) | ![图片](img/569cf22a-f936-4118-aa06-9b2b11755af7.png)
    |'
- en: Let's discuss this in more detail.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论这个问题。
- en: ThirdPersonController
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ThirdPersonController
- en: We've already used both of the third-person prefabs, `ThirdPersonController`
    and `AIThirdPersonController`, in [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml),
    *Content, Objects, and Scale*, and [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml),
    *Gaze-Based Control*, respectively.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第二章 [内容、对象和缩放](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml) 和第四章 [基于注视的控制](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml)
    中分别使用了这两个第三人称预制件，`ThirdPersonController` 和 `AIThirdPersonController`。
- en: The `ThirdPersonController` prefab has child objects that define the character's
    body, namely our friend Ethan. He is a rigged avatar (from the `.fbx` file), which
    means that humanoid animations can be applied to make him walk, run, jump, and
    so on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThirdPersonController` 预制件有子对象定义角色的身体，即我们的朋友伊森。他是一个绑定了骨骼的化身（来自 `.fbx` 文件），这意味着可以应用类人动画使他行走、奔跑、跳跃等。'
- en: The `ThirdPersonController` prefab uses a Rigidbody for physics and Capsule
    Collider for collision detection.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThirdPersonController` 预制件使用 Rigidbody 进行物理运算，并使用 Capsule Collider 进行碰撞检测。'
- en: It has two scripts. A `ThirdPersonUserControl` script takes user input, such
    as thumbstick presses, and tells the character to move, jump, and so on. A `ThirdPersonCharacter`
    script implements physics movements and calls the animations that are needed for
    running, crouching, and so on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个脚本。一个 `ThirdPersonUserControl` 脚本接收用户输入，例如摇杆按下，并告诉角色移动、跳跃等。一个 `ThirdPersonCharacter`
    脚本实现物理运动并调用所需的动画，例如跑步、蹲下等。
- en: AIThirdPersonController
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AIThirdPersonController
- en: The `AIThirdPersonController` prefab is identical to the `ThirdPersonController`
    prefab, but the former adds a `NavMeshAgent` and an `AICharacterControl` script,
    which constrains where and how the character can move around the scene. If you
    recall, in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based
    Control*, we used the `AICharacterController` to make Ethan walk around the scene
    and avoid bumping into objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`AIThirdPersonController` 预制件与 `ThirdPersonController` 预制件相同，但前者添加了 `NavMeshAgent`
    和 `AICharacterControl` 脚本，这限制了角色在场景中的移动位置和方式。如果您还记得，在第四章 [基于注视的控制](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml)
    中，我们使用了 `AICharacterController` 使伊森在场景中行走并避免碰撞到物体。'
- en: First-person FPSController
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一人称 FPSController
- en: The `FPSController` prefab is a first-person controller that uses both a CC
    component and a Rigidbody. It has a child camera attached to it. When the character
    moves, the camera moves with it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`FPSController` 预制件是一个第一人称控制器，它使用 CC 组件和 Rigidbody。它附有一个子相机。当角色移动时，相机也会随之移动。'
- en: The core distinction between third-person controller prefabs and first-person
    controller prefabs is the **child object**. Third-person controller prefabs have
    a rigged humanoid child object, while first-person controller prefabs have a camera
    child object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第三人称控制器预制件和第一人称控制器预制件之间的核心区别是 **子对象**。第三人称控制器预制件有一个绑定了骨骼的类人子对象，而第一人称控制器预制件有一个子相机对象。
- en: Its body mass is set to a low value (`1`) and `IsKinematic` is enabled. This
    means that it will have limited momentum and does not react to other rigid objects,
    but it can be driven by animations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它的身体质量设置为低值（`1`），并且启用了 `IsKinematic`。这意味着它将具有有限的动量，不会对其他刚体对象做出反应，但它可以被动画驱动。
- en: Its `FirstPersonController` script offers a plethora of parameters for running,
    jumping, audio footsteps, and more. The script also includes parameters and animations
    for a *head bob*, which bounces the camera in a natural way when the character
    is moving. If you use the `FPSController` script in your VR project, *be sure
    to disable any head bob features* or you might need to clean the puke off your
    keyboard!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它的 `FirstPersonController` 脚本提供了大量参数，用于跑步、跳跃、音频脚步声等。脚本还包括用于 *头部晃动* 的参数和动画，当角色移动时，相机会以自然的方式弹跳。如果你在你的
    VR 项目中使用 `FPSController` 脚本，**务必禁用任何头部晃动功能*，否则你可能需要清理键盘上的呕吐物！
- en: RigidBodyFPSController
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RigidBodyFPSController
- en: The `RigidBodyFPSController` prefab is a first-person controller with a Rigidbody
    but no CC component. Like `FPSController`, it has a child camera object. When
    the character moves, the camera moves with it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`RigidBodyFPSController` 预制体是一个带有 Rigidbody 但没有 CC 组件的第一人称控制器。像 `FPSController`
    一样，它有一个子相机对象。当角色移动时，相机也会随之移动。'
- en: A `RigidBodyFPSController` prefab's body mass is more substantial, set to 10,
    and is not kinematic. That is, it *can* get bounced around when it collides with
    other objects. It has a separate Capsule Collider component with the `ZeroFriction`
    physic material. The `RigidBodyFirstPersonController` script is different from
    the `FPSController` one, but the former has a lot of similar parameters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`RigidBodyFPSController` 预制体的质量更重，设置为 10，并且是非运动学（kinematic）的。这意味着当它与其它物体碰撞时，它**可以**被弹来弹去。它有一个独立的胶囊碰撞器组件，并使用
    `ZeroFriction` 物理材质。`RigidBodyFirstPersonController` 脚本与 `FPSController` 脚本不同，但前者有很多相似的参数。'
- en: '**Why am I going through all of this detail here?** If you''ve built any non-VR
    projects in Unity, then you''ve most likely used these prefabs. However, you might
    not have paid much attention to how they''re assembled. Virtual reality is experienced
    from the first-person perspective. Our implementation toolbox is Unity. It is
    important to understand Unity''s tools that manage and control this first-person
    experience.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么我要在这里详细说明这些内容？** 如果你曾在 Unity 中构建过任何非 VR 项目，那么你很可能使用过这些预制体。然而，你可能没有太多关注它们是如何组装的。虚拟现实是从第一人称视角体验的。我们的实现工具箱是
    Unity。理解 Unity 中管理和控制这种第一人称体验的工具非常重要。'
- en: Using glide locomotion
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用滑行运动
- en: For our locomotion features in this chapter, let's take an *agile* approach
    to development. This means (in part) that we'll start by defining our new feature,
    or story, with a set of requirements. Then, we'll incrementally build and test
    this feature, one requirement at a time, by iterating and refining our work as
    we go along. Experimentation is not only allowed, it's encouraged.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的运动功能，让我们采取一种 *敏捷* 的开发方法。这意味着（部分）我们将首先定义我们的新功能或故事，并附带一系列需求。然后，我们将通过迭代和细化我们的工作，逐步构建和测试这个功能，一次处理一个需求。实验不仅被允许，而且被鼓励。
- en: '**Agile software development** is a broad term for methodologies that encourage
    small incremental and iterative development in a fashion that''s easy to respond
    to changing and refined requirements. See the Agile Manifesto at [http://agilemanifesto.org/](http://agilemanifesto.org/).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**敏捷软件开发** 是一个广泛的术语，指的是那些鼓励以易于应对变化和细化需求的方式，进行小幅度增量迭代开发的方法。请参阅 [敏捷宣言](http://agilemanifesto.org/)。'
- en: 'The feature we want to implement is this: as a first-person character, when
    I start walking, I will move through the scene in the direction I am looking until
    I indicate to stop walking. Here are the requirements to achieve this feature:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要实现的功能是：作为一个第一人称角色，当我开始行走时，我将朝着我注视的方向在场景中移动，直到我指示停止行走。以下是实现此功能的需求：
- en: Move in the direction you're looking
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向你注视的方向移动
- en: Keep your feet on the ground
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请将双脚稳稳地放在地上
- en: Don't pass through solid objects
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要穿过固体物体
- en: Don't fall off the edge of the world
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要从世界的边缘掉下去
- en: Step over small objects and handle uneven terrain
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨过小物体并处理不平坦的地形
- en: Start and stop moving by clicking an input button
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击输入按钮开始和停止移动
- en: This sounds reasonable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来是合理的。
- en: To begin, if you have a saved version of the scene from [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml),
    *Gaze-Based Control*, you can start with that. Or, build a similar simple new
    scene containing a ground plane, some 3D objects as obstacles, and a copy of your
    `MeMyselfEye` prefab.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你有从 [第 4 章](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml) “基于注视的控制” 保存的场景版本，你可以从那里开始。或者，构建一个类似的简单新场景，包含地面平面、一些作为障碍物的
    3D 对象，以及你的 `MeMyselfEye` 预制体的副本。
- en: Move in the direction you're looking
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向你注视的方向移动
- en: 'We already have a `MeMyselfEye` object containing the camera rig. We''re going
    to turn it into a first-person controller. Our first requirement is to move about
    the scene in the direction you''re looking. Add a script named `GlideLocomotion`.
    Keeping it simple, let''s start by performing the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个包含相机装置的 `MeMyselfEye` 对象。我们将将其转换为一个第一人称控制器。我们的第一个要求是在你注视的方向上移动场景。添加一个名为
    `GlideLocomotion` 的脚本。保持简单，让我们先执行以下步骤：
- en: Select the `MeMyselfEye` object in the Hierarchy panel
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构面板中选择 `MeMyselfEye` 对象
- en: In the Inspector panel, select Add Component | New Script and name it `GlideLocomotion`
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器面板中，选择添加组件 | 新脚本，并将其命名为 `GlideLocomotion`
- en: 'Then, open the script and code it, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开脚本并按照以下方式编写代码：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The normal walking speed for humans is about 1.4 meters per second. In VR, that
    could make you feel sick. Let's travel a lot slower than that, at 0.4 m/s. During
    `Update()`, we check the current direction in which the player is looking (`camera.transform.forward`)
    and move the `MeMyselfEye` transform position in this direction at the current
    velocity.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 人类正常的行走速度大约是每秒1.4米。在VR中，这可能会让你感到恶心。让我们以比这慢得多，0.4 m/s 的速度移动。在 `Update()` 中，我们检查玩家当前注视的方向（`camera.transform.forward`）并以此方向和当前速度移动
    `MeMyselfEye` 的变换位置。
- en: 'Note the coding shortcuts for the self-modification of a variable (`*=` and
    `+=`). The last two lines of the preceding code could have been written out like
    this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意变量自我修改的编码快捷键（`*=` 和 `+=`）。前述代码的最后两行可以写成如下：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, I used the `*=` and `+=` operators instead. Save the script and the scene
    and try it in VR.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了 `*=` 和 `+=` 运算符。保存脚本和场景，并在VR中尝试。
- en: When you look forward, you move forward. Look left, move left. Look right, move
    right. It works!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向前看时，你就向前移动。向左看，就向左移动。向右看，就向右移动。它工作得很好！
- en: Look up... *Whoa!! Did you expect that?! We're freakin' flying!* You can move
    up, down, and all around as if you're Superman or piloting a drone. Presently,
    `MeMyselfEye` has no mass and physics and does not respond to gravity. Nonetheless,
    it meets our requirement to move in the direction you're looking. So, let's continue.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 向上看... *哇！！你期待这个吗？！我们简直在飞!* 你可以向上、向下以及全方位移动，就像超人或者操控无人机一样。目前，`MeMyselfEye` 没有质量，没有物理属性，也不受重力影响。尽管如此，它满足了你在注视的方向上移动的要求。所以，让我们继续。
- en: Keep your feet on the ground
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持脚在地面
- en: 'The next requirement wants you to keep your feet on the ground. We know that
    `GroundPlane` is flat and positioned at Y = `0`. So, let''s just add this simple
    constraint to the `GlideLocomotion` script, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要求是让你保持脚在地面。我们知道 `GroundPlane` 是平的，位置在 Y = `0`。所以，让我们只给 `GlideLocomotion`
    脚本添加这个简单的约束，如下所示：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the script and try it in VR.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并在VR中尝试。
- en: Not bad. Now, we can move around the Y = `0` plane.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错。现在，我们可以在 Y = `0` 平面上移动。
- en: On the other hand, you're like a ghost, readily passing through the cube, sphere,
    and the other objects.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你就像一个鬼魂，可以轻易地穿过立方体、球体和其他物体。
- en: Don't pass through solid objects
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要穿过固体物体
- en: 'The third requirement states *don''t pass through solid objects*. Here''s an
    idea. Give it a Rigidbody component, a collider, and let the physics engine take
    care of it. Follow these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第三项要求是*不要穿过固体物体*。这里有一个想法。给它添加一个刚体组件、一个碰撞体，让物理引擎来处理。按照以下步骤操作：
- en: Select the `MeMyselfEye` object in the Hierarchy panel
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构面板中选择 `MeMyselfEye` 对象
- en: In the Inspector panel, navigate to Add Component | Physics | Rigidbody
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器面板中，导航到添加组件 | 物理 | 刚体
- en: Then Add Component | Physics | Capsule Collider
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加组件 | 物理 | 胶囊碰撞体
- en: Set the Capsule Collider Height to 2
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将胶囊碰撞体高度设置为 2
- en: If your Character Controller's capsule collider (green mesh in the Scene window)
    extends through the ground plane, adjusts its Center Y to `1`
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的角色控制器胶囊碰撞体（场景窗口中的绿色网格）延伸到地面平面，请调整其 Center Y 到 `1`
- en: Try it in VR.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中尝试。
- en: '*Whoa!! What the...?* It was going fine there for a second, but as soon as
    you knock into the cube, you go spinning out of control in wild directions, like
    a spacewalk gone bad in the movie *Gravity*. Well, that''s a Rigidbody for you.
    Forces are being applied in all directions and axes. Let''s add some constraints
    as follows.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*哇！！这是怎么了...？* 它刚才还一切正常，但一碰到立方体，你就失去了控制，像电影 *重力* 中糟糕的太空行走一样在各个方向上旋转。嗯，这就是刚体的作用。力被应用到所有方向和轴上。让我们添加以下约束。'
- en: 'In the Inspector panel''s Rigidbody pane, check off the checkboxes for Freeze
    Position: Y and Freeze Rotation: X and Z.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器面板的Rigidbody面板中，勾选冻结位置：Y和冻结旋转：X和Z的复选框。
- en: Try it in VR.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中尝试。
- en: Now that's pretty nice! You're able to move by looking in a direction, you're
    not flying (Y position constrained), and you don't pass through solid objects.
    Instead, you slide past them since only the Y rotation is allowed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真是太好了！你能够通过看向某个方向来移动，你不会飞（Y位置受约束），而且你不会穿过固体物体。相反，你会在它们旁边滑行，因为只允许Y旋转。
- en: If your `KillTarget` script is still running (from [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml),
    *Content, Objects, and Scale*), you should be able to stare at Ethan until he
    explodes. Do it, make Ethan explode... *Whoa!* We just got blown out of here by
    the explosion, spinning out of control in wild directions again. Maybe we're just
    not ready for this powerful physics engine yet. We can probably address this in
    the scripting, but for the time being, let's abandon the Rigidbody idea. We'll
    come back to it in the next chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的`KillTarget`脚本仍在运行（来自[第2章](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml)，*内容、对象和缩放*），你应该能够盯着Ethan直到他爆炸。做吧，让Ethan爆炸...
    *哇!* 我们被爆炸冲击波吹出了这里，再次在疯狂的方向上失去控制。也许我们还没有准备好使用这个强大的物理引擎。我们可能在脚本中解决这个问题，但暂时让我们放弃Rigidbody的想法。我们将在下一章回到它。
- en: 'You may recall that CC includes a Capsule Collider and supports movement that
    is constrained by collisions. We''ll try that instead, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，CC包括胶囊碰撞体，并支持受碰撞约束的运动。我们将尝试使用它，如下所示：
- en: In the Inspector panel, click on the Rigidbody pane's *gear* icon and select
    Remove Component
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器面板中，点击Rigidbody面板的*齿轮*图标并选择移除组件
- en: Also, remove its Capsule Collider component
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，移除其胶囊碰撞体组件
- en: In the Inspector panel, navigate to Add Component | Physics | Character Controller
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器面板中，导航到添加组件 | 物理 | Character Controller
- en: If your Character Controller's capsule collider (green mesh in the Scene window)
    extends through the ground plane, adjusts its Center Y to `1`
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的Character Controller的胶囊碰撞体（场景窗口中的绿色网格）延伸到地面平面，调整其中心Y到`1`
- en: 'Modify the `GlideLocomotion` script, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`GlideLocomotion`脚本，如下所示：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Instead of updating `transform.position` directly, we called the built-in `CharacterController.Move()`
    function and let it do it for us. It knows that the characters should behave with
    certain constraints.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代替直接更新`transform.position`，我们调用了内置的`CharacterController.Move()`函数，让它为我们完成。它知道角色应该以某些约束行为。
- en: Save the script and try it in VR.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并在VR中尝试。
- en: This time, when we bump into objects (a cube or sphere), we kind of go over
    it and then remain in the air. The `Move()` function does not apply gravity to
    the scene for us. We need to add that to the script, which isn't so hard (see
    the Unity API docs at [http://docs.unity3d.com/ScriptReference/CharacterController.Move.html](http://docs.unity3d.com/ScriptReference/CharacterController.Move.html)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们撞到物体（一个立方体或球体）时，我们有点翻过它，然后停留在空中。`Move()`函数不会为我们应用场景中的重力。我们需要在脚本中添加这一点，这并不难（参见Unity
    API文档[http://docs.unity3d.com/ScriptReference/CharacterController.Move.html](http://docs.unity3d.com/ScriptReference/CharacterController.Move.html))。
- en: 'However, there is a simpler way. The `CharacterController.SimpleMove()` function
    applies gravity to the move for us. Just replace the whole `Update()` function
    with the following one-liner:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个更简单的方法。`CharacterController.SimpleMove()`函数为我们应用重力。只需用以下单行替换整个`Update()`函数：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `SimpleMove()` function takes care of gravity and also handles `Time.deltaTime`.
    So, all that we need to give it is the movement direction vector. Also, since
    it's introducing gravity, we don't need the Y = `0` constraint either. Much simpler.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleMove()`函数负责处理重力和`Time.deltaTime`。所以，我们只需要给它一个移动方向向量。此外，由于它引入了重力，我们也不需要Y
    = `0`的约束。简单多了。'
- en: Save the script and try it in VR.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并在VR中尝试。
- en: Awesome! I think we've met all the requirements so far. *Just don't go walking
    off the edge...*
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我认为我们已经满足了所有的要求。*只是不要走得太远...*
- en: The exercises in this section assume you're using VR in seated or standing mode,
    not room-scale. We're modifying the whole MyMyselfEye rig as we move the player.
    In room-scale, that's moving the play area bounds as well. Since we're attaching
    the collider to the MyMyselfEye position, if you physically step away from the
    center of the play area, the collider will not be aligned with your actual body
    position. Later on, we will address issues of locomotion with room-scale VR.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的练习假设您正在使用坐姿或站立模式的VR，而不是房间规模。随着玩家移动，我们正在修改整个MyMyselfEye装置。在房间规模中，这意味着移动游戏区域边界。由于我们将碰撞器附加到MyMyselfEye位置，如果您从游戏区域中心物理移动，碰撞器将不会与您的实际身体位置对齐。稍后，我们将解决房间规模VR中的运动问题。
- en: Don't fall off the edge of the world
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要从世界边缘掉落
- en: Now that we have gravity, if we walk off the edge of the ground plane, you'll
    fall into oblivion. Fixing this isn't a first-person character thing. Just add
    some railings to the scene.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了重力，如果我们从地面平面的边缘走开，你会掉入虚无。解决这个问题并不是第一人称角色的事情。只需在场景中添加一些栏杆即可。
- en: 'Use cubes, scaling them to the desired thickness and length and moving them
    into position. Go ahead and do it. I won''t give you the step-by-step instructions
    for it. For example, I used these transforms:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用立方体，将它们缩放到所需的厚度和长度，并将它们移动到位置。去做吧。我不会给你一步一步的指导。例如，我使用了这些变换：
- en: 'Scale: `0.1`, `0.1`, `10.0`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比例：`0.1`，`0.1`，`10.0`
- en: 'Railing 1: Position: `-5`, `1`, `0`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栏杆1：位置：`-5`，`1`，`0`
- en: 'Railing 2: Position: `5`, `1`, `0`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栏杆2：位置：`5`，`1`，`0`
- en: 'Railing 3: Position: `0`, `1`, `-5`; Rotation: `0`, `90`, `0`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栏杆3：位置：`0`，`1`，`-5`；旋转：`0`，`90`，`0`
- en: 'Railing 4: Position: `0`, `1`, `5`; Rotation: `0`, `90`, `0`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栏杆4：位置：`0`，`1`，`5`；旋转：`0`，`90`，`0`
- en: Try it in VR. Try to walk through the railings. Whew! This is safer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中试试。尝试穿过栏杆。哇！这更安全。
- en: Stepping over small objects and handling uneven terrain
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨越小物体和处理不平坦地形
- en: 'While we''re at it, add a few things to walk on and over, such as a ramp and
    other obstacles. The result will look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们做到这一点时，添加一些可以走和跨越的东西，比如斜坡和其他障碍物。结果将看起来像这样：
- en: '![](img/216d0ee2-2f12-4c85-8a59-38ca4a4ea4ad.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/216d0ee2-2f12-4c85-8a59-38ca4a4ea4ad.png)'
- en: Try it in VR. Walk up the ramp and step off the cube. Hey, this is fun!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中试试。走上斜坡，然后从立方体上跳下来。嘿，这很有趣！
- en: The CC component is taking care of the requirement to step over small objects
    and handle uneven terrain. You might want to tinker with its Slope Limit and Step
    Offset settings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: CC组件正在处理跨越小物体和处理不平坦地形的要求。您可能想要调整其斜率限制和步偏移设置。
- en: '**Caution**: Glide locomotion can cause motion sickness, especially for players
    who are susceptible. Please use it with caution in your apps. This may become
    especially noticeable as you glide up the ramp and then jump off the block onto
    the ground plane. On the other hand, some people love rollercoaster VR! Also,
    giving the player control of the locomotion through a mechanic as simple as a
    button press can go a long way in helping reduce queasiness and motion sickness,
    which we''ll add next.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：滑行运动可能导致晕动症，特别是对于易感玩家。请在您的应用程序中谨慎使用。这可能会在您沿着斜坡滑行然后跳到地面平面上时变得特别明显。另一方面，有些人喜欢过山车VR！此外，通过简单的按钮按下机制让玩家控制运动，可以在很大程度上帮助减少恶心和晕动症，我们将在下一部分添加。'
- en: Starting and stopping movement
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始和停止运动
- en: The next requirement is *to start and stop moving by clicking an input button*.
    We'll look for a button press using the logical `"Fire1"` button. If you want
    to use a different button, or if you're targeting a platform that does not have
    a mapping to `"Fire1"` please refer to [Chapter 5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml),
    *Handy Interactables*, under the topic *Basic button input*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要求是*通过点击输入按钮来开始和停止移动*。我们将寻找使用逻辑`"Fire1"`按钮的按钮按下。如果您想使用不同的按钮，或者如果您正在针对没有`"Fire1"`映射的平台，请参阅第5章，*实用交互项*，在*基本按钮输入*主题下。
- en: 'Modify the `GlideLocomotion` script as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式修改`GlideLocomotion`脚本：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On Daydream, you may call `GvrControllerInput.ClickButtonDown` and `ClickButtonUp` instead.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Daydream上，您可以使用`GvrControllerInput.ClickButtonDown`和`ClickButtonUp`。
- en: By adding a Boolean `isWalking` flag, we can switch the forward movement on
    and off, which can be signaled by a key press.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加布尔`isWalking`标志，我们可以开关前进运动，这可以通过按键来信号。
- en: Adding comfort mode locomotion
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加舒适模式运动
- en: We have mentioned the potential of motion sickness several times already in
    this chapter, and earlier in this book. In general, the more control you give
    the player in moving around within VR the better off she'll be and reduce the
    risk of feeling queasy. Offering a button to start/stop motion is one step, as
    we just saw. Another is what's commonly referred to as *comfort mode*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章中多次提到运动病感的可能性，以及在这本书的早期。一般来说，你给予玩家在 VR 中移动的更多控制，她就会过得更好，并降低感到不适的风险。提供开始/停止运动的按钮是一步，正如我们刚才看到的。另一步是通常所说的
    *舒适模式*。
- en: It's been discovered that using glide locomotion around curves is worse that
    simply going in a straight line. So, one technique for getting around in a VR
    scene is only allow forward motion, regardless of which direction the player is
    looking, and then use the thumbstick to change direction. Also, rather than allow
    the thumbstick to change the direction angle continuously, we limit it to fixed
    angle steps of 30 degrees, for example. We'll add this to our `GlideLocomotion`
    script as follows.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 已经发现，在曲线周围使用滑动移动比简单地直线行走要差。因此，在 VR 场景中移动的一种技术是只允许向前移动，无论玩家朝哪个方向看，然后使用摇杆来改变方向。此外，我们限制摇杆连续改变方向角度，例如，将其限制为固定的
    30 度步长。我们将此添加到我们的 `GlideLocomotion` 脚本中，如下所示。
- en: 'At the top of the class, add the following variables:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的顶部添加以下变量：
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then in `Update()`, add the following statements:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `Update()` 函数中添加以下语句：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, when the `"Fire1"` button is pressed and `isWalking` is true, we move the
    `MeMyselfEye` forward in the direction indicated in its transform, rather than
    the `Camera` look directions, changing the line to `character.SimpleMove(transform.forward
    * velocity)`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当按下 `"Fire1"` 按钮且 `isWalking` 为真时，我们将 `MeMyselfEye` 向其变换指示的方向移动，而不是 `Camera`
    的观察方向，将行更改为 `character.SimpleMove(transform.forward * velocity)`。
- en: When the user pushes the thumbstick to the right, that is, the logical `"Horizontal"`
    axis is positive, we will rotate the rig clockwise by 30 degrees (`comfortAngle`).
    When the thumbstick is pressed left, we rotate counter-clockwise. We check for
    greater than 0.5 rather than exactly 1.0 so the player does not need to jam the
    stick all the way to the edge.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户将摇杆推向右侧时，即逻辑上的 `"Horizontal"` 轴为正，我们将以顺时针方向旋转装置 30 度（`comfortAngle`）。当摇杆向左按下时，我们逆时针旋转。我们检查大于
    0.5 而不是正好 1.0，这样玩家就不需要将摇杆推到边缘。
- en: We don't want to keep rotating, again and again, each update while the joystick
    is pressed, so we set a flag, `hasRotated`, and then ignore the axis until it
    comes to rest at the zero position. Then, we'll allow the player to press it again.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望每次摇杆被按下时都重复旋转，因此我们设置一个标志 `hasRotated`，然后忽略该轴，直到它静止在零位置。然后，我们将允许玩家再次按下它。
- en: The result is a comfortable navigation mechanic where one button moves you forward
    and another lets you change direction in large increments.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个舒适的导航机制，一个按钮让你向前移动，另一个按钮让你以大步改变方向。
- en: 'For your reference, some button mappings used in this mechanic are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 供你参考，此机制中使用的某些按钮映射如下：
- en: In OpenVR on HTC VIVE, `"Fire1"` is the menu button on one controller, `"Horizontal"`
    is touching the touchpad on the other controller.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 HTC VIVE 上的 OpenVR 中，`"Fire1"` 是一个控制器的菜单按钮，`"Horizontal"` 是另一个控制器触摸板的触摸。
- en: In OpenVR on Oculus, `"Fire1"` is the right controller's B button, `"Horizontal"`
    is the left controller thumbstick.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Oculus 上的 OpenVR 中，`"Fire1"` 是右侧控制器的 B 按钮，`"Horizontal"` 是左侧控制器的摇杆。
- en: 'On Daydream, you should modify the code to use `GvrControllerInput`. To detect
    horizontal clicks on the touchpad, call `GvrControllerInput.TouchPosCentered`,
    which returns a `Vector2`, and check `x` for values between `-1` and `1`. For
    example, replace the call to GetAxis with the following:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Daydream 上，你应该修改代码以使用 `GvrControllerInput`。为了检测触摸板上的水平点击，调用 `GvrControllerInput.TouchPosCentered`，它返回一个
    `Vector2`，并检查 `x` 的值是否在 `-1` 和 `1` 之间。例如，将调用 GetAxis 替换为以下内容：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You're encouraged to extend the `ButtonTest()` function used in the beginning
    of [Chapter 5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml), *Handy Interactables*,
    to determine which button mappings, axes, and SDK functions work best for your
    target VR device.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励你扩展 [第 5 章](21722631-9544-4b1e-a888-877d34b0fff7.xhtml) 开头使用的 `ButtonTest()`
    函数，即 *Handy Interactables*，以确定哪些按钮映射、轴和 SDK 函数最适合你的目标 VR 设备。
- en: We just implemented glide locomotion, where you move forward smoothly in the
    direction you're looking, or with comfort mode, in the direction your body is
    facing, while your head can look around. Comfort mode reduces the chance of motion
    sickness by having you change the direction you're facing in jumps of 30-degree
    angles. But even that may not be comfortable enough, and some developers (and
    players) prefer no gliding at all, and instead let you just *teleport* from one
    location to another.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实现了滑行移动功能，其中你可以朝着你所看的方向平滑前进，或者使用舒适模式，朝着你身体面向的方向前进，同时你的头部可以四处张望。舒适模式通过让你以30度角跳跃改变面向的方向来减少运动病的发生。但即使这样可能还不够舒适，一些开发者（和玩家）甚至更倾向于完全不使用滑行，而是让你能够从一处直接*传送*到另一处。
- en: Other locomotion considerations
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他移动考虑因素
- en: If you want to offer your players a VR ride, you can define a predefined *track* to
    glide along, like a guided tour of a building or art gallery. Tracks can be 3D,
    moving you up and down too, with gravity, such as VR roller coasters, or without
    gravity, such as a space tour. We do not recommend this mechanic except for the
    most hardcore thrill seekers as it has a good chance of causing motion sickness.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为你的玩家提供VR骑行体验，你可以定义一个预定义的*轨道*来滑行，就像建筑或艺术画廊的导览一样。轨道可以是3D的，不仅上下移动，还有重力，例如VR过山车，或者没有重力，例如太空之旅。我们不推荐这种机制，除非是最狂热的寻求刺激者，因为它有很高的可能性引起运动病。
- en: Another technique for comfort during locomotion is **Tunneling**. During the
    movement, the camera is cropped with a vignette and simple background, like a
    grid, is displayed in the player's peripheral vision, so the user only sees what
    is directly before them. Eliminating peripheral vision while moving can reduce
    the chance of motion sickness.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在移动过程中的舒适技术是**隧道模式**。在移动过程中，摄像头被剪裁，并在玩家的周边视野中显示一个简单的背景，如网格，这样用户就只能看到直接在他们面前的东西。在移动时消除周边视野可以减少运动病的发生。
- en: For vertical locomotion, apps have implemented a climbing mechanic, using your
    hands to reach, grab, and pull yourself up. Mountain climbing simulation games
    such as The Climb ([http://www.theclimbgame.com/](http://www.theclimbgame.com/))
    takes this idea to the next level (literally!), providing a number of different
    reach mechanics and grip types to grab onto.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于垂直移动，应用程序已经实现了攀爬机制，使用你的手去够、抓和拉自己向上。登山模拟游戏如The Climb（[http://www.theclimbgame.com/](http://www.theclimbgame.com/））将这一想法提升到了新的水平（字面意思上），提供了多种不同的够取机制和握持类型来抓住。
- en: Other apps have also tried using your hands, not for climbing, but for walking.
    For example, reaching and pulling like a rope, or swinging your arms like a runner,
    or even a circular pulling motion like you're operating a wheelchair.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其他应用程序也尝试使用你的手，不是为了攀爬，而是为了行走。例如，像拉绳子一样伸手和拉扯，或者像跑步者一样摆动手臂，甚至像操作轮椅一样进行圆形拉扯动作。
- en: 'Of course, there are hardware devices, such as that implement locomotion mechanisms
    using your feet to walk and run. Examples include:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有硬件设备，例如使用你的脚走路和跑步来实现移动机制的设备。例如：
- en: VR treadmills such as Virtuix Omni ([http://www.virtuix.com/](http://www.virtuix.com/))
    and VR Virtualizer ([https://www.cyberith.com/](https://www.cyberith.com/)), where
    you walk in place with your feet and legs to walk and run in VR.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VR跑步机如Virtuix Omni（[http://www.virtuix.com/](http://www.virtuix.com/））和VR Virtualizer（[https://www.cyberith.com/](https://www.cyberith.com/）），你可以在VR中用脚和腿原地行走和跑步。
- en: Exercise bikes such as VirZoom ([https://www.virzoom.com/](https://www.virzoom.com/))
    where you can bike and even hang glide in VR.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如VirZoom（[https://www.virzoom.com/](https://www.virzoom.com/））这样的健身自行车，你可以在VR中骑自行车甚至进行滑翔。
- en: Body tracking sensors can be used not just for player locomotion but also motion
    capture for creating character animations. Devices include Optitrack ([http://optitrack.com/motion-capture-virtual-reality/](http://optitrack.com/motion-capture-virtual-reality/)),
    Perception Neuron ([https://neuronmocap.com/](https://neuronmocap.com/)), ProVR
    ([http://www.vrs.org.uk/virtual-reality-gear/motion-tracking/priovr.html](http://www.vrs.org.uk/virtual-reality-gear/motion-tracking/priovr.html)),
    and others.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身体追踪传感器不仅可以用于玩家移动，还可以用于捕捉动作以创建角色动画。这些设备包括Optitrack（[http://optitrack.com/motion-capture-virtual-reality/](http://optitrack.com/motion-capture-virtual-reality/））、Perception
    Neuron（[https://neuronmocap.com/](https://neuronmocap.com/））、ProVR（[http://www.vrs.org.uk/virtual-reality-gear/motion-tracking/priovr.html](http://www.vrs.org.uk/virtual-reality-gear/motion-tracking/priovr.html））和其他设备。
- en: You probably need to write your app specifically for that device as there are
    no standards for these body tracking devices, but they're certainly a lot of fun.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要为该设备编写特定的应用程序，因为这些身体跟踪设备没有标准，但它们确实非常有趣。
- en: Techniques for teleportation
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传送技巧
- en: '**Pointer teleportation** is a mechanic where you point to a location you want
    to go to, and you jump there. No gliding. You just teleport to the new location.
    A laser beam or arc may be drawn, along with a teleport location receptacle to
    indicate where you may go.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**指针传送**是一种机制，您指向您想要去的位置，然后跳转到那里。没有滑动。您只是传送到新位置。可能绘制一条激光束或弧线，以及一个传送位置接收器，以指示您可以前往的位置。'
- en: As we've seen in previous chapters, we can make our own scripts. But since this
    is a core feature of VR applications, teleportation components are often included
    with device SDK toolkits. We'll write our own and consider some provided ones
    afterward.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，我们可以编写自己的脚本。但鉴于这是 VR 应用程序的核心功能，传送组件通常包含在设备 SDK 工具包中。我们将编写自己的，并在之后考虑一些提供的组件。
- en: To begin, if you have a saved version of the scene from [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based
    Control*, you can start with that. You may disable a few objects that we do not
    need, including `Ethan` and `WalkTarget`. Or, build a similar simple new scene
    containing a ground plane, some 3D objects as obstacles, and a copy of your `MeMyselfEye`
    prefab.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果您有 [第 4 章](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml) 中保存的场景版本，*基于注视的控制*，您可以从中开始。您可以禁用一些我们不需要的对象，包括
    `Ethan` 和 `WalkTarget`。或者，构建一个类似的简单新场景，包含地面平面、一些作为障碍物的 3D 对象，以及您的 `MeMyselfEye`
    预制件的副本。
- en: Looking to teleport
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备传送
- en: The mechanic we'll implement for our homegrown teleportation will work on any
    VR platform, using gaze-based pointing. Similar to how we controlled Ethan the
    zombie in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based
    Control*, we'll cast a ray from the player's camera view to the ground plane to
    choose a move-to location.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现的自定义传送机制将适用于任何 VR 平台，使用基于注视的指向。类似于我们在 [第 4 章](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml)，*基于注视的控制*
    中控制僵尸 Ethan 的方式，我们将从玩家的摄像机视图中发射一条射线到地面平面以选择移动到的位置。
- en: In our script, we'll use button press to initiate the teleport and release to
    jump there if you've selected a valid location. Alternatively, you could consider
    other input such as a forward push of the thumbstick using `Input.GetAxis`(v*ertical*)
    .
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本中，我们将使用按钮按下以开始传送，并在选择了一个有效位置后释放以跳转到那里。或者，您可以考虑其他输入，例如使用 `Input.GetAxis`(v*ertical*)
    的拇指杆向前推。
- en: 'First, let''s create a teleport marker (similar to the WalkTarget one), as
    follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个传送标记（类似于 WalkTarget 的一个），如下所示：
- en: Add an empty game object to the Hierarchy panel, and rename it `TeleportMarker`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构面板中添加一个空的游戏对象，并将其重命名为 `TeleportMarker`。
- en: Reset its Transform values to position (`0`,`0`,`0`) (using the gear icon in
    the upper-right of the Transform pane).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其变换值重置为位置 (`0`,`0`,`0`)（使用变换面板右上角的齿轮图标）。
- en: Right-click on the mouse and navigate to 3D Object | Cylinder. This will create
    a cylindrical object parented by `TeleportMarker`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击鼠标，导航到 3D 对象 | 圆柱。这将创建一个由 `TeleportMarker` 作为父对象的圆柱形对象。
- en: Reset its transform and change the Scale to (`0.4`, `0.05`, `0.4`). This will
    create a flat disk with a diameter of `0.4`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置其变换并更改缩放为 (`0.4`, `0.05`, `0.4`)。这将创建一个直径为 `0.4` 的扁平圆盘。
- en: Disable or remove its Capsule Collider.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用或删除其胶囊碰撞器。
- en: For now, we'll use the default material. Or, you could decorate your marker
    with another material. (For example, if you have Steam `InteractionSystem` installed,
    try the `TeleportPointVisible` material. If you have Daydream Elements installed,
    try the `TeleportGlow` material.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将使用默认材质。或者，您可以用另一种材质装饰您的标记。（例如，如果您安装了 Steam `InteractionSystem`，请尝试 `TeleportPointVisible`
    材质。如果您安装了 Daydream Elements，请尝试 `TeleportGlow` 材质。）
- en: 'Now, let''s write the script:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写脚本：
- en: Select the `MeMyselfEye` object in the Hierarchy panel
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构面板中选择 `MeMyselfEye` 对象
- en: Disable or remove the `GlideLocomotion` component, if present
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，禁用或删除 `GlideLocomotion` 组件
- en: Select Add Component | New Script and name it `LookTeleport`
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择添加组件 | 新脚本，并将其命名为 `LookTeleport`
- en: 'Write the script as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 编写以下脚本：
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The script works as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的工作原理如下：
- en: When the player clicks, targeting begins, and the target marker is made visible
    (`SetActive(true)`).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家点击时，开始定位，并将目标标记设置为可见 (`SetActive(true)`).
- en: While targeting, we identify what the player is looking at (`Raycast`). And
    if it's the ground, we position the target there (`hit.point`). Otherwise, the
    target is reset to the player's position.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在瞄准时，我们识别玩家正在看什么（`Raycast`）。如果是地面，我们将目标定位在那里（`hit.point`）。否则，目标将重置到玩家的位置。
- en: When the player stops pressing the button, the target is hidden. And we position
    the player to the target's current position, thus completing the teleportation.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家停止按按钮时，目标将被隐藏。我们将玩家定位到目标当前位置，从而完成传送。
- en: Notice that we are using the `TeleportMarker` target to store the state of our
    teleport mechanic while in targeting mode. When the target is active, we're targeting.
    When we exit targeting, we use the target's position as the new player position.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用 `TeleportMarker` 目标来存储在瞄准模式下的传送机制的状态。当目标处于活动状态时，我们正在瞄准。当我们退出瞄准时，我们使用目标的位置作为新的玩家位置。
- en: 'Save the script and in Unity:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并在 Unity 中：
- en: Drag the `GroundPlane` object onto the Ground slot
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `GroundPlane` 对象拖放到地面槽中
- en: Drag the `TeleportMarker` object onto the Target slot
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TeleportMarker` 对象拖放到目标槽中
- en: Press Play. Pressing the input button will activate the target marker, which
    moves as you look. On releasing the button, you teleport to that position. You
    can cancel the teleport by looking at something other than the ground and releasing
    the button.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放。按下输入按钮将激活目标标记，它随着你的视线移动。在释放按钮时，你将传送到该位置。你可以通过看向地面以外的其他东西并释放按钮来取消传送。
- en: Teleporting between surfaces
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在表面之间传送
- en: In the previous script, we're using a plain Raycast to determine where to place
    the `TeleportMarker`. This really only works on Plane objects. For any other 3D
    object, the hit point might be any surface, not just the topside walkable one.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的脚本中，我们使用普通的 Raycast 来确定放置 `TeleportMarker` 的位置。这仅在平面对象上有效。对于任何其他 3D 对象，击中点可能是任何表面，而不仅仅是可通行的顶部表面。
- en: An alternative approach is to use NavMesh to identify surfaces you can teleport
    to within the scene. Back in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml),
    *Gaze-Based Control*, we generated a NavMesh for Ethan's `AIThirdPersonController`
    to control where he's allowed to roam. This time, we also use the NavMesh to determine
    where we (`MeMyselfEye`) can go. Feel free to go back and review our conversations
    about NavMesh.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 NavMesh 识别场景内可以传送到的表面。[第 4 章](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml)中的“基于注视的控制”，我们为
    Ethan 的 `AIThirdPersonController` 生成了一个 NavMesh，以控制他可以自由游荡的地方。这次，我们也使用 NavMesh
    来确定我们（MeMyselfEye）可以去的地方。请随意回顾我们关于 NavMesh 的对话。
- en: The advantage of this approach is the available teleportation locations can
    be a subset of the ground plane. There can be can be multiple other object surfaces
    and even complex terrains. The teleportation locations will be limited to valid
    flat or slightly sloped surfaces.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是可用的传送位置可以是地面平面的子集。可以有多个其他对象表面，甚至复杂的地面。传送位置将限制在有效的平坦或略微倾斜的表面上。
- en: 'In case you skipped that section, or if you''ve rearranged objects in your
    scene since then, we will regenerate the NavMesh now:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跳过了该部分，或者自那时起您已经重新排列了场景中的对象，我们现在将重新生成 NavMesh：
- en: Select the Navigation panel. If it's not already a tab in your editor, open
    the Navigation window from the main menu by navigating to Window | Navigation.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 Navigation 面板。如果它还不是您编辑器中的一个选项卡，请从主菜单打开导航窗口，导航到 Window | Navigation。
- en: Select its Object tab.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择其 Object 选项卡。
- en: Select the Ground Plane in Hierarchy, then in the Navigation window's Object
    pane, check the Navigation Static checkbox. (Alternatively, you can use the object's
    Inspector window Static drop-down list.)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 中选择地面平面，然后在导航窗口的对象面板中，勾选导航静态复选框。（或者，您也可以使用对象的检查器窗口中的静态下拉列表。）
- en: 'Repeat step 3 for each of the objects that should block your possible teleportation
    locations: the cubes, sphere, and so on.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对应于应该阻止你可能的传送位置的对象（如立方体、球体等）重复步骤 3。
- en: 'For demonstration, we will now also add a second story platform:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们现在还将添加一个第二层平台：
- en: In Hierarchy, create a new 3D Cube and name it Overlook
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 中创建一个新的 3D 立方体，并将其命名为 Overlook
- en: Set its Scale to (`2.5`, `0.1`, `5`) and its Position to (`4`, `2.5`, `0.5`)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其缩放设置为 (`2.5`, `0.1`, `5`)，并将其位置设置为 (`4`, `2.5`, `0.5`)
- en: In the Navigation window, select the Object tab and check Navigation Static
    for the overlook, then
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航窗口中，选择对象选项卡，然后为 overlook 勾选导航静态。
- en: Select the Bake tab and click on the Bake button at the bottom of the panel
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择烘焙选项卡，然后单击面板底部的 Bake 按钮
- en: 'Note that its height (Y Scale) of the platform is greater than Agent Height
    (2) in the Navigation Bake settings. This will ensure the player can go both beneath
    the platform and on top of it. In the Scene window, you can see the areas in blue
    defined by the NavMesh, shown next, including a nice lookout area on the second
    story platform:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，平台的高度（Y 轴）在导航烘焙设置中大于代理高度（2）。这将确保玩家可以进入平台下方并在其上方行走。在场景窗口中，你可以看到由 NavMesh 定义的蓝色区域，如下所示，包括二楼平台上的一个不错的观景区：
- en: '![](img/e6f1877b-cbad-4ccd-8ef3-1a22c5c9ce4e.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6f1877b-cbad-4ccd-8ef3-1a22c5c9ce4e.png)'
- en: We can now modify the script to find our teleport target position on the NavMesh
    rather than the ground plane. Unfortunately, Unity does not provide a `Raycast`
    function for directly finding a hit point on the NavMesh. Instead, we find a hit
    point, as usual, using Physics colliders (which may be on the side or bottom of
    an object, not just the walkable surface), and then call `NavMesh.SamplePosition`
    to find the hit point position on the NavMesh. Modify the `LookTeleport` script
    as follows.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以修改脚本，以便在 NavMesh 上而不是在地面上找到我们的传送目标位置。不幸的是，Unity 并没有提供用于直接在 NavMesh 上找到击中点的
    `Raycast` 函数。相反，我们像往常一样使用物理碰撞体（可能位于对象的侧面或底部，而不仅仅是可通行表面）来找到击中点，然后调用 `NavMesh.SamplePosition`
    来找到 NavMesh 上的击中点位置。按照以下方式修改 `LookTeleport` 脚本。
- en: 'Add the following line at the top of your script to access the NavMesh API:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本顶部添加以下行以访问 NavMesh API：
- en: '[PRE10]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, modify `Update()` as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下方式修改 `Update()`：
- en: '[PRE11]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The call to `NavMesh.SamplePosition` takes the `hit.point` and finds the closest
    point on the NavMesh, within a given radius (we gave 1.0).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavMesh.SamplePosition` 的调用使用 `hit.point` 并在给定的半径内找到 NavMesh 上的最近点（我们给出了 1.0）。'
- en: Press Play. Now, you can set the `TeleportMarker` not only on the walkable surface
    of the `GroundPlane` but also on top of the Overlook!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放。现在，你可以在 `GroundPlane` 的可通行表面上设置 `TeleportMarker`，甚至可以在观景台上方设置！
- en: 'One more thing. Doing a `Physics.Raycast` can get quite expensive, especially
    in scenes with a lot of objects. You can limit the Raycast search by providing
    a layer mask. For example, create a layer named `Teleport` and set this layer
    for both `GroundPlane` and Overlook game objects. Then, modify the Raycast call
    as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事。执行 `Physics.Raycast` 可能相当昂贵，尤其是在有很多对象的场景中。你可以通过提供层掩码来限制 Raycast 的搜索。例如，创建一个名为
    `Teleport` 的层，并将此层设置为 `GroundPlane` 和 Overlook 游戏对象。然后，按照以下方式修改 Raycast 调用：
- en: '[PRE12]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will limit our Raycast to just the surfaces overlaid by the NavMesh, namely
    the ground plane and overlook.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将限制我们的 Raycast 只在 NavMesh 上叠加的表面，即地面平面和观景台。
- en: The next scenario we'll consider is not permitting free roaming at all, but
    setting up a limited set of teleportation locations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要考虑的下一个场景是完全不允许自由漫游，而是设置一组有限的传送位置。
- en: Teleport spawn points
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传送出生点
- en: It is very common in VR applications to limit teleportation to only specific
    predefined locations within the scene. In that case, you would not need any free-roaming
    glide locomotion or arbitrary teleportation targets. Instead, you can define the
    specific teleportation spawn points. Let's see how to do this.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VR 应用程序中，限制传送只限于场景中的特定预定义位置是非常常见的。在这种情况下，你不需要任何自由漫游的滑行移动或任意的传送目标。相反，你可以定义特定的传送出生点。让我们看看如何做到这一点。
- en: 'First, let''s create a `TeleportSpawn` prefab to mark our locations:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个 `TeleportSpawn` 预制件来标记我们的位置：
- en: In Hierarchy, create a 3D Sphere and name it `TeleportSpawn`
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，创建一个 3D 球体并将其命名为 `TeleportSpawn`
- en: Reset its transform (gear icon | Reset)
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置其变换（齿轮图标 | 重置）
- en: Set its Scale to `0.4`, `0.4`, `0.4`
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其缩放设置为 `0.4`，`0.4`，`0.4`
- en: Set its Position to something like (`2`, `0`, `3`)
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置设置为类似（`2`，`0`，`3`）
- en: Create a new layer named `TeleportSpawn` from Inspector | Layers | Add Layer
    and fill in the name in an empty slot
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从检查器 | 层 | 添加层创建一个新的层命名为 `TeleportSpawn` 并在空槽中填写名称
- en: Select the `TeleportSpawn` object in Hierarchy again, and now set its layer
    (Layers | TeleportSpawn) to the one we just defined
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在层次结构中选择 `TeleportSpawn` 对象，并将它的层（层 | TeleportSpawn）设置为刚刚定义的那个
- en: 'Let''s quickly make a material:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速创建一个材质：
- en: In your Materials folder, right-click to Create a new Material and name it `Teleport
    Material`
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的材质文件夹中，右键单击以创建一个新的材质并命名为 `Teleport Material`
- en: Set its Rendering Mode to Transparent
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其渲染模式设置为透明
- en: Set its Albedo color and give it a low alpha (such as 30) so it's translucent,
    such as our pale green (`70`, `230`, `70`, `30`)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其 Albedo 颜色并给予一个低 alpha 值（例如 30）以便它是半透明的，例如我们的浅绿色（`70`，`230`，`70`，`30`）
- en: Drag the material onto the `TeleportSpawn` object
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质拖放到 `TeleportSpawn` 对象上
- en: 'For this exercise, we''ll replace the `LookTeleport` component on `MeMyselfEye`
    with a new `LookSpawnTeleport` one:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将用新的 `LookSpawnTeleport` 替换 `MeMyselfEye` 上的 `LookTeleport` 组件：
- en: In Hierarchy, select `MeMyselfEye`
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中选择 `MeMyselfEye`
- en: Disable the `LookTeleport` component, if present
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，禁用 `LookTeleport` 组件
- en: Add Component | New Script and name it `LookSpawnTeleport`
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加组件 | 新脚本，并将其命名为 `LookSpawnTeleport`
- en: 'Write the new script as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式编写新脚本：
- en: '[PRE13]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Update()` function does a Raycast to see if any of the spawn point objects
    is selected. If so, the object is highlighted (unhighlighting any previous ones).
    Then, if the `Fire1` button is pressed, it teleports the player to that location.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()` 函数执行一次 Raycast 来查看是否有任何出生点对象被选中。如果是这样，该对象将被突出显示（取消突出显示任何之前的对象）。然后，如果按下
    `Fire1` 按钮，它将玩家传送到那个位置。'
- en: 'We add a couple of private helper functions, `Highlight()` and `Unhighlight()`.
    The first highlights an object by modifying its material color, making it more
    opaque (alpha 0.8). Unhighlight restores the original color when you look away:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了几个私有辅助函数，`Highlight()` 和 `Unhighlight()`。第一个通过修改材质颜色使其更不透明（alpha 0.8）来突出显示一个对象，使其更不透明。当你看开时，`Unhighlight`
    恢复原始颜色：
- en: '[PRE14]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'OK, now let''s place a few of the markers around the scene:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们在场景周围放置一些标记：
- en: Drag the `TeleportSpawn` object from Hierarchy to your `Prefabs` folder in the
    Project Assets
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TeleportSpawn` 对象从层级拖放到项目资产中的 `Prefabs` 文件夹
- en: Duplicate `TeleportSpawn` three times
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TeleportSpawn` 复制三次
- en: Position one of them at (`0`, `0`, `-1.5`) (the default `MeMyselfEye` position)
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其中一个放置在 (`0`, `0`, `-1.5`)（默认的 `MeMyselfEye` 位置）
- en: Move the others to suitable locations, such as (`2`, `0`, `3`), (`-4`, `0`,
    `1`), and if you have the Overlook, (`3.5`, `2.5`, `0`)
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其他对象移动到合适的位置，例如 (`2`, `0`, `3`), (`-4`, `0`, `1`)，如果你有 Overlook，则 (`3.5`, `2.5`,
    `0`)
- en: Alright! Press Play. When you look at a spawn point, it highlights. When you
    press the `Fire1` button, you teleport to the location.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！按 Play。当你看向一个出生点时，它会突出显示。当你按下 `Fire1` 按钮时，你会传送到那个位置。
- en: It may be useful to add a reticle (small cursor) at the center of your camera
    view to help focus the player's attention on the teleport objects, as we did in
    [Chapter 6](36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml), *World Space UI,* under
    the topic *The reticle cursor*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml) “世界空间 UI” 主题下的 *The reticle
    cursor* 部分中，我们像这样做了一个小光标（小光标），在摄像机视图中添加一个光标（小光标）可能很有用，以帮助玩家集中注意力在传送对象上：
- en: Although the teleport works, it may be nice if it also sets your view direction.
    One way to do this is to carefully place the `TeleportSpawn` objects facing the
    direction we want the player to face, and setting the player's transform rotation,
    in addition to position.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然传送是有效的，但如果它还设置你的视图方向会更好。一种方法是仔细放置 `TeleportSpawn` 对象，使其面向我们希望玩家面对的方向，并设置玩家的变换旋转，以及位置。
- en: 'To give a visual clue for the direction the spawn point is facing, we''ll add
    a graphic. We have included an image file, `flip-flops.png`, with this book. Otherwise,
    use anything that indicates a forward direction. Perform the following steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给出生点指向的方向提供一个视觉提示，我们将添加一个图形。我们在这本书中包含了一个图像文件，`flip-flops.png`。否则，使用任何表示前进方向的标志。执行以下步骤：
- en: Import the `flip-flops.png` texture by dragging it into your `Project Textures`
    folder (or navigating to Import New Asset...).
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将其拖放到你的 `Project Textures` 文件夹（或导航到 Import New Asset...）导入 `flip-flops.png`
    纹理。
- en: Create a new material in the Material folder and name it `FlipFlops`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在材质文件夹中创建一个新的材质，并将其命名为 `FlipFlops`。
- en: Drag the `flip-flops` texture onto the `FlipFlops` material's Albedo map and
    choose Rendering Mode as Cutout.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `flip-flops` 纹理拖放到 `FlipFlops` 材质的 Albedo 映射上，并将渲染模式选择为 Cutout。
- en: Select the `TeleportSpawn` object in Hierarchy.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中选择 `TeleportSpawn` 对象。
- en: Create a child Quad object (right-click Create | 3D Object | Quad).
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个子 Quad 对象（右键单击创建 | 3D 对象 | Quad）。
- en: Drag the `FlipFlops` material onto the `Quad`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `FlipFlops` 材质拖放到 `Quad` 上
- en: Set the Quad's Transform Position to (`0`, `.01`, `0`) and its Rotation to (`90`, `0`, `0`)
    so that it lies flat on the ground plane.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Quad 的 Transform Position 设置为 (`0`, `.01`, `0`)，并将其 Rotation 设置为 (`90`, `0`,
    `0`)，使其平躺在地面平面上。
- en: Select the parent `TeleportSpawn` object and in Inspector, press Apply to save
    these changes to the prefab. Now all the spawns will have feet.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择父级 `TeleportSpawn` 对象，并在检查器中按 Apply 保存这些更改到预制体。现在所有出生点都将有脚
- en: Note that for the one up on the Overlook, you can adjust its Quad so it's visible
    from below, such as Position (`0`, `-0.2`, `0`) and Rotation (`-90`, `0`, `180`)
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，对于位于Overlook之上的对象，你可以调整其Quad，使其从下方可见，例如位置(`0`, `-0.2`, `0`)和旋转(`-90`, `0`,
    `180`)
- en: 'The modification to our script to apply the rotation is trivial:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本中应用旋转的修改是微不足道的：
- en: '[PRE15]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There it is, a gaze-based teleportation system with predefined spawn points,
    as shown here in the Scene window:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，这是一个基于目光的、具有预定义出生点的传送系统，如图所示在场景窗口中：
- en: '![](img/6e2f7fd4-7437-410a-9f78-5d726a596fe5.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e2f7fd4-7437-410a-9f78-5d726a596fe5.png)'
- en: Other teleport considerations
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他传送考虑因素
- en: There's a lot more that can be said and done with teleportation. You may prefer
    to select the location using hand controllers rather than gaze. It is common to
    show the teleport pointer using an arced laser beam (using a Bezier curve). The
    teleport spawn point is often rendered using a glow or fiery effect. Many of these
    features have already been built and provided using higher-level VR toolkits (see
    next topic).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 关于传送，还有很多可以说的和可以做的。你可能更喜欢使用手柄控制器而不是目光选择位置。通常使用弧形激光束（使用贝塞尔曲线）来显示传送指针。传送出生点通常使用发光或火焰效果。许多这些功能已经通过高级VR工具包构建并提供了（见下一主题）。
- en: Blink teleport is a technique that does a fade-out fade-in between the change
    in player position. It is said to provide an additional degree of comfort. We
    won't show the code here, but there are several techniques for implementing fades
    for VR, such as creating a screen-space canvas that covers the entire camera with
    a black panel, and lerping its alpha channel as it fades (see [https://docs.unity3d.com/ScriptReference/Mathf.Lerp.html](https://docs.unity3d.com/ScriptReference/Mathf.Lerp.html)).
    Some have even found fading with a literal blink effect is quite natural, where
    you rapidly fade out from top to bottom, and fade in bottom to top, like an eyelid
    closing and opening.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 闪烁传送是一种在玩家位置变化之间进行淡出淡入的技术。据说这提供了一种额外的舒适度。我们这里不会展示代码，但有一些实现VR中淡入淡出的技术，例如创建一个覆盖整个相机的屏幕空间画布，使用黑色面板，并在淡入淡出时lerping其alpha通道（见[https://docs.unity3d.com/ScriptReference/Mathf.Lerp.html](https://docs.unity3d.com/ScriptReference/Mathf.Lerp.html)）。有些人甚至发现使用真实的眨眼效果进行淡入淡出非常自然，其中你从上到下快速淡出，然后从下到上淡入，就像眼睑的闭合和打开。
- en: Another technique is to provide a third-person view of the scene from above,
    sometimes called a **mini-map**, **god view***,* or **dollhouse view**. From this
    perspective, the player could point to a new location to teleport. This mini version
    of the scene could be an object the player uses as a tool in the main scene, or
    you transition to this view mode during the teleportation selection process.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术是从上方提供场景的第三人称视角，有时称为**迷你地图**、**上帝视角**或**玩具屋视角**。从这个视角，玩家可以指向一个新位置进行传送。这个场景的迷你版本可以是玩家在主场景中用作工具的对象，或者你在传送选择过程中切换到这种视图模式。
- en: You can also teleport to a different scene. Combined with the blink fade in/out,
    you call `SceneManager.LoadScene("OtherSceneName")` rather than simply changing
    the transform position. Note, you must add the other scene to the Build Settings
    Scenes to Build list (see [https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadScene.html](https://github.com/thestonefox/VRTK)).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以传送到不同的场景。结合闪烁淡入淡出，你调用`SceneManager.LoadScene("OtherSceneName")`而不是简单地改变变换位置。注意，你必须将其他场景添加到构建设置场景的构建列表中（见[https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadScene.html](https://github.com/thestonefox/VRTK)）。
- en: Clever use of teleportation and the player's direction can lead to efficient
    use of limited play space and give the perception of the VR space being much larger
    than actually in real life. For example, in room-scale VR, if you have the player
    walk toward the edge of the play space and enter an elevator (teleport), she could
    be facing the back of the elevator going in and must turn around when the doors
    open on the new level and can now physically walk forward. In fact, infinite corridors
    and connected rooms could be implemented this way while maintaining player immersion.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明地使用传送和玩家的方向可以有效地利用有限的游玩空间，并给人一种VR空间比现实中更大的感知。例如，在房间规模VR中，如果你让玩家走向游玩空间的边缘并进入电梯（传送），她可能会面对电梯的背面进入，并在新级别的门打开时必须转身，此时可以物理地向前行走。实际上，可以通过这种方式实现无限走廊和相连的房间，同时保持玩家的沉浸感。
- en: Teleportation toolkits
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传送工具包
- en: We have explored several different locomotion and teleportation mechanics. All
    of them use your gaze direction for selection. This is sometimes the best choice.
    Sometimes it's not. It certainly is the lowest common denominator between various
    VR devices, from high-end HTC VIVE and Oculus Rift to the low-end Google Cardboard,
    gaze-based selection with a simple click will always be available.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探索了多种不同的移动和传送机制。它们都使用你的注视方向进行选择。这有时是最佳选择。有时则不是。这无疑是各种VR设备之间最低的共同点，从高端的HTC
    VIVE和Oculus Rift到低端Google Cardboard，基于注视的简单点击选择始终可用。
- en: It is likely you will prefer to use the hand controller for selection. High-end
    systems include two positionally tracked controllers, one for each hand. Lower-end
    devices, such as Google Daydream, include a single 3DOF "laser pointer" controller. Another
    reason we avoided implementing with controllers so far is the coding varies greatly
    from one device to the next. Also, the device-specific toolkits often come with
    components and prefabs that implement this mechanic, optimized for their particular
    platform, including high-performance shaders for rendering arced laser beams and
    teleportation markers.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你更喜欢使用手柄控制器进行选择。高端系统包括两个位置跟踪控制器，每个手一个。低端设备，如Google Daydream，包括一个单一的3DOF“激光指针”控制器。我们之前避免使用控制器实现的原因之一是代码在不同设备之间差异很大。此外，特定设备的工具包通常附带实现此机制所需的组件和预制体，针对特定平台进行了优化，包括用于渲染弧形激光束和传送标记的高性能着色器。
- en: In this section, we will show how to implement teleportation using these higher-level
    components, using SteamVR Interaction System and Google Daydream Elements. If
    you're not using one of these, please see the toolkits project with your target
    device, or consider a generalized toolkit such as the open source VRTK ([https://github.com/thestonefox/VRTK](https://github.com/thestonefox/VRTK)).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何使用这些高级组件实现传送，使用SteamVR交互系统和Google Daydream Elements。如果你没有使用这些工具之一，请查看你的目标设备的工具包项目，或者考虑使用通用的工具包，如开源的VRTK
    ([https://github.com/thestonefox/VRTK](https://github.com/thestonefox/VRTK))。
- en: Teleporting with SteamVR Interaction System
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SteamVR交互系统进行传送
- en: The SteamVR Interaction System we first introduced in [Chapter 5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml),
    *Handy Interactables* includes easy to use teleport components. If you are using
    SteamVR SDK, it can be found in the `Assets/SteamVR/InteractionSystem/Teleport/` folder.
    The teleport tools include a lot of extras we didn't get a chance to implement
    ourselves, including materials, models, prefabs, scripts, shaders, sounds, textures,
    haptics, oh my!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](21722631-9544-4b1e-a888-877d34b0fff7.xhtml)中首次介绍的SteamVR交互系统，*Handy
    Interactables*，包括易于使用的传送组件。如果你使用SteamVR SDK，它可以在`Assets/SteamVR/InteractionSystem/Teleport/`文件夹中找到。传送工具包括许多我们没有机会自己实现的额外功能，包括材质、模型、预制体、脚本、着色器、声音、纹理、触觉等！
- en: 'Specifically, the teleport toolkit includes:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，传送工具包包括：
- en: '`Teleporting` prefab: Teleportation controller, add one per scene'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Teleporting`预制体：传送控制器，每个场景添加一个'
- en: '`TeleportPoint` prefab:Locations you want to teleport to, add one for each
    location'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TeleportPoint`预制体：你想要传送到的位置，每个位置添加一个'
- en: '`TeleportArea` component: Add to a game object, such as a Plane, to allow teleporting
    anywhere on that area'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TeleportArea`组件：添加到游戏对象，例如一个平面，以允许在该区域内任意位置进行传送'
- en: 'Interaction System includes its own `Player` camera rig which replaces the
    default `[CameraRig]` we have been using, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 交互系统包括其自带的`Player`相机装置，它取代了我们一直使用的默认`[CameraRig]`，如下所示：
- en: Locate the `Player` prefab in `SteamVR/InteractionSystem/Core/Prefabs`
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SteamVR/InteractionSystem/Core/Prefabs`中定位`Player`预制体
- en: Drag it as a child of `MeMyselfEye` in your scene Hierarchy
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其拖动为场景`Hierarchy`中`MeMyselfEye`的子对象
- en: Delete or disable the `[CameraRig]` object
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除或禁用`[CameraRig]`对象
- en: Drag a copy of `Teleporting` prefab from Project `Assets/SteamVR/InteractionSystem/Teleport/Prefabs` as
    a child of `MeMyselfEye` (this controller can actually go anywhere in the scene)
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目`Assets/SteamVR/InteractionSystem/Teleport/Prefabs`中拖动`Teleporting`预制体的副本作为`MeMyselfEye`的子对象（这个控制器实际上可以在场景中的任何地方移动）
- en: Select the Player in Hierarchy, and drag its parent `MeMyselfEye` onto its Tracking
    Origin Transform slot
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Hierarchy`中选择玩家，并将它的父对象`MeMyselfEye`拖动到其跟踪原点变换槽中
- en: This last step is important. The toolkit's teleportation components change the
    position of the `Player` object by default. We want to teleport the Player parent,
    `MeMyselfEye`, when we teleport. This might also be used if in your game, for
    example, the player is sitting in the cockpit of vehicle and you intend to teleport
    the whole vehicle, not just the Player itself.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一步很重要。工具包的传送组件默认会改变 `Player` 对象的位置。当我们传送时，我们希望传送 `Player` 的父对象 `MeMyselfEye`。如果在你的游戏中，例如，玩家坐在车辆的驾驶舱中，而你打算传送整个车辆，而不仅仅是玩家本身，这也可能被使用。
- en: 'If you followed the projects earlier in this chapter, disable the things we
    won''t be using here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循了本章前面的项目，请禁用我们在这里不会使用的东西：
- en: On `MyMyselfEye`, disable or remove the Look Teleport and Look Spawn Teleport
    components
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MyMyselfEye` 上禁用或移除Look Teleport和Look Spawn Teleport组件
- en: Disable or delete each of the `TeleportSpawn` objects
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用或删除每个 `TeleportSpawn` 对象
- en: 'Now, for each teleport location:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于每个传送位置：
- en: Drag a copy of the `TeleportPoint` prefab from Project `Assets/SteamVR/InteractionSystem/Teleport/Prefabs`
    into the Hierarchy
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TeleportPoint` 预制件的副本从项目 `Assets/SteamVR/InteractionSystem/Teleport/Prefabs`
    拖到层次结构中
- en: Place one where you want in the scene. As previously, we used (`0`, `0`, `-1.5`),
    (`2`, `0`, `3`), (`-4`, `0`, `1`), and on the Overlook (`3.5`, `2.5`, `0`)
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其放置在场景中的任何位置。如前所述，我们使用了 (`0`, `0`, `-1.5`), (`2`, `0`, `3`), (`-4`, `0`, `1`),
    以及在Overlook位置 (`3.5`, `2.5`, `0`)
- en: 'That''s it! Press Play. The teleport points do not show until you press the
    button on your controller, then they glow, a dashed laser arc lets you choose
    one, and you go there. In the Game window shown here, I am teleporting to the
    Overlook location:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！按下播放。传送点不会显示，直到你按下控制器上的按钮，然后它们会发光，一条虚线激光弧让你选择一个，然后你就可以到达那里。在此处显示的游戏窗口中，我正在传送至Overlook位置：
- en: '![](img/1a63a4c3-8a3a-4468-9af3-d3737417b404.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a63a4c3-8a3a-4468-9af3-d3737417b404.png)'
- en: Please review the many options on the Teleport component. You can modify or
    replace materials used for highlighting teleport points, sounds, and other effects.
    The Teleport Arc component has options for rendering the laser arc, and the `TeleportPoints`
    themselves can each be modified separately.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看Teleport组件上的许多选项。您可以修改或替换用于突出显示传送点的材质、声音和其他效果。Teleport Arc组件提供了渲染激光弧的选项，而
    `TeleportPoints` 本身也可以分别进行修改。
- en: Teleporting with Daydream Elements
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Daydream Elements进行传送
- en: The Google Daydream Elements package we first introduced in [Chapter 5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml), *Handy
    Interactables* includes some teleport components. If you are targeting Google
    Daydream, you can install the separate Daydream Elements download from GitHub
    ([https://github.com/googlevr/daydream-elements/releases](https://github.com/googlevr/daydream-elements/releases)).
    And documentation can be found on the Elements site ([https://developers.google.com/vr/elements/teleportation](https://developers.google.com/vr/elements/teleportation)).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第五章中首次介绍的Google Daydream Elements包，*Handy Interactables* 包含一些传送组件。如果你针对Google
    Daydream，你可以从GitHub安装单独的Daydream Elements下载（[https://github.com/googlevr/daydream-elements/releases](https://github.com/googlevr/daydream-elements/releases)）。相关文档可以在Elements网站上找到（[https://developers.google.com/vr/elements/teleportation](https://developers.google.com/vr/elements/teleportation)）。
- en: Once imported into your project, it can be found in the `Assets/DaydreamElements/Elements/Teleport/` folder.
    There is a demo scene, Teleport, and associated materials, models, prefabs, scripts,
    shaders, and textures.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导入到你的项目中，它可以在 `Assets/DaydreamElements/Elements/Teleport/` 文件夹中找到。这里有一个演示场景，Teleport，以及相关的材质、模型、预制件、脚本、着色器和纹理。
- en: 'Out of the box, the tools are pretty generic and very customizable. The primary
    prefab is `TeleportController`, which does all the work. The user input used to
    trigger teleport behavior can be configured in the Unity Editor by filling the
    component slots, as shown here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些工具相当通用且可高度自定义。主要的预制件是 `TeleportController`，它负责所有工作。用于触发传送行为的用户输入可以通过在Unity编辑器中填充组件槽进行配置，如下所示：
- en: '![](img/c0b48a82-4c23-4594-a210-38c2abd5ffa7.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0b48a82-4c23-4594-a210-38c2abd5ffa7.png)'
- en: You can extend the teleporter by changing its *detector*, *visualizer*, and
    *transition* classes.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更改其 *探测器*、*可视化器* 和 *过渡* 类来扩展传送器。
- en: '**Detector**: Such as the `ArcTeleportDetector` does a curved arc Raycast to
    find objects in the scene and limits the hit to horizontal surfaces with adequate
    space to "fit" the player, so you do not teleport into walls.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探测器**：例如，`ArcTeleportDetector` 会进行曲线弧形射程以在场景中找到对象，并将击中限制在具有足够空间“适合”玩家的水平表面上，这样你就不会传送到墙壁中。'
- en: '**Visualizer**: Such as the `ArcTeleportVisualizer`, renders the arc when teleport
    is triggered.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可视化器**：例如`ArcTeleportVisualizer`，在触发传送时渲染弧线。'
- en: '**Transition**: Such as `LinearTeleportTransition`, animates the player to
    the new location. This could be modified to implement a blink effect, for example.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过渡**：例如`LinearTeleportTransition`，将玩家动画移动到新位置。这可以修改以实现眨眼效果，例如。'
- en: 'To add it to your scene:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其添加到您的场景中：
- en: Drag the `TeleportController` prefab into your Hierarchy as child of Player
    (for us that `MeMyselfEye` | GVRCameraRig | Player)
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TeleportController`预制件拖放到您的层次结构中，作为Player的子对象（对我们来说就是`MeMyselfEye` | GVRCameraRig
    | Player）。
- en: Reset its Transform, if necessary
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，重置其变换。
- en: Drag the `MeMyselfEye` object onto the `TeleportController` component's Player
    transform slot
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MeMyselfEye`对象拖放到`TeleportController`组件的Player变换槽中。
- en: Drag `GvrControllerPointer` (or whichever controller game object you're using)
    onto the Controller transform slot
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GvrControllerPointer`（或您正在使用的任何控制器游戏对象）拖放到控制器变换槽中。
- en: Press Play and you can teleport all around your scene. There is no need to place
    specific teleport targets.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放，您可以在场景的任何地方传送。不需要放置特定的传送目标。
- en: By default, the `TeleportController` will work by letting you land on any object
    in the scene that has a collider. You can limit the objects considered by the
    detector's Raycast by specifying the layer(s). Also, if you want arbitrarily shaped
    target areas that are not necessarily game objects in your scene, you can add
    sets of objects with just colliders, no renderers. This is how the teleport areas
    on the islands are implemented in the Daydream Elements teleport demo.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`TeleportController`将通过让您在任何具有碰撞器的场景对象上着陆来工作。您可以通过指定层来限制检测器Raycast考虑的对象。此外，如果您想在场景中添加任意形状的目标区域，这些区域不一定是游戏对象，您可以添加仅具有碰撞器而没有渲染器的对象集。这就是在Daydream
    Elements传送演示中实现岛屿上的传送区域的方式。
- en: Resetting center and position
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置中心和位置。
- en: Sometimes in VR, the view presented in the headset is not quite in sync with
    your body's orientation. Device SDKs provide functions to reset the orientation
    of the headset with respect to the real-world space. This is often referred to
    as the **recentering** of the view.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在VR中，头戴式设备中呈现的视图与您的身体方向不完全同步。设备SDK提供函数以重置头戴式设备相对于真实世界空间的方向。这通常被称为视图的**居中**。
- en: Unity provides an API call that maps to the underlying device SDK to recenter
    the device, `UnityEngine.VR.InputTracking.Recenter()`. This function will center
    tracking to the current position and orientation of the HMD. It only works with
    seated and standing experiences. Room scale experiences are not affected.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了一个API调用，它映射到底层设备SDK以重新居中设备，`UnityEngine.VR.InputTracking.Recenter()`。此函数将跟踪中心定位到HMD的当前位置和方向。它仅适用于坐姿和站姿体验。房间规模体验不受影响。
- en: 'At the time of this writing, Recenter does not work in SteamVR, even for seated
    configuration. The solution is to call the following code instead:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Recenter在SteamVR中不起作用，即使是坐姿配置。解决方案是调用以下代码：
- en: '[PRE16]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Daydream controller has reset built into the underlying system (press and
    hold the system button). This is because unwanted drift is so common on mobile
    VR devices. Also, for Cardboard (and Daydream users without a controller), there
    is a standard floor canvas menu you should include in your player rig (as we did
    in [Chapter 3](5f03c1ec-a1bc-4ec8-bf4b-dc7a4492aba4.xhtml), *VR Build and Run*),
    that includes a reset and recenter buttons.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Daydream控制器在底层系统中集成了重置功能（按住系统按钮）。这是因为在不想要的漂移在移动VR设备上非常常见。此外，对于Cardboard（以及没有控制器的Daydream用户），您应该在玩家装置中包含一个标准的地面画布菜单，该菜单应包括重置和居中按钮（正如我们在[第3章](5f03c1ec-a1bc-4ec8-bf4b-dc7a4492aba4.xhtml)，*VR构建和运行*）中做的那样）。
- en: On other systems, you can choose a button that triggers a call to `Recenter` as
    needed.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他系统上，您可以根据需要选择一个触发调用`Recenter`的按钮。
- en: Supporting room scale teleportation
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持房间规模传送。
- en: As mentioned, the Unity Recenter function does not have any affect on room scale
    setups. We assume that room scale players are standing and mobilized, so they
    can just turn themselves to face "forward" within the VR scene.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Unity Recenter功能对房间规模设置没有任何影响。我们假设房间规模玩家是站立并活跃的，因此他们可以在VR场景中自行转身面对“前方”。
- en: When teleporting, however, we are moving the player to a new location, and possibly
    to an entirely different scene. When we reposition MyMyselfEye or any parent of
    the positionally tracked camera, the player is not necessary located at origin
    of that rig. If the player teleports to a new location, his whole play space should
    be ported and the player should end up standing on the virtual location he specifically
    chose.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们传送时，我们正在将玩家移动到新的位置，可能是一个完全不同的场景。当我们重新定位MyMyselfEye或任何位置跟踪摄像机的父对象时，玩家不必位于该装置的原点。如果玩家传送到新位置，他的整个游戏空间应该被传送，并且玩家最终应该站在他特别选择的虚拟位置上。
- en: 'The following function will compensate the teleport transform to the player''s
    relative pose within the playspace. As written, it assumes it is a component on
    the MeMyselfEye player root object:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将补偿传送变换，使玩家在游戏空间中的相对姿态。按照编写方式，它假定它是一个位于MeMyselfEye玩家根对象上的组件：
- en: '[PRE17]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To use it in our previous teleport script examples, replace the `transform.position
    = target.transform.position;` line with a call to `TeleportRoomscale( target.transform.position
    )` instead.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的传送脚本示例中使用它时，将`transform.position = target.transform.position;`行替换为对`TeleportRoomscale(target.transform.position)`的调用。
- en: Managing VR motion sickness
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理VR运动病
- en: VR motion sickness, or simulator sickness, is a real symptom and a concern for
    virtual reality. Researchers, psychologists, and technologists with a wide array
    of specializations and PhDs are studying the problem to better understand the
    underlying causes and find solutions.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: VR运动病，或称模拟器病，是虚拟现实中的一个真实症状和关注点。研究人员、心理学家和技术人员，拥有广泛的专长和博士学位，正在研究这个问题，以更好地理解潜在的原因并找到解决方案。
- en: A cause of VR motion sickness is a lag in screen updates, or latency, when you're
    moving your head. Your brain expects the world around you to change exactly in
    sync. Any perceptible delay can make you feel uncomfortable, to say the least.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: VR运动病的一个原因是，当你移动头部时，屏幕更新滞后，或者延迟。你的大脑期望你周围的世界会精确同步地改变。任何可感知的延迟都可能让你感到不舒服，至少可以说。
- en: Latency can be reduced by faster rendering of each frame, keeping to the recommended
    frames per second. Device manufacturers see this as their problem to solve, in
    both hardware and device driver software. GPU and chip manufacturers see it as
    a processor performance and throughput problem. We will undoubtedly see leaps
    and bounds of improvements over the coming years.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更快地渲染每一帧，保持推荐的每秒帧数，可以减少延迟。设备制造商将其视为他们需要解决的问题，无论是硬件还是设备驱动程序软件。GPU和芯片制造商将其视为处理器性能和吞吐量问题。我们无疑将在未来几年看到显著的改进。
- en: At the same time, as VR developers, we need to be aware of latency and other
    causes of VR motion sickness. Developers need to look at it like it's our problem
    too because ultimately, it comes down to performance and ergonomics. With an ongoing
    dichotomy of mobile VR versus desktop VR, there will always be upper bounds on
    the performance of devices that our players will be using. In [Chapter 13](c938e975-93f3-4435-9d99-9f76bbbd0a98.xhtml),
    *Optimizing for Performance and Comfort*, we dive into the technical details of
    the rendering pipeline and performance.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，作为VR开发者，我们需要意识到延迟和VR运动病的其他原因。开发者需要将其视为我们自己的问题，因为最终，这取决于性能和人体工程学。在移动VR与桌面VR持续的二分法中，玩家将使用的设备性能始终会有上限。在第13章[优化性能和舒适度](c938e975-93f3-4435-9d99-9f76bbbd0a98.xhtml)中，我们深入探讨了渲染管道和性能的技术细节。
- en: 'But it''s not just technology. I can get nauseous riding a real-world roller
    coaster. So, why wouldn''t a VR one have a similar effect? Things to consider
    that help improve your players'' comfort and safety include game mechanics and
    user experience design such as the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题不仅仅是技术。我乘坐现实世界的过山车也会感到恶心。那么，为什么VR过山车不会有类似的效果呢？以下是一些有助于提高玩家舒适度和安全性的考虑因素，包括以下游戏机制和用户体验设计：
- en: '**Don''t move fast**: When moving or animating a first-person character, don''t
    move too fast. High-speed first-person shooter games that work on gaming consoles
    and desktop PCs may not work out so well in VR.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要快速移动**：当移动或动画化第一人称角色时，不要移动得太快。在游戏机和个人电脑上运行的高速第一人称射击游戏在VR中可能效果不佳。'
- en: '**Look forward**: When moving through a scene, if you''re looking to the side
    rather than straight ahead, you''re more likely to feel nauseous.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向前看**：当你穿过一个场景时，如果你向侧面看而不是直视前方，你更有可能感到恶心。'
- en: '**Don''t turn your head too fast**: Discourage users from turning their head
    quickly with the VR headset on. The latency in updating the HMD screen is aggravated
    by larger changes in the viewport in small time slices.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要快速转动头部**：使用VR头盔时，不要鼓励用户快速转动头部。在小的时片内视口的大幅变化加剧了更新HMD屏幕的延迟。'
- en: '**Offer comfort mode**: When a scene requires you to quickly turn yourself
    a lot of times, provide a ratcheted rotation mechanism, also known as comfort
    mode, which lets you change the direction in which you look in larger increments.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供舒适模式**：当场景需要你快速多次转身时，提供一种旋转机制，也称为舒适模式，允许你以更大的增量改变观察方向。'
- en: '**Use fade or blink** cuts during teleportation and scene changes. When fading,
    go to a dark color, as white can be startling.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在传送和场景转换期间使用淡入或闪烁剪辑**。在淡入时，过渡到深色，因为白色可能会令人震惊。'
- en: '**Use tunneling** or other techniques during locomotion. Reduce what is visible
    in the peripheral vision by masking the camera except what is just in front of
    you.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在移动过程中使用隧道或其他技术**。通过遮挡相机除了你正前方之外的所有可见内容，减少视野中的可见内容。'
- en: '**Use a third-person camera**: If you have high-speed action but you don''t
    necessarily intend to give the user a thrill ride, use a third-person camera view.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用第三人称摄像机**：如果你有高速动作，但并不一定打算给用户带来刺激的体验，可以使用第三人称摄像机视角。'
- en: '**Stay grounded**: Provide visual cues that help the user stay grounded, such
    as horizon lines, nearby objects in your field of view, and relative fixed-position
    objects, such as dashboards and body parts.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持脚踏实地**：提供有助于用户保持平衡的视觉提示，例如地平线线、视野中的附近物体以及相对固定的位置物体，如仪表盘和身体部位。'
- en: '**Provide an option to recenter the view**: Mobile VR devices, in particular,
    are subject to drift and the need to be recentered on occasion. With wired VR
    devices, it helps you avoid getting tangled in HMD wires. As a safety issue, recentering
    your view relative to the real world may help you avoid hitting furniture and
    walls in the physical space.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供重新居中视图的选项**：特别是移动VR设备容易发生漂移，有时需要重新居中。对于有线VR设备，这有助于你避免被HMD线缠住。作为一个安全问题，将你的视图相对于现实世界重新居中可能有助于你在物理空间中避免撞到家具和墙壁。'
- en: '**Don''t use cut scenes**: In traditional games (and movies), a technique that
    can be used to transition between levels is to show a 2D cutscene movie. This
    does not work in VR if the head motion detection is disabled. It breaks the immersion
    and can cause nausea. An alternative is to simply fade to black and then open
    the new scene.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用剪辑场景**：在传统游戏（和电影）中，用于在关卡之间切换的技术是显示一个2D剪辑电影。如果禁用了头部运动检测，这在VR中是不起作用的。它会破坏沉浸感并可能导致恶心。一种替代方法是简单地淡入黑色，然后打开新场景。'
- en: '**Optimize rendering performance**: It behooves all VR developers to understand
    the underlying causes of latency-specifically rendering performance-and what you
    can do to optimize it, such as lowering the poly count and choosing lighting models
    carefully. Learn to use performance monitoring tools in order to keep the frames
    per second within the expected and acceptable limits. More on this will be discussed
    in [Chapter 10](df997d92-d63c-4701-9786-da7ba54082b6.xhtml), *Using All 360 Degrees*.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化渲染性能**：所有VR开发者都应该了解延迟的根本原因——特别是渲染性能——以及你可以做什么来优化它，例如降低多边形数量和仔细选择光照模型。学会使用性能监控工具，以保持每秒帧数在预期和可接受的范围内。更多内容将在第10章中讨论，*使用所有360度*。'
- en: '**Encourage users to take breaks**: Alternatively, you can maybe just provide
    a puke-bag with your game! Or not.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鼓励用户休息**：或者，你可能只是提供一款游戏呕吐袋！或者不提供。'
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored many different ways of moving around within your
    virtual environments. We started by examining Unity's components that support
    conventional third-person and first-person characters and quickly realized most
    of those capabilities are not too useful in VR. For instance, we don't want the
    app to bob our head up and down as we walk, and we don't necessarily want to go
    jumping off buildings either. Moving around is important, but player comfort is
    more so. You don't want to induce motion sickness.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在虚拟环境中移动的许多不同方式。我们首先检查了Unity支持的传统第三人称和第一人称角色的组件，并很快意识到这些功能在VR中并不太有用。例如，我们不希望应用程序在我们行走时上下晃动头部，我们也不一定想从建筑物上跳下来。移动很重要，但玩家的舒适度更为重要。你不想引起运动病。
- en: Locomotion is moving smoothly and linearly across the scene, akin to walking.
    Using gaze-based mechanics, we implemented moving in the direction you're looking
    and used input buttons to start and stop. Then, we separated the locomotion from
    head direction, always moving "forward" and using a separate input (thumbpad)
    to change the angle our body is facing. With this *comfort mode*, you can locomote
    and still look around.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 机动性是平滑且线性地在场景中移动，类似于行走。我们利用基于注视的机制实现了朝你注视的方向移动，并使用输入按钮来开始和停止。然后，我们将机动性与头部方向分离，始终朝“前方”移动，并使用单独的输入（拇指盘）来改变身体面向的角度。在这种*舒适模式*下，你可以移动的同时四处张望。
- en: Jumping to a new location is called teleportation. We started again with a gaze-based
    mechanic, letting you select a teleport location where you're looking. We implemented
    a couple ways of constraining where you are allowed to teleport, using NavMesh
    and using teleport spawn points. Then, we looked at some teleportation toolkits,
    from SteamVR and Google Daydream, which provide a rich set of capabilities, as
    well as a juicy user experience that is not trivial to implement from scratch.
    If you're targeting a different platform, such as Oculus, there are similar tools.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 跳到新位置被称为传送。我们再次从基于注视的机制开始，让你选择一个你注视的传送位置。我们实现了几种限制你允许传送位置的方法，包括使用导航网格和使用传送出生点。然后，我们研究了几个传送工具包，如SteamVR和Google
    Daydream，它们提供了一套丰富的功能，以及一个丰富的用户体验，这些功能从零开始实现并不简单。如果你针对的是不同的平台，例如Oculus，也有类似的工具。
- en: In the next chapter,we'll explore the Unity physics engine more and implement
    some interactive games.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探索Unity物理引擎并实现一些交互式游戏。
