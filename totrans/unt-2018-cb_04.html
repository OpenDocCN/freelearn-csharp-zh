<html><head></head><body>
        

                            
                    <h1 class="header-title">Playing and Manipulating Sounds</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Playing different one-off sound effects with a single AudioSource</li>
<li>Playing and controlling different sounds each with their own AudioSource</li>
<li>Creating just-in-time AudioSource components at runtime through C# scripting</li>
<li>Delaying before playing a sound</li>
<li>Preventing an Audio Clip from restarting if it is already playing</li>
<li>Waiting for audio to finish playing before auto-destructing an object</li>
<li>Creating a metronome through the precise scheduling of sounds with dspTime</li>
<li>Matching the audio pitch to the animation speed</li>
<li>Simulating acoustic environments with Reverb Zones</li>
<li>Adding volume control with Audio Mixers</li>
<li>Making a dynamic soundtrack with Snapshots</li>
<li>Balancing in-game audio with Ducking</li>
<li>Audio visualization from sample spectral data</li>
<li>Synchronizing simultaneous and sequential music to create a simple 140 bpm music-loop manager</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Sound is a very important part of the gaming experience. In fact, it can't be stressed enough how crucial it is to the player's immersion in a virtual environment. Just think of the engine running in your favorite racing game, the distant urban buzz in a simulator game, or the creeping noises in horror games. Think of how these sounds transport you into the game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The big picture</h1>
                
            
            
                
<p>Before getting on with the recipes, let's first review how the different sound features work in Unity. A project with audio needs one or more audio files, which are called <strong>AudioClips</strong> in Unity, and these sit in your <strong>Project</strong> folders. At the time of writing, Unity 2017 supports four audio file formats: <kbd>.wav</kbd>, <kbd>.ogg</kbd>, <kbd>.mp3</kbd>, and <kbd>.aif</kbd>. Files in these types are re-encoded when Unity builds for a target platform. It also supports tracker modules in four formats: .xm, <strong>.mod</strong>, <strong>.</strong><strong>it</strong>, and <strong>.s3m</strong>.</p>
<p>A scene or prefab GameObject can have an <strong>AudioSource</strong> component – which can be linked to an <strong>AudioClip</strong> sound file at Design-Time, or through scripting at Run-Time. At any time in a scene, there is one active <strong>AudioListener</strong> component inside a GameObject. When you create a new scene, there is one added automatically for you in the <em>Main Camera</em>. One can think of an <strong>AudioListener</strong> as a simulated digital '"ear," since the sounds Unity plays are based on the relationship between playing <strong>AudioSources</strong> and the active <strong>AudioListener</strong>.</p>
<p>Simple sounds, such as pickup effects and background soundtrack music, can be defined as as <strong>2D sound</strong>. However, Unity supports <strong>3D sounds</strong>, which means that the location and distance between playing <strong>AudioSources</strong> and the active <strong>AudioListener</strong> determine the way the sound is perceived in terms of loudness and the left/right balance.</p>
<p>You can also engineer synchronized sound playing and scheduling through <kbd>AudioSettings.dspTime</kbd> – a value based on the samples in the audio system, so it is much more precise than the <kbd>Time.time</kbd> value. Also, <kbd>dspTime</kbd> will pause/suspend with the scene, so no logic is required for rescheduling when using <kbd>dspTime</kbd>. Several recipes in this chapter illustrate this approach.</p>
<p>In recent years, Unity has added a powerful new feature to game audio: the <strong>AudioMixer</strong>. The <strong>AudioMixer</strong> radically changes the way in which sound elements can be experienced by players and worked with by game developers. It allows us to mix and arrange audio pretty much in the same way that musicians and producers do in their <strong>Digital Audio Workstations</strong> (<strong>D.A.W.</strong>), such as <strong>GarageBand</strong> or <strong>ProTools</strong>. It allows you to route <strong>AudioSource</strong> clips into specific channels that can have their volumes individually adjusted and processed by customized effects and filters. You can work with multiple <strong>AudioMixers</strong>, send a mixer's output to a parent mixer, and save mix preferences as <strong>Snapshots</strong>. Also, you can access mixer parameters from scripting. The following figure represents the main Unity audio mixing concepts and their relationships:</p>
<div><img src="img/aeb76899-3541-4772-bfae-f4fe02750351.png"/></div>
<p>The figure above represents the main Unity audio mixing concepts and their relationships:</p>
<p>Taking advantage of the new AudioMixer feature in many example projects, this chapter is filled with recipes that will hopefully help you implement a better and more efficient sound design for your projects, augmenting the player's sense of immersion, transporting them into the game environment, and even improving the gameplay.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Future audio features</h1>
                
            
            
                
<p>The recipes demonstrate both scripted and Unity audio system approaches to managing audio and introducing dynamic effects at runtime. Games can become much more engaging when the audio environment of effects and music can subtly change based on the context of what is happening in the game – whether you chose effects such as reverb zones, ducking to de-emphasize some sounds for a while, or allow the user to control the audio volumes.</p>
<p>Finally, what is possible with special audio is now getting even more interesting, with the introduction of Ambisonic Audio when playing 3D VR games – allowing rich audio experiences based on whether sounds are above or below the listener, as well as their distance from an audio source. Some reference sources for ambisonic audio include:</p>
<ul>
<li>Wikipedia offers some history of ambisonics: <a href="https://en.wikipedia.org/wiki/Ambisonics">https://en.wikipedia.org/wiki/Ambisonics</a>.</li>
<li>Learn about Unity and ambisonic audio in the Unity docs:<a href="https://docs.unity3d.com/Manual/AmbisonicAudio.html"> https://docs.unity3d.com/Manual/AmbisonicAudio.html</a>.</li>
<li>Google's reference pages about special audio and ambisonics: <a href="https://developers.google.com/vr/concepts/spatial-audio">https://developers.google.com/vr/concepts/spatial-audio</a>.</li>
<li>Occulus reference pages about special audio and ambisonics: <a href="https://developer.oculus.com/downloads/package/oculus-ambisonics-starter-pack/">https://developer.oculus.com/downloads/package/oculus-ambisonics-starter-pack/</a>.</li>
<li>Robert Hernadez has published a great article at Medium.com disambiguating how to record and edit ambisonic audio: <a href="https://medium.com/@webjournalist/spatial-audio-how-to-hear-in-vr-10914a41f4ca">https://medium.com/@webjournalist/spatial-audio-how-to-hear-in-vr-10914a41f4ca</a>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Playing different one-off sound effects with a single AudioSource component</h1>
                
            
            
                
<p>The basics of playing a sound are very straightforward in Unity (adding an <strong>AudioSource</strong> component to a GameObject and linking it to an <strong>AudioClip</strong> sound file). For simple sound effects such as short, one-off plays of pickup confirmation noises, it's useful to have a single <strong>AudioSource</strong> component and reuse it to play different sound effects – which is what we'll do in this recipe.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Try this with any short audio clip that is less than one second in duration. We have included some classic Pacman game sound clips inside the <kbd>04_01</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To play multiple sounds using the same <strong>AudioSource</strong> component, do the following:</p>
<ol>
<li>Create a new Unity 2D project and import the sound clip files.</li>
<li>Create a C# script class, <kbd>PlaySound</kbd>s, in a new folder, <kbd>_Scripts</kbd>, containing the following code, and add an instance as a scripted component to the <strong>Main Camera</strong>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
 
[RequireComponent(typeof(AudioSource))] 
public class PlaySounds : MonoBehaviour  
{ 
    public AudioClip clipEatCherry; 
    public AudioClip clipExtraLife; 
 
    private AudioSource audioAudioSource; 
 
    void Awake() { 
        audioAudioSource = GetComponent&lt;AudioSource&gt;(); 
    } 
 
    void Update() { 
        if (Input.GetKey(KeyCode.UpArrow))
            audioAudioSource.PlayOneShot(clipEatCherry); 
 
        if (Input.GetKey(KeyCode.DownArrow)) 
            audioAudioSource.PlayOneShot(clipExtraLife); 
    } 
}</pre>
<ol start="3">
<li>Ensure that the <strong>MainCamera</strong> GameObject is selected in the <strong>Hierarchy</strong>. Then, in the <strong>Inspector</strong> panel, drag the Pacman Eating Cherry sound clip from the <strong>Project</strong> panel into the public Pacman Eating Cherry <strong>AudioClip</strong> variable in the <kbd>PlaySounds (Script)</kbd> scripted component. Repeat this procedure for the Pacman Extra Life sound clip. These steps are illustrated in the screenshot:</li>
</ol>
<div><img src="img/288ddefa-548e-4662-b08d-2adeb64b8360.png" style="width:39.17em;height:17.83em;"/></div>
<ol start="4">
<li>Run the scene, and press the <em>UP</em> and <em>DOWN</em> arrow keys to play the different sound effects.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You have created a C# script class, <kbd>PlaySounds</kbd>. The script class includes a <kbd>RequireComponent</kbd> attribute declaring that any GameObject containing a scripted object component of this class must have a sibling AudioSource component (and one will be automatically added if such a component does not exist when the scripted component is added).</p>
<p>The <kbd>PlaySounds</kbd> script class has two public <strong>AudioClip</strong> properties: <kbd>Pacman Eating Cherry</kbd> and <kbd>Pacman Extra Life</kbd>. At <strong>Design-Time</strong>, we associated <strong>AudioClip</strong> sound files from the <strong>Project</strong> panel with these public properties.</p>
<p>At runtime, the <kbd>Update()</kbd> method is executed in every frame. This method checks for the <em>UP</em> and <em>DOWN</em> array keys being pressed, and if so, plays the Eat Cherry or Extra Life sounds correspondingly – sending the <strong>AudioSource</strong> component a <kbd>PlayOneShot()</kbd> message with the appropriate <strong>AudioClip</strong> sound file link.</p>
<p>NOTE: Cannot pause/interrogate sounds played with <strong>PlayOneShot</strong><br/>
<br/> While great for short, one-off sound effects, a limitation of the <kbd>PlayOneShot()</kbd> method is that you cannot then interrogate the status of the playing sound (has it finished, at what point is it playing, and so on). Nor can you pause/restart a sound played with <kbd>PlayOneShot()</kbd>. For such detailed control of sounds, each sound needs its own AudioSource component.<br/>
<br/>
Learn more about the <kbd>PlayOneShot()</kbd> method in the Unity documentation: <a href="https://docs.unity3d.com/ScriptReference/AudioSource.PlayOneShot.html">https://docs.unity3d.com/ScriptReference/AudioSource.PlayOneShot.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Play a sound at a static point in 3D world space</h1>
                
            
            
                
<p>Similar to <kbd>PlayOneShot()</kbd> is the <kbd>PlayClipAtPoint()</kbd> <strong>AudioSource</strong> method. This allows you to play a sound clip for an <strong>AudioSource</strong> created at a specific point in 3D World Space. Note that this is a static class method – so that you don't need an <strong>AudioSource</strong> component to use this method – an <strong>AudioSource</strong> component is created (at the location you give), and will exist as long as the <strong>AudioClip</strong> sound is playing. The <strong>AudioSource</strong> component will automatically be removed by Unity once the sound has finished playing. All you need is a <kbd>Vector3</kbd> (x,y,z) position object, and a reference to the <strong>AudioClip</strong> file to be played:</p>
<pre>Vector3 location = new Vector3(10, 10, 10); 
AudioSource.PlayClipAtPoint(soundClipToPlay, location); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Playing and controlling different sounds each with their own AudioSource component</h1>
                
            
            
                
<p>While the approach in the previous recipe (using <kbd>PlayOneShot(...)</kbd> with a single <strong>AudioSource</strong>) is fine for one-off sound effects, when further control may be required over a playing sound, each sound will needs to be played in its own <strong>AudioSource</strong> component. In this recipe, we'll create two separate <strong>AudioSource</strong> components and pause/resume each with different arrow keys.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Try this with two audio clips that are several seconds long. We have included two free music clips inside folder <kbd>04_02</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To play different sounds each with their own AudioSouce component, do the following:</p>
<ol>
<li>Create a new Unity 2D project and import the sound clip files.</li>
<li>Create a GameObject in the scene containing an <strong>AudioSource</strong> component linked to the 186772__dafawe__medieval <strong>AudioClip</strong>. This can be done in a single step by dragging the music clip from the <strong>Project</strong> panel into either the <strong>Hierarchy</strong> or <strong>Scene</strong> panels. Rename this new GameObject to music1_medieval.</li>
<li>Repeat the previous step to create another GameObject named music2_arcade, containing an <strong>AudioSource</strong> linked to 251461__joshuaempyre__arcade-music-loop.</li>
<li>For both AudioSources created, uncheck the Play Awake property – so these sounds do not begin playing as soon as the scene is loaded.</li>
<li>Create an empty GameObject named Manager.</li>
</ol>
<ol start="6">
<li>Create a C# script class, MusicManager, in a new folder, <kbd>_Scripts</kbd>, containing the following code, and add an instance as a scripted component to the Manager GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
 
public class MusicManager : MonoBehaviour  { 
    public AudioSource audioSourceMedieval; 
    public AudioSource audioSourceArcade; 
 
    void Update() { 
        if (Input.GetKey(KeyCode.RightArrow)){ 
            if (audioSourceMedieval.time &gt; 0) 
                audioSourceMedieval.UnPause(); 
            else 
                audioSourceMedieval.Play(); 
        } 
 
        if (Input.GetKey(KeyCode.LeftArrow)) 
            audioSourceMedieval.Pause(); 
             
        if (Input.GetKey(KeyCode.UpArrow)){ 
            if (audioSourceArcade.time &gt; 0) 
                audioSourceArcade.UnPause(); 
            else 
                audioSourceArcade.Play(); 
        } 
 
        if (Input.GetKey(KeyCode.DownArrow)) 
            audioSourceArcade.Pause(); 
    } 
} </pre>
<ol start="7">
<li>Ensure that the <strong>Manager</strong> GameObject is selected in the <strong>Hierarchy</strong>. In the <strong>Inspector</strong> panel, drag the music1_medieval <strong>GameObject</strong> from the Scene panel into the public <strong>Audio Source Medieval</strong> AudioSource variable in the <kbd>MusicManager (Script)</kbd> scripted component. Repeat this procedure, dragging GameObject music2_arcade into the public Audio Source Arcade variable.</li>
<li>Run the scene, and press the <em>UP</em> and <em>DOWN</em> arrow keys to start/resume and pause the medieval sound clip. Press the <em>RIGHT</em> and <em>LEFT</em> arrow keys to start/resume and pause the arcade sound clip.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You created a C# script class, <kbd>MusicManager</kbd>, and added an instance of this class as a component to the Manager GameObject. You also created two <strong>GameObjects</strong>, named music1_medieval and music2_arcade, in the scene, each containing an <strong>AudioSource</strong> component linked to a different music clip.</p>
<p>The script class has two public <strong>AudioSource</strong> properties: <kbd>Music Medieval</kbd> and <kbd>Music Arcade</kbd>. At <strong>Design-Time</strong>, we associated the <strong>AudioSource</strong> components of <strong>GameObjects</strong> music1_medieval and music2_arcade with these public properties.</p>
<p>At Run-Time, the <kbd>Update()</kbd> method is executed in every frame. This method checks for the <em>UP/DOWN/RIGHT/LEFT</em> array keys being pressed. If the <em>UP</em> arrow key is detected, the medieval music audio source is sent a <kbd>Play()</kbd> or <kbd>UnPause()</kbd> message. The <kbd>Play()</kbd> message is sent if the clip is not already playing (its time property is zero). If the DOWN arrow key is pressed, the medieval music audio source is sent a <kbd>Pause()</kbd> message.</p>
<p>The arcade music clip is controlled in a corresponding way through detection of the RIGHT/LEFT array keys.</p>
<p>Each <strong>AudioClip</strong> sound file being associated with its own <strong>AudioSource</strong> component allows simultaneous playing, and managing of each sound independently.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating just-in-time AudioSource components at runtime through C# scripting</h1>
                
            
            
                
<p>In the previous recipe, for each sound clip we wanted to manage, in the scene we had to manually create <strong>GameObjects</strong> with <strong>AudioSource</strong> components at Design-Time. However, using C# scripting, we can create our own <strong>GameObjects</strong> that contain <strong>AudioSources</strong> at <strong>Run-Time</strong>, just when they are needed. This method is similar to the built-in <strong>AudioSource PlayClipAtPoint()</strong> method, but the created <strong>AudioSource</strong> component is completely under our programmatic control – although we then have to be responsible for destroying this component when it is no longer needed.</p>
<p>This code was inspired by some of the code posted in 2011 in the online <strong>Unity Answers</strong> forum by user Bunny83. Unity has a great online community helping each other and posting interesting ways of adding features to games. Learn more about that post at <a href="http://answers.unity3d.com/questions/123772/playoneshot-returns-false-for-isplaying.html">http://answers.unity3d.com/questions/123772/playoneshot-returns-false-for-isplaying.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe adapts the previous one. So, make a copy of the project for the previous recipe, and work on this copy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create just-in-time AudioSource components at run time through C# scripting do the following:</p>
<ol>
<li>Delete the music1_medieval and music-loop GameObjects from the scene – we'll be creating these at <strong>Run-Time</strong> in this recipe!</li>
<li>Refactor the <kbd>MusicManager</kbd> C# script class to read as follows (note that the <kbd>Update()</kbd> method is unchanged):</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
 
public class MusicManager : MonoBehaviour { 
    public AudioClip clipMedieval; 
    public AudioClip clipArcade; 
 
    private AudioSource audioSourceMedieval; 
    private AudioSource audioSourceArcade; 
 
    void Awake() { 
        audioSourceMedieval = CreateAudioSource(clipMedieval, true); 
        audioSourceArcade = CreateAudioSource(clipArcade, false); 
    } 
 
    private AudioSource CreateAudioSource(AudioClip audioClip, bool startPlayingImmediately) { 
        GameObject audioSourceGO = new GameObject(); 
           audioSourceGO.transform.parent = transform; 
        audioSourceGO.transform.position = transform.position; 
        AudioSource newAudioSource = audioSourceGO.AddComponent&lt;AudioSource&gt;() as AudioSource; 
        newAudioSource.clip = audioClip; 
        if(startPlayingImmediately) 
            newAudioSource.Play(); 
 
        return newAudioSource; 
    } 
 
    void Update(){ 
        if (Input.GetKey(KeyCode.RightArrow)){ 
            if (audioSourceMedieval.time &gt; 0) 
                audioSourceMedieval.UnPause(); 
            else 
                audioSourceMedieval.Play(); 
        } 
 
        if (Input.GetKey(KeyCode.LeftArrow)) 
            audioSourceMedieval.Pause(); 
         
        if (Input.GetKey(KeyCode.UpArrow)){ 
            if (audioSourceArcade.time &gt; 0) 
                audioSourceArcade.UnPause(); 
            else 
                audioSourceArcade.Play();             
        } 
 
        if (Input.GetKey(KeyCode.DownArrow)) 
            audioSourceArcade.Pause(); 
   } 
} </pre>
<ol start="3">
<li>Ensure that the <kbd>MainCamera</kbd> <strong>GameObject</strong> is selected in the <strong>Hierarchy</strong>. In the Inspector panel, drag the <strong>AudioClip</strong> 186772__dafawe__medieval sound clip from the Project panel into the public Clip Medieval <strong>AudioClip</strong> variable in the <kbd>MusicManager (Script)</kbd> scripted component. Repeat this procedure with <strong>AudioClip</strong> 251461__joshuaempyre__arcade-music-loop for the Clip Arcade variable.</li>
<li>Run the scene, and press the <em>UP</em> and <em>DOWN</em> arrow keys to start/resume and pause the medieval sound clip. Press the <em>RIGHT</em> and <em>LEFT</em> arrow keys to start/resume and pause the arcade sound clip.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The key feature of this recipe is the new <kbd>CreateAudioSource(...)</kbd> method. This method takes input as a reference to a sound clip file and a Boolean true/false value as to whether the sound should start playing immediately. The method does the following:</p>
<ul>
<li>Creates a new <strong>GameObject</strong> (with the same parent, and at the same location as the <strong>GameObject</strong> doing the creating)</li>
<li>Adds a new <strong>AudioSource</strong> component to the new <strong>GameObject</strong></li>
<li>Sets the audio clip of the new AudioSource component to the provided AudioClip parameter</li>
<li>If the Boolean parameter was true, the <strong>AudioSource</strong> component is immediately sent a <kbd>Play()</kbd> message to start it playing the sound clip</li>
<li>A reference to the AudioSource component is returned</li>
</ul>
<p>The rest of the <kbd>MusicManager</kbd> script class is very similar to that in the previous recipe. There are two public <kbd>AudioClip</kbd> variables, <kbd>clipMedieval</kbd> and <kbd>clipArcade</kbd>, which are set through drag-and-drop at <strong>Design-Time</strong> to link to the sound clip files in <strong>Sounds Project</strong> folder.</p>
<p>The <kbd>audioSourceMedieval</kbd> and <kbd>audioSourceArcade AudioSource</kbd> variables are now private. These values are set up in the <kbd>Awake(</kbd>) method, by calling and storing values returned by the <kbd>CreateAudioSource(...)</kbd> method with the <strong>clipMedieval</strong> and <kbd>clipArcade</kbd> AudioClip variables.</p>
<p>To illustrate how the Boolean parameter works, the medieval music <strong>AudioSource</strong> is created to play immediately, while the arcade music won't start playing until the <em>UP</em> arrow key is pressed. Playing/Resuming/Pausing the two audio clips is just the same as in the previous recipe – via the arrow-key detection logic in the (unchanged) <kbd>Update()</kbd> method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding the CreateAudioSource(...) method as an extension to the MonoBehavior class</h1>
                
            
            
                
<p>Since the <kbd>CreateAudioSource(...)</kbd> method is a general-purpose method that could be used by many different game script classes, it doesn't naturally sit within the <kbd>MusicManager</kbd> class. The best place for general-purpose generative methods such as this is to add them as static (class) methods to the component class they work with – in this case it would be great if we could add this method to <kbd>MonoBehavior</kbd> class itself – so any scripted component could create <strong>AudioSource</strong> GameObjects on the fly.</p>
<p>All we have to do is create a class (usually named <kbd>ExtensionMethods</kbd>) with a static method, as follows:</p>
<pre>using UnityEngine; 
 
public static class ExtensionMethods { 
    public static AudioSource CreateAudioSource(this MonoBehaviour parent, AudioClip audioClip, bool startPlayingImmediately) 
    { 
         GameObject audioSourceGO = new GameObject("music-player"); 
         audioSourceGO.transform.parent = parent.transform; 
         audioSourceGO.transform.position = parent.transform.position; 
         AudioSource newAudioSource = audioSourceGO.AddComponent&lt;AudioSource&gt;() as AudioSource; 
         newAudioSource.clip = audioClip; 
 
         if (startPlayingImmediately) 
               newAudioSource.Play(); 
 
         return newAudioSource; 
    } 
} </pre>
<p>As we can see, we add an extra first parameter to the extension method, stating which class we are adding this method to. Since we have added this to the <kbd>MonoBehavior</kbd> class, we can now use this method in our scripted classes as if it were built-in. So our <kbd>Awake()</kbd> method in our <kbd>MusicManager</kbd> class looks as follows:</p>
<pre>void Awake() { 
   audioSourceMedieval = this.CreateAudioSource(clipMedieval, true); 
   audioSourceArcade = this.CreateAudioSource(clipArcade, false); 
} </pre>
<p>That's it – we can now remove the method from our <kbd>MusicManager</kbd> class and use this method in any of our <kbd>MonoBehavior</kbd> scripted classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Delaying before playing a sound</h1>
                
            
            
                
<p>Sometimes we don't want to play a sound immediately, but after a short delay. For example, we might want to wait a second or two before playing a sound to indicate the slightly delayed onset of a poison drunk or having walked into a spell that weakens the player. For such cases, <strong>AudioSource</strong> offers the <kbd>PlayDelayed(...)</kbd> method. This recipe illustrates a simple approach for such cases where we do not wish to immediately start playing a sound.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Try this with two audio clips that are several seconds long. We have included two free music clips inside the <kbd>04_04</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To schedule a sound to play after a given delay, do the following:</p>
<ol>
<li>Create a new Unity 2D project and import the sound clip files.</li>
<li>Create a <strong>GameObject</strong> in the scene containing an <strong>AudioSource</strong> component linked to the <strong>Pacman Opening Song</strong> <strong>AudioClip</strong>. This can be done in a single step by dragging the music clip from the Project panel into either the <strong>Hierarchy</strong> or <strong>Scene</strong> panels.</li>
<li>Repeat the previous step to create another <strong>GameObject</strong>, containing an <strong>AudioSource</strong> linked to the Pacman Dies clip.</li>
<li>For both <strong>AudioSources</strong> created, uncheck the Play Awake property – so these sounds do not begin playing as soon as the scene is loaded.</li>
<li>Create a <strong>UI Button</strong> named <strong>Button-music</strong> on the screen, changing its text to Play Music Immediately.</li>
<li>Create a <strong>UI Button</strong> named <strong>Button-dies</strong> on the screen, changing its text to Play Dies Sound After 1 second.</li>
</ol>
<ol start="7">
<li>Create an empty <strong>GameObject</strong> named SoundManager.</li>
<li>Create a C# script class, DelayedSoundManager, in a new folder, <kbd>_Scripts</kbd>, containing the following code, and add an instance as a scripted component to the SoundManager <strong>GameObject</strong>:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
 
public class DelayedSoundManager : MonoBehaviour { 
    public AudioSource audioSourcePacmandMusic; 
    public AudioSource audioSourceDies; 
 
    public void ACTION_PlayMusicNow() { 
        audioSourcePacmandMusic.Play(); 
    } 
 
    public void ACTION_PlayDiesSoundAfterDelay() { 
        float delay = 1.0F; 
        audioSourceDies.PlayDelayed(delay); 
    } 
} </pre>
<ol start="9">
<li>With the Button-music <strong>GameObject</strong> selected in the Hierarchy panel, create a new on-click event-handler, dragging the SoundsManager <strong>GameObject</strong> into the Object slot, and selecting the ACTION_PlayMusicNow() method.</li>
<li>With the Button-dies GameObject selected in the Hierarchy panel, create a new on-click event-handler, dragging the SoundsManager GameObject into the Object slot, and selecting the ACTION_PlayDiesSoundAfterDelay() method.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You add two <strong>GameObjects</strong> to the scene, containing <kbd>AudioSources</kbd> linked to music and dying sound clips. You created a C# script class, <kbd>DelayedSoundManager</kbd>, and added an instance to an empty <strong>GameObject</strong>. You associated the two AudioSources in your <strong>GameObjects</strong> with the two public variables in your scripted component.</p>
<p>You created two buttons:</p>
<ul>
<li>Button-music, with a click action to invoke the <kbd>DelayedSoundManager.ACTION_PlayMusicNow()</kbd> method</li>
<li>Button-dies, with a click action to invoke the <kbd>DelayedSoundManager.PlayDiesSoundAfterDelay()</kbd> method.</li>
</ul>
<p class="mce-root"/>
<p>The <kbd>DelayedSoundManager.ACTION_PlayMusicNow()</kbd> method immediately sends a Play() message to the audio source linked to the <strong>Pacman Opening Song AudioClip</strong>. However, the <kbd>DelayedSoundManager.PlayDiesSoundAfterDelay()</kbd> method sends a PlayDelayed(...) message to the audio source linked to the <strong>Pacman Dies AudioClip</strong>, passing a value of 1.0, making Unity wait 1 second before playing the sound clip.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preventing an Audio Clip from restarting if it is already playing</h1>
                
            
            
                
<p>In a game, there may be several different events that cause a particular sound effect to start playing. If the sound is already playing, then in almost all cases, we won't wish to restart the sound. This recipe includes a test, so that an Audio Source component is only sent a <kbd>Play()</kbd> message if it is currently not playing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Try this with any audio clip that is one second or longer in duration. We have included the engineSound audio clip inside the <kbd>04_05</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To prevent an <strong>AudioClip</strong> from restarting, follow these steps:</p>
<ol>
<li>Create a new Unity 2D project and import the sound clip file.</li>
<li>Create a GameObject in the scene containing an <strong>AudioSource</strong> component linked to the <kbd>AudioClip engineSound</kbd>. This can be done in a single step by dragging the music clip from the Project panel into either the Hierarchy or Scene panels.</li>
<li>Uncheck the Play Awake property for the <strong>AudioSource</strong> component of the engineSound GameObject – so this sound does not begin playing as soon as the scene is loaded.</li>
<li>Create a UI button named <strong>Button-play-sound</strong>, changing its text to Play Sound. Position the button in the center of the screen by setting its Rect <strong>Transform</strong> property position to middle-center.</li>
</ol>
<ol start="5">
<li>Create a C# script class, <kbd>WaitToFinishBeforePlaying</kbd>, in a new folder, <kbd>_Scripts</kbd>, containing the following code, and add an instance as a scripted component to the Main Camera GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
using UnityEngine.UI; 
 
public class WaitToFinishBeforePlaying : MonoBehaviour  { 
   public AudioSource audioSource; 
   public Text buttonText; 
 
   void Update() { 
         string statusMessage = "Play sound"; 
         if(audioSource.isPlaying ) 
               statusMessage = "(sound playing)"; 
 
         buttonText.text = statusMessage; 
   } 
 
   public void ACTION_PlaySoundIfNotPlaying() { 
         if( !audioSource.isPlaying ) 
               audioSource.Play(); 
   } 
} </pre>
<ol start="6">
<li>With Main Camera selected in the <strong>Hierarchy</strong> panel, drag engineSound into the Inspector panel for the public Audio Source variable, and drag the Text child of Button-play-sound for the public ButtonText.</li>
<li>With Button-play-sound selected in the Hierarchy panel, create a new on-click event-handler, dragging the Main Camera into the Object slot, and selecting the <kbd>ACTION_PlaySoundIfNotPlaying()</kbd> function.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p><strong>Audio Source</strong> components have a public readable property, <strong>isPlaying</strong>, which is a Boolean true/false flag, indicating whether the sound is currently playing. In this recipe, the text of the button is set to display Play Sound when the sound is not playing, and (<kbd>sound playing</kbd>) when it is. When the button is clicked, the <kbd>ACTION_PlaySoundIfNotPlaying()</kbd> method is called. This method uses an <kbd>if</kbd> statement, ensuring that a <kbd>Play()</kbd> message is only sent to the Audio Source component if its <strong>isPlaying</strong> is false, and updates the button's text as appropriate.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>The <em>Waiting for the audio to finish playing before auto-destructing an object</em> recipe in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Waiting for the audio to finish playing before auto-destructing an object</h1>
                
            
            
                
<p>An event may occur (such as an object pickup or the killing of an enemy) that we wish to notify to the player of by playing an audio clip, and an associated visual object (such as an explosion particle system, or a temporary object in the location of the event). However, as soon as the clip has finished playing, we will want the visual object to be removed from the scene. This recipe provides a simple way to link the ending of a playing audio clip with the automatic destruction of its containing object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Try this with any audio clip that is a second or more in duration. We have included the <kbd>engineSound</kbd> audio clip inside the <kbd>04_06</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To wait for audio to finish playing before destroying its parent GameObject, follow these steps:</p>
<ol>
<li>Create a new Unity 2D project and import the sound clip file.</li>
<li>Create a GameObject in the scene containing an <strong>AudioSource</strong> component linked to the <strong>AudioClip</strong> <strong>engineSound</strong>. This can be done in a single step by dragging the music clip from the Project panel into either the <strong>Hierarchy</strong> or <strong>Scene</strong> panels. Rename this the AudioObject GameObject.</li>
<li>Uncheck the Play Awake property for the AudioSource component of the <strong>GameObject</strong> engineSound – so this sound does not begin playing as soon as the scene is loaded.</li>
</ol>
<ol start="4">
<li>Create a C# script class, <kbd>AudioDestructBehaviour</kbd>, in a new folder, <kbd>_Scripts</kbd>, containing the following code, and add an instance as a scripted component to the AudioObject GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
using UnityEngine; 
 
public class AudioDestructBehaviour : MonoBehaviour { 
   private AudioSource audioSource; 
 
   void Awake() { 
         audioSource = GetComponent&lt;AudioSource&gt;(); 
   } 
 
   private void Update() { 
         if( !audioSource.isPlaying ) 
               Destroy(gameObject); 
   } 
} </pre>
<ol start="5">
<li>In the <strong>Inspector</strong> panel, disable (uncheck) the <kbd>AudioDestructBehaviour</kbd> scripted component of AudioObject (when needed, it will be re-enabled via C# code):</li>
</ol>
<div><img src="img/ea58c4f8-5e25-4d9e-9dbc-1584ab99cb18.png"/></div>
<ol start="6">
<li>Create a C# script class, <kbd>ButtonActions</kbd>, in the <kbd>_Scripts</kbd> folder, containing the following code, and add an instance as a scripted component to the Main Camera GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
 
public class ButtonActions : MonoBehaviour { 
   public AudioSource audioSource; 
 
   public AudioDestructBehaviour audioDestructScriptedObject; 
 
   public void ACTION_PlaySound() { 
         if( !audioSource.isPlaying ) 
               audioSource.Play(); 
   } 
 
   public void ACTION_DestroyAfterSoundStops(){ 
         audioDestructScriptedObject.enabled = true; 
   } 
} </pre>
<ol start="7">
<li>With Main Camera selected in the <strong>Hierarchy</strong> panel, drag AudioObject into<br/> the <strong>Inspector</strong> panel for the public Audio Source variable.</li>
<li>With Main Camera selected in the <strong>Hierarchy</strong> panel, drag AudioObject into<br/>
the <strong>Inspector</strong> panel for the public Audio Destruct Scripted Object variable.</li>
<li>Create a UI button named <strong>Button-play-sound</strong>, changing its text to Play Sound. Position the button in the center of the screen by setting its <strong>Rect Transform</strong> property to middle-center.</li>
<li>With Button-play-sound selected in the <strong>Hierarchy</strong> panel, create a new on-click event-handler, dragging the Main Camera into the Object slot, and selecting the <kbd>ACTION_PlaySound()</kbd> function.</li>
<li>Create a second UI button named Button-destroy-when-finished-playing, changing its text to Destroy When Sound Finished. Position the button in the center of the screen (just below the other button) by setting its <strong>Rect Transform</strong> property to middle-center and then drag the button down a little.</li>
<li>With Button-destroy-when-finished-playing selected in the <strong>Hierarchy</strong> panel, create a new on-click event-handler, dragging the Main Camera into the Object slot, and selecting the <kbd>ACTION_ DestroyAfterSoundStops()</kbd> function.</li>
<li>Run the scene. Clicking the Play Sound button will play the engine sound each time. However, once the Destroy When Sound Finished button has been clicked, as soon as the engineSound finished playing, you'll see the AudioObject GameObject disappear from the <strong>Hierarchy</strong> panel, since the GameObject has destroyed itself.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You created a ButtonActions script class and added an instance as a component to the Main Camera <strong>GameObject</strong>. This has two public variables, one to an <strong>AudioSource</strong> and one to an instance of the AudioDestructBehaviour scripted component.</p>
<p class="mce-root"/>
<p>The GameObject named <strong>AudioObject</strong> contains an <strong>AudioSource</strong> component, which stores and manages the playing of the audio clip. <strong>AudioObject</strong> also contains a scripted component, which is an instance of the <kbd>AudioDestructBehaviour</kbd> class. This script is initially disabled. When enabled, every frame in this object (via its <kbd>Update()</kbd> method) tests whether the audio source is playing (<kbd>!audio.isPlaying</kbd>). As soon as the audio is found to be not playing, the GameObject is destroyed.</p>
<p>There are two UI buttons created. The <strong>Button-play-sound</strong> button calls the <kbd>ACTION_PlaySound()</kbd> method of the scripted component in <strong>Main Camera</strong>. This method will start playing the audio clip, if it is not already playing.</p>
<p>The second button, <strong>Button-destroy-when-finished-playing</strong>, calls the <kbd>ACTION_</kbd><kbd>DestoryAfterSoundStops()</kbd> method of the scripted component in Main Camera. This method enables the <strong>AudioDestructBehaviour</strong> scripted component in the <strong>AudioObject</strong> GameObject – so that the <strong>AudioObject GameObject</strong> will be destroyed, once its <strong>AudioSource</strong> sound has finished playing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>The <em>Preventing an Audio Clip from restarting if it is already playing</em> recipe in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a metronome through the precise scheduling of sounds with dspTime</h1>
                
            
            
                
<p>In cases where we need precise scheduling of when sounds play, we should use the <kbd>AudioSource.PlayScheduled(...)</kbd> method. This method uses the <kbd>AudioSettings.dspTime</kbd> value, which is highly accurate based on the playing of music data through the Unity audio system. Another advantage of the <kbd>dspTime</kbd> value is that is it independent of the graphical rendering frame rate:</p>
<div><img src="img/14fad81a-0b48-4ccc-bb69-4fa176b67d3d.png" style="width:23.33em;height:14.33em;"/></div>
<p>Note that the <kbd>dspTime</kbd> value is automatically frozen when a game is paused or suspended – so music scheduled using this approach will pause and resume flawlessly along with the scene gameplay. In this recipe, we'll create a metronome by precisely scheduling when two different sounds will play. Note that this recipe is based on some examples from the Unity documentation for the <kbd>AudioSource.PlayScheduled(...)</kbd> method: <a href="https://docs.unity3d.com/ScriptReference/AudioSource.PlayScheduled.html">https://docs.unity3d.com/ScriptReference/AudioSource.PlayScheduled.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have provided two metronome sound clips inside the <kbd>04_07</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To schedule a sound to play after a given delay, do the following:</p>
<ol>
<li>Create a new Unity 2D project and import the provided sound clip files.</li>
<li>Create a GameObject in the scene containing an <strong>AudioSource</strong> component linked to the <strong>metronome_tick AudioClip</strong>. This can be done in a single step by dragging the music clip from the Project panel into either the <strong>Hierarchy</strong> or <strong>Scene</strong> panels.</li>
<li>Repeat the previous step to create another GameObject, containing an <strong>AudioSource</strong> linked to the metronome_tick_accent clip.</li>
</ol>
<ol start="4">
<li>For both <strong>AudioSources</strong> created, uncheck the Play Awake property – so these sounds do not begin playing as soon as the scene is loaded.</li>
<li>Create an empty GameObject named MetronomeManager.</li>
<li>Create a C# script class, Metronome, in a new folder, <kbd>_Scripts</kbd>, containing the following code, and add an instance as a scripted component to the MetronomeManager GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
 
public class Metronome : MonoBehaviour { 
    public AudioSource audioSourceTickBasic; 
    public AudioSource audioSourceTickAccent; 
 
    public double bpm = 140.0F; 
    public int beatsPerMeasure = 4; 
 
    private double nextTickTime = 0.0F; 
    private int beatCount; 
    private double beatDuration; 
 
    void Start() { 
        beatDuration = 60.0F / bpm; 
        beatCount = beatsPerMeasure; // so about to do a beat 
        double startTick = AudioSettings.dspTime; 
        nextTickTime = startTick; 
    } 
 
    void Update() { 
        if (IsNearlyTimeForNextTick()) 
            BeatAction(); 
    } 
 
    private bool IsNearlyTimeForNextTick() { 
        float lookAhead = 0.1F; 
        if ((AudioSettings.dspTime + lookAhead) &gt;= nextTickTime) 
            return true; 
        else 
            return false; 
    } 
 
    private void BeatAction() { 
        beatCount++; 
        string accentMessage = ""; 
 
        if (beatCount &gt; beatsPerMeasure) 
            accentMessage = AccentBeatAction(); 
        else 
            audioSourceTickBasic.PlayScheduled(nextTickTime); 
 
        nextTickTime += beatDuration; 
        print("Tick: " + beatCount + "/" + signatureHi + accentMessage); 
    } 
 
    private string AccentBeatAction() { 
        audioSourceTickAccent.PlayScheduled(nextTickTime); 
        beatCount = 1; 
        return " -- ACCENT ---"; 
    } 
} </pre>
<ol start="7">
<li>Select the MetronomeManager GameObject in the Hierarchy. Drag metronome_tick from the Hierarchy into the <strong>Inspector</strong> Audio Source Tick Basic public variable, for the Metronome (Script) component.</li>
<li>Drag metronome_tick_accent from the Hierarchy into the Inspector Audio Source Tick Accent public variable, for the Metronome (Script) component:</li>
</ol>
<div><img src="img/cd68dae0-aece-415a-b050-2e78d38f168e.png" style="width:41.42em;height:19.33em;"/></div>
<ol start="9">
<li>Play the scene. You will see (in the Console) and hear the regular metronome sounds, with the first beat of each count playing the accented (and louder) sound.</li>
</ol>
<ol start="10">
<li>Try changing the Bpm (beats per minute) setting, to speed up or slow down the metronome. Or change the number of Beats Per Measure, to count up to 3, 4, or 6 beats between each accented beat.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You add to the scene two GameIObjects, containing AudioSources linked to music clips for a basic and an accented metronome "tick." You created a Metronome C# script class and added an instance to an empty GameObject. You associated the two AudioSources in your GameObjects with the two public variables in your scripted component.</p>
<p>The <kbd>Start()</kbd> method calculates the duration of each beat (based on bpm), initializes the beat count (so the first beat is an accented beat), and then sets <kbd>nextTickTime</kbd>, the time for the next tick to the current dspTime.</p>
<p>The <kbd>IsNearlyTimeForNextTick()</kbd> method returns a Boolean true/false value indicating if it is nearly time to schedule the next tick. The value returned is based on whether the current <kbd>dspTime</kbd> is within 1/10<sup>th</sup> of a second of the value of <kbd>nextTickTime</kbd>. If so, then true is returned.</p>
<p>The <kbd>Update()</kbd> method is a single if statement. If it's nearly time for the next beat, the <kbd>BeatAction()</kbd> method is invoked.</p>
<p>The <kbd>BeatAction()</kbd> method does the following:</p>
<ul>
<li>Adds 1 to the number of beats</li>
<li>Initializes the accentMessage string to be empty (the default)</li>
<li>IF:<br/>
the next beat should be 1 (the accent), AccentBeatAction() and the string returned are stored in accentMessage</li>
<li>ELSE (if not accent next beat):<br/>
the basic beat sound is scheduled</li>
<li>The next beat time is calculated (current beat time + duration of each beat)</li>
<li>It displays the beat count message in Console (including the string for any accent message)</li>
</ul>
<p>The AccentBeatAction() method does three things: it schedules the accented beat sound, it resets the beat count to 1, and it returns a string to be shown with the beat message (with text to indicate an accent beat is next: -- ACCENT ---).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating just-in-time AudioSource GameObjects for the basic and accented beats</h1>
                
            
            
                
<p>We can reduce the Design-Time work for the metronome by making use of the Extension method presented in the <em>Creating just-in-time AudioSource components at runtime through C# scripting</em> recipe.</p>
<p>First, copy the <kbd>ExtensionMethods.cs</kbd>  C# script class into your metronome project. Next, delete the two GameObjects in the scene containing <strong>AudioSource</strong> components, and instead declare two public variables for each <kbd>AudioClip ()</kbd>. Finally, we just need to write an <kbd>Awake()</kbd> method that will create the required GameObjects in the scene containing <strong>AudioSource</strong> basic on the <strong>AudioClip</strong> variables (and making the basic beat quieter than the accented one):</p>
<pre>void Awake() { 
   audioSourceTickBasic = this.CreateAudioSource(clipTickBasic, false); 
   audioSourceTickBasic.volume = 0.5F; 
 
   audioSourceTickAccent = this.CreateAudioSource(clipTickAccent, false); 
   audioSourceTickAccent.volume = 1.00F; 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating beat sounds through data rather than AudioClips</h1>
                
            
            
                
<p>The Unity documentation about <kbd>dspTime</kbd> provides an interesting approach to creating the basic and accented beats for a metronome – though editing the audio data samples themselves. Check out their scripted metronome at <a href="https://docs.unity3d.com/ScriptReference/AudioSettings-dspTime.html">https://docs.unity3d.com/ScriptReference/AudioSettings-dspTime.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Matching the audio pitch to the animation speed</h1>
                
            
            
                
<p>Many artifacts sound higher in pitch when accelerated and lower when slowed down. Car engines, fan coolers, a record player... the list goes on. If you want to simulate this kind of sound effect in an animated object that can have its speed changed dynamically, follow this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, you'll need an animated 3D object and an audio clip. Please use the <kbd>animatedRocket.fbx</kbd> and <kbd>engineSound.wav</kbd> files, available in the <kbd>04_08</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To change the pitch of an audio clip according to the speed of an animated object, please follow these steps:</p>
<ol>
<li>Create a new Unity 3D project.</li>
<li>Create a new Models folder in the Project panel, and into this import the provided animatedRocket.fbx file.</li>
<li>Create a new Sounds folder in the Project panel, and into this Import the provided audio clip, engineSound.wav.</li>
<li>Select the animatedRocket file in the Project panel. In the Inspector for animatedRocket Import Settings, click the Animations button. In Animations select (the only) Take 001 clip, and make sure to check the Loop Time option. Click on the Apply button to save the changes. See the screenshot for these settings:</li>
</ol>
<div><img src="img/287379b6-8649-4823-9ee6-d6dbd243f51d.png" style="width:28.58em;height:36.58em;"/></div>
<p>The reason we didn't need to check <strong>Loop Pose</strong> option is because our animation already loops in a seamless fashion. If it didn't, we could have checked that option to automatically create a seamless transition from the last to the first frame of the animation.</p>
<ol start="5">
<li>Add an instance of <kbd>animatedRocket</kbd> as a GameObject in the scene by dragging it from the <strong>Project</strong> panel into the Scene or <strong>Hierarchy</strong> panel.</li>
<li>Add an AudioSource component to the engineSound GameObject.</li>
</ol>
<ol start="7">
<li>With engineSound selected in the <strong>Hierarchy</strong>, drag the engineSound AudioClip file from the <strong>Project</strong> panel into the <strong>Inspector</strong> for the <strong>Audio Clip</strong> parameter of the Audio Source component. Ensure the Loop option is checked, and the Play On Awake option is unchecked:</li>
</ol>
<div><img src="img/76e48ab6-4c24-4282-a9ed-7f01865ee829.png" style="width:28.75em;height:23.08em;"/></div>
<ol start="8">
<li>Create an Animator Controller for our model. Select the Models folder in the Project panel, and use the Create menu to create a new <strong>Animator</strong> Controller file named Rocket Controller.</li>
<li>Double-click the Rocket Controller file in the Project panel to open the <strong>Animator</strong> panel. Create a new state by choosing menu option: Create State | Empty (as shown in the screenshot):</li>
</ol>
<div><img src="img/0851aa59-05c6-44b6-a4dd-671a7322b5c6.png" style="width:32.17em;height:12.33em;"/></div>
<ol start="10">
<li>Rename this new state spin (in its <strong>Inspector</strong> properties), and set Take 001 as its motion in the Motion field:</li>
</ol>
<div><img src="img/f3bc6c09-492f-46a9-9f72-e6a5830cfb12.png" style="width:37.08em;height:13.42em;"/></div>
<ol start="11">
<li>Select animatedRocket in the <strong>Hierarchy</strong> panel. Drag Rocket Controller from the <kbd>Models</kbd> folder in the Project panel into the Controller parameter for the Animator component in the <strong>Inspector</strong>. Ensure that the Apply Root Motion option is unchecked in the <strong>Inspector</strong>:</li>
</ol>
<div><img src="img/4d01c174-4d66-42a1-b905-887aba4211fa.png" style="width:37.25em;height:18.17em;"/></div>
<ol start="12">
<li>Create a C# script class, <kbd>ChangePitch</kbd>, in the <kbd>_Scripts</kbd> folder, containing the following code, and add an instance as a scripted component to the <kbd>animatedRocket</kbd> GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
 
public class ChangePitch : MonoBehaviour{ 
   public float acceleration = 0.05f; 
   public float minSpeed = 0.0f; 
   public float maxSpeed = 2.0f; 
   public float animationSoundRatio = 1.0f; 
 
   private float speed = 0.0f; 
   private Animator animator; 
   private AudioSource audioSource; 
 
    private void Awake() { 
        animator = GetComponent&lt;Animator&gt;(); 
        audioSource = GetComponent&lt;AudioSource&gt;(); 
    } 
 
    void Start() { 
         speed = animator.speed; 
        AccelerateRocket (0); 
   }      
 
   void Update() { 
         if (Input.GetKey (KeyCode.Alpha1)) 
            AccelerateRocket(acceleration); 
          
         if (Input.GetKey (KeyCode.Alpha2)) 
            AccelerateRocket(-acceleration); 
   } 
 
   public void AccelerateRocket(float acceleration) { 
         speed += acceleration; 
         speed = Mathf.Clamp(speed,minSpeed,maxSpeed); 
         animator.speed = speed; 
         float soundPitch = animator.speed * animationSoundRatio; 
         audioSource.pitch = Mathf.Abs(soundPitch); 
   } 
} </pre>
<ol start="13">
<li>Play the scene and change the animation speed by pressing number key 1 (accelerate) and 2 (decelerate) on your keyboard. The audio pitch will change accordingly.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You created a C# script class, <strong>ChangePitch</strong>, and added an instance to the <strong>animatedRocket</strong> GameObject. It declares several variables, the most important of which is <kbd>acceleration</kbd>.</p>
<p>It's <kbd>Awake()</kbd> method caches references to the Animator and <strong>AudioSource</strong> sibling components. The <kbd>Start()</kbd> method sets the initial speed from the <strong>Animator</strong>, and calls the <kbd>AccelerateRocket(...)</kbd> method, passing 0 to calculate the resulting pitch for the Audio Source.</p>
<p>In each frame, the Update() method tests for keyboard keys 1 and 2. When detected, they call the <kbd>AccelerateRocket(...)</kbd> method, passing a positive or negative value of acceleration as appropriate.</p>
<p>The <kbd>AccelerateRocket(...)</kbd> method increments variable speed with the received argument. The <kbd>Mathf.Clamp()</kbd> command limits the new speed value between the minimum and maximum speed. Then, it changes the <strong>Animator</strong> speed and <strong>Audio Source</strong> pitch according to the new speed absolute (positive) value. The value is then clamped a second time to avoid negative numbers. If you wish to reverse the animation, check out the code files in the solution provided for this recipe.</p>
<p>Please note that setting the animation speed, and therefore the sound pitch, to 0 will cause the sound to stop, making it clear that stopping the object's animation also prevents the engine sound from playing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here is some information on how to fine-tune and customize this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing the Animation/Sound Ratio</h1>
                
            
            
                
<p>If you want the audio clip pitch to be more or less affected by the animation speed, change the value of the public Animation/Sound Ratio parameter in the Inspector.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Accessing the function from other scripts</h1>
                
            
            
                
<p>The <kbd>AccelerateRocket(...)</kbd> function was made public so that it can be accessed from other scripts. As an example, we have included the <kbd>ExternalChangePitch.cs</kbd> script in the <kbd>_Scripts</kbd> folder. To illustrate how the <strong>ChangePitch</strong> scripted component can be controlled form another script, do the following:</p>
<ol>
<li>Attach this script to the <strong>Main Camera</strong> GameObject. Drag the <strong>animatedRocket</strong> GameObject from the Hierarchy into the public <strong>Change Pitch Scripted Component</strong> variable.</li>
<li>Run the scene.</li>
<li>Use the <em>UP</em> and <em>DOWN</em> arrow keys to control the animation speed (and sound pitch).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Allowing reverse animation (negative speeds!)</h1>
                
            
            
                
<p>In the Animator panel, create a new Float parameter, <strong>Speed</strong>, initialized to 1.0. With state spin selected in the <strong>Animator</strong> panel, check the <strong>Speed Parameter Multiplier</strong> option and choose the <strong>Speed</strong> parameter. In the Inspector, set <strong>Min Speed</strong> to -2, to allow negative speeds for animations.</p>
<p>In the <strong>ChangePitch</strong> C# script, replace the <strong>AccelerateRocket</strong> method with the following:</p>
<pre>public void AccelerateRocket(float acceleration) { 
   speed += acceleration;  
   speed = Mathf.Clamp(speed, minSpeed, maxSpeed); 
 
   animator.SetFloat("Speed", speed); 
   float soundPitch = speed * animationSoundRatio; 
   audioSource.pitch = Mathf.Abs(soundPitch); 
} </pre>
<p>Now when you use key 1 (accelerate) and 2 (decelerate), you can actually decelerate to zero and then continue to reverse the animation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Simulating acoustic environments with Reverb Zones</h1>
                
            
            
                
<p>Once you have created your level's geometry and the scene is looking just the way you want it to, you might want your sound effects to correspond to that look. Sound behaves differently depending upon the environment in which it is projected, so it can be a good idea to make it reverberate accordingly. In this recipe, we will address this acoustic effect by using Reverb Zones.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared the <kbd>ReverbZone.unitypackage</kbd> file, containing a basic level named <strong>reverbScene</strong> and a prefab, Signal. The package can be found in the <kbd>04_09</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps to simulate the sonic landscape of a tunnel:</p>
<ol>
<li>Create a new Unity 3D project.</li>
<li>Import the provided <strong>Unity</strong> package, <strong>ReverbZone</strong>, into your project.</li>
<li>From the Project panel, open <strong>reverbScene</strong> – it's in the <kbd>_Scenes</kbd> folder in the <kbd>ReverbZones</kbd> folder. This scene gives you a tunnel, and a controllable character (<em>W A S D</em> keys and <em>Shift</em> to run).</li>
</ol>
<ol start="4">
<li>From the Project panel, drag the Signal prefab into the Hierarchy – it's in the <kbd>_Prefabs</kbd> folder in the <kbd>ReverbZones</kbd> folder. This will add a sound-emitting object to the scene. Place it in the center of the tunnel:</li>
</ol>
<div><img src="img/c5f6e601-504a-4af4-a12e-8db352f55463.png" style="width:34.50em;height:29.75em;"/></div>
<ol start="5">
<li>Make five copies of the <strong>Signal</strong> GameObject and distribute them throughout the tunnel (leaving a copy just outside each entrance):</li>
</ol>
<div><img src="img/496916f1-7221-4a49-b39c-60114dedfdd3.png"/></div>
<ol start="6">
<li>In the Hierarchy panel, use the <strong>Create menu</strong> | <strong>Audio</strong> | <strong>Audio Reverb Zone</strong> to add a <strong>Reverb Zone</strong> to the scene. Then place this new GameObjct in the center of the tunnel.</li>
</ol>
<p>Use menu GameObject | Move To View if there is already a GameObject where you want to position another one. Since our Signal GameObject is in the middle of the tunnel, we can double-click that GameObject, then single-click Reverb Zone and move to view – to move the Reverb Zone object to the same location.</p>
<ol start="7">
<li>Select the <strong>Reverb Zone</strong> GameObject. In the Inspector panel, change the <strong>Reverb Zone</strong> component parameters to these values: <strong>Min Distance</strong> = <kbd>6</kbd>, <strong>Max Distance</strong> = <kbd>18</kbd>, and <strong>Preset</strong> = <kbd>StoneCorridor</kbd>:</li>
</ol>
<div><img src="img/5bd41d25-65a8-4e4f-9c0b-266f32bf832b.png"/></div>
<ol start="8">
<li>Play the scene. As you walk through the tunnel, you will hear the audio reverberate when inside the Reverb Zone area.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Once positioned, the Audio Reverb Zone applies an audio filter to all audio sources within its radius.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are more options for you to try.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Attaching the Audio Reverb Zone component to Audio Sources</h1>
                
            
            
                
<p>Instead of creating an Audio Reverb Zone GameObject, you can attach it to the sound-emitting object (in our case, Signal) as a component through the <strong>Component</strong> | <strong>Audio</strong> | <strong>Audio</strong> <strong>Reverb Zone</strong> menu. In such cases, the Reverb Zone will be individually set up around its parent GameObject.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making your own Reverb settings</h1>
                
            
            
                
<p>Unity comes with several <strong>Reverb Presets</strong>. We have used <strong>StoneCorridor</strong>, but your scene can ask for something less intense (such as Room) or more radical (such as Psychotic). If these presets still won't be able to recreate the effect that you have in mind, change it to User and edit its parameters as you wish.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding volume control with Audio Mixers</h1>
                
            
            
                
<p>Sound-volume adjustment can be a very important feature, especially if your game is a standalone. After all, it can be very frustrating for players to have to access the <strong>Operating System</strong> volume control. In this recipe, we will use the Audio Mixer feature to create independent volume controls for Music and Sound FX.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have provided a Unity package named <kbd>VolumeControl.unitypackage</kbd>, containing an initial scene featuring soundtrack music and sound effects. The file is available inside the <kbd>04_10</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To add volume control sliders to your scene, follow these steps:</p>
<ol>
<li>Create a new Unity 3D project.</li>
<li>Import the provided <strong>Unity</strong> package, <strong>Volume</strong>, into your project.</li>
<li>Open the <strong>Volume</strong> scene from <strong>Project</strong> panel folder, <strong>VolumeControl</strong> | <kbd>_Scenes</kbd>.</li>
<li>Play the scene and walk toward the semitransparent green wall in the tunnel, using the <em>W A S D</em> keys (press <em>Shift</em> to run). You will be able to listen to:
<ul>
<li>A looping music soundtrack</li>
<li>Bells ringing</li>
<li>A robotic speech whenever the character collides with the wall</li>
</ul>
</li>
<li>In the <strong>Project</strong> panel, use the Create menu to add an <strong>Audio Mixer</strong> file. Rename this new file MainMixer.</li>
<li>Double-click MainMixer to open the <strong>Audio Mixer</strong> panel.</li>
</ol>
<ol start="7">
<li>In the the <strong>Audio Mixer</strong> panel <strong>Groups</strong> section, highlight <strong>Master</strong> and click the + (plus) sign to add a child to the <strong>Master</strong> group. Name this child <strong>Music</strong>. Repeat these actions to add a second child of <strong>Master</strong> named FX:</li>
</ol>
<div><img src="img/4e196b5d-9e9f-481b-81dc-4c86d2caf4e2.png" style="width:13.50em;height:19.33em;"/></div>
<ol start="8">
<li>In the the Audio Mixer panel Mixers section, highlight MainMixer and click the + (plus) sign to add a new item to the Mixers group. Rename this MusicMixer (you may need to rename this via the Project panel, since you've created a new Audio Mixer file through this process).</li>
<li>Drag MusicMixer onto MainMixer (child it), and select Music as its output in the pop-up dialog window.</li>
<li>In the the <strong>Audio Mixer</strong> panel Mixers section, highlight <strong>MainMixer</strong> and click the + (plus) sign to add a new item to the <strong>Mixers</strong> group. Name this <strong>FxMixer</strong>.</li>
<li>Child (drag) <strong>FxMixer</strong> onto <strong>MainMixer</strong>, and select Fx as its output in the pop-up dialog window.</li>
<li>Select MusicMixer. Select its Master group and add a child named Soundtrack.</li>
<li>Select <strong>FxMixer</strong> and add two children to its <strong>Master</strong> group: one named Speech, and another named Bells:</li>
</ol>
<div><img src="img/dbb0f356-94dd-44f5-95cf-cfd45f3d0948.png" style="width:13.25em;height:21.25em;"/></div>
<ol start="14">
<li>Select the <strong>DialogueTrigger</strong> GameObject in the <strong>Hierarchy</strong>. In the <strong>Inspector</strong>, change its <strong>Audio Source</strong> component Output track to <strong>FxMixer</strong> | <strong>Speech</strong>:</li>
</ol>
<div><img src="img/7707cd89-f690-4463-bfe7-ef346b642c88.png" style="width:35.17em;height:16.83em;"/></div>
<ol start="15">
<li>Select the <strong>Soundtrack</strong> GameObject in the <strong>Hierarchy</strong>. In the <strong>Inspector</strong>, change its Audio Source component <strong>Output</strong> track to <strong>MusicMixer</strong> | <strong>Soundtrack</strong>.</li>
<li>Select <strong>Signal</strong> from the <kbd>Prefabs</kbd> folder in the <strong>Project</strong> panel. In the <strong>Inspector</strong>, change its Audio Source component Output track to FxMixer | Bells.</li>
</ol>
<p class="mce-root"/>
<ol start="17">
<li>Select <strong>MainMixer</strong> in the <strong>Audio Mixer</strong> panel, and select its <strong>Master</strong> track. In the <strong>Inspector</strong> panel, right-click on Volume in the <strong>Attenuation</strong> component. From the pop-up-context menu, select <strong>Expose</strong> <strong>Volume</strong> (of Master) to script:</li>
</ol>
<div><img src="img/8dde7821-a2ce-4bb1-b8af-89bccd79ce27.png" style="width:33.33em;height:10.67em;"/></div>
<ol start="18">
<li>Repeat the operation to expose the <strong>Volume</strong> to scripts for both the <strong>Music</strong> and FX Groups.</li>
<li>At the top-right of the <strong>Audio Mixer</strong> panel, you should see <strong>Exposed Parameters</strong> (three). Click the drop-down icon, and rename them as follows: MyExposedParam to OverallVolume; MyExposedParam1 to MusicVolume, and MyExposedParam2 to FxVolume. Note the sequence of the three parameters may not match the order you added them, so double-check that the greyed-out track names on the right correspond correctly:</li>
</ol>
<div><img src="img/5337a07a-2550-47f3-854a-05d204563484.png"/></div>
<ol start="20">
<li>In the <strong>Hierarchy</strong> panel, use the <strong>Create</strong> drop-down menu to add a <strong>UI Panel</strong> to the scene (menu: <strong>Create</strong> | <strong>UI</strong> | <strong>Panel</strong>). Unity will automatically add a Canvas parent for this panel.</li>
<li>In the <strong>Hierarchy</strong> panel, create a UI Slider to the scene (menu: <strong>Create</strong> | <strong>UI</strong> | <strong>Slider</strong>). Make it a child of the <strong>Panel</strong> object. Rename this slider as <strong>Slider-overall</strong>. Set the slider's Min Value to <kbd>0.000025</kbd> (or <kbd>2.5e-05</kbd>).</li>
<li>Duplicate it and rename the new copy to Slider-music. In the <strong>Inspecto</strong>r panel, <strong>Rect Transform</strong> component, change its Pos Y parameter to <kbd>-40</kbd>.</li>
<li>Duplicate Slider-music and rename the new copy to <strong>Slider-fx</strong>. Change its <strong>Pos Y</strong> parameter to <kbd>-70</kbd>:</li>
</ol>
<div><img src="img/350f4d6a-fd4c-4b39-8456-96e54abbf58f.png" style="width:34.08em;height:11.33em;"/></div>
<ol start="24">
<li>Create a C# script class, <strong>VolumeControl</strong>, in the <kbd>_Scripts</kbd> folder, containing the following code, and add an instance as a scripted component to the <strong>Main Camera</strong> GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
using UnityEngine.Audio; 
 
public class VolumeControl : MonoBehaviour { 
    public GameObject panel; 
   public AudioMixer myMixer; 
   private bool isPaused = false; 
 
   void Start(){ 
        panel.SetActive(false); 
 
        ON_CHANGE_OverallVol(0.01F); 
        ON_CHANGE_MusicVol(0.01F); 
        ON_CHANGE_FxVol(0.01F); 
   } 
 
   void Update() { 
         if (Input.GetKeyUp (KeyCode.Escape)) { 
               panel.SetActive(!panel.activeInHierarchy); 
 
               if(isPaused) 
                     Time.timeScale = 1.0f; 
               else 
                     Time.timeScale = 0.0f; 
 
               isPaused = !isPaused; 
         }            
   }      
 
    public void ON_CHANGE_OverallVol(float vol) { 
        myMixer.SetFloat("OverallVolume", Mathf.Log10(vol) * 20f); 
    } 
 
   public void ON_CHANGE_MusicVol(float vol) { 
         myMixer.SetFloat ("MusicVolume", Mathf.Log10(vol) * 20f); 
   } 
 
   public void ON_CHANGE_FxVol(float vol) { 
         myMixer.SetFloat ("FxVolume", Mathf.Log10(vol) * 20f); 
   } 
} </pre>
<ol start="25">
<li>With <strong>Main Camera</strong> selected in the <strong>Hierarchy</strong> panel, drag the <strong>Panel</strong> GameObject into the Inspector for the public Panel variable.</li>
<li>With <strong>Main Camera</strong> selected in the <strong>Hierarchy</strong> panel, drag <strong>MainMixer</strong> from the Project panel into the <strong>Inspector</strong> for the public My Mixer variable.</li>
<li>Select the <strong>OverallSlider</strong> component. Below the <strong>On Value Changed</strong> list, click the + sign to add an action. From the <strong>Hierarchy</strong> panel, drag Main Camera into the Object slot and using the drop-down menu, choose VolumeControl | ON_CHANGE_OverallVol option.  For testing purposes, change the appropriate selector from Runtime Only to Editor and Runtime.</li>
<li>Repeat the previous step with MusicSlider and FxSlider, but this time, choose the ON_CHANGE_MusicVol and ON_CHANGE_FxVol options, respectively, from the drop-down menu.</li>
<li>Play the scene. You will be able to access the sliders when pressing <em>ESCAPE</em> on your keyboard and adjust volume settings from there.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <strong>Audio Mixer</strong> feature works in a similar fashion to <strong>Digital Audio Workstations</strong>, such as <strong>Logic</strong> and <strong>Sonar</strong>. Through Audio Mixers you can organize and manage audio elements by routing them into specific groups that can have individual audio tracks you can tweak, allowing adjustments in volume level and sound effects.</p>
<p>By organizing and routing our audio clips into two groups (Music and FX), we established MainMixer as a unified controller for volume. Then, we used the Audio Mixer to expose the volume levels for each track of <strong>MainMixer</strong>, making them accessible to our script.</p>
<p class="mce-root"/>
<p>Also, we have set up a basic UI featuring three sliders that, when in use, will pass their float values (between 0.000025 and 1) as arguments to three specific functions in our script: ON_CHANGE_MusicVol, ON_CHANGE_FxVol, and ON_CHANGE_OverallVol. These functions, on their turn, use the SetFloat command to effectively change the volume levels at runtime. However, before passing on the new volume levels, the script converts linear values (between 0.000025 and 1) to the decibel levels that are used by the Audio Mixer. This conversion is calculated through the log(x) * 20 mathematical function.</p>
<p>For a full explanation on issues regarding the conversion of linear values to decibel levels and vice-versa, check out Aaron Brown's excellent article at <a href="http://www.playdotsound.com/portfolio-item/decibel-db-to-float-value-calculator-making-sense-of-linear-values-in-audio-tools/">http://www.playdotsound.com/portfolio-item/decibel-db-to-float-value-calculator-making-sense-of-linear-values-in-audio-tools/</a>.</p>
<p>If one of the sliders seems not to work, double-check that the name of the first parameter to <kbd>SetFloat(...)</kbd> matches the exposed parameter in the <strong>AudioMixer</strong> – any spelling difference will mean the on-change function will not change values in the <strong>Audio Mixer</strong>. For example, if the named exposed parameter was wrongly named "<strong>OveralVolume</strong>" (missing an "l"), this statement in response to a slider change would not work due to the spelling mismatch:</p>
<pre>myMixer.SetFloat ("OverallVolume ", Mathf.Log10(vol) * 20f); </pre>
<p>The <kbd>VolumeControl</kbd> script includes code to enable and disable the UI and the <strong>EventSystem</strong>, depending upon whether the player hits the <em>ESCAPE</em> key to activate/deactivate the volume-control sliders.</p>
<p>Since our VolumeControl script sets the maximum volume level for the music and Fx tracks, you should not manually change any of the track volumes of the MainMixer at Design-Time. For general adjustments, use the secondary MusicMixer and FxMixer mixers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here is some extra information on Audio Mixers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Playing with Audio Production</h1>
                
            
            
                
<p>There are many creative uses for exposed parameters. We can, for instance, add effects such as <strong>Distortion</strong>, <strong>Flange</strong>, and <strong>Chorus</strong> to audio channels, allowing users to operate virtual sound tables/mixing boards.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>The <em>Making a dynamic soundtrack with Snapshots</em> recipe in this chapter.<br/>
The <em>Balancing the in-game audio with Ducking</em> in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making a dynamic soundtrack with Snapshots</h1>
                
            
            
                
<p>Dynamic soundtracks are the ones that change according to what is happening to the player in the game, musically reflecting that place or moment of the character's adventure. In this recipe, we will implement a soundtrack that changes twice; the first time when entering a tunnel, and the second time when coming out of it. To achieve this, we will use the <strong>Snapshot</strong> feature of the <strong>Audio Mixer</strong>.</p>
<p>Snapshots are a way of saving the state of your <strong>Audio Mixer</strong>, keeping your preferences for volume levels, audio effects, and more. We can access these states through C# scripting, creating transitions between mixes, and by bringing up the desired sonic ambience for each moment of the player's journey.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared a basic game level, contained inside the Unity package named <kbd>DynamicSoundtrack</kbd>, and two soundtrack audio clips in the <kbd>.ogg</kbd> format: <kbd>Theme01_Percussion</kbd> and <kbd>Theme01_Synths</kbd>. All these files can be found in the <kbd>04_11</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To make a dynamic soundtrack, follow these steps:</p>
<ol>
<li>Create a new Unity 3D project.</li>
<li>Import the provided Unity package, DynamicSoundtrack, and the two <kbd>.ogg</kbd> files into your project.</li>
<li>Open the Dynamic scene from <strong>Project</strong> panel folder, DynamicSoundtrack | _Scenes.</li>
<li>In the Project panel, use the Create menu to add an Audio Mixer file. Rename this new file Mixer-music. Double-click it to open the Audio Mixer panel.</li>
<li>In the the Audio Mixer panel Groups section, highlight Master and click the + (plus) sign to add a child to the Master group. Name this child Percussion. Repeat these actions to add a second child of Master, named Synths:</li>
</ol>
<div><img src="img/ce937ba3-ebb4-43d9-b076-7c6734a3f936.png" style="width:35.25em;height:18.58em;"/></div>
<ol start="6">
<li>From the <strong>Hierarchy</strong> view, create a new <strong>Empty</strong> GameObject. Name it Music.</li>
<li>Create a GameObject in the scene containing an <strong>AudioSource</strong> component linked to the Theme01_Percussion <strong>AudioClip</strong>. This can be done in a single step by dragging the music clip from the Project panel into either the <strong>Hierarchy</strong> or Scene panels. Child this new GameObject to the <strong>Music</strong> GameObject in the <strong>Hierarchy</strong>.</li>
</ol>
<ol start="8">
<li>Ensure the Theme01_Percussion GameObject is selected in the <strong>Hierarchy</strong>. In the Inspector for the <strong>AudioSource</strong> component, change its Output to Percussion (<strong>MusicMixer</strong>), make sure the <strong>Play On Awake</strong> option is checked, check the <strong>Loop</strong> option, and make sure its <strong>Spatial Blend</strong> is set to 2D:</li>
</ol>
<div><img src="img/bc2c2792-bde9-4a45-a330-ca278dc289f1.png" style="width:35.17em;height:18.08em;"/></div>
<ol start="9">
<li>Repeat the previous two steps for the Theme01_Synths <strong>AudioClip</strong> – setting the <strong>Output</strong> to Synths (<strong>MusicMixer</strong>).</li>
<li>Open the <strong>Audio Mixer</strong> and play the scene. We will now use the mixer to set the soundtrack for the start of the scene. With the scene playing, click on the <strong>Edit</strong> in Play Mode button, as shown in the screenshot, at the top of the <strong>Audio Mixer</strong>. Drop the volume on the <strong>Synths</strong> track down to <strong>-30 dB</strong>:</li>
</ol>
<div><img src="img/fa270b68-b74b-450d-80ab-68824bd8e401.png"/></div>
<ol start="11">
<li>Select the Percussion track. Click the Add.. button for <strong>Attenuation</strong>, and add a <strong>High-pass</strong> effect. From the <strong>Inspector</strong> view, change the <strong>Cutoff</strong> frequency of the <strong>High-pass</strong> effect to <strong>544.00 Hz</strong>:</li>
</ol>
<div><img src="img/c15d7736-a7f2-466f-ab6c-3146f255afd3.png" style="width:36.08em;height:21.75em;"/></div>
<ol start="12">
<li>Every change, so far, has been assigned to the current Snapshot. From the Snaphots view, right-click on the current Snapshot and rename it to Start. Click the + (plus) sign to make a copy of the current snapshot, rename this copy Tunnel:</li>
</ol>
<div><img src="img/7adeff53-424e-4a1d-8e8f-e1d64ea92857.png" style="width:12.67em;height:12.58em;"/></div>
<ol start="13">
<li>Select the <strong>Tunnel</strong> snapshot and select the <strong>High-pass</strong> effect of the Percussion group. In the Inspector, set property <strong>Cutoff frequency</strong> of <strong>10.00</strong> Hz:</li>
</ol>
<div><img src="img/0b25d80c-50cc-4fe4-bc07-db9ae098fe53.png" style="width:35.58em;height:18.83em;"/></div>
<ol start="14">
<li>Switch between the <strong>Tunnel</strong> and Start snapshots. You'll be able to hear the difference.</li>
<li>Duplicate the <strong>Tunnel</strong> snapshot, rename it <strong>OtherSide</strong>, and select it.</li>
<li>Raise the volume of the <strong>Synths</strong> track up to 0 dB.</li>
<li>Now that we have our three <strong>Snapshots</strong>, it's time to create triggers to make transitions among them.</li>
<li>Stop running the scene (so changes to the <strong>Hierarchy</strong> will be stored in the scene).</li>
<li>In the <strong>Hierarchy</strong>, create a <strong>Cube</strong> GameObject (menu: <strong>Create</strong> | <strong>3D Object</strong> | <strong>Cube</strong>). Name it Cube-tunnel-trigger.</li>
<li>In the Inspector, access the Cube-tunnel-trigger GameObject's Box Collider component and check the <strong>Is Trigger</strong> option. Uncheck its <strong>Mesh Renderer</strong> component. Adjust its size and position to the scene tunnel's interior. You may find Scene Wireframe view useful for the cube collider positioning:</li>
</ol>
<div><img src="img/a23204bd-a7d1-470e-ad44-2a000deabb13.png" style="width:45.33em;height:18.42em;"/></div>
<ol start="21">
<li>Make two copies of cube Cube-tunnel-trigger and rename them to cube Cube-start-trigger and cube Cube-otherside-trigger. Adjust their size and position, so that they occupy the areas before the tunnel's entrance (where the character is) and after its exit:</li>
</ol>
<div><img src="img/98f42182-da98-42a3-b7e3-181c33041b26.png"/></div>
<ol start="22">
<li>Create a C# script class, <kbd>SnapshotTrigger</kbd>, in the _Scripts folder, containing the following code:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
using UnityEngine.Audio; 
 
public class SnapshotTrigger : MonoBehaviour { 
   public AudioMixerSnapshot snapshot; 
   public float crossfade; 
 
   private void OnTriggerEnter(Collider other) { 
         snapshot.TransitionTo (crossfade); 
   } 
} </pre>
<ol start="23">
<li>Add an instance of <kbd>SnapshotTrigger</kbd> to all three trigger cubes (Cube-tunnel-trigger, Cube-start-trigger, and Cube-otherside-trigger).</li>
<li>Select Cube-tunnel-trigger. From the <strong>Inspector</strong> for the Snapshot Trigger (Script) component, set Snapshot to <strong>Tunnel</strong>, and <strong>Crossfade</strong> as 2:</li>
</ol>
<div><img src="img/9ab0df2e-e1ac-44f5-bf68-3f45524941ef.png" style="width:34.83em;height:23.67em;"/></div>
<ol start="25">
<li>Make changes to <strong>Cube-start-trigger</strong> and <strong>Cube-otherside-trigger</strong> by setting their <strong>Snapshots</strong> to <strong>Start</strong> and <strong>OtherSide</strong>, respectively – also with <strong>Crossfade</strong> as <kbd>2</kbd>.</li>
<li>Test the scene. The background music will change as the character moves from the starting point, through the tunnel, and out the other side.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The Snapshot feature allows you to save <strong>Audio Mixer</strong> states (including all volume levels and every filter setting) so that you can change those mixing preferences at <strong>Run-Time</strong>, making the audio design more suitable for specific locations or gameplay settings. For this recipe, we have created three <strong>Snapshots</strong> for different moments in the player's journey:</p>
<ul>
<li>Before entering the tunnel</li>
<li>Inside the tunnel</li>
<li>Outside the tunnel</li>
</ul>
<p>We have used the <strong>Highpass</strong> filter to make the initial <strong>Snapshot</strong> less intense. We have also turned the Synths track volume up to emphasize the open environment outside the tunnel. Our aim is for the changes in the audio mix to help set the right mood for the game.</p>
<p>To activate our snapshots, we have placed <strong>trigger</strong> colliders, featuring our <strong>Snapshot Trigger</strong> scripted component in which we set the desired Snapshot and the time in seconds, that it takes to make the transition (a crossfade) between the previous Snapshot and the next. In fact, the function in our script is really this straightforward – the line of <kbd>snapshot.TransitionTo (crossfade)</kbd> code simply starts a transition lasting <kbd>crossfade</kbd> seconds to the desired Snapshot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here is some information on how to fine-tune and customize this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reducing the need for multiple audio clips</h1>
                
            
            
                
<p>You might have noticed how different the <kbd>Theme01_Percussion</kbd> audio clip sounds when the <strong>Cutoff frequency</strong> of the <strong>High-pass</strong> filter is set as <kbd>10.00 Hz</kbd>. This is because the high-pass filter, as its name suggests, cuts off lower frequencies of the audio signal. In this case, it attenuated the bass drum down to inaudible levels while keeping the shakers audible. The opposite effect can be achieved through the <strong>Lowpass</strong> filter. A major benefit is<br/>
the opportunity to have two separate tracks in the same audio clip.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dealing with audio file formats and compression rates</h1>
                
            
            
                
<p>To avoid a loss of audio quality, you should import your sound clips using the appropriate file format, depending upon your target platform. If you are not sure which format to use, check out Unity's documentation on the subject at <a href="http://docs.unity3d.com/Manual/AudioFiles.html">http://docs.unity3d.com/Manual/AudioFiles.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying Snapshots to background noise</h1>
                
            
            
                
<p>Although we have applied Snapshots to our music soundtrack, background noise can also benefit immensely. If your character travels across places that are significantly different, transitioning from open spaces to indoor environments, you should consider applying snapshots to your environment audio mix. Be careful, however, to create separate <strong>Audio Mixers</strong> for Music and Environment – unless you don't mind having musical and ambient<br/>
sound tied to the same Snapshot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting creative with effects</h1>
                
            
            
                
<p>In this recipe, we have mentioned the High-pass and Low-pass filters. However, there are many effects that can make audio clips sound radically different. Experiment! Try applying effects such as Distortion, Flange, and Chorus. In fact, we encourage you to try every effect, playing with their settings. The creative use of these effects can bring out different expressions to a single audio clip.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>The <em>Adding volume control with Audio Mixers</em> recipe in this chapter.</p>
<p>The <em>Balancing soundtrack volume with Ducking</em> recipe in this chapter.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Balancing in-game audio with Ducking</h1>
                
            
            
                
<p>As much as the background music can be important in establishing the right atmosphere, there will be times when other audio clips should be emphasized, and the music volume turned down for the duration of that clip. This effect is known as <strong>Ducking</strong>. Maybe you will need it for dramatic effect (simulating hearing loss after an explosion took place), or maybe you want to make sure that the player listens to a specific bit of information presented as an audio speed sound clip. In this recipe, we will learn how to emphasize a piece of dialog by ducking the audio whenever a specific sound message is played. For that effect, we will use the <strong>Audio Mixer</strong> to send information between tracks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have provided the <kbd>soundtrack.mp3</kbd> audio clip and a Unity package named Ducking.unitypackage, containing an initial scene. All these files are available inside the <kbd>04_12</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To apply Audio Ducking to your soundtrack, follow these steps:</p>
<ol>
<li>Create a new <strong>Unity 3D</strong> project.</li>
<li>Import the provided <strong>Unity</strong> package,<strong> </strong><strong>Ducking</strong>, and the <kbd>soundtrack.mp3</kbd> file into your project.</li>
<li>Open the Ducking scene from <strong>Project</strong> panel folder, <strong>Ducking</strong> | <kbd>_Scenes</kbd>.</li>
<li>Enter Run-Time by playing the scene and walk toward the semitransparent green wall in the tunnel, using the <em>W, A, S,</em> and <em>D</em> keys (by pressing <em>Shift</em> to run). You will hear the robotDucking speech audio clip play as the character collides with the green wall ("This your captain speaking ..."). Then stop the scene playing to return to Design-Time.</li>
<li>Create a <strong>GameObject</strong> in the scene containing an <strong>AudioSource</strong> component linked to the soundtrack <strong>AudioClip</strong>. This can be done in a single step by dragging the music clip from the <strong>Project</strong> panel into either the <strong>Hierarchy</strong> or <strong>Scene</strong> panels.</li>
</ol>
<ol start="6">
<li>Ensure the GameObject soundtrack is selected in the <strong>Hierarchy</strong>. In the <strong>Inspector</strong> for the <strong>Audio Source</strong> component, make sure the Play On Awake option is checked, check the Loop option, and make sure its <strong>Spatial Blend</strong> is set to 2D (if necessary, see screenshot in the previous recipe for same action on the percussion GameObject).</li>
<li>Play the scene again. The soundtrack music should be playing. Then stop the scene playing to return to <strong>Design-Time</strong>.</li>
<li>In the <strong>Project</strong> panel, use the <strong>Create</strong> menu to add an <strong>Audio Mixer</strong> file. Rename this new file <strong>MainMixer</strong>.</li>
<li>Double-click <strong>MainMixer</strong> to open the <strong>Audio Mixer</strong> panel.</li>
<li>In the the <strong>Audio Mixer</strong> panel Groups section, highlight <strong>Master</strong> and click the + (plus) sign to add a child to the <strong>Master</strong> group. Name this child Music. Repeat these actions to add a second child of Master, named FX. Add a third child to the <strong>Master</strong> group, named Input:</li>
</ol>
<div><img src="img/51d8ac5b-84a1-4b63-b141-44ca6296f723.png" style="width:13.25em;height:19.67em;"/></div>
<ol start="11">
<li>In the Audio Mixers view, add a new <strong>Mixer</strong> by clicking the + (plus) sign to add a new <strong>Mixer</strong> to the project. Name it <strong>MusicMixer</strong>. Drag it into the <strong>MainMixer</strong> (to become its child) and select the Music group as its Output:</li>
</ol>
<div><img src="img/68ad76d8-b80d-4153-b6f2-d8c360d9e46e.png" style="width:16.50em;height:14.25em;"/></div>
<ol start="12">
<li>Repeat the previous step to add another child of <strong>MainMixer</strong>, named <strong>FxMixer</strong>, to the project, selecting the FX group as the output.</li>
<li>Select <strong>MusicMixer</strong>. Select its <strong>Master</strong> group and add a child named <kbd>Soundtrack</kbd>:</li>
</ol>
<div><img src="img/2cd38a48-a015-46ba-a2d4-2acdf2c61858.png" style="width:37.17em;height:24.42em;"/></div>
<ol start="14">
<li>Select <strong>FxMixer</strong> and add a child named <strong>Bells</strong>.</li>
</ol>
<ol start="15">
<li>From the <strong>Hierarchy</strong> view, select the <strong>DialogueTrigger GameObject</strong>. In the <strong>Inspector</strong>, change the Output track to <strong>MainMixer</strong> | <strong>Input</strong>, for the <strong>Audio Source</strong> component:</li>
</ol>
<div><img src="img/865c010c-bab9-49db-9a42-17ca978e8453.png" style="width:28.42em;height:30.33em;"/></div>
<ol start="16">
<li>Select the <strong>Soundtrack</strong> GameObject. In the <strong>Inspector</strong> for the <strong>Audio</strong> <strong>Sourc</strong>e component, change its Output track to <strong>MusicMixer</strong> | <strong>Soundtrack</strong>.</li>
</ol>
<ol start="17">
<li>From the <strong>Ducking</strong> | <strong>Prefabs</strong> folder in the Project panel, select the Signal prefab. In the Inspector, set its <strong>Audio Source</strong> component <strong>Output</strong> to <strong>FxMixer</strong> | <strong>Bells</strong>.</li>
<li>Open the <strong>Audio Mixer</strong> window. Choose <strong>MainMixer</strong>, select the Music track controller, right-click on <strong>Attenuation</strong>, and using the context menu, add the <strong>Duck Volume</strong> effect:</li>
</ol>
<div><img src="img/25a69c10-a7ae-4764-8e71-4ce0aeae78da.png" style="width:30.67em;height:21.50em;"/></div>
<ol start="19">
<li>Select the Input track, right-click on <strong>Attenuation</strong>, and using the context menu, add <strong>Send</strong>.</li>
<li>With the Input track still selected, go to the <strong>Inspector</strong> view and change the Receive setting in <strong>Send</strong> to <strong>Music\Duck</strong> Volume and its <strong>Send</strong> level to 0.00 db.</li>
</ol>
<ol start="21">
<li>Select the <strong>Music</strong> track. From the Inspector view, change the settings on the <strong>Duck Volume</strong> as follows: <strong>Threshold</strong>: <kbd>-</kbd><kbd>40.00 db</kbd>, <strong>Ratio</strong>: <kbd>300.00%</kbd>, <strong>Attack</strong> <strong>Time</strong>: <kbd>100.00 ms</kbd>, <strong>Release Time</strong>: <kbd>200.00 ms</kbd>:</li>
</ol>
<div><img src="img/3a0ca160-25e9-43c5-a513-b028d1bf447c.png" style="width:31.00em;height:23.08em;"/></div>
<ol start="22">
<li>Test the scene again. Entering the trigger object will cause the soundtrack volume to drop considerably, recovering the original volume in two seconds.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this recipe, we have created, in addition to Music and Sound FX, a group named Input, to which we have routed the audio clip that triggers the Duck Volume effect attached to our music track. The Duck Volume effect changes the track's volume whenever it receives an input that is louder than indicated in its Threshold setting. In our case, we have sent the Input track as input, and adjusted the settings so the volume will be reduced as soon as 0.1 seconds after the input had been received, turning back to its original value of 2 seconds after the input has ceased. The amount of volume reduction was determined by our Ratio of 300.00%. Playing around with the setting values will give you a better idea of how each parameter affects the final result. Also, make sure to visualize the graphic as the trigger sound is played. You will be able to see how the Input sound passes the threshold, triggering the effect.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The tracks are organized so that the other sound clips (other than speech) will not affect the volume of the music – but every music clip will be affected by audio clips sent to the input track.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>The <em>Adding volume control with Audio Mixers</em> recipe in this chapter.</p>
<p>The <em>Making a dynamic soundtrack with Snapshots</em> recipe in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Audio visualization from sample spectral data</h1>
                
            
            
                
<p>The Unity audio systems allows us to access the music data – via the <kbd>AudioSource.GetSpectrumData(...)</kbd> method. This gives us the opportunity to use that data to present Run-Time visualization of the overall sound being heard (from the <strong>AudioListener</strong>), or the individual sound being played by individual <strong>AudioSources</strong>.</p>
<p>The screenshot shows lines drawn using a sample script provided by Unity (<a href="https://docs.unity3d.com/ScriptReference/AudioSource.GetSpectrumData.html">https://docs.unity3d.com/ScriptReference/AudioSource.GetSpectrumData.html</a>):</p>
<div><img src="img/09aa10c3-5f54-420d-a202-25edf5fcf4a6.png" style="width:23.92em;height:11.42em;"/></div>
<p>However, in that sample code, their use of <kbd>Debug.DrawLine()</kbd> only appears in the Scene panel when running the game in the Unity Editor (not for final builds), and so cannot be seen by the game player. In this recipe, we'll take that same spectral data, and use it to create a <strong>Run-Time</strong> audio spectral visualization in the Game panel. We'll do this by creating a row of 512 small cubes, and then changing their heights each frame based on 512 audio data samples for the playing <strong>AudioSource</strong> component.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have provided several 140 bmp sampled free music clips inside the <kbd>04_13</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To schedule a sound to play after a given delay, do the following:</p>
<ol>
<li>Create a new 3D project and import the provided sound clip files.</li>
<li>In the Inspector, set the Background of the Main Camera to black.</li>
<li>Set the Main Camera Transform Position to (224, 50, -200).</li>
<li>Set the Main Camera Camera component to have these settings: Projection = Perspective, Field of View 60, and Clipping Planes 0.3 - 300.</li>
<li>Add <strong>DirectionalLight</strong> to the scene.</li>
<li>Add a new empty GameObject named visualizer to the scene. Add an <strong>AudioSource</strong> component to this GameObject, and set its <strong>AudioClip</strong> to one of the 140 bmp loops provided.</li>
<li>Create a C# script class, <strong>SpectrumCubes</strong>, in a new folder, _Scripts, containing the following code, and add an instance as a scripted component to the visualizer GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
 
public class SpectrumCubes : MonoBehaviour  
{ 
    const int NUM_SAMPLES = 512; 
    public Color displayColor; 
    public float multiplier = 5000; 
    public float startY; 
    public float maxHeight = 50; 
    private AudioSource audioSource; 
    private float[] spectrum = new float[NUM_SAMPLES]; 
    private GameObject[] cubes = new GameObject[NUM_SAMPLES]; 
 
    void Awake() { 
        audioSource = GetComponent&lt;AudioSource&gt;(); 
        CreateCubes(); 
    } 
 
    void Update() { 
        audioSource.GetSpectrumData(spectrum, 0, FFTWindow.BlackmanHarris); 
        UpdateCubeHeights(); 
    } 
 
    private void UpdateCubeHeights() { 
        for (int i = 0; i &lt; NUM_SAMPLES; i++) 
        { 
            Vector3 oldScale = cubes[i].transform.localScale; 
            Vector3 scaler = new Vector3(oldScale.x, HeightFromSample(spectrum[i]), oldScale.z); 
            cubes[i].transform.localScale = scaler; 
            Vector3 oldPosition = cubes[i].transform.position; 
            float newY = startY + cubes[i].transform.localScale.y / 2; 
            Vector3 newPosition = new Vector3(oldPosition.x, newY, oldPosition.z); 
            cubes[i].transform.position = newPosition; 
        } 
    } 
 
    private float HeightFromSample(float sample) { 
        float height = 2 + (sample * multiplier); 
        return Mathf.Clamp(height, 0, maxHeight); 
    } 
 
    private void CreateCubes() { 
        for (int i = 0; i &lt; NUM_SAMPLES; i++) { 
            GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube); 
            cube.transform.parent = transform; 
            cube.name = "SampleCube" + i; 
 
            Renderer cubeRenderer = cube.GetComponent&lt;Renderer&gt;(); 
            cubeRenderer.material = new Material(Shader.Find("Specular")); 
            cubeRenderer.sharedMaterial.color = displayColor; 
 
            float x = 0.9f * i; 
            float y = startY; 
            float z = 0; 
            cube.transform.position = new Vector3(x, y, z); 
 
            cubes[i] = cube; 
        } 
    } 
 
} </pre>
<ol start="8">
<li>With the visualizer GameObject selected in the <strong>Hierarchy</strong>, click to choose a visualization color from the <strong>Inspector Display Color</strong> public variable for the <strong>SpectrumCubes</strong> (Script) component.</li>
<li>Run the scene – you should see the cubes jump up and down, presenting a Run-Time visualization of the sound data spectrum for the playing sound.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You created a C# script class, <kbd>SpectrumCubes</kbd>. You created a GameObject with an <strong>AudioSource</strong> component, and an instance of your scripted class. All the work is done by the methods in the <kbd>SpectrumCues</kbd> C# script class, so each of these is explained in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The void Awake() method</h1>
                
            
            
                
<p>This method caches references to the sibling <strong>AudioSource</strong> component, and then invokes the <kbd>CreateCubes()</kbd> method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The void CreateCubes() method</h1>
                
            
            
                
<p>This method loops for the number of samples (default is 512), to create a 3D Cube GameObject, in a row along the X-axis. Each Cube is created with the name "Cube&lt;i&gt;" (where "i" is from 0 to 511) and then parented to the visualizer GameObject (since the scripted method is running in this GameObject). Each cube then has the color of its renderer set to the value of the public displayColor parameter. The cube is then positioned on the X-axis according to the loop number, at the value of the public startY parameter (so multiple visualizations can be at different parts of the screen), and Z = 0. Finally, a reference to the new cube GameObject is stored in the cubes[] array.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The void Update() method</h1>
                
            
            
                
<p>Each frame in this method updates the values inside the spectrum[] array through a call to <kbd>GetSpectrumData(...)</kbd>. In our example, the <kbd>FFTWindow.BlackmanHarris</kbd> frequency window technique is used. Then the <kbd>UpdateCubeHeights()</kbd> method is invoked.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The void UpdateCubeHeights() method</h1>
                
            
            
                
<p>This method loops for each cube to set its height to a scaled value of its corresponding audio data value in the <kbd>spectrum[]</kbd> array. The cube has its Y-value scaled by the value returned by the <kbd>HeightFromSample(spectrum[i])</kbd> method. The cube is then moved up (its transform position is set) from the value of <kbd>startY</kbd> by half its height – so that all the scaling appears upwards (rather than up and down) – this is to have a flat line along the base of our spectrum of cubes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The float HeightFromSample(float) method</h1>
                
            
            
                
<p>Method  <kbd>HeightFromSample(float)</kbd> does a simple calculation (sample value times public parameter multiplier), plus minimum value of two added to it. The value returned from the function is this result, limited to the maxHeight public parameter (via the <kbd>Mathf.Clamp(...)</kbd> method).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding visualizations to a second AudioSource</h1>
                
            
            
                
<p>The script has been written to be easy to have multiple visualizations in a scene. So to create a second visualizer for a second <strong>AudioClip</strong> in the scene, do the following:</p>
<ol>
<li>Duplicate the visualizer GameObject.</li>
<li>Drag a different AudioClip from the <strong>Project</strong> panel into the <strong>Audio Source</strong> component of your new GameObject.</li>
</ol>
<ol start="3">
<li>Set the Start <strong>Y</strong> public parameter in the <strong>Inspector</strong> to 60 (so the new row of cubes will be above the original row).</li>
<li>In the <strong>Inspector</strong>, choose a different Display Color public variable for the <strong>SpectrumCubes (Script)</strong> component:</li>
</ol>
<div><img src="img/987f9d56-391c-4727-aa15-b530eaaa2ad9.png" style="width:28.08em;height:19.00em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Try out different FFT (Fast Fourier Transform) window types</h1>
                
            
            
                
<p>There are several different approaches to frequency analysis of audio data, our recipe currently uses the <kbd>FFTWindow.BlackmanHarris</kbd> version. Learn (and try out!) some of the others from the Unity <kbd>FFTWindow</kbd> documentation page: <a href="https://docs.unity3d.com/ScriptReference/FFTWindow.html">https://docs.unity3d.com/ScriptReference/FFTWindow.html</a>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Synchronizing simultaneous and sequential music to create a simple 140 bpm music-loop manager</h1>
                
            
            
                
<p>The <em>Creating a metronome through the precise scheduling of sounds with</em> <kbd>dspTime</kbd> recipe demonstrated how to create a metronome by scheduling when sounds play using the <kbd>AudioSource.PlayScheduled(...)</kbd> method and the <kbd>AudioSettings.dspTime</kbd> value. Another situation when we need to precisely schedule audio start times is to ensure a smooth transition from one music track to another, or to ensure simultaneous music tracks play in time together.</p>
<p>In this recipe, we'll create a simple 4-track 140 bpm music manager that starts playing a new sound after a fixed time – the result of which is that the tracks fit together perfectly, and those that overlap do so in synchronicity:</p>
<div><img src="img/47e24a71-b907-4ddf-9aab-99df2b36f208.png" style="width:22.83em;height:2.00em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have provided several 140 bmp sampled free music clips inside the <kbd>04_14</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a music-loop manager, do the following:</p>
<ol>
<li>Create a new Unity 3D project and import the provided sound clip files.</li>
<li>Create four GameObjects in the scene containing an <strong>AudioSource</strong> component linked to different <strong>AudioClip</strong> loops from the 140 bpm files provided. This can be done in a single step by dragging the music clip from the <strong>Project</strong> panel into either the <strong>Hierarchy</strong> or Scene panels.</li>
</ol>
<ol start="3">
<li>In the Inspector, uncheck the <strong>Play On Awake</strong> parameter for all four <strong>AudioSource</strong> components (so they don't start playing until we tell them to).</li>
<li>Add a new empty <strong>GameObject</strong> named <strong>musicScheduler</strong> to the scene.</li>
<li>Create a C# script class, <strong>LoopScheduler</strong>, in a new folder, <kbd>_Scripts</kbd>, containing the following code, and add an instance as a scripted component to the <strong>musicScheduler</strong> GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
 
public class LoopScheduler : MonoBehaviour { 
    public float bpm = 140.0F; 
    public int numBeatsPerSegment = 16; 
    public AudioSource[] audioSources = new AudioSource[4]; 
    private double nextEventTime; 
    private int nextLoopIndex = 0; 
    private int numLoops; 
    private float numSecondsPerMinute = 60F; 
    private float timeBetweenPlays; 
 
    void Start() { 
        numLoops = audioSources.Length; 
timeBetweenPlays = numSecondsPerMinute / bpm * numBeatsPerSegment; 
        nextEventTime = AudioSettings.dspTime; 
    } 
 
    void Update() { 
        double lookAhead = AudioSettings.dspTime + 1.0F; 
        if (lookAhead &gt; nextEventTime) 
            StartNextLoop(); 
 
        PrintLoopPlayingStatus(); 
    } 
 
    private void StartNextLoop() { 
        audioSources[nextLoopIndex].PlayScheduled(nextEventTime); 
        nextEventTime += timeBetweenPlays; 
 
        nextLoopIndex++; 
        if (nextLoopIndex &gt;= numLoops) 
            nextLoopIndex = 0; 
    } 
 
    private void PrintLoopPlayingStatus(){ 
        string statusMessage = "Sounds playing: "; 
        int i = 0; 
 
        while (i &lt; numLoops) { 
            statusMessage += audioSources[i].isPlaying + " "; 
            i++; 
        } 
 
        print(statusMessage); 
    } 
} </pre>
<ol start="6">
<li>With the <strong>musicScheduler</strong> GameObject selected in the <strong>Hierarchy</strong>, drag each of the music loop GameObjects into the four available slots for the <strong>AudioSources</strong> public array variable in the <strong>Loop Scheduler (Script)</strong> component:</li>
</ol>
<div><img src="img/7718015b-b831-4215-8b4f-8173a251bdea.png" style="width:33.92em;height:21.08em;"/></div>
<ol start="7">
<li>Run the scene – each clips should start in turn after the same time delay. If you chose one or two longer clips, they will continue playing while the next clip begins – all overlapping perfectly since they are all 140 bpm sound clips.</li>
</ol>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You added four <strong>GameObjects</strong> to the scene, containing <strong>AudioSources</strong> linked to 140 bpm music clips. You created a C# script class, <kbd>LoopScheduler</kbd>, and added an instance to an empty <strong>GameObject</strong>. You associated the four <strong>AudioSources</strong> in your <strong>GameObjects</strong> with the four slots in the public <strong>AudioSource</strong> array variable in your scripted component.</p>
<p>The numbers of music clips you use can easily be changed by changing the size of the public array variable.</p>
<p>The <kbd>Start()</kbd> method counts the length of the array to set the <kbd>numLoops</kbd> variable. It then calculates the number of seconds to delay before starting each clip (this is fixed according to the beats-per-minute and beats-per-measure). Finally, it sets the current time to be the time to start the first loop.</p>
<p>The <kbd>Update()</kbd> method decides whether it's time to schedule the next loop, by testing whether the current time plus a 1-second look-ahead, is past the time to start the next loop. If so, the <kbd>StartNextLoop()</kbd> method is invoked. Regardless of whether we have started the next loop, the <kbd>PrintLoopPlayingStatus()</kbd> method to display to the user which loops are playing or not is printed to the Console.</p>
<p>The <kbd>PrintLoopPlayingStatus()</kbd> method loops for each <strong>AudioSource</strong> reference in the array, creating a string of trues and falses to be then printed out.</p>
<p>The <kbd>StartNextLoop()</kbd> method sends a <kbd>PlayScheduled(...)</kbd> message to the next <kbd>AudioSource</kbd> to be played, passing the <kbd>nextEventTime</kbd> value. It then adds the time between plays for the next event time. The next value of the loop index is then calculated (add one, if past the end of the array, then reset to 0 again).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding visualizations to the four playing loops</h1>
                
            
            
                
<p>It's great fun to watch the visualization of the loop sounds as they play together. To add visualizations to the four AudioSources, all you have to do is:</p>
<ol>
<li>Import the <strong>SpectrumCubes.cs</strong> C# script file from the previous recipe into this project.</li>
<li>Set the Main Camera Transform Position to (224, 50, -200).</li>
<li>Set the <strong>Main Camera Camera component</strong> to have these settings: Projection = Perspective, Field of View 60, and Clipping Planes 0.3 - 300.</li>
<li>Add a <strong>Directional Light GameObject</strong> to the scene.</li>
<li>For each of the four <strong>GameObjects</strong> containing your <strong>AudioSources</strong>, add an instance of the <strong>SpectrumCubes</strong> script class.</li>
<li>In the <strong>Inspector</strong> for the <strong>Spectrum Cubes (Script)</strong> component, change the displayColors for each <strong>AudioSource GameObject</strong>.</li>
<li>Set the startY values of Spectrum Cubes (Script) components for the four <strong>GameObjects</strong> to be -50, 0, 50, 100. For most screen sizes, this should allow you too see all four visualization spectrums:</li>
</ol>


            

            
        
    </body></html>