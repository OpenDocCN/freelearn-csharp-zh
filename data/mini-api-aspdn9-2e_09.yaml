- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Object Relational Mapping with Entity Framework Core and Dapper
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Entity Framework Core和Dapper进行对象关系映射
- en: In the previous chapter, we used direct connections to SQL and NoSQL databases
    to create and retrieve data, a staple of most APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了直接连接到SQL和NoSQL数据库来创建和检索数据，这是大多数API的基本功能。
- en: In reality, a large segment of APIs based on .NET favor the use of **Object
    Relation Mapping** ( **ORM** ) to converse with databases over the direct connection
    method. This is because ORMs offer another layer of abstraction over the underlying
    data, promoting SOLID design principles while being conducive to scalability and
    easy long-term maintenance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，大量基于.NET的API倾向于使用**对象关系映射**（**ORM**）与数据库进行交互，而不是直接连接方法。这是因为ORM在底层数据之上提供了另一层抽象，促进了SOLID设计原则，同时有利于可扩展性和易于长期维护。
- en: In this chapter, we are going to explore two of the mainstream ORM frameworks
    – Entity Framework Core and Dapper. With these two technologies, we will be able
    to map the entities in our database and manage them as if the data was contained
    within the classes that make up our minimal API project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨两个主流ORM框架——Entity Framework Core和Dapper。使用这两种技术，我们将能够映射数据库中的实体，并将它们作为如果数据包含在我们的最小API项目中的类来管理。
- en: 'We will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主要内容：
- en: Introduction to ORMs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORMs简介
- en: Configuring Dapper in minimal API projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最小API项目中配置Dapper
- en: Performing CRUD operations with Dapper
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dapper执行CRUD操作
- en: Configuring Entity Framework in minimal API projects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最小API项目中配置Entity Framework
- en: Performing CRUD operations with Entity Framework
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Entity Framework执行CRUD操作
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following software to be installed on your machine:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的机器上安装以下软件：
- en: Visual Studio 2022 or Visual Studio Code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022或Visual Studio Code
- en: Microsoft SQL Server 2022 Developer Edition
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft SQL Server 2022开发者版
- en: Microsoft SQL Server Management Studio
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft SQL Server Management Studio
- en: You will need to create a database in SQL Server ( **MyCompany** ). The SQL
    to create the required **Employees** table was provided in the previous chapter,
    but I will also include it in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在SQL Server中创建一个数据库（**MyCompany**）。创建所需**Employees**表的SQL语句在上一章中已提供，但我也将包括在本章中。
- en: 'The code for this chapter is available in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
    .'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub仓库中找到：[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)。
- en: Introduction to ORMs
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ORMs简介
- en: ORMs were first introduced in the 1990s to address the mismatch between the
    way data is modeled in relational databases such as SQL and **Object-Oriented
    Programming** ( **OOP** ) languages, often referred to as the **Impedance Mismatch**
    .
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ORMs首次在20世纪90年代推出，旨在解决关系数据库（如SQL）中数据建模方式与面向对象编程（**OOP**）语言之间的不匹配，通常被称为**阻抗不匹配**。
- en: Data in a *relational database* is laid out in a series of tables, each with
    a number of columns defining the property of each record, which in turn is represented
    by a row in the table. The relationships between entities in a relational database
    are represented by *foreign keys* and *join* operations that occur during a query.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库中的数据以一系列表的形式排列，每个表都有多个列定义每条记录的属性，这些属性反过来由表中的一行表示。关系型数据库中实体之间的关系由**外键**和查询期间发生的**连接**操作表示。
- en: In contrast, data in an *OOP language* is represented as objects that have fields,
    properties, and operational logic such as methods and functions that can act on
    the data. Relationships between objects in OOP are more abstract, represented
    by pointer references and concepts such as inheritance and polymorphism.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在面向对象的语言中，数据以具有字段、属性和操作逻辑（如方法和函数，可以作用于数据）的对象形式表示。面向对象语言中对象之间的关系更为抽象，通过指针引用和继承、多态等概念表示。
- en: An ORM bridges the gap between these two paradigms by providing a means of mapping
    the data, which allows us to work with database records as if they were objects.
    This provides a layer of abstraction that simplifies the complexities of SQL,
    making it easier to perform **Create** , **Read** , **Update** , **Delete** (
    **CRUD** ) operations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ORM通过提供一种映射数据的方法来弥合这两种范式之间的差距，使我们能够将数据库记录作为对象来处理。这提供了一层抽象，简化了SQL的复杂性，使得执行**创建**、**读取**、**更新**、**删除**（**CRUD**）操作变得更加容易。
- en: There are many, widely used ORMs on offer for various OOP languages and frameworks.
    The first widely used ORM was **TopLink** . Developed in 1994, it was designed
    to provide mapping for Java applications, influencing many of the ORM technologies
    we take for granted today, such as the two we will be exploring in this chapter
    – Dapper and Entity Framework.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于各种面向对象的编程语言和框架，有许多广泛使用的ORM可供选择。第一个广泛使用的ORM是**TopLink**。它在1994年开发，旨在为Java应用程序提供映射，影响了今天我们视为理所当然的许多ORM技术，包括我们将在本章中探讨的两个——Dapper和Entity
    Framework。
- en: ORMs are a significant accelerator to any project, but particularly to minimal
    API projects. They reduce boilerplate code in ASP.NET because they can be easily
    installed as a package, and configuration can be achieved centrally, with queries
    and commands requiring less ceremony than direct SQL connections that use classes
    such as **SqlConnection** and **SqlCommand** .
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ORM是任何项目的显著加速器，尤其是对最小API项目。它们减少了ASP.NET中的样板代码，因为它们可以作为包轻松安装，并且配置可以集中完成，查询和命令比使用**SqlConnection**和**SqlCommand**等类的直接SQL连接需要更少的仪式。
- en: One of the most powerful aspects of ORMs is the ability for them to manage the
    schema of the underlying database. Objects can be of course mapped from an existing
    database, but ORMs provide the ability to manage the database structure in the
    same way classes are configured in code.. This makes schema management really
    simple and more efficient because developers would be altering class structures
    anyway. It prevents *double keying* , taking advantage of the work that has already
    been done in code to automate the dependent changes in the database.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ORM最强大的方面之一是它们能够管理底层数据库的模式。当然，对象可以从现有数据库映射，但ORM提供了以与代码中配置类相同的方式管理数据库结构的能力。这使得模式管理变得非常简单和高效，因为开发者无论如何都会更改类结构。它防止了*双重键入*，利用代码中已经完成的工作来自动化数据库中的相关更改。
- en: If you read the previous chapter, you’ll remember that we created a database
    called **MyCompany** to use as an example for connecting directly from our API.
    We will continue to use this database, but instead, we will map the objects within
    it using ORMs. Let’s first do this using the ORM, Dapper.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了上一章，你会记得我们创建了一个名为**MyCompany**的数据库，作为从我们的API直接连接的示例。我们将继续使用这个数据库，但这次我们将使用ORM来映射其内的对象。让我们首先使用ORM，Dapper来实现这一点。
- en: Configuring Dapper in minimal API projects
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在最小API项目中配置Dapper
- en: I’m starting with Dapper because it is an ORM that is often referred to as a
    *Micro-ORM* when compared to Entity Framework. The reason for this is that it
    does away with a lot of ORM features such as result caching, change tracking,
    lazy loading, and database migrations. Instead, Dapper focuses on simplicity and
    performance. Being a more lightweight solution means that it could be preferable
    to Entity Framework, depending on the needs of your minimal API.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择从Dapper开始，因为它与Entity Framework相比，通常被称为*微型ORM*。这是因为它去掉了许多ORM功能，如结果缓存、更改跟踪、延迟加载和数据库迁移。相反，Dapper专注于简单性和性能。作为一个更轻量级的解决方案，它可能更适合你的最小API需求。
- en: Dapper is a good starting point for learning ORMs because it still uses SQL
    queries, making it the perfect middle-ground between the direct connection method
    shown in the previous chapter and the more verbose ORM feature set provided by
    Entity Framework.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper是学习ORM的一个好起点，因为它仍然使用SQL查询，这使得它在上一章中展示的直接连接方法和Entity Framework提供的更冗长的ORM功能集之间成为完美的中间地带。
- en: Database migrations and Dapper
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库迁移和Dapper
- en: The last differentiating feature (database migrations) is an important one because
    it relates to the ability to change the schema of a database. We will talk about
    migrations later in the chapter when we explore Entity Framework, but for now,
    know that database migrations change the database schema from our code, and Dapper
    does not support this via migrations. However, you can still change the table
    schema by sending SQL commands through Dapper. This is outside of the scope of
    this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个区分性功能（数据库迁移）非常重要，因为它与更改数据库模式的能力相关。当我们探索Entity Framework时，我们将在本章后面讨论迁移，但在此之前，要知道数据库迁移是通过代码更改数据库模式，而Dapper不支持通过迁移来实现这一点。然而，你仍然可以通过Dapper发送SQL命令来更改表结构。这超出了本章的范围。
- en: Dapper works with many database providers, including SQL Server, Oracle, SQLite,
    MySQL, and PostgreSQL. It uses ADO.NET, meaning that it will work with any database
    platform that has a provider using ADO.NET. Because we are using the database
    we created in the previous chapter, we will be connecting to a SQL Server database.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper与许多数据库提供程序兼容，包括SQL Server、Oracle、SQLite、MySQL和PostgreSQL。它使用ADO.NET，这意味着它将与任何具有使用ADO.NET提供程序的数据库平台一起工作。因为我们正在使用上一章中创建的数据库，所以我们将连接到SQL
    Server数据库。
- en: Let’s create a new (empty) ASP.NET project in Visual Studio so that we have
    a clean slate to work on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Visual Studio中创建一个新的（空白的）ASP.NET项目，以便我们有一个干净的平台来工作。
- en: Once you have created the project, navigate to **Program.cs** , which should
    have the template **Hello** **World** example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了项目，导航到**Program.cs**，它应该有一个**Hello World**模板示例。
- en: To start with, we need a database to connect to. If you followed along with
    the previous chapter, you will have installed a SQL Server instance and created
    a database called **MyCompany** . If you haven’t done this already, install SQL
    Server and create the database within SQL Server Management Studio.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个数据库来连接。如果你跟随上一章的内容，你将已经安装了一个SQL Server实例并创建了一个名为**MyCompany**的数据库。如果你还没有这样做，请安装SQL
    Server并在SQL Server Management Studio中创建数据库。
- en: 'Once you have a database, if you don’t yet have the **Employees** table, you
    can use the following SQL to create one:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了数据库，如果你还没有**Employees**表，你可以使用以下SQL来创建一个：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Dapper uses providers to facilitate the connection to the target database platform.
    For SQL Server, the required providers are the same as for direct connections
    to SQL Server from C#: **Microsoft.Data.SqlClient** .'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper使用提供程序来简化与目标数据库平台的连接。对于SQL Server，所需的提供程序与从C#直接连接到SQL Server的要求相同：**Microsoft.Data.SqlClient**。
- en: 'Install **Microsoft.Data.SqlClient** , either from the **NuGet** package manager
    GUI or in the Package Manager Console by running the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安装**Microsoft.Data.SqlClient**，无论是从**NuGet**包管理器GUI还是通过在包管理器控制台运行以下命令：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While we’re installing **NuGet** packages, we also need to install the **Dapper**
    package. You can do this in the package manager console by running the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在安装**NuGet**包时，我们还需要安装**Dapper**包。你可以在包管理器控制台运行以下命令来完成此操作：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We could technically start writing queries now, directly within our minimal
    API endpoints, but for consistency and good practice, we should create a new service
    specifically for Dapper and register it for dependency injection. Create a class
    called **DapperService** . As we did in the previous chapter for **SQLService**
    and **MongoDbService** , we will register this class as a singleton in **Program.cs**
    . Ensure you register the service before **app.Run();** :'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们现在可以直接在我们的最小API端点中编写查询，但为了保持一致性和良好的实践，我们应该为Dapper创建一个新的服务并为其注册依赖注入。创建一个名为**DapperService**的类。正如我们在上一章中为**SQLService**和**MongoDbService**所做的那样，我们将在这个类中注册单例到**Program.cs**中。确保在**app.Run();**之前注册服务：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have now configured the project to use Dapper on a SQL Server database using
    dependency injection with the relevant provider, and we have created a database
    to work with, meaning that we can proceed with performing our first CRUD operations
    from our minimal API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经配置了项目，使其使用依赖注入和相关的提供程序在SQL Server数据库上使用Dapper，并且我们已经创建了一个可以工作的数据库，这意味着我们可以从我们的最小API开始执行我们的第一个CRUD操作。
- en: Performing CRUD operations with Dapper
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Dapper执行CRUD操作
- en: Let’s work our way through each of the aspects of CRUD in Dapper with some examples.
    First of all, let’s create an employee.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些示例来逐步了解Dapper中CRUD的各个方面。首先，让我们创建一个员工。
- en: Creating an Employee record
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建员工记录
- en: 'First, we will create an endpoint that creates an employee. That means we’ll
    be using the **POST** method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个创建员工的端点。这意味着我们将使用**POST**方法：
- en: 'Go to **Program.cs** and map a POST endpoint to the **employees** route. It
    should accept an **Employee** as a parameter, and it should inject **DapperService**
    :'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**Program.cs**并将POST端点映射到**employees**路由。它应该接受一个**Employee**作为参数，并且应该注入**DapperService**：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, we can create a method within **DapperService** that handles the creation
    of the employee in the database (this is where we get to use Dapper).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以在**DapperService**内部创建一个方法来处理在数据库中创建员工（这就是我们使用Dapper的地方）。
- en: 'Open **DapperService.cs** and create a method called **AddEmployee** :'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**DapperService.cs**并创建一个名为**AddEmployee**的方法：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Like the direct connection examples from the previous chapter, Dapper uses **SqlConnection**
    to connect to a SQL Server. Inside the scope of that connection, you need to write
    the appropriate query for the action you want to take. Because we’re creating
    an **employee** , we will be adding a new record to the database and so we will
    write an **INSERT** statement.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前一章中的直接连接示例，Dapper 使用 **SqlConnection** 连接到 SQL Server。在该连接的作用域内，您需要编写执行所需操作的适当查询。因为我们正在创建一个
    **employee**，所以我们将向数据库添加一条新记录，因此我们将编写一个 **INSERT** 语句。
- en: Make a **using** statement to hold the connection to the database (remember,
    **using** statements allow the connection to be automatically disposed of) and
    add the connection string to your database.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **using** 语句来保持对数据库的连接（记住，**using** 语句允许自动释放连接）并将连接字符串添加到数据库中。
- en: 'Follow this up by defining a string that represents the **INSERT** statement:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着，定义一个表示 **INSERT** 语句的字符串：
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice how the **INSERT** statement must contain all the relevant columns and
    values as parameters for those columns.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 **INSERT** 语句必须包含所有相关列及其值作为参数。
- en: 'Next, we will use Dapper to commit the database transaction against the instantiated
    **SqlConnection** . We can use **ExecuteAsync()** , a Dapper extension method
    that will execute the statement while mapping the properties from the **Employee**
    object that we passed into this the **AddEmployee()** method:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Dapper 将数据库事务提交给实例化的 **SqlConnection**。我们可以使用 **ExecuteAsync()**，这是一个
    Dapper 扩展方法，它将在映射从我们传递到这个 **AddEmployee()** 方法的 **Employee** 对象属性时执行语句：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now have a method on **DapperService** that can receive an **Employee**
    parameter and commit it to the database via Dapper, as shown here:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有一个在 **DapperService** 上的方法，可以接收一个 **Employee** 参数并通过 Dapper 将其提交到数据库，如下所示：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'All that remains now is to call this method in the **POST** endpoint we started
    writing in **Program.cs** , before returning an **HTTP 201 CREATED** status code
    to the client:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在剩下的只是调用我们在 **Program.cs** 中开始编写的 **POST** 端点上的此方法，在返回 **HTTP 201 CREATED**
    状态码给客户端之前：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That’s taken care of the *Create* part of CRUD.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了 CRUD 的 *Create* 部分。
- en: Storing and referencing connection strings
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和引用连接字符串
- en: In the previous chapter, I demonstrated how you can follow best practices by
    storing connection strings in a configuration file and then referencing them via
    **IConfiguration.**
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我演示了如何通过将连接字符串存储在配置文件中并通过 **IConfiguration** 引用来遵循最佳实践。
- en: If you haven’t already done so, please refer to this in the previous chapter
    so that you can implement it for Dapper and Entity Framework usage.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请参考上一章，以便您可以为 Dapper 和 Entity Framework 的使用实现它。
- en: Let’s move on to the *Read* part now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续到 *Read* 部分。
- en: Reading an Employee record
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取员工记录
- en: 'The *Read* part will entail having a **GET** endpoint on top of a **SELECT**
    query on the database:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*Read* 部分将包括在数据库上执行一个 **SELECT** 查询的 **GET** 端点：'
- en: 'Start by adding a **GET** endpoint to **Program.cs** , mapped to the **Employees**
    route. It should have a route parameter called **id** that is passed through the
    body of the lambda expression inside the endpoint, and it should inject **DapperService**
    :'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在 **Program.cs** 中添加一个 **GET** 端点，映射到 **Employees** 路由。它应该有一个名为 **id** 的路由参数，该参数通过端点内部
    lambda 表达式的主体传递，并且应该注入 **DapperService**：
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we’re going to take the same approach we took in the last example by
    making a new function in **DapperService** , but this time, instead of inserting,
    it will run a **SELECT** query to get the employee for the specified **id** ,
    before returning it to the endpoint:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将采取与上一个示例相同的方法，在 **DapperService** 中创建一个新的函数，但这次，而不是插入，它将运行一个 **SELECT**
    查询以获取指定 **id** 的员工，然后在返回到端点之前：
- en: '[PRE11]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**QuerySingleAsync<Employee>()** is where the Dapper code comes in. Like before,
    this is a Dapper extension method that allows us to execute a SQL query, with
    the expectation that one record will be returned, that record being an employee.'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**QuerySingleAsync<Employee>()** 是 Dapper 代码介入的地方。和之前一样，这是一个 Dapper 扩展方法，允许我们执行一个
    SQL 查询，预期返回一条记录，即一个员工记录。'
- en: Notice the parameters being sent in. We passed the SQL query, but then we passed
    a new instance of an object array. This is the value for the **@employeeId** parameter
    that we declared in the SQL query. Dapper expects us to pass our parameter values
    in as an array of objects so that their values can be mapped to the relevant parameters
    in the query.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意发送的参数。我们传递了SQL查询，然后传递了一个新的对象数组实例。这是我们在SQL查询中声明的**@employeeId**参数的值。Dapper期望我们以对象数组的形式传递参数值，以便它们的值可以映射到查询中的相关参数。
- en: We also called a specific extension method – **QuerySingleAsync()** . The reason
    for this is obvious – we only want one record. If you want more, there are functions
    such as **Query()** that will return an **IEnumerable** containing many records.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还调用了一个特定的扩展方法——**QuerySingleAsync()**。原因很明显——我们只想得到一个记录。如果你需要更多，有如**Query()**这样的函数将返回包含多个记录的**IEnumerable**。
- en: 'Finally, we once again simply call the function in **DapperService** from the
    endpoint, returning the result to the client:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们再次简单地从端点调用**DapperService**中的函数，将结果返回给客户端：
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, let’s look at how we can *update* an employee record.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何更新员工记录。
- en: Updating an Employee record
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新员工记录
- en: We’re two letters into CRUD now. Let’s take a look now at **Update** by taking
    the same approach – creating a **PUT** endpoint and connecting it to **DapperService:**
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经进入了CRUD的第二个字母。让我们现在通过采取相同的方法来查看**更新**——创建一个**PUT**端点并将其连接到**DapperService**：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we create a function that performs the update against the database:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个函数来对数据库进行更新操作：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how the code we’ve added to update the record in **DapperService** is
    similar to the code we added to create a record. The main difference is the SQL
    string. Otherwise, we’re still passing in an **Employee** object and mapping its
    properties to the record in the database via Dapper.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们添加到**DapperService**中更新记录的代码与我们添加到创建记录的代码相似。主要区别是SQL字符串。否则，我们仍然传递一个**Employee**对象，并通过Dapper将其属性映射到数据库中的记录。
- en: Deleting an Employee record
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除员工记录
- en: Finally, we’ve reached the final section of CRUD – **Delete** .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达了CRUD的最后一部分——**删除**。
- en: 'We’ll follow the same principle we’ve applied in all the operations up to this
    point, but this time I’m going to start by adding the functionality to **DapperService**
    for deleting a record by ID:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循到目前为止在所有操作中应用的原则，但这次我将首先在**DapperService**中添加通过ID删除记录的功能：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can add an endpoint to use the service for record deletion, returning
    a **NO CONTENT** result to the client on success:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个端点来使用该服务进行记录删除，在成功时向客户端返回**无内容**的结果：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ve covered enough of Dapper that you should now be able to use it to perform
    basic simple CRUD operations on SQL databases through this powerful yet lightweight
    (micro) ORM. You could also try swapping out the SQL provider for one that supports
    another database, such as MySQL or PostgreSQL, to improve your experience of using
    Dapper to manage data in SQL for incoming requests on your minimal APIs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了足够的Dapper知识，你现在应该能够使用它通过这个强大而轻量级的（微）ORM在SQL数据库上执行基本的简单CRUD操作。你也可以尝试用支持其他数据库的SQL提供程序替换SQL提供程序，例如MySQL或PostgreSQL，以改善你使用Dapper管理SQL数据在最小API上的请求体验。
- en: Dapper has its place, but Entity Framework is a more feature-rich alternative
    that is used for not only transacting data but also to manage the SQL database
    structure from code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper有其位置，但Entity Framework是一个功能更丰富的替代品，不仅用于交易数据，还可以通过代码管理SQL数据库结构。
- en: Let’s take a look at how we can build the same functionality we’ve explored
    in the section, using Entity Framework.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用Entity Framework构建我们在该部分中探索的相同功能。
- en: Configuring Entity Framework in minimal API projects
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在最小API项目中配置Entity Framework
- en: Firstly, we need to use Microsoft’s Entity Framework packages to configure the
    connection, referred to hereafter as the **context** . This wording already creates
    a layer of abstraction from the database as we start to consider our data as members
    of this context.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用Microsoft的Entity Framework包来配置连接，以下称为**上下文**。这种说法已经创建了一个从数据库的抽象层，因为我们开始将数据视为该上下文的成员。
- en: 'Start by installing the following packages via the package manager console
    in Visual Studio:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过Visual Studio中的包管理器控制台安装以下包：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This ensures that all the libraries required to interact with SQL Server through
    Entity Framework are in place.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了所有通过Entity Framework与SQL Server交互所需的库都已就绪。
- en: 'Next, we will **scaffold** the existing **MyCompany** database, again from
    the package manager console, using the connection string for the database:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从包管理控制台再次使用数据库的连接字符串来**scaffold**现有的**MyCompany**数据库：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Scaffolding** means that Entity Framework looks at the schema of the database
    and maps the tables to objects in your code. The result is a **DbContext** , which
    wraps all of the different entities in the context. A series of models will also
    be created that are classes representing each of the entities. These are placed
    in the folder specified by the **OutputDir** switch used by the console command.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scaffolding**意味着Entity Framework会查看数据库的模式并将表映射到你的代码中的对象。结果是生成一个**DbContext**，它封装了上下文中的所有不同实体。还会创建一系列模型，这些模型是代表每个实体的类。这些模型被放置在由控制台命令使用的**OutputDir**开关指定的文件夹中。'
- en: Because I stated that I want the context to be called **MyCompanyContext** ,
    a new class called **MyCompanyContext** has been generated in the **Models** folder.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我说了我想将上下文称为**MyCompanyContext**，所以在**Models**文件夹中生成了一个名为**MyCompanyContext**的新类。
- en: In this class, you can see that a **DbSet<Employee>** called **Employees** has
    been added. A **DbSet** represents all the current records in a given database
    table. This is a collection representing each of the records in **Employees**
    , and by adding to, retrieving from, updating, or removing from this collection,
    we can indirectly change the corresponding SQL table. Let’s look at the generated
    code to further understand what is happening here.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，你可以看到添加了一个名为**Employees**的**DbSet<Employee>**。一个**DbSet**代表给定数据库表中所有当前记录。这是一个表示**Employees**中每个记录的集合，通过向、从、更新或从这个集合中删除，我们可以间接更改相应的SQL表。让我们看看生成的代码，以进一步了解这里发生了什么。
- en: '**MyCompanyContext** is a class derived from **DbContext** . It represents
    the data source in use and provides a means of interacting with this source at
    a higher level of abstraction. When the class is instantiated, **DbContextOptions**
    is injected into it, which is then passed to the base **DbContext** class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**MyCompanyContext**是一个从**DbContext**派生的类。它代表了正在使用的数据源，并提供了一种以更高层次抽象与该源交互的方式。当类被实例化时，**DbContextOptions**会被注入其中，然后传递给基类**DbContext**：'
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Entity Framework then generates the code required to build the context, mapping
    business objects to tables in the database, allowing a model to be created:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework随后生成构建上下文所需的代码，将业务对象映射到数据库中的表，从而允许创建模型：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Entity Framework is instructed in this example to use SQL Server with the specified
    connection string to model the entities based on the database schema:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Entity Framework被指示使用指定的连接字符串来使用SQL Server来根据数据库模式建模实体：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Before we start looking at communicating with the database through Entity Framework
    from the API endpoints, we have another piece of configuration to explore.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始通过API端点使用Entity Framework与数据库通信之前，我们还有另一项配置要探索。
- en: It’s important to understand how **migrations** are used by Entity Framework
    to change the database schema. A migration is a set of instructions to follow
    to make specific changes to a database. Whether to add a column to a table, add
    a new table, or remove a column, it can usually be done via a migration.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Entity Framework如何使用迁移来更改数据库模式是很重要的。迁移是一组指令，用于对数据库进行特定的更改。无论是向表中添加列、添加新表还是删除列，通常都可以通过迁移来完成。
- en: Migrations keep Entity Framework as the single source of truth for your data
    by outlining how a database’s structural change should be managed, in addition
    to data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据之外，迁移还概述了如何管理数据库的结构变化，从而保持Entity Framework作为你数据的单一真相来源。
- en: 'Let’s explore migrations by making a change to our **Employees** table. We’re
    going to add a **Title** column to the table. First, open the **Employee** model
    that was generated in the **Models** folder and add **Title** as a **string**
    property:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过修改我们的**Employees**表来探索迁移。我们将在表中添加一个**Title**列。首先，打开在**Models**文件夹中生成的**Employee**模型，并将**Title**添加为一个**string**属性：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, we head back to the package manager console to input a command to add
    the migration. This command asks Entity Framework to look for any changes to any
    of the **DbSet** objects in the **DbContext** . It will then generate C# code
    that will eventually run SQL on the database to commit the changes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们回到包管理控制台，输入一个命令来添加迁移。此命令要求Entity Framework查找**DbContext**中任何**DbSet**对象的变化。然后，它将生成最终会在数据库上运行SQL以提交更改的C#代码。
- en: 'Use the **Add-Migration** command in the package manager console, followed
    by a string that gives the migration a name:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在包管理控制台中使用 **Add-Migration** 命令，然后跟一个字符串，为迁移提供一个名称：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Migration names
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移名称
- en: When naming a migration, it is good practice to provide a summary of the changes
    these migrations make – for example, **changed_datatype_of_salary_column_to_decimal**
    .
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当命名迁移时，提供这些迁移所做的更改的摘要是一个好的做法——例如，**changed_datatype_of_salary_column_to_decimal**。
- en: 'Entity Framework will then build the project and add a new class for the migration
    in the **Migrations** folder, creating the folder if it does not yet exist:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework 将构建项目，并在 **Migrations** 文件夹中添加一个新的迁移类，如果尚不存在，则创建该文件夹：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can see that the migration specifies that a column is to be added called
    **Title** .
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到迁移指定要添加一个名为 **Title** 的列。
- en: 'To commit this to the database, we can write another simple command in the
    package manager console:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此提交到数据库，我们可以在包管理控制台编写另一个简单的命令：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If all went as expected, you’ll see that the **Employees** table in the database
    has a **Title** column.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切如预期进行，你将看到数据库中的 **Employees** 表有一个 **Title** 列。
- en: Now that we’ve covered the basics of its configuration, let’s update the endpoints
    in **Program.cs** to use Entity Framework.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了其配置的基本知识，让我们更新 **Program.cs** 中的端点以使用 Entity Framework。
- en: Performing CRUD operations with Entity Framework
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Entity Framework 执行 CRUD 操作
- en: 'We have a new dependency in the form of the **DbContext** . We should register
    it within the **Main** method in **Program.cs** for use during a request:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个新的依赖项，形式为 **DbContext**。我们应该在 **Program.cs** 中的 **Main** 方法中注册它，以便在请求期间使用：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we did in the previous examples using Dapper, we will create a new service
    for managing CRUD operations for **Employee** objects. This time, we will be more
    specific with the naming, and call it **EmployeeService** .
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在之前的 Dapper 示例中做的那样，我们将创建一个新的服务来管理 **Employee** 对象的 CRUD 操作。这次，我们将对命名更加具体，并将其称为
    **EmployeeService**。
- en: 'In **EmployeeService** , start by adding a constructor, to which we can pass
    the registered context:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **EmployeeService** 中，首先添加一个构造函数，我们可以向其中传递已注册的上下文：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, define all the functions that will be needed for CRUD operations using
    **MyCompanyContext** :'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义所有需要的 CRUD 操作函数，使用 **MyCompanyContext**：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we’ll create a customer exception called **EmployeeNotFoundException**
    , which can we throw in the event a requested employee is not present in the data
    source:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个名为 **EmployeeNotFoundException** 的客户异常，当请求的员工不在数据源中时，我们可以抛出这个异常：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In each of these new functions within **EmployeeService** , we are interacting
    with the database via the **Employees** collection sitting within **MyCompanyContext**
    . We are then committing the changes we have made to this collection to the database
    using **SaveChangesAsync();** .
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **EmployeeService** 中的每个新函数中，我们通过位于 **MyCompanyContext** 中的 **Employees**
    集合与数据库进行交互。然后，我们使用 **SaveChangesAsync();** 将我们对该集合所做的更改提交到数据库。
- en: Take note of the reusability of one of the functions, **GetEmployeeById** .
    In most CRUD operations, we need to be able to target the affected **Employee**
    object, and we can reuse this function for this. To guard against the potential
    of an employee not being found in the collection, there is a custom exception
    that can be thrown. This is useful for the API endpoint because it means it can
    cater its response to a specific exception if it occurs, in this case, returning
    a **404 NOT FOUND** status code if necessary.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意其中一个函数的可重用性，**GetEmployeeById**。在大多数 CRUD 操作中，我们需要能够定位受影响的 **Employee** 对象，我们可以重用这个函数。为了防止在集合中找不到员工的可能性，我们可以抛出一个自定义异常。这对于
    API 端点很有用，因为它意味着它可以在发生时针对特定的异常进行响应，在这种情况下，如果需要，返回 **404 NOT FOUND** 状态码。
- en: We’ve established that in Entity Framework, interacting with a database table
    means interacting with a collection in C#. This is apparent in **EmployeeService**
    , where LINQ queries are used in place of the SQL queries that would have been
    used in a direct SQL connection or a micro-ORM such as Dapper.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了在 Entity Framework 中，与数据库表交互意味着与 C# 中的集合交互。这在 **EmployeeService** 中很明显，其中使用了
    LINQ 查询，而不是在直接 SQL 连接或像 Dapper 这样的微 ORM 中使用的 SQL 查询。
- en: With the establishment of **EmployeeService** , the API endpoints in **Program.cs**
    can be altered to use Entity Framework rather than the previously used Dapper.
    But to what extent do they need to be changed?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 **EmployeeService** 的建立，**Program.cs** 中的 API 端点可以修改为使用 Entity Framework
    而不是之前使用的 Dapper。但它们需要改变到什么程度呢？
- en: The answer to this is – not very much at all, thanks to the abstraction we’ve
    created in the form of **EmployeeService** . We’ve used an injected dependency
    to manage the database interaction, with the functions within having the same
    name or **signature** as each other, meaning that we can just swap out the injected
    **DapperService** for the new **EmployeeService** that uses Entity Framework.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案是——并不多，多亏了我们以**EmployeeService**的形式创建的抽象。我们使用注入的依赖项来管理数据库交互，其中函数具有相同的名称或**签名**，这意味着我们可以简单地用新的使用Entity
    Framework的**EmployeeService**替换注入的**DapperService**。
- en: 'Head back to **Program.cs** and register **EmployeeService** for dependency
    injection:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到**Program.cs**并注册**EmployeeService**以进行依赖注入：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Double-click the parameter that currently passes in **DapperService** to any
    of the mapped endpoints. In Visual Studio, you can rename this object **EmployeeService**
    by holding *Ctrl* and pressing the *R* key twice.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 双击当前传递给任何映射端点的**DapperService**参数。在Visual Studio中，您可以通过按两次*Ctrl*和*R*键来重命名此对象为**EmployeeService**。
- en: After renaming, all other occurrences will also be updated. You shouldn’t have
    any errors as long as the functions called by each endpoint have the same signature
    regardless of whether you’re using **DapperService** or **EmployeeService** .
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名后，所有其他出现的地方也将被更新。只要每个端点调用的函数签名相同，无论您是使用**DapperService**还是**EmployeeService**，您都不应该有任何错误。
- en: 'The following code shows the **POST** endpoint for creating an **employee**
    after it has been updated to use **EmployeeService** :'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了创建**员工**后更新为使用**EmployeeService**的**POST**端点：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This was a rather whirlwind introduction to Entity Framework, which has a great
    deal more in the way of features. However, the main focus is on a minimal API’s
    interaction with databases in an abstracted manner, and this example is enough
    to get you started on your ORM journey.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Entity Framework的一个相当快速的介绍，它有更多功能。然而，主要重点是抽象方式下最小API与数据库的交互，这个例子足以让您开始ORM之旅。
- en: Let’s review the things we’ve learned about Dapper and Entity Framework in this
    chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章关于Dapper和Entity Framework所学到的东西。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has introduced the use of Dapper and Entity Framework to provide
    an abstraction layer between minimal API endpoints and relational databases.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用Dapper和Entity Framework来在最小API端点和关系型数据库之间提供抽象层。
- en: We opened with an introduction to ORMs, defining their role in simplifying database
    interactions in minimal APIs, before providing an overview of the various features
    available for interaction with data sources.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从ORMs的介绍开始，定义了它们在简化最小API数据库交互中的作用，然后概述了与数据源交互的各种功能。
- en: We then stepped through the configuration of Dapper, adding the relevant libraries
    and providing a dedicated **DapperService** that could be used on minimal API
    endpoints with dependency injection. Once we had configured Dapper, we created
    the SQL queries in **DapperService** and linked the endpoints to the service to
    provide an end-to-end link between API and database via Dapper.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们逐步配置了Dapper，添加了相关库，并提供了专门的**DapperService**，该服务可以在具有依赖注入的最小API端点上使用。一旦我们配置了Dapper，就在**DapperService**中创建了SQL查询，并将端点链接到服务，通过Dapper提供API和数据库之间的端到端链接。
- en: Having established CRUD operations on the database with Dapper, we contrasted
    this by configuring Entity Framework, and then performed the equivalent setup
    of a service for completing CRUD operations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Dapper在数据库上建立CRUD操作后，我们通过配置Entity Framework进行了对比，然后执行了完成CRUD操作的服务等效设置。
- en: Finally, the original **DapperService** was swapped out for the new **EmployeeService**
    using Entity Framework, demonstrating the versatility of injecting an abstraction
    as a dependency for data management.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用Entity Framework的**EmployeeService**替换了原始的**DapperService**，展示了将抽象作为数据管理依赖项注入的灵活性。
- en: There’s no doubt that integrating data sources via ORMs is a significant aspect
    of building a minimal API. When managing data, depending on the way the data is
    requested, the potential for bottlenecks in performance can be significant. We
    will explore this concept and ways that these bottlenecks can be mitigated in
    the next chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，通过ORMs集成数据源是构建最小API的一个重要方面。在管理数据时，根据数据请求的方式，性能瓶颈的可能性可能很大。我们将在下一章探讨这个概念以及缓解这些瓶颈的方法。
- en: Part 3 - Optimal Minimal APIs
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分 - 最佳最小API
- en: To build high-performing, scalable APIs, it’s essential to fine-tune your system’s
    performance and take advantage of advanced programming techniques. This part covers
    how to identify bottlenecks, employ asynchronous programming, and implement caching
    strategies to improve efficiency and user experience.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建高性能、可扩展的API，对系统性能进行微调和利用高级编程技术至关重要。本部分涵盖了如何识别瓶颈、采用异步编程以及实施缓存策略来提高效率和用户体验。
- en: 'This part has the following chapters:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B20968_10.xhtml#_idTextAnchor154) , *Profiling and Identifying
    Bottlenecks*'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B20968_10.xhtml#_idTextAnchor154) ，*分析和识别瓶颈*'
- en: '[*Chapter 11*](B20968_11.xhtml#_idTextAnchor165) , *Utilizing Asynchronous
    Programming for Scalability*'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B20968_11.xhtml#_idTextAnchor165) ，*利用异步编程实现可扩展性*'
- en: '[*Chapter 12*](B20968_12.xhtml#_idTextAnchor174) , *Caching Strategies for
    Enhanced Performance*'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B20968_12.xhtml#_idTextAnchor174) ，*增强性能的缓存策略*'
