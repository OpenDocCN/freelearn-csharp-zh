<html><head></head><body>
<div><h1 class="chapterNumber">1</h1>
<h1 class="chapterTitle" id="_idParaDest-14">Understanding the Importance of Software Architecture</h1>
<p class="normal">We started writing this book in 2018. It has been five years since the publication of the first edition, and the importance of s<strong class="keyWord">oftware architecture</strong> for creating <strong class="keyWord">enterprise applications</strong> (<strong class="keyWord">EAs</strong>) that attend to our customers’ needs has only grown. Besides, technology itself is evolving at a speed that is hard to follow, and for this reason, new architectural opportunities keep emerging. So, we keep saying that the more we build complex and fantastic solutions, the more we need great software architectures to build and maintain them.</p>
<p class="normal">We are sure that is the reason why you decided to read this new edition of the book, and this is the reason why we decided to write it. It is not only a matter of how .NET 8 is different from .NET 6, because there are other incredible books that take this approach. It is truly the purpose of delivering to the community a book that can support developers and software architects in the difficult decision of what component to use while designing a solution. For this reason, in this new edition, we have reformulated the way we present all the content.</p>
<p class="normal">You will find while reading the chapters of this new edition that you will be given support for understanding the fundamentals and technology topics that are unavoidable when designing enterprise applications using .NET 8, C#, and cloud computing. Most of the examples will use Microsoft Azure, but we will always present this content in a way that you are not locked into a specific cloud platform.</p>
<p class="normal">It is important to remind you that it is not a simple task to write about this important subject, which offers so many alternative techniques and solutions. The main objective of this book is not to build an exhaustive and never-ending list of available techniques and solutions but to show how various families of techniques are related, and how they impact, in practice, the construction of a maintainable and sustainable solution. We hope you all enjoy this new journey!</p>
<p class="normal">Specifically, in <em class="chapterRef">Chapter 1</em>, <em class="italic">Understanding the Importance of Software Architecture</em>, we will discuss how the need to keep our focus on creating effective enterprise solutions continuously increases; users always need more new features in their applications. Moreover, the need to deliver frequent application versions (due to a quickly changing market) increases our obligation to have sophisticated software architecture and development techniques.</p>
<p class="normal">The following topics will be covered in this chapter:</p>
<ul>
<li class="bulletList">What software architecture is</li>
<li class="bulletList">Some software development process models that may help you as a software architect</li>
<li class="bulletList">The process for gathering the right information to design high-quality software</li>
<li class="bulletList">Design techniques for helping in the process of development</li>
<li class="bulletList">Cases where the requirements impact the system results</li>
</ul>
<p class="normal">For this new edition, we have also reformulated the way we will present the case study of the book. You will find it in a single chapter, at the end of the book, where it will be easy for you to understand the whole purpose of its implementation.</p>
<p class="normal">The case study of this book will take you through the process of creating the software architecture for a travel agency<a id="_idIndexMarker000"/> called <strong class="keyWord">World Wild Travel Club</strong> (<strong class="keyWord">WWTravelClub</strong>). The purpose of this case study is to help you understand the theory explained in each chapter and to provide an example of how to develop an enterprise application with Azure, Azure DevOps, GitHub, C# 12, .NET 8, ASP.NET Core, and other technologies that will be introduced in this book.</p>
<p class="normal">By the end of this chapter, you will understand exactly what the mission of software architecture is. You will also have learned what Azure is and how to create an account on the platform. You will also have received an overview of software processes, models, and other techniques that will enable you to lead your team.</p>
<h1 class="heading-1" id="_idParaDest-15">What is software architecture?</h1>
<p class="normal">That you are reading<a id="_idIndexMarker001"/> this book today is thanks to the computer scientists who decided to consider software development as an engineering area. This happened in the last century, more specifically, at the end of the sixties, when they proposed that the way we develop software is quite like the way we construct buildings. That is why we have the name <strong class="keyWord">software architecture</strong>. Just as an architect designs a building and oversees its construction based on that design, the main goal of a software architect is to ensure that the software application is implemented well; and good implementation requires the design of a great architectural solution.</p>
<p class="normal">In a professional development project, you must do the following things:</p>
<ul>
<li class="bulletList">Define the customer requirements for the solution.</li>
<li class="bulletList">Design a great solution to meet those requirements.</li>
<li class="bulletList">Implement the designed solution.</li>
<li class="bulletList">Test the solution implementation.</li>
<li class="bulletList">Validate the solution with your customer.</li>
<li class="bulletList">Deliver the solution in the working environment.</li>
<li class="bulletList">Maintain the solution afterward.</li>
</ul>
<p class="normal">Software engineering defines these activities as the software development lifecycle fundamentals. All the theoretical software development process models (waterfall, spiral, incremental, agile, and so on) are somehow related to this cycle. No matter the model you use, if you do not perform the essential tasks in the initial stages of your project, you will not deliver acceptable software as a solution.</p>
<p class="normal">The main point about designing great solutions is foundational to the purpose of this book. You must understand that great real-world solutions bring with them a few fundamental constraints:</p>
<ul>
<li class="bulletList">The solution needs to meet user requirements.</li>
<li class="bulletList">The solution needs to be delivered on time.</li>
<li class="bulletList">The solution needs to adhere to the project budget.</li>
<li class="bulletList">The solution needs to deliver good quality.</li>
<li class="bulletList">The solution needs to guarantee safe and effective future evolution.</li>
</ul>
<p class="normal">Great solutions need to be sustainable, and you must understand that there is no sustainable software without great software architecture. Nowadays, great software architecture depends on both modern tools and modern environments to perfectly fit users’ requirements.</p>
<p class="normal">For this reason, this book will use some great tools provided by Microsoft. We decided to write the book always following<a id="_idIndexMarker002"/> the <strong class="keyWord">long-term support</strong> (<strong class="keyWord">LTS</strong>) versions, which is why we are<a id="_idIndexMarker003"/> now applying all the examples using .NET 8. This is the second LTS version as a unified platform for software development, which gives us a great opportunity to create fantastic solutions.</p>
<figure class="mediaobject"><img alt="Linha do tempo  Descrição gerada automaticamente" src="img/B19820_01_01.png"/></figure>
<p class="packt_figref">Figure 1.1: .NET support</p>
<p class="normal">.NET 8 is delivered together with C# 12. Considering the .NET approach of targeting so many platforms and devices, C# is now one of the most used programming languages in the world and runs on everything from small devices up to huge servers in different <strong class="keyWord">operating systems </strong>(<strong class="keyWord">OSs</strong>) and environments.</p>
<p class="normal">The book will also use <strong class="keyWord">Microsoft Azure</strong>, which is Microsoft’s cloud platform, where you will find all the components the company provides to build advanced software architecture solutions.</p>
<p class="normal">It is worth mentioning that the use of .NET 8 with Azure was just an option chosen by the authors. .NET can work just as well using other cloud providers, and Azure can handle other coding frameworks very well.</p>
<p class="normal">To be a software architect, you need to be familiar with these technologies, and many others too. This book will guide you on a journey where, as a software architect working in a team, you will learn how to provide optimal solutions using these tools. Let us start this journey by creating your Azure account.</p>
<h1 class="heading-1" id="_idParaDest-16">Creating an Azure account</h1>
<p class="normal">Microsoft Azure<a id="_idIndexMarker004"/> is one of the best cloud solutions currently available on the market. It is important to know that, inside Azure, we will find a selection of components that can help us define the architecture of twenty-first-century solutions.</p>
<p class="normal">If you want to check Azure’s current state, structure, and updates in a compact, digestible way, just go to <a href="https://azurecharts.com/">https://azurecharts.com/</a>, developed by Alexey Polkovnikov. The content is continuously updated so you can revisit it to learn, evaluate, or even just have fun with the dozens of Azure components described in this Azure encyclopedia.</p>
<p class="normal">This subsection will guide you in creating an Azure account. If you already have one, you can skip this part.</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">First, go to <a href="https://azure.microsoft.com">https://azure.microsoft.com</a>. There, you will find the information you need to start your subscription. Translation to your native language is usually set automatically.</li>
<li class="numberedList">Once you have accessed this portal, it is possible to sign up. If you have never done this before, there is a <strong class="screenText">Start free </strong>option, so you will be able to use some Azure features without spending any money. Please check the options for free plans at <a href="https://azure.microsoft.com/free/">https://azure.microsoft.com/free/</a>.</li>
<li class="numberedList">The process for creating a free account is quite simple, and you will be guided by a form that requires you to have a <strong class="screenText">Microsoft account</strong> or <strong class="screenText">GitHub account</strong>.</li>
<li class="numberedList">During the process, you will also be asked for a credit card number to verify your identity and to keep out spam and bots. However, you will not be charged unless you upgrade the account.</li>
<li class="numberedList">To finish the assignment, you will need to accept the subscription agreement, offer details, and privacy statement.</li>
<li class="numberedList">Once you have finished filling out the form, you will be able to access the Azure portal. As you can see in the following screenshot, the panel shows a dashboard that you can customize, and a menu on the left, where you can set up the Azure components you are going to use in your solution. Throughout this book, we will come back to this screen to set up the components needed to help us create modern software architecture. To find the next page, just select the hamburger menu icon and click on <strong class="screenText">All services</strong>:</li>
</ol>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_01_02.png"/></figure>
<p class="packt_figref">Figure 1.2: The Azure portal</p>
<p class="normal">Once you have<a id="_idIndexMarker005"/> created your Azure account, you are ready to find out how a software architect can lead a team to develop software, taking advantage of all the opportunities offered by Azure. However, it is important to keep in mind that a software architect needs to go beyond just technologies because they are expected to define how the software will be delivered.</p>
<p class="normal">Today, a software architect not only designs the basis of a piece of software but also determines how the whole software development and deployment process is conducted. The next section will cover some of the most widely used software development paradigms in the world. We will start by describing what the community refers to as traditional software engineering. After that, we will cover the agile models that have changed the way we build software nowadays.</p>
<h1 class="heading-1" id="_idParaDest-17">Software development process models</h1>
<p class="normal">As a software<a id="_idIndexMarker006"/> architect, it is important for you to understand some of the common development processes that are currently used in most enterprises. A software development process defines how people in a team produce and deliver software. In general, this process relates to a software engineering theory called the <strong class="keyWord">software development process model</strong>. Ever since software development was first defined as an engineering process, many process models for developing software have been proposed. Let us review the traditional software models, and then look at the agile ones that are currently common.</p>
<h2 class="heading-2" id="_idParaDest-18">Reviewing traditional software development process models</h2>
<p class="normal">Some of the <a id="_idIndexMarker007"/>models introduced in software engineering theory are already<a id="_idIndexMarker008"/> considered traditional and obsolete. This book does not aim to cover all of them, but here, we will give a brief explanation of the ones that are still used in some companies – the <strong class="keyWord">waterfall</strong> and <strong class="keyWord">incremental</strong> models.</p>
<h3 class="heading-3" id="_idParaDest-19">Understanding the waterfall model principles</h3>
<p class="normal">This topic may <a id="_idIndexMarker009"/>appear strange in a software architecture book from 2023, but yes, you may still find companies where the <a id="_idIndexMarker010"/>most traditional software process model remains the <a id="_idIndexMarker011"/>guideline for software development. This process executes all fundamental tasks in sequence. Any software development project consists of the following steps:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Requirements</strong>: where a product requirements document is created, and it is the basis for the software development process</li>
<li class="bulletList"><strong class="keyWord">Design</strong>: where the software architecture is developed according to the requirements</li>
<li class="bulletList"><strong class="keyWord">Implementation</strong>: where the software is programmed</li>
<li class="bulletList"><strong class="keyWord">Verification</strong>: where tests are performed in the application</li>
<li class="bulletList"><strong class="keyWord">Maintenance</strong>: where the cycle starts again after delivery</li>
</ul>
<p class="normal">Let us look at a diagrammatic representation of this:</p>
<figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="img/B19820_01_03.png"/></figure>
<p class="packt_figref">Figure 1.3: The waterfall development cycle (<a href="https://en.wikipedia.org/wiki/Waterfall_model">https://en.wikipedia.org/wiki/Waterfall_model</a>)</p>
<p class="normal">Often, the use of <a id="_idIndexMarker012"/>waterfall models causes problems such as delays in the delivery of a functional version of the software and user dissatisfaction due to the distance between expectations and the final product delivered. Besides, in my experience, having application tests start only after the completion of development always feels terribly stressful.</p>
<h3 class="heading-3" id="_idParaDest-20">Analyzing the incremental model</h3>
<p class="normal"><strong class="keyWord">Incremental development</strong> is <a id="_idIndexMarker013"/>an<a id="_idIndexMarker014"/> approach that tries to overcome <a id="_idIndexMarker015"/>the biggest problem of the waterfall model: the user can test the solution only at the end of the project. The idea of a model following this approach is to give the users opportunities to interact with the solution as early as possible so that they can give useful feedback, which will help during the development of <a id="_idIndexMarker016"/>the software.</p>
<figure class="mediaobject"><img alt="A picture containing text  Description automatically generated" src="img/B19820_01_04.png"/></figure>
<p class="packt_figref">Figure 1.4: The incremental development cycle (<a href="https://en.wikipedia.org/wiki/Incremental_build_model">https://en.wikipedia.org/wiki/Incremental_build_model</a>)</p>
<p class="normal">The<a id="_idIndexMarker017"/> incremental model presented in the preceding picture was introduced as an alternative to the waterfall approach. The idea of the model is to run for each increment a set of practices related to software development (<strong class="keyWord">communication</strong>, <strong class="keyWord">planning</strong>, <strong class="keyWord">modeling</strong>, <strong class="keyWord">construction</strong>, and <strong class="keyWord">deployment</strong>). Although it mitigated problems related to the lack of communication with the customer, fewer increments were still a problem for big projects because the increments were still too long.</p>
<p class="normal">When the incremental approach was used on a large scale – mainly at the end of the last century – many problems related to project bureaucracy were reported, due to the large amount of documentation required. This clunky scenario caused the rise of a very important movement in the software development industry – <strong class="keyWord">agile</strong>.</p>
<h3 class="heading-3" id="_idParaDest-21">Understanding agile software development process models</h3>
<p class="normal">At the <a id="_idIndexMarker018"/>beginning of this century, developing software was considered one of the most chaotic <a id="_idIndexMarker019"/>activities in engineering. The percentage of software projects that failed was incredibly high, and this fact proved the need for a different approach to deal with the flexibility required by software development projects.</p>
<p class="normal">In 2001, the <strong class="keyWord">Agile Manifesto</strong> was <a id="_idIndexMarker020"/>introduced to the world, and from that time forward various agile process models were proposed. Some of them have survived up until now and are still very common.</p>
<div><p class="normal">The Agile Manifesto has <a id="_idIndexMarker021"/>been translated into more than 60 languages. You can check it out at <a href="https://agilemanifesto.org/">https://agilemanifesto.org/</a>.</p>
</div>
<p class="normal">One of the biggest differences between agile models and traditional models is the way developers interact with the customer. The message behind all agile models is that the faster you deliver software to the user, the better. This idea is sometimes confusing for software developers who understand this as – <em class="italic">Let’s try coding, and that’s all, folks!</em></p>
<p class="normal">However, there is an important observation of the Agile Manifesto that many people do not read when they start working with agile:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_01_05.png"/></figure>
<p class="packt_figref">Figure 1.5: Manifesto for agile software development</p>
<p class="normal">A <a id="_idIndexMarker022"/>software <a id="_idIndexMarker023"/>architect always needs to remember this. Agile processes do not mean a lack of discipline. Moreover, when you use the agile process, you will quickly understand that there is no way to develop good software without discipline. On the other hand, as a software architect, you need to understand that <em class="italic">soft </em>means flexibility. A software project that refuses to be flexible tends to ruin itself over time.</p>
<p class="normal">The 12 principles <a id="_idIndexMarker024"/>behind agile are foundational to this flexible approach:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Continuously delivering valuable software to satisfy the customer must be the highest priority of any developer.</li>
<li class="numberedList">Changing requirements needs to be understood as an opportunity to make the customer more competitive.</li>
<li class="numberedList">Use a weekly timescale to deliver software.</li>
<li class="numberedList">A software team must be composed of businesspeople and developers.</li>
<li class="numberedList">A software team needs to be trusted and should have the correct environment to get the project done.</li>
<li class="numberedList">The best way to communicate with a software team is face to face.</li>
<li class="numberedList">You can see the greatest software team achievement when the software is really working in production.</li>
<li class="numberedList">Agile works<a id="_idIndexMarker025"/> properly when it delivers sustainable development.</li>
<li class="numberedList">The more you invest in techniques and good design, the more agile you are.</li>
<li class="numberedList">Simplicity is essential.</li>
<li class="numberedList">The more self-organized the teams are, the better-quality delivery you will have.</li>
<li class="numberedList">Software teams tend to improve their behavior from time to time, analyzing and adjusting their process.</li>
</ol>
<p class="normal">Even<a id="_idIndexMarker026"/> 20 years after the launch of the Agile Manifesto, its importance and connection to the current needs of software teams remain intact. Certainly, there are many companies where this approach is not fully accepted, but as a software architect, you should understand this as an opportunity to transform practices and evolve the team you are working with.</p>
<p class="normal">There are many techniques and models that were presented to the software community with the agile approach. The next subsections will discuss <strong class="keyWord">lean software development</strong>, <strong class="keyWord">extreme programming</strong>, and <strong class="keyWord">Scrum</strong>, so that you can decide as a software architect which ones you might use to improve your software delivery.</p>
<h4 class="heading-4">Lean software development</h4>
<p class="normal">After the <a id="_idIndexMarker027"/>Agile Manifesto, the<a id="_idIndexMarker028"/> approach of lean software development was introduced to the community as an adaptation of a well-known movement in automobile engineering, Toyota’s model for building cars. The lean manufacturing method delivers a high level of quality even with few resources.</p>
<p class="normal">Mary and Tom Poppendieck mapped seven lean principles for software development, really connected to agile and the<a id="_idIndexMarker029"/> approach of many companies of this century, which are listed here:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Eliminate waste</strong>: You may consider waste to be anything that will interfere with the delivery of the real need of the customer.</li>
<li class="bulletList"><strong class="keyWord">Build quality in</strong>: An organization that wants to guarantee quality needs to promote it in processes from the very beginning, instead of only considering it when code is being tested.</li>
<li class="bulletList"><strong class="keyWord">Create knowledge</strong>: All companies that have achieved excellence have a common pattern of generating new knowledge by disciplined experimentation, documenting that knowledge, and guaranteeing that it is spread all over the organization.</li>
<li class="bulletList"><strong class="keyWord">Defer commitment</strong>: Plan decisions at the latest possible moment without causing damage to the project.</li>
<li class="bulletList"><strong class="keyWord">Deliver fast</strong>: The faster you deliver software, the more elimination of waste you have. Companies that compete using time frequency have significant advantages over their competitors.</li>
<li class="bulletList"><strong class="keyWord">Respect people</strong>: Giving reasonable objectives to the team, together with plans that will guide them to self-organize their routine, is a matter of respecting the people that you work with.</li>
<li class="bulletList"><strong class="keyWord">Optimize the whole</strong>: A lean company improves the cycle of value; from the moment it receives a new requirement to the point at which it delivers the software.</li>
</ul>
<p class="normal">Following the<a id="_idIndexMarker030"/> lean principles helps a team or company to improve the quality of the features that are delivered to the customer. It also creates a reduction in time spent on features that will not be used by the customer. In lean, deciding the features that are important to the customer guides the team in delivering software that matters, and this is exactly what the Agile Manifesto intends to promote in software teams.</p>
<h4 class="heading-4">Extreme programming</h4>
<p class="normal">Just before the<a id="_idIndexMarker031"/> release<a id="_idIndexMarker032"/> of the Agile Manifesto, some of the participants who designed the document, especially Kent Beck, presented to the world the <strong class="keyWord">extreme programming</strong> (<strong class="keyWord">XP</strong>)<strong class="keyWord"> methodology </strong>for developing software.</p>
<p class="normal">XP is based on the values of simplicity, communication, feedback, respect, and courage. It was considered later as a social change in programming, according to Beck in his second book about the topic. It certainly promotes a huge change in the flow of development.</p>
<p class="normal">XP states that <a id="_idIndexMarker033"/>every team should simply do only what it was asked to do, communicating face to face daily, demonstrating the software early to get feedback, respecting the expertise of each member of the team, and having the courage to tell the truth about progress and estimates, considering the team’s work as a whole.</p>
<p class="normal">XP also delivers<a id="_idIndexMarker034"/> a set of rules. These rules may be changed by the team if they detect something is not working properly, but it is important to always maintain the values of the methodology.</p>
<p class="normal">These rules are <a id="_idIndexMarker035"/>divided into planning, managing, designing, coding, and testing. Don Wells has mapped XP at <a href="http://www.extremeprogramming.org/">http://www.extremeprogramming.org/</a>. Although some of the ideas of the methodology were criticized strongly by many companies and specialists, there are many good practices <a id="_idIndexMarker036"/>that are still used nowadays:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Writing software requirements using user stories</strong>: User stories are considered an agile approach to describing user needs, together with acceptance tests, which are used to guarantee the correct implementation.</li>
<li class="bulletList"><strong class="keyWord">Divide software into iterations and deliver small releases</strong>: The practice of iterating in software development is implemented by all methodologies aside from waterfall. The fact of delivering faster versions decreases the risk of not meeting the customer’s expectations.</li>
<li class="bulletList"><strong class="keyWord">Avoid working overtime and guarantee a sustainable velocity</strong>: Although this must be one of the hardest tasks a software architect may deal with, overtime indicates that something is not working properly in the process.</li>
<li class="bulletList"><strong class="keyWord">Keep things simple</strong>: While developing solutions, it is quite common to try to anticipate features that the customer would like to have. This approach increases the complexity of the development and the time to market the solution. A different approach will cause high costs, and probably a low level of features that are used in the system you are developing.</li>
<li class="bulletList"><strong class="keyWord">Refactoring</strong>: The approach of refactoring the code continuously is good because it enables the evolution of your software and guarantees the design improvement that will truly be necessary due to the normal technical changes of the platforms you use to develop.</li>
<li class="bulletList"><strong class="keyWord">Keep the customer always available</strong>: If you follow XP, you should have an expert customer inside your team. This is certainly something that is hard to do, but the main idea of this approach is to guarantee that the customer is involved in all parts of development. As another bonus, having the customer close to<a id="_idIndexMarker037"/> your team means they understand the difficulties and expertise the team has, enabling an increase in trust between the parties.</li>
<li class="bulletList"><strong class="keyWord">Continuous integration</strong>: This practice is one of the bases of the current DevOps approach. The less difference you have between your personal code repository and the main code repository, the better.</li>
<li class="bulletList"><strong class="keyWord">Code the unit test first</strong>: A unit test is an approach where you program specific code for testing a single unit (class/method) of your project. This is discussed in a current development methodology called <strong class="keyWord">Test-Driven Development</strong> (<strong class="keyWord">TDD</strong>). The<a id="_idIndexMarker038"/> main goal here is to guarantee that every business rule has its own unit test case.</li>
<li class="bulletList"><strong class="keyWord">Code must be written to agreed standards</strong>: The need to determine standards for coding is connected to the idea that no matter which developer you have working on a specific part of the project, the code must be written so that any of them will understand it.</li>
<li class="bulletList"><strong class="keyWord">Pair programming</strong>: Pair programming is another difficult approach to achieve in every single minute of a software project, but the technique itself – one programmer coding and the other actively observing and offering comments, criticism, and advice – is useful in critical scenarios.</li>
<li class="bulletList"><strong class="keyWord">Acceptance tests</strong>: The adoption of acceptance tests to meet user stories is a good way to guarantee that newly released versions of the software do not cause damage to its current needs. An even better option is to have these acceptance tests automated.</li>
</ul>
<p class="normal">It is worth <a id="_idIndexMarker039"/>mentioning that many of these rules are today considered vital practices in different software development methodologies, including DevOps and Scrum. We will discuss DevOps later in this book, in <em class="chapterRef">Chapter 8</em>, <em class="italic">Understanding DevOps Principles and CI/CD</em>. Let us get into the Scrum model right now.</p>
<h4 class="heading-4">Getting into the Scrum model</h4>
<p class="normal">Scrum is an <a id="_idIndexMarker040"/>agile model for the<a id="_idIndexMarker041"/> management of software development projects. The model comes from lean principles and is one of the more widely used approaches for developing software<a id="_idIndexMarker042"/> nowadays.</p>
<div><p class="normal">Please check out this link for more information about the Scrum framework: <a href="https://www.scrum.org/">https://www.scrum.org/</a>.</p>
</div>
<p class="normal">As you can<a id="_idIndexMarker043"/> see in the following figure, the basis of Scrum is that you have a flexible backlog of user requirements (<strong class="screenText">Product Backlog</strong>) that needs to be discussed in each agile cycle, called a <strong class="keyWord">Sprint</strong>. The<a id="_idIndexMarker044"/> Sprint goal (<strong class="screenText">Sprint Backlog</strong>) is determined by the <strong class="keyWord">Scrum Team</strong>, composed of <a id="_idIndexMarker045"/>the <strong class="keyWord">Product Owner</strong>, the <strong class="keyWord">Scrum Master</strong>, and<a id="_idIndexMarker046"/> the <strong class="keyWord">Development Team</strong>. The Product Owner is responsible for<a id="_idIndexMarker047"/> prioritizing what will be delivered in that Sprint. During the Sprint, this person will help the team to develop the required features. The person who leads the team in the Scrum process is called the Scrum Master. All the meetings and processes are conducted by this person.</p>
<figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="img/B19820_01_06.png"/></figure>
<p class="packt_figref">Figure 1.6: The Scrum process</p>
<p class="normal">It is common to apply <a id="_idIndexMarker048"/>Scrum together with another agile technique, called <strong class="keyWord">Kanban</strong>, also developed by Toyota for manufacturing cars and commonly <a id="_idIndexMarker049"/>used for software maintenance. The main purpose of Kanban is to enable a visual system to make sure everybody<a id="_idIndexMarker050"/> understands what is going on in the product that is being developed. The famous Kanban board is an incredible way to do so, where you define what the team must do, what they are doing, and the things that are already done. </p>
<p class="normal">It is important to note that the Scrum process does not discuss how the software needs to be implemented, nor which activities will be done. Again, you must remember the basis of software development, discussed at the beginning of this chapter; Scrum needs to be implemented together with a process model. DevOps is one of the approaches that may help you use a software development process model together with Scrum. Check out <em class="chapterRef">Chapter 8</em>, <em class="italic">Understanding DevOps Principles and CI/CD</em>, to understand it better.</p>
<h3 class="heading-3" id="_idParaDest-22">Scaling agile throughout a company</h3>
<p class="normal">Today it is <a id="_idIndexMarker051"/>quite common to find companies where agility is being practiced and evolving in a good way, considering the results of the techniques presented in the previous sections. The mixture of Scrum, Kanban, and XP, together with the evolution of the maturity of the software development process, has brought good results for companies and we have a world where software development is one of the key strategies for the success of a business.</p>
<p class="normal">Some companies naturally need to scale up the number of teams, but the important question in this process is how to evolve without missing agility. And you can be sure that this question may be addressed to you, as a software architect. You may find in <em class="italic">SAFe® – Scaled Agile Framework</em> a good answer to this question:</p>
<blockquote class="packt_quote">
<p class="quote">SAFe® for LeanEnterprises is a knowledge base of proven, integrated principles, practices, and competencies for achieving business agility using Lean, Agile, and DevOps.”</p>
<p class="cite">– Dean Leffingwell, creator.</p>
<p class="cite">© Scaled Agile, Inc.</p>
</blockquote>
<p class="normal">Based on the core values of alignment, built-in quality, transparency, and program execution, the framework provides a detailed path for delivering products with the agility needed in companies where you have one or more value streams. Its principles enable agility and incremental delivery, system thinking, fast and economic decisions, and mainly, organization around value.</p>
<p class="normal">As a software architect, you may find opportunities for growth, considering you can work as a software architect in a system team, a system architect in an agile release train, or even an enterprise architect in the company. For sure, this will require a lot of studying and dedication, but this structure is what you will find in big companies.</p>
<p class="normal">As with every framework, technique, or model that you will find in this book, the purpose of presenting SAFe to you is not to cover every single detail of the content. You will find excellent material and training on their website. But as a software architect, understanding how to scale up a company may be good knowledge to have in your toolbelt! Now that you know it, let us go back to the stages of designing software with high quality, discussing how to gather the right information to design it.</p>
<h1 class="heading-1" id="_idParaDest-23">Gathering the right information to design high-quality software</h1>
<p class="normal">Fantastic! You’ve <a id="_idIndexMarker052"/>just started a software development project. Now, it is time to use all your knowledge to deliver the best software you can. Your first question is probably – <em class="italic">How do I start?</em> Well, as a software architect, you are going to be the one to answer that question. And you can be sure that your answer is going to evolve with each software project you lead.</p>
<p class="normal">Defining a software development process is the first task. This is generally done during the project planning process, or it might happen before it starts.</p>
<p class="normal">Another very important task is to gather the software requirements. No matter which software development process you decide to use, collecting real user needs is part of a difficult and continuous job. Of course, there are techniques to help you with this, and you can be sure that gathering requirements will help you to define important aspects of your software architecture.</p>
<p class="normal">These two tasks are considered by most experts in software development as the keys to success at the end of the development project journey. As a software architect, you need to enable them so that you can avoid as many problems as possible while guiding your team.</p>
<h2 class="heading-2" id="_idParaDest-24">Understanding the requirements gathering process</h2>
<p class="normal">There are <a id="_idIndexMarker053"/>many ways to represent the requirements. The most traditional approach consists of you having to write a perfect specification before the beginning of the analysis. Agile methods suggest instead that you need to write user stories as soon as you are ready to start a development cycle.</p>
<p class="normal">Remember that you do not write requirements just for the user; you write them for you and your team too.</p>
<p class="normal">The truth is that no matter the approach you decide to adopt in your projects, you will have to follow some steps<a id="_idIndexMarker054"/> to gather requirements. This is what we call the <strong class="keyWord">requirements engineering process</strong>.</p>
<figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="img/B19820_01_07.png"/></figure>
<p class="packt_figref">Figure 1.7: Requirements engineering process</p>
<p class="normal">During this <a id="_idIndexMarker055"/>process, you need to be sure that the solution is feasible. In some cases, the feasibility analysis is part of the project planning process too, and by the time you start the requirements elicitation, you will have the feasibility report already done. So, let us check the other parts of this process, which will give you a lot of important information about the software architecture.</p>
<h2 class="heading-2" id="_idParaDest-25">Detecting exact user needs</h2>
<p class="normal">There are a<a id="_idIndexMarker056"/> lot of ways to detect what exactly the user needs for a specific scenario. This process is known as <em class="italic">elicitation</em>. In general, this can be done using techniques that will help you to understand what we call user requirements. Here, you have a list of common techniques:</p>
<ul>
<li class="bulletList"><strong class="keyWord">The power of imagination</strong>: If you are an expert in the area where you are providing solutions, you may use your own imagination to find new user requirements. Brainstorming can be conducted collaboratively so that a group of experts can define the user’s needs.</li>
<li class="bulletList"><strong class="keyWord">Questionnaires</strong>: This tool is useful for detecting common and important requirements such as the number and kind of users, peak system usage, and the most commonly used <strong class="keyWord">OS</strong> and web browser.</li>
<li class="bulletList"><strong class="keyWord">Interviews</strong>: Interviewing the users helps you as an architect to detect user requirements that perhaps questionnaires and your imagination will not cover.</li>
<li class="bulletList"><strong class="keyWord">Observation</strong>: There is no better way to understand the daily routine of a user than observing them for a day.</li>
</ul>
<p class="normal">As soon as<a id="_idIndexMarker057"/> you apply one or more of these techniques, you will have great and valuable information about the user’s needs.</p>
<p class="normal">Remember that you can use these techniques in any situation where the real need is to gather requirements, no matter whether it is for the whole system or for a single story.</p>
<p class="normal">At that moment, you will be able to start analyzing these user needs and detecting the user and system requirements. Let us see how to do so in the next section.</p>
<h2 class="heading-2" id="_idParaDest-26">Analyzing requirements</h2>
<p class="normal">When you <a id="_idIndexMarker058"/>have detected the user needs, it is time to begin analyzing the requirements. To do so, you can use techniques such as the following:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Prototyping</strong>: Prototypes <a id="_idIndexMarker059"/>are fantastic to clarify and materialize the system requirements. Today, we have many tools that can help you to<a id="_idIndexMarker060"/> mock interfaces. A nice open-source tool is the <strong class="keyWord">Pencil Project</strong>. You will find further information about it at <a href="https://pencil.evolus.vn/">https://pencil.evolus.vn/</a>. <strong class="keyWord">Figma</strong> (<a href="https://www.figma.com/">https://www.figma.com/</a>) is also a good tool <a id="_idIndexMarker061"/>for prototyping and they provide a starter pack that is free forever.</li>
<li class="bulletList"><strong class="keyWord">Use cases</strong>: The <strong class="keyWord">Unified Modeling Language</strong> (<strong class="keyWord">UML</strong>) use case model is an option if you <a id="_idIndexMarker062"/>need detailed documentation. The model is composed of a detailed specification and a diagram. <strong class="keyWord">Lucidchart</strong> (<a href="https://www.lucidchart.com/">https://www.lucidchart.com/</a>) is another good tool that <a id="_idIndexMarker063"/>can help you out with this. You <a id="_idIndexMarker064"/>can see the model created in <em class="italic">Figure 1.8</em>:</li>
</ul>
<figure class="mediaobject"><img alt="Diagrama  Descrição gerada automaticamente" src="img/B19820_01_08.png"/></figure>
<p class="packt_figref">Figure 1.8: Use case diagram example</p>
<p class="normal">While you are analyzing the requirements of the system, you will be able to clarify exactly what the user’s needs are. This is helpful when you are not sure about the real problem you need<a id="_idIndexMarker065"/> to solve, and it is much better than just starting to program the system and hoping for the best. Time invested in requirements analysis is time invested in better code later.</p>
<h2 class="heading-2" id="_idParaDest-27">Writing the specifications</h2>
<p class="normal">After<a id="_idIndexMarker066"/> you finish the analysis, it is important to register it as a specification. The specification document can be written using traditional requirements, or user stories, which are commonly used in agile projects.</p>
<p class="normal">A requirements specification represents the technical contract between the user and the team. There are some basic rules that this document needs to follow:</p>
<ul>
<li class="bulletList">All stakeholders need to understand exactly what is written in the technical contract, even if they are not technicians.</li>
<li class="bulletList">The document needs to be clear.</li>
<li class="bulletList">You need to classify each requirement.</li>
<li class="bulletList">Use simple future tense to represent each requirement:<ul>
<li class="bulletList"><strong class="keyWord">Bad example</strong>: A common user registers themselves.</li>
<li class="bulletList"><strong class="keyWord">Good example</strong>: A common user shall register themselves.</li>
</ul>
</li>
<li class="bulletList">Ambiguity and controversy need to be avoided.</li>
<li class="bulletList">Some additional information can help the team to understand the context of the project they are going to work on. Here are some tips about how to add useful information:<ul>
<li class="bulletList">Write an introductory chapter to give a full idea of the solution.</li>
<li class="bulletList">Create a glossary to make understanding easier.</li>
<li class="bulletList">Describe the kind of user the solution will cover.</li>
</ul>
</li>
<li class="bulletList">Write functional and non-functional requirements:
    <p class="normal">Functional requirements are quite simple to understand because they describe exactly what the software will do. On the other hand, non-functional requirements determine the restrictions related to the software, which means scalability, robustness, security, and performance. We will cover these aspects in the next section.</p></li>
</ul>
<ul>
<li class="bulletList">Attach documents that can help the user to understand the rules.</li>
</ul>
<p class="normal">If you decide to write user stories, a good tip to follow is to write short sentences representing each moment in the system with each user, as follows:</p>
<p class="normal"><em class="italic">As &lt;user&gt;, I want &lt;feature&gt;, so that &lt;reason&gt;</em></p>
<p class="normal">This approach <a id="_idIndexMarker067"/>will explain exactly the reason why that feature will be implemented. It is also a good tool to help you analyze the stories that are most important and prioritize the success of the project. They can also be great for informing the automated acceptance tests that should be built.</p>
<h2 class="heading-2" id="_idParaDest-28">Understanding the principles of scalability, robustness, security, and performance</h2>
<p class="normal">Detecting requirements is a task that will let you understand the software you are going to develop. However, as a software architect, you must pay attention to more than just the functional requirements for that system. Understanding the non-functional requirements is important, and one of the earliest activities for a software architect.</p>
<p class="normal">We are going to look at this in more detail in <em class="italic">Chapter 2</em>, <em class="italic">Non-Functional Requirements</em>, but at this point, it is important to know that the principles of scalability, robustness, security, and performance need to be applied to the requirements gathering process. Let us look at each concept:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Scalability</strong>: The<a id="_idIndexMarker068"/> Internet gives you the opportunity to have a solution with a great number of users all over the world. This is fantastic, but you, as a software architect, need to design a solution that provides that possibility. Scalability is the possibility for an application to increase its processing power as soon as it is necessary, due to the number of resources that are being consumed.</li>
<li class="bulletList"><strong class="keyWord">Robustness</strong>: No<a id="_idIndexMarker069"/> matter how scalable your application is, if it is not able to guarantee a stable and always-on solution, you are not going to get any peace. Robustness is important for critical solutions, where you do not have the opportunity to carry out maintenance at any time due to the kind of problem that the application solves. In many industries, the software cannot stop, and lots of routines run when nobody is available (overnight, during holidays, and so on). Designing a reliable solution will free you up to live your life while your software is running smoothly.</li>
<li class="bulletList"><strong class="keyWord">Security</strong>: This is <a id="_idIndexMarker070"/>another really important area that needs to be discussed after the requirements stage. Everybody worries about security, and different laws dealing with it are in place in different parts of the world. You, as a software architect, must understand that security needs to be provided by design. This is the only way to cope with all the needs that the security community is discussing right now.</li>
<li class="bulletList"><strong class="keyWord">Performance</strong>: The<a id="_idIndexMarker071"/> process of understanding the system you are going to develop will probably give you a good idea of what you will need to do to get the desired performance from the system. This topic needs to be discussed with the user, to identify most of the bottlenecks you will face during the development stage.</li>
</ul>
<p class="normal">It is worth mentioning that all these concepts are requirements for the new generation of solutions that the world needs. What differentiates good software from incredible software is the amount of work done to meet the project requirements.</p>
<h2 class="heading-2" id="_idParaDest-29">Reviewing the specification</h2>
<p class="normal">Once you<a id="_idIndexMarker072"/> have the specification written, it is time to confirm with the stakeholders whether they agree with it. This can be done in a review meeting, or it can be done online using collaboration tools.</p>
<p class="normal">This is when you present all the prototypes, documents, and information you have gathered. As soon as everybody agrees with the specification, you are ready to start studying the best way to implement this part of your project.</p>
<p class="normal">It is worth mentioning that you might use the process described here for either the complete software or for just a small part of it.</p>
<h1 class="heading-1" id="_idParaDest-30">Using design techniques as a helpful tool</h1>
<p class="normal">Defining a solution is not easy. Determining which technology to use is also difficult. It is true that, during your career as a software architect, you will find many projects where your customer will bring you a solution <em class="italic">ready for development</em>. This can get quite complicated if you consider that solution as the correct solution; most of the time, there will be architectural and functional mistakes that will cause problems in the solution in the future.</p>
<p class="normal">There are some cases where the problem is worse – when the customer does not know the best solution for the problem. Some design techniques can help us with this, and we will introduce two of them here: <strong class="keyWord">Design Thinking</strong> and <strong class="keyWord">Design Sprint</strong>.</p>
<p class="normal">What you must understand is that these techniques can be a fantastic option to discover real requirements. As a software architect, you are committed to helping your team to use the correct tools at the correct time, and these tools may be the right options to ensure the project’s success.</p>
<h2 class="heading-2" id="_idParaDest-31">Design Thinking</h2>
<p class="normal">Design Thinking <a id="_idIndexMarker073"/>is a process that allows you to collect data directly from the users, focusing on achieving the best results to solve a problem. During this process, the team will have the opportunity to discover all the <em class="italic">personas</em> that will interact with the system. This will have a wonderful impact on the solution since you can develop the software by focusing on the user experience, which can have a fantastic impact on the results.</p>
<p class="normal">The process is based on the following steps:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord">Empathize</strong>: In this step, you must execute field research to discover users’ concerns. This is where you find out about the users of the system. The process is good for making you understand why and for whom you are developing this software.</li>
<li class="numberedList"><strong class="keyWord">Define</strong>: Once you have the users’ concerns, it is time to define their needs to solve them.</li>
<li class="numberedList"><strong class="keyWord">Ideate</strong>: The needs will provide an opportunity to brainstorm some possible solutions.</li>
<li class="numberedList"><strong class="keyWord">Prototype</strong>: These solutions can be developed as mock-ups to confirm whether they are good ones.</li>
<li class="numberedList"><strong class="keyWord">Test</strong>: Testing the prototypes will help you to understand the prototype that is most connected to the real needs of the users.</li>
</ol>
<p class="normal">The focus of a<a id="_idIndexMarker074"/> technique like this one is to accelerate the process of discerning the right product and considering the <strong class="keyWord">Minimum Viable Product</strong> (<strong class="keyWord">MVP</strong>). For sure, the prototype process will help stakeholders to understand the final product and, at the same time, engage the team to deliver the best solution.</p>
<h2 class="heading-2" id="_idParaDest-32">Design Sprint</h2>
<p class="normal">Design Sprint <a id="_idIndexMarker075"/>is a process focused on solving critical business questions through design in a five-day sprint. This technique was presented by Google, and it is something that allows you to quickly test and learn from an idea when you are looking to build and launch a solution to market.</p>
<p class="normal">The process involves experts spending a week to solve the problem at hand, in a war room prepared for that purpose. The week looks like this:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Monday</strong>: The focus of this day is to identify the target of the sprint and map the challenge to achieve it.</li>
<li class="bulletList"><strong class="keyWord">Tuesday</strong>: After understanding the goal of the sprint, participants start sketching solutions that may solve it. It is time to find customers to test the new solution that will be provided.</li>
<li class="bulletList"><strong class="keyWord">Wednesday</strong>: This is when the team needs to decide on the solutions that have the greatest chance of solving the problem. The team must draw these solutions into a storyboard, preparing a plan for the prototype.</li>
<li class="bulletList"><strong class="keyWord">Thursday</strong>: It is time to prototype the idea planned on the storyboard.</li>
<li class="bulletList"><strong class="keyWord">Friday</strong>: Having completed the prototype, the team presents it to customers, learning by getting information from their reactions to the solution designed.</li>
</ul>
<p class="normal">As you can see, in both techniques, the acceleration of collecting reactions from customers comes from prototypes that will materialize your team’s ideas into something more tangible for the end user.</p>
<h1 class="heading-1" id="_idParaDest-33">Common cases where the requirements gathering process impacts system results</h1>
<p class="normal">All the information <a id="_idIndexMarker076"/>discussed up to this point in the chapter is useful if you want to design software following the principles of good engineering. Rather than advocating for traditional or agile development methods, the emphasis is on building software in a professional manner.</p>
<p class="normal">It is also a good idea to know about some cases in which failing to perform the activities you read about can cause some trouble for a software project. The following cases intend to describe what can go wrong, and how the preceding techniques can help a development team to solve the associated problems.</p>
<p class="normal">In most cases, very simple actions can guarantee better communication between the team and the customer, and this easy communication flow can transform a big problem into a real solution. Let us examine three common cases where requirements gathering can impact software performance, functionality, and usability.</p>
<h2 class="heading-2" id="_idParaDest-34">Case 1 – my website is too slow to open that page!</h2>
<p class="normal">Performance is one of the biggest problems that you as a software architect will deal with during your career. The reason why this aspect of any software is so problematic is that we do not have infinite computational resources to solve problems. The cost of computation is still high, especially if you are talking about software with a high number of simultaneous users.</p>
<p class="normal">You cannot solve performance problems by writing requirements. However, you will not end up in trouble if you write them correctly. The idea here is that requirements must present the desired performance of a system. A simple sentence describing this can help the entire team that works on the project:</p>
<p class="normal"><em class="italic">Non-functional requirement: Performance – any web page of this software shall respond in at least 2 seconds, even when 1,000 users are accessing it concurrently</em>.</p>
<p class="normal">The preceding sentence just lets everybody (users, testers, developers, architects, managers, and so on) know that any web page has a target to achieve. This is a good start, but it is not enough. A great environment for developing and deploying your application is also important. This is where .NET 8 can help you a lot; especially if you are talking about web apps, ASP.NET Core is considered one of the fastest options to deliver solutions today.</p>
<p class="normal">When it comes to <a id="_idIndexMarker077"/>performance, you, as a software architect, should consider the use of the techniques listed in the following sections together with specific tests to guarantee this non-functional requirement. It is also important to mention that ASP.NET Core will help you to use them easily, together with <a id="_idIndexMarker078"/>some <strong class="keyWord">Platform as a Service</strong> (<strong class="keyWord">PaaS</strong>) solutions delivered by Microsoft Azure.</p>
<h3 class="heading-3" id="_idParaDest-35">Understanding backend caching</h3>
<p class="normal">Caching is a <a id="_idIndexMarker079"/>great technique to avoid time-consuming and redundant queries. For instance, if you are fetching car models from a database, the number of cars in the database can <a id="_idIndexMarker080"/>increase, but the models themselves will not change. Once you have an application that constantly accesses car models, a good practice is to cache that information.</p>
<p class="normal">It is important to understand that a cache is stored in the backend and that cache is shared by the whole application (<em class="italic">in-memory caching</em>). A point to focus on is that when you are working on a scalable solution, you can configure a <em class="italic">distributed cache</em> using the Azure platform. In fact, ASP.NET provides both in-memory caching and distributed caching, so you can decide on the one that best fits your needs. <em class="chapterRef">Chapter 2</em>, <em class="italic">Non-Functional Requirements</em>, covers scalability aspects in the Azure platform.</p>
<p class="normal">It is also important to mention that caching can happen in the frontend, in proxies along the way to the server, CDNs, and so on.</p>
<h3 class="heading-3" id="_idParaDest-36">Applying asynchronous programming</h3>
<p class="normal">When you<a id="_idIndexMarker081"/> develop ASP.NET applications, you need to keep in mind that your app needs to be designed for simultaneous access by many users. Asynchronous programming lets you do this simply, by giving you the keywords <code class="inlineCode">async</code> and <code class="inlineCode">await</code>.</p>
<p class="normal">The basic concept behind these keywords is that <code class="inlineCode">async</code> enables any method to run asynchronously. On the other hand, <code class="inlineCode">await</code> lets you synchronize the call of an asynchronous method without blocking the thread that is calling it. This easy-to-develop pattern will make your application run without performance bottlenecks and bring better responsiveness. This book will cover more about this subject in <em class="chapterRef">Chapter 2</em>, <em class="italic">Non-Functional Requirements</em>.</p>
<h3 class="heading-3" id="_idParaDest-37">Dealing with object allocation</h3>
<p class="normal">One very good tip <a id="_idIndexMarker082"/>to avoid poor performance is to understand how<a id="_idIndexMarker083"/> the <strong class="keyWord">Garbage Collector </strong>(<strong class="keyWord">GC</strong>) works. The GC is the engine that will free memory automatically when you finish using it. There are some very important aspects of this topic, due to the complexity that the GC has.</p>
<p class="normal">Some types of objects are not collected by the GC if you do not dispose of them. The list includes any object that interacts with I/O, such as files and streaming. If you do not correctly use the C# syntax to create and destroy this kind of object, you will have memory leaks, which will deteriorate your application’s performance.</p>
<p class="normal">The incorrect way of working with I/O objects is:</p>
<pre class="programlisting code"><code class="hljs-code">System.IO.StreamWriter file = new System.IO.StreamWriter(@"C:\sample.txt");
file.WriteLine("Just writing a simple line");
</code></pre>
<p class="normal">The correct way of working with I/O objects is:</p>
<pre class="programlisting code"><code class="hljs-code">using System.IO.StreamWriter file = new System.IO.StreamWriter(@"C:\sample.txt");
file.WriteLine("Just writing a simple line");
</code></pre>
<p class="normal">It might<a id="_idIndexMarker084"/> be worth noting that this correct approach also ensures the file gets written (it calls <code class="inlineCode">FileStream.Flush()</code> to dispose of its resources gracefully). In the incorrect example, the contents might not even be written to the file. Even though the preceding practice is mandatory for I/O objects, it is totally recommended that you keep doing this in all disposable objects. Indeed, using code analyzers in your solutions with warnings as errors will prevent you from accidentally making these mistakes! This will help the GC and will keep your application running with the right amount of memory. Depending on the type of object, mistakes here can snowball, and you could end up with other bad things on a bigger scale, for instance, port/connection exhaustion.</p>
<p class="normal">Another important aspect that you need to know about is that the time spent by the GC collecting objects will interfere with the performance of your app. Because of this, avoid allocating large objects and be careful with event handling and week references; otherwise, it can lead to you always waiting for the GC to finish its task.</p>
<h3 class="heading-3" id="_idParaDest-38">Getting better database access</h3>
<p class="normal">One of the most common performance Achilles’ heels is database access. The reason why this is still a big problem is a lack of attention paid while writing queries or lambda expressions to get information from a database. This book will cover Entity Framework Core in <em class="chapterRef">Chapter 13</em>, <em class="italic">Interacting with Data in C# – Entity Framework Core</em>, but it is important to know what to choose and the correct data information to read from a database. Filtering columns and rows is imperative for an application that wants to deliver on performance.</p>
<p class="normal">The good <a id="_idIndexMarker085"/>thing is that best practices related to caching, asynchronous programming, and object allocation fit completely into the environment of databases. It is only a matter of choosing the correct pattern to get better-performing software.</p>
<h2 class="heading-2" id="_idParaDest-39">Case 2 – the user’s needs are not properly implemented</h2>
<p class="normal">The more<a id="_idIndexMarker086"/> technology is used in a wide variety of areas, the more difficult it is to deliver exactly what the user needs. Maybe this sentence sounds weird to you, but you must understand that developers, in general, study how to develop software, but they rarely study delivering the needs of a specific area. Of course, it is not easy to learn how to develop software, but it is even more difficult to understand a specific need in a specific area. Software development nowadays delivers software to all types of industries. The question here is <em class="italic">how can a developer, whether a software architect or not, evolve enough to deliver software in the area they are responsible for?</em></p>
<p class="normal">Gathering software requirements will help you in this tough task; writing them will make you understand and organize the architecture of the system. There are several ways to minimize the risks of implementing something different from what the user really needs:</p>
<ul>
<li class="bulletList">Prototyping the interface to achieve an understanding of the user interface faster</li>
<li class="bulletList">Designing the data flow to detect gaps between the system and the user operations</li>
<li class="bulletList">Frequent meetings to stay up to date on the user’s current needs and be aligned with incremental deliveries</li>
</ul>
<p class="normal">Again, as a software architect, you will have to define how the software will be implemented. Most of the time, you are not going to be the one who programs it, but you will always be the one responsible for this. For this reason, some techniques can be useful to avoid the wrong implementation:</p>
<ul>
<li class="bulletList">Requirements are reviewed by the developers to guarantee that they understand what they need to develop.</li>
<li class="bulletList">Code inspection to validate a predefined code standard. We will cover this in <em class="chapterRef">Chapter 4</em>, <em class="italic">Best Practices in Coding C# 12</em>.</li>
<li class="bulletList">Meetings to eliminate impediments.</li>
</ul>
<p class="normal">Remember, making sure the implementation matches the user’s needs is your responsibility. Use every tool you can to do so.</p>
<h2 class="heading-2" id="_idParaDest-40">Case 3 – the usability of the system does not meet the user’s needs</h2>
<p class="normal">Usability is a key <a id="_idIndexMarker087"/>point for the success of a software project. The way the software is presented and how it solves a problem will determine whether the user wants to use it or not. As a software architect, you must keep in mind that delivering software with good usability is mandatory nowadays.</p>
<p class="normal">There are basic concepts of usability that this book does not intend to cover, but a good way to meet the user’s needs when it comes to usability is by understanding who is going to use the software. Design Thinking can help you a lot with that, as was discussed earlier in this chapter.</p>
<p class="normal">Understanding the user will help you to decide whether the software is going to run on a web page, a cell phone, or even in the background. This understanding is very important to a software architect because the elements of a system will be better presented if you correctly map who will use them.</p>
<p class="normal">On the other hand, if you do not care about that, you will just deliver software that works. This can be good for a short time, but it will not exactly meet the real needs that made a person ask you to architect the software. You must keep in mind the options and understand that good software is software designed to run on many platforms and devices.</p>
<p class="normal">You will be happy to know that .NET 8 is an incredible cross-platform option for that. So, you can develop solutions to run your apps in Linux, Windows, Android, and iOS. You can run your applications on big screens, tablets, cell phones, and even drones! You can embed apps on boards for automation or in HoloLens for mixed reality. Software architects must be open-minded to design exactly what their users need.</p>
<h1 class="heading-1" id="_idParaDest-41">Summary</h1>
<p class="normal">In this chapter, you learned about the purpose of a software architect in a software development team. Also, this chapter covered the basics of software development process models and the requirements gathering process. You also had the opportunity to learn about how to create your Azure account, which will be used during the case study of this book. Moreover, you even learned about functional and non-functional requirements and how to create them using user stories. These techniques will help you deliver a better software project.</p>
<p class="normal">In the next chapter, you will have the opportunity to understand how important functional and non-functional requirements are to software architecture.</p>
<h1 class="heading-1" id="_idParaDest-42">Questions</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">What is the expertise that a software architect needs to have?</li>
<li class="numberedList">How can Azure help a software architect?</li>
<li class="numberedList">How does a software architect decide on the best software development process model to use in a project?</li>
<li class="numberedList">How does a software architect contribute to gathering requirements?</li>
<li class="numberedList">What kind of requirements does a software architect need to check in a requirements specification?</li>
<li class="numberedList">How do Design Thinking and Design Sprint help a software architect in the process of gathering requirements?</li>
<li class="numberedList">How do user stories help a software architect in the process of writing requirements?</li>
<li class="numberedList">What are some good techniques to develop very good performance software?</li>
<li class="numberedList">How does a software architect check whether a user requirement is correctly implemented?</li>
</ol>
<h1 class="heading-1" id="_idParaDest-43">Further reading</h1>
<p class="normal">Here, we have listed some books and links you may consider using to gather more information about the topics covered in this chapter.</p>
<ul>
<li class="bulletList">For information on Azure, check these out:<ul>
<li class="bulletList"><a href="https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers">https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers</a></li>
<li class="bulletList"><a href="https://azure.microsoft.com/overview/what-is-azure/">https://azure.microsoft.com/overview/what-is-azure/</a></li>
<li class="bulletList"><a href="https://azure.microsoft.com/services/devops/">https://azure.microsoft.com/services/devops/</a></li>
<li class="bulletList"><a href="https://azurecharts.com/">https://azurecharts.com/</a></li>
</ul>
</li>
<li class="bulletList">More information on .NET 8 can be found here:<ul>
<li class="bulletList"><a href="https://docs.microsoft.com/dotnet/">https://docs.microsoft.com/dotnet/</a></li>
<li class="bulletList"><a href="https://docs.microsoft.com/aspnet/">https://docs.microsoft.com/aspnet/</a></li>
<li class="bulletList"><a href="https://docs.microsoft.com/aspnet/core/performance/performance-best-practices">https://docs.microsoft.com/aspnet/core/performance/performance-best-practices</a></li>
</ul>
</li>
<li class="bulletList">Software development process model links are listed here:<ul>
<li class="bulletList"><a href="https://agilemanifesto.org/">https://agilemanifesto.org/</a></li>
<li class="bulletList"><a href="https://www.amazon.com/Software-Engineering-10th-Ian-Sommerville/dp/0133943038">https://www.amazon.com/Software-Engineering-10th-Ian-Sommerville/dp/0133943038</a></li>
<li class="bulletList"><a href="https://www.amazon.com/Software-Engineering-Practitioners-Roger-Pressman/dp/0078022126/">https://www.amazon.com/Software-Engineering-Practitioners-Roger-Pressman/dp/0078022126/</a></li>
<li class="bulletList"><a href="https://scrumguides.org/">https://scrumguides.org/</a></li>
<li class="bulletList"><a href="https://www.packtpub.com/application-development/professional-scrummasters-handbook">https://www.packtpub.com/application-development/professional-scrummasters-handbook</a></li>
<li class="bulletList"><a href="https://en.wikipedia.org/wiki/Incremental_build_model">https://en.wikipedia.org/wiki/Incremental_build_model</a></li>
<li class="bulletList"><a href="https://en.wikipedia.org/wiki/Waterfall_model">https://en.wikipedia.org/wiki/Waterfall_model</a></li>
<li class="bulletList"><a href="http://www.extremeprogramming.org/">http://www.extremeprogramming.org/</a></li>
<li class="bulletList"><a href="https://www.gv.com/sprint/">https://www.gv.com/sprint/</a></li>
</ul>
</li>
<li class="bulletList">Here you can find SAFe® information:<ul>
<li class="bulletList"><a href="https://www.scaledagileframework.com/">https://www.scaledagileframework.com/</a></li>
<li class="bulletList"><a href="https://scaledagile.com/train-certify/">https://scaledagile.com/train-certify/</a></li>
<li class="bulletList"><a href="https://docs.microsoft.com/azure/devops/boards/plans/safe-concepts">https://docs.microsoft.com/azure/devops/boards/plans/safe-concepts</a></li>
</ul>
</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code1750817512109020461.png"/></p>
</div>
</body></html>