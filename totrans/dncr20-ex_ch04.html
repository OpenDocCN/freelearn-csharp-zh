<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>Let&amp;#x27;s Chat Web Application</title>
    <link href="css/style.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Let's Chat Web Application</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>T</span>here is an old saying:</p>
<div class="mce-root packt_quote"><em>"A single conversation with a wise person is worth a month's study of books</em>."</div>
<p class="mce-root">With this thought, let's enable a conversation with our online friends by developing a chat application called Let's Chat in ASP.NET Core 2.0. Over the course of the next three chapters, we will be developing and deploying this chat app. While doing so, we will dive deep into ASP.NET Core 2.0 features, learn their intricacies, and learn how to unit test our ASP.NET Core 2.0 app. We will also learn about containers and deploy our app on the cloud. We will end these three chapters with a quick development and walkthrough of a Chatbot using the Microsoft Bot Framework, which can be easily created in a matter of minutes and can be added to any of your web apps and also integrated with social networks.&#160; In this chapter, we will cover the following topics:</p>
<ul>
<li>Let's Chat web app requirement specifications</li>
<li>Let's Chat web app design</li>
<li>Project setup</li>
</ul>
<p>With reference to ASP.NET Core 2.0, we will also learn the following:</p>
<ul>
<li>Authentication</li>
<li>Authorization</li>
<li>ASP.NET Core pipeline</li>
<li>Middleware</li>
<li>Dependency registration</li>
<li>Reading configuration values</li>
<li>Logging</li>
</ul>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Let's Chat web app requirement specifications</h1>
                </header>
            
            <article>
                
<p>In this section, we will discuss the requirements for developing our Let's Chat web application in ASP.NET Core 2.0.</p>
<p>As a user, I should be able to fulfill t<span>he following requirements for this chat room app</span>:</p>
<ol>
<li>Register myself in the web app</li>
<li>Log in to the app</li>
<li>Reset the password in case I have forgotten the old one</li>
<li>See a list of all the currently logged in users in the chat room</li>
<li>See a users joining or leaving the chat room</li>
<li>See the display pictures of logged in users, if they exist</li>
<li>Chat with all online users at the same time, just like a chat room</li>
<li>Access the app from a browser over the internet and chat with any number of online users</li>
</ol>
<p>To give an example, we are looking at a highly trimmed down version of something like <a href="https://gitter.im/dotnet/cli">https://gitter.im/dotnet/cli</a>, which is a chat room for .NET Core <strong>command-line interface</strong> (<strong>CLI</strong>) tools.&#160;</p>
<p>Now that we have the requirement specifications in place, let's see the activity flow of the app and come up with a flowchart. The following is a rough flowchart of the app workflow:</p>
<div class="CDPAlignCenter CDPAlign"><img height="398" width="404" src="assets/e8aeb145-101d-449f-8dde-6419c16c2cde.png"/></div>
<p>Let's have a look at the flow:</p>
<ol>
<li><strong>Start</strong>: This is the start of the flow. The user browses the chat URL. It is being conceptualized as a site, as we want to access it from the browser and chat with any number of online users (requirement&#160;<em>Steps 7</em> and <em>8</em>).</li>
<li><strong>Is user logged in</strong>?: At this point, the app checks whether the user is authenticated or not, that is, the user is logged in or not. If the user is logged in, he/she is redirected to the chat room page; otherwise, the user is redirected to the login page. There is also the provision to reset the password (requirement&#160;<em>Steps 2</em> and <em>3</em>).</li>
</ol>
<ol start="3">
<li><strong>Is user registered?</strong>: When the user is not logged in, he/she is redirected to the login page, where they need to provide a proper username and password to get authenticated and logged in. But this can happen only if the user has valid credentials, that is, the user is already registered (requirement <em>Step 1</em>).</li>
<li><strong>Register User</strong>: If the user is not registered, the app should provide a provision to register the user (requirement <em>Step 1</em>).</li>
<li><strong>Login</strong>: This is the landing screen for any unauthenticated user. Already authenticated users are directly navigated to the chat room page. This indicates to other online users that the user has joined the room (requirement <em>Step 2</em>).</li>
<li><strong>Chat Room</strong>: Upon successful authentication, the user is redirected to the chat room, where he/she can see the list of online users and chat with all of them (requirements <em>Steps 4</em>, <em>5</em>, and <em>6</em>).</li>
<li><strong>Chat with other users</strong>: Once the user is in the chat room, he/she can chat with all the online users and can also see their names and display pictures in the chat (requirements <em>Steps 6</em> and <em>7</em>).</li>
<li><strong>Finish</strong>: Once the user is done chatting with their friends, he /she can exit the page. This indicates to other online users that the user has left the room (requirement <em>Step 5</em>).</li>
</ol>
<p>As we can see and infer from the flowchart, this is pretty much how every modern online app workflow happens. We also see that chatting happens only in <em>Steps 6</em> and <em>7</em> of the flowchart. All the other steps are for authentication and setup. We also know that this flow covers all the requirements.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Let's Chat web app&#160;– high-level design</h1>
                </header>
            
            <article>
                
<p>In this section, we will look at the flowchart that we created and we will come up with granular modules to constitute the app using ASP.NET Core 2.0. We need to develop the following:</p>
<ul>
<li>An authentication and authorization module that takes care of login and authentication of users</li>
<li>A registration module that takes care of user registration</li>
<li>A chat room page</li>
<li>A module that keeps track of all the logged in users and notifies the client chat room pages about the user joining and leaving</li>
<li>A user information module that keeps track of all the user information, such as display name, display picture, and so on</li>
<li>A chat hub module that enables a message to be broadcast from each user to the other online users</li>
</ul>
<p>Sounds easy? Let's see how we can design and implement each of the preceding requirements using ASP.NET Core 2.0:</p>
<ul>
<li><strong>Authentication and authorization&#160;module</strong>: This is a core functionality and needed in most modern apps. It makes sense to use something that is already developed, tested, and secure, so that we do not waste our time and energy in rediscovering the wheel. There are a variety of ways by which we can achieve this, such as by creating and using a custom identity provider, or using Facebook, Twitter, Google, or Microsoft authentication providers. We will use Facebook authentication in our app, as it's more likely for the user to have a profile picture in Facebook, which would give a good user experience while chatting. This is done through OAuth (pronounced&#160;<em>oh-auth</em>), which stands for open authorization and is an open standard for token-based authentication and authorization on the internet. We will discuss this in detail when we implement it in our app. This will take care of <em>Steps 1</em> through <em>5</em> in our flowchart discussed in the previous section.</li>
<li><strong>Chat hub module</strong>: This module will be responsible for enabling real-time chat between all online users and will also track the users as they join and leave the room. The hub will receive messages from clients and then broadcast the received messages to all clients. This will be an implementation on top of the SignalR hub and will be responsible for handling user connections, disconnections, and all the real-time messaging functionality. We have already seen and coded the basics of SignalR in our last app.</li>
</ul>
<p>Now that we have high-level designs in place, let's deep dive into the details to implement these and learn more about them.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Project setup</h1>
                </header>
            
            <article>
                
<p>In this section, we will start the development of the Let's Chat web app and learn all the required fundamentals and ASP.NET Core 2.0 features in the process.</p>
<p>Create a new ASP.NET Core 2.0 MVC app named Let's Chat, like we did in the <em>Creating a simple running code</em>&#160;section of <a href="ch01.html">Chapter 1</a>, <em>Getting Started</em>.</p>
<p>Since we need SignalR as well for all the real-time messaging, we need to install the SignalR package in our app. To do so, please follow the steps mentioned in the <em>Project setup</em>&#160;section of <a href="ch03.html">Chapter 3</a>, <em>Building Our First .NET Core Game - Tic</em>&#160;-<em>Tac-Toe.</em></p>
<p>After installation of SignalR, we are ready to start coding the app. We will start with the authentication and authorization module first and then move on to the Chat hub module.</p>
<p>Authentication and authorization are closely interlinked, but are quite different and are the fundamental concepts of security for distributed applications. It's imperative we understand these concepts so that we can develop a secure application. One of the most defining principles of security is <em>trust</em>. When we make our web app available on the internet, it's like keeping our resource in a public area, where hundreds and thousands of people can see it. Do you trust that your resource will be safe? There is a saying,&#160;<em>In God we trust, the rest must bring data</em>&#160;so, it's a big <em>NO</em>! Just like stuff left in a public area is not safe, the content we have made available on the internet is not safe and from this comes the need for authentication and authorization. Let's understand authentication and authorization, and then dig into coding the module.</p>
<p>Authentication deals with the process of obtaining some sort of credentials from the users and validates the user's identity based on these credentials. Authorization is the process of specifying the privileges/access rights of the resources to the authenticated resources. Authentication always happens before authorization, even if the app allows anonymous access, as the app would identify the user as an anonymous user first and then grant access. Authorization generally works on the basis of the principle of least privilege.</p>
<p>In research, investigations, and journalism, the <em>Five Ws and How or 5W1H</em>&#160;methodology of questioning is known to be a highly effective way of gathering the information, so let's use the same approach to understand authentication and authorization:</p>
<div>
<table>
<tbody>
<tr>
<td>
<p><strong>Question</strong></p>
</td>
<td>
<p><strong>Authentication</strong></p>
</td>
<td>
<p><strong>Authorization</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>What/who?</strong></p>
</td>
<td>
<p>As per the Oxford dictionary, the meaning of the word authentication in the computing world is <em>The process or action of verifying the identity of a user or process. It is meant to identify the user/process and whether it is valid.</em></p>
</td>
<td>
<p>As per the Oxford dictionary, the literal meaning of the word authorization is <em>The action of authorizing.</em></p>
</td>
</tr>
<tr>
<td>
<p><strong>Why?</strong></p>
</td>
<td>
<p>To validate the identity of the user/process on the basis of credentials.</p>
</td>
<td>
<p>To control or restrict access to your devices/services/resources.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Where/when?</strong></p>
</td>
<td>
<p>Wherever/whenever I need to restrict or control access to devices/services. But security experts may differ in their answer and say everywhere and at all times.</p>
</td>
<td>
<p>Wherever/whenever I need to restrict or control access to devices/services. But security experts may differ in their answer and say everywhere and at all times.</p>
</td>
</tr>
<tr>
<td>
<p><strong>How?</strong></p>
</td>
<td>
<p>Validate the supplied credentials against the stored credentials.</p>
</td>
<td>
<p>Check the role of the user/process and grant or refuse access to the resource.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Example</strong></p>
</td>
<td>
<p>Someone knocks at your door. You look out and check you know the person by identifying him/her. This is authentication. The question that comes to mind is <em>who are you?</em></p>
</td>
<td>
<p>In the same example, after performing authentication (identifying the person), you either let him/her into your house if the person is your friend or relative, or you don't if you don't know them well. This is authorization. The question that comes to mind is <em>what privileges do you have?</em></p>
</td>
</tr>
</tbody>
</table>
</div>
<p>The following diagram illustrates the authentication and authorization flow:</p>
<div class="CDPAlignCenter CDPAlign"><img height="60" width="341" src="assets/388dd761-aaa8-4c49-ba1c-69852fbb1eff.png"/></div>
<p>Authentication and authorization are vast topics and if we go into details, there could be a book on them alone, so we will briefly look at the various different implementations and related buzzwords to get the gist of them. The enthusiastic reader may want to read more about authentication and authorization. A few great and reliable resources I can suggest are:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/">https://docs.microsoft.com/en-us/aspnet/core/security/authorization/</a></li>
<li><a href="https://channel9.msdn.com/Search?term=Advanced%20ASP.NET%20Core%20Authorization%20with%20Barry%20Dorrans#pubDate=year&amp;ch9Search&amp;lang-en=en">https://channel9.msdn.com/Search?term=Advanced%20ASP.NET%20Core%20Authorization%20with%20Barry%20Dorrans#pubDate=year&amp;ch9Search&amp;lang-en=en</a></li>
</ul>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Authentication</h1>
                </header>
            
            <article>
                
<p>There has been a variety of implementations for authentication in ASP.NET over the years. Some of the most well-known ones are:</p>
<ul>
<li>Windows authentication</li>
<li>Forms authentication</li>
<li>Token-based authentication</li>
</ul>
<p>The following sections discuss these further.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Windows authentication</h1>
                </header>
            
            <article>
                
<p>This uses local Windows users and groups to authenticate. It can be sub-classified into:</p>
<ul>
<li><strong>Basic authentication:</strong><em>&#160;</em>&#160;Usernames and passwords are sent as Base64-encoded strings and hence can be easily cracked, so it's a very weak form of authentication and should not be used.</li>
<li><strong>Digest authentication:</strong>&#160;Issues with basic authentication are solved with digest authentication and the data sent is MD5 hashed. This hashed message is not easy to decipher. However, some browsers don't support it.</li>
<li><strong>Integrated authentication</strong>: Kerberos authentication or <strong>NT LAN Manager</strong> (<strong>NTLM</strong>) authentication. This is the best of the lot, in terms or security as well as support.</li>
</ul>
<p>Windows authentication is still supported in ASP.NET Core 2.0, but since it is based on Windows, it won't be available on Linux or Macintosh. The app has to be hosted with IIS or HTTP.SYS (a web server for ASP.NET Core, which runs <em>only</em> on Windows). This is suited for intranet networks where the servers, clients, and users all belong to the same Windows domain.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Forms authentication</h1>
                </header>
            
            <article>
                
<p>This is cookie/URL-based authentication in which a username and password are stored on the client machine as cookies and are sent encrypted in the URL for every request if the user has turned off cookie support. We can implement this in ASP.NET Core 2.0 as cookie authentication, as illustrated in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="316" width="360" src="assets/d7291395-2811-4010-9d09-2f94150ef3db.png"/></div>
<p><span>As we can see, once we have the auth-key set with the initial call to authenticate, we just pass the session ID/token from the cookie in every request. It can be used with ASP.NET Core Identity or without it.</span> ASP.NET Core Identity is a membership system that allows us to add login functionality to our web app. Users can create an account and log in with username and password or they can use external social login providers, such as Facebook, Twitter, Google, Microsoft, and so on. We can use SQL Server or other persistence storage mechanisms to store the user details. Since this needs a very detailed understanding, you are advised to read about ASP.NET Identity from Microsoft's official documentation at&#160;<a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?tabs=visual-studio%2Caspnetcore2x">https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?tabs=visual-studio%2Caspnetcore2x</a>.</p>
<p>If you have worked with ASP.NET prior to ASP.NET Core, you will find out that the fundamental type <kbd>IPrincipal</kbd> is more or less the same. It used to be implemented as <kbd>user</kbd> on <kbd>HTTPContext</kbd>, which represented the user for a request. Now, we also have a property named <kbd>user</kbd>, but its type is <kbd>ClaimsPrincipal</kbd>, which in turn implements <kbd>IPrincipal</kbd>. This is the shift that ASP.NET Core 2.0 has taken from the previous version of ASP.NET: that is, it has moved to claims-based from a role-based model and claims is the superset of a role. So, the question arises, what is a claim?</p>
<p>Claims are sets of information stored in key value pair form and are used to store user information such as name, address, email address, phone number, and so on. We can use claims as the replacement for roles as we can transfer the role to a claim. For example, I say "I am Rishabh Verma. I live in India. I am the author of this book", where I am claiming that my name is Rishabh Verma, I am claiming that I live in India, and I am claiming that I have the role of author of this book. This is what I mean when I say claims are the superset of roles, as in the preceding statement I have transformed my role of author into a claim.</p>
<p>The following code should nicely explain claims, identity, and principal relations from the preceding statement:</p>
<pre><span>IList&amp;lt;Claim&amp;gt; claimCollection = new List&amp;lt;Claim&amp;gt;<br/>{<br/>     new Claim(ClaimTypes.Name, "Rishabh Verma")<br/>     ,new Claim(ClaimTypes.Country, "India")<br/></span><span>     ,new Claim(ClaimTypes.Role, "Author")<br/></span>}<br/><br/><span>ClaimsIdentity identity = new ClaimsIdentity(claimCollection);</span><br/><span>ClaimsPrincipal principal = new ClaimsPrincipal(identity);</span></pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Token-based authentication</h1>
                </header>
            
            <article>
                
<p>The fundamental concept behind a token-based authentication system is simple. It allows users to enter their username and password in order to obtain a token, and then use this token in every request to fetch a specific resource—without using their username and password again. Once the token has been obtained, the user can offer the token to access the resource for a time period, while the token is valid. This is depicted in the following diagram:&#160;</p>
<div class="CDPAlignCenter CDPAlign"><img height="331" width="409" src="assets/fafb9d4f-52ca-48a2-b372-25f4994a90f7.png"/></div>
<p><span>It is stateless and scalable. T</span>he server need not store the token in a session or memory (stateless) and hence it is scalable. It is mobile application-ready, secure, and can be used to pass authentication to other systems. Due to the rise of <strong>Single-Page Applications</strong> (<strong>SPAs</strong>), <strong>Internet of Things</strong> (<strong>IoT</strong>), and web APIs, token-based authentication has gained importance. Although there are different ways to implement the tokens, the&#160;<span><strong>JSON Web Token</strong>&#160;(</span><strong>JWT</strong>) is more widely used. The JWT is an open standard and has become the de-facto standard token, which defines a compact and self-contained method for securely transmitting information between parties, encoded as a JSON object. The JWT has gained massive popularity due to its compactness, which allows tokens to be easily transmitted through query strings, header attributes, and within the body of requests.</p>
<p>The JWT consists of three parts:</p>
<ul>
<li><strong>Header</strong>: Containing the type of the token and the hashing algorithm.</li>
<li><strong>Payload</strong>: Containing the claims of identity.</li>
<li><strong>Signature</strong>:&#160;Contains the string created using a secret and the combined header and payload. It is used to identify the integrity of the token.</li>
</ul>
<p>It is in the format <kbd>xxxxx.yyyyy.zzzzz</kbd> and a sample token may look like this:</p>
<pre>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoicmlzaGFiaCIsInN1cm5hbWUiOiJ2ZXJtYSIsInNpdGUiOiJodHRwOi8vd3d3LnJpc2hhYmh2ZXJtYS5uZXQiLCJjb2F1dGhvciI6Ik5laGEifQ.Nxhxs024YUyPMVHlsQQWvZ3QN8oXAwL0OAzR6FN62_E</pre>
<div class="packt_tip">You can create the JWT from your data at&#160;&#160;<a href="https://jwt.io/">https://jwt.io/</a>, and can also paste the JWT and check its data.</div>
<p>Let us wrap up our discussion on authentication with a quick discussion of OAuth and OpenID Connect.</p>
<ul>
<li><strong>OAuth 2.0:</strong> It is an open standard for authorization. It is commonly used to provide a way for users to log in to a website (say, our Let's Chat app at&#160;<a href="http://packtletschat.azurewebsites.net">http://packtletschat.azurewebsites.net</a>) using a third-party account such as Facebook without having to provide the password of their Facebook account to the Let's Chat app. While we will use it for authentication, it is actually an authorization protocol.</li>
<li><strong>OpenID Connect (OIDC)</strong>:&#160;It&#160;is a HTTP-based protocol that uses identity providers to validate that the user is actually who they says they are. It is a very simple protocol and provides protection for passwords. It is a simple layer that works on top of OAuth 2.0 and adds additional security on top of the OAuth&#160; protocol. Due to its simplicity, it has found widespread adoption. Google, Facebook, and Stack Exchange are a few of the best-known identity providers. It's important to note that OIDC is a very different protocol to OpenID. The latter is an XML-based protocol that follows similar approaches and goals to OIDC, but in a less developer-friendly way.</li>
</ul>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Authorization</h1>
                </header>
            
            <article>
                
<p>As discussed earlier, authorization is orthogonal and independent from authentication. Let's have a quick glance at the different types of authorization:</p>
<ul>
<li>Simple authorization</li>
<li>Role-based authorization</li>
<li>Claim-based authorization</li>
</ul>
<p>Let's discuss them in the next sections.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Simple authorization</h1>
                </header>
            
            <article>
                
<p>If you have worked with ASP.NET MVC before, you may already be familiar with authorization. The <kbd>[Authorize]</kbd> and <kbd>[AllowAnonymous]</kbd> attributes are the inbuilt authorization components in the framework. At the simplest level, applying the <kbd>[Authorize]</kbd> attribute over a <kbd>Controller</kbd> or action restricts the access to the <kbd>Controller</kbd> or action to authenticated users only. If you apply the <kbd>[Authorize]</kbd> attribute to a <kbd>Controller</kbd>, it applies to all the actions:</p>
<pre>[Authorize]<br/>public class AccountController : Controller<br/>{<br/>    public ActionResult Login()<br/>    {<br/>    }<br/><br/>    public ActionResult Logout()<br/>    {<br/>    }<br/>}</pre>
<p>In the preceding code, only authenticated users have access to the <kbd>Login</kbd> action as well. This doesn't make sense as I want to log in when I am not logged in, and not when I am already logged in. So if you want it to be applied to only a few actions, then apply the attribute to those actions alone. The other way to prevent this situation is to use the&#160;<kbd>[AllowAnnonymous]</kbd> attribute on the <kbd>Login</kbd> action, and that makes it accessible to non-authenticated users as well.</p>
<div class="packt_tip">Treat <kbd>[AllowAnonymous]</kbd> like a <kbd>0</kbd>,&#160; and <kbd>[Authorize]</kbd> as <kbd>1</kbd>. So if you apply <kbd>[Authorize]</kbd> on the <kbd>Controller</kbd> and <kbd>[AllowAnonymous]</kbd> on an action, that action will be accessible anonymously (<kbd>1 x 0 = 0</kbd>), while other actions will require authentication. On the contrary, if you apply <kbd>[AllowAnonymous]</kbd> on the controller and <kbd>[Authorize]</kbd> on an action, all the actions will be accessible anonymously. The reason for this is that anything multiplied by <kbd>0</kbd> is <kbd>0</kbd>, so if you apply <kbd>[AllowAnonymous]</kbd> on the <kbd>Controller</kbd>, all other action level attributes are bypassed.</div>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Role-based authorization</h1>
                </header>
            
            <article>
                
<p>When a <kbd>ClaimsPrincipal</kbd> object is created, like we did previously, there is a property called <kbd>IsInRole</kbd>. This property provides us access to the <kbd>Roles</kbd> of the user. Role-based authorization checks are declarative. They can be used in the same way, using the&#160;<kbd>[Authorize]</kbd> attribute that we have seen, by passing in the <kbd>Roles</kbd> parameter:</p>
<pre>[Authorize(Roles = "Administrator,ITAdminsitrator")]<br/>public class UserAdministrationController : Controller<br/>{ <br/>    ….<br/>}</pre>
<p>In the preceding example, all the actions of <kbd>UserAdministrationController</kbd> are accessible to authenticated users with either the&#160;<kbd>Adminsitrator</kbd> or <kbd>ITAdministrator</kbd> roles. So, we can provide multiple roles as comma-separated values in the <kbd>Roles</kbd> parameter and they will be treated as an <em>or</em> condition. You can further restrict access to only one of the roles by providing the attribute at the action level.</p>
<p>&#160;What if I need to have an <em>and</em> condition between roles? The following snippet will ensure that actions are accessible only if the authenticated user has both <kbd>ITAdministrator</kbd> and <kbd>Administrator</kbd> roles:</p>
<pre>[Authorize(Roles = "ITAdminsitrator")]<br/>[Authorize(Roles = "Administrator")]<br/>public class UserAdministrationController : Controller<br/>{ <br/>    ….<br/>}</pre>
<p>If we look at the overloads of the&#160;<kbd>[Authorize]</kbd> attribute, there is an overload that accepts the following policy:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5b645a68-54b9-4014-bd8c-b3a0650ee07d.jpg"/></div>
<p>Policy-based role checks are also supported and can be done at the <kbd>Startup</kbd> in the&#160;<kbd>ConfigureServices()</kbd> method while configuring authorization:</p>
<pre>public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddMvc();<br/>    services.AddAuthorization(options =&amp;gt;<br/>    {<br/>        options.AddPolicy("RequireAdminRole", policy =&amp;gt; <br/>        policy.RequireRole("Administrator"));<br/>    });<br/>} <br/><br/>[Authorize(Policy="RequireAdminRole")]<br/>public IActionResult HighPreviligeAction()<br/>{<br/>    return View();<br/>}</pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Claims-based authorization</h1>
                </header>
            
            <article>
                
<p>When you want to authorize based on user claims, then we can use claims-based authorization. A real-world example would be when you are driving a vehicle and the traffic police stop you, suspecting you are younger than 18 years. Then, you take out your driving license and claim that you are a perfectly legal age to drive . The police accept your claim (since it is issued by a valid authority) and let you drive on. This is claims-based authorization. Claims-based authorization checks are also declarative and can be decorated on a controller or action. Claims requirements are policy-based, so like in the previous section, we need to register the policy at startup, expressing the claims requirement. In the preceding example, the code would look like this:</p>
<pre>services.AddAuthorization(options =&amp;gt;<br/>    {<br/>        options.AddPolicy("RequireClaim", policy =&amp;gt; <br/>        policy.RequireClaim("&amp;lt;&amp;lt;Claim Needed&amp;gt;&amp;gt;"));<br/>    });</pre>
<p>This discussion should have given you a pretty clear view of authentication and authorization, and you should now be able to dive deep into these topics and broaden and deepen your knowledge on these fundamental concepts.</p>
<p class="mce-root CDPAlignLeft CDPAlign">We also notice that all authentication and authorization is implemented in the <kbd>ConfigureServices()</kbd> method of the&#160;<kbd>Startup</kbd> class where the pipeline is&#160; configured and middleware is added. To complete the discussion, let's quickly understand the ASP.NET Core pipeline, and how it serves the requests. The following diagram illustrates how the request is served by ASP.NET Core in a step-by-step fashion:</p>
<div class="CDPAlignCenter CDPAlign"><img height="228" width="454" src="assets/73d351ed-4c3e-45bd-a18a-f41454504115.png"/></div>
<p>Here is the flow:</p>
<ol>
<li>The browser sends the HTTP request to the server. The request is received by the reverse proxy.</li>
<li>The request is forwarded by the reverse proxy to ASP.NET Core.</li>
<li>The ASP.NET Core web server receives the request and routes it through its pipeline, through middleware. After passing through middleware, the request is processed by the ASP.NET Core application, which generates the response and passes it back.</li>
<li>The ASP.NET Core web server sends the response to the reverse proxy.</li>
<li>The HTTP response is sent to the browser.</li>
</ol>
<div class="packt_infobox"><span>A reverse proxy is a type of proxy server that retrieves resources on behalf of a client from one or more servers. It can be defined as a software component that is responsible for receiving requests and forwarding them on to the appropriate web server. The reverse proxy is exposed directly to the internet, whereas the underlying web server is exposed only to the proxy. This setup has several benefits, primarily security and performance for web servers.</span></div>
<p>Let's look at the details of <em>Step 3</em>, as it talks about the ASP.NET Core web server and its pipeline, which is our area of interest. First things first. What is middleware?</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Middleware</h1>
                </header>
            
            <article>
                
<p>As per the ASP.NET Core documentation (available at&#160;<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?tabs=aspnetcore2x">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?tabs=aspnetcore2x</a>), middleware is a software that is assembled into an application pipeline to handle requests and responses. Each component:</p>
<ul>
<li>Chooses whether to pass the request to the next component in the pipeline</li>
<li>Can perform work before and after the next component in the pipeline is invoked</li>
</ul>
<p class="lf-text-block lf-block x-hidden-focus">Request delegates are used to build the request pipeline. The request delegates handle each HTTP request.&#160;Request delegates are configured using the<span>&#160;<kbd>Run</kbd>, <kbd>Map</kbd>, and <kbd>Use</kbd></span><span>&#160;</span>extension methods. An individual request delegate can be specified inline as an anonymous method (called <strong>inline middleware</strong>), or it can be defined in a reusable class. These reusable classes and inline anonymous methods are<span>&#160;</span><em>middleware</em>. Each middleware component in the request pipeline is responsible for invoking the next component in the pipeline, or short-circuiting the chain as required.</p>
<p>The classical diagram of middleware in the pipeline, which is available at Microsoft's official ASP.NET Core documentation site, is shown here, with the added detail of steps, which makes it extremely lucid. What happens in <em>Step 3</em>&#160;is shown in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="244" width="382" src="assets/d65abcc3-891e-47c6-a41d-10dd40a89e51.png"/></div>
<p class="mce-root">Lets look at it in a step-by-step approach:</p>
<ol>
<li><strong>Step 1</strong>: The request is received by <strong>Middleware 1</strong>. The pseudo code of <strong>Middleware 1</strong> in the&#160;<kbd>Configure(IApplicationBuilder app, IHostingEnvironment env)</kbd>&#160;method of <kbd>Startup.cs</kbd> would be <kbd>UseMiddleware1();</kbd>, as it processes the request and invokes the next middleware.&#160;<span>Recall that we discussed the <kbd>Use</kbd>, <kbd>Map</kbd>, and <kbd>Run</kbd> methods in brief in</span> <span><a href="ch03.html">Chapter 3</a>,&#160;</span><span><em>Building Our First .NET Core Game Tic-Tac-Toe</em></span><span>.</span></li>
<li><strong>Step 2</strong>: The code/logic of <strong>Middleware 1</strong> is executed.</li>
<li><strong>Step 3</strong>:&#160;<kbd>RequestDelegate</kbd>—<kbd>next();</kbd> is executed, which invokes the next middleware.</li>
<li><strong>Step 4</strong>: The code/logic of <strong>Middleware 2</strong> is executed.&#160;<span>The pseudo code of <strong>Middleware 2</strong> in the&#160;<kbd>Configure(IApplicationBuilder app, IHostingEnvironment env)</kbd></span><span>&#160;method of&#160;</span><kbd>Startup.cs</kbd><span>&#160;would be&#160;</span><kbd>UseMiddleware2();</kbd>.</li>
<li><strong>Step 5</strong>:&#160;<kbd>RequestDelegate</kbd>—<kbd>next();&#160;</kbd> is executed, which invokes the next middleware.</li>
<li><strong>Step 6</strong>: The code/logic of <strong>Middleware 3</strong> is executed. Based on this diagram, the request is handled here, but we can chain in as much middleware as we need.&#160;<span>The pseudo code of <strong>Middleware 3</strong> in the&#160;<kbd>Configure(IApplicationBuilder app, IHostingEnvironment env)</kbd></span><span>&#160;method of&#160;</span><kbd>Startup.cs</kbd><span>&#160;can be either&#160;</span><kbd>UseMiddleware3();</kbd>, which doesn't call&#160;<kbd>next();</kbd>, or it can simply be <kbd>RunMiddleware3();</kbd>, which short-circuits the pipeline. Normally, this would be the MVC <kbd>Routing</kbd> middleware, which would route the request to the MVC <kbd>Controller</kbd>, which processes the request and returns the response.</li>
<li><strong>Step 7</strong>: As the request is handled in the last step, the response is returned to <strong>Middleware 2</strong>, which can do further processing of the response and return it.</li>
<li><strong>Steps 8 and 9</strong>: Likewise, the response is processed in <strong>Middleware 2</strong> and <strong>Middleware 1</strong>.</li>
<li><strong>Step 10</strong>: The processed response from all middleware is returned.</li>
</ol>
<p>If we look at the&#160;<kbd>Configure(IApplicationBuilder app, IHostingEnvironment env)</kbd> method in our&#160;<kbd>Startup.cs</kbd> class, we see the following code, which comes with the default MVC template:</p>
<pre>public void Configure(IApplicationBuilder app, IHostingEnvironment env)<br/>{<br/>    if (env.IsDevelopment())<br/>    {            <br/>        app.<strong>Use</strong>DeveloperExceptionPage(); <br/>        app.<strong>Use</strong>BrowserLink();<br/>    }<br/>    else<br/>    {<br/>        app.<strong>Use</strong>ExceptionHandler("/Home/Error");<br/>    }<br/><br/>    app.<strong>Use</strong>StaticFiles();<br/>    app.<strong>Use</strong>Mvc(routes =&amp;gt;<br/>    {<br/>        routes.MapRoute(name: "default",template: " <br/>        {controller=Home}/{action=Index}/{id?}");<br/>    });<br/>}</pre>
<p class="mce-root CDPAlignLeft CDPAlign">They say that a picture is worth a thousand words, so to understand this code in the context of the pipeline, if we draw the diagram for a non-developer environment (that is,&#160;<kbd>env.IsDevelopment() == false;</kbd>), here is roughly what it would look like:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="304" width="502" src="assets/4fec7bc6-63d4-44e4-b1b2-7ce058dee3bb.png"/></div>
<p>We can see that, based on the code for the <kbd>else</kbd> case, the request first goes through the exception middleware through&#160;<kbd>app.UseExceptionHandler("/Home/Error");</kbd>.<strong>&#160;</strong>This is done to ensure that if any part of the code encounters the exception in the pipeline, it is handled by the exception handler, so it's kept first. From the diagram, we can note that during the request processing, the middleware does nothing, but just invokes the next middleware in the chain. This can be seen from the ASP.NET Core source code, which is freely available for everyone to see and learn from GitHub (<a href="https://github.com/aspnet">https://github.com/aspnet</a>). I would highly encourage readers to browse the code and see the implementation for a better understanding of the way things have been implemented by the ASP.NET Core team.</p>
<p>Next in line is the static file middleware, which serves static files such as <kbd>css</kbd>, <kbd>js</kbd>, <kbd>images</kbd>, and so on placed in the&#160;<kbd>wwwroot</kbd> folder. These should be served fast as it makes sense to keep this middleware early in the pipeline. If a request for a static file comes, the static file middleware serves the request and <em>short-circuits</em> the pipeline, so that other unnecessary code is not executed while serving the static file contents. This is configured through&#160;<kbd>app.UseStaticFiles();</kbd>. Then comes the MVC routing, which routes the incoming request to its desired controller action. We see that there are a number of items that are executed in this middleware. We will go into detail concerning each of these items in later sections and chapters, but the important stuff to note here is that the request is served from the controller action and then routed back through the same pipeline. The static file middleware has no role while a non-static file request is being served, and that becomes evident from the diagram. If there is an exception, it would be handled by the exception handler and the response is served back.</p>
<div class="packt_infobox">The first <kbd>app.Run</kbd> delegate terminates the pipeline. That is, after this, even if you add any further middleware or code, it will not be executed. Multiple request delegates or middleware can be chained using <kbd>app.Use</kbd>. The <kbd>next</kbd> parameter represents the next delegate in the pipeline. We can short-circuit the pipeline by not invoking the <kbd>next</kbd> action. Never call <kbd>next.Invoke</kbd> after the response has been sent to the client. Changes to <kbd>HttpResponse</kbd> after the response has started will throw an exception. The order in which middleware components are added in the <kbd>Configure</kbd> method defines the order in which they are invoked on the requests, and the reverse order for the response.&#160;</div>
<p><span>Hopefully, by now we have a relatively good understanding of the ASP.NET Core pipeline and middleware. Before we write middleware of our own and learn how to plug it into our pipeline, let's first learn about Dependency Injection, as it will be used extensively in whatever ASP.NET Core application that we write.</span></p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dependency Injection</h1>
                </header>
            
            <article>
                
<p><strong>Dependency Injection</strong>&#160;(<strong>DI</strong>) is a software design pattern that enables us to develop loosely coupled code and is a great way to reduce tight coupling between software components. The <strong>D</strong> of the <strong>SOLID</strong>&#160;design principles stands for <strong>Dependency Inversion Principle</strong>&#160;(<strong>DIP</strong>), which states that "<em>high-level modules should not depend upon low-level modules. Both should depend on abstractions</em>". That is, it depends on abstractions, not on concrete implementations. If we speak in the language of the code, the class should not use new or static helper methods to populate its dependencies; it should rather have them injected. If you ever heard your architect or lead utter "<em>program to interfaces, not implementations</em>", it's because he/she wants you to use DI.&#160;DI is the implementation of DIP<strong>.&#160;</strong></p>
<p><span>DI enables better:</span></p>
<ul>
<li>Testability</li>
<li>Maintainability</li>
<li>Reusability&#160;</li>
</ul>
<p>I am not great at dishing out examples, but let me give it a try with a real-world scenario. Suppose there is a boy who wants to get married. To get married, he needs a girl, so he is dependent on a girl for marriage. The pseudo code for this scenario would be roughly as follows:&#160;</p>
<pre>public class Boy : IBoy<br/>{<br/>    //// Get married. First get the girl friend and then marry her.<br/>    public void GetMarried()<br/>    {<br/>        IGirl girl = this.GetGirl(); //// Returns null, if boy doesn't <br/>        have a girl-friend.<br/>        //// Marry with girl.<br/>    }<br/>}</pre>
<p>We notice that the <kbd>Boy</kbd> class has hard coupling with the <kbd>girl</kbd> class, as it gets a specific instance of the <kbd>girl</kbd> class in the <kbd>marriage</kbd> method and marries her. This hard coupling represents that the boy already has a girlfriend and so boy and girl are tightly linked. Well, most boys are not lucky (or unlucky, depending upon how you see it), enough to have a girlfriend. Also, the preceding code might not work for all scenarios, such as if the boy doesn't have a girlfriend or if the parents find a girl for the boy.</p>
<p>A better way of implementing the preceding code would be to remove the hard-coupling of the girl by injecting the <kbd>girl</kbd> object from outside. With this, the <kbd>GetMarried</kbd> method is generic as it, removes the hard-coupling of the <kbd>girl</kbd> class, and will work for all boys, depending on the <kbd>girl</kbd> object passed:</p>
<pre>public class Boy : IBoy<br/>{<br/>    //// Get married. The girl object passed can be boy's girlfriend or <br/>         any girl selected by his parents<br/>    public void GetMarried(IGirl girl)<br/>    {<br/>        //// Marry with girl.<br/>    }<br/>}</pre>
<p>This is the simplest example of DI, in which rather than creating a new instance of a dependent object, we inject the dependency from outside. There are various ways in which dependency can be injected. We will discuss only a few here, with reference to classes and interfaces, as follows.</p>
<p>Let us suppose we have two classes:</p>
<ul>
<li><kbd>CoreClass</kbd> is the main class implementing the&#160;<kbd>ICore</kbd> interface</li>
<li><kbd>DependencyClass</kbd> is the class implementing the&#160;<kbd>IDependency</kbd>&#160;interface, so that <kbd>CoreClass</kbd> is dependent on <kbd>DependencyClass:</kbd></li>
</ul>
<pre style="padding-left: 60px">public class CoreClass : ICore<br/>{<br/>    public CoreClass()<br/>    {<br/>    }<br/><br/>    //// Class Methods. Hidden for brevity<br/>}<br/><br/><span>public class DependencyClass : IDependency<br/></span>{<br/>    public DependencyClass()<br/>    {<br/>    }<br/><br/>    //// Class methods. Hidden for brevity<br/>}</pre>
<p>Taking the preceding classes and interfaces as a reference, we can inject the dependency in the following ways:</p>
<ul>
<li><strong>Constructor injection</strong>: In constructor injection, the dependency object is injected at the time of constructing the object, that is, in the constructor of the class. This way, the dependency is clearly spelled out at the time of the object's creation. The disadvantages are that once the object is created, the dependency cannot be changed and since the dependency is injected in the constructor, the class doesn't have a default parameterless constructor. The constructor-injected code for the preceding class would look like this:</li>
</ul>
<pre style="padding-left: 60px">public class CoreClass : ICore<br/>{<br/>    private readonly IDependency dependency;<br/>    <br/>    public CoreClass(IDependency dependency)<br/>    {<br/>        this.dependency = dependency;<br/>    }<br/><br/>    //// Class Methods. Hidden for brevity<br/>}</pre>
<ul>
<li><strong>Property setter injection</strong>: In property injection, the dependency object is injected as a property setter. This way, the default construction of the class continues to exist and the dependency can be changed, even after object's creation, by just setting the property. The disadvantage is that since the dependency is not injected at the time of the object creation, the dependency to be set can be missed and hence may result in runtime errors. The property injected code would look like this:</li>
</ul>
<pre style="padding-left: 60px" class="mce-root">public class CoreClass : ICore<br/>{<br/>    public CoreClass()<br/>    {<br/>    }<br/><br/>    public IDependency Dependency {get;set;}<br/>    //// Class Methods. Hidden for brevity<br/>}</pre>
<p style="padding-left: 60px">In the preceding&#160;<kbd>CoreClass</kbd> class, there is a property named&#160;<kbd>Dependency</kbd>&#160;of type <kbd>IDependency</kbd> that is needed for the class to function correctly. However, if the developer just initializes <kbd>CoreClass</kbd> by creating a new instance of it and forgets to set the <kbd>Dependency</kbd> property, we may encounter a runtime exception. In contrast, in constructor injection, since the dependency is passed at the time of the object's creation, we are never at risk of such issues.</p>
<p>We have seen how dependencies can be injected. Imagine a system where we have numerous classes in which dependency needs to be injected. If we follow any one the preceding approaches for injection and create the objects at every place where they are needed, it will become spaghetti code or become completely messed up. It is therefore meaningful to have classes to create these classes and inject dependencies as needed. These classes are called containers, DI containers,&#160;<strong>Inversion of Control</strong> (<strong>IoC</strong>) containers. A container can be thought of as a factory that is responsible for providing instances of types that are requested from it. If a given type has declared that it has dependencies, and the container has been configured to provide the dependency types, it will create the dependencies as part of creating the requested instance. In this way, complex dependency graphs can be provided to classes without the need for any hardcoded object construction. In addition to creating objects with their dependencies, containers typically manage object lifetimes within the application.</p>
<p>ASP.NET Core comes with a very simple built-in container (the <kbd>IServiceProvider</kbd> interface) that supports constructor injection by default. ASP.NET's container refers to the types it manages as services. These services can be injected into the container in the <kbd>ConfigureServices</kbd> method of the ASP.NET Core application's <kbd>Startup</kbd> class.</p>
<p>There are certain facts about the inbuilt ASP.NET Core container that we need to be aware of to make correct use of DI in the app.</p>
<p>The constructor for the dependency that should be resolved must have a <kbd>public</kbd> access modifier.</p>
<p>There should be only one constructor that gets resolved with a given set of parameters. Constructor overloads are supported, but only one overload can exist, whose arguments can all be fulfilled by DI. If multiple constructors exist, you may encounter <kbd>InvalidOperationException</kbd>.</p>
<p>Notice the signature of the&#160;<kbd>ConfigureServices</kbd> method in the <kbd>Startup</kbd> class:</p>
<pre><span class="hljs-comment">// This method gets called by the runtime. Use this method to add services to the container.</span><span> <br/></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureServices</span>(<span class="hljs-params">IServiceCollection services</span>)<br/>{<br/>    //// Code excluded for brevity.<br/>}</span></pre>
<p>This method exposes the <kbd>IServicesCollection</kbd>, where we can add our own services/types as needed. This can be done by the following extension methods in the&#160;<kbd>Microsoft.Extensions.DependencyInjection</kbd> namespace:</p>
<ul>
<li><kbd>AddTransient</kbd>: Use this extension method to instantiate types that should be created each time they are requested. This should be used for lightweight, stateless services.</li>
<li><kbd>AddScoped</kbd>:&#160;<span>Use this extension method to instantiate types that should be created once per request. Types that are based on requests should be instantiated on a per-request basis and hence should be created by this method.</span></li>
<li><kbd>AddSingleton</kbd>:&#160;<span>Use this extension method</span> <span>to create types that should be instantiated&#160;only once and should be used throughout the life cycle&#160;of the application. A common example of this scenario is caching. One instance is good enough for the application.&#160;</span></li>
</ul>
<p>My architect calls these <em>every time, sometimes, and one time</em>, respectively. Transients are created every time they are requested; scoped are created once per request, so sometimes. Singletons are created once in the lifetime of the application, so one time. Nice way to remember!</p>
<div class="packt_tip">On a lighter note and to digest the concept: the <strong>Prime Minister</strong> (<strong>PM</strong>) of a nation can be a good example of a singleton. Irrespective of where and how many times he/she is needed, there is one and only one PM, so the PM is a singleton. Likewise, examples of transient and scoped can be formed. This is left as an exercise and teaser to readers to come up with real-world examples of transient and scoped.</div>
<p>Each of these extension methods have seven or more overloads to provide flexibility and cater to different needs, such as passing the concrete instance or providing a factory method to create the object. Readers should have a good look at the overloads and make effective use of these methods. The easiest way to do so is either to use <em>F12</em> on one of these extension methods in Visual Studio and read the method documentation, or use the object browser of Visual Studio, or browse the source code on GitHub (<a href="https://github.com/PacktPublishing/.NET-Core-2.0-By-Example">https://github.com/PacktPublishing/.NET-Core-2.0-By-Example</a>).</p>
<p>I will list a few of the ways by which we can inject the types/services:</p>
<pre>services.AddSingleton&amp;lt;IHttpContextAccessor, HttpContextAccessor&amp;gt;();    <br/>//// Will inject HttpContextAccessor where IHttpContextAccessor is used  <br/>     but only one instance.<br/>services.AddSingleton&amp;lt;HttpContextAccessor&amp;gt;(); <br/><br/>//// Directly inject HttpContextAccessor as a singleton<br/>services.AddSingleton&amp;lt;Connection&amp;gt;((serviceProvider) =&amp;gt; this.CreateConnection(serviceProvider)); <br/><br/>//// Singleton using factory method overload using service provider.   <br/>     Same overloads apply to transient and scoped as well.<br/>services.AddTransient&amp;lt;IUserRepository, UserRepository&amp;gt;(); <br/><br/>//// A new instance of UserRepository would be created and passed, <br/>     whenever it is requested.<br/>services.AddScoped&amp;lt;IScopedService, ScopedService&amp;gt;(); <br/>//// Would be created and passed, once per request.</pre>
<p>This concludes our discussion on DI. For a more detailed and extensive dive into DI in ASP.NET Core 2.0, please visit&#160;<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection</a>.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How do you write custom middleware?</h1>
                </header>
            
            <article>
                
<p>Now is the right time to create simple middleware of our own and plug it into the pipeline, so that all this theory that we have gone through ends with a practical example.</p>
<p>We can write either inline middleware or a neatly written class which can be configured at the startup. We will write both:</p>
<pre> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Configure</span>(<span class="hljs-params">IApplicationBuilder app</span>) <br/></span><span> { <br/>    app.Run(</span><span class="hljs-keyword">async</span><span> context =&amp;gt; <br/>    { <br/>        </span><span class="hljs-keyword">await</span><span> context.Response.WriteAsync(</span><span class="hljs-string">".NET Core 2.0 By Example"</span><span>); <br/>    });<br/> }</span></pre>
<p>This is the simplest middleware that one can write. This is the <kbd>Run</kbd> middleware and short-circuits the pipeline&#160; after execution, and just sends a response with the message <kbd>".NET Core 2.0 By Example"</kbd>. It has been plugged with this code into the <kbd>Configure</kbd> method of&#160;<kbd>Startup.cs/</kbd>.</p>
<p>Having seen inline middleware, let's write the more serious middleware that you would write in your app.</p>
<p>Let's begin by creating a class called <kbd>MyFirstMiddleware</kbd>.</p>
<p>Since middleware is just a request delegate that processes the request/response and then invokes the next one in the chain, the following is how we would create the class for middleware. Notice the next request delegate is expected to be resolved by DI. It's a pretty simple class, consisting of:</p>
<ul>
<li>A <kbd>readonly</kbd> field to hold the reference to the next <kbd>RequestDelegate</kbd>.</li>
<li>A constructor that expects the next <kbd>RequestDelegate</kbd> to be executed as the parameter. During construction, it sets the field with the reference of the next request delegate.</li>
<li>An <kbd>Invoke</kbd> method that takes an <kbd>HttpContext</kbd> object to fiddle with and then passes it along to the next middleware.</li>
</ul>
<p>Let's have a look at the code:</p>
<pre><span>public class MyFirstMiddleware<br/>{ <br/>    //// To hold the next middleware in the pipeline.<br/>    private readonly RequestDelegate next;<br/><br/>    public MyFirstMiddleware(RequestDelegate next) <br/>    { <br/>        this.next = next; <br/>    }<br/>    <br/>    public async Task Invoke(HttpContext httpContext) <br/>    { <br/>        // Execute the logic, that doesn't write to response.<br/><br/>        // Call the next delegate in the pipeline<br/>        await this.next(httpContext); <br/>    }<br/>}</span></pre>
<p>With this, we have our simple middleware code ready. However, we are yet to plug it into our app pipeline. To do so, we will create an extension method of <kbd>IApplicationBuilder</kbd>, which internally uses the&#160;<kbd>UseMiddleware&amp;lt;T&amp;gt;</kbd> method to register the middleware, as shown here:</p>
<pre><span class="hljs-keyword">public</span><span> </span><span class="hljs-keyword">static</span><span> </span><span class="hljs-keyword">class</span><span> </span><span class="hljs-title">MyFirstMiddlewareExtensions</span><span> <br/>{ <br/>    </span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IApplicationBuilder <span class="hljs-title">UseMyFirstMiddleware</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <br/>    IApplicationBuilder builder</span>) <br/>    </span><span>{ <br/>        </span><span class="hljs-keyword">return</span><span> builder.UseMiddleware&amp;lt;<span class="hljs-title">MyFirstMiddlewareExtensions</span>&amp;gt;(); <br/>    }<br/>}</span></pre>
<p>Finally, to plug it into our pipeline, go to the <kbd>Configure</kbd> method of the&#160;<kbd>Startup</kbd> class and add the middleware with a simple single line of code,&#160;<kbd>app.UseMyFirstMiddleware();</kbd>.</p>
<p>With this, we have created our very first middleware and plugged it into our app pipeline. Sweet, short, and simple!</p>
<p>Next, we will look at the configuration providers in ASP.NET Core and how we can read configuration and use it in our app.</p>
<div class="packt_infobox"><span>Extension methods in C# allow us to extend an existing type with new functionality, and add new methods to it, without having to derive or recompile the old type.&#160;</span>Extension methods are a special kind of static method, but they are called as if they are instance methods on the extended type.&#160; The most common extension methods are the <kbd>LINQ</kbd> standard query operators. ASP.NET Core makes extensive use of extension methods for registering services.</div>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuration</h1>
                </header>
            
            <article>
                
<p>When we develop ASP.NET Core web apps, we will quickly realize that we need to change a few settings at runtime. To give an example, consider a web application that makes API calls to the service. When you develop the web app, the service is deployed in some development server and when you deploy it in production, the service URL is different, so the URL should not be hardcoded in the application. Instead, it should be read from the configuration, so that it can be changed without having to recompile the code. Another often used example is that of database connection strings, if the app makes use of them. This section takes a look at how we can accomplish this in ASP.NET Core.</p>
<p>The ASP.NET Core configuration model has three main constructs of interest:</p>
<ul>
<li><kbd>ConfigurationProvider</kbd></li>
<li><kbd>ConfigurationRoot</kbd></li>
<li><kbd>ConfigurationBuilder</kbd></li>
</ul>
<p>As shown in the following screenshot, the map diagram is constructed from <kbd>Microsoft.Extensions.Configuration</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5f65ea3a-6b35-406a-8610-583dfe10861d.png"/></div>
<p><kbd>ConfigurationProvider</kbd> is abstracted from the developer and hence we would not see it, but it's good to know that there is support for multiple configuration providers. A few of the important ones are:</p>
<ul>
<li><strong>JSON file</strong>: Reads the JSON file in the app's&#160;<kbd>Startup</kbd>&#160;folder and configures the application</li>
<li><strong>Command-line arguments</strong>: While launching the app, command-line arguments can be passed as a key value to configure the application</li>
<li><strong>Environment variables</strong>: Setting the environment variables, the provider reads the environment variable and takes care of configuration</li>
<li><strong>Azure Key Vault</strong>: We will cover this in later chapters when we discuss Azure, but as the name suggests, it is a key vault.</li>
</ul>
<p>So in a single app, we can choose to read a few configurations from the JSON file, a few from the command line, and so on. When we add multiple providers, it's important to consider the order in which we add them, as that defines the order in which the configuration values are added to the underlying dictionary. Configuration values from later providers will overwrite values with the same key from earlier providers.&#160;Also, we can notice in the diagram that there is a <kbd>GetReloadToken</kbd> method in <kbd>ConfigurationProvider</kbd> and a&#160;<kbd>Reload</kbd> method in <kbd>ConfigurationRoot</kbd> as well. If we read the documentation (using <em>F12</em> in Visual Studio), we know that the configuration system supports reloading the configuration without having to restart the web app, which is fantastic. Let's see how we can read the configuration.&#160;The default <kbd>Startup.cs</kbd> comes with the following code:</p>
<pre>public Startup(IConfiguration configuration)<br/>{<br/>    Configuration = configuration;<br/>}<br/><br/>public IConfiguration Configuration { get; }</pre>
<p>Notice that we already have the&#160;<kbd>IConfiguration</kbd> interface injected in the <kbd>Startup</kbd> constructor, which sets the <kbd>Configuration</kbd> property of the <kbd>Startup</kbd>. Also notice that when we create an app from the template, <kbd>appsettings.json</kbd> is included by default. Essentially, the default code has already wired up JSON-based configuration for us and we can leverage its goodness without having to code anything extra.</p>
<p>To make effective use of the&#160;<kbd>Configuration</kbd> property, lets do <em>F12</em> (go to definition) on&#160;<kbd>IConfiguration</kbd> and check out its properties. The following is the code that comes up in Visual Studio:</p>
<pre>    //<br/>    // Summary:<br/>    // Represents a set of key/value application configuration <br/>       properties.<br/>    [DefaultMember("Item")]<br/>    public interface IConfiguration<br/>    {<br/>        //<br/>        // Summary:<br/>        // Gets or sets a configuration value. //<br/>        // Parameters:<br/>        // key:<br/>        // The configuration key. //<br/>        // Returns:<br/>        // The configuration value.<br/>        string this[string key] { get; set; }<br/><br/>        //<br/>        // Summary:<br/>        // Gets the immediate descendant configuration sub-sections. //<br/>        // Returns:<br/>        // The configuration sub-sections.<br/>        IEnumerable&amp;lt;IConfigurationSection&amp;gt; GetChildren();<br/><br/>        //<br/>        // Summary:<br/>        // Returns a Microsoft.Extensions.Primitives.IChangeToken that <br/>           can be used to observe<br/>        // when this configuration is reloaded. //<br/>        // Returns:<br/>        // A Microsoft.Extensions.Primitives.IChangeToken.<br/>        IChangeToken GetReloadToken();<br/>        //<br/>        // Summary:<br/>        // Gets a configuration sub-section with the specified key. //<br/>        // Parameters:<br/>        // key:<br/>        // The key of the configuration section. //<br/>        // Returns:<br/>        // The <br/>           Microsoft.Extensions.Configuration.IConfigurationSection. //<br/>        // Remarks:<br/>        // This method will never return null. If no matching sub-<br/>           section is found with<br/>        // the specified key, an empty <br/>           Microsoft.Extensions.Configuration.IConfigurationSection<br/>        // will be returned.<br/>        IConfigurationSection GetSection(string key);<br/>    }</pre>
<p>So, we see that we can get the value of a key through the indexer property, passing in the key to look up. We can get children, get a reload token, or get a specific section by giving the key. This documentation makes our task of using the configuration extremely easy. Let's see an example. First, d<span>efine the config that we want to read, as shown here:</span></p>
<pre>{<br/>"Book": ".NET Core 2.0 By Example",<br/>  "Genere": {<br/>    "Name": "Technical level 200"<br/>  },<br/>  "Authors": [<br/>    {<br/>      "Name": "Rishabh Verma",<br/>      "Experience": "10"<br/>    },<br/>    {<br/>      "Name": "Neha Shrivastava",<br/>      "Experience": "7"<br/>    }<br/>  ]<br/>}</pre>
<p>The code to read the values would be:</p>
<pre>var book = Configuration["Book"];<br/>var genereName = Configuration["Genere:Name"];<br/>var author1Name = Configuration["Authors:0:Name"];<br/>var author1Experience = Configuration["Authors:0: Experience "];<br/>var author2Name = Configuration["Authors:1:Name"];<br/>var author2Experience = Configuration["Authors:1:Experience"];</pre>
<p>Notice that we used a zero-based index to access the contents of an array. The rest of the keys are read&#160; just by passing in the correct key to the&#160;<kbd>Configuration</kbd> indexer, as we have just seen.</p>
<p>We generally use different configuration settings for different environments. For example, Development, Test, Staging, and Production may all have different configuration settings. The <kbd>CreateDefaultBuilder</kbd> extension method in an ASP.NET Core 2.0 app adds configuration providers for reading JSON files and environment variables in the following order:</p>
<ol>
<li><kbd>appsettings.json</kbd></li>
<li><kbd>appsettings.&amp;lt;EnvironmentName&amp;gt;.json</kbd></li>
<li>Environment variables</li>
</ol>
<p>Here,&#160;<kbd>appsettings.&amp;lt;EnvironmentName&amp;gt;.json</kbd> would overwrite the key values defined in <kbd>appsettings.json</kbd> and the environment variables would overwrite the key values defined before them.</p>
<p>This didn't need any code changes in our <kbd>Startup</kbd> class. However, if we wish to use any other named config file, then we will need the code to be changed. The following example uses <kbd>config.json</kbd> as the configuration file, followed by <kbd>config.Development.json</kbd>:</p>
<pre>public Startup(IHostingEnvironment env)<br/>{<br/>    var builder = new ConfigurationBuilder()<br/>       .SetBasePath(env.ContentRootPath)<br/>       .AddJsonFile("config.json")<br/>       .AddJsonFile($"config.{env.EnvironmentName}.json");<br/>       Configuration = builder.Build();<br/>}</pre>
<p>A thoughtful programmer would say that in my <kbd>appsettings.json</kbd>, there may be a variety of sections for caching, database connection strings, service URLs, and so on. Why should I pass on all these values to every place? For example, what has caching to do with the database connection strings section or the service URL? Looks like there is no separation of concerns, and a clear violation of the&#160;<strong>I</strong> of <strong>SOLID</strong>: <strong>Interface Segregation Principle</strong>. Why should caching depend on <kbd>IConfiguration</kbd> when it needs just a subsection of it? To prevent these violations, it is <em>not</em> recommended to use the preceding way to access settings if configurations are to be read outside of <kbd>Startup.cs</kbd>.</p>
<p>We should instead use what is called the&#160;<kbd>Options</kbd> pattern. Using it is simple: first create a simple <strong>Plain&#160;Old&#160;CLR&#160;O</strong><span><strong>bject</strong> (</span><strong>POCO</strong>) class and then use it by registering it as a service and consume it wherever we need.&#160;It's a simple and dumb class with properties and no logic or smartness.</p>
<p>The POCO class for the preceding example would be:</p>
<pre>public class BookDetails<br/>{<br/>     public string Book { get; set; }<br/>     public Genere Genere { get; set; }<br/>     public Author[] Authors { get; set; }<br/> }<br/><br/> public class Genere<br/> {<br/>     public string Name { get; set; }<br/> }<br/><br/> public class Author<br/> {<br/>     public string Name { get; set; }<br/>     public string Experience { get; set; }<br/> }</pre>
<p>To register it, we go to the <kbd>ConfigureServices</kbd> method in <kbd>Startup.cs</kbd> and add the following line:</p>
<pre>services.Configure&amp;lt;BookDetails&amp;gt;(Configuration);</pre>
<p><kbd>BookDetails</kbd> will be populated and added to the container. To use it in the controller, the following code would suffice:</p>
<pre>private readonly BookDetails details;<br/><br/>public HomeController(IOptions&amp;lt;BookDetails&amp;gt; options)<br/>{<br/>     this.details = options.Value;<br/>}</pre>
<p>The properties can now be used from the strongly typed object,&#160;<kbd>details</kbd>.&#160;If you wish to overwrite certain properties after the configuration is bound, you can do the following in the&#160;<kbd>ConfigureService</kbd> method:</p>
<pre>services.Configure&amp;lt;BookDetails&amp;gt;(Configuration);<br/>services.Configure&amp;lt;BookDetails&amp;gt;(opt =&amp;gt; {opt.Name = “Roslyn via C#”;});</pre>
<p>This changes the name of the book to <kbd>"Roslyn Via C#"</kbd>.&#160;This is a last-one-wins approach, in which what is done last prevails.&#160;</p>
<p>Another question that comes to mind is what if my configuration value changes, do I restart my app like in the old days when modifying the <kbd>web.config</kbd> used to restart the app? No, we have this covered in ASP.NET Core. For this, we need to use <kbd>IOptionsSnapshot</kbd>, which is designed to support the reloading of configuration data when the configuration file changes. Using <kbd>IOptionsSnapshot</kbd> with the&#160;<kbd>reloadOnChange</kbd> flag set to <kbd>true</kbd>, the options are bound to the configuration and reloaded when the file changes.</p>
<p>From the preceding sample, we just need to change <kbd>IOptions</kbd> to <kbd>IOptionsSnapshot</kbd> and add a flag, <kbd>reloadOnChange</kbd>, to <kbd>true</kbd> while adding the JSON file in the&#160;<kbd>AddJsonFile</kbd> method.</p>
<p>Let's take a step back and look at our <kbd>Program.cs</kbd>, which is the entry point of the application:</p>
<pre>public static void Main(string[] args)<br/>{<br/>    BuildWebHost(args).Run();<br/>}<br/><br/>public static IWebHost BuildWebHost(string[] args) =&amp;gt;<br/>         WebHost.CreateDefaultBuilder(args)<br/>         .UseStartup&amp;lt;Startup&amp;gt;()<br/>         .Build();<br/>}</pre>
<p>The <kbd>CreateDefaultBuilder</kbd> loads optional configurations from <kbd>appsettings.json</kbd>,&#160;<kbd>appsettings.{Environment}.json</kbd>, User Secrets (in the&#160;Development&#160;environment), environment variables, and command-line arguments. The <kbd>CommandLine</kbd> configuration provider is called last. Calling the provider last allows the command-line arguments passed at runtime to override the configuration set by the other configuration providers called earlier, by the last-one-wins approach. Also, it is important to note that <kbd>reloadOnChange</kbd>&#160;is enabled for the <kbd>appsettings</kbd> file and so command-line arguments are overridden if a matching configuration value in an&#160;<kbd>appsetting<em>s</em></kbd>&#160;file is changed after the app starts.</p>
<p>When we work in enterprise applications, we will realize that there are a variety of configuration settings, such as secrets, passwords, and so on, that should not be kept in configuration files and hence should be kept out of the application code. Also, as a best practice, we should not be using production secrets in our development environment. In production also, these should be read from Azure Key Vault, which we will look at in later chapters. In the development environment, we can use the Secret Manager tool to safeguard secrets.</p>
<p>Before seeing how to use User Secrets, a question comes to mind: is that why we don't use environment variables to keep secrets away from the application, as it is supported by ASP.NET Core and is also there by default in the template code? Yes, we can use environment variables. However, environment variables are stored as plain text and can be accessed from any third-party code, so we can use them in local development but should not rely on them for production deployments.</p>
<p>The Secret Manager tool is just a fancy name given to store the secrets of a .NET Core project outside of the code base during development. The data stored is <em>not</em> encrypted. The only advantage this approach provides is that the secrets would not be part of the code and hence will not be checked in the source control, and so the secret will remain a secret during development. The secret is stored in a JSON file, which is kept in the user profile folder. To set up the User Secret tool, edit the <kbd>.csproj</kbd> file and add the following line in the <kbd>ItemGroup</kbd> node:</p>
<pre>&amp;lt;DotNetCliToolReference Include="Microsoft.Extensions.SecretManager.Tools" Version="2.0.0" /&amp;gt;</pre>
<p>So the final code looks like this:</p>
<pre>&amp;lt;ItemGroup&amp;gt;<br/>    &amp;lt;DotNetCliToolReference <br/>    Include="Microsoft.VisualStudio.Web.CodeGeneration.Tools" <br/>    Version="2.0.0" /&amp;gt;<br/>    &amp;lt;DotNetCliToolReference <br/>    Include="Microsoft.Extensions.SecretManager.Tools" Version="2.0.0" <br/>    /&amp;gt;<br/>&amp;lt;/ItemGroup&amp;gt;</pre>
<p>Save the <kbd>.csproj</kbd> file. This will restore the package we just added. Now, right-click the project in the <span class="packt_screen">Solution Explorer</span> and select <span class="packt_screen">Manage User Secrets</span>. This will add a new node named <kbd>UserSecretId</kbd> in the <kbd>PropertyGroup</kbd>. Save the file. A file named <kbd>secrets.json</kbd> will open up in Visual Studio. Hover over it and see the path. It will be <kbd>%AppData%\microsoft\UserSecrets\&amp;lt;userSecretsId&amp;gt;\secrets.json</kbd>.</p>
<p>Now we can add key value-pairs in the JSON file, just like we did for the configuration file.&#160;To read them, we need to add a couple of lines of code in our startup, as shown here:</p>
<pre>public Startup(IHostingEnvironment env)<br/>{<br/>    var builder = new ConfigurationBuilder()<br/>       .SetBasePath(env.ContentRootPath)<br/>       .AddJsonFile("config.json")<br/>       .AddJsonFile($"config.{env.EnvironmentName}.json");<br/><br/>       Configuration = builder.Build();<br/>}</pre>
<p>After this, we can access the secret, just like we access anything else from the configuration:</p>
<pre>var secretValue = Configuration["SecretKey"];</pre>
<p>This concludes our configuration discussion. Let's check out how we can do logging.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Logging</h1>
                </header>
            
            <article>
                
<p>ASP.NET Core supports the logging API, which&#160;works with a wide variety of logging providers. We can write logs to one or more locations and we can also plug in third-party logging frameworks, such as NLog, Serilog, and so on. In this section, we will look at out-of-the box logging, as it is sufficient for the logging needs of most apps.</p>
<p>Let's see the architecture of the logging infrastructure. The code map diagram for logging is shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ea861236-f127-49cb-814c-50edc17cce06.png"/></div>
<p>As we can see, it consists of the following main components:</p>
<ul>
<li><kbd>ILogger/ ILogger&amp;lt;TCategoryName&amp;gt;</kbd>: We will use this in our app to log messages. We can see it has the<kbd>IsEnabled()</kbd>&#160;method to check whether logging is enabled and <kbd>Log</kbd> to write the log.</li>
<li><kbd>ILoggerFactory</kbd>: It has a method to add a provider and logger.</li>
<li><kbd>ILoggerProvider</kbd>: It has a method to create the logger and it will control the output location of the log.</li>
</ul>
<p>We also notice the <kbd>EventId</kbd>, <kbd>LogLevel</kbd> enumeration, and extensions for registering the logging.</p>
<p>We can configure logging at the time of building the <kbd>WebHost</kbd> in the <kbd>Program.cs</kbd> file, as shown here:</p>
<pre>  public static IWebHost BuildWebHost(string[] args) =&amp;gt;<br/>            WebHost.CreateDefaultBuilder(args)<br/>                .UseStartup&amp;lt;Startup&amp;gt;()<br/>                <strong>.ConfigureLogging((hostingContext, logging) =&amp;gt; {</strong><strong>         <br/>                 logging.AddConfiguration(hostingContext. <br/>                 Configuration.GetSection("Logging"));</strong><br/><strong>                logging.AddConsole();</strong><br/><strong>                logging.AddDebug();</strong><br/>            })<br/>                .Build();</pre>
<p><span>This code configures the logging to read the logging configuration section provided in <kbd>appsettings.json</kbd> and adds console and debug logging.&#160;</span>Alternatively, we can inject <kbd>ILoggerFactory</kbd> as a parameter in the&#160;<kbd>Configure</kbd>&#160;method of <kbd>Startup.cs</kbd> and configure <kbd>loggerFactory</kbd>&#160;, as shown here:</p>
<pre>public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)<br/>{<br/>    loggerFactory.AddConsole();<br/>    loggerFactory.AddDebug();<br/>    //// Other methods omitted for brevity.<br/>}</pre>
<p>&#160;Like any other type or service in the ASP.NET Core application, the logger is also injected into a class or controller through DI.&#160; Here we inject <kbd>ILogger&amp;lt;T&amp;gt;</kbd>, where&#160;<kbd>T</kbd>&#160;is the name of the class. The type parameter&#160;<kbd>T</kbd>&#160;is used to define the&#160;<em>category</em> as it follows the <kbd>ILogger&amp;lt;TCategoryName&amp;gt;</kbd> interface.</p>
<p>For example, to write a log message in an ASP.NET Core controller,&#160;<kbd>HomeController</kbd>, we would inject the&#160;<kbd>ILogger&amp;lt;HomeController&amp;gt;</kbd>&#160;and call one of the logging extension methods on&#160;<kbd>ILogger</kbd>:</p>
<pre>public class HomeController: Controller <br/>{<br/>    private readonly ILogger&amp;lt;HomeController&amp;gt; logger;<br/><br/>    public HomeController(ILogger&amp;lt;HomeController&amp;gt; logger)<br/>    {<br/>         this.logger = logger;<br/>    }<br/><br/>    public IActionResult Index()<br/>    {<br/>        logger.<strong>LogInformation</strong>($"Calling {nameof(this.Index)}");<br/>        return View();<br/>    }<br/>}</pre>
<p class="mce-root">This will write a log message to each output of the configured logging providers. The following is what it would look like in the console:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d61c6be4-43d1-4d95-a8be-65da5cd28beb.jpg"/></div>
<p>ASP.NET Core&#160;includes numerous logging providers out of the box, which we can use to write log messages to various locations:</p>
<ul>
<li><strong>Console provider</strong>: To write log messages to the console</li>
<li><strong>Debug provider</strong>: To write log messages to the <span class="packt_screen">Debug</span> window while debugging in Visual Studio</li>
<li><strong>EventSource provider</strong>: To write log messages using Event Tracing for Windows</li>
<li><strong>Event Log provider</strong>: To write log messages to the Windows event log</li>
</ul>
<p>There is support for third-party structured logging as well, which is greatly useful, as it makes finding and diagnosing issues&#160;easier in production. Structured logging involves associating key-value pairs with each log entry, instead of a simple string of messages. We will not delve into this discussion, but it's good to know and the reader should take it up as an exercise to explore and implement structured logging with ASP.NET Core apps.</p>
<p>A&#160;<em>category</em>&#160;is included with each log that is created. We specify the category while creating an&#160;<kbd>ILogger</kbd>&#160;object. The category may be any string, but the convention is to use the qualified name of the class from which the logs are written, like we did in our previous example. We can also specify the log level, which indicates the degree of severity or importance of the log. For example, typically we use an information&#160;log when a method executes normally, a warning&#160;log when a method returns a 404 return code, and an error&#160;log when an unexpected exception is caught.&#160;Log methods that include the level in the method name are&#160;extension methods for <kbd>ILogger</kbd>&#160;, such as<kbd>LogError</kbd>,<kbd>LogWarning</kbd>, <kbd>LogInformation</kbd>, and&#160;<kbd>LogTrace</kbd>. Behind the scenes, these methods call the&#160;<kbd>Log</kbd>&#160;method whcih takes a&#160;<kbd>LogLevel</kbd>&#160;parameter.&#160;ASP.NET Core defines the following&#160;log levels, ordered here from least to highest severity. The documentation of the code makes it intuitive to understand:</p>
<pre>    //<br/>    // Summary:<br/>    // Defines logging severity levels.<br/>    public enum LogLevel<br/>    {<br/>        //<br/>        // Summary:<br/>        // Logs that contain the most detailed messages. These messages <br/>           may contain sensitive<br/>        // application data. These messages are disabled by default and <br/>           should never be<br/>        // enabled in a production environment.<br/>        Trace = 0,<br/>        //<br/>        // Summary:<br/>        // Logs that are used for interactive investigation during <br/>           development. These logs<br/>        // should primarily contain information useful for debugging <br/>           and have no long-term<br/>        // value.<br/>        Debug = 1,<br/>        //<br/>        // Summary:<br/>        // Logs that track the general flow of the application. These <br/>           logs should have long-term<br/>        // value.<br/>        Information = 2,<br/>        //<br/>        // Summary:<br/>        // Logs that highlight an abnormal or unexpected event in the <br/>           application flow,<br/>        // but do not otherwise cause the application execution to <br/>           stop.<br/>        Warning = 3,<br/>        //<br/>        // Summary:<br/>        // Logs that highlight when the current flow of execution is <br/>           stopped due to a failure.<br/>        // These should indicate a failure in the current activity, not <br/>           an application-wide<br/>        // failure.<br/>        Error = 4,<br/>        //<br/>        // Summary:<br/>        // Logs that describe an unrecoverable application or system <br/>           crash, or a catastrophic<br/>        // failure that requires immediate attention.<br/>        Critical = 5,<br/>        //<br/>        // Summary:<br/>        // Not used for writing log messages. Specifies that a logging <br/>           category should not<br/>        // write any messages.<br/>        None = 6<br/>    }</pre>
<p>We can set minimum trace levels while configuring the logger as well, with the following code, which creates the <kbd>WebHost</kbd> in the <kbd>Program.cs</kbd> file:</p>
<pre>.ConfigureLogging(logging =&amp;gt; logging.SetMinimumLevel(LogLevel.Warning))</pre>
<p>We can also do scope-based logging; that is, logging, on a logical group of operations within a scope in order to attach same data to each log. The <kbd>BeginScope</kbd> method is specifically made for this purpose and the following example shows the sample usage:</p>
<pre class="mce-root"> using (this.logger.BeginScope($"Logging scope demo"))<br/> {<br/>      this.logger.LogInformation($"Calling {nameof(this.Index)}");<br/>      return View();<br/> }</pre>
<p>Before we conclude, let's have a look at the configuration for <kbd>Logging</kbd> in the <kbd>appSettings.json</kbd> file. Consider the following <kbd>Logging</kbd> configuration:</p>
<pre>{<br/>  "Logging": {<br/>    "IncludeScopes": false,<br/>    "Debug": {<br/>      "LogLevel": {<br/>        "Default": "Information"<br/>      }<br/>    },<br/>    "Console": {<br/>      "LogLevel": {       <br/>        "Microsoft.AspNetCore.Mvc.Razor": "Error",<br/>        "Default": "Information"<br/>      }<br/>    },<br/>    "LogLevel": {<br/>      "Default": "Debug"<br/>    }<br/>  }<br/>}</pre>
<p>The preceding configuration defines four logging filters. The following is the interpretation of the configuration:</p>
<ol>
<li>Scope-based logging is disabled, as we have <kbd>IncludeScopes</kbd> as <kbd>false</kbd>. One of the primary use cases of scope-based logging comes in transactional data access or operations, where you may want to attach the same identifier to all the operations that happen in the transaction.</li>
<li>The default log level of the&#160;<kbd>Debug</kbd> log provider is <kbd>Information</kbd> for all categories.</li>
<li>The default log level of the&#160;<kbd>Console</kbd> log provider is <kbd>Information</kbd> for all categories.</li>
<li>The log level of categories beginning with <kbd>Microsoft.AspNetCore.Mvc.Razor</kbd> is <kbd>Error</kbd> for the&#160;<kbd>Console</kbd> log provider.</li>
<li>The default log level for all log providers for all categories is <kbd>Debug</kbd>.</li>
</ol>
<p>For a detailed and deep dive into logging in ASP.NET Core 2.0, readers should visit&#160;<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x</a>.<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x"></a></p>
<p>With this, we conclude our discussion of logging, and this chapter as well.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed the Let's Chat web application, its requirements and high-level design, and did the project setup to get started with coding. After doing the project setup, we learned about ASP.NET Core fundamentals, such as authentication, authorization, middleware, Dependency Injection, configuration, and logging.</p>
<p>In the next chapter, we will complete the fundamentals and then dive into coding the Let's Chat application.</p>


            </article>

            
        </section>
    </div>
</body>
</html>