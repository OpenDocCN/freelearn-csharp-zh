- en: Chapter 7.  Building a File Storage Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will walk through advanced development with `Xamarin.Forms`.
    We take a look at the use of Behaviors on UI elements. Then we will build a custom
    layout using the `Layout <View>` framework. We will also build our first SQLite
    database for storing text files. The following topics will be covered in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expected knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic Xamarin.Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# threading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Project structure setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a data access layer using SQLite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the ISQLiteStorage interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional threading techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the AsyncSemaphore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the AsyncLock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing native setup requirements for SQLite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the IoC container and modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing cross-platform logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the SQLiteStorage class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to C# 6.0 syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling alerts in view-models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the IMethods interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the ExtendedContentPage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a CarouselView using custom layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding scroll control to the CarouselView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a CustomRenderer for native gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a SynchronizationContext
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the EditFilePage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Windows Phone version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin by creating a new `Xamarin.Forms` project. Select **File** | **New**
    | **Solution** and create a new **Forms App**, as shown in the following screenshot**:**
  prefs: []
  type: TYPE_NORMAL
- en: '![Project structure setup](img/B05293_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the project `FileStorage`. Once the project is created, create another
    portable class library called `FileStorage.Portable`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project structure setup](img/B05293_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are going to start at the lower level and work upwards to native projects.
  prefs: []
  type: TYPE_NORMAL
- en: Building a data access layer using SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we focused on project architecture and we discussed
    the concepts one layer for data access this is where our database layer sits.
    Our data access layer is where we will be storing local text files.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite is the most commonly used database framework for mobiles. It is an in-process
    library that implements a self-contained, serverless, zero-configuration, transactional
    SQL database engine, and is free to use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are other frameworks that Xamarin supports such as ADO.NET and Realm,
    but it has been proven that SQLite is the most efficient database layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in the setup process is to add the following SQLite NuGet packages
    in our `FileStorage.Portable` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SQLite.Net.Async-PCL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLite.Net.Core-PCL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLite.Net-PCL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you add these in your packages, they should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a data access layer using SQLite](img/B05293_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to add a new folder called `DataAccess`. Inside this folder,
    create two subfolders called `Storable` and `Storage`. Inside the `Storable` folder,
    add a new file called `IStorable.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will be the interface for every object type stored in the database. In
    the preceding example, we are only going to have one storable, and each storable
    must have a string property called `Key`. This property will be used as the primary
    key for each database table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another file in the `Storable` folder called `FileStorable.cs` and implement
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FileStorable` object will be used as the data model for the file storable
    table in the database. In SQLite, during the setup of the database, tables are
    created from objects using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `FileStorable` object we pass as the type to the `CreateTable` function
    is used to map columns in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Building the ISQLiteStorage interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we must set up another class, which  will be used to control the queries
    performed on the database. Add a new file called `ISQLiteStorage.cs` into the
    `Storage` folder and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding interface defines all the functions that will be executed on the
    database. The advantage of using SQLite is that it performs all processing asynchronously,
    so every function that executes an SQL query returns a task. If you look closely
    at the `InsertObject` and `DeleteObjectByKey` functions, these require a type,
    meaning that we can execute queries to specific tables using types.
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional threading techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is where we will add some finesse with a common threading approach known
    as **asynchronous locking**. Since there will only be one instance of the **SQLiteStorage**
    object, this means we have the possibility of a race condition as multiple threads
    can make changes to the same database connection at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Race conditions are a common threading issue where multiple threads try to perform
    operations at the same time on shared data.
  prefs: []
  type: TYPE_NORMAL
- en: How do we solve this problem?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Locking is the most common C# approach for restricting shared resources between
    multiple threads. In order to avoid this situation, we create an object for locking
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to restrict code blocks to one thread at any one time, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is the perfect approach when our code is synchronous. The problem we have
    is our SQLite implementation is asynchronous, and the restriction with basic locking
    is we cannot execute asynchronous code inside a lock statement. This is where
    we have to implement the async-lock pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AsyncSemaphore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a new folder called `Threading` to the `FileStorage.Portable` project.
    Inside this folder, we are going to add a new file called `AsyncSemaphore.cs`
    and implement the first part as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `SemaphoreSlim` object is used to limit the number of threads that can access
    a resource.
  prefs: []
  type: TYPE_NORMAL
- en: The `AsyncSemaphore` keeps a count (the `m_count` property), which is the number
    of open *slots* it has available to satisfy waiters.
  prefs: []
  type: TYPE_NORMAL
- en: The `Task` returned from the `WaitAsync` function (the static `s_completed`
    property) will enter the completed state when the `AsyncSemaphore` has given it
    an available slot. That same `Task` will enter the `Canceled` state if the `CancellationToken`
    is signaled before the wait is satisfied; in that case, the `AsyncSemaphore` does
    not lose a slot.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A waiter is simply a `TaskCompletionSource` of type bool. It contains a `Task`,
    which is the operation to be performed by a single thread.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the AsyncLock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have built the `AsyncSemaphore` class, we will use this object
    inside the `AsyncLock` object. Let''s add a new file called `AsyncLock.cs` into
    the `Threading` folder and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `AsyncLock` class uses the `AsyncSemaphore` to ensure that only one thread
    at any one time has access to the bounded code block after the `LockAsync` function.
    The lock can be acquired asynchronously by calling `LockAsync`, and it is released
    by disposing the result of that task. The `AsyncLock` takes an optional `CancellationToken`,
    which can be used to cancel the acquiring of the lock.
  prefs: []
  type: TYPE_NORMAL
- en: The `Task` returned from the `LockAsync` function will enter the `Completed`
    state when it has acquired the `AsyncLock`. That same `Task` will enter the Canceled
    state if the `CancellationToken` is signaled before the wait is satisfied; in
    that case, the `AsyncLock` is not taken by that task.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's get back to implementing the `SQLiteStorage` class; this is where
    we are going to implement the async-lock pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing native setup requirements for SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next step is to add the final setup requirements. Each device platform has
    a specific framework that it must use when setting up the connection to the local
    database. This means we are going to add another dependency-injected interface
    to set these native side requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new file called `ISqliteSetup.cs` to the `Storage` folder and implement
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we implement this class in the platform projects, we need to add the
    following SQLite NuGet packages for all platform projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SQLite.Net.Async-PCL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLite.Net.Core-PCL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLite.Net-PCL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s turn our attention to the iOS project. Add a new folder called `DataAccess`,
    add in a new file called `SQLiteSetup.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The main property that we need to focus on is `ISQLitePlatform`. This comes
    from the `SQLite.Net.Interop` library. We will be registering this item inside
    an IoC container as we will need this instance down in the portable project when
    we create a connection to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go any further, we need to set up the IoC container with Autofac.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the IoC container and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like our last projects, we are going to set up another IoC container using
    Autofac. Let's first add the Autofac nuget packages to all projects in the solution.
    We can then copy the `IoC` folder from the `Stocklist.Portable` project in [Chapter
    5](ch05.html "Chapter 5. Building a Stocklist Application"), *Building a Stocklist
    Application*. Make sure you include both the `IoC.cs` and `IModule.cs` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s hop over to the native projects, add the `Modules` folder in the
    iOS and Android projects, and implement `IOSModule.cs` and `DroidModule.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: and the DroidModule,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Notice how quick we are piecing things together?**'
  prefs: []
  type: TYPE_NORMAL
- en: When you have the right direction in building cross-platform applications, the
    complexity of multiple platform support should not be an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Inside both of the aforementioned modules we are registering the `SQLiteSetup`
    and `SQLitePlatformIOS/Droid` objects so the `SQLiteStorage` implementation can
    use these items inside the `FileStorage.Portable` project.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get back to finishing off the `SQLiteStorage` implementation, we are
    going to set up a useful logging approach that can be used in all cross-platform
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing cross-platform logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our IoC container, we are going to use dependency injection
    for logging. Adding customized logging features in cross-platform applications
    is very useful for tracking operations between all of the different projects.
    The first step is to add a new folder called `Logging`, add a new file called
    `ILogger.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For this example, our logger is going to use the standard `Debug` console from
    `System.Diagnostics` with iOS, but in Android we are going to use the extensive
    logging functionality provided by Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the `Logging` folder in both iOS and Android and implement the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Nothing too flash with iOS logging, but we have an extra output line for logging
    statements with current time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for the Android implementation, we are going to use native logging from
    the `Android.Util` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the `Log` object from the `Android.Util` library, we have the option to specify
    priorities (`info`, `debug`, `error`). The more we can dig into the specifics
    of what we want the application to spit out, the better we can track exactly what
    is happening under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! Now let's get back to building the `SQLiteStorage` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the SQLiteStorage class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now back to the `FileStorage.Portable` project. Let''s add another file into
    the `Storage` folder called `SQLiteStorage.cs` and implement the `private` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have a private `AsyncLock` object as we will be doing synchronous and asynchronous
    locking implementations. We then have two SQLite objects for creating the connection
    to our local database. The `_dbPath` variable is used to hold the local database
    path; this will be used for setting up the connection. We also have our dependency
    service interface `ILogger` and another string for tagging the current object.
    Tagging is useful with logging as it tells the logger what class is logging.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to C# 6.0 syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s add in the constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see some C# 6.0 syntax. Using the question mark (`?`) after the
    constructor parameter `sqliteSetup` means that, if the object is not null, we
    can access the property. This avoids having to create an `if` statement such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also some more C# 6.0 syntax with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The dollar sign (`$`) character is used for interpolated strings. Interpolated
    string expressions create a string by replacing the contained expressions with
    the `ToString` representations of the expressions' results.
  prefs: []
  type: TYPE_NORMAL
- en: Look more closely at the items we are assigning. We are using the `SQLiteSetup`
    object to set the database path and SQLite platform properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our first two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `CreateSQLiteAsyncConnection` function creates a new `Func` of type `SQLiteConnectionWithLock`,
    we use this `Func` to instantiate a new `SQLiteAsyncConnection`. The `Func` checks
    if we have already created a connection to the database. If we haven't yet established
    this connection, it will create a new instance of the `SQLiteConnectionWithLock`
    object and pass in the database path and platform we retrieved from the `SQLSetup
    object`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `CreateTable` function, we will take our first look at the async-lock
    pattern. The great thing about the `AsyncLock` object is that we can contain the
    await inside a `using` statement. When one thread is creating a table on the one
    instance of the `SQLiteAsyncConnection`, another thread will have to wait at the
    using line until the previous thread has finished creating the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next function is `GetTable`. This will use the async-lock pattern again
    to make sure that only one thread is querying the database at any one time. This
    function will perform a standard SQL query for selecting all the items of a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The table will be determined by the type `T` passed, and the result received
    from the database will be all the table''s items as an `IEnumerable` of type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we are catching any exception that may occur in this query?
  prefs: []
  type: TYPE_NORMAL
- en: We are building a location string to pinpoint the exact location in our application
    where the exception is coming from. Then we use our `ILogger` implementation to
    route the custom-built exception string to the specific native output console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we have the `InsertObject` function. This will be responsible for adding
    a new item to the correct table in the database. We will also make use of the
    async-lock pattern to lock the connection from being accessed while an insertion
    is taking place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `CreateInsertOrReplaceQuery` function?
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add an extension class to the `IStorable` interface. Add a
    new file called `StorableExtensions.cs` to the location **DataAccess****| Storable**
    in the `FileStorage.Portable` project and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function is clever enough to build an insert and replace query
    out of any item that inherits the `IStorable` interface. It uses the `System.Reflection`
    library to retrieve all properties of an `IStorable` object using the `GetRuntimeProperties`
    function. We then iterate through all properties and build a query according to
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we didn't have the `PrimaryKey` attribute set on the `Key` property in the
    `FileStorable` class, the update would not work and a new item would be added
    every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the `DeleteObjectByKey` function. This will be used to delete an item
    from a table using the `Key` property from the `IStorable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic! SQLite has been set up and integrated with the async-lock pattern
    to make it thread-safe. Our final step is to add the `PortableModule` for the
    IoC container and register the `SqliteStorage` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `FireStorable.Portable` project, create a new folder called `Modules`,
    add in a new file called `PortableModule.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now we can start with the user interface layer and begin building some custom
    UI objects.
  prefs: []
  type: TYPE_NORMAL
- en: Handling alerts in view-models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Handling alerts via view-models is important as we handle many errors via `try/catch`
    statements. To respond to these errors, we want to display an alert dialog showing
    the error message to the user. There are two ways we are going to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Using an `EventHandler` for pushing events to the current page so that we can
    call the `DisplayAlert` function with different messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an interface for dependency injection where we will implement native alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our first step is to add the `ViewModelBase` class; this is where alerts will
    be fired from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder in the `FileStorage.Portable` project called `ViewModels`,
    add a new file called `ViewModelBase.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are using the same `ViewModelBase` implementation we used in [Chapter 5](ch05.html
    "Chapter 5. Building a Stocklist Application"), *Building a Stocklist Application*,
    except we are adding an extra `IMethods` interface in the constructor (we will
    implement this later), which is used to show native alerts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the protected methods `OnPropertyChanged` and `LoadAsync` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And the public methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though we are working in the portable project, this is still part of the
    presentation layer when it comes to architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The `NotifyAlert` function is used to display alerts via the `Xamarin.Forms`
    function `DisplayAlert` on a `ContentPage`. The `ShowEntryAlert` function is used
    to display alerts via the `IMethod` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the TaskCompletionSource?
  prefs: []
  type: TYPE_NORMAL
- en: This means we can await the `ShowEntryAlert` function. When the user responds
    to the alert, the `Task` will enter the completed state. This ensures that the
    code is executed only once a response is received.
  prefs: []
  type: TYPE_NORMAL
- en: Building the IMethods interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new folder in the `FileStorage.Portable` project,
    adding a new file called `IMethods.cs`, and implementing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For all native projects, add a new folder called `Extras`. Let''s start with
    the iOS project. add a new file called `IOSMethods.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We should recognize the `Exit` function from previous chapters. The `DisplayEntryAlert`
    function creates a `PlainTextInputUIAlertView`. This alert will ask for text input
    via a textbox and we can retrieve this text value using the `GetTextField` function.
    The alert will also display a `Yes` and `No` button, so when the user enters text
    and presses `Yes`, a new file will be created with the text input set as the filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s replicate the same procedure for Android. Add a new file called
    `DroidMethods.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This time for Android, we are using the `AlertDialog.Builder` framework. We
    use the `Forms.Context` property to retrieve the current context, which we use
    to create a new `AlertDialog.Builder`. We have to use the `SetView` function in
    this framework to assign a custom view for text input. This custom view is created
    using a new XML layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new file called `EntryAlertView.xml` to the **Resources** | **layout**
    folder and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: All we have is an `EditText` object to retrieve the filename from the user in
    the alert dialog. Using `FindViewById` in the `DroidMethods` class, we can reference
    this `EditText` item to retrieve the text value entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: That's everything. Our next step is a customized `ContentPage` to handle the
    `Alert` events from each view-model.
  prefs: []
  type: TYPE_NORMAL
- en: Building the ExtendedContentPage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a new folder called `UI` inside the `FileStorage` project, add in a new
    file called `ExtendedContentPage.cs`, and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `_model` property is used to reference the view-model of each page as every
    view-model inherits the `ViewModelBase` class. When the page is created, we register
    the `HandleAlert` function to the view-model `Alert` event. Every time this function
    is called, it will call the `DisplayAlert` function from `Xamarin.Forms`.
  prefs: []
  type: TYPE_NORMAL
- en: Why are we implementing two different techniques for showing alerts?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cross-platform feature for displaying alerts does not allow us to use the
    text input addition that we built natively.
  prefs: []
  type: TYPE_NORMAL
- en: Great! We now have a nice solution for multiple types of alert in out cross-platform
    projects. Our next step is to implement our first custom layout known as a `CarouselView`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Xamarin.Forms` has its own `CarouselView`, but it has been removed until the
    UI object is more stable.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a CarouselView using custom layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Xamarin.Forms` is a very young layout system, meaning that the number of layouts
    is quite limited. There are times when we will need to implement our own custom
    layouts to give us control over exactly where and how our views and controls appear
    on screen. The requirement will come from situations where you need to improve
    performance on screens that display a lot of views and controls, and sometimes
    the standard layouts are not good enough. We want to implement our custom layouts
    to carry out the absolute minimum amount of work required to produce the required
    layout.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All layouts derive from the `Xamarin.Forms.Layout` class, which provides the
    required mechanisms for adding and removing children internally as well as some
    key utilities for writing a layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a new folder called `Controls` in the `FireStorable`
    project. Add a new file called `CarouselLayout.cs` and implement the first part
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All layouts must inherit the `Layout` framework. `Xamarin.Forms.Layout<T>` provides
    a publicly exposed `IList<T>` Children that end users can access. We want all
    children of this collection to be of type `View`.
  prefs: []
  type: TYPE_NORMAL
- en: We have two `private` properties, one for the layout width and an `IDisposable`
    for handling data change subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add in some more properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We have an indexing reference that will return an array element from the **`ItemsSource
    IEnumerable`** , and the `ItemTemplate` property, which is used to render a view
    layout for every child in `ItemsSource`. We have to use the `Linq` function `ToList`
    to allow us to access an `IEnumerable` via an index value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to add some overrides to the `Layout` framework. Every custom
    layout must override the `LayoutChildren` method. This is responsible for positioning
    children on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will call another method, `ComputeLayout`, which will
    return an `IEnumerable` of **Rectangles** (also known as **regions**). We then
    iterate through the `IEnumerable` and call `LayoutChildIntoBoundingRegion` for
    each region. This method will handle positioning the element relative to the bounding
    region.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our layout must also implement the `OnMeasure` function. This is required to
    make sure the new layout is sized correctly when placed inside other layouts.
    During layout cycles, this method may be called many times depending on the layout
    above it and how many layout exceptions are required to resolve the current layout
    hierarchy. Add the following below the `LayoutChildren` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is therefore important to consider speed when implementing this function.
    Failure to implement this function will not always break your layout, particularly
    if it's always inside parents, which fix the child size anyway.
  prefs: []
  type: TYPE_NORMAL
- en: The `ComputeNiaveLayout` will return a list of **rows**. We then retrieve the
    last row from this list and use this for the max x-value and max y-value to determine
    the total width and height by calculating the difference between the first and
    last element on both the x-axis and y-axis. Finally, we return a new `SizeRequest`
    object with the calculated width and height, which will be used to resize the
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the missing functions `ComputeNiaveLayout` and `ComputeLayout` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is used simply to perform the `SelectMany` query. The `ComputeNiaveLayout`
    layout is where all the work is done. This will iterate through all children;
    it will create one **row**, and one rectangle inside this row that will size to
    the height of the layout and the width will equal the total of all children widths.
    All children will be positioned horizontally next to one another to the right
    of the screen, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a CarouselView using custom layouts](img/B05293_07_04-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But only one child will be visible on screen at any one time as each child
    is sized to the full height and width of the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Hold on! What if I have a lot of children? This means that they will be stacked
    horizontally past the width of the screen. What do we do now?
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of a carousel view is to only show one view at a time, when the user
    swipes left and right; the view on the left/right side of the current view will
    come onto screen while the current view will move out of view, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a CarouselView using custom layouts](img/B05293_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even though we have a custom layout that presents children horizontally, how
    are we going to handle the swipe events and scroll control?
  prefs: []
  type: TYPE_NORMAL
- en: We will achieve scroll control via a `ScrollView` and create a custom renderer
    for handling swipe events.
  prefs: []
  type: TYPE_NORMAL
- en: Adding scroll control to the CarouselView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a new file into the `Controls` folder called `CarouselScroll.cs` and implement
    the first part as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `CarouselScroll` will inherit the `ScrollView` object as this will be the
    bounding view for the `CarouselLayout`. We are also going to create a `DataTemplate`
    variable for setting the `DataTemplate` object inside the `CarouselLayout`. Then,
    in the constructor, we instantiate a new `CarouselLayout` object as the `Content`
    of the `ScrollView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add a custom binding object for the `ItemsSource`. Like a `ListView`,
    we will bind an `ObserableCollection` of items to this property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Take note of the `propertyChanged` event; when the binding changes, we will
    update the `ItemsSource` property of the `CarouselLayout.` Remember that the `CarouselLayout`
    is in charge of laying out a child for every item in the `IEnumerable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need another bindable property for data changes. This will be an `IObservable`
    object that will listen for any `DataChange` events. If an event occurs, the `CarouselLayout`
    will layout the children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to override the `LayoutChildren` function; so when the `ScrollView`
    updates its children, we want to update the height and width properties of the
    `CarouselLayout`, thus updating the layout of the children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have one more function, `GetSelectedItem`, which simply returns a child
    from the `CarouselLayout` using an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Our next stage into the `CarouselView` is creating a `CustomRenderer` that will
    allow swipe gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Building a CustomRenderer for native gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need to handle swipe left and right gestures for each mobile platform.
    Unfortunately, `Xamarin.Forms` doesn''t offer a cross-platform feature for swipe
    gestures, so we need to implement this ourselves. In order to do this, we are
    going to build a `CustomRenderer`. Start by adding a new file to the `Controls`
    folder called `GestureView.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This view has an `EventHandler` for each gesture, we also require a gesture
    for tap events. Even though `Xamarin.Forms` offers this feature when we render
    over the top of the `CarouselView` at runtime, the `Xamarin.Forms` gesture will
    no longer work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, inside the `FileStorage.iOS` project, let''s add a new folder called `Renderers`
    and another folder inside this called `GestureView`. Then, inside the `GestureView`
    folder, add in a new file called `GestureViewiOS.cs` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This view has an `EventHandler` for each gesture, we also require a gesture
    for tap events. Even though `Xamarin.Forms` offers these features when we render
    over the top of the `CarouselView` at runtime, the Xamarin.Forms gesture will
    no longer work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This function will only be called once from the `OnElementChanged` function
    of the `GestureViewRenderer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the renderer class. Add another file called `GestureViewRenderer.cs`
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a property from the `UI` object changes, the `OnElementChanged` function
    will be called. We only call the `SetNativeControl` once if the `Control` property
    of the renderer is null. The `Element` property of a renderer is usually the UI
    object from the `Xamarin.Forms` project (in our case the `FileStorage` project,
    `GestureView`). When we receive a reference to the `GestureView` object (inside
    the `OnElementChanged` function), we pass this into the `InitGestures` function
    in order to use the `EventHandlers` on the `GestureView` object. Now, when we
    swipe left and right or tap on the native `mainView` object, it will call the
    `NotifySwipeLeft`, `NotifySwipeLeft`, and `NotifyTouch` functions for the `GestureView`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to add the following line above the namespace declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We must always add the `ExportRenderer` attribute to a custom renderer class
    to specify that it will be used to render the `Xamarin.Forms` control.
  prefs: []
  type: TYPE_NORMAL
- en: The `GestureViewiOS` object will be the view displayed on top of the `GestureView`
    object in our `FileStorage` project. Wherever a new `GestureView` object is placed
    in our `ContentPage`, the `GestureViewRenderer` will render a new `GestreViewiOS`view
    in its place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement the same for Android. Add a new folder inside the `FileStorage.Droid`
    project called `Renderers` and another folder inside this called `GestureView`.
    Then, inside the `GestureView` folder, add in a new file called `GestureListener.cs`
    and implement the first part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: A `GestureDetector` is used to respond to multiple types of press event for
    a particular view. We also pass the `Xamarin.Forms GestureView` object into this
    class so that we can fire the `NotifySwipeLeft`, `NotifySwipeLeft`, and `NotifyTouch`
    functions when a particular event occurs. The threshold values are used as a minimum
    swipe distance and touch pressure. When a user performs a swipe on this view,
    a certain amount of pressure and movement must be applied for an event to be fired.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `SimpleOnGestureListener` extension is a convenience class when you only
    want to listen for a subset of all the gestures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we must override the following functions (we aren''t going to be doing
    anything with these but they must be overridden):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the functions that we are going to use. The `OnSingleTapUp` function
    will be responsible for handling touch events, called when a user applies a single
    tap gesture to the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnFling` function is responsible for handling swipe events. The two `MotionEvent`
    items are the start and end points (*x*, *y*) when a user starts to swipe and
    when the finger is removed. We calculate the drag distance and make sure that
    the absolute value of `diffX` is greater than the absolute value of `diffY`. This
    ensures that we are dragging horizontally. We then make sure that the absolute
    value of `diffX` is greater than the `Swipe_Threshold`, and the `VelocityX` is
    greater than the `Swipe_Velocity_Threshold`. If all this is met, we then fire
    a swipe right if the `diffX` is positive; otherwise, it will fire a swipe left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now build the `GestureViewRenderer` and integrate is with the `GestureDetector`.
    Add a new file into the `Gesture` folder called `GestureViewRenderer.cs` and implement
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now going to create an empty `LinearLayout`to use for the `Control`.
    This is the blank view that will receive the touch events. We then instantiate
    a new `GestureListener` from above and pass this into a new `GestureDetector`.
    The GestureDetector''s `OnTouchEvent` function is called for all touch and motion
    events, and within this class we break down the events in more detail to determine
    the exact event that took place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Notice the null checks on the `OldElemenet` and `NewElement` properties of the
    arguments?
  prefs: []
  type: TYPE_NORMAL
- en: If the `OldElemenet` is null, we must deregister touch events, and if the `NewElement`
    is null, we register the `GenericMotion` and `Touch` events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `GestureView` and `GestureViewRenderers` ready, it''s
    time to create the final control and add a new **Forms ContentView Xaml** file
    called `CarouselView.xaml`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a CustomRenderer for native gestures](img/B05293_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also implement the following in `CarouselView.xaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will create a `Grid` to overlay the `GestureView` on top
    of the `CarouselScroll`. This means that the `GestureView` will detect the swipe
    and touch events and pass these down to the `CarouselScroll`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement `CarouselView.xaml.cs` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part shows the event registration to the `GestureView`. We also have
    a custom binding for a `Command`, which will be invoked when a `Touch` event occurs.
    Let''s add the `EventHandler` functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `HandleTouch` function will simply call the `GetSelectedItem` function from
    the `CarouselScroll.` This means we get the bound object from the view and we
    use this as a parameter that is passed into the execution of the `SelectCommand`.
    The `HandleSwipeLeft` function will increase the selected index by 1 and scroll
    to the left by the entire width amount of the view. Remember, each child takes
    up the entire width and height of the view, so in order to move to the next child,
    we have to scroll horizontally by the width.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have the `HandleSwipeRight` function, which will perform the opposite
    to `HandleSwipeLeft` and scroll in the opposite direction. In each swipe function,
    we also perform a check to see if we are on the starting child or the last child.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have just built your first custom layout. Now let's build
    the rest of the user interface and see how we can use it.
  prefs: []
  type: TYPE_NORMAL
- en: Building the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s now time to build the user interface screens; we are going to start by building
    the view-models. Inside the `FileStorage.Portable` project, add a new folder called
    `ViewModels`, add a new file called `MainPageViewModel.cs`, and implement the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the `ISQLiteStorage` object in this view-model because we will be
    creating the database tables when this view-model is created. Don''t forget we
    need to implement the public properties for all `private` properties; the following
    are two properties to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add the remaining properties. We call the `SetupSQLite` function from
    the constructor to set up the database as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `SetupSQLite` function is responsible for creating the asynchronous connection
    to the local database and building the one table from the `FileStorable` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s build the page for this view-model. Add a new folder called `Pages`
    inside the `FileStorage` project, add in a new file called `MainPage.xaml`, and
    implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Remember our custom control `ExtendedContentPage`?
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use this for all pages so that every page has alert functionality
    connected with its view-model. The following line gives the reference to our custom
    control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: <ui:ExtendedContentPage
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'public partial class MainPage : ExtendedContentPage, INavigableXamarinFormsPage'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '#region Constructors'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'public MainPage (MainPageViewModel model) : base(model)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: BindingContext = model;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: InitializeComponent ();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#endregion'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#region INavigableXamarinFormsPage interface'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public void OnNavigatedTo(IDictionary<string, object> navigationParameters)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this.Show (navigationParameters);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#endregion'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'public class FileItemViewModel : ViewModelBase'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '#region Private Properties'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private string _fileName;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: private string _contents;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#endregion'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#region Public Properties'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public string FileName
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: get
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return _fileName;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if (value.Equals(_fileName))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: _fileName = value; OnPropertyChanged("FileName");
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public string Contents
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: get
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return _contents;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if (value.Equals(_contents))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: _contents = value; OnPropertyChanged("Contents");
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#endregion'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#region Public Methods'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public void Apply(FileStorable file)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FileName = file.Key ?? string.Empty;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Contents = file.Contents ?? string.Empty;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#endregion'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#region Constructors'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'public FileItemViewModel(INavigationService navigation, IMethods methods) :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: base(navigation, methods) { }
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#endregion'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'public class FilesPageViewModel : ViewModelBase'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#region Private Properties'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: private readonly Func<FileItemViewModel> _fileFactory;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: private readonly ISQLiteStorage _storage;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: private readonly SynchronizationContext _context;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: private ICommand _editFileCommand;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: private ICommand _createFileCommand;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: private bool _noFiles;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '#endregion'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '#region Public Properties'
  prefs: []
  type: TYPE_NORMAL
- en: public Subject<DataChange> DataChanges { get; private set; }
  prefs: []
  type: TYPE_NORMAL
- en: public ICommand EditFileCommand
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: get
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return _editFileCommand;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (value.Equals(_editFileCommand))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: _editFileCommand = value;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: OnPropertyChanged("EditFileCommand");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public ICommand CreateFileCommand
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: get
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return _createFileCommand;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (value.Equals(_createFileCommand))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _createFileCommand = value;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: OnPropertyChanged("CreateFileCommand");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public bool AnyFiles
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: get
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return _noFiles;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (value.Equals(_noFiles))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: _noFiles = value;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: OnPropertyChanged("AnyFiles");
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public ObservableCollection<FileItemViewModel> Cells { get; set; }
  prefs: []
  type: TYPE_NORMAL
- en: '#endregion'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '#region Constructors'
  prefs: []
  type: TYPE_NORMAL
- en: public FilesPageViewModel(INavigationService navigation, Func<Action<object>,
    ICommand> commandFactory,
  prefs: []
  type: TYPE_NORMAL
- en: IMethods methods, ISQLiteStorage storage, Func<FileItemViewModel>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fileFactory) : base(navigation, methods)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: DataChanges = new Subject<DataChange>();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: // retrieve main thread context _context =
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: SynchronizationContext.Current;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: _storage = storage;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: _fileFactory = fileFactory;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Cells = new ObservableCollection<FileItemViewModel>();
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: _editFileCommand = commandFactory(async (file) =>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await Navigation.Navigate(PageNames.EditFilePage,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: new Dictionary<string, object>()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"filename", (file as FileItemViewModel).FileName},'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"contents", (file as FileItemViewModel).Contents} });'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: _createFileCommand = commandFactory(async (obj) =>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: var fileName = await ShowEntryAlert("Enter file name:");
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if (!string.IsNullOrEmpty(fileName))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: await Navigation.Navigate(PageNames.EditFilePage,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: new Dictionary<string, object>()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"filename", fileName'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '});'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '#endregion'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Using a SynchronizationContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all `Xamarin.Forms` applications, when we update view-model properties that
    are bound to a view, they must be changed on the main UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This rule applies to any application. UI changes must happen on the main UI
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: The `SynchronizationContext.Current` property is used to retrieve the current
    sync context of any thread.
  prefs: []
  type: TYPE_NORMAL
- en: How do we know this context is from the main UI thread?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We store a reference to this context in the constructor because all view-models
    are created on the main UI thread. This means we have the current sync context
    of the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how we are going to use this sync context reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `UpdateFiles` function is called every time the page appears. When we call
    `Post` on the context object, we have to pass an action that will be propagated
    to the main UI thread when it becomes available. Inside this action, we will use
    the `GetTable` function to retrieve all files from the table. Then, for every
    `FileStorable` object, we instantiate a new `FileItemViewModel` from the factory
    and add this to the `ObservableCollection`. After we do this for all files, we
    publish a new event to the `DataChanges` sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to add the `OnAppear` function, which will be called every
    time the page appears; it doesn''t matter if we push or pop to this page, this
    function will be called every time. This means that we will update the current
    files, every time the page appears, so the `CarouselView` will have the most current
    list of files in the database at all times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s build the page for this view-model. To do so, inside the `Pages`
    folder, add in `FilesPage.xaml` and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are including the `CarouselView` in this page, we have to add a new
    reference namespace at the top of the page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Building the EditFilePage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we move to the last page of the application. Add a new file called `EditFilePage.xaml`
    to the `Pages` folder and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We have an `Entry` property at the very top for editing the filename and we
    have an `Editor` for filling in the text contents of the file. We also have two
    buttons: one for saving the file and one for deleting it.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, turn our attention to the `Entry` item; we are going to introduce a new
    `Xamarin.Forms` feature called `Behaviours`.
  prefs: []
  type: TYPE_NORMAL
- en: Behaviours
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behaviours enable you to implement objects which can be concisely attached to
     events and behaviours of any control type. This means we can package and reuse
    behaviours between similar controls without having to write repetitive code behind
    our XAML sheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new folder called `Behaviours`, add in a new file called `LowercaseEntryBehaviour.cs`,
    and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The `OnAttachedTo` and `OnDetachingFrom` methods get invoked when the behavior
    is attached/detached from parent UI element; so we subscribe to the `TextChanged`
    event, and when it triggers, we update the `Text` property by calling the `ToLower`
    function. This means that irrespective of the case of the text when it is entered
    into the `Entry` object, it will always be lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add the view-model for the `EditFilePage`. Inside the `ViewModels`
    folder, add another file called `EditFilePageViewModel.cs` and implement the `private`
    properties first as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We have to use the `ISQLiteStorage` object for saving and deleting files on
    the local database. We then have another two properties to record the contents
    of the file and filename. The two commands are used to invoke the SQLite functions
    for saving and deleting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and add the public properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that we only want to publicize the variables that are going to be bound
    through the XAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we add the constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, finally, we add the remaining functions; we have the `OnDisppear` function,
    which will be used for clearing the filename and contents whenever the page disappears.
    Then we have the `LoadAsync` override, which is going to set the filename and
    contents from the navigation parameters that are passed in from the previous page.
    From the `FilesPage`, when a user selects a file from the carousel, the `FileItemViewModel`
    object details are passed into a dictionary for the navigation parameters that
    are passed into the `EditFilePage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic! We have finished implementing the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have built everything in the `FileStorage.Portable` and `FileStorage` projects,
    but there are still pieces missing. Here is your challenge; fill in the missing
    pieces of the solution and compile it. The remaining files are exactly the same
    from all our other `Xamarin.Forms` solutions, but now it is your turn to finish
    off the project.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Windows Phone version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are looking for an even bigger challenge, then try adding on the Windows
    Phone version. Don''t be intimidated by this exercise, most of the code is shared
    for you. On the Windows Phone version, you will have to implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WinPhoneMethods`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GestureViewRenderer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLiteSetup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoggerWinPhone`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will also need to download a Visual Studio extension for SQLite from the
    following link [http://sqlite.org/download.html](http://sqlite.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the **sqlite-wp81-winrt-3130000.vsix** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the Windows Phone version](img/B05293_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Install the extensions and then reopen Visual Studio. Then, in your Windows
    Phone project, right-click on **References** and select **Add Reference....**
    Then select **Windows Phone 8.1** | **Extensions** from the left-hand side and
    select **SQLite for Windows Phone 8.1**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the Windows Phone version](img/B05293_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you run this project, you must make sure that the **x86** configuration
    is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the Windows Phone version](img/B05293_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To help you get started, the implementation for the `SQLiteSetup` class is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see the finished version, visit the following link: [https://github.com/flusharcade/chapter7-filestorage](https://github.com/flusharcade/chapter7-filestorage).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored a walkthrough for integrating SQLite in a `Xamarin.Forms`
    application. We addressed the async-lock pattern and how to implement it with
    SQLite to make database connections thread-safe. In the final chapter, we will
    build a cross-platform camera application that will implement native control over
    camera hardware. We will also present camera video outlets via a `CustomRenderer`
    and build events to handle camera events in our portable library.
  prefs: []
  type: TYPE_NORMAL
