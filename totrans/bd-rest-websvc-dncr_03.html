<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">User Registration and Administration</h1>
                </header>
            
            <article>
                
<p>We built the foundation of the app in the last chapter, where we also explored the HTTP verbs in detail while creating a controller inside the ASP.NET Core Web API.</p>
<p>Now, we are gradually moving toward an important aspect of the API, called <strong>authentication</strong>. Authentication is definitely a required component because of the ease of accessibility of the API. Limiting the requests and putting a restriction on them would prevent malicious attacks.</p>
<p>Users of your application, or customers, in our case, need a registration form/interface where their details can be grabbed by the system. We will see how to register users with the API.</p>
<p>After you register and have all the details of the customers, such as <em>email</em> and <em>password</em>, it will be easy for you to identify the requests coming from a client. Wait, that is easy, but there are principles we need to follow in order to authenticate the user to access our resources. That is where <em>Basic Authentication</em> and <em>OAuth Authentication</em> will come into the picture.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Why authentication and limiting requests?</li>
<li>Using EF Core for bootstrapping our REST API</li>
<li>Adding basic authentication to our REST API</li>
<li>Adding Oauth 2.0 authentication to our service</li>
<li>Defining the client-based API consumption architecture</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why authentication and limiting requests?</h1>
                </header>
            
            <article>
                
<p>If I told you that there is a Web API exposed from a particular country's government that you can use to get all the details of its citizens, then the first thing you would ask me is whether you can extract data from the API or not. That is exactly what we will be discussing.</p>
<p>So, if you take the previous example, the data that comes back from that API would have the citizens' sensitive data, such as <em>name</em>, <em>address</em>, <em>phone number</em>, <em>country, and social security number</em>. The government should never allow everyone to access this data. Only authenticated sources are allowed, generally. What that means is when you call one API, you need to send your identity and ask to it to allow you to operate on the data. If the identity is wrong or not in the list of allowed sources, it will be rejected by the API. Imagine terrorists trying to access the API, you would definitely deny access by detecting their identity.</p>
<p>Now imagine another scenario, where a university has an API that sends out results of a particular semester of a certain course. Many other websites would show the results on their site by calling this university API. A hacker comes in and uses a code block to call the API in a loop. If the time interval is too small, then don't be surprised if you get a <span class="packt_screen">Server Busy/Server Unreachable</span> message. That is because, with a huge number of requests in a short span of time, the server becomes overloaded and runs out of resources.</p>
<p>That is where imposing limitations on the API not to allow more requests from the same source in a particular time interval comes into the picture. For example, if any consumer accesses our API, we will not allow the request if the consumer has already requested it before in the last 10 seconds or so.</p>
<p><span>First,</span> <span>l</span>et's design the database for our app before exploring other concepts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Database design</h1>
                </header>
            
            <article>
                
<p><span>We will</span> <span>d</span>efinitely have a <em>Customers</em> table. We will store customer information in that table and use the primary key of this table as a reference in other tables, such as <em>Orders</em> and <em>Cart</em>.</p>
<p>The <span class="packt_screen">Customers</span> table can be designed as follows. You can find the database script, named <kbd>FlixOneStore.sql</kbd>, with this book:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/13d529d2-2429-4ed7-9d63-2bd5da584ac6.png" style="width:21.33em;height:17.83em;"/></div>
<p>CRUD operations will be performed on these tables from the API. Let's start by doing some operations on this table from the API. More precisely, we are talking about the customer registration and login process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User registration</h1>
                </header>
            
            <article>
                
<p>Let's get the models into the API <span>first</span> <span>so that we can create an object and save data in the database. We will use</span> <strong>Entity Framework Core</strong> <span>(</span><strong>EF Core</strong><span>) version 2.0.2 for this.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up EF with the API</h1>
                </header>
            
            <article>
                
<p>To use EF Core, the following package is required, which can be downloaded and installed from <span class="packt_screen">NuGet Package Manager</span> inside <span class="packt_screen">Tools</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0d8b9441-f7c0-4226-867d-0abc0b97fc64.png" style="width:45.92em;height:4.08em;"/></div>
<p>Additionally, we need another package named <span class="packt_screen">Microsoft.EntityFrameworkCore.Tools</span><span>. This will help us with creating model classes from the database:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7be0ab79-59d9-415f-8011-7c78d69294ca.png" style="width:54.00em;height:4.58em;"/></div>
<p>Now, we arrive at the point where we need model classes according to the database tables. The following powershell command can be executed inside the package manager console to create the model class for the <em>Customers</em> table:</p>
<pre><strong>Scaffold-DbContext "Server=.;Database=FlixOneStore;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -Tables Customers </strong></pre>
<p>We have provided the connection string in the command so that it connects to our database.</p>
<p>The following are two important parts of the command we just explored:</p>
<ul>
<li><kbd>-OutputDir Models</kbd>: This defines the folder in which the model class will be placed.</li>
<li><kbd>-Tables Customers</kbd>: This defines the table that will be extracted as the model class. We will be dealing with <em>Customers</em> for now.</li>
</ul>
<p>After execution, you will see two files, <kbd>Customers.cs</kbd> and <kbd>FixOneStoreContext.cs</kbd>, inside the <kbd>Models</kbd> folder. The <kbd>Customers.cs</kbd> file will be something like the following:</p>
<pre>using System;<br/>namespace DemoECommerceApp.Models<br/>{<br/>  public partial class Customers<br/>  {<br/>    public Guid Id { get; set; }<br/>    public string Gender { get; set; }<br/>    public string Firstname { get; set; }<br/>    public string Lastname { get; set; }<br/>    public DateTime Dob { get; set; }<br/>    public string Email { get; set; }<br/>    public Guid? Mainaddressid { get; set; }<br/>    public string Telephone { get; set; }<br/>    public string Fax { get; set; }</pre>
<pre>    public string Password { get; set; }<br/>    public bool Newsletteropted { get; set; }<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring DbContext</h1>
                </header>
            
            <article>
                
<p>The <kbd>context</kbd> class can be found in the same folder that has the <kbd>OnConfiguring</kbd> and <kbd>OnModelCreating</kbd> methods with a property for <em>Customers</em>.</p>
<p>The following code block shows the <kbd>FlixOneStoreContext</kbd> class:</p>
<pre>using Microsoft.EntityFrameworkCore;<br/>namespace DemoECommerceApp.Models<br/>{<br/>  public partial class FlixOneStoreContext : DbContext<br/>  {<br/>    public virtual DbSet&lt;Customers&gt; Customers { get; set; }<br/>    public FlixOneStoreContext(DbContextOptions&lt;<br/>    FlixOneStoreContext&gt; options)<br/>    : base(options)<br/>    { }<br/>    // Code is commented below, because we are applying<br/>    dependency injection inside startup.<br/>    // protected override void OnConfiguring(<br/>    DbContextOptionsBuilder optionsBuilder)<br/>    // {<br/>    // if (!optionsBuilder.IsConfigured)<br/>    // {<br/>    //#warning To protect potentially sensitive information<br/>    in your connection string, you should move it out of <br/>    source code. See http://go.microsoft.com/fwlink/?LinkId=723263 <br/>    for guidance on storing connection strings.<br/>    // optionsBuilder.UseSqlServer(@"Server=.;<br/>    Database=FlixOneStore;Trusted_Connection=True;");<br/>    // }<br/>    // }<br/>    protected override void OnModelCreating(ModelBuilder modelBuilder)<br/>    {<br/>      modelBuilder.Entity&lt;Customers&gt;(entity =&gt;<br/>      {<br/>        entity.Property(e =&gt; e.Id)<br/>        .HasColumnName("id")<br/>        .ValueGeneratedNever();<br/>        entity.Property(e =&gt; e.Dob)<br/>        .HasColumnName("dob")<br/>        .HasColumnType("datetime");<br/>        entity.Property(e =&gt; e.Email)<br/>        .IsRequired()<br/>        .HasColumnName("email")<br/>        .HasMaxLength(110);<br/>        entity.Property(e =&gt; e.Fax)<br/>        .IsRequired()<br/>        .HasColumnName("fax")<br/>        .HasMaxLength(50);<br/>        entity.Property(e =&gt; e.Firstname)<br/>        .IsRequired()<br/>        .HasColumnName("firstname")<br/>        .HasMaxLength(50);<br/>        entity.Property(e =&gt; e.Gender)<br/>        .IsRequired()<br/>        .HasColumnName("gender")<br/>        .HasColumnType("char(1)");<br/>        entity.Property(e =&gt; e.Lastname)<br/>        .IsRequired()<br/>        .HasColumnName("lastname")<br/>        .HasMaxLength(50);<br/>        entity.Property(e =&gt; e.Mainaddressid).HasColumnName<br/>        ("mainaddressid");<br/>        entity.Property(e =&gt; e.Newsletteropted).HasColumnName<br/>        ("newsletteropted");<br/>        entity.Property(e =&gt; e.Password)<br/>        .IsRequired()<br/>        .HasColumnName("password")<br/>        .HasMaxLength(50);<br/>        entity.Property(e =&gt; e.Telephone)<br/>        .IsRequired()<br/>        .HasColumnName("telephone")<br/>        .HasMaxLength(50);<br/>      });<br/>    }<br/>  }<br/>}</pre>
<p>Did you notice that I have commented the <kbd>OnConfiguring</kbd> method and added a constructor so that we can inject dependencies from startup to initialize the context with a connection string? Let's do that.</p>
<p>So, inside the <kbd>ConfigureServices</kbd> startup, we will add the context to the services collection using the connection string:</p>
<pre>public void ConfigureServices(IServiceCollection services)<br/>{<br/>  services.AddSingleton&lt;IProductService, ProductService&gt;();<br/>  services.AddMvc();<br/>  var connection = @"Server=.;Database=FlixOneStore;<br/>  Trusted_Connection=True";<br/>  services.AddDbContext&lt;FlixOneStoreContext&gt;(<br/>  options =&gt; options.UseSqlServer(connection));<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating the controller</h1>
                </header>
            
            <article>
                
<p>The next step is to add the controller. To do so, refer to the following steps:</p>
<ol>
<li>Right-click on the <kbd>Controller</kbd> folder, then click on <span class="packt_screen">Add</span>, followed by <span class="packt_screen">Controller</span>. You will end up on a modal where you will see options to create different types of controllers:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d624fe8b-4518-4322-b5b3-519aa20bad1a.png" style="width:50.08em;height:28.17em;"/></div>
<ol start="2">
<li>Select <span class="packt_screen">API Controller with actions, using Entity Framework</span> and click on the <span class="packt_screen">Add</span> button. The following screenshot shows what happens next:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dea4c3e2-3769-40b1-8ac8-c9c3224528b9.png" style="width:39.92em;height:14.08em;"/></div>
<ol start="3">
<li>Click on <span class="packt_screen">Add</span>. <em>Voila!</em> It did all that hard work and created a fully fledged controller using EF Core with actions using all major HTTP verbs. The following code block is a small snapshot of the controller with the <kbd>GET</kbd> methods only. I have removed other methods to save space:</li>
</ol>
<pre style="padding-left: 60px">// Removed usings for brevity.<br/>namespace DemoECommerceApp.Controllers<br/>{<br/>  [Produces("application/json")]<br/>  [Route("api/Customers")]<br/>  public class CustomersController : Controller<br/>  {<br/>    private readonly FlixOneStoreContext _context;<br/>    public CustomersController(FlixOneStoreContext context)<br/>    {<br/>      _context = context;<br/>    }<br/>    // GET: api/Customers<br/>    [HttpGet]<br/>    public IEnumerable&lt;Customers&gt; GetCustomers()<br/>    {<br/>      return _context.Customers;<br/>    }<br/>    // GET: api/Customers/5<br/>    [HttpGet("{id}")]<br/>    public async Task&lt;IActionResult&gt; GetCustomers<br/>    ([FromRoute] Guid id)<br/>    {<br/>      if (!ModelState.IsValid)<br/>      {<br/>        return BadRequest(ModelState);<br/>      }<br/>      var customers = await <br/>      _context.Customers.SingleOrDefaultAsync(m =&gt; m.Id == id);<br/>      if (customers == null)<br/>      {<br/>        return NotFound();<br/>      }<br/>      return Ok(customers);<br/>    }<br/><br/>    // You will also find PUT POST, DELETE methods.<br/>    // These action methods are removed to save space.<br/>  }<br/>}</pre>
<p>Some points to note here:</p>
<ul>
<li>Notice how <kbd>FlixOneStoreContext</kbd> is initialized here by injecting it into the constructor. Further more, it will be used for database-related operations inside all actions:</li>
</ul>
<pre style="padding-left: 60px">private readonly FlixOneStoreContext _context;<br/>public CustomersController(FlixOneStoreContext context)<br/>{<br/>  _context = context;<br/>}</pre>
<ul>
<li>The next thing to focus on is the methods used to return the results from the actions. See how <kbd>BadRequest()</kbd>, <kbd>NotFound()</kbd>, <kbd>Ok()</kbd>, and <kbd>NoContent()</kbd> are used to return proper HTTP response codes that can be easily understood by clients. We will see what codes they return in a while when we call these actions to perform real tasks.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calling the API from a page to register the customer</h1>
                </header>
            
            <article>
                
<p>To simplify things, I have designed a simple HTML page with controls for a customer record, as follows. We will input data and try to call the API in order to save the record:</p>
<pre>&lt;div class="container"&gt;<br/>  &lt;h2&gt;Register for FlixOneStore&lt;/h2&gt;<br/>  &lt;div class="form-horizontal"&gt;<br/>    &lt;div class="form-group"&gt;<br/>      &lt;label class="control-label col-sm-2" for=<br/>      "txtFirstName"&gt;First Name:&lt;/label&gt;<br/>      &lt;div class="col-sm-3"&gt;<br/>        &lt;input type="text" class="form-control" id=<br/>        "txtFirstName" placeholder=<br/>        "Enter first name" name="firstname"&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="form-group"&gt;<br/>      &lt;label class="control-label col-sm-2" for=<br/>      "txtLastName"&gt;Last Name:&lt;/label&gt;<br/>      &lt;div class="col-sm-3"&gt;<br/>        &lt;input type="text" class="form-control" id=<br/>        "txtLastName" placeholder=<br/>        "Enter last name" name="lastname"&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="form-group"&gt;<br/>      &lt;label class="control-label col-sm-2" for="txtEmail"&gt;<br/>      Email:&lt;/label&gt;<br/>      &lt;div class="col-sm-3"&gt;<br/>        &lt;input type="email" class="form-control" id=<br/>        "txtEmail" placeholder=<br/>        "Enter email" name="email"&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="form-group"&gt;<br/>      &lt;label class="control-label col-sm-2" for="gender"&gt;<br/>      Gender:&lt;/label&gt;<br/>      &lt;div class="col-sm-3"&gt;<br/>        &lt;label class="radio-inline"&gt;&lt;input type="radio" <br/>        value="M" name="gender"&gt;Male&lt;/label&gt;<br/>        &lt;lable class="radio-inline"&gt;&lt;input type="radio" <br/>        value="F" name="gender"&gt;Female&lt;/lable&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="form-group"&gt;<br/>      &lt;label class="control-label col-sm-2" for="txtDob"&gt;<br/>      Date of Birth:&lt;/label&gt;<br/>      &lt;div class="col-sm-3"&gt;<br/>        &lt;input type="date" class="form-control" id="txtDob" /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="form-group"&gt;<br/>      &lt;label class="control-label col-sm-2" for="txtMobile"&gt;<br/>      Mobile Number:&lt;/label&gt;<br/>      &lt;div class="col-sm-3"&gt;<br/>        &lt;input type="text" class="form-control" id="txtMobile"<br/>        placeholder=<br/>        "Enter mobile number" /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="form-group"&gt;<br/>      &lt;label class="control-label col-sm-2" for="txtFax"&gt;Fax:&lt;/label&gt;<br/>      &lt;div class="col-sm-3"&gt;<br/>        &lt;input type="text" class="form-control" id="txtFax"<br/>        placeholder="Enter fax" /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="form-group"&gt;<br/>      &lt;label class="control-label col-sm-2" for="txtPassword"&gt;<br/>      Password:&lt;/label&gt;<br/>      &lt;div class="col-sm-3"&gt;<br/>        &lt;input type="password" class="form-control" id=<br/>        "txtPassword" placeholder=<br/>        "Enter password" name="pwd"&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="form-group"&gt;<br/>      &lt;label class="control-label col-sm-2" for="txtConfirmPassword"&gt;<br/>      Confirm Password:&lt;/label&gt;<br/>      &lt;div class="col-sm-3"&gt;<br/>        &lt;input type="password" class="form-control"<br/>        id="txtConfirmPassword" placeholder=<br/>        "Enter password again" name="confirmpwd"&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="form-group"&gt;<br/>      &lt;div class="col-sm-offset-2 col-sm-10"&gt;<br/>        &lt;button type="button" class="btn btn-success"<br/>        id="btnRegister"&gt;Register&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</pre>
<p>I have used bootstrap and <em>jQuery</em> with my code. You can refer to the whole code in the attached files with the book or refer to <a href="https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core">https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core</a>.</p>
<p>Now comes the important part of the code, where we will call the API to store the customer record. Refer to the following code block:</p>
<pre>$(document).ready(function () {<br/>  $('#btnRegister').click(function () {<br/>    // Check password and confirm password.<br/>    var password = $('#txtPassword').val(),<br/>    confirmPassword = $('#txtConfirmPassword').val();<br/>    if (password !== confirmPassword) {<br/>      alert("Password and Confirm Password don't match!");<br/>      return;<br/>    }<br/><br/>    // Make a customer object.<br/>    var customer = {<br/>      "gender": $("input[name='gender']:checked").val(),<br/>      "firstname": $('#txtFirstName').val(),<br/>      "lastname": $('#txtLastName').val(),<br/>      "dob": $('#txtDob').val(),<br/>      "email": $('#txtEmail').val(),<br/>      "telephone": $('#txtMobile').val(),<br/>      "fax": $('#txtFax').val(),<br/>      "password": $('#txtPassword').val(),<br/>      "newsletteropted": false<br/>    };<br/><br/>    $.ajax({<br/>      <strong>url: 'http://localhost:57571/api/Customers',</strong><br/>      <strong>type: "POST",</strong><br/>      contentType: "application/json",<br/>      data: JSON.stringify(customer),<br/>      dataType: "json",<br/>      success: function (result) {<br/>        alert("A customer record created for: "<br/>        + result.firstname + " " + result.lastname);<br/>      },<br/>      error: function (err) {<br/>        alert(err.responseText);<br/>      }<br/>    });<br/>  });<br/>});</pre>
<p class="mce-root">Notice the <kbd>http://localhost:57571/api/Customers</kbd> URL and <kbd>POST</kbd> HTTP method. This eventually calls the <kbd>Post</kbd> method present in the API named <kbd>PostCustomers</kbd>. We will definitely have some uniqueness in the table, and in our case, I am taking email as unique for each record. That's why I need to modify the <kbd>action</kbd> method a little bit:</p>
<pre>// POST: api/Customers<br/>[HttpPost]<br/>public async Task&lt;IActionResult&gt; PostCustomers([FromBody] Customers customers)<br/>{<br/>  if (!ModelState.IsValid)<br/>  {<br/>    return BadRequest(ModelState);<br/>  }<br/>  <strong>// Unique mail id check.</strong><br/><strong>  if (_context.Customers.Any(x =&gt; x.Email == customers.Email))</strong><br/><strong>  {</strong><br/><strong>    ModelState.AddModelError("email", "User with mail id already<br/>    exists!");</strong><br/><strong>    return BadRequest(ModelState);</strong><br/><strong>  }</strong><br/>  _context.Customers.Add(customers);<br/>  try<br/>  {<br/>    await _context.SaveChangesAsync();<br/>  }<br/>  catch (DbUpdateException ex)<br/>  {<br/>    if (CustomersExists(customers.Id))<br/>    {<br/>      return new StatusCodeResult(StatusCodes.Status409Conflict);<br/>    }<br/>    else<br/>    {<br/>      throw;<br/>    }<br/>  }<br/>  return CreatedAtAction("GetCustomers", new { id = customers.Id },<br/>  customers);<br/>}</pre>
<p>I am returning <kbd>BadRequest()</kbd> by adding an error message for the model property email. We will see how this is shown on the browser shortly!</p>
<p>The following image captured from the browser shows you a successful <em>customer</em> creation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fdfb7a93-b70c-4ab5-9bc7-dcfaea41c97b.png" style="width:40.67em;height:28.33em;"/></div>
<p>A successful registration of a <em>customer</em> would look something like the preceding image, which shows us the success message in the alert as we have that inside the <kbd>success</kbd> method of the ajax call.</p>
<p>You can perform anything you want with the data received from the <kbd>action</kbd> method upon completion, as it returns the whole <kbd>customer</kbd> object. If you don't believe me, refer to the following screenshot from the source window of the debugger tool:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1f43ff98-4614-4c25-9636-e1bb5afc27d5.png" style="width:32.00em;height:23.75em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">The response to the POST request with the new Customer created inside the jQuery Ajax success method</div>
<p>So, who did this? Simple, the following return statement, which is inside the <kbd>POST</kbd> method, does all the magic:</p>
<pre>return CreatedAtAction("GetCustomers", new { id = customers.Id }, customers); </pre>
<p>This particular line does a couple of things:</p>
<ul>
<li>Sends <span class="packt_screen">Status Code: 201 Created</span> as the <kbd>POST</kbd> action successfully created the resource.</li>
<li>Sets a <span class="packt_screen">Location</span> header with the actual URL for the resource. If you remember RESTful characteristics, after the <kbd>POST</kbd> action, the server should send the URL of the resource. That is what it does.</li>
</ul>
<p>Let me show you the network tab of developer tools to prove my point. You can also use <em>Postman</em> and analyze it. The following screenshot shows you the response details:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0e5ced39-c692-4874-9748-3678ffcec256.png" style="width:36.75em;height:15.92em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The response received by a POST success request with Status Code and Location Header</div>
<p><kbd>Guid</kbd> is actually the <kbd>Customer ID</kbd> as we have defined it in the column type in database, and I am assigning the value to it inside the <kbd>Customer</kbd> model class constructor.</p>
<p>Now, if you copy this URL and open it in your browser or Postman, you will get the details of the customer, as the following screenshot shows you:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0361fdff-75a5-40c2-9b8e-831b0a2b1c3b.png" style="width:39.58em;height:22.58em;"/></div>
<p>Let's see a <kbd>BadRequest()</kbd> example with a mail ID that already exists. As the <kbd>taditdash@gmail.com</kbd> customer already exists, sending another request with the same email ID should send us an error message as a response. Let's have a look:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b705c323-5591-45a6-955c-0faf6bf710b4.png" style="width:43.17em;height:30.17em;"/></div>
<p class="mce-root">Remember, we added a line to check the email ID existence and added a <kbd>ModelState</kbd> error. That is in action now.</p>
<div class="packt_tip packt_infobox"><span>For simplicity of the demo in this book, I am just saving a plain text password. You should not do that in the actual project. Implementing proper encryption for a password is a must.</span></div>
<p>With this, I would end the registration process. However, there is scope to implement validation at the client side as well as at the server side. You can add attributes to the <kbd>Model</kbd> class properties to make it solid so that you don't get bad data from clients. Send a <kbd>BadRequest()</kbd> response when <kbd>ModelState</kbd> validation fails. Required email-format and password-comparison attributes can be added to the <kbd>Model</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CORS</h1>
                </header>
            
            <article>
                
<p>If you see the following error when you call the API action, then you need to enable <strong>Cross Origin Resource Sharing</strong> (<strong>CORS</strong>):</p>
<pre>Failed to load http://localhost:57571/api/Customers: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'null' is therefore not allowed access. The response had HTTP status code 404.</pre>
<p>To enable CORS for all origins, follow the steps shown ahead:</p>
<ol>
<li>Install the <kbd>Microsoft.AspNetCore.Cors</kbd> NuGet package:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/22cabbf2-3499-49f6-a794-536a0950a562.png" style="width:37.50em;height:5.83em;"/></div>
<ol start="2">
<li>Inside <kbd>Startup ConfigureServices</kbd>, add the following code to implement a policy for CORS that would allow all origins:</li>
</ol>
<pre style="padding-left: 60px">services.AddCors(options =&gt;<br/>{<br/>  options.AddPolicy("AllowAll",<br/>    builder =&gt;<br/>    {<br/>      builder<br/>      .AllowAnyOrigin()<br/>      .AllowAnyMethod()<br/>      .AllowAnyHeader();<br/>    });<br/>});</pre>
<ol start="3">
<li>Inside the <kbd>Configure</kbd> method, add the following line before <kbd>app.UseMvc();</kbd> (it's important):</li>
</ol>
<pre style="padding-left: 60px">app.UseCors("AllowAll");</pre>
<p>Now, it should work as expected. If you want to explore CORS more, visit <a href="https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-2.1">https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-2.1</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding basic authentication to our REST API</h1>
                </header>
            
            <article>
                
<p>Now that we registered the <em>customer</em>, we can move towards the authentication process. Authentication is to verify whether a <em>customer</em> is a valid user of our site or not. We already have their credentials with us since they registered using our registration form. When they try to access any resource from our site using those credentials, we will verify first and then allow.</p>
<p>Registration will be allowed for everyone and won't be authenticated. However, when a <em>customer</em> wants to <em>read their profile details</em> or <em>delete their account,</em> and so on, then we need authentication in place so that the data is returned to users who are actual trusted users of the application.</p>
<p>For <em>basic authentication</em>:</p>
<ul>
<li>We will get the <em>username</em>, which will be the <em>email ID</em> and <em>password</em> from the client while they request a resource. This will be sent with HTTP headers. We will see it when we design the client.</li>
<li>Then, that data will be verified from the database.</li>
<li>If found, the operation will be allowed, otherwise a <kbd>401 Unauthorized</kbd> response will be sent.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 1 – Adding the (authorize) attribute</h1>
                </header>
            
            <article>
                
<p>Let's restrict the action method that is returning the <em>customer</em> profile details, the <kbd>GET</kbd> method of <kbd>CustomersController</kbd> named <kbd>GetCustomers([FromRoute] Guid id)</kbd>.</p>
<p>We will verify the following two things when a <em>customer</em> is trying to access the profile:</p>
<ul>
<li>The request is coming from a trusted user of the application. Meaning, the request is coming from a <em>customer</em> having a valid <em>email</em> and <em>password</em>.</li>
<li>The customer can only access their profile. To check this, we will verify the <em>customer's</em> credentials (present in the request) with the requested <em>customer's</em> ID on the URL.</li>
</ul>
<p>Let's get started. Remember that our goal is to achieve the following:</p>
<pre>[Authorize(AuthenticationSchemes = "Basic")]<br/>public async Task&lt;IActionResult&gt; GetCustomers([FromRoute] Guid id)</pre>
<p>For now, we will focus our attention on this action method to understand the concept. You can see the <kbd>Authorize</kbd> attribute with an <kbd>AuthenticationScheme</kbd> defined as <kbd>Basic</kbd> here. That means we have to tell <span>the runtime</span> <span>what the</span> <em>basic authentication</em> <span>is so that it will execute that first before going into the action method.</span></p>
<p>If the authentication succeeds, the action method will be executed, otherwise a <span class="packt_screen">401 Unauthorized response</span> will be sent to the client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 2 – Designing BasicAuthenticationOptions and BasicAuthenticationHandler</h1>
                </header>
            
            <article>
                
<p>First of all, we need a class that would derive the <kbd>AuthenticationSchemeOptions</kbd> class present in <kbd>Microsoft.AspNetCore.Authentication</kbd>, as shown in the following code block:</p>
<pre>using Microsoft.AspNetCore.Authentication;<br/>namespace DemoECommerceApp.Security.Authentication<br/>{<br/>  public class BasicAuthenticationOptions : AuthenticationSchemeOptions {}<br/>}</pre>
<p>It is left blank for simplicity but can be loaded with different properties. We will not go into that.</p>
<p>Next, we need a handler for <em>basic authentication</em>, where we will have our actual logic:</p>
<pre>public class BasicAuthenticationHandler : AuthenticationHandler&lt;BasicAuthenticationOptions&gt;</pre>
<p>We can have its constructor-like following with an extra <kbd>DbContext</kbd> param as we will validate the <em>customer</em> details from the database:</p>
<pre>public BasicAuthenticationHandler(IOptionsMonitor&lt;BasicAuthenticationOptions&gt; options, ILoggerFactory logger, UrlEncoder encoder, ISystemClock clock, <strong>FlixOneStoreContext context</strong>)<br/>: base(options, logger, encoder, clock)</pre>
<pre>{<br/>  <strong>_context = context;</strong><br/>}</pre>
<p><kbd>AuthenticationHandler&lt;T&gt;</kbd> is an abstract class having properties and methods related to authentication especially. We will be overriding two methods, for now, <kbd>HandleAuthenticateAsync</kbd> and <kbd>HandleChallengeAsync</kbd>. <kbd>HandleAuthenticateAsync</kbd> will have actual logic to authenticate the customer and <kbd>HandleChallengeAsync</kbd> is used to deal with 401 challenge concerns, meaning whenever you decide that <em>customer</em> is not valid, codes can be written in this method to deal with that situation.</p>
<p>We are assuming that we will receive the email and password in the HTTP header called <kbd>Authorization</kbd> separated by a delimiter colon (<kbd>:</kbd>). The following is the code to extract the data from the header and validate whether it is correct or not:</p>
<pre>protected override Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()<br/>{<br/>  <strong>// 1. Verify if AuthorizationHeaderName present in the header.</strong><br/><strong>  // AuthorizationHeaderName is a string with value "Authorization".</strong><br/>  if (!Request.Headers.ContainsKey(AuthorizationHeaderName))<br/>  {<br/>    // Authorization header not found.<br/>    return Task.FromResult(AuthenticateResult.NoResult());<br/>  }<br/>  <strong>// 2. Verify if header is valid.</strong> <br/>  if (!AuthenticationHeaderValue.TryParse(Request.Headers<br/>  [AuthorizationHeaderName], out AuthenticationHeaderValue <br/>  headerValue))<br/>  {<br/>    // Authorization header is not valid.<br/>    return Task.FromResult(AuthenticateResult.NoResult());<br/>  }<br/>  <strong>// 3. Verify is scheme name is Basic. BasicSchemeName is a string</strong><br/><strong>  // with value 'Basic'.</strong> <br/>  if (!BasicSchemeName.Equals(headerValue.Scheme, StringComparison.<br/>  OrdinalIgnoreCase))<br/>  {<br/>    // Authorization header is not Basic.<br/>    return Task.FromResult(AuthenticateResult.NoResult());<br/>  }<br/>  <strong>// 4. Fetch email and password from header.</strong><br/><strong>  // If length is not 2, then authentication fails.</strong><br/>  byte[] headerValueBytes = Convert.FromBase64String(headerValue.<br/>  Parameter);<br/>  string emailPassword = Encoding.UTF8.GetString(headerValueBytes);<br/>  string[] parts = emailPassword.Split(':');<br/>  if (parts.Length != 2)<br/>  {<br/>    return Task.FromResult(AuthenticateResult.Fail("Invalid Basic<br/>    Authentication Header"));<br/>  }<br/>  string email = parts[0];<br/>  string password = parts[1];<br/>  <strong>// 5. Validate if email and password are correct.</strong><br/>  var customer = _context.Customers.SingleOrDefault(x =&gt; <br/>  x.Email == email &amp;&amp; x.Password == password);<br/>  if (customer == null)<br/>  {<br/>    return Task.FromResult(AuthenticateResult.Fail("Invalid email <br/>    and password."));<br/>  }<br/>  <strong>// 6. Create claims with email and id.</strong><br/>  var claims = new[]<br/>  { <br/>    new Claim(ClaimTypes.Name, email),<br/>    new Claim(ClaimTypes.NameIdentifier, customer.Id.ToString())<br/>  };<br/>  <strong>// 7. ClaimsIdentity creation with claims.</strong><br/>  var identity = new ClaimsIdentity(claims, Scheme.Name);<br/>  var principal = new ClaimsPrincipal(identity);<br/>  var ticket = new AuthenticationTicket(principal, Scheme.Name);<br/>  return Task.FromResult(AuthenticateResult.Success(ticket));<br/>}</pre>
<p>The code is very easy to understand. I have added the steps over code blocks. Basically, we are trying to validate the header and then process it to see whether they are correct. If correct, then create the <kbd>ClaimsIdentity</kbd> object, which can be further used in the application. We will do that in the next section. At each step, if validation fails, we send <kbd>AuthenticateResult.NoResult()</kbd> or <kbd>AuthenticateResult.Fail()</kbd>.</p>
<p>Let's work on attaching this authentication to our action method, using something like the following:</p>
<pre>[HttpGet("{id}")]<br/><strong>[Authorize(AuthenticationSchemes = "Basic")]</strong><br/>public async Task&lt;IActionResult&gt; GetCustomers([FromRoute] Guid id)<br/>{<br/>  if (!ModelState.IsValid)<br/>  {<br/>    return BadRequest(ModelState);<br/>  }<br/>  <strong>var ident = User.Identity as ClaimsIdentity;</strong><br/><strong>  var currentLoggeedInUserId = ident.Claims.FirstOrDefault<br/>  (c =&gt; c.Type == ClaimTypes.NameIdentifier)?.Value;</strong><br/><strong>  if (currentLoggeedInUserId != id.ToString())</strong><br/><strong>  {</strong><br/><strong>    // Not Authorized</strong><br/><strong>    return BadRequest("You are not authorized!");</strong><br/><strong>  }</strong><br/>  var customers = await _context.Customers.SingleOrDefaultAsync<br/>  (m =&gt; m.Id == id);<br/>  if (customers == null)<br/>  {<br/>    return NotFound();<br/>  }<br/>  return Ok(customers);<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 3 – Registering basic authentication at startup</h1>
                </header>
            
            <article>
                
<p>Looks like everything is set up, however, we have missed one step of registering this basic authentication in the startup. Otherwise, how could the <kbd>BasicAuthenticationHandler</kbd> handler be called? Have a look:</p>
<pre>services.AddAuthentication("Basic")<br/>.AddScheme&lt;BasicAuthenticationOptions, BasicAuthenticationHandler&gt;("Basic", null);<br/>services.AddTransient&lt;IAuthenticationHandler, BasicAuthenticationHandler&gt;();</pre>
<p>To test the API, you can design an HTML page to show the profile of the user by getting details from the API using the <kbd>Id</kbd>. You can use the <em>jQuery Ajax</em> call to the API and operate on the result received:</p>
<pre>$.ajax({<br/>  <strong>url: 'http://localhost:57571/api/Customers/<br/>  910D4C2F-B394-4578-8D9C-7CA3FD3266E2',</strong><br/>  type: "GET",<br/>  contentType: "application/json",<br/>  dataType: "json",<br/>  <strong>headers: { 'Authorization': 'Basic ' + btoa<br/>  (email + ':' + password)},</strong><br/>  success: function (result) {<br/>    // Work with result. Code removed for brevity.<br/>  },<br/>  error: function (err) <br/>  {<br/>    if (err.status == 401) <br/>    {<br/>      alert("Either wrong email and password or you are <br/>      not authorized to access the data!")<br/>    }<br/>  }<br/>});</pre>
<p>Notice the header part where we have the <kbd>Authorization</kbd> header mentioned with <kbd>email</kbd> and <kbd>password</kbd> separated by a colon (<kbd>:</kbd>) and passed to the <kbd>btoa</kbd> method, which is responsible for Base64 encryption. After you get the result, you can do <em>n</em> number of things. The following screenshot shows it on the page using some bootstrap designing:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3c735c15-2fd7-4ca7-b798-4622722d9f87.png" style="width:35.17em;height:34.75em;"/></div>
<p>Now, there is an important code block that should be included with the previous handler code. That is another <kbd>HandleChallengeAsync</kbd> method that should be overridden. The purpose of this method is to handle the situation when the authentication fails.</p>
<p>We will just send one header with the response, named <kbd>WWW-Authenticate</kbd>, whose value can be set with a <kbd>realm</kbd>. Have a look at the code first and then I will explain:</p>
<pre>protected override async Task HandleChallengeAsync(AuthenticationProperties properties)<br/>{<br/>  Response.Headers["WWW-Authenticate"] = $"Basic <br/>  realm=\"http://localhost:57571\", charset=\"UTF-8\"";<br/>  await base.HandleChallengeAsync(properties);<br/>}</pre>
<div class="packt_infobox">If a client tries to access a restricted resource or a resource that requires authentication, it's the server's responsibility to inform the client about the authentication type and related information. The <kbd>WWW-Authenticate</kbd> HTTP response header is set by the server that defines the authentication method that should be used to gain access to the restricted resource requested.</div>
<p class="mce-root">So, it's obvious that the <kbd>WWW-Authenticate</kbd> header is sent along with a <span class="packt_screen">401 Unauthorized</span> response. The string contains three things: <em>Authentication Type</em>, <em>Realm</em>, and <em>Charset</em>. The realm is the domain or area where the authentication will be valid.</p>
<p class="mce-root">In our case, the scheme is <kbd>Basic</kbd>, Realm is <kbd>http://localhost:57571</kbd>, and Charset is <kbd>UTF-8</kbd>. Therefore, if the client provides the basic authentication params as <kbd>Username</kbd> and <kbd>Password</kbd>, those will be valid in the <kbd>localhost:57571</kbd> domain.</p>
<p class="mce-root">That is what it signifies. So, just remove the header assigning a code or comment it out to test this. The following is the screenshot from the <span class="packt_screen">Network</span> tab of the developer tool in Chrome:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/51293f33-d7e5-4bb1-8877-8d78738f0569.png" style="width:39.17em;height:17.50em;"/></div>
<p class="mce-root">Have a look at the following screenshot of an alert message, which we have inside the error method of the Ajax call. This happens when the API action is called without any credentials:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/066f2093-32e1-4cb7-a809-90ec7d3b7324.png" style="width:28.92em;height:9.25em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding OAuth 2.0 authentication to our service</h1>
                </header>
            
            <article>
                
<p>OAuth is an open standard used by APIs to control access to the resources by clients, such as websites, desktop applications, or even other APIs. However, the API implementing OAuth can provide user information without sharing the password with third-party apps.</p>
<p>You must have seen websites where they allow logins using different services, such as Facebook, Twitter, or Google, saying something such as (for Facebook) <span class="packt_screen">Login with Facebook</span>. That means Facebook has an OAuth server that would validate your app by a certain identity that you have provided to Facebook earlier, and give you an access token that would have some validity. Using that token, you can read the required user's profile.</p>
<p>The following is some basic OAuth2.0 terminology:</p>
<ul>
<li class="mce-root"><strong>Resource:</strong> We have already defined this in previous chapters. Resources are the things that we need to protect. That may be any information related to our system.</li>
<li class="mce-root"><strong>Resource server:</strong> This is the server that would protect the resource, mostly the API that we have designed to access our eCommerce database.</li>
<li class="mce-root"><strong>Resource owner:</strong> The person who would grant us access to a particular resource. Mostly the users are the owners, and as you have seen when you click on <span class="packt_screen">Login with Facebook</span>, it will ask for your login and consent.</li>
<li class="mce-root"><strong>Client:</strong> The app that wants our resource access. In our case, it is the browser that is trying to access the resources when <em>jQuery</em> codes are executed on the HTML pages we designed.</li>
<li class="mce-root"><strong>Access token:</strong> This is actually the pillar of this architecture. The OAuth server that we will design should provide a token using the credentials of the user for subsequent access to our resources, as we know OAuth standard tells us not provide passwords to clients.</li>
<li class="mce-root"><strong>Bearer token:</strong> This is a particular type of access token that allows anyone to use the token easily, meaning, in order to use the token for resource access, a client doesn't need a cryptographic key or other secret keys. As this is less secure than other types of tokens, bearer tokens should only be used over HTTPs and should expire in a short amount of time.</li>
<li class="mce-root"><strong>Authorization server:</strong> This is the server providing the access token to the client.</li>
</ul>
<p>Let's start adding OAuth to our Web API. We are going to use <span class="packt_screen">IdentityServer4</span>, which is a free, open source OpenID Connect and OAuth 2.0 framework for ASP.NET Core. The project can be found here: <a href="https://github.com/IdentityServer">https://github.com/IdentityServer</a>.</p>
<p>IdentityServer (<a href="http://identityserver.io/">http://identityserver.io/</a>) is based on OWIN/Katana, but to our knowledge, it is distributed and available as a NuGet package. In order to start on IdentityServer, install the following two NuGet Packages:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0c04f874-1ab5-4675-a2d3-4c06a25d577a.png" style="width:46.00em;height:9.50em;"/></div>
<div class="packt_infobox">The <em>authorization server</em> in a production scenario is ideally isolated from the main web API. But for this book, we will directly put that in the same Web API project for simplicity. <span>We are not using the default ASP.NET Core Identity. We will be using our own set of tables. For instance, we will use our</span> <em>customer</em> <span>table details for verification.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 1 – Designing the Config class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Config</kbd> class holds important details of the authorization server, such as <em>Resources</em>, <em>Clients</em>, and <em>Users</em>. These details are used while generating the token. Let's design it:</p>
<pre>public class Config<br/>{<br/>  public static IEnumerable&lt;ApiResource&gt; GetApiResources()<br/>  {<br/>    return new List&lt;ApiResource&gt;<br/>    {<br/>      new ApiResource<br/>      (<br/>        "FlixOneStore.ReadAccess",<br/>        "FlixOneStore API", <br/>         new List&lt;string&gt; <br/>         {<br/>           JwtClaimTypes.Id,<br/>           JwtClaimTypes.Email,<br/>           JwtClaimTypes.Name,<br/>           JwtClaimTypes.GivenName,<br/>           JwtClaimTypes.FamilyName<br/>        }<br/>      ),<br/><br/>      new ApiResource("FlixOneStore.FullAccess", "FlixOneStore API")<br/>    }; <br/>  }<br/>}</pre>
<p><kbd>ApiResource</kbd> is used to declare different scopes and claims for the API. For a simple case, an API might have one simple resource structure where it would give access to all clients. However, in a typical scenario, clients can be restricted to access different parts of the API. While declaring the clients, we will use these resources in order to configure their scope and access rights. <kbd>ReadAccess</kbd> and <kbd>FullAccess</kbd> are two different resource types that can be used with clients to give read and full access, respectively.</p>
<p>Basically, the methods that we are designing now will be called on <kbd>Startup</kbd>. Here, <kbd>GetApiResources</kbd> is actually creating two types of resource with different settings. The first one is what we will be dealing with for the moment. We have named it <kbd>FlixOneStore.ReadAccess</kbd>. You can see a list of strings with <kbd>Id</kbd>, <kbd>Name</kbd>, and so on, these are the details of the customer that will be generated with the token and passed to the client.</p>
<p>Let's add details for a client from where we will consume the authorization server:</p>
<pre>public static IEnumerable&lt;Client&gt; GetClients()<br/>{<br/>  return new[]<br/>  {<br/>    new Client<br/>    {<br/>      Enabled = true,<br/>      ClientName = "HTML Page Client",<br/>      ClientId = "<strong>htmlClient</strong>",<br/>      AllowedGrantTypes = <strong>GrantTypes.ResourceOwnerPassword</strong>,<br/><br/>      ClientSecrets =<br/>      {<br/>        new Secret("<strong>secretpassword</strong>".Sha256())<br/>      },<br/><br/>      AllowedScopes = { "FlixOneStore.ReadAccess" }<br/>    }<br/>  };<br/>}</pre>
<p>You can add a number of clients as per your needs. You can set <em>client id</em>, <em>client secret,</em> and <em>grant types</em> according to OAuth standards in this method. Notice the secret password is set as <kbd>secretpassword</kbd>. You can set any string here; it can be a <kbd>Guid</kbd>. Here, <kbd>GrantType.ResourceOwnerPassword</kbd> defines the way we will validate the incoming request to generate tokens.</p>
<p>It says to the <em>Authorization Server</em>, "Hey look for <kbd>username</kbd> and <kbd>password</kbd> inside the request body." There are other types of Grant available. You can explore more on the official documentation link.</p>
<p>You might have a question now! What are we going to do with <kbd>username</kbd> and <kbd>password</kbd>? Of course, we will validate them, but with what? The answer is the <kbd>Email</kbd> and <kbd>Password</kbd> fields from the <kbd>Customers</kbd> table. We have not done anything related to connecting <em>Authorization Server</em> with the <em>Customers</em> table. That is what we will do next. But before that, let's register these settings at <kbd>Startup</kbd>.</p>
<div class="packt_infobox">Just to make sure we are on the same page, we landed at the point where we are trying to generate a token from the Authorization Server in order to access our API.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 2 – Registering Config at startup</h1>
                </header>
            
            <article>
                
<p>For registration, the following is what we have to do inside the <kbd>ConfigureServices</kbd> method:</p>
<pre>services.AddIdentityServer()<br/>        .AddInMemoryApiResources(Config.GetApiResources())<br/>        .AddInMemoryClients(Config.GetClients())<br/>        .AddProfileService&lt;<strong>ProfileService</strong>&gt;()<br/>        .AddDeveloperSigningCredential();</pre>
<p>We are loading all those config settings here, such as <em>Resources</em> and <em>Clients</em>, by calling the methods we designed. <kbd>AddDeveloperSigningCredential</kbd> adds a temporary key at the startup time, used only on the development environment when we don't have any certificate to apply for Authorization. You would add proper certificate details for actual use.</p>
<p>Mark <kbd>ProfileService</kbd> here. This is what I was talking about in the previous section, which will be used to validate the user credentials against the database. We will look at it in a little while. First, let's test our API, assuming that the Authorization Server is ready with <kbd>ProfileService</kbd> set up.</p>
<p>Now coming to the API, we need to add <kbd>AuthenticationScheme</kbd> at the start of the API to declare what Authentication we will be using. For that, add the following code:</p>
<pre>services.AddAuthentication(options =&gt;<br/>{<br/>  options.DefaultAuthenticateScheme = <br/>  JwtBearerDefaults.AuthenticationScheme;<br/>  options.DefaultChallengeScheme = <br/>  JwtBearerDefaults.AuthenticationScheme;<br/>})<br/>.AddJwtBearer(o =&gt;<br/>{<br/>  o.Authority = "http://localhost:57571";<br/>  o.Audience = "FlixOneStore.ReadAccess";<br/>  o.RequireHttpsMetadata = false;<br/>});</pre>
<p><kbd>JwtBearerDefaults.AuthenticationScheme</kbd> is actually a string constant with the <strong>Bearer</strong> value. <strong>Bearer authentication</strong> is also known as <strong>token authentication</strong>. That means our clients need to send a token in order to access the API's resources. And to get the token, they need to call our <em>authorization server</em>, available at <kbd>/connect/token</kbd>.</p>
<p>Notice we have <kbd>Audience</kbd> set as <kbd>FlixOneStore.ReadAccess</kbd>, which we have specified for the clients inside config. Simply put, we are setting up the bearer type of authentication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 3 – Adding the [Authorize] attribute</h1>
                </header>
            
            <article>
                
<p>The next thing is to add the <kbd>[Authorize]</kbd> attribute to the API controller action. Let's test this with the <kbd>GetCustomers(id)</kbd> method:</p>
<pre>// GET: api/Customers/5<br/>[HttpGet("{id}")]<br/>[Authorize]<br/>public async Task&lt;IActionResult&gt; GetCustomers([FromRoute] Guid id)</pre>
<p>Calling it from the <em>Postman</em> yields the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e2baca5b-b2bc-411e-8929-a8c66cf2101b.png"/></div>
<p>So, our request is not authorized anymore. We got a reply that we need to send a token in order to access the resource. Let's get the token, then.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 4 – Getting the token</h1>
                </header>
            
            <article>
                
<p>In order to get the token, we need to call the authorization server sitting at <kbd>/connect/token</kbd>.</p>
<p>The following is a screen captured from <em>Postman</em> where a <kbd>POST</kbd> request is performed on the <kbd>http://localhost:57571/connect/token</kbd> URL with a body containing all the required parameters in order to authenticate the client. These are the details that we registered inside the <kbd>GetClients()</kbd> method in <em>Step 1</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/38096c2e-0803-4c37-a14f-963cb390af21.png"/></div>
<p>Oops! It's a bad request. That is because we passed the wrong secret password for the client. If you remember, we set it as <kbd>secretpassword</kbd>, but passed it as <kbd>secret</kbd>. That's why it got rejected.</p>
<p>Some important things to note here. To get the token:</p>
<ul>
<li>We need to send a <kbd>POST</kbd> request to the <kbd>/connect/token</kbd> URL. As we have implemented the server in the same app, the domain is the same here as the API.</li>
<li>We need to have a <span><kbd>Content-Type</kbd> header set as <kbd>application/x-www-form-urlencoded</kbd> (which is actually in a different tab on the screenshot).</span></li>
<li>In the body of the request, we added all the required parameters of OAuth according to standards and they match exactly what we had in the configuration class.</li>
</ul>
<p>When we send everything as required correctly, we will receive a token, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2981f005-71a2-4b96-8ef9-247082327d9c.png"/></div>
<p>We received the bearer token response according to OAuth specifications. They are <kbd>access_token</kbd>, <kbd>expires_in</kbd>, and <kbd>token_type</kbd>. The <kbd>expires_in</kbd> param is set to 3,600 by default for the access token, which is in seconds, meaning 1 hour. After 1 hour, this token won't work anymore. Therefore, before this token expires, let's quickly call our API with it and see whether that works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 5 – Calling the API with the access token</h1>
                </header>
            
            <article>
                
<p>Have a look at the following picture, which shows you the call to the API using the token we just received:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4afb75d0-4098-4983-ba63-2e71e983633c.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Calling the API endpoint with the token in the authorization header</div>
<p>Voila! That worked. I just copied the token I got and added in the <kbd>Bearer [Access Token]</kbd> format to the authorization header and sent the request. Everything is perfect now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Step 6 – Adding the ProfileService class</h1>
                </header>
            
            <article>
                
<p>While we explored all this, I left out one part that I want to explain now. If you see the body of the request while we fetch the access token, it is something like:</p>
<pre>grant_type=password&amp;scope=FlixOneStore.ReadAccess&amp;client_id=htmlClient&amp;client_secret=secretpassword&amp;<strong>username=taditdash@gmail.com&amp;password=12345</strong></pre>
<p>Focus on the <kbd>username</kbd> and <kbd>password</kbd> parameters. They are here for a reason. While generating the token, these are getting validated and yes, we are validating with the database directly. Let's see how.</p>
<p><kbd>IdentityServer4</kbd> provides two interfaces for this purpose, named <kbd>IProfileService</kbd> and <kbd>IResourceOwnerPasswordValidator</kbd>.</p>
<p>The following is a <kbd>ResourceOwnerPasswordValidator</kbd> class implementing the interface. Remember, we set <kbd>AllowedGrantTypes = GrantTypes.ResourceOwnerPassword</kbd> inside the config for the client. That's why we are doing this to validate the user's credentials:</p>
<pre>public class ResourceOwnerPasswordValidator : IResourceOwnerPasswordValidator<br/>{<br/>  private readonly FlixOneStoreContext _context;<br/>  public ResourceOwnerPasswordValidator(FlixOneStoreContext context)<br/>  {<br/>    _context = context;<br/>  }<br/>  public async Task <strong>ValidateAsync</strong>(ResourceOwnerPassword<br/>  ValidationContext context)<br/>  {<br/>    try<br/>    {<br/>      var customer = await _context.Customers.SingleOrDefaultAsync<br/>      (m =&gt; m.Email == context.UserName);<br/>      if (customer != null)<br/>      {<br/>        if (customer.Password == context.Password)<br/>        {<br/>          <strong>context.Result = new GrantValidationResult(</strong><br/><strong>            subject: customer.Id.ToString(),</strong><br/><strong>            authenticationMethod: "database",</strong><br/><strong>            claims: GetUserClaims(customer));</strong><br/>          return;<br/>        }<br/>        context.Result = new GrantValidationResult<br/>        (TokenRequestErrors.InvalidGrant,<br/>        "Incorrect password");<br/>        return;<br/>      }<br/>      context.Result = new GrantValidationResult<br/>      (TokenRequestErrors.InvalidGrant,<br/>      "User does not exist.");<br/>      return;<br/>    }<br/>    catch (Exception ex)<br/>    {<br/>      context.Result = new GrantValidationResult<br/>      (TokenRequestErrors.InvalidGrant,<br/>      "Invalid username or password");<br/>    }<br/>  }<br/>  public static Claim[] GetUserClaims(Customers customer)<br/>  {<br/>    return new Claim[]<br/>    {<br/>      new Claim(JwtClaimTypes.Id, customer.Id.ToString() ?? ""),<br/>      new Claim(JwtClaimTypes.Name, (<br/>      !string.IsNullOrEmpty(customer.Firstname) &amp;&amp;  <br/>      !string.IsNullOrEmpty(customer.Lastname))<br/>      ? (customer.Firstname + " " + customer.Lastname)<br/>      : String.Empty),<br/>      new Claim(JwtClaimTypes.GivenName, customer.Firstname ?? <br/>      string.Empty),<br/>      new Claim(JwtClaimTypes.FamilyName, customer.Lastname ??       <br/>      string.Empty),<br/>      new Claim(JwtClaimTypes.Email, customer.Email ?? string.Empty)<br/>    };<br/>  }<br/>}</pre>
<p>Mark the bold lines on the preceding code. <kbd>ValidateAsync</kbd> is the method that is giving us the details from the request, and then it is verified with the database value. If matched, we create a <kbd>GrantValidationResult</kbd> object with <kbd>subject</kbd>, <kbd>authenticationMethod</kbd>, and <kbd>claims</kbd>.</p>
<p><kbd>GetUserClaims</kbd> helps us build all the claims. We will see the actual use of these claims in a moment.</p>
<div class="packt_infobox">We added a number of claims inside config with a list of <kbd>ApiResources</kbd>, such as <kbd>Id</kbd>, <kbd>Name</kbd>, <kbd>Email</kbd>, <kbd>GivenName</kbd>, and <kbd>FamilyName</kbd>. That means the server can return these details about the <em>customer</em>.</div>
<p>Let's jump to <kbd>ProfileService</kbd>:</p>
<pre>public class ProfileService : IProfileService<br/>{<br/>  private readonly FlixOneStoreContext _context;<br/>  public ProfileService(FlixOneStoreContext context)<br/>  {<br/>    _context = context;<br/>  }<br/>  public async Task GetProfileDataAsync(ProfileDataRequestContext <br/>  profileContext)<br/>  {<br/>    if (!string.IsNullOrEmpty(profileContext.Subject.Identity.Name))<br/>    {<br/>      var customer = await _context.Customers<br/>      .SingleOrDefaultAsync(m =&gt; m.Email == <br/>      profileContext.Subject.Identity.Name);<br/>      if (customer != null)<br/>      {<br/>        <strong>var claims = ResourceOwnerPasswordValidator.<br/>        GetUserClaims(customer);</strong><br/><strong>        profileContext.IssuedClaims = claims.Where(</strong><strong>x =&gt; <br/>        profileContext.RequestedClaimTypes.Contains(x.Type)).ToList();</strong><br/>      }<br/>    }<br/>    else<br/>    {<br/>      var customerId = profileContext.Subject.Claims.FirstOrDefault<br/>      (x =&gt; x.Type == "sub");<br/>      if (!string.IsNullOrEmpty(customerId.Value))<br/>      {<br/>        var customer = await _context.Customers<br/>        .SingleOrDefaultAsync(u =&gt; u.Id == <br/>        Guid.Parse(customerId.Value));<br/>        if (customer != null)<br/>        {<br/>          <strong>var claims = <br/>          ResourceOwnerPasswordValidator.GetUserClaims(customer);</strong><br/><strong>          profileContext.IssuedClaims = claims.Where(x =&gt; <br/>          profileContext.RequestedClaimTypes.Contains(x.Type)).<br/>          ToList();</strong><br/>        }<br/>      }<br/>    } <br/>  }<br/>}</pre>
<p>A <kbd>ProfileDataRequestContext</kbd> object is populated with all the claims we added in <kbd>ApiResource</kbd>. Refer to the following screenshot of the list of claims requested while debugging:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/06d0514e-22cd-44d7-9392-f6c45c63eed5.png"/></div>
<p>That means we need to fill all these details from the <em>customer</em> record that we did and add that to <kbd>IssuedClaims</kbd>.</p>
<p>Hold on a second! Why are we doing this? Because our config told us to provide this information. But do we need to fill in all that requested information? No. Not necessarily. We can issue as many, or as few, claims as we wish to.</p>
<p>The big question now! Where do we find this information? We know that after all these authorization setups, we get an encrypted token string. Did you guess? Yes, all that information actually resides inside the token itself. Don't trust me, trust the following screenshot. As the token is a JWT token, you can use <a href="https://jwt.io/">https://jwt.io/</a> to decode it and see what is inside:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d1e5db9b-fc37-4fe5-9f32-13cecc86ce8b.png" style="width:20.25em;height:24.75em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client-based API-consumption architecture</h1>
                </header>
            
            <article>
                
<p>We have discussed <em>RESTful Services, Web APIs</em>, as well as how to register, authenticate, and authorize a user. Moreover, we did focus a little on the consumption aspect of the service. Services are designed not only to test on <em>Postman</em> but actually for consumption by different types of application (desktop, web, mobile, smart watches, and IoT apps).</p>
<p>While most modern apps are based on MVC-based architecture, there is a certain need to consume web services inside the controllers of those apps. Basically, I need to find a way to call the services from my controller without any hassle.</p>
<p>For that to happen, I can't call <em>Postman</em> or any other third-party tool. What I need is a client or component that can interact with the <em>RESTful Web API</em> for me. I just need to tell that client that I need the <em>Customer</em> details by passing the <kbd>id</kbd> or some identifier and the rest is taken care of by the client, from calling the API, passing the value to it, and getting the response. The response eventually comes back to the controller, which I can then operate on.</p>
<p>We will explore how to build a REST client with simple, quick, and easy steps in <a href="9fcac4d2-710a-48a2-98be-ed0034525cee.xhtml">Chapter 10</a>, <em>Building a Web Client (Consuming Web Services)</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Registration is a very common, yet very important part of an application. We handled the registration of <em>Customers</em> through the API. Before that, we learned to bootstrap the API controller actions and model classes with EF Core. While we were doing all this, we landed on CORS and learned how to handle that, too.</p>
<p>Gradually, we moved to the authentication part, where we discussed <em>Basic Authentication</em> in detail. It is a mechanism to validate the client by the <em>Customer</em> (who are users of our API) credentials (<kbd>username</kbd> and <kbd>password</kbd>), which are passed in with the requests.</p>
<p><em>Bearer</em> or <em>Token-based</em> Authentication was the next topic we explored, and we implemented the OAuth paradigm using <em>IdentityServer4</em>. In this case, the client can't access a resource directly by <kbd>username</kbd> and <kbd>password</kbd> as it was in the case of basic. What it needs is a token first, which is generated by one Authorization Server upon request by the client with <span>client details such as</span> <em>client id</em> <span>and</span> <em>client secret</em>. The token, then, can be sent to the API for subsequent requests for restricted resource access.</p>
<p>In the next chapter, we will take all this knowledge to build other components of our API, such as <em>Cart</em>, <em>Shipment</em>, <em>Order Items</em>, and <em>Checkout</em>.</p>


            </article>

            
        </section>
    </body></html>