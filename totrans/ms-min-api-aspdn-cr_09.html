<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer069">
<h1 class="chapter-number" id="_idParaDest-121"><a id="_idTextAnchor125"/>9</h1>
<h1 id="_idParaDest-122"><a id="_idTextAnchor126"/>Leveraging Globalization and Localization</h1>
<p>When developing an application, it is important to think about multi-language support; a multilingual application allows for a wider audience reach. This is also true for web APIs: messages returned by endpoints (for example, validation errors) should be localized, and the service should be able to handle different cultures and deal with time zones. In this chapter of the book, we will talk about <strong class="bold">globalization</strong> and <strong class="bold">localization</strong>, and <a id="_idIndexMarker452"/>we will<a id="_idIndexMarker453"/> explain what features are available in minimal APIs to work with these concepts. The information and samples that will be provided will guide us when adding multi-language support to our services and correctly handling all the related behaviors so that we will be able to develop global applications.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>Introducing globalization and localization</li>
<li>Localizing a minimal API application</li>
<li>Using resource files</li>
<li>Integrating localization in validation frameworks</li>
<li>Adding UTC support to a globalized minimal API</li>
</ul>
<h1 id="_idParaDest-123"><a id="_idTextAnchor127"/>Technical requirements</h1>
<p>To follow the descriptions in this chapter, you will need to create an ASP.NET Core 6.0 Web API application. Refer to the <em class="italic">Technical requirements</em> section in <a href="B17902_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Minimal APIs</em>, for instructions on how to do so.</p>
<p>If you’re using your console, shell, or Bash terminal to create the API, remember to change your working directory to the current chapter number (<strong class="source-inline">Chapter09</strong>).</p>
<p>All the code samples in this chapter can be found in the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter09">https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter09</a>.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor128"/>Introducing globalization and localization</h1>
<p>When thinking <a id="_idIndexMarker454"/>about internationalization, we <a id="_idIndexMarker455"/>must deal with globalization and localization, two terms that seem to refer to the same concepts but actually involve different areas. Globalization is the task of designing applications that can manage and support different cultures. Localization is the process of adapting an application to a particular culture, for example, by providing translated resources for each culture that will be supported.</p>
<p class="callout-heading">Note</p>
<p class="callout">The terms internationalization, globalization, and localization are often abbreviated to <em class="italic">I18N</em>, <em class="italic">G11N,</em> and <em class="italic">L10N</em>, respectively.</p>
<p>As with all the other features that we have already introduced in the previous chapters, globalization and localization can be handled by the corresponding middleware and services that ASP.NET Core provides and work in the same way in minimal APIs and controller-based projects.</p>
<p>You can find a great introduction to globalization and localization in the official documentation available at <a href="https://docs.microsoft.com/dotnet/core/extensions/globalization">https://docs.microsoft.com/dotnet/core/extensions/globalization</a> and <a href="https://docs.microsoft.com/dotnet/core/extensions/localization">https://docs.microsoft.com/dotnet/core/extensions/localization</a>, respectively. In the rest of the chapter, we will focus on how to add support for these features in a minimal API project; in this way, we’ll introduce some important concepts and explain how to leverage globalization and localization in ASP.NET Core.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor129"/>Localizing a minimal API application</h1>
<p>To enable localization within<a id="_idIndexMarker456"/> a minimal API application, let us go through the following steps:</p>
<ol>
<li>The first step to making an application localizable is to specify the supported cultures by setting the corresponding options, as follows:<p class="source-code">var builder = WebApplication.CreateBuilder(args);</p><p class="source-code">//...</p><p class="source-code">var supportedCultures = new CultureInfo[] { new("en"), new("it"), new("fr") };</p><p class="source-code">builder.Services.Configure&lt;RequestLocalizationOptions&gt;(options =&gt;</p><p class="source-code">{</p><p class="source-code">   options.SupportedCultures = supportedCultures;</p><p class="source-code">   options.SupportedUICultures = supportedCultures;</p><p class="source-code">   options.DefaultRequestCulture = new <a id="_idTextAnchor130"/></p><p class="source-code">   RequestCulture(supportedCultures.First());</p><p class="source-code">});</p></li>
</ol>
<p>In our example, we want to support three cultures – English, Italian, and French – so, we create an array of <strong class="source-inline">CultureInfo</strong> objects. </p>
<p>We’re defining neutral cultures, that is, cultures that have a language but are not associated with a country or region. We could also use specific cultures, such as <strong class="source-inline">en-US</strong> or <strong class="source-inline">en-GB</strong>, to represent the cultures of a particular region: for example, <strong class="source-inline">en-US</strong> would refer to the English culture prevalent in the United States, while <strong class="source-inline">en-GB</strong> would refer to the English culture prevalent in the United Kingdom. This difference is important because, depending on the scenario, we may need to use country-specific information to correctly implement localization. For example, if we want to show a date, we have to <a id="_idIndexMarker457"/>know that the date format in the United States is <strong class="source-inline">M/d/yyyy</strong>, while in the United Kingdom, it is <strong class="source-inline">dd/MM/yyyy</strong>. So, in this case, it becomes fundamental to work with specific cultures. We also use specific cultures if we need to support language differences across cultures. For example, a particular word may have different spellings depending on the country (e.g., <em class="italic">color</em> in the US versus <em class="italic">colour</em> in the UK). That said, for our scenario of minimal APIs, working with neutral cultures is just fine.</p>
<ol>
<li value="2">Next, we configure <strong class="source-inline">RequestLocalizationOptions</strong>, setting the cultures and specifying the default one to use if no information about the culture is provided. We specify both the supported cultures and the supported UI cultures: <ul><li>The supported cultures control the output of culture-dependent functions, such as date, time, and number format.</li><li>The supported UI cultures are used to choose which translated strings (from <strong class="source-inline">.resx</strong> files) are searched for. We will talk about <strong class="source-inline">.resx</strong> files later in this chapter.</li></ul></li>
</ol>
<p>In a typical application, cultures and UI cultures are set to the same values, but of course, we can use different options if needed.</p>
<ol>
<li value="3">Now that we have configured our service to support globalization, we need to add the localization middleware to the ASP.NET Core pipeline so it will be able to automatically set the culture of the request. Let us do so using the following code:<p class="source-code">var app = builder.Build();</p><p class="source-code">//...</p><p class="source-code">app.UseRequestLocalization();</p><p class="source-code">//...</p><p class="source-code">app.Run();</p></li>
</ol>
<p>In the preceding code, with <strong class="source-inline">UseRequestLocalization()</strong>, we’re adding <strong class="source-inline">RequestLocalizationMiddleware</strong> to the ASP.NET Core pipeline to set the current culture of each request. This task is performed using a list of <strong class="source-inline">RequestCultureProvider</strong> that can read information about the culture from various sources. Default providers comprise the following:  </p>
<ul>
<li><strong class="source-inline">QueryStringRequestCultureProvider</strong>: Searches for the <strong class="source-inline">culture</strong> and <strong class="source-inline">ui-culture</strong> query string parameters</li>
<li><strong class="source-inline">CookieRequestCultureProvider</strong>: Uses the ASP.NET Core cookie</li>
<li><strong class="source-inline">AcceptLanguageHeaderRequestProvider</strong>: Reads the requested culture from the <strong class="source-inline">Accept-Language</strong> HTTP header</li>
</ul>
<p>For each request, the<a id="_idIndexMarker458"/> system will try to use these providers in this exact order, until it finds the first one that can determine the culture. If the culture cannot be set, the one specified in the <strong class="source-inline">DefaultRequestCulture</strong> property of <strong class="source-inline">RequestLocalizationOptions</strong> will be used.</p>
<p>If necessary, it is also possible to change the order of the request culture providers or even define a custom provider to implement our own logic to determine the culture. More information on this topic is available at <a href="https://docs.microsoft.com/aspnet/core/fundamentals/localization#use-a-custom-provider">https://docs.microsoft.com/aspnet/core/fundamentals/localization#use-a-custom-provider</a>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The localization middleware must be inserted before any other middleware that might use the request culture.</p>
<p>In the case of web APIs, whether using controller-based or minimal APIs, we usually set the request culture through the <strong class="source-inline">Accept-Language</strong> HTTP header. In the following section, we will see how to extend Swagger with the ability to add this header when trying to invoke methods.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor131"/>Adding globalization support to Swagger</h2>
<p>We want Swagger to <a id="_idIndexMarker459"/>provide us <a id="_idIndexMarker460"/>with a<a id="_idIndexMarker461"/> way to specify the <strong class="source-inline">Accept-Language</strong> HTTP header for each request so that we can test our globalized endpoints. Technically speaking, this means adding an <strong class="bold">operation filter</strong> to Swagger<a id="_idIndexMarker462"/> that will be able to automatically insert the language header, using the following code:</p>
<pre class="source-code">
public class AcceptLanguageHeaderOperationFilter : IOperationFilter
{
     private readonly List&lt;IOpenApiAny&gt;? 
     supportedLanguages;
     public AcceptLanguageHeaderOperationFilter 
     (IOptions&lt;RequestLocalizationOptions&gt; 
     requestLocalizationOptions)
     {
           supportedLanguages = 
           requestLocalizationOptions.Value.
           SupportedCultures?.Select(c =&gt; 
           newOpenApiString(c.TwoLetterISOLanguageName)).
           Cast&lt;IOpenApiAny&gt;().           ToList();
     }
     public void Apply(OpenApiOperation operation, 
     OperationFilterContext context)
     {
           if (supportedLanguages?.Any() ?? false)
           {
                 operation.Parameters ??= new 
                 List&lt;OpenApiParameter&gt;();
                 operation.Parameters.Add(new 
                 OpenApiParameter
                 {
                       Name = HeaderNames.AcceptLanguage,
                       In = ParameterLocation.Header,
                       Required = false,
                       Schema = new OpenApiSchema
                       {
                             Type = "string",
                             Enum = supportedLanguages,
                             Default = supportedLanguages.
                             First()
                       }
                 });
           }
     }
}</pre>
<p>In the preceding code, <strong class="source-inline">AcceptLanguageHeaderOperationFilter</strong> takes the <strong class="source-inline">RequestLocalizationOptions</strong> object via dependency injection that we have defined at startup and extracts the supported languages in the format that Swagger expects from it. Then, in the <strong class="source-inline">Apply()</strong> method, we add a <a id="_idIndexMarker463"/>new <strong class="source-inline">OpenApiParameter</strong> that <a id="_idIndexMarker464"/>corresponds<a id="_idIndexMarker465"/> to the <strong class="source-inline">Accept-Language</strong> header. In particular, with the <strong class="source-inline">Schema.Enum</strong> property, we provide the list of supported languages using the values we have extracted in the constructor. This method is invoked for every operation (that is, every endpoint), meaning that the parameter will be automatically added to each of them.</p>
<p>Now, we need to add the new filter to Swagger:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
//...
builder.Services.AddSwaggerGen(options =&gt;
{
     options.OperationFilter&lt;AcceptLanguageHeaderOperation
     Filter&gt;();
});</pre>
<p>As we did with the preceding code, for every operation, Swagger will execute the filter, which in turn will add a parameter to specify the language of the request.</p>
<p>So, let’s suppose we have the following endpoint:</p>
<pre class="source-code">
app.MapGet("/culture", () =&gt; Thread.CurrentThread.CurrentCulture.DisplayName);</pre>
<p>In the preceding handler, we just return the culture of the thread. This method takes no parameter; however, after adding the preceding filter, the Swagger UI will show the following:</p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<img alt="Figure 9.1 – The Accept-Language header added to Swagger " height="333" src="image/Figure_9.1_B17902.jpg" width="798"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The Accept-Language header added to Swagger</p>
<p>The operation filter has added <a id="_idIndexMarker466"/>a new <a id="_idIndexMarker467"/>parameter<a id="_idIndexMarker468"/> to the endpoint, allowing us to select the language from a dropdown. We can click the <strong class="bold">Try it out</strong> button to choose a value from the list and then click <strong class="bold">Execute</strong> to invoke the endpoint:</p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<img alt="Figure 9.2 – The result of the execution with the Accept-Language HTTP header " height="667" src="image/Figure_9.2_B17902.jpg" width="462"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The result of the execution with the Accept-Language HTTP header</p>
<p>This is the result of selecting <strong class="source-inline">it</strong> as a language request: Swagger has added the <strong class="source-inline">Accept-Language</strong> HTTP header, which, in turn, has been used by ASP.NET Core to set the current culture. Then, in the end, we get and return the culture display name in the route handler.</p>
<p>This example shows us that <a id="_idIndexMarker469"/>we have<a id="_idIndexMarker470"/> correctly<a id="_idIndexMarker471"/> added globalization support to our minimal API. In the next section, we’ll go further and work with localization, starting by providing translated resources to callers based on the corresponding languages.</p>
<h1 id="_idParaDest-127">Us<a id="_idTextAnchor132"/>ing resource files</h1>
<p>Our minimal API now <a id="_idIndexMarker472"/>supports globalization, so it can switch cultures based on the request. This means that we can provide localized messages to callers, for example, when communicating validation errors. This feature is based on the so-called <strong class="bold">resource files</strong> (<strong class="source-inline">.resx</strong>), a particular kind of XML file that contains key-value string pairs representing messages that must be localized.</p>
<p class="callout-heading">Note</p>
<p class="callout">These resource files are exactly the same as they have been since the early versions of .NET.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor133"/>Creating and working with resource files</h2>
<p>With resource files, we can <a id="_idIndexMarker473"/>easily <a id="_idIndexMarker474"/>separate strings from code and group them by culture. Typically, resource files are put in a folder called <strong class="source-inline">Resources</strong>. To create a file of this kind using Visual Studio, let us go through the following steps:</p>
<p class="callout-heading">Important note</p>
<p class="callout">Unfortunately, Visual Studio Code does not provide support for handling <strong class="source-inline">.resx</strong> files. More information about this topic is available at <a href="https://github.com/dotnet/AspNetCore.Docs/issues/2501">https://github.com/dotnet/AspNetCore.Docs/issues/2501</a>.</p>
<ol>
<li value="1">Right-click on the folder in <strong class="bold">Solution Explorer</strong> and then choose <strong class="bold">Add</strong> | <strong class="bold">New Item</strong>. </li>
<li>In the <strong class="bold">Add New Item</strong> dialog window, search for <strong class="source-inline">Resources</strong>, select the corresponding template, and name the file, for example, <strong class="source-inline">Messages.resx</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer062">
<img alt="Figure 9.3 – Adding a resource file to the project " height="567" src="image/Figure_9.3_B17902.jpg" width="996"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Adding a resource file to the project</p>
<p>The new file will immediately open in the Visual Studio editor. </p>
<ol>
<li value="3">The first thing to <a id="_idIndexMarker475"/>do in the <a id="_idIndexMarker476"/>new file is to select <strong class="bold">Internal</strong> or <strong class="bold">Public</strong> (based on the code visibility we want to achieve) from the <strong class="bold">Access Modifier</strong> option so that Visual Studio will create a C# file that exposes the properties to access the resources:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer063">
<img alt="Figure 9.4 – Changing the Access Modifier of the resource file " height="177" src="image/Figure_9.4_B17902.jpg" width="780"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Changing the Access Modifier of the resource file</p>
<p>As soon as we change this value, Visual Studio will add a <strong class="source-inline">Messages.Designer.cs</strong> file to the project and automatically create properties that correspond to the strings we insert in the resource file.</p>
<p>Resource files must follow a precise naming convention. The file that contains default culture messages can have any name (such as <strong class="source-inline">Messages.resx</strong>, as in our example), but the other <strong class="source-inline">.resx</strong> files that provide the corresponding translations must have the same name, with the specification of the culture (neutral or specific) to which they refer. So, we have <strong class="source-inline">Messages.resx</strong>, which will store default (English) messages. </p>
<ol>
<li value="4">Since we also want to localize our messages in Italian, we need to create another file with the name <strong class="source-inline">Messages.it.resx</strong>.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">We don’t create a resource file for French culture on purpose because this way, we’ll see how APS.NET Core looks up the localized messages in practice. </p>
<ol>
<li value="5">Now, we can start experimenting with resource files. Let’s open the <strong class="source-inline">Messages.resx</strong> file and set <strong class="bold">Name</strong> to <strong class="source-inline">HelloWorld</strong> and <strong class="bold">Value</strong> to <strong class="source-inline">Hello World!</strong>.</li>
</ol>
<p>In this way, Visual Studio will add a static <strong class="source-inline">HelloWorld</strong> property in the <strong class="source-inline">Messages</strong> autogenerated class that allows<a id="_idIndexMarker477"/> us to access<a id="_idIndexMarker478"/> values based on the current culture. </p>
<ol>
<li value="6">To demonstrate this behavior, also open the <strong class="source-inline">Messages.it.resx</strong> file and add an item with the same <strong class="bold">Name</strong>, <strong class="source-inline">HelloWorld</strong>, but now set <strong class="bold">Value</strong> to the translation <strong class="source-inline">Ciao mondo!</strong>.</li>
<li>Finally, we can add a new endpoint to showcase the usage of the resource files:<p class="source-code">// using Chapter09.Resources;</p><p class="source-code">app.MapGet("/helloworld", () =&gt; Messages.HelloWorld);</p></li>
</ol>
<p>In the preceding route handler, we simply access the static <strong class="source-inline">Mesasges.HelloWorld</strong> property that, as discussed before, has been automatically created while editing the <strong class="source-inline">Messages.resx</strong> file.</p>
<p>If we now run the minimal API and try to execute this endpoint, we’ll get the following responses based on the request language that we select in Swagger:</p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<img alt="Table 9.1 – Responses based on the request language " height="246" src="image/B17902_09_Table1.jpg" width="1236"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.1 – Responses based on the request language</p>
<p>When accessing a property such as <strong class="source-inline">HelloWorld</strong>, the autogenerated <strong class="source-inline">Messages</strong> class internally uses <strong class="source-inline">ResourceManager</strong> to look up the corresponding localized string. First of all, it looks for a resource file whose name contains the requested culture. If it is not found, it reverts to the parent culture of that culture. This means that, if the requested culture is specific, <strong class="source-inline">ResourceManager</strong> searches for the neutral culture. If no resource file is still found, then the default one is used.</p>
<p>In our case, using Swagger, we can select only English, Italian, or French as a neutral culture. But what happens if a client sends other values? We can have situations such as the following:</p>
<ul>
<li>The request culture is <strong class="source-inline">it-IT</strong>: the system searches for <strong class="source-inline">Messages.it-IT.resx</strong> and then finds and uses <strong class="source-inline">Messages.it.resx</strong>.</li>
<li>The request culture is <strong class="source-inline">fr-FR</strong>: the system searches for <strong class="source-inline">Messages.fr-FR.resx</strong>, then <strong class="source-inline">Messages.fr.resx</strong>, and (because neither are available) finally uses the default, <strong class="source-inline">Messages.resx</strong>.</li>
<li>The request culture is <strong class="source-inline">de</strong> (German): because this isn’t a supported culture at all, the default request culture will be <a id="_idIndexMarker479"/>automatically <a id="_idIndexMarker480"/>selected, so strings will be searched for in the <strong class="source-inline">Messages.resx</strong> file.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">If a localized resource file exists, but it doesn’t contain the specified key, then the value of the default file will be used.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor134"/>Formatting localized messages using resource files</h2>
<p>We can also <a id="_idIndexMarker481"/>use resource<a id="_idIndexMarker482"/> files to format localized messages. For example, we can add the following strings to the resource files of the project:</p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<img alt="Table 9.2 – A custom localized message " height="154" src="image/B17902_09_Table2.jpg" width="1539"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.2 – A custom localized message</p>
<p>Now, let’s define this endpoint:</p>
<pre class="source-code">
// using Chapter09.Resources;
app.MapGet("/hello", (string name) =&gt;
{
     var message = string.Format(Messages.GreetingMessage, 
     name);
     return message;
});</pre>
<p>As in the preceding code example, we get a string from a resource file according to the culture of the request. But, in this case, the message contains a placeholder, so we can use it to create a custom localized message using the name that is passed to the route handler. If we try to execute the endpoint, we will get results such as these:</p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<img alt="Table 9.3 – Responses with custom localized messages based on the request language " height="240" src="image/B17902_09_Table3.jpg" width="1341"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.3 – Responses with custom localized messages based on the request language</p>
<p>The possibility to create localized messages with placeholders that are replaced at runtime using different values is a key point for creating truly localizable services.</p>
<p>In the beginning, we<a id="_idIndexMarker483"/> said that a<a id="_idIndexMarker484"/> typical use case of localization in web APIs is when we need to provide localized error messages upon validation. In the next section, we’ll see how to add this feature to our minimal API.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor135"/>Integrating localization in validation frameworks</h1>
<p>In <a href="B17902_06.xhtml#_idTextAnchor082"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Validation and Mapping</em>, we talked about how to integrate validation into a minimal <a id="_idIndexMarker485"/>API project. We learned <a id="_idIndexMarker486"/>how to use the <strong class="source-inline">MiniValidation</strong> library, rather than <strong class="source-inline">FluentValidation</strong>, to validate our models and provide validation messages to the callers. We also said that <strong class="source-inline">FluentValidation</strong> already provides translations for standard error messages.</p>
<p>However, with both libraries, we can leverage the localization support we have just added to our project to support localized and custom validation messages.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor136"/>Localizing validation messages with MiniValidation</h2>
<p>Using the <strong class="source-inline">MiniValidation</strong> library, we can<a id="_idIndexMarker487"/> use validation<a id="_idIndexMarker488"/> based <a id="_idIndexMarker489"/>on <strong class="bold">Data Annotations</strong> with minimal APIs. Refer to <a href="B17902_06.xhtml#_idTextAnchor082"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Validation and Mapping</em>, for instructions on how to add this library to the project.</p>
<p>Then, recreate the same <strong class="source-inline">Person</strong> class:</p>
<pre class="source-code">
public class Person
{
     [Required]
     [MaxLength(30)]
     public string FirstName { get; set; }
     [Required]
     [MaxLength(30)]
     public string LastName { get; set; }
     [EmailAddress]
     [StringLength(100, MinimumLength = 6)]
     public string Email { get; set; }
}</pre>
<p>Every validation attribute allows us to specify an error message, which can be a static string or a reference to a resource file. Let’s see how to correctly handle the localization for the <strong class="source-inline">Required</strong> attribute. Add the following values in resource files:</p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<img alt="Table 9.4 – Localized validation error messages used by Data Annotations " height="376" src="image/B17902_09_Table4.jpg" width="1473"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.4 – Localized validation error messages used by Data Annotations</p>
<p>We want it so that when <a id="_idIndexMarker490"/>a required <a id="_idIndexMarker491"/>validation rule fails, the localized message that corresponds to <strong class="source-inline">FieldRequiredAnnotation</strong> is returned. Moreover, this message contains a placeholder, because we want to use it for every required field, so we also need the translation of property names.</p>
<p>With these resources, we can update the <strong class="source-inline">Person</strong> class with the following declarations:</p>
<pre class="source-code">
public class Person
{
     [Display(Name = "FirstName", ResourceType = 
      typeof(Messages))]
     [Required(ErrorMessageResourceName = 
     "FieldRequiredAnnotation",
      ErrorMessageResourceType = typeof(Messages))]
     public string FirstName { get; set; }
     //...
}</pre>
<p>Each validation attribute, such as <strong class="source-inline">Required</strong> (as used in this example), exposes properties that allow us to specify the name of the resource to use and the type of class that contains the corresponding definition. Keep in mind that the name is a simple string, with no check at compile time, so if we write an incorrect value, we’ll only get an error at runtime. </p>
<p>Next, we can use the <strong class="source-inline">Display</strong> attribute to also specify the name of the field that must be inserted in the validation message.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the complete declaration of the <strong class="source-inline">Person</strong> class with localized data annotations on the GitHub repository at https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/blob/main/Chapter09/Program.cs#L97.</p>
<p>Now we can re-add the validation code shown in <a href="B17902_06.xhtml#_idTextAnchor082"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Validation and Mapping</em>. The difference is that now the<a id="_idIndexMarker492"/> validation <a id="_idIndexMarker493"/>messages will be localized:</p>
<pre class="source-code">
app.MapPost("/people", (Person person) =&gt;
{
     var isValid = MiniValidator.TryValidate(person, out 
     var errors);
     if (!isValid)
     {
           return Results.ValidationProblem(errors, title: 
           Messages.ValidationErrors);
     }
     return Results.NoContent();
});</pre>
<p>In the preceding code, the messages contained in the <strong class="source-inline">errors</strong> dictionary that is returned by the <strong class="source-inline">MiniValidator.TryValidate()</strong> method will be localized according to the request culture, as described in the previous sections. We also specify the <strong class="source-inline">title</strong> parameter in the <strong class="source-inline">Results.ValidationProblem()</strong> invocation because we want to localize this value too (otherwise, it will always be the default <strong class="source-inline">One or more validation errors occurred</strong>).</p>
<p>If instead of data annotations, we prefer using <strong class="source-inline">FluentValidation</strong>, we know that it supports localization of standard error messages by default from <a href="B17902_06.xhtml#_idTextAnchor082"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Validation and Mapping</em>. However, with this library, we <a id="_idIndexMarker494"/>can also<a id="_idIndexMarker495"/> provide our translations. In the next section, we’ll talk about implementing this solution.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor137"/>Localizing validation messages with FluentValidation</h2>
<p>With <strong class="source-inline">FluentValidation</strong>, we can <a id="_idIndexMarker496"/>totally <a id="_idIndexMarker497"/>decouple the validation rules from our models. As said before, refer to <a href="B17902_06.xhtml#_idTextAnchor082"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Validation and Mapping</em>, for instructions on how to add this library to the project and how to configure it.</p>
<p>Next, let us recreate the <strong class="source-inline">PersonValidator</strong> class:</p>
<pre class="source-code">
public class PersonValidator : AbstractValidator&lt;Person&gt;
{
     public PersonValidator()
     {
           RuleFor(p =&gt; p.FirstName).NotEmpty().
           MaximumLength(30);
           RuleFor(p =&gt; p.LastName).NotEmpty().
           MaximumLength(30);
           RuleFor(p =&gt; p.Email).EmailAddress().Length(6, 
           100);
     }
}</pre>
<p>In the case that we haven’t specified any messages, the default ones will be used. Let’s add the following resource to customize the <strong class="source-inline">NotEmpty</strong> validation rule:</p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<img alt="Table 9.5 – The localized validation error messages used by FluentValidation " height="200" src="image/B17902_09_Table5.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.5 – The localized validation error messages used by FluentValidation</p>
<p>Note that, in this case, we also have a placeholder that will be replaced by the property name. However, different from data annotations, <strong class="source-inline">FluentValidation</strong> uses a placeholder with a name to better identify its meaning.</p>
<p>Now, we can add this message in the validator, for example, for the <strong class="source-inline">FirstName</strong> property:</p>
<pre class="source-code">
RuleFor(p =&gt; p.FirstName).NotEmpty().
     WithMessage(Messages.NotEmptyMessage).
     WithName(Messages.FirstName);</pre>
<p>We use <strong class="source-inline">WithMessage()</strong> to specify the message that must be used when the preceding rule fails, following which we add the <strong class="source-inline">WithName()</strong> invocation to overwrite the default property name used for the <strong class="source-inline">{PropertyName}</strong> placeholder of the message.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the complete implementation of the <strong class="source-inline">PersonValidator</strong> class with localized messages in the GitHub repository at https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/blob/main/Chapter09/Program.cs#L129.</p>
<p>Finally, we can leverage the <a id="_idIndexMarker498"/>localized<a id="_idIndexMarker499"/> validator in our endpoint, as we did in <a href="B17902_06.xhtml#_idTextAnchor082"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Validation and Mapping</em>:</p>
<pre class="source-code">
app.MapPost("/people", async (Person person, IValidator&lt;Person&gt; validator) =&gt;
{
     var validationResult = await validator.
     ValidateAsync(person);
     if (!validationResult.IsValid)
     {
           var errors = validationResult.ToDictionary();
           return Results.ValidationProblem(errors, title: 
           Messages.ValidationErrors);
     }
     return Results.NoContent();
});</pre>
<p>As in the case of data annotations, the <strong class="source-inline">validationResult</strong> variable will contain localized error messages that we return to the caller using the <strong class="source-inline">Results.ValidationProblem()</strong> method (again, with the definition of the <strong class="source-inline">title</strong> property).</p>
<p class="callout-heading">Tip</p>
<p class="callout">In our example, we have seen how to explicitly assign translations for each property using the <strong class="source-inline">WithMessage()</strong> method. <strong class="source-inline">FluentValidation</strong> also provides a way to replace all (or some) of its default messages. You can find more information in the official documentation at <a href="https://docs.fluentvalidation.net/en/latest/localization.xhtml#default-messages">https://docs.fluentvalidation.net/en/latest/localization.xhtml#default-messages</a>.</p>
<p>This ends our overview of localization using resource files. Next, we’ll talk about an important topic when dealing with services<a id="_idIndexMarker500"/> that are <a id="_idIndexMarker501"/>meant to be used worldwide: the correct handling of different time zones.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor138"/>Adding UTC support to a globalized minimal API</h1>
<p>So far, we have added <a id="_idIndexMarker502"/>globalization <a id="_idIndexMarker503"/>and localization support to our minimal API because we want it to be used by the widest audience possible, irrespective of culture. But, if we think about being accessible to a worldwide audience, we should consider several aspects related to globalization. Globalization does not only pertain to language support; there are important factors we need to consider, for example, geographic locations, as well as time zones.</p>
<p>So, for example, we can have our minimal API running in Italy, which follows <em class="italic">Central European Time</em> (CET) (GMT+1), while our clients can use browsers that execute a single-page application, rather than mobile apps, all over the world. We could also have a database server that contains our data, and this could be in another time zone. Moreover, at a certain point, it may be necessary to provide better support for worldwide users, so we’ll have to move our service to another location, which could have a new time zone. In conclusion, our system could deal with data in different time zones, and, potentially, the same services could switch time zones during their lives.</p>
<p>In these situations, the ideal solution is working with <strong class="source-inline">DateTimeOffset</strong>, a data type that includes time zones and that <strong class="source-inline">JsonSerializer</strong> fully supports, preserving time zone information during serialization and deserialization. If we could always use it, we’d automatically solve any problem related to globalization, because converting a <strong class="source-inline">DateTimeOffset</strong> value to a different time zone is straightforward. However, there are cases in which we can’t handle the <strong class="source-inline">DateTimeOffset</strong> type, for example:</p>
<ul>
<li>When we’re working on a legacy system that relies on <strong class="source-inline">DateTime</strong> everywhere, updating the code to use <strong class="source-inline">DateTimeOffset</strong> isn’t an option because it requires too many changes and breaks the compatibility with the old data.</li>
<li>We have a database server such as MySQL that doesn’t have a column type for storing <strong class="source-inline">DateTimeOffset</strong> directly, so handling it requires extra effort, for example, using two separate columns, increasing the complexity of the domain.</li>
<li>In some cases, we simply aren’t interested in sending, receiving, and saving time zones – we just want to handle time in a “universal” way.</li>
</ul>
<p>So, in all the scenarios where we can’t or don’t want to use the <strong class="source-inline">DateTimeOffset</strong> data type, one of the best and simplest ways to deal with different time zones is to handle all dates using <em class="italic">Coordinated Universal Time</em> (<em class="italic">UTC</em>): the service must assume that the dates it receives are in the UTC format and, on the other hand, all the dates returned by the API must be in UTC.</p>
<p>Of course, we must handle this behavior in a centralized way; we don’t want to have to remember to apply the conversion to and from the UTC format every time we receive or send a date. The well-known JSON.NET library provides an option to specify how to treat the time value when working with a <strong class="source-inline">DateTime</strong> property, allowing it to automatically handle all dates as UTC and convert them to that format if they represent a local time. However, the current version of Microsoft <strong class="source-inline">JsonSerializer</strong> used in minimal APIs doesn’t include such a feature. From <a href="B17902_02.xhtml#_idTextAnchor023"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring Minimal APIs and Their Advantages</em>, we know that we cannot change the default JSON serializer in minimal APIs, but we can overcome this<a id="_idIndexMarker504"/> lack of <a id="_idIndexMarker505"/>UTC support by creating a simple <strong class="source-inline">JsonConverter</strong>:</p>
<pre class="source-code">
public class UtcDateTimeConverter : JsonConverter&lt;DateTime&gt;
{
     public override DateTime Read(ref Utf8JsonReader 
     reader, Type typeToConvert, JsonSerializerOptions  
     options)
     =&gt; reader.GetDateTime().ToUniversalTime();
     public override void Write(Utf8JsonWriter writer, 
     DateTime value, JsonSerializerOptions options)
     =&gt; writer.WriteStringValue((value.Kind == 
     DateTimeKind.Local ? value.ToUniversalTime() : value)
     .ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'
     fffffff'Z'"));
}</pre>
<p>With this converter, we tell <strong class="source-inline">JsonSerializer</strong> how to treat <strong class="source-inline">DateTime</strong> properties:</p>
<ul>
<li>When <strong class="source-inline">DateTime</strong> is read from JSON, the value is converted to UTC using the <strong class="source-inline">ToUniversalTime()</strong> method.</li>
<li>When <strong class="source-inline">DateTime</strong> must be written to JSON, if it represents a local time (<strong class="source-inline">DateTimeKind.Local</strong>), it is converted to UTC before serialization – then, it is serialized using the <strong class="source-inline">Z</strong> suffix, which indicates that the time is UTC.</li>
</ul>
<p>Now, before using this converter, let’s add the following endpoint definition:</p>
<pre class="source-code">
app.MapPost("/date", (DateInput date) =&gt;
{
     return Results.Ok(new
     {
           Input = date.Value,
           DateKind = date.Value.Kind.ToString(),
           ServerDate = DateTime.Now
     });
});
public record DateInput(DateTime Value);</pre>
<p>Let’s try to call it, for example, with a date formatted as <strong class="source-inline">2022-03-06T16:42:37-05:00</strong>. We’ll obtain something <a id="_idIndexMarker506"/>similar<a id="_idIndexMarker507"/> to the following:</p>
<pre class="source-code">
{
  "input": "2022-03-06T22:42:37+01:00",
  "dateKind": "Local",
  "serverDate": "2022-03-07T18:33:17.0288535+01:00"
}</pre>
<p>The input date, containing a time zone, has automatically been converted to the local time of the server (in this case, the server is running in Italy, as stated at the beginning), as also demonstrated by the <strong class="source-inline">dateKind</strong> field. Moreover, <strong class="source-inline">serverDate</strong> contains a date that is relative to the server time zone.</p>
<p>Now, let’s add <strong class="source-inline">UtcDateTimeConverter</strong> to <strong class="source-inline">JsonSerializer</strong>:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
//...
builder.Services.Configure&lt;Microsoft.AspNetCore.Http.Json.
JsonOptions&gt;(options =&gt;
{
     options.SerializerOptions.Converters.Add(new 
     UtcDateTimeConverter());
});</pre>
<p>With this configuration, every <strong class="source-inline">DateTime</strong> property will be processed using our custom converters. Now, execute the endpoint again, using the same input as before. This time, the result will be as follows:</p>
<pre class="source-code">
{
  "input": "2022-03-06T21:42:37.0000000Z",
  "dateKind": "Utc",
  "serverDate": "2022-03-06T17:40:08.1472051Z"
}</pre>
<p>The input is the same, but our <strong class="source-inline">UtcDateTimeConverter</strong> has now converted the date to UTC and, on the other hand, has serialized the server date as UTC; now, our API, in a centralized way, can automatically handle all dates as UTC, no matter its time zone or the time zones of the callers.</p>
<p>Finally, there are two other points to make all the systems correctly work with UTC:</p>
<ul>
<li>When we need to retrieve the current date in the code, we always have to use <strong class="source-inline">DateTime.UtcNow</strong> instead of <strong class="source-inline">DateTime.Now</strong></li>
<li>Client applications must know that they will receive the date in UTC format and act accordingly, for example, invoking the <strong class="source-inline">ToLocalTime()</strong> method</li>
</ul>
<p>In this way, the <a id="_idIndexMarker508"/>minimal <a id="_idIndexMarker509"/>API is truly globalized and can work with any time zone; without having to worry about explicit conversion, all times input or output will be always in UTC, so it will be much easier to handle them.</p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor139"/>Summary</h1>
<p>Developing minimal APIs with globalization and localization support in mind is fundamental in an interconnected world. ASP.NET Core includes all the features needed to create services that can react to the culture of the user and provide translations based on the request language: the usage of localization middleware, resource files, and custom validation messages allows the creation of services that can support virtually every culture. We have also talked about the globalization-related problems that could arise when working with different time zones and shown how to solve it using the centralized UTC date time format so that our APIs can seamlessly work irrespective of the geographic location and time zone of clients.</p>
<p>In <a href="B17902_10.xhtml#_idTextAnchor140"><em class="italic">Chapter 10</em></a>, <em class="italic">Evaluating and Benchmarking the Performance of Minimal APIs</em>, we will talk about why minimal APIs were created and analyze the performance benefits of using minimal APIs over the classic controller-based approach.</p>
</div>
</div></body></html>