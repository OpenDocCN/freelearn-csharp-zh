- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Unit Testing and Test-Driven Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试和测试驱动开发
- en: This chapter delves into the foundational concepts of unit testing and **Test-Driven
    Development** ( **TDD** ) within Visual Studio 2022. You will learn about the
    significance of writing tests before code and explore the integration of testing
    frameworks. Practical examples will guide you through creating effective unit
    tests, ensuring code reliability, and fostering a test-driven mindset.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了 Visual Studio 2022 中单元测试和 **测试驱动开发**（**TDD**）的基础概念。您将了解在编写代码之前编写测试的重要性，并探索测试框架的集成。实际示例将指导您创建有效的单元测试，确保代码可靠性，并培养测试驱动的心态。
- en: We will embark on a journey to understand the essentials of unit testing and
    TDD. We’ll start by gaining an overview of these foundational concepts and exploring
    their significance in the software development life cycle.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始一段旅程，了解单元测试和 TDD 的基本要素。我们将从对这些基础概念的整体了解和探索它们在软件开发生命周期中的重要性开始。
- en: Following this introduction, we will delve into the practical aspects of setting
    up unit testing within Visual Studio Code. This section will guide you through
    the initial steps of configuring your development environment, laying the groundwork
    for the integration of testing frameworks into your workflow.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在此介绍之后，我们将深入探讨在 Visual Studio Code 中设置单元测试的实际方面。本节将指导您完成配置开发环境的初始步骤，为将测试框架集成到您的流程中打下基础。
- en: Once the setup is complete, we will transition into creating our first test
    using IntelliTest, a feature of Visual Studio that automates the generation of
    unit tests. This hands-on experience will demonstrate how IntelliTest can streamline
    the testing process, making it more efficient and less time-consuming.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置完成，我们将过渡到创建第一个测试，使用的是 Visual Studio 的一个功能——IntelliTest，它可以自动化生成单元测试。这种动手经验将展示
    IntelliTest 如何简化测试过程，使其更加高效和节省时间。
- en: Next, we will apply what we’ve learned in a real-world example, practicing TDD
    from the ground up. This section will walk you through the process of writing
    tests before code, a core principle of TDD, and how it can lead to more robust
    and reliable software.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将应用所学知识，通过一个真实世界示例练习从零开始的 TDD。本节将向您介绍在编写代码之前编写测试的过程，这是 TDD 的一个核心原则，以及它如何导致更健壮和可靠的软件。
- en: Finally, we will explore how to automate your testing process with Live Unit
    Testing, a feature that runs your unit tests in the background as you code. This
    section will show you how to enable and utilize Live Unit Testing to enhance your
    development workflow, ensuring that your code remains reliable and bug-free throughout
    the development process.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探索如何使用 Live Unit Testing 自动化测试过程，这是一个在您编码时在后台运行单元测试的功能。本节将向您展示如何启用并利用
    Live Unit Testing 来增强您的开发流程，确保您的代码在整个开发过程中保持可靠且无错误。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing unit testing and TDD
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍单元测试和 TDD
- en: Setting up unit testing in Visual Studio
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中设置单元测试
- en: Creating tests with IntelliTest
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IntelliTest 创建测试
- en: Practicing TDD with a real-world example
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用真实世界示例练习 TDD
- en: Automating your tests with Live Unit Test
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Live Unit Test 自动化测试
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'While writing this chapter, I used the following version of Visual Studio:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本章时，我使用了以下版本的 Visual Studio：
- en: Visual Studio Enterprise 2022 version 17.12.0
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Enterprise 2022 版本 17.12.0
- en: Preview 1.0
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预览 1.0
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch01](https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch01)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch01](https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch01)找到
- en: Introducing unit testing and TDD
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍单元测试和 TDD
- en: Before delving into the usage of unit testing and the TDD approach through Visual
    Studio, let’s begin with a refresher on what they are and why it’s valuable to
    consider them in your project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨通过 Visual Studio 使用单元测试和 TDD 方法之前，让我们先回顾一下它们是什么以及为什么在项目中考虑它们是有价值的。
- en: Unit testing is a focused software testing method that targets individual units
    or components within a software system. The primary aim of unit testing is to
    ensure that each software unit functions as intended, meeting specified requirements.
    Typically conducted by developers, unit testing takes place early in the development
    stage, preceding the integration and testing of the entire system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种针对软件系统内单个单元或组件的集中式软件测试方法。单元测试的主要目标是确保每个软件单元按预期工作，满足指定的要求。通常由开发者执行，单元测试在开发早期进行，先于整个系统的集成和测试。
- en: Automated unit tests are executed whenever code undergoes modification, ensuring
    that new changes do not disrupt existing functionality. These tests are meticulously
    crafted to validate the smallest conceivable unit of code, such as a function
    or method, in isolation from the broader system. This approach empowers developers
    to swiftly identify and address issues in the initial phases of development, thereby
    enhancing overall software quality and reducing the time needed for subsequent
    testing phases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化单元测试在代码发生修改时执行，确保新更改不会破坏现有功能。这些测试被精心设计来验证最小的可想象代码单元，如函数或方法，在更广泛的系统之外进行。这种方法使开发者能够在开发初期迅速识别和解决问题，从而提高整体软件质量并减少后续测试阶段所需的时间。
- en: The F.I.R.S.T principles of unit testing
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试的F.I.R.S.T.原则
- en: By conscientiously embracing the **Fast, Isolated/Independent, Repeatable, Self-Validating,
    Timely** ( **F.I.R.S.T.** ) principles in unit testing, developers are guided
    in the meticulous crafting of effective tests. These principles serve as a compass,
    steering the testing process toward excellence by instilling key criteria that
    underpin the reliability and robustness of unit tests.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过认真遵循单元测试的**快速、隔离/独立、可重复、自我验证、及时**（**F.I.R.S.T.**）原则，开发者被引导精心制作有效的测试。这些原则作为指南针，通过灌输支撑单元测试可靠性和鲁棒性的关键标准，将测试过程引导至卓越。
- en: 'Let’s look at each of the factors of F.I.R.S.T. in more detail:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看F.I.R.S.T.的每个因素：
- en: '**Fast** : The speed of execution is a fundamental characteristic of effective
    unit tests. It is imperative that unit tests run swiftly, as developers frequently
    execute them throughout the development process. A fast test suite provides rapid
    feedback, allowing developers to promptly identify and rectify issues. This not
    only accelerates the development cycle but also cultivates a culture of responsiveness,
    where developers are encouraged to run tests frequently. The ability to obtain
    quick feedback enhances the early detection of potential problems, fostering a
    proactive approach to software quality.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**：执行速度是有效单元测试的一个基本特征。单元测试必须运行迅速，因为开发者经常在整个开发过程中执行它们。快速的测试套件提供快速反馈，使开发者能够及时识别和纠正问题。这不仅加速了开发周期，还培养了一种响应性文化，鼓励开发者频繁运行测试。快速获得反馈的能力增强了早期发现潜在问题的能力，促进了对软件质量的主动方法。'
- en: '**Isolated/independent** : Independence is a cornerstone principle in unit
    testing. Each unit test should operate in isolation, devoid of dependencies on
    other tests. The order in which tests are executed or the success or failure of
    one test must not impact the results of another. This isolation ensures that developers
    can pinpoint and address issues in a focused manner, simplifying the debugging
    process. By adhering to the principle of independence, developers gain the advantage
    of precisely identifying the source of a problem, thereby expediting the resolution
    process.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离/独立**：独立性是单元测试的一个基石原则。每个单元测试都应该在隔离状态下运行，不依赖于其他测试。测试执行的顺序或某个测试的成功或失败不应影响其他测试的结果。这种隔离确保开发者能够以专注的方式定位和解决问题，简化调试过程。遵循独立性的原则，开发者能够精确地识别问题的根源，从而加速问题的解决过程。'
- en: '**Repeatable** : The repeatability of unit tests is paramount for maintaining
    the integrity of the testing process. A unit test should consistently produce
    the same result every time it is executed. This consistency ensures reliability
    in the test results, facilitating a dependable and predictable testing environment.
    If a test fails, developers should be able to reproduce the failure consistently,
    enabling them to investigate and resolve issues with confidence. Repeatability
    is a cornerstone for establishing trust in the testing suite and the overall software
    development process.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重复性**：单元测试的可重复性对于维护测试过程的一致性至关重要。单元测试应在每次执行时始终产生相同的结果。这种一致性确保了测试结果的可信度，促进了一个可靠和可预测的测试环境。如果测试失败，开发者应该能够一致地重现失败，使他们能够自信地调查和解决问题。可重复性是建立对测试套件和整体软件开发过程信任的基础。'
- en: '**Self-validating** : Unit tests should possess self-contained criteria for
    success or failure, requiring no manual interpretation. A self-validating test
    ensures unambiguous results, reducing the potential for misinterpretation. Developers
    can quickly understand the state of the code based solely on the test results,
    streamlining the debugging and issue-resolution processes. The self-validating
    nature of unit tests contributes to the clarity and effectiveness of the testing
    suite, enabling developers to make informed decisions based on the unambiguous
    outcomes of each test.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自我验证**：单元测试应具备成功或失败的自包含标准，无需人工解释。自我验证的测试确保结果明确，减少了误解的可能性。开发者可以仅根据测试结果快速了解代码的状态，从而简化调试和问题解决过程。单元测试的自我验证特性有助于测试套件的清晰性和有效性，使开发者能够根据每个测试的明确结果做出明智的决策。'
- en: '**Timely** : Timeliness in test writing is a critical factor in the effectiveness
    of unit testing. Ideally, tests should be authored before the corresponding code
    is implemented. This proactive approach ensures that tests serve as a living specification
    for the desired behavior, guiding the implementation process. Writing tests in
    a timely manner establishes a foundation for a well-defined and controlled development
    cycle. Timely testing also plays a pivotal role in identifying and addressing
    issues early in the development cycle, reducing the likelihood of defects propagating
    to later stages of the software development process. Embracing timely testing
    enhances the overall efficiency and reliability of the software development life
    cycle.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**及时性**：测试编写的及时性是单元测试有效性的关键因素。理想情况下，测试应该在相应的代码实现之前编写。这种主动的方法确保测试作为期望行为的活生生的规范，指导实现过程。及时编写测试为定义明确和受控的开发周期奠定了基础。及时测试在开发周期早期识别和解决问题上也发挥着关键作用，减少了缺陷传播到软件开发后期阶段的可能性。采用及时测试可以增强整个软件开发生命周期的效率和可靠性。'
- en: Now that we’ve established a foundational understanding of unit testing and
    its principles, let’s turn our attention to the broader context of TDD.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了单元测试及其原则的基础理解，让我们将注意力转向TDD的更广泛背景。
- en: TDD – unifying principles for software quality
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD – 软件质量统一原则
- en: These F.I.R.S.T principles seamlessly pave the way to an overarching methodology
    known as TDD. TDD merges design, development, and testing into a unified framework,
    providing developers with a comprehensive approach to not only crafting simple
    and clean code but also ensuring thorough testing. The incremental development
    approach systematically tests all facets of business logic, making TDD the gold
    standard for creating high-quality software. It embodies the best coding and design
    practices throughout the entire process.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些F.I.R.S.T原则无缝地铺平了通往一个称为TDD的总体方法的道路。TDD将设计、开发和测试合并到一个统一的框架中，为开发者提供了一种全面的方法，不仅能够编写简单和干净的代码，还能确保彻底的测试。增量开发方法系统地测试了业务逻辑的所有方面，使TDD成为创建高质量软件的黄金标准。它在整个过程中体现了最佳的编码和设计实践。
- en: 'The main purpose of TDD is to achieve simpler and more reliable code. For that,
    TDD follows a simple and effective process, illustrated by the **red-green-refactor
    cycle** :'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的主要目的是实现更简单、更可靠的代码。为此，TDD遵循一个简单而有效的过程，即**红-绿-重构周期**：
- en: '![Figure 1.1 – The TDD cycle](img/B22218_01_1.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – TDD周期](img/B22218_01_1.jpg)'
- en: Figure 1.1 – The TDD cycle
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – TDD周期
- en: 'Let’s understand this TDD cycle in more detail:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解这个TDD周期：
- en: '**Red – writing a** **failing test** :'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红色 – 编写一个** **失败的测试** :'
- en: In the first phase of TDD, known as the Red phase, developers embark on the
    journey by articulating their intent through the creation of a failing test. This
    test specifically targets a small unit of functionality that has not yet been
    implemented. It serves as a tangible expression of the desired behavior, essentially
    outlining the expectations for the code that is yet to be written. It is important
    to note that, at this stage, the test is expected to fail since the corresponding
    functionality is absent from the code base.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在TDD的第一个阶段，称为红阶段，开发者通过创建一个失败的测试来开始他们的旅程。这个测试专门针对尚未实现的小功能单元。它作为期望行为的具体表达，本质上概述了尚未编写的代码的期望。重要的是要注意，在这个阶段，测试预计会失败，因为相应的功能尚未存在于代码库中。
- en: The primary purpose of the Red phase is to set a clear objective for the subsequent
    development process. By initially focusing on the expected outcome without any
    code in place, developers define a roadmap for the functionality they are about
    to implement. This intentional act of writing a test before writing the code not
    only establishes a specification for the upcoming functionality but also helps
    solidify the developer’s understanding of the problem at hand.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 红阶段的主要目的是为后续的开发过程设定一个明确的目标。通过最初专注于预期结果而不放置任何代码，开发者为即将实施的功能制定了路线图。在编写代码之前先编写测试的这种有意行为不仅为即将到来的功能建立了规范，还有助于巩固开发者对当前问题的理解。
- en: '**Green – writing the minimum amount of code to pass** **the test** :'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色 – 编写通过测试所需的最小代码**：'
- en: Following the Red phase, the development process proceeds to the Green phase.
    Here, the developer crafts the minimal amount of code necessary to make the previously
    written test pass successfully. The emphasis during this phase is on simplicity
    and efficiency. The goal is not to create an elaborate solution but to address
    the immediate requirement highlighted by the failing test.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在红阶段之后，开发过程进入绿色阶段。在这里，开发者编写必要的最小代码，使之前编写的测试成功通过。这个阶段的重点是简洁和效率。目标是不要创建复杂的解决方案，而是解决失败测试所突出的即时需求。
- en: By concentrating on the bare minimum code required for success, developers foster
    a culture of simplicity and avoid unnecessary complexities. This focused approach
    encourages the creation of code that meets the specific needs outlined by the
    test, laying the foundation for a solution that is both functional and concise.
    The success of the test in this phase signifies the achievement of the targeted
    functionality, validating the initial expectations set in the Red phase.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过专注于实现成功所需的最小代码量，开发者培养了一种简洁的文化，避免了不必要的复杂性。这种专注的方法鼓励创建满足测试具体需求的代码，为既功能性强又简洁的解决方案奠定基础。在这个阶段测试的成功表明了目标功能的实现，验证了在红阶段设定的初始期望。
- en: '**Refactor – refactoring** **the code** :'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构 – 重构代码**：'
- en: With a passing test in place, the development process enters the Refactor phase.
    At this juncture, the developer takes a step back to review and enhance the code
    that has been implemented. The primary objectives during refactoring are to improve
    the maintainability, readability, and extensibility of the code without altering
    its functionality.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在测试通过后，开发过程进入重构阶段。在这个阶段，开发者会退后一步，回顾并增强已经实现的代码。重构的主要目标是在不改变其功能的前提下，提高代码的可维护性、可读性和可扩展性。
- en: Refactoring is a critical aspect of TDD as it ensures that the code base remains
    clean and adaptable to future changes. Developers strive to eliminate redundancies,
    improve naming conventions, and apply design patterns where appropriate. This
    phase reinforces the commitment to producing not only functional but also well-crafted
    code. The successful completion of this phase sets the stage for a code base that
    is not only effective but also sustainable in the long run.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重构是TDD的关键方面，因为它确保代码库保持清洁并适应未来的变化。开发者努力消除冗余，改进命名约定，并在适当的地方应用设计模式。这个阶段强化了生产不仅功能性强而且精心制作的代码的承诺。这个阶段的成功完成为长期有效的代码库奠定了基础。
- en: '**Repeat –** **iterative process** :'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复 – 迭代过程**：'
- en: TDD follows an iterative approach, and the Repeat phase encapsulates the cyclical
    nature of this development methodology. The entire Red-Green-Refactor cycle is
    repeated for each new piece of functionality that needs to be implemented. This
    iterative process ensures a systematic and gradual evolution of the code base,
    with each cycle contributing to the overall development of the software.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TDD遵循迭代方法，重复（Repeat）阶段封装了这种开发方法的循环性质。对于需要实现的新功能，整个红-绿-重构（Red-Green-Refactor）周期都会重复进行。这种迭代过程确保代码库的系统性和渐进式演变，每个周期都对软件的整体开发做出贡献。
- en: By repeating the cycle, developers continually refine and expand the application,
    responding to evolving requirements and ensuring that the code remains aligned
    with the project’s objectives. This iterative nature of TDD promotes adaptability
    and agility, making it a valuable methodology for projects with changing or evolving
    requirements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重复循环，开发者不断改进和扩展应用程序，响应不断变化的需求，并确保代码与项目目标保持一致。TDD的这种迭代性质促进了适应性和敏捷性，使其成为具有变化或发展需求的项目的一种有价值的开发方法。
- en: This approach not only ensures the creation of functional software but also
    cultivates a mindset of continuous improvement and adaptability in the development
    process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不仅确保创建出功能软件，而且培养了在开发过程中的持续改进和适应性思维模式。
- en: AAA pattern – a structured approach to testing
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AAA模式 - 测试的结构化方法
- en: Building upon the principles of TDD and F.I.R.S.T, another key methodology in
    the realm of unit testing is the **Arrange-Act-Assert** ( **AAA** ) pattern. This
    pattern provides a uniform structure for organizing tests within a suite. The
    AAA pattern contributes significantly to the readability and maintainability of
    test suites, aligning seamlessly with the overarching goals of TDD.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在TDD和F.I.R.S.T原则的基础上，单元测试领域中的另一个关键方法是**安排-行动-断言**（**AAA**）模式。该模式为测试套件内的测试组织提供了一个统一的结构。AAA模式对测试套件的可读性和可维护性做出了重大贡献，与TDD的总体目标无缝对接。
- en: 'The AAA pattern breaks down a test into three distinct sections:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: AAA模式将测试分解为三个不同的部分：
- en: '**Arrange** : This section is about setting up the test environment.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安排**：本节涉及设置测试环境。'
- en: In the Arrange section, the focus is on preparing the environment for the test.
    This involves setting up the objects to be tested, bringing the **System under
    Test** ( **SUT** ) to a specific state, and configuring any dependencies. Whether
    instantiating objects directly or preparing test doubles dependencies, the goal
    is to establish a controlled and consistent starting point for the test.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在安排（Arrange）部分，重点是准备测试环境。这包括设置要测试的对象，将**系统单元**（**SUT**）带到特定状态，并配置任何依赖项。无论是直接实例化对象还是准备测试替身依赖项，目标都是为测试建立一个受控和一致的开始点。
- en: '**Act** : This section is about performing the action on the SUT.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行动**：本节涉及在系统单元（SUT）上执行操作。'
- en: The Act section is where the actual interaction with the SUT takes place. This
    involves invoking a method or action on the SUT, passing any required dependencies,
    and capturing the output value, if applicable. The Act phase is crucial for simulating
    the real-world usage of the system and observing its behavior.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 行动（Act）部分是实际与系统单元（SUT）交互的地方。这包括在系统单元上调用方法或执行操作，传递任何必需的依赖项，并在适用的情况下捕获输出值。行动阶段对于模拟系统的实际使用和观察其行为至关重要。
- en: '**Assert** : This section focuses on verifying the expected outcome.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：本节专注于验证预期的结果。'
- en: In the Assert section, the test makes explicit claims about the expected outcome.
    This may include checking the return value, inspecting the final state of the
    SUT and its collaborators, or verifying the methods called on them. The Assert
    phase is the culmination of the test, ensuring that the behavior aligns with the
    anticipated results.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在断言（Assert）部分，测试对预期的结果做出明确声明。这可能包括检查返回值、检查系统单元及其协作者的最终状态，或验证调用在它们上的方法。断言阶段是测试的总结，确保行为与预期结果一致。
- en: The AAA pattern’s structured approach provides clarity and consistency across
    all tests in a suite. By adhering to this pattern, developers can easily comprehend
    and navigate through tests, ultimately reducing the maintenance cost of the entire
    test suite. Whether starting with Arrange, Act, or Assert, the AAA pattern accommodates
    different testing styles while promoting a unified and systematic testing methodology.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: AAA 模式的结构化方法为套件中所有测试提供了清晰和一致性。通过遵循此模式，开发者可以轻松理解并导航测试，从而降低整个测试套件的维护成本。无论从 Arrange、Act
    还是 Assert 开始，AAA 模式都能适应不同的测试风格，同时促进统一和系统的测试方法。
- en: Now that we’ve had a tour of unit testing and TDD, let’s dive in and see how
    to create a unit test project within Visual Studio.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经对单元测试和 TDD 进行了简要的介绍，让我们深入探讨如何在 Visual Studio 中创建单元测试项目。
- en: Setting up unit testing in Visual Studio 2022
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2022 中设置单元测试
- en: In this section, we will first create a unit test project within Visual Studio.
    Once that is done, we’ll go through an overview of the **Test Explorer** view
    and its main options. The **Test Explorer** view serves as a central hub for all
    testing activities within the IDE, offering a comprehensive overview of our test
    suite’s status and performance. It allows us to easily navigate through test results,
    identify failures, and access detailed information about each test case.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先在 Visual Studio 中创建一个单元测试项目。一旦完成，我们将概述**测试资源管理器**视图及其主要选项。**测试资源管理器**视图充当
    IDE 中所有测试活动的中心枢纽，提供对我们测试套件状态和性能的全面概述。它允许我们轻松导航测试结果，识别失败，并访问每个测试用例的详细信息。
- en: Creating a unit test project
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建单元测试项目
- en: 'Visual Studio and .NET support three testing frameworks:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 和 .NET 支持三种测试框架：
- en: '**MSTest** : This is the default testing framework provided by Microsoft for
    .NET applications. It’s fully integrated into Visual Studio and offers features
    for writing and running tests within the IDE.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MSTest**：这是 Microsoft 为 .NET 应用提供的默认测试框架。它完全集成到 Visual Studio 中，并提供在 IDE
    中编写和运行测试的功能。'
- en: '**NUnit** : This is a popular open-source testing framework for .NET applications.
    It provides a flexible and extensible platform for writing and executing tests
    and is widely used in the . NET community.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NUnit**：这是 .NET 应用中流行的开源测试框架。它提供了一个灵活且可扩展的平台来编写和执行测试，并在 .NET 社区中得到广泛应用。'
- en: '**xUnit** : This is another open-source testing framework for .NET applications.
    It follows a more modern and flexible approach compared to MSTest and NUnit and
    is gaining popularity among . NET developers.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**xUnit**：这是另一个用于 .NET 应用的开源测试框架。与 MSTest 和 NUnit 相比，它采用更现代和灵活的方法，并且在 .NET
    开发者中越来越受欢迎。'
- en: 'First, you need to create a new project for your test set, in the solution
    containing the project we want to test. Right-click on your solution and select
    **Add** | **New Project...** . This will take you to the following screen:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要为你的测试集创建一个新的项目，在包含我们想要测试的项目解决方案中。右键单击你的解决方案，然后选择**添加** | **新建项目...**。这将带您进入以下屏幕：
- en: '![Figure 1.2 – Adding a new test project](img/B22218_01_2.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 添加新的测试项目](img/B22218_01_2.jpg)'
- en: Figure 1.2 – Adding a new test project
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 添加新的测试项目
- en: I filtered this view by the three top dropdowns to keep displaying the template
    projects for testing available by default in Visual Studio. You may notice that
    the last two templates on the list mention **Playwright** . Playwright is a library
    that enables end-to-end testing for modern web apps. With it, you can create unit
    tests to assess the functionality of your user interface.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过三个顶部下拉菜单过滤了这个视图，以保持默认显示在 Visual Studio 中可用的测试模板项目。你可能注意到列表中的最后两个模板提到了**Playwright**。Playwright
    是一个库，它使现代 Web 应用能够进行端到端测试。使用它，你可以创建单元测试来评估用户界面的功能。
- en: Since xUnit is the most used framework in the industry, we will focus on it
    for our examples.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 xUnit 是行业中最常用的框架，我们将专注于它来展示我们的示例。
- en: 'Another way to create your unit test project is by right-clicking directly
    on your class in your code base and selecting **Create Unit Tests** from the menu:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建单元测试项目的另一种方法是直接在代码库中右键单击你的类，然后从菜单中选择**创建单元测试**：
- en: '![Figure 1.3 – Selecting Create Unit Tests from the menu](img/B22218_01_3.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 从菜单中选择创建单元测试](img/B22218_01_3.jpg)'
- en: Figure 1.3 – Selecting Create Unit Tests from the menu
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 从菜单中选择创建单元测试
- en: 'This action will open a menu that allows you to configure your unit test project:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作将打开一个菜单，允许您配置您的单元测试项目：
- en: '![Figure 1.4 – The Create Unit Tests window](img/B22218_01_4.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 创建单元测试窗口](img/B22218_01_4.jpg)'
- en: Figure 1.4 – The Create Unit Tests window
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 创建单元测试窗口
- en: By default, this allows you to create an MSTestv2 project, but you can install
    additional extensions to use other frameworks. If you already have a unit tests
    project created, you may add your test methods to it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这允许您创建一个MSTestv2项目，但您可以安装额外的扩展来使用其他框架。如果您已经创建了一个单元测试项目，您可以将测试方法添加到其中。
- en: Regardless of how you create them, all the tests in this project can be managed
    in the **Test Explorer** view and we will explore it in the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您如何创建它们，本项目中所有测试都可以在**测试探索器**视图中进行管理，我们将在下一节中探讨它。
- en: Overview of the Test Explorer view
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试探索器视图概述
- en: Test Explorer serves as a powerful and centralized tool in Visual Studio 2022,
    facilitating the management and execution of unit tests. This feature-rich window
    allows developers to seamlessly view, organize, and run their unit tests within
    the **Integrated Development** **Environment** ( **IDE** ).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 测试探索器在Visual Studio 2022中作为强大的集中式工具，简化了单元测试的管理和执行。这个功能丰富的窗口允许开发者无缝地查看、组织和运行他们的单元测试，在**集成开发环境**（**IDE**）中。
- en: 'To access Test Explorer, there are two options:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问测试探索器，有两种选择：
- en: You can navigate to the **Test** menu in Visual Studio or utilize the convenient
    keyboard shortcut accessed by pressing *Ctrl* + *E* , releasing them, and then
    pressing *T* .
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在Visual Studio中导航到**测试**菜单，或利用通过按下*Ctrl* + *E*，释放它们，然后按下*T*键可访问的方便的键盘快捷键。
- en: Since version 17.6, you can use the **all-in-one search** feature to quickly
    access all the features provided by Visual Studio. Simply open an all-in-one search
    using the *Ctrl* + *Q* shortcut, type **Test Explorer** , then press *Enter* ,
    and you’ll be directed to the **Test** **Explorer** window.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自17.6版本以来，您可以使用**一站式搜索**功能快速访问Visual Studio提供的所有功能。只需使用*Ctrl* + *Q*快捷键打开一站式搜索，输入**测试探索器**，然后按*Enter*键，您将被导向**测试探索器**窗口。
- en: 'Here’s a visualization of the **Test** **Explorer** window:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**测试探索器**窗口的视觉展示：
- en: '![Figure 1.5 – The Test Explorer window](img/B22218_01_5.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 测试探索器窗口](img/B22218_01_5.jpg)'
- en: Figure 1.5 – The Test Explorer window
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 测试探索器窗口
- en: 'The **Test Explorer** console provides a clear and organized view of all available
    tests, making it easy for developers to navigate through their test suites. This
    interface offers advanced functionality for test management, such as the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试探索器**控制台提供了所有可用测试的清晰和组织视图，使得开发者能够轻松地浏览他们的测试套件。此界面提供了测试管理的先进功能，例如以下内容：'
- en: '**Categorize and group tests** : Utilize attributes and categories to group
    tests based on functional areas, features, or specific requirements. This helps
    in creating a logical hierarchy and makes it easier to focus on specific subsets
    of tests. By default, tests are grouped based on **Project** , followed by **Namespace**
    , and then **Class** . If you wish to modify the organization of your tests, simply
    click on the **Group By** button in Test Explorer and choose a new grouping criterion:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分类和分组测试**：利用属性和类别根据功能区域、功能或特定要求对测试进行分组。这有助于创建逻辑层次结构，并使关注特定测试子集变得更容易。默认情况下，测试基于**项目**分组，然后是**命名空间**，接着是**类**。如果您想修改测试的组织结构，只需在测试探索器中点击**按组**按钮并选择一个新的分组标准：'
- en: '![Figure 1.6 – Test Explorer – Group By](img/B22218_01_6.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 测试探索器 – 按组](img/B22218_01_6.jpg)'
- en: Figure 1.6 – Test Explorer – Group By
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 测试探索器 – 按组
- en: 'Here is the description of the groups you can choose from:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您可以选择的分组描述：
- en: '**Duration** : Groups tests by execution time: **Fast** , **Medium** , and
    **Slow**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续时间**：按执行时间分组：**快速**、**中等**和**慢速**'
- en: '**State** : Groups tests by execution results: **Failed Tests** , **Skipped
    Tests** , **Passed Tests** , and **Not Run**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：按执行结果分组测试：**失败的测试**、**跳过的测试**、**通过的测试**和**未运行的测试**'
- en: '**Target Framework** : Groups tests by the framework their projects’ target'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标框架**：按项目目标框架分组测试'
- en: '**Namespace** : Groups tests by the containing namespace'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**：按包含的命名空间分组测试'
- en: '**Project** : Groups tests by the containing project'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目**：按包含的项目分组测试'
- en: '**Class** : Groups tests by the containing class'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：按包含的类分组测试'
- en: '**Filtering and searching** : With a large code base, locating specific tests
    can be challenging. Test Explorer offers filtering options and a powerful search
    functionality.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤和搜索**：在大型代码库中，定位特定测试可能具有挑战性。测试资源管理器提供过滤选项和强大的搜索功能。'
- en: '![Figure 1.7 – Test Explorer – applying a search filter](img/B22218_01_7.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – 测试资源管理器 – 应用搜索过滤器](img/B22218_01_7.jpg)'
- en: Figure 1.7 – Test Explorer – applying a search filter
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 测试资源管理器 – 应用搜索过滤器
- en: You can enter a command in the textbox, such as **Namespace:""** or any other
    filter criteria you wish to use for your search. Additionally, you can directly
    click on the provided command to initiate your filtering.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文本框中输入命令，例如 **命名空间:""** 或您希望用于搜索的任何其他过滤标准。此外，您可以直接点击提供的命令来启动过滤。
- en: '**Creating a playlist** : You can create and manage playlists of tests in Visual
    Studio to organize and run specific sets of tests. To create a playlist, select
    one or more tests in Test Explorer, right-click, and choose **Add to Playlist**
    | **New Playlist** .'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建播放列表**：您可以在 Visual Studio 中创建和管理测试播放列表，以组织和运行特定的测试集。要创建播放列表，请在测试资源管理器中选择一个或多个测试，右键单击，然后选择
    **添加到播放列表** | **新建播放列表**。'
- en: '![Figure 1.8 – Test Explorer – Add to Playlist](img/B22218_01_8.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 测试资源管理器 – 添加到播放列表](img/B22218_01_8.jpg)'
- en: Figure 1.8 – Test Explorer – Add to Playlist
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 测试资源管理器 – 添加到播放列表
- en: The playlist opens in a new **Test Explorer** tab, where you can save it with
    a name and location. You can edit playlists by adding or removing tests, and you
    can use the **Edit** button to manage tests more conveniently with checkboxes.
    Playlists can be dynamic, and automatically updated based on the tests included
    or excluded. They can be saved as XML files and edited manually if needed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 播放列表在新 **测试资源管理器** 选项卡中打开，您可以为其命名并指定位置。您可以通过添加或删除测试来编辑播放列表，并可以使用 **编辑** 按钮通过复选框更方便地管理测试。播放列表可以是动态的，并基于包含或排除的测试自动更新。它们可以保存为
    XML 文件，如果需要可以手动编辑。
- en: Now we have had an overview of the **Test Explorer** view, let’s explore a preview
    functionality of Visual Studio 2022 and create a test using it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 **测试资源管理器** 视图有了概述，让我们探索 Visual Studio 2022 的预览功能并使用它创建一个测试。
- en: Creating a test with IntelliTest
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IntelliTest 创建测试
- en: In this section, our goal is to explore how to use IntelliTest for creating
    tests. For that, we will first learn how to enable the IntelliTest functionality.
    Next, we will learn how to execute it and generate tests with it. At the end of
    the section, we will learn how to organize our generated unit tests by saving,
    executing, and reviewing them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们的目标是探索如何使用 IntelliTest 创建测试。为此，我们首先将学习如何启用 IntelliTest 功能。接下来，我们将学习如何执行它并使用它生成测试。在本节结束时，我们将学习如何通过保存、执行和审查来组织我们生成的单元测试。
- en: IntelliTest offers characterization tests, allowing you to understand how code
    behaves through a suite of traditional unit tests. This suite can serve as a regression
    suite, aiding in handling the challenges of refactoring legacy or unfamiliar code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliTest 提供特征测试，允许您通过一系列传统的单元测试来了解代码的行为。这个套件可以作为回归测试套件，帮助处理重构旧代码或未知代码的挑战。
- en: Through guided test input generation, IntelliTest employs an open-code analysis
    and constraint-solving approach to automatically produce precise test input values,
    often without requiring user intervention. It generates factories for complex
    object types and allows customization of these factories to meet specific requirements.
    Assertions specified as correctness properties in the code are utilized to further
    direct test input generation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引导测试输入生成，IntelliTest 采用开放代码分析和约束求解方法自动生成精确的测试输入值，通常无需用户干预。它为复杂对象类型生成工厂，并允许自定义这些工厂以满足特定要求。代码中指定的正确性断言被用于进一步指导测试输入生成。
- en: Integrated seamlessly into the Visual Studio IDE, IntelliTest provides a cohesive
    environment for test suite generation. Information gathered during test suite
    creation, including automatically generated inputs, code outputs, and generated
    test cases, as well as their pass or fail statuses, is readily available within
    Visual Studio. This integration enables easy iteration between code refinement
    and IntelliTest reruns without leaving the IDE. Test results can be saved as a
    unit test project within the solution and are automatically recognized by Visual
    Studio Test Explorer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'IntelliTest is available in Visual Studio Enterprise Edition. It systematically
    explores the code base, generating test data and unit tests for each method to
    ensure comprehensive code coverage and validate code behavior. As of the time
    of writing, IntelliTest is a preview feature in Visual Studio 17.9, so you must
    enable it from the **Options** menu by following these steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Tools** | **Options** | **Manage** **Preview Features** .
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **IntelliTest support for NetFx and Net6 using Z3 v4** option under
    **Preview Features** .
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Enable Preview Features – Intellitest](img/B22218_01_9.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Enable Preview Features – Intellitest
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Once enabled, we can explore how IntelliTest works. For example, I’ve created
    a public class implementing **FizzBuzz** . To generate tests with IntelliTest
    for the class, right-click on the class name, find the **IntelliTest (Preview)**
    option, and then select **Generate Tests** :'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – IntelliTest – Generate Tests](img/B22218_01_10.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – IntelliTest – Generate Tests
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: IntelliTest execution and test generation
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IntelliTest executes our code multiple times using various inputs. Each execution
    is documented in a table, displaying the input test data along with the corresponding
    output or any exceptions that occur.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – Generating tests with IntelliTest](img/B22218_01_11.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Generating tests with IntelliTest
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: After test generation, we can access the test project and examine the parameterized
    unit tests that have been generated.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Saving, executing, and reviewing unit tests
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We may choose the unit tests we want to keep and use the save option to save
    them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12 – IntelliTest’s save option](img/B22218_01_12.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: Figure 1.12 – IntelliTest’s save option
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The select box in the top-left corner of the window allows you to filter through
    all the methods of the class. The individual unit tests, associated with each
    row, are stored in the **.g.cs** file within the test project, while the parameterized
    unit test is stored in its respective **.** **cs** file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – IntelliTest – unit test project](img/B22218_01_13.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: Figure 1.13 – IntelliTest – unit test project
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: We can execute these unit tests and review the outcomes using Test Explorer,
    just as we would handle manually created unit tests.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Similar to classic unit tests, we can generate the project without running IntelliTest
    first by choosing the option in the menu.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与经典单元测试类似，我们可以通过选择菜单中的选项来生成项目，而无需首先运行IntelliTest。
- en: Using IntelliTest to generate tests from your code base is a valuable tool,
    especially for legacy projects and non-regression testing. Now, let’s move forward
    with a real-world example to illustrate how to implement TDD within Visual Studio.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IntelliTest从您的代码库中生成测试是一个非常有价值的工具，特别是对于遗留项目和回归测试。现在，让我们通过一个真实世界的例子来说明如何在Visual
    Studio中实现TDD。
- en: Practicing TDD with a real-world example
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过真实世界的例子练习TDD
- en: In TDD, everything begins with the specification and a thorough understanding
    of the intended functionality. It’s essential to grasp the meaning of what we
    want to accomplish in order to write effective tests. With that in mind, let’s
    establish a scenario for our example.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD中，一切从规格说明和对预期功能的彻底理解开始。为了编写有效的测试，理解我们想要完成的意义是至关重要的。考虑到这一点，让我们为我们的示例建立一个场景。
- en: We’ll create a **ValidateMail** method that will process email verification.
    Our goal here is to explore the tools available in Visual Studio to enhance our
    TDD experience.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个**ValidateMail**方法来处理电子邮件验证。我们的目标是探索Visual Studio中可用的工具，以增强我们的TDD（测试驱动开发）体验。
- en: 'Now that we have outlined our requirements, our next step is to begin by creating
    our unit test project. For this, we’ll choose xUnit, as discussed earlier in this
    chapter. We will create an empty Class Library Project:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了我们的需求，我们的下一步是开始创建我们的单元测试项目。为此，我们将选择xUnit，正如本章前面所讨论的。我们将创建一个空的类库项目：
- en: 'We’ll start by writing a test, in our xUnit project, that specifies the behavior
    or functionality we want to implement:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在xUnit项目中编写一个测试，指定我们想要实现的行为或功能：
- en: '[PRE0]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first thing we’ll notice when writing this code is that our test doesn’t
    compile because the **User** class doesn’t exist yet in our Class Library Project.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们编写这段代码时，我们首先会注意到我们的测试无法编译，因为我们的类库项目中还没有**User**类。
- en: We’ll leverage the power of IntelliSense to create our class and its method.
    IntelliSense is an integrated code completion tool within Visual Studio, offering
    various features such as List Members, Parameter Info, Quick Info, and Complete
    Word. These functionalities facilitate a deeper understanding of the code being
    utilized, assist in managing typed parameters, and enable the quick addition of
    calls to properties and methods with minimal keystrokes.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将利用IntelliSense的强大功能来创建我们的类及其方法。IntelliSense是Visual Studio中集成的代码补全工具，提供各种功能，如列出成员、参数信息、快速信息和完成单词。这些功能有助于更深入地理解正在使用的代码，帮助管理键入参数，并允许通过最少的按键快速添加对属性和方法的调用。
- en: 'Place the cursor on the **User()** class and expand the IntelliSense menu,
    selecting the **Generate new type…** quick action:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标放在**User()**类上，展开IntelliSense菜单，选择**生成新类型…**快速操作：
- en: '![Figure 1.14 – Generate new type...](img/B22218_01_14.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图1.14 – 生成新类型...](img/B22218_01_14.jpg)'
- en: Figure 1.14 – Generate new type...
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 – 生成新类型...
- en: This will open a window where we can choose the accessibility ( **Default**
    , **Internal** , or **Public** ), the kind ( **Class** or **Struct** ), the project,
    and whether to create a new file or use an existing one. Since we selected our
    Class Library project, the accessibility of our new class is obviously set to
    **Public** .
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开一个窗口，我们可以选择可访问性（**默认**、**内部**或**公共**）、类型（**类**或**结构**）、项目，以及是否创建新文件或使用现有文件。由于我们选择了我们的类库项目，我们新类的可访问性显然设置为**公共**。
- en: '![Figure 1.15 – The Generate Type window](img/B22218_01_15.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图1.15 – 生成类型窗口](img/B22218_01_15.jpg)'
- en: Figure 1.15 – The Generate Type window
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15 – 生成类型窗口
- en: 'Now, in the same way, we will use IntelliSense to create our **ValidateMail()**
    method:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，以同样的方式，我们将使用IntelliSense来创建我们的**ValidateMail()**方法：
- en: '![Figure 1.16 – Generate method ValidateMail’](img/B22218_01_16.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图1.16 – 生成方法ValidateMail’](img/B22218_01_16.jpg)'
- en: Figure 1.16 – Generate method ValidateMail’
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16 – 生成方法ValidateMail’
- en: With that done, our test is built, but it still fails because we have yet to
    fix its behavior.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，我们的测试已经构建，但它仍然失败，因为我们还没有修复其行为。
- en: 'Here’s our **User** class with the minimum amount of code to make our test
    pass:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的**User**类，包含使测试通过所需的最少代码：
- en: '[PRE1]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we have a **ValidateMail** method returning **true** that should respect
    the specification of our test.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个返回**true**的**ValidateMail**方法，它应该遵守我们的测试规格说明。
- en: You can use the quick access feature, above your method, to run the unit test
    without going to the **Test** **Explorer** view.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用位于方法上方的高级访问功能来运行单元测试，而无需进入**测试资源管理器**视图。
- en: '![Figure 1.17 – Using the quick access tool to run a test](img/B22218_01_17.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图1.17 – 使用快速访问工具运行测试](img/B22218_01_17.jpg)'
- en: Figure 1.17 – Using the quick access tool to run a test
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.17 – 使用快速访问工具运行测试
- en: 'Here we are; our first test is green. We can write the second testing class
    that will handle the cases where our **ValidateMail()** must return **false**
    . For that, we will use the **Theory** and **InlineData** xUnit attributes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里了；我们的第一个测试是绿色的。我们可以编写第二个测试类，该类将处理我们的**ValidateMail()**必须返回**false**的情况。为此，我们将使用**Theory**和**InlineData**
    xUnit属性：
- en: '[PRE2]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We are up for another iteration, from red to green. Here’s the method with
    the minimum amount of code to make the unit test pass:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备进行另一轮迭代，从红色变为绿色。以下是使单元测试通过所需的最少代码的方法：
- en: '[PRE3]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we are checking each condition of our test method, with one **If** for
    each test to make it pass.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在检查测试方法的每个条件，每个测试都有一个**If**来使其通过。
- en: As you can see, our approach maintains a naïve and simple perspective. Now,
    it’s time to enter the refactor phase of our TDD process. For that, we will explore
    a feature of Visual Studio named Live Unit Test.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的方法保持了一种天真而简单的视角。现在，是时候进入我们TDD流程的重构阶段了。为此，我们将探索Visual Studio的一个名为实时单元测试的功能。
- en: Automating your tests with Live Unit Test
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实时单元测试自动化测试
- en: In this section, we will explore the capabilities of automating testing with
    Live Unit Test. First, we will learn how to configure Live Unit Testing. Then,
    we will see how to launch it
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索使用实时单元测试自动化测试的功能。首先，我们将学习如何配置实时单元测试。然后，我们将看到如何启动它
- en: Live Unit Testing revolutionizes the testing process by automatically executing
    unit tests in real-time as you make code changes. This dynamic feature provides
    developers with the ability to refactor and modify code with increased confidence.
    By automatically running all affected tests during code editing, Live Unit Testing
    ensures that any changes made do not introduce regressions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 实时单元测试通过在您进行代码更改时自动执行单元测试来革新测试过程。这个动态功能为开发者提供了重构和修改代码的信心。通过在代码编辑期间自动运行所有受影响的测试，实时单元测试确保所做的任何更改都不会引入回归。
- en: Furthermore, Live Unit Testing offers insights into the adequacy of test coverage
    for your code base. It visually presents code coverage in real-time, allowing
    developers to quickly identify areas where tests are lacking.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，实时单元测试可以提供有关代码库测试覆盖率充分性的见解。它实时地以可视化的方式呈现代码覆盖率，使开发者能够快速识别测试不足的区域。
- en: Let’s activate this feature by navigating to **Test** | **Live Unit Testing**
    | **Start** .
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到**测试** | **实时单元测试** | **启动**来激活此功能。
- en: '![Figure 1.18 – Start Live Unit Testing](img/B22218_01_18.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图1.18 – 开始实时单元测试](img/B22218_01_18.jpg)'
- en: Figure 1.18 – Start Live Unit Testing
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.18 – 开始实时单元测试
- en: 'When you launch Live Unit Testing for the first time, the configuration window
    will open up:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次启动实时单元测试时，配置窗口将打开：
- en: '![Figure 1.19 – Configure Live Unit Testing](img/B22218_01_19.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图1.19 – 配置实时单元测试](img/B22218_01_19.jpg)'
- en: Figure 1.19 – Configure Live Unit Testing
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.19 – 配置实时单元测试
- en: Configuring Live Unit Testing
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置实时单元测试
- en: When Live Unit Testing is deactivated, you can access the setup wizard by navigating
    to **Test** | **Live Unit Testing** | **Configure Live** **Unit Testing** .
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当实时单元测试被禁用时，您可以通过导航到**测试** | **实时单元测试** | **配置实时单元测试**来访问设置向导。
- en: During a Live Unit Testing operation, a workspace — a duplicate of the original
    repository — is established. Any modifications made in Visual Studio that are
    not yet saved are integrated into this workspace. Subsequently, Live Unit Testing
    initiates a build, conducts a test run, and furnishes the latest code coverage
    report.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时单元测试操作期间，会建立一个工作区——原始存储库的副本。在Visual Studio中进行的任何尚未保存的修改都将集成到这个工作区中。随后，实时单元测试启动构建，执行测试运行，并提供最新的代码覆盖率报告。
- en: The initial setup in the wizard should address file copying origins and destinations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 向导中的初始设置应解决文件复制源和目标。
- en: 'Let’s understand more about the settings in this wizard:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解这个向导中的设置：
- en: '**Repository root** : This is the main folder that contains all the necessary
    files for Live Unit Testing. It should include all the source code, binaries,
    and tools required for testing. If the solution file is not located within this
    root folder, adjustments may need to be made to ensure proper setup.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库根目录**：这是包含所有Live Unit Testing所需文件的主要文件夹。它应包括所有源代码、二进制文件和测试所需的工具。如果解决方案文件不在该根目录内，可能需要调整以确保正确设置。'
- en: '**Workspace folder** : This (set, by default, to **lut** for Live Unit Testing)
    is where Live Unit Testing stores a copy of the repository. By default, this root
    is created in the user’s home folder, but it can be customized based on preference
    or specific requirements.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作区文件夹**：这是Live Unit Testing存储仓库副本的位置（默认设置为**lut**用于Live Unit Testing）。默认情况下，此根目录创建在用户的家目录中，但可以根据偏好或特定要求进行自定义。'
- en: '**Excluded files** : Exclude generated artifacts from being copied to the Live
    Unit Testing workspace to prevent interference with regular builds.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排除的文件**：排除生成的工件被复制到Live Unit Testing工作区，以防止干扰常规构建。'
- en: '**Build options** : By default, Live Unit Testing utilizes multiple CPU cores
    for faster builds.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建选项**：默认情况下，Live Unit Testing使用多个CPU核心进行更快地构建。'
- en: '**Test case timeout** : This allows setting a specific time duration, after
    which tests are automatically aborted if they exceed the allotted time.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例超时**：这允许设置一个特定的时间段，在此之后，如果测试超过分配的时间，则自动终止。'
- en: '**Use multiple processors** : By default, Live Unit Testing attempts to utilize
    multiple processors for faster test execution. However, deselect this option if
    your machine experiences slowdowns or if parallel test execution causes issues,
    such as file conflicts.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用多个处理器**：默认情况下，Live Unit Testing会尝试利用多个处理器以加快测试执行速度。但是，如果您的机器出现减速或并行测试执行导致问题，如文件冲突，请取消选择此选项。'
- en: If we select **<custom>** for the **Excluded** files, we can define our own
    rules. The setup wizard will bring us to the **lutignore** file editor without
    default values filled in.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为**排除**文件选择**<自定义>**，我们可以定义自己的规则。设置向导将带我们到**lutignore**文件编辑器，其中不填充默认值。
- en: '![Figure 1.20 – Configure lutignore file](img/B22218_01_20.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图1.20 – 配置lutignore文件](img/B22218_01_20.jpg)'
- en: Figure 1.20 – Configure lutignore file
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.20 – 配置lutignore文件
- en: Let’s get an overview of the **lutignore** file structure according to the Microsoft
    documentation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据Microsoft文档概述一下**lutignore**文件结构。
- en: 'The **lutignore** file follows the same format as a **gitignore** file. It
    should include rules that correspond to folders or files created during the build
    process, ensuring they are not copied into the workspace for Live Unit Testing.
    For most default project templates, the provided **lutignore** file is adequate:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**lutignore**文件遵循与**gitignore**文件相同的格式。它应包括与构建过程中创建的文件夹或文件相对应的规则，确保它们不会被复制到Live
    Unit Testing工作区。对于大多数默认项目模板，提供的**lutignore**文件是足够的：'
- en: '[PRE4]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These rules prevent the copying of any **BIN** or **OBJ** folders to the Live
    Unit Testing workspace.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则防止将任何**BIN**或**OBJ**文件夹复制到Live Unit Testing工作区。
- en: 'If your repository has a single build folder, specify that folder in the **ignore**
    file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的仓库只有一个构建文件夹，请在**ignore**文件中指定该文件夹：
- en: '[PRE5]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This rule ensures that the **ARTIFACTS** folder is not copied to the Live Unit
    Testing workspace.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则确保**ARTIFACTS**文件夹不会被复制到Live Unit Testing工作区。
- en: 'In cases where your repository contains additional tools within the build folder,
    those tools should also be excluded using matching patterns:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的仓库包含构建文件夹中的额外工具的情况下，也应使用匹配模式排除这些工具：
- en: '[PRE6]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first rule excludes the **ARTIFACTS** folder. The second ensures that the
    **TOOLS** subfolder within **ARTIFACTS** is copied, which may contain necessary
    tools and utilities.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则排除了**ARTIFACTS**文件夹。第二条确保**ARTIFACTS**中的**TOOLS**子文件夹被复制，其中可能包含必要的工具和实用程序。
- en: Launching Live Unit Testing
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动Live Unit Testing
- en: Now that we have configured Live Unit Testing, it is open and awaiting a playlist
    of tests to run.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了Live Unit Testing，它已打开并等待运行测试的播放列表。
- en: '![Figure 1.21 – Live Unit Testing console](img/B22218_01_21.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图1.21 – Live Unit Testing控制台](img/B22218_01_21.jpg)'
- en: Figure 1.21 – Live Unit Testing console
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.21 – Live Unit Testing控制台
- en: Use the pen icon to add your set of tests. Alternatively, you can add all your
    tests by clicking on the link at the bottom of the message.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用笔形图标添加您的测试集。或者，您也可以通过点击消息底部的链接来添加所有测试。
- en: Returning to our previous example and our **ValidateMail()** function, you can
    see green checkmarks on the left side of our code lines. These indicate that the
    code is covered by passing unit tests.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前的例子和我们的 **ValidateMail()** 函数，您可以在代码行的左侧看到绿色的勾选标记。这表明代码已被通过单元测试覆盖。
- en: '![Figure 1.22 – Live Unit Testing checkmarks](img/B22218_01_22.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.22 – 实时单元测试勾选标记](img/B22218_01_22.jpg)'
- en: Figure 1.22 – Live Unit Testing checkmarks
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.22 – 实时单元测试勾选标记
- en: Now, we can proceed to the refactoring step of our TDD iteration.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续进行我们的 TDD 迭代的重构步骤。
- en: 'First, we will concatenate all the conditions and intentionally let the tests
    fail:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将所有条件连接起来，并故意让测试失败：
- en: '[PRE7]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we update the document, Live Unit Testing automatically rebuilds and updates
    the test status indicators, changing checkmarks to red crosses.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新文档时，实时单元测试会自动重新构建并更新测试状态指示器，将勾选标记变为红色叉号。
- en: '![Figure 1.23 – Live unit test red crosses](img/B22218_01_23.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.23 – 实时单元测试红色叉号](img/B22218_01_23.jpg)'
- en: Figure 1.23 – Live unit test red crosses
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.23 – 实时单元测试红色叉号
- en: Now, we can fix our code and the checkmarks will appear automatically.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以修复我们的代码，勾选标记将自动出现。
- en: 'In our case, the process is very smooth, but in a larger code base with more
    unit tests, they may not have finished running while we have already made changes
    to the code. For this issue, you have an option in the top-level menu of Visual
    Studio: **Tools** | **Options** | **Live Unit Testing** | **General** .'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，这个过程非常顺利，但在更大的代码库和更多的单元测试中，它们可能在我们已经更改代码的情况下还没有完成运行。对于这个问题，您在 Visual
    Studio 的顶级菜单中有一个选项：**工具** | **选项** | **实时单元测试** | **常规** 。
- en: '![Figure 1.24 – Additional configuration – Live Unit Testing](img/B22218_01_24.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.24 – 额外配置 – 实时单元测试](img/B22218_01_24.jpg)'
- en: Figure 1.24 – Additional configuration – Live Unit Testing
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.24 – 额外配置 – 实时单元测试
- en: Thanks to this window, you can customize your Live Unit Testing experience according
    to your needs.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这个窗口，您可以根据您的需求自定义您的实时单元测试体验。
- en: We can see that Live Unit Testing offers a quick visualization of our code coverage.
    You can access a deeper analysis of the coverage of your code base in Visual Studio
    by navigating to the **Test** menu and selecting **Analyze Code Coverage for All
    Tests** . For more information, you can consult the Microsoft documentation at
    [https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested?view=vs-2022&tabs=csharp](https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested?view=vs-2022&tabs=csharp)
    .
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，实时单元测试为我们提供了代码覆盖率的快速可视化。您可以通过导航到 Visual Studio 的**测试**菜单并选择**分析所有测试的代码覆盖率**来访问对代码库覆盖的更深入分析。有关更多信息，您可以查阅
    Microsoft 文档，网址为 [https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested?view=vs-2022&tabs=csharp](https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested?view=vs-2022&tabs=csharp)
    。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the importance of unit testing as a non-regression
    or development process. We began with a reminder of good unit testing practices
    and TDD before exploring the functionalities offered by Visual Studio 2022 to
    enhance our productivity.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了单元测试作为非回归或开发过程的重要性。我们从提醒良好的单元测试实践和 TDD 开始，然后探讨了 Visual Studio 2022
    提供的功能，以增强我们的生产力。
- en: We provided an overview of the **Test Explorer** view, demonstrating how to
    manage and organize unit tests. Then, we delved into the new IntelliSense feature,
    which provides tools to easily add non-regression tests to legacy code bases with
    minimal effort, freeing our minds for future refactoring. Finally, we learned
    how to leverage IntelliSense tools and Live Unit Testing to facilitate our TDD
    experience.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们概述了**测试资源管理器**视图，展示了如何管理和组织单元测试。然后，我们深入探讨了新的智能感知功能，该功能提供工具，可以以最小的努力轻松地将非回归测试添加到旧代码库中，从而让我们有更多精力进行未来的重构。最后，我们学习了如何利用智能感知工具和实时单元测试来简化我们的测试驱动开发（TDD）体验。
- en: In the next chapter, we will dive deeper into the world of debugging and explore
    all that Visual Studio 2022 offers for advanced strategies.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探索调试的世界，并了解 Visual Studio 2022 为高级策略提供的所有功能。
