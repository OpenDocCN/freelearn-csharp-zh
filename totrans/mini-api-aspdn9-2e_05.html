<html><head></head><body>
  <div id="_idContainer042">
   <h1 class="chapter-number" id="_idParaDest-66">
    <a id="_idTextAnchor094">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     5
    </span>
   </h1>
   <h1 id="_idParaDest-67">
    <a id="_idTextAnchor095">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     The Middleware Pipeline
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     APIs are collections of commands that can be triggered on request.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     When a request is received, we can execute logic that is bespoke to the use case of that request.
    </span>
    <span class="koboSpan" id="kobo.3.3">
     However, a request does not instantly hit our endpoints as soon as it is received.
    </span>
    <span class="koboSpan" id="kobo.3.4">
     There is a pipeline that is first traversed before our logic can be executed and the request is eventually returned to the client.
    </span>
    <span class="koboSpan" id="kobo.3.5">
     This pipeline is called the middleware pipeline, and it is a feature set within ASP.NET that allows us to extend our APIs in a way that separates concerns, optimizes performance, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      promotes reusability.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     In this chapter, we are going to explore
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.7.1">
      An introduction
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.8.1">
       to middleware
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.9.1">
      Configuring
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.10.1">
       middleware pipelines
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      Implementing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       custom middleware
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-68">
    <a id="_idTextAnchor096">
    </a>
    <span class="koboSpan" id="kobo.13.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.14.1">
     You are encouraged to write and extend the code examples shown in this chapter to improve your practical understanding.
    </span>
    <span class="koboSpan" id="kobo.14.2">
     However, if you wish to gain access to the source code, you can obtain it from the following GitHub
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.15.1">
      link:
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.17.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-69">
    <a id="_idTextAnchor097">
    </a>
    <span class="koboSpan" id="kobo.18.1">
     An introduction to middleware
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.19.1">
      Middleware
     </span>
    </strong>
    <span class="koboSpan" id="kobo.20.1">
     as a
    </span>
    <a id="_idIndexMarker126">
    </a>
    <span class="koboSpan" id="kobo.21.1">
     concept was introduced to ASP.NET in ASP.NET Core.
    </span>
    <span class="koboSpan" id="kobo.21.2">
     Replacing the older HTTP pipeline model, which used HTTP modules and HTTP handlers, it offers a simpler and more flexible way to manage the way HTTP requests are handled
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.22.1">
      by APIs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.23.1">
     If you think of an API application as a pipeline with requests traveling through it, the concept becomes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.24.1">
      more straightforward.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.25.1">
     Middleware is
    </span>
    <a id="_idIndexMarker127">
    </a>
    <span class="koboSpan" id="kobo.26.1">
     a component that sits on the pipeline before a request is handled by an endpoint.
    </span>
    <span class="koboSpan" id="kobo.26.2">
     It is executed on every request and is part of a sequence, with components executing in the order in which they
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      were registered.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     Each middleware component has a role to play, with the ability to affect the request irrespective of the endpoint it has requested.
    </span>
    <span class="koboSpan" id="kobo.28.2">
     Each middleware component can be built in, such as routing, for example, or custom middleware, written for specific purposes such as logging or authentication, to name
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.29.1">
      a couple.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.30.1">
     Once a middleware component has completed its work, it passes the request to the next middleware component in the pipeline, until all middleware components have been traversed.
    </span>
    <span class="koboSpan" id="kobo.30.2">
     Then the request can hit the endpoint holding the code written, which has logic specific to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.31.1">
      that endpoint.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.32.1">
     Middleware progression
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.33.1">
     It’s worth noting that while it is true that middleware components pass requests on to each other in a chain, they only do this unless there is a reason for the request to be terminated, with an exception being returned.
    </span>
    <span class="koboSpan" id="kobo.33.2">
     Depending on the context, a middleware pipeline can end prematurely
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.34.1">
      by design.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.35.1">
     As you have seen in the previous chapters, endpoints must send some form of response to their clients.
    </span>
    <span class="koboSpan" id="kobo.35.2">
     Once request handling has been completed, endpoints then send the response back to the client via the middleware pipeline, where it travels once again through each middleware component in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.36.1">
      reverse order.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.37.1">
     Here is a visualization of
    </span>
    <a id="_idIndexMarker128">
    </a>
    <span class="koboSpan" id="kobo.38.1">
     an example
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      request pipeline:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer040">
     <span class="koboSpan" id="kobo.40.1">
      <img alt="Figure 5.1: An example middleware pipeline flow" src="image/B20968_05_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.41.1">
     Figure 5.1: An example middleware pipeline flow
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.42.1">
     Middleware is a very
    </span>
    <a id="_idIndexMarker129">
    </a>
    <span class="koboSpan" id="kobo.43.1">
     important aspect of not just minimal APIs but ASP.NET in general, with widespread use in web API and MVC projects.
    </span>
    <span class="koboSpan" id="kobo.43.2">
     It provides developers with a way of registering custom behavior at the application level, as a design pattern that decouples this behavior from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.44.1">
      endpoint-specific logic.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.45.1">
     For example, there are certain logs that might need to be captured every time a request is received.
    </span>
    <span class="koboSpan" id="kobo.45.2">
     This could be a log stating that a resource such as a SQL database was accessed as part of a request, or an error log if the request should not have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.46.1">
      been made.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.47.1">
     It would be inefficient to include the logging code in every endpoint as they are written, and the developer would have to remember to include the logic to capture the log message.
    </span>
    <span class="koboSpan" id="kobo.47.2">
     This is, as you can imagine, not sustainable and is a
    </span>
    <a id="_idIndexMarker130">
    </a>
    <span class="koboSpan" id="kobo.48.1">
     violation of the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.49.1">
      don’t repeat yourself
     </span>
    </strong>
    <span class="koboSpan" id="kobo.50.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.51.1">
      DRY
     </span>
    </strong>
    <span class="koboSpan" id="kobo.52.1">
     ) principle.
    </span>
    <span class="koboSpan" id="kobo.52.2">
     Using a logging middleware component means that the required log messages will be captured every time a request is received, and it only has to be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.53.1">
      configured once.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.54.1">
     This is not to say that middleware components
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.55.1">
      must
     </span>
    </em>
    <span class="koboSpan" id="kobo.56.1">
     be general in their execution.
    </span>
    <span class="koboSpan" id="kobo.56.2">
     They are classes or methods like any other and have access to the incoming request in the form of an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.57.1">
      HttpContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.58.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.58.2">
     As a result, they can scrutinize the request just like an endpoint can and execute any custom logic applicable to that request before the endpoint
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.59.1">
      is reached.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.60.1">
     Let’s look at a basic example of a middleware
    </span>
    <a id="_idIndexMarker131">
    </a>
    <span class="koboSpan" id="kobo.61.1">
     component that is created as a class.
    </span>
    <span class="koboSpan" id="kobo.61.2">
     The component simply writes to the console before calling the next component in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.62.1">
      the sequence:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.63.1">
public class MySuperSimpleMiddlewareClass
{
    private readonly RequestDelegate _next;
    public MySuperSimpleMiddlewareClass(
        RequestDelegate next)
    {
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        Console.WriteLine(
            "Request handled by middleware component");
        await _next(context);
        Console.WriteLine(
            "Response handled by middleware component");
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.64.1">
     This middleware
    </span>
    <a id="_idIndexMarker132">
    </a>
    <span class="koboSpan" id="kobo.65.1">
     class has a constructor that receives an object of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.66.1">
      RequestDelegate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.67.1">
     when the class is instantiated.
    </span>
    <span class="koboSpan" id="kobo.67.2">
     This delegate is a representation of the next middleware component in the pipeline.
    </span>
    <span class="koboSpan" id="kobo.67.3">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.68.1">
      _next()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.69.1">
     delegate can be used to call the next middleware component and continue
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.70.1">
      the sequence.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.71.1">
     Understanding how the pipeline passes control flow between each component is critical, but it’s worth nothing if we don’t know how to build our own components.
    </span>
    <span class="koboSpan" id="kobo.71.2">
     We’ll now move on to explore how you can create and configure middleware within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.72.1">
      your pipeline.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-70">
    <a id="_idTextAnchor098">
    </a>
    <span class="koboSpan" id="kobo.73.1">
     Configuring middleware pipelines
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.74.1">
     You can structure a middleware component in different ways depending on its purpose.
    </span>
    <span class="koboSpan" id="kobo.74.2">
     The previous example demonstrated the creation of a simple middleware component using a class.
    </span>
    <span class="koboSpan" id="kobo.74.3">
     Let’s explore this type of component in more detail before looking at other ways of building and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.75.1">
      registering them.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-71">
    <a id="_idTextAnchor099">
    </a>
    <span class="koboSpan" id="kobo.76.1">
     Middleware classes
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.77.1">
     Middleware classes
    </span>
    <a id="_idIndexMarker133">
    </a>
    <span class="koboSpan" id="kobo.78.1">
     need to have an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.79.1">
      Invoke
     </span>
    </strong>
    <span class="koboSpan" id="kobo.80.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.81.1">
      InvokeAsync
     </span>
    </strong>
    <span class="koboSpan" id="kobo.82.1">
     method so that they can be triggered when it is their turn.
    </span>
    <span class="koboSpan" id="kobo.82.2">
     Notice how, in the example we saw in the previous section, we have a method called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.83.1">
      _next()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.84.1">
     , passing in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.85.1">
      HttpContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.86.1">
     object that the same method received.
    </span>
    <span class="koboSpan" id="kobo.86.2">
     This is where the middleware component calls the next component in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.87.1">
      the pipeline.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.88.1">
     Once you’ve created a middleware component, you will need to add it to the pipeline.
    </span>
    <span class="koboSpan" id="kobo.88.2">
     In a minimal API, the setup of the API takes place in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.89.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.90.1">
     , with the creation of a
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.91.1">
       WebApplication
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.92.1">
      object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.93.1">
     Remember in the previous chapters when we created an instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.94.1">
      WebApplication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.95.1">
     and called it
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.96.1">
      app
     </span>
    </strong>
    <span class="koboSpan" id="kobo.97.1">
     ?
    </span>
    <span class="koboSpan" id="kobo.97.2">
     This
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.98.1">
      app
     </span>
    </strong>
    <span class="koboSpan" id="kobo.99.1">
     object has a method called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.100.1">
      UseMiddleware&lt;T&gt;()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.101.1">
     .
    </span>
    <span class="koboSpan" id="kobo.101.2">
     This allows us to tell the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.102.1">
      WebApplication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.103.1">
     object that it should use a middleware component of a specific type.
    </span>
    <span class="koboSpan" id="kobo.103.2">
     If we wanted to register our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.104.1">
      MySuperSimpleMiddleware
     </span>
    </strong>
    <span class="koboSpan" id="kobo.105.1">
     class as middleware, we would do it before we start the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.106.1">
      WebApplication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.107.1">
     object
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.108.1">
      with
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.109.1">
       app.Run()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.110.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.111.1">
WebApplicationBuilder builder =
    WebApplication.CreateBuilder(args);
var app = builder.Build();
app.UseMiddleware&lt;MySuperSimpleMiddlewareClass&gt;();
app.Run();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.112.1">
     Now that the middleware has been added to our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.113.1">
      WebApplication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.114.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.114.2">
     it will be invoked within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.115.1">
      the pipeline.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.116.1">
     Writing middleware in a class has its advantages and disadvantages.
    </span>
    <span class="koboSpan" id="kobo.116.2">
     On one hand, it might make sense to use a class to be keep middleware tidy and decoupled from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.117.1">
      WebApplication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.118.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.118.2">
     You might also want to use a factory design pattern to produce and register
    </span>
    <a id="_idIndexMarker134">
    </a>
    <span class="koboSpan" id="kobo.119.1">
     appropriate middleware classes.
    </span>
    <span class="koboSpan" id="kobo.119.2">
     On the other hand, the use of a class may be overkill.
    </span>
    <span class="koboSpan" id="kobo.119.3">
     After all, we are building
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.120.1">
      minimal APIs
     </span>
    </em>
    <span class="koboSpan" id="kobo.121.1">
     , where, most of the time, it is favorable to keep logic small
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.122.1">
      and simple.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.123.1">
     In the spirit of minimalism, there is an alternative to middleware classes in the form of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.124.1">
      inline middleware.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-72">
    <a id="_idTextAnchor100">
    </a>
    <span class="koboSpan" id="kobo.125.1">
     Inline middleware
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.126.1">
     This is a lot simpler than using
    </span>
    <a id="_idIndexMarker135">
    </a>
    <span class="koboSpan" id="kobo.127.1">
     classes.
    </span>
    <span class="koboSpan" id="kobo.127.2">
     When
    </span>
    <a id="_idIndexMarker136">
    </a>
    <span class="koboSpan" id="kobo.128.1">
     creating middleware inline, we create and register the component with our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.129.1">
      WebApplication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.130.1">
     object in one block of code.
    </span>
    <span class="koboSpan" id="kobo.130.2">
     Once again, considering our instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.131.1">
      WebApplication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.132.1">
     called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.133.1">
      app
     </span>
    </strong>
    <span class="koboSpan" id="kobo.134.1">
     , we will still be passing in an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.135.1">
      HTTPContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.136.1">
     object and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.137.1">
      RequestDelegate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.138.1">
     object, but instead of a constructor, private field, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.139.1">
      InvokeAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.140.1">
     method, everything will happen inside the body of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.141.1">
      the endpoint.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.142.1">
     Let’s look at how we could rewrite
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.143.1">
      MySuperSimpleMiddlewareClass
     </span>
    </strong>
    <span class="koboSpan" id="kobo.144.1">
     into an inline
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.145.1">
      middleware component:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.146.1">
app.Use(async (context, next) =&gt;
{
    Console.WriteLine(
        "Request handled by inline middleware component");
    await next(context);
    Console.WriteLine(
        "Response handled by inline middleware component");
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.147.1">
     In this example, we add
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.148.1">
      app.UseMiddleware&lt;MySuperSimpleMiddlewareClass&gt;()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     with the much more generic
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      app.Use()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     .
    </span>
    <span class="koboSpan" id="kobo.151.2">
     Instead of specifying a type, we are now passing an asynchronous anonymous function that will be registered to the pipeline.
    </span>
    <span class="koboSpan" id="kobo.151.3">
     The body of the lambda expression shown in the example is the equivalent of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.152.1">
      InvokeAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.153.1">
     found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.154.1">
      within
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.155.1">
       MySuperSimpleMiddlewareClass
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.156.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.157.1">
     Just like before, we are writing a console message on the incoming request, followed by a call to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.158.1">
      RequestDelegate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.159.1">
     , object which passes to the next component.
    </span>
    <span class="koboSpan" id="kobo.159.2">
     We then have another console message, which will be executed on the request response as it travels back through the pipeline on its way to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.160.1">
      the client.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.161.1">
     The beauty of registering middleware inline is its consistency with the endpoints you create.
    </span>
    <span class="koboSpan" id="kobo.161.2">
     If you were to register small middleware components in this way, before constructing endpoints by mapping
    </span>
    <a id="_idIndexMarker137">
    </a>
    <span class="koboSpan" id="kobo.162.1">
     them onto the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.163.1">
      WebApplication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.164.1">
     object, your project would
    </span>
    <a id="_idIndexMarker138">
    </a>
    <span class="koboSpan" id="kobo.165.1">
     indeed be minimal in the way minimal APIs were designed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.166.1">
      to be.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.167.1">
     We have covered the basics of configuring pipelines in the previous section, but there are some pitfalls that you should be aware of to ensure you are getting the benefits
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.168.1">
      of middleware.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.169.1">
     Maintaining order
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.170.1">
     As we discussed in the first part
    </span>
    <a id="_idIndexMarker139">
    </a>
    <span class="koboSpan" id="kobo.171.1">
     of the chapter, middleware resides as a sequence of components within a pipeline in which a request travels between the client
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.172.1">
      and server.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.173.1">
     This sequence of components is linear, meaning that the order in which individual components are executed is critical, depending on their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.174.1">
      respective goals.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.175.1">
     The order of execution is determined by the order in which the components are registered, and how they are registered is determined by the way they are constructed – that is, class-based or as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.176.1">
      inline middleware.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.177.1">
     Each of these components can modify the request and the response within the pipeline.
    </span>
    <span class="koboSpan" id="kobo.177.2">
     As you can imagine, this makes it easy to produce unexpected results if caution is not taken.
    </span>
    <span class="koboSpan" id="kobo.177.3">
     For example, as part of your pipeline, you may need to add a field to the payload.
    </span>
    <span class="koboSpan" id="kobo.177.4">
     This is fine, but if you have another middleware component within the pipeline that references that new field, you have created a dependency
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.178.1">
      between components.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.179.1">
     If the component that references the new field was to be registered before the component that created it, the pipeline would hit an exception because a property that does not yet exist will have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.180.1">
      been referenced.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.181.1">
     Therefore, when writing middleware, it is essential that you verify that the request is hitting each component in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.182.1">
      correct order.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.183.1">
     Go ahead and run the
    </span>
    <a id="_idIndexMarker140">
    </a>
    <span class="koboSpan" id="kobo.184.1">
     project containing these middleware examples.
    </span>
    <span class="koboSpan" id="kobo.184.2">
     You will see the order in which the middleware is executing in the logs shown in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.185.1">
      Output
     </span>
    </strong>
    <span class="koboSpan" id="kobo.186.1">
     tab accessible from the bottom left of the window in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.187.1">
      Visual Studio.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.188.1">
     Default middleware
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.189.1">
     There are built-in middleware
    </span>
    <a id="_idIndexMarker141">
    </a>
    <span class="koboSpan" id="kobo.190.1">
     components that ASP.NET automatically registers for
    </span>
    <a id="_idIndexMarker142">
    </a>
    <span class="koboSpan" id="kobo.191.1">
     minimal API projects depending on the way they have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.192.1">
      been configured.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.193.1">
     If the hosting environment is set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.194.1">
      Development
     </span>
    </strong>
    <span class="koboSpan" id="kobo.195.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.196.1">
      UseDeveloperExceptionPage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.197.1">
     middleware will be registered.
    </span>
    <span class="koboSpan" id="kobo.197.2">
     This component displays a page showing error responses from the pipeline when they occur, which is very useful
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.198.1">
      for debugging.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.199.1">
     The routing that we depend on and worked with in the previous chapter is itself a middleware.
    </span>
    <span class="koboSpan" id="kobo.199.2">
     It is added automatically by ASP.NET if endpoints exist.
    </span>
    <span class="koboSpan" id="kobo.199.3">
     ASP.NET will not add it automatically if you add
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.200.1">
       UseRouting()
      </span>
     </strong>
    </span>
    <span class="No-Break">
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.201.1">
      manually.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.202.1">
     After
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.203.1">
      UseRouting
     </span>
    </strong>
    <span class="koboSpan" id="kobo.204.1">
     , ASP.NET will also add
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.205.1">
      UseAuthentication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.206.1">
     if
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.207.1">
      IAuthenticationSchemeProvider
     </span>
    </strong>
    <span class="koboSpan" id="kobo.208.1">
     is detected in the service provider.
    </span>
    <span class="koboSpan" id="kobo.208.2">
     Like
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.209.1">
      UseRouting
     </span>
    </strong>
    <span class="koboSpan" id="kobo.210.1">
     , if you add the component manually, ASP.NET will skip adding
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.211.1">
      UseAuthentication
     </span>
    </strong>
    <span class="koboSpan" id="kobo.212.1">
     .
    </span>
    <span class="koboSpan" id="kobo.212.2">
     The same is true for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.213.1">
      UseAuthorization()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.214.1">
     with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.215.1">
      IAuthorizationSchemeProvider
     </span>
    </strong>
    <span class="koboSpan" id="kobo.216.1">
     .
    </span>
    <span class="koboSpan" id="kobo.216.2">
     Most default middleware will not be noticed by the developer
    </span>
    <a id="_idIndexMarker143">
    </a>
    <span class="koboSpan" id="kobo.217.1">
     unless
    </span>
    <a id="_idIndexMarker144">
    </a>
    <span class="koboSpan" id="kobo.218.1">
     there is a need to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.219.1">
      override it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.220.1">
     Now that we’ve explored middleware as a concept, we should move on to discuss how we can extend minimal APIs by writing our own
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.221.1">
      custom middleware.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-73">
    <a id="_idTextAnchor101">
    </a>
    <span class="koboSpan" id="kobo.222.1">
     Implementing custom middleware
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.223.1">
     Custom middleware is
    </span>
    <a id="_idIndexMarker145">
    </a>
    <span class="koboSpan" id="kobo.224.1">
     any middleware component that either you have written yourself or is not part of the default middleware components registered
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.225.1">
      by ASP.NET.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.226.1">
     Custom middleware affords us a lot of flexibility in the way we extend the functionality of our API outside of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.227.1">
      request endpoints.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.228.1">
     Some examples of custom middleware might be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.229.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.230.1">
       Logging middleware
      </span>
     </strong>
     <span class="koboSpan" id="kobo.231.1">
      :  Capture
     </span>
     <a id="_idIndexMarker146">
     </a>
     <span class="koboSpan" id="kobo.232.1">
      events and store logs as
     </span>
     <a id="_idIndexMarker147">
     </a>
     <span class="koboSpan" id="kobo.233.1">
      requests
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.234.1">
       are received
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.235.1">
       Error-handling middleware
      </span>
     </strong>
     <span class="koboSpan" id="kobo.236.1">
      : Have
     </span>
     <a id="_idIndexMarker148">
     </a>
     <span class="koboSpan" id="kobo.237.1">
      specific ways that errors are
     </span>
     <a id="_idIndexMarker149">
     </a>
     <span class="koboSpan" id="kobo.238.1">
      treated within
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.239.1">
       the pipeline
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.240.1">
       Validation middleware
      </span>
     </strong>
     <span class="koboSpan" id="kobo.241.1">
      :  Check
     </span>
     <a id="_idIndexMarker150">
     </a>
     <span class="koboSpan" id="kobo.242.1">
      that data is in a specific state on
     </span>
     <a id="_idIndexMarker151">
     </a>
     <span class="koboSpan" id="kobo.243.1">
      receipt
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.244.1">
       or response.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.245.1">
       Request-timing middleware
      </span>
     </strong>
     <span class="koboSpan" id="kobo.246.1">
      : Record the
     </span>
     <a id="_idIndexMarker152">
     </a>
     <span class="koboSpan" id="kobo.247.1">
      time a request takes
     </span>
     <a id="_idIndexMarker153">
     </a>
     <span class="koboSpan" id="kobo.248.1">
      for the purposes of monitoring
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.249.1">
       and telemetry
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.250.1">
       IP-blocking middleware
      </span>
     </strong>
     <span class="koboSpan" id="kobo.251.1">
      : Check
     </span>
     <a id="_idIndexMarker154">
     </a>
     <span class="koboSpan" id="kobo.252.1">
      the IP address of the request’s remote
     </span>
     <a id="_idIndexMarker155">
     </a>
     <span class="koboSpan" id="kobo.253.1">
      host and check to see if it is in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.254.1">
       ban list
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.255.1">
     Let’s write
    </span>
    <a id="_idIndexMarker156">
    </a>
    <span class="koboSpan" id="kobo.256.1">
     some custom middleware using the example of logging.
    </span>
    <span class="koboSpan" id="kobo.256.2">
     In this example, we’ll keep things simple and minimal by writing the middleware as an inline
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.257.1">
      middleware component.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.258.1">
     Open
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.259.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.260.1">
     and start by creating a new blank middleware component; that is to say, create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.261.1">
      Use()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.262.1">
     method receiving an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.263.1">
      HttpContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.264.1">
     object and a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.265.1">
      RequestDelegate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.266.1">
     object with nothing in the body of the accompanying
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.267.1">
      lambda expression:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.268.1">
app.Use(async (context, next) =&gt;
{
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.269.1">
     Now we have a blank canvas for a simple middleware component, we can add some logic to log some content.
    </span>
    <span class="koboSpan" id="kobo.269.2">
     In this example, we’re going to log the content to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.270.1">
      the console.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.271.1">
     The question is,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.272.1">
      what
     </span>
    </em>
    <span class="koboSpan" id="kobo.273.1">
     do we want
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.274.1">
      to log?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.275.1">
     The useful thing about having the request passed into the component as a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.276.1">
      HttpContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.277.1">
     instance, is that we can access the individual properties of the request via this object.
    </span>
    <span class="koboSpan" id="kobo.277.2">
     This means we can access the target HTTP method, the target route, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.278.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.279.1">
     Let’s start by logging some content from the request as it is received, before passing the control flow on to the next component in the pipeline.
    </span>
    <span class="koboSpan" id="kobo.279.2">
     To do this, update the body of the lambda expression so that it reflects this updated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.280.1">
      example here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.281.1">
app.Use(async (context, next) =&gt;
{
    Console.WriteLine(
        $"Request: {context.Request.Method}
        {context.Request.Path}");
    await next(context);
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.282.1">
     Now our middleware is accessing data from the request and using string interpolation, arranging the data into a string that can be logged to the console.
    </span>
    <span class="koboSpan" id="kobo.282.2">
     This gives our API the benefit of being auditable (easy to track and review historical events) and easier to maintain.
    </span>
    <span class="koboSpan" id="kobo.282.3">
     On top of this, because we’ve used a custom middleware, we’ve not had to repeat ourselves by writing the same log for each endpoint
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.283.1">
      we create.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.284.1">
     Remember, the middleware components on the pipeline don’t just execute for the incoming request.
    </span>
    <span class="koboSpan" id="kobo.284.2">
     The outgoing response also traverses the middleware pipeline in reverse on its way back to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.285.1">
      the client.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.286.1">
     If we wanted to log the contents of the response to the console as it travels back through the pipeline, we could simply add another
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.287.1">
      Console.WriteLine()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.288.1">
     statement underneath our call to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.289.1">
      next()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.290.1">
     .
    </span>
    <span class="koboSpan" id="kobo.290.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.291.1">
      Response
     </span>
    </strong>
    <span class="koboSpan" id="kobo.292.1">
     member of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.293.1">
      HttpContex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.294.1">
     t object should provide us with up-to-date data for the outgoing response, which we can log, as in the example
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.295.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.296.1">
app.Use(async (context, next) =&gt;
{
    Console.WriteLine(
        $"Request: {context.Request.Method}
        {context.Request.Path}");
    await next(context);
    Console.WriteLine(
        $"Response: {context.Response.StatusCode}");
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.297.1">
     As a
    </span>
    <a id="_idIndexMarker157">
    </a>
    <span class="koboSpan" id="kobo.298.1">
     reminder, this was an inline middleware component, meaning that it was created using a lambda expression in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.299.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.300.1">
     .
    </span>
    <span class="koboSpan" id="kobo.300.2">
     For the sake of consistency, here is an example of how the same middleware component could be written in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.301.1">
      a class:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.302.1">
public class LoggingMiddleware
{
    private readonly RequestDelegate _next;
    public LoggingMiddleware(RequestDelegate next)
    {
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        Console.WriteLine(
            $"Request: {context.Request.Method}
            {context.Request.Path}");
        await _next(context);
        Console.WriteLine(
            $"Response: {context.Response.StatusCode}");
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.303.1">
     Here is
    </span>
    <a id="_idIndexMarker158">
    </a>
    <span class="koboSpan" id="kobo.304.1">
     how the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.305.1">
      Program
     </span>
    </strong>
    <span class="koboSpan" id="kobo.306.1">
     class
    </span>
    <strong class="source-inline">
    </strong>
    <span class="koboSpan" id="kobo.307.1">
     would look after registering the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.308.1">
      class-based middleware:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.309.1">
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.UseMiddleware&lt;LoggingMiddleware&gt;();
app.MapGet("/", () =&gt; "Hello World!");
app.Run();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.310.1">
     Logging
    </span>
    <a id="_idIndexMarker159">
    </a>
    <span class="koboSpan" id="kobo.311.1">
     is a straightforward example of middleware’s ability to take action before routes are hit.
    </span>
    <span class="koboSpan" id="kobo.311.2">
     For more complex use cases, it might be necessary to
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.312.1">
      short-circuit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.313.1">
     the
    </span>
    <a id="_idIndexMarker160">
    </a>
    <span class="koboSpan" id="kobo.314.1">
     pipeline.
    </span>
    <span class="koboSpan" id="kobo.314.2">
     This would stop other components in the pipeline from executing and can be easily achieved by omitting the call to the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.315.1">
       RequestDelegate
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.316.1">
      object.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.317.1">
     Short-circuiting is simple enough, but what if our middleware has a level of complexity that means it might have to block routing from taking place?
    </span>
    <span class="koboSpan" id="kobo.317.2">
     This would mean the middleware stops the request from reaching the
    </span>
    <a id="_idIndexMarker161">
    </a>
    <span class="koboSpan" id="kobo.318.1">
     intended endpoint, or any endpoints
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.319.1">
      at all.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.320.1">
     To understand this concept
    </span>
    <a id="_idIndexMarker162">
    </a>
    <span class="koboSpan" id="kobo.321.1">
     further, we need to look at a style of middleware component called
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.322.1">
       terminal middleware
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.323.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-74">
    <a id="_idTextAnchor102">
    </a>
    <span class="koboSpan" id="kobo.324.1">
     Terminal middleware
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.325.1">
     Classic middleware
    </span>
    <a id="_idIndexMarker163">
    </a>
    <span class="koboSpan" id="kobo.326.1">
     components such as the ones we have worked with in this
    </span>
    <a id="_idIndexMarker164">
    </a>
    <span class="koboSpan" id="kobo.327.1">
     chapter all have one thing in common – the requests that pass through them on the pipeline will eventually reach an endpoint, and then the endpoint will handle sending the requests back through the pipeline to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.328.1">
      the client.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.329.1">
     However, there are scenarios where we would not want a request to reach the endpoint.
    </span>
    <span class="koboSpan" id="kobo.329.2">
     For example, if we had implemented a banned IP list, in which IP addresses for malicious or suspicious hosts were listed, we would want to achieve the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.330.1">
      with middleware:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.331.1">
      Identify the IP address of the remote host sending
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.332.1">
       the request
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.333.1">
      Determine whether the IP address is on the list of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.334.1">
       banned IPs
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.335.1">
      If it is a banned IP address, send a response back to the client from the middleware, stating that the host is forbidden from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.336.1">
       proceeding further
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.337.1">
     Let’s write our own middleware component that checks incoming IP addresses and blocks the request from going any further
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.338.1">
      if needed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.339.1">
     First, create a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.340.1">
      scaffold
     </span>
    </em>
    <span class="koboSpan" id="kobo.341.1">
     of a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.342.1">
      middleware class:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.343.1">
public class IPBlockingMiddleware
{
    private readonly RequestDelegate _next;
    public IPBlockingMiddleware(RequestDelegate next,
        IEnumerable&lt;string&gt; blockedIPs)
    {
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        await _next(context);
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.344.1">
     At the moment, our middleware doesn’t do anything, other than simply passing control to the next component in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.345.1">
      the pipeline.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.346.1">
     Looking back at the
    </span>
    <a id="_idIndexMarker165">
    </a>
    <span class="koboSpan" id="kobo.347.1">
     three goals of our IP-blocking middleware, the first
    </span>
    <a id="_idIndexMarker166">
    </a>
    <span class="koboSpan" id="kobo.348.1">
     goal is to identify the IP address of the requesting host.
    </span>
    <span class="koboSpan" id="kobo.348.2">
     This information can be retrieved from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.349.1">
      HttpContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.350.1">
     object as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.351.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.352.1">
var requestIP =
    context.Connection.RemoteIpAddress?.ToString();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.353.1">
     Next, we need to identify whether the requesting IP address is a banned IP.
    </span>
    <span class="koboSpan" id="kobo.353.2">
     To do this, we need to add a collection to store the banned list, and then a check against the incoming
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.354.1">
      IP address.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.355.1">
     Add a private
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.356.1">
      HashSet&lt;string&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.357.1">
     field under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.358.1">
      RequestDelegate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.359.1">
     field.
    </span>
    <span class="koboSpan" id="kobo.359.2">
     We’ll use this as our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.360.1">
      banned list:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.361.1">
private readonly HashSet&lt;string&gt; _blockedIPs;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.362.1">
     This list can be passed to the middleware when it is registered via
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.363.1">
      its constructor.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.364.1">
     Update the constructor to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.365.1">
      reflect this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.366.1">
public IPBlockingMiddleware(RequestDelegate next,
    IEnumerable&lt;string&gt; blockedIPs)
    {
        _next = next;
        _blockedIPs = new HashSet&lt;string&gt;(blockedIPs);
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.367.1">
     Now all that remains is to act against the offending request.
    </span>
    <span class="koboSpan" id="kobo.367.2">
     We can write messages into the response to the client via the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.368.1">
      HttpContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.369.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.369.2">
     Here, we can include a message to inform
    </span>
    <a id="_idIndexMarker167">
    </a>
    <span class="koboSpan" id="kobo.370.1">
     the client that their IP address is blocked.
    </span>
    <span class="koboSpan" id="kobo.370.2">
     Following this, we can use a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.371.1">
      return
     </span>
    </strong>
    <span class="koboSpan" id="kobo.372.1">
     statement
    </span>
    <a id="_idIndexMarker168">
    </a>
    <span class="koboSpan" id="kobo.373.1">
     to stop the request in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.374.1">
      its tracks:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.375.1">
public async Task InvokeAsync(HttpContext context)
    {
        var requestIP =
            context.Connection.RemoteIpAddress?.ToString();
        if (_blockedIPs.Contains(requestIP))
        {
            context.Response.StatusCode = 403;
            Console.WriteLine(
                $"IP {requestIP} is blocked.");
            await context.Response.WriteAsync(
                "Your IP is blocked.");
            return;
        }
        Console.WriteLine($"IP {requestIP} is allowed.");
        await _next(context);
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.376.1">
     Once all these changes have been added, we will have a fully functioning custom middleware class that is able to detect banned IP addresses for incoming requests and block them from
    </span>
    <a id="_idIndexMarker169">
    </a>
    <span class="koboSpan" id="kobo.377.1">
     reaching the endpoints
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.378.1">
      we’ve configured.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.379.1">
     Your
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.380.1">
      IPBlockingMiddleware
     </span>
    </strong>
    <span class="koboSpan" id="kobo.381.1">
     class should
    </span>
    <a id="_idIndexMarker170">
    </a>
    <span class="koboSpan" id="kobo.382.1">
     now look
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.383.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.384.1">
public class IPBlockingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly HashSet&lt;string&gt; _blockedIPs;
    public IPBlockingMiddleware(RequestDelegate next,
        IEnumerable&lt;string&gt; blockedIPs)
    {
        _next = next;
        _blockedIPs = new HashSet&lt;string&gt;(blockedIPs);
    }
    public async Task InvokeAsync(HttpContext context)
    {
        var requestIP =
            context.Connection.RemoteIpAddress?.ToString();
        if (_blockedIPs.Contains(requestIP))
        {
            context.Response.StatusCode = 403;
            await context.Response.WriteAsync(
                "Your IP is blocked.");
            return;
        }
        await _next(context);
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.385.1">
     In the preceding
    </span>
    <a id="_idIndexMarker171">
    </a>
    <span class="koboSpan" id="kobo.386.1">
     middleware example, we have a constructor parameter in the form of a list of blocked IPs.
    </span>
    <span class="koboSpan" id="kobo.386.2">
     This means that when registering the middleware in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.387.1">
      Program.cs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.388.1">
     , the list would have to be created beforehand, and then
    </span>
    <a id="_idIndexMarker172">
    </a>
    <span class="koboSpan" id="kobo.389.1">
     passed in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.390.1">
      during registration:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.391.1">
//Create the list of blocked Ips
private readonly List&lt;string&gt; _blockedIPs =
    new List&lt;string&gt; { "192.168.1.1", "203.0.113.0" };
app.UseMiddleware&lt;IPBlockingMiddleware&gt;(_blockedIPs);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.392.1">
     You could test the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.393.1">
      IPBlocking
     </span>
    </strong>
    <span class="koboSpan" id="kobo.394.1">
     functionality by adding the loopback address to the blacklist.
    </span>
    <span class="koboSpan" id="kobo.394.2">
     This should return a response with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.395.1">
      403
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.396.1">
      status code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.397.1">
app.UseMiddleware&lt;IPBlockingMiddleware&gt;(
    new List&lt;string&gt; { "::1" }
);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.398.1">
     Gradually, we’re starting to introduce more complex logic into our minimal API with custom and default middleware components.
    </span>
    <span class="koboSpan" id="kobo.398.2">
     As complexity increases, so does the probability that errors will occur.
    </span>
    <span class="koboSpan" id="kobo.398.3">
     As we know, all potential errors must be handled to maintain
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.399.1">
      system continuity.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.400.1">
     Middleware
    </span>
    <a id="_idIndexMarker173">
    </a>
    <span class="koboSpan" id="kobo.401.1">
     can also be used to achieve this.
    </span>
    <span class="koboSpan" id="kobo.401.2">
     Let’s explore how we can write a
    </span>
    <a id="_idIndexMarker174">
    </a>
    <span class="koboSpan" id="kobo.402.1">
     component that catches and handles unexpected behavior and errors that may occur within
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.403.1">
      the pipeline.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-75">
    <a id="_idTextAnchor103">
    </a>
    <span class="koboSpan" id="kobo.404.1">
     Handling errors within the middleware pipeline
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.405.1">
     In
    </span>
    <a id="_idIndexMarker175">
    </a>
    <span class="koboSpan" id="kobo.406.1">
     this example, we will stick with a class-based middleware component structure, as it offers a clean structure with types that can be swapped out as needed.
    </span>
    <span class="koboSpan" id="kobo.406.2">
     (This is more of a personal preference than
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.407.1">
      good practice.)
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.408.1">
     A dedicated error handling component can be useful, as it ensures that you are always able to review and address errors as they occur, rather than facing the problematic and often embarrassing situation where an unhandled exception crashes the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.409.1">
      application completely.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.410.1">
     Here is an example of a basic exception-handling
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.411.1">
      middleware component:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.412.1">
public class ExceptionHandlingMiddleware
{
    private readonly RequestDelegate _next;
    public ExceptionHandlingMiddleware(
        RequestDelegate next)
    {
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            Console.WriteLine(
                $"Exception caught: {ex.Message}");
            context.Response.StatusCode = 500;
            await context.Response.WriteAsync(
                "An unexpected error occurred.");
        }
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.413.1">
     Notice how, in this code, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.414.1">
      try catch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.415.1">
     block in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.416.1">
      InvokeAsync()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.417.1">
     doesn’t do much at all in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.418.1">
      try
     </span>
    </strong>
    <span class="koboSpan" id="kobo.419.1">
     body.
    </span>
    <span class="koboSpan" id="kobo.419.2">
     It simply passes execution to the next component.
    </span>
    <span class="koboSpan" id="kobo.419.3">
     This is because this middleware will be the first component in the pipeline to be registered.
    </span>
    <span class="koboSpan" id="kobo.419.4">
     It is the first because we are not interested in handling errors at the first component in the pipeline, but we are for all other
    </span>
    <a id="_idIndexMarker176">
    </a>
    <span class="koboSpan" id="kobo.420.1">
     components.
    </span>
    <span class="koboSpan" id="kobo.420.2">
     By placing our logic in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.421.1">
      catch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.422.1">
     body,
    </span>
    <strong class="source-inline">
    </strong>
    <span class="koboSpan" id="kobo.423.1">
     any errors that happen later in the pipeline will
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.424.1">
      bubble up
     </span>
    </em>
    <span class="koboSpan" id="kobo.425.1">
     to this component and be caught, allowing us to handle them and then update the response to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.426.1">
      client accordingly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.427.1">
     It also covers us for the handling of any exceptions during the execution of middleware components on the return journey (the response) as the flow of execution is heading back toward this component.
    </span>
    <span class="koboSpan" id="kobo.427.2">
     As the component was the first to be registered, it will be the last to execute on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.428.1">
      return journey.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.429.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.430.1">
      catch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.431.1">
     statement, we can do whatever is needed to handle the exception.
    </span>
    <span class="koboSpan" id="kobo.431.2">
     In this example, we simply write the value of the caught exception’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.432.1">
      Message
     </span>
    </strong>
    <span class="koboSpan" id="kobo.433.1">
     field to the console.
    </span>
    <span class="koboSpan" id="kobo.433.2">
     Then we set the status code of the request to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.434.1">
      500 INTERNAL SERVER ERROR
     </span>
    </strong>
    <span class="koboSpan" id="kobo.435.1">
     and write a message into the response.
    </span>
    <span class="koboSpan" id="kobo.435.2">
     All of this happens via the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.436.1">
      HttpContext
     </span>
    </strong>
    <span class="koboSpan" id="kobo.437.1">
     object that travels through
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.438.1">
      the pipeline.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.439.1">
     If you wanted to force one of these exceptions to see an example of the output, you could create a dedicated example endpoint that simply throws
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.440.1">
      an exception:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.441.1">
app.MapGet("/employees/exceptionexample", () =&gt;
{
    throw new NotImplementedException();
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.442.1">
     Calling this endpoint
    </span>
    <a id="_idIndexMarker177">
    </a>
    <span class="koboSpan" id="kobo.443.1">
     while in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.444.1">
      Debug
     </span>
    </strong>
    <span class="koboSpan" id="kobo.445.1">
     mode will display the exception details in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.446.1">
      the browser.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer041">
     <span class="koboSpan" id="kobo.447.1">
      <img alt="Figure 5.2: Exception details shown in the browser for debugging purposes" src="image/B20968_05_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.448.1">
     Figure 5.2: Exception details shown in the browser for debugging purposes
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.449.1">
     In this chapter, we’ve delved deep into the intricacies of middleware and pipeline customization in minimal APIs.
    </span>
    <span class="koboSpan" id="kobo.449.2">
     By understanding the concepts and practical implementations of middleware, we’ve laid the groundwork for creating more robust, maintainable, and flexible API applications.
    </span>
    <span class="koboSpan" id="kobo.449.3">
     Let’s summarize the key points and skills
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.450.1">
      we’ve covered.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-76">
    <a id="_idTextAnchor104">
    </a>
    <span class="koboSpan" id="kobo.451.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.452.1">
     In this chapter, we explored the essential role that middleware plays in the ASP.NET Core minimal APIs.
    </span>
    <span class="koboSpan" id="kobo.452.2">
     Middleware components are pivotal in the request-response lifecycle, enabling developers to handle key areas of a system such as logging, authentication, error handling,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.453.1">
      and more.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.454.1">
     We started by introducing the concept of middleware and explaining how it fits into the overall architecture of minimal APIs.
    </span>
    <span class="koboSpan" id="kobo.454.2">
     Middleware components act as intermediaries that can inspect, modify, or terminate HTTP requests and responses.
    </span>
    <span class="koboSpan" id="kobo.454.3">
     This modular approach promotes a clean separation of concerns and enhances the maintainability of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.455.1">
      the application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.456.1">
     Next, we delved into configuring middleware pipelines, illustrating how the order of middleware registration affects the processing of requests.
    </span>
    <span class="koboSpan" id="kobo.456.2">
     Middleware components are executed in the order they are added to the pipeline, and the response travels back through the pipeline in reverse order.
    </span>
    <span class="koboSpan" id="kobo.456.3">
     This sequential processing model is critical for ensuring that each middleware component functions correctly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.457.1">
      and efficiently.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.458.1">
     We then moved on to implementing custom middleware, providing examples such as logging and IP blocking.
    </span>
    <span class="koboSpan" id="kobo.458.2">
     These examples demonstrated how custom middleware can be tailored to meet specific
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.459.1">
      application requirements.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.460.1">
     We highlighted the importance of error-handling middleware, showing how it can be used to catch and manage exceptions centrally, thereby simplifying error management and improving
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.461.1">
      application robustness.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.462.1">
     Middleware is a fantastic way of extending the functionality of minimal APIs, but they are useless if their requests don’t have data that can be reviewed, manipulated, and transformed.
    </span>
    <span class="koboSpan" id="kobo.462.2">
     In the next chapter, we’ll explore how data traveling through an API can be mapped for it to be processed optimally
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.463.1">
      and accurately.
     </span>
    </span>
   </p>
  </div>
 </body></html>