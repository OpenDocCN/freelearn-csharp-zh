<html><head></head><body>
  <div><h1 class="chapterNumber">21</h1>
    <h1 id="_idParaDest-282" class="chapterTitle">Massive Worlds: Introduction to DOTS</h1>
    <p class="normal">While Unity is a powerful and performant engine (when used properly), there’s a limit on how many GameObjects you can have without reaching performance limits. While the <strong class="keyWord">Object-Oriented Programming</strong> (<strong class="keyWord">OOP</strong>) paradigm provides a convenient way to code a game, due to its internal works, it won’t always take advantage of all the modern CPU features, like caching, <strong class="keyWord">Single Instruction Multiple Data</strong> (<strong class="keyWord">SIMD</strong>) operations, and multi-threading. While it isn’t impossible to use such features in OOP, doing so is not a trivial task and can lead to difficult-to-track bugs. Unity’s response to that issue was releasing the first production-ready version of the DOTS packages, which will help us with these problems.</p>
    <p class="normal">In this chapter, we will examine the following build concepts:</p>
    <ul>
      <li class="bulletList">Understanding what DOTS is</li>
      <li class="bulletList">Creating our first DOTS game</li>
      <li class="bulletList">Creating gameplay in DOTS</li>
    </ul>
    <p class="normal">Let’s start by getting an idea of what DOTS is and why we should use it.</p>
    <h1 id="_idParaDest-283" class="heading-1">Understanding what DOTS is</h1>
    <p class="normal">The Unity Data-Oriented Technology Stack (DOTS) is a set of Unity packages<a id="_idIndexMarker1406"/> that allows us to write data-oriented code easily. While there are plenty of packages in the DOTS stack, let’s focus on the three key ones that serve as pillars for the rest:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Entities: </strong>Unity takes on the ECS<a id="_idIndexMarker1407"/> pattern. It replaces GameObjects and MonoBehaviours with<a id="_idIndexMarker1408"/> Entities, Components, and Systems (ECS, a paradigm in Unity that separates data (components) from logic (systems), enhancing performance and scalability), a cache-friendly way to store and update our scene objects. It provides considerable performance boosts, especially in games with lots of objects.</li>
      <li class="bulletList"><strong class="keyWord">Jobs:</strong> The Unity way to create multi-threaded<a id="_idIndexMarker1409"/> code. It groups data<a id="_idIndexMarker1410"/> and code that processes jobs. They are executed in parallel thanks to the job scheduler, which guarantees that explicit dependencies between jobs are respected. This avoids classic multi-threading issues like deadlocks and race conditions. Unity uses Jobs to boost the performance of its different systems, like rendering or physics. It cannot be applied to regular MonoBehaviour methods like Update without significant <a id="_idIndexMarker1411"/>modifications, but entities are highly compatible with jobs.</li>
      <li class="bulletList"><strong class="keyWord">Burst</strong>: A code compiler capable <a id="_idIndexMarker1412"/>of converting C# scripts<a id="_idIndexMarker1413"/> to highly optimized native code. It uses LLVM, which applies advanced optimizations when compiling. The code<a id="_idIndexMarker1414"/> to convert needs to use a subset of C#, called <strong class="keyWord">High Performant C#</strong> (<strong class="keyWord">HPC</strong>#), so it cannot be applied to any script without (sometimes) considerable modification.</li>
    </ul>
    <p class="normal">While these packages<a id="_idIndexMarker1415"/> can be used separately (especially the Jobs and Burst packages), the idea is to mix them to parallelize our game logic written in ECS using Jobs, while Burst makes it run as fast as possible. The other DOTS packages provide different features like rendering (Entities Graphics), physics (Unity Physics and Havok), and networking (Netcode for Entities).</p>
    <p class="normal">All of this sounds great and exciting, but there are some caveats<a id="_idIndexMarker1416"/> when using this technology. Here’s a list of the most important ones:</p>
    <ul>
      <li class="bulletList">It’s a fundamental change from the GameObject approach. This means that you must relearn how to do the same things you are already comfortable doing with GameObjects and MonoBehaviours.</li>
      <li class="bulletList">The learning curve can be steep, depending on your programming experience. This is caused by the limited C# features available due to HPC#, custom APIs to learn, and the multi-threaded nature of its code. Even if the Jobs package is easy to use, it adds challenges that aren’t present in single-thread code.</li>
      <li class="bulletList">It’s in its early stages. It’s likely that its API will change considerably in the short term (for the better!). Luckily, the data-oriented principles won’t change, meaning that we won’t need to relearn them again, just the APIs involved.</li>
      <li class="bulletList">Some GameObjects features aren’t available in DOTS yet, like UI, audio, terrain, or animations. For now, you need to implement such features in GameObjects and synchronize them with their respective entities. It is a hard endeavor that requires several custom solutions.</li>
    </ul>
    <p class="normal">Regardless, these obstacles didn’t stop ambitious games from being made with DOTS, like V-Rising and Cities Skylines 2. The idea of discussing DOTS’ caveats is not to intimidate but to understand when it is justified to use it. The games I just mentioned are great examples of where DOTS shines, given that those games simulate huge worlds with lots of objects. Here’s a non-comprehensive list of games that could benefit<a id="_idIndexMarker1417"/> from using DOTS:</p>
    <ul>
      <li class="bulletList">Big worlds with several objects that require complex simulation logic to run in a performant way. Some examples of this are massively multiplayer online games (MMOs), city-builder games, or big RPGs that simulate vast worlds like Cyberpunk 2077 or Assassin’s Creed.</li>
      <li class="bulletList">Complex simulations require real-life behavior, like wind-tunnel simulations, architecture visualization, or even galaxy star simulations.</li>
      <li class="bulletList">Specific features of a GameObjects-based game can use DOTS, like a crowd in a football stadium or complex particle systems. DOTS and GameObjects can coexist in the same game.</li>
    </ul>
    <p class="normal">On the other hand, simple games that run properly with GameObjects don’t need the difficulties and current limitations<a id="_idIndexMarker1418"/> of DOTS. For example, fighting games that require two main objects (the fighters) and a minimal environment are not good candidates. Other examples are casual open-world exploration games like Firewatch, which, even<a id="_idIndexMarker1419"/> if they feature big landscapes to explore, have a simple enough logic to get away with some clever tricks using GameObjects. In the end, Firewatch was made without DOTS.</p>
    <p class="normal">These limitations will be sorted in the future, making all types of games using DOTS viable, but for now, let’s avoid starting a project in a way that might risk its development. I’m not saying that DOTS is risky, but I want to be clear that not every game is worth the effort and pitfalls of relearning a new tech from scratch.</p>
    <p class="normal">If, after careful consideration and research, you think your future project might benefit from using DOTS, then stick with us; in the next section, we are going to learn how DOTS works by doing a simple introductory project.</p>
    <h1 id="_idParaDest-284" class="heading-1">Creating our first DOTS game</h1>
    <p class="normal">There is plenty to learn in order<a id="_idIndexMarker1420"/> to create performant games with DOTS, so let’s start by creating a simple project featuring cubes moving forward. Emphasis on cubes – we are going to have thousands of them! I know it is not the most exciting project, but bear with me, as in the <em class="italic">Creating Gameplay in the DOTS</em> section in this chapter, we will convert it into an actual (but simple) game.</p>
    <p class="normal">In this section, we will examine the following DOTS concepts:</p>
    <ul>
      <li class="bulletList">Creating a DOTS project</li>
      <li class="bulletList">Creating entities with subscenes</li>
      <li class="bulletList">Creating components and bakers</li>
      <li class="bulletList"> Creating systems using Jobs and Burst</li>
      <li class="bulletList">Debugging systems jobs and queries</li>
    </ul>
    <p class="normal">Let’s start by discussing how to set up a project to be compatible with DOTS.</p>
    <h2 id="_idParaDest-285" class="heading-2">Creating a DOTS project</h2>
    <p class="normal">The first step for creating a DOTS project<a id="_idIndexMarker1421"/> is the one you should already know by this point in the book: creating a brand-new URP project. If you are not sure how to do it, please refer to <em class="chapterRef">Chapter 1</em>, <em class="italic">Embark on Your Unity Journey</em>. Make sure you are using the <strong class="screenText">3D (URP)</strong> template, as DOTS is only compatible with URP and HDRP, and we didn’t cover HDRP in this book. You can also add DOTS to an existing project if needed.</p>
    <p class="normal">Now, it’s time to install the needed DOTS packages. We mentioned that there are three key packages: Entities, Jobs, and Burst, and we also mentioned that the rest of the packages are built on top of them. Aside from those packages, we need <strong class="screenText">Entities Graphics</strong> to render our entities. Given that this package has dependencies on the core DOTS packages, just installing it will bring the holy three packages. </p>
    <p class="normal">If you don’t remember how to install packages, please refer to the <em class="italic">Installing ProBuilder</em> section from <em class="chapterRef">Chapter 3</em>,<code class="inlineCode"> </code><em class="italic">From Blueprint to Reality: Building with Terrain and ProBuilder</em>. Those instructions install the <strong class="screenText">ProBuilder</strong> package, but the steps can be extrapolated to install this one. At the time of writing this chapter, <strong class="screenText">Entities Graphics</strong> is in version 1.0.16.</p>
    <figure class="mediaobject"><img src="img/B21361_21_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.1: Installing Entities Graphics and also the Entities package as a dependency</p>
    <p class="normal">You might receive a message about the <strong class="keyWord">Burst</strong> package being updated, which might cause Unity to be unstable. As usual, restart Unity when installing a new package to fix the issue.</p>
    <p class="normal">The next thing to do is to change the URP<a id="_idIndexMarker1422"/> settings to use Forward+, a new URP rendering path that is utilized by DOTS for rendering. Do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Select the currently used SRP asset as explained in the <em class="italic">Configuring performant shadows</em> section of <em class="chapterRef">Chapter 12</em>, <em class="italic">Enlightening Worlds: Illuminating Scenes with the Universal Render Pipeline</em>. In my case, the asset is called <strong class="screenText">URP-HighFidelity</strong>, so you can also search for it by name in the <strong class="screenText">Project</strong> panel.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_21_02.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.2: Seeing the current SRP asset in use.</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">In the <strong class="screenText">Renderer List </strong>of the SRP asset, double-click its first element to select the renderer asset. In my case, it is called <strong class="screenText">URP-HighFidelity-Renderer</strong>, so again, you can just search it in the <strong class="screenText">Project </strong>panel.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_21_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.3: Selecting the Renderer asset used by the SRP asset</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">In the renderer asset, set the <strong class="screenText">Rendering Path</strong> option to <strong class="screenText">Forward+</strong>.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_21_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.4: Activating Forward+ as the current rendering path</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Press the <strong class="screenText">Play</strong> button in the editor to make sure everything works fine. If you see a warning message in the console like the one in <em class="italic">Figure 21.5</em>, make sure you are modifying the proper asset. The console message will tell you the name of the asset to change.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_21_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.5: Warning message when playing a DOTS project and not using Forward+</p>
    <p class="normal">Consider that the other URP renderer assets might be used if the game allows changing the quality settings if the game features an options menu. In such a case, change all renderer assets to use Forward+.</p>
    <div><p class="normal">A discussion about Forward+ is beyond<a id="_idIndexMarker1423"/> the scope of this chapter. For more info, check the following link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/rendering/forward-plus-rendering-path.html">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/rendering/forward-plus-rendering-path.html</a></p>
    </div>
    <p class="normal">There is an extra step that is not necessary for DOTS to work, but that will make the editor experience faster. Just go to <strong class="screenText">Edit | Project Settings | Editor</strong> and check the <strong class="screenText">Enter Play Mode Options</strong> checkbox. This will avoid the costly domain reload process that happens whenever we play a game in the editor. While this might be necessary in GameObject-based projects, pure DOTS projects can avoid it. Enable this option when doing a hybrid DOTS game.</p>
    <div><p class="normal">There are ways to use<a id="_idIndexMarker1424"/> the Play Mode Options in GameObject projects. Check the following documentation link for more info: <a href="https://docs.unity3d.com/Manual/ConfigurableEnterPlayMode.html">https://docs.unity3d.com/Manual/ConfigurableEnterPlayMode.html</a></p>
    </div>
    <p class="normal">Now that we have our project<a id="_idIndexMarker1425"/> properly set up, let’s create our first entity.</p>
    <h2 id="_idParaDest-286" class="heading-2">Creating entities with subscenes</h2>
    <p class="normal">While entities work differently<a id="_idIndexMarker1426"/> from GameObjects, you are still going<a id="_idIndexMarker1427"/> to use GameObjects to create entities in the editor. The idea is to use the familiar Unity tools you are used to working with, like the <strong class="screenText">Scene</strong>, <strong class="screenText">Hierarchy</strong>, and <strong class="screenText">Inspector</strong> panels, and even Prefabs. This works by converting specific GameObjects and their components into their entity equivalents. We will also instantiate entities via scripting later in this chapter.</p>
    <p class="normal">To convert GameObjects to entities in the editor, we are going to use the baking system. It uses bakers – scripts responsible for converting specific components to their entities’ equivalents. Some DOTS packages come with bakers to convert specific Unity components; for example, Entities Graphics has bakers to convert the <code class="inlineCode">MeshFilter </code>and the <code class="inlineCode">MeshRenderer</code> components to their entities’ versions. The converted versions might differ considerably from the original ones, and usually, one component can be converted to several ECS components. If you don’t install the Entities Graphics package, <code class="inlineCode">MeshFilter</code> and <code class="inlineCode">MeshRenderer</code> will be discarded when converting them, as there’s no baker in the project for them, making your entity not be rendered. Later in this chapter, we will create our own bakers.</p>
    <p class="normal">The way to tell Unity<a id="_idIndexMarker1428"/> which GameObjects should be converted <a id="_idIndexMarker1429"/>is via a subscene, which is another scene that will contain just the GameObjects to convert. The idea is for a main scene to load the entities subscene by using the SubScene component, which is responsible for converting and loading the entities in the subscene. Note that the conversion happens in the editor, meaning that no conversion happens when playing the game from a build. This allows loading subscenes extremely fast, thanks to the way scenes are serialized.</p>
    <p class="normal">To create a subscene, do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">In an existing scene, right-click in any empty space of the Hierarchy and select the <strong class="screenText">New Sub Scene | Empty Scene</strong> option. If you see the option grayed out, make sure to save the main scene first.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_21_06.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.6: Creating a subscene</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">In the save-file prompt, save the subscene like you save a regular scene.</li>
      <li class="numberedList">This will create a GameObject with the <strong class="screenText">SubScene </strong>component in the main scene. It will have the Scene Asset property set to reference the subscene file we created. If the <strong class="screenText">New Sub Scene</strong> option is not available, create the subscene asset and GameObject manually until it looks like <em class="italic">Figure 21.7</em>.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_21_07.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.7: A subscene component that loads the subscene asset we just created</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Make sure the checkbox of the subscene GameObject in the Hierarchy is checked, as it allows you to edit the subscene and add objects to it.</li>
      <li class="numberedList">Create a cube using <strong class="screenText">GameObject | 3D Object | Cube</strong> and drag it inside the subscene in the Hierarchy. Make sure you create it inside the subscene by noting the indentation seen in <em class="italic">Figure 21.8</em>. If it is created outside the subscene, the cube will look right, but because it is still a regular GameObject.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_21_08.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.8: Indentation that shows that the Cube is inside the subscene</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">To confirm the cube was converted, select it and check if the <strong class="screenText">Entity Baking Preview</strong> is at the bottom of the <strong class="screenText">Inspector</strong>. Click it to show a list of ECS components converted from the cube’s original components.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_21_09.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.9: Entity Baking Preview showing the ECS components created from your original Cube</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">Make sure the scene camera is pointing to the cube, and then play the game. You must see the cube being rendered in the <strong class="screenText">Game </strong>panel. Make sure that the camera is not inside the subscene; we need it to be a classic GameObject.</li>
    </ol>
    <p class="normal">And that’s it! You created<a id="_idIndexMarker1430"/> your very first<a id="_idIndexMarker1431"/> entity! Of course, it doesn’t do anything fancy, but now we are ready to add custom behavior to it, starting by adding ECS components.</p>
    <h2 id="_idParaDest-287" class="heading-2">Creating components and bakers</h2>
    <p class="normal">Before creating ECS components, let’s discuss<a id="_idIndexMarker1432"/> how they differ from GameObject <a id="_idIndexMarker1433"/>components. Think of GameObject components as individual tools in a toolbox – each one is designed for a specific task, like rendering shapes or detecting collisions. They work independently but together create the functionality of an object in your game. On the other hand, ECS components are more like raw materials in a factory line; they don’t do anything on their own. Instead, they are efficiently processed and assembled by systems to create the desired behavior. This shift from using individual tools (GameObject components) to processing raw materials (ECS components) enables Unity to optimize game performance, especially in complex scenes with many objects.</p>
    <p class="normal">While we still want to add components to entities to add behavior to them, the responsibilities of ECS components are limited to holding only data. This means they won’t have Updates or other events like <code class="inlineCode">OnTriggerEnter</code>; it’s just pure data. They can have methods to facilitate operating on that data but not the core gameplay logic. </p>
    <p class="normal">You might be wondering where our logic will be placed then, and the answer is systems. We will create them later in this chapter, but first, let’s add the entity data required for our gameplay logic to work.</p>
    <p class="normal">With data, I am referring to variables like our character’s bullets, the score, health points, position, and so on. We usually create fields in <code class="inlineCode">MonoBehaviours</code> for such purposes, and here’s no different, but this time, we won’t use classes that inherit from <code class="inlineCode">MonoBehaviour</code>. Instead, we are going to use structs that implement <code class="inlineCode">IComponentData</code>. Structs allow the Entities package to manage the memory of our components differently from how the <strong class="keyWord">Garbage Collector</strong> works by organizing it in a way that leverages the CPU cache. Structs are also compatible with HPC#, the subset of C# compatible with Burst. More about Burst and CPU caching will be discussed later in this chapter.</p>
    <div><p class="normal">The difference between structs<a id="_idIndexMarker1434"/> and classes in C# is outside the scope of this book. You can learn more about this here: <a href="https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct">https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct</a></p>
    </div>
    <p class="normal">You can create a component by creating a script using the plus button in the <strong class="screenText">Project</strong> panel, selecting the <strong class="screenText">C# script</strong> option, and naming the script like the component you want to create. Don’t create the script using the <strong class="screenText">Add Component</strong> button in the Inspector, as we need some extra steps before adding components to the to-be-converted GameObjects. We recommend putting all your ECS components’ scripts inside a <code class="inlineCode">Scripts/ECS/Components</code> folder to easily distinguish between your regular Unity scripts and the ECS scripts.</p>
    <p class="normal">As we want our cube to move<a id="_idIndexMarker1435"/> forward, we need a velocity value. Components with transform<a id="_idIndexMarker1436"/> data like position and rotation were added by Transform bakers included in the Entities package. To create our velocity ECS component, start by creating a script called <code class="inlineCode">Velocity</code> and put the following code inside it.</p>
    <figure class="mediaobject"><img src="img/B21361_21_10.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.10: An ECS component that holds the velocity of the entity</p>
    <p class="normal">Remember that we shouldn’t use classes; use structs instead. While you can use classes, they will be a different type of component (managed component) that is considerably less performant, and we don’t need them now. Also, notice how we included the <code class="inlineCode">Unity.Entities</code> namespace. And that’s it! We have our first ECS component! But we are not finished yet. If you try to add this component to our cube in the subscene, it won’t work. Our component won’t be listed in the <strong class="screenText">Add Component</strong> button in the <strong class="screenText">Inspector</strong>, and you can’t even drag and drop the script file as usual. Remember that the baker system needs a baker for our ECS component and a MonoBehaviour to convert.</p>
    <p class="normal">The idea is to use GameObjects and <code class="inlineCode">MonoBehaviours</code> to use the existing Unity tools to create scenes and convert them to entities through bakers. So far, we created the ECS component, but we still need the <code class="inlineCode">MonoBehaviour</code> version of that component to add it to the subscene GameObjects. The <code class="inlineCode">MonoBehaviour</code> version of our component is called the <strong class="keyWord">Authoring Component</strong>, and the ECS component is the <strong class="keyWord">Runtime Component</strong>. To create the authoring component, create a regular component with the fields we want to configure from the editor. In the following image, you can see the <code class="inlineCode">VelocityAuthoring</code> component:</p>
    <figure class="mediaobject"><img src="img/B21361_21_11.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.11: The authoring component for our Velocity runtime component</p>
    <p class="normal">It’s just the classic MonoBehaviour component<a id="_idIndexMarker1437"/> we are used to creating, with the same fields<a id="_idIndexMarker1438"/> our runtime component will have. Now that we have a component that we can add to our authoring GameObjects in the subscene, just add it to the cube. If you check the <strong class="screenText">Entity Baking Preview</strong> pane at the bottom of the <strong class="screenText">Inspector</strong>, no new ECS component was added. We still need to create the baker to convert <code class="inlineCode">VelocityAuthoring</code> into <code class="inlineCode">Velocity</code>. A baker is a class that inherits from the <code class="inlineCode">Baker </code>class and converts authoring components into runtime components. In the next image, you can see the baker for our <code class="inlineCode">VelocityAuthoring</code> component.</p>
    <figure class="mediaobject"><img src="img/B21361_21_12.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.12: The baker that converts the VelocityAuthoring component to the runtime component</p>
    <p class="normal">As you can see, we created a class that inherits from <code class="inlineCode">Baker&lt;VelocityAuthoring&gt;</code>, meaning that this will be the baker for <code class="inlineCode">VelocityAuthoring</code> when the baking system does the conversion. In the <code class="inlineCode">Bake</code> method, we receive the instance of the authoring component to convert, accessing its data to create the runtime component.</p>
    <p class="normal">First, we get the entity created for the converted GameObject by using the <code class="inlineCode">GetEntity</code> method. Its only parameter highlights that we want this object to move during play mode. Hence, it’s dynamic. Then, we create the instance of the runtime component, and we set its velocity value to be the same as the authoring component. This way, we make sure that the value set in the Inspector is the one that the runtime component will have. Finally, we use the <code class="inlineCode">AddComponent</code> method to add the runtime component to the converted entity.</p>
    <div><p class="normal">For more information<a id="_idIndexMarker1439"/> about the different transform usage flags used in <code class="inlineCode">GetEntity</code>, check this link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-usage-flags.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-usage-flags.html</a></p>
    </div>
    <p class="normal">If you save your scripts and make sure the authoring component is added to the cube, the <strong class="screenText">Entity Baking Preview</strong> pane should show the <strong class="screenText">Velocity</strong> runtime component. You can click it and confirm that its value is the same as the authoring component.</p>
    <figure class="mediaobject"><img src="img/B21361_21_13.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.13: The Entity Baking Preview shows how our runtime component reflects the authoring component value</p>
    <p class="normal">While this seems like a lot to create<a id="_idIndexMarker1440"/> a component, in real projects, this becomes a powerful<a id="_idIndexMarker1441"/> tool. Authoring components might add several runtime components, sometimes conditionally. For example, the <strong class="screenText">Rigidbody</strong> baker in the <strong class="screenText">Unity Physics</strong> package will add different components depending on whether <strong class="screenText">Is Kinematic</strong> is checked or unchecked.</p>
    <p class="normal">Now that we have the needed data, let’s create the system to move our cube.</p>
    <h2 id="_idParaDest-288" class="heading-2">Creating systems using Jobs and Burst</h2>
    <p class="normal">Regular MonoBehaviours not only have<a id="_idIndexMarker1442"/> data but also the logic to create the behavior<a id="_idIndexMarker1443"/> they represent. Sometimes, they need<a id="_idIndexMarker1444"/> data from <a id="_idIndexMarker1445"/>other components, like the position in <code class="inlineCode">Transform</code>, so they use methods like <code class="inlineCode">GetComponent</code> to access other components’ data. In ECS, this works quite differently.</p>
    <p class="normal">Given ECS components have just data, the logic goes into a different place called <strong class="keyWord">Systems</strong>. They apply the game logic, such as moving or rotating objects, to the entities that require such logic. The way for systems to identify which entities must have their logic applied is via their data. Systems will query all entities that have specific sets of components for their logic to work and will iterate the resulting entities to apply that logic. In this case, we want to move entities, but not all entities, just the entities that have the <code class="inlineCode">Velocity</code> component and position data.</p>
    <div><p class="normal">The clarification that our system requires to have position data might be confusing, given that all GameObjects have a <strong class="screenText">Transform</strong> component. This is not necessarily true in DOTS, and it’s explained in more detail in the <code class="inlineCode">TransformUsageFlags</code> property info box we mentioned before. In this project, we will always use <code class="inlineCode">TransformUsageFlag.Dynamic</code>, so for this case, we can assume all entities will have transformation data such as position, rotation, and scale.</p>
    </div>
    <p class="normal">To make our movement system, first, we need to create a script, as seen in the following image:</p>
    <figure class="mediaobject"><img src="img/B21361_21_14.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.14: An empty ECS system that serves as the base to create our movement system</p>
    <p class="normal">A system consists of a partial struct that implements the <code class="inlineCode">ISystem</code> interface. It needs to be partial given that DOTS relies on code generators, meaning that lots of boilerplate code to make a system work will be in another <code class="inlineCode">MovementSystem</code> partial struct created automatically for us. We also added an <code class="inlineCode">OnUpdate</code> method, the equivalent to the MonoBehaviour’s <code class="inlineCode">Update</code> method, but with a very important difference.</p>
    <div><p class="normal">Again, the <code class="inlineCode">partial</code> keyword<a id="_idIndexMarker1446"/> is outside the scope of the book. Check the following link for more info: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods">https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/partial-classes-and-methods</a></p>
    </div>
    <p class="normal">The regular <code class="inlineCode">Update</code> method belongs to specific components, meaning that the <code class="inlineCode">Update</code> will be executed once per component instance. If we have 100 <code class="inlineCode">GameObjects</code> with a <code class="inlineCode">MonoBehaviour</code> that has an <code class="inlineCode">Update</code> method, that method will be executed 100 times per frame, once for each <code class="inlineCode">GameObject</code>. But in this case, by default, there’s always a single instance of our system in the game, which is created automatically by the Entities package, regardless of the entities present in the scene. This means that our movement systems <code class="inlineCode">OnUpdate</code> method will be executed once per frame as soon as we play the game, just because the system script exists. There are ways to prevent the automatic system creation, to have more than one instance of a system, and to prevent the <code class="inlineCode">OnUpdate</code> execution, but let’s keep things simple.</p>
    <p class="normal">After saving your system script, to make sure it is working, play the game and, during play mode, open the <code class="inlineCode">Systems</code> panel in <strong class="screenText">Window | Entities | System</strong>. This window will list all the systems that are running and their performance metrics.</p>
    <figure class="mediaobject"><img src="img/B21361_21_15.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.15: The Systems window showing our Movement System.</p>
    <p class="normal">The next step is to iterate all entities<a id="_idIndexMarker1447"/> that have the <code class="inlineCode">Velocity</code> and the <code class="inlineCode">LocalTransform</code> component. The latter<a id="_idIndexMarker1448"/> is one of the several Transform<a id="_idIndexMarker1449"/> ECS equivalents added by the Transform bakers. There<a id="_idIndexMarker1450"/> are several ways to iterate entities, but let’s first see the most common and performant way, using jobs. Jobs are structs that contain the logic we want to apply in multiple threads, and the data needed to apply it, such as delta time or the positions of the objects to move. In our case, the data will be the entity components and some extra data, like delta time. To iterate entities, we have a type of job called <code class="inlineCode">IJobEntity</code>. There are plenty of job types for different purposes, but for ECS, we will be using <code class="inlineCode">IJobEntity</code> most of the time.</p>
    <p class="normal">In the following figure, you can see a job script that moves all entities with <code class="inlineCode">Velocity</code> and <code class="inlineCode">LocalTransform</code>:</p>
    <figure class="mediaobject"><img src="img/B21361_21_16.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.16: A job to move entities that have LocalTransform and Velocity components</p>
    <p class="normal">There are a lot of things happening here, so let’s analyze this script piece by piece:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">We created a partial<a id="_idIndexMarker1451"/> struct that implements <code class="inlineCode">IJobEntity</code><strong class="screenText"> </strong>in a script<a id="_idIndexMarker1452"/> that uses the <code class="inlineCode">Unity.Entities</code> and <code class="inlineCode">Unity.Transforms</code> namespaces.</li>
      <li class="numberedList">This struct has an <a id="_idIndexMarker1453"/>execute method<a id="_idIndexMarker1454"/> with two parameters, one of type <code class="inlineCode">LocalTransform</code><strong class="screenText"> </strong>and the other of <code class="inlineCode">Velocity</code><strong class="screenText"> </strong>type. It’s no coincidence that these parameters match the exact components we need to move entities. The parameters defined in the <code class="inlineCode">Execute</code><strong class="screenText"> </strong>method of an <code class="inlineCode">IJobEntity</code><strong class="screenText"> </strong>serve to tell ECS that we want to iterate entities with such components, ignoring the ones without them.</li>
      <li class="numberedList">The <code class="inlineCode">LocalTransform</code><strong class="screenText"> </strong>parameter is prefixed by a <code class="inlineCode">ref</code> keyword, while <code class="inlineCode">Velocity</code><strong class="screenText"> </strong>is prefixed by an <code class="inlineCode">in</code> keyword. Those are ways to tell ECS the privileges we want over those components. <code class="inlineCode">Ref</code> means that we will modify <code class="inlineCode">LocalTransform</code>, while <code class="inlineCode">in</code> means we will only read the data of <code class="inlineCode">Velocity</code>. For the job system to make sure any job is safe to execute in parallel with others, it needs to know how the data in them will be treated. Two jobs that write the same data (for example, two jobs that move objects in different ways) cannot be executed in parallel to prevent race conditions and using locks. However, two jobs that read the same data can execute in parallel, given that read-only operations are thread-safe. Always define parameters as <code class="inlineCode">in</code> (read-only) whenever possible, using <code class="inlineCode">re</code> only when necessary.</li>
      <li class="numberedList">We calculate the number of meters to move as usual by multiplying the velocity with delta time. We didn’t access delta time, as usual, using <code class="inlineCode">Time.deltaTime</code>. To allow for safe job parallelization, they are designed to deal only with the data inside the job, avoiding accessing static variables whenever possible. That’s why delta time is a field in the struct so that later when we instantiate the job in our system, we will fill this data.</li>
      <li class="numberedList">In <code class="inlineCode">MonoBehaviours</code>, modifying the axes returned by <code class="inlineCode">transform.position</code> directly (not storing it in a variable) is not possible; given that <code class="inlineCode">transform.position</code> returns a copy of the position, modifying it will throw an error. The same applies to any other getter. But in ECS, it’s perfectly valid, given that we are manipulating the data by reference, not just a copy. We accessed <code class="inlineCode">LocalTransform</code><strong class="screenText"> </strong>via a <code class="inlineCode">ref</code> keyword, meaning that we are accessing the position memory directly. In regular <code class="inlineCode">MonoBehaviours</code>, this is not possible, given the position of our GameObjects is stored in the C++ side of a Transform, so copies are necessary.</li>
    </ol>
    <div><p class="normal">Jobs can access mutable static data if they are not Burst-compiled (more on this later). But even if that is possible, it is highly dangerous as the ECS safety systems cannot prevent two jobs from modifying such static data. That’s why it is safer to copy the data to the job as we did with <code class="inlineCode">Time.deltaTime</code>.</p>
    </div>
    <p class="normal">Now, the only responsibility<a id="_idIndexMarker1455"/> of <code class="inlineCode">MovementSystem </code>is to instantiate the job, fill in its data, and schedule<a id="_idIndexMarker1456"/> it. By scheduling<a id="_idIndexMarker1457"/> it, the job system will take<a id="_idIndexMarker1458"/> care of checking when it is safe to execute our job, considering how other systems’ jobs might read and write the same data our job needs. Remember that the idea of defining read-write or read-only access for our components when using the <code class="inlineCode">ref</code> and <code class="inlineCode">in</code> keywords is to allow the job scheduler to take such considerations.</p>
    <p class="normal">Our system’s OnUpdate method will look like the following figure:</p>
    <figure class="mediaobject"><img src="img/B21361_21_17.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.17: The movement system instancing MoveJob and scheduling it</p>
    <p class="normal">As you can see, we simply instantiate the job, filling the <code class="inlineCode">DeltaTime</code> field with this frame’s delta time, and then we schedule the job using <code class="inlineCode">ScheduleParallel</code>. The first thing to notice is that we used <code class="inlineCode">SystemAPI.Time.DeltaTime</code> is the ECS way to get the frame’s delta time. </p>
    <p class="normal">ECS has its own timing mechanism, and while we can still use <code class="inlineCode">Time.DeltaTime</code>, we should stick to the ECS version to work properly with the rest of the systems. Also, we didn’t specify the entities the job will iterate. Systems code generators know the entities we want to iterate based on the system job’s <code class="inlineCode">Execute </code>method parameters, so we don’t need to worry about providing this data to the job.</p>
    <p class="normal">Finally, we used the <code class="inlineCode">ScheduleParallel</code> method to not only tell the job scheduler to schedule our job but also to tell it that we want to iterate the entities in parallel. This means that the job worker threads (usually one for each CPU core) will be processing different entities, reducing the time it takes to execute our logic by spreading the work. You can also use <code class="inlineCode">Schedule</code> instead, which processes all our entities in a single core but still in parallel with other jobs. For now, we will stick with <code class="inlineCode">ScheduleParallel</code> for most cases.</p>
    <p class="normal">Now we need the final piece of the DOTS tri-force, Burst. Remember, Burst will take HPC# compliant code and convert it into performant native code. Here’s a non-comprehensive list of requirements of HPC#:</p>
    <ul>
      <li class="bulletList">Using managed references (objects) is not possible. This includes strings, arrays, lists, dictionaries, and most of the C# libraries, like <code class="inlineCode">System.Collections</code>.</li>
      <li class="bulletList">Exceptions (try/catch) work in the editor, but they will abort execution in builds.</li>
      <li class="bulletList"><code class="inlineCode">Debug.Log</code> support is limited to constant strings, string interpolation, and <code class="inlineCode">string.Format</code>.</li>
      <li class="bulletList">Static read-only data and <a id="_idIndexMarker1459"/>constants are safe. Mutable static data isn’t unless the <code class="inlineCode">SharedStatic</code><strong class="keyWord"> </strong>struct is used: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/csharp-shared-static.html">https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/csharp-shared-static.html</a></li>
    </ul>
    <p class="normal">We have used HPC# in the code<a id="_idIndexMarker1460"/> so far, so we just need to tag the code<a id="_idIndexMarker1461"/> to Burst-compile <a id="_idIndexMarker1462"/>using the <code class="inlineCode">BurstCompile</code> attribute. In systems, you can<a id="_idIndexMarker1463"/> add this attribute to the <code class="inlineCode">OnUpdate</code> method, and for jobs, add the attribute to the <code class="inlineCode">job</code> struct to Burst-compile its <code class="inlineCode">Execute</code> method.</p>
    <figure class="mediaobject"><img src="img/B21361_21_18.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.18: Burst-compiling our systems and jobs</p>
    <div><p class="normal">There are some considerations<a id="_idIndexMarker1464"/> to follow in your code to make Burst work even faster. Check this link for more information: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/optimization-overview.html">https://docs.unity3d.com/Packages/com.unity.burst@1.8/manual/optimization-overview.html</a></p>
    </div>
    <p class="normal">Now, you can play the game and observe how our cube will move forward. Feel free to copy the cube several times over the scene until you have hundreds or even thousands of them. See how the game performance doesn’t suffer!</p>
    <p class="normal">It is easy for the systems to not work as expected when entities are misconfigured, like forgetting to add the <code class="inlineCode">Velocity</code> component. This can cause<a id="_idIndexMarker1465"/> systems to not find the entities<a id="_idIndexMarker1466"/> they need. Let’s see how to debug systems<a id="_idIndexMarker1467"/> to see the entities<a id="_idIndexMarker1468"/> they found, which jobs they are scheduling, and check if their code is Burst-compiled.</p>
    <h2 id="_idParaDest-289" class="heading-2">Debugging system jobs and queries</h2>
    <p class="normal">Systems apply logic by iterating<a id="_idIndexMarker1469"/> entities that have specific components, using jobs <a id="_idIndexMarker1470"/>and other methods. To debug a non-working system, we should<a id="_idIndexMarker1471"/> check if it is finding entities. To do so, the system code generator creates instances of <code class="inlineCode">EntityQuery</code>, a type responsible for finding entities with specific components. Our <code class="inlineCode">MoveJob</code> job requires entities with <code class="inlineCode">LocalTransform</code> and <code class="inlineCode">Velocity</code>, so an entity query is generated automatically in the <code class="inlineCode">MovementSystem</code> for it to schedule its job. Systems could iterate different groups of entities (for example, when scheduling more than one job), so systems can have several queries. Entity queries can also be created manually for other purposes, but we don’t need them now.</p>
    <div><p class="normal">Entity queries are fast due to them caching archetype chunks. These memory chunks store entities that have the same set of components, so it’s easy to track where the required entities are located. For more<a id="_idIndexMarker1472"/> info on archetypes, see the following link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.1/manual/concepts-archetypes.html">https://docs.unity3d.com/Packages/com.unity.entities@1.1/manual/concepts-archetypes.html</a></p>
    </div>
    <p class="normal">We can use the <strong class="screenText">Systems</strong> window (<strong class="screenText">Window | Entities | Systems</strong>) during play mode to see how many entities our system is finding and all the queries that find them. Check the <strong class="screenText">Entity Count</strong> column of a system. Also, after selecting the system in the list, the <strong class="screenText">Inspector</strong> will show the system queries, informing each query component.</p>
    <figure class="mediaobject"><img src="img/B21361_21_19.png" alt="" role="presentation"/></figure>
    <figure class="mediaobject">Figure 21.19: Checking system’s queries using the Systems window and the Inspector</figure>
    <p class="normal">Use the <strong class="screenText">Relationships</strong> tab to see which entities match the query. In the following image, you can see that our query is finding our cube.</p>
    <figure class="mediaobject"><img src="img/B21361_21_20.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.20: Checking the entities matching the system’s queries.</p>
    <p class="normal">If your queries don’t match the expected<a id="_idIndexMarker1473"/> entities, check if such entities have the required<a id="_idIndexMarker1474"/> components. It’s easy to forget to add the authoring components<a id="_idIndexMarker1475"/> into our entities or even forget to put the authoring GameObjects inside the subscene, mistakenly leaving them in the main scene.</p>
    <p class="normal">Another thing to check is if our system is scheduling the job and to see if the system and the jobs are Burst-compiled. To do so, we can do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Open the Unity Profiler as we saw in <em class="chapterRef">Chapter 18</em>, <em class="italic">Performance Wizardry: Optimizing Your Game with Profiler Tools</em>.</li>
      <li class="numberedList">Capture profiling data during play mode and select any frame.</li>
      <li class="numberedList">Enable the <strong class="screenText">Timeline</strong> view if you are not already there by clicking any place in the CPU usage module, clicking the <strong class="screenText">Hierarchy</strong> button to display the selection box, and clicking <strong class="screenText">Timeline</strong>.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_21_21.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.21: Enabling Timeline mode in the Profiler’s CPU module</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Search for your job in the <strong class="screenText">timeline</strong> by using the mouse wheel to zoom in. Your system should be inside the <strong class="screenText">SimulationSystemGroup </strong>profiler marker. Note that even if we have thousands of entities, our system is only scheduling a job to iterate them, so its marker will be very small.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_21_22.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.22: Finding our systems in the profiler</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Check the marker color. If it’s light green, it means it is burst compiled. If it is light blue, it is not, meaning we didn’t add the <code class="inlineCode">BurstCompile</code><strong class="screenText"> </strong>attribute to the <code class="inlineCode">OnUpdate</code><strong class="screenText"> </strong>method, or we tried to Burst-compile non-HPC# code. Notice how the non-Burst-compiled version is significantly slower than the Burst-compiled one in the following image.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_21_23.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.23: Non-Burst compiled system code</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">In the profiler, click<a id="_idIndexMarker1476"/> the three dots<a id="_idIndexMarker1477"/> button in the top-right part<a id="_idIndexMarker1478"/> of the timeline (not the similar button in the top-right corner of the window) and enable <strong class="screenText">Show Flow Events</strong>. This will enable us to see the jobs our system schedules.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_21_24.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.24: Enabling flow events</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">Select our system in the timeline and follow the lines to the jobs. You should see several instances of it in different threads, as each instance deals with different groups of entities (if there are enough). Remember to expand the job thread group using the gray triangle at its left to see the job’s details.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_21_25.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.25: Checking the jobs scheduled by our system.</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">Check if the job’s marker color is light green. If it’s not, remember to add the <code class="inlineCode">BurstCompile</code><strong class="screenText"> </strong>method to the <code class="inlineCode">job</code> struct (not the <code class="inlineCode">Execute</code> method).</li>
    </ol>
    <p class="normal">In this section, we discussed how to create and configure a DOTS project and how to create a subscene where we placed GameObjects to convert them to entities. We also created a runtime component (<code class="inlineCode">Velocity</code>), added to our converted entities by a baker (<code class="inlineCode">VelocityBaker</code>), which converted the authoring component (<code class="inlineCode">VelocityAuthoring</code>) to the runtime component. We used the velocity value to create a system that scheduled a job that applied that velocity to each entity’s <code class="inlineCode">LocalTransform</code> position, moving the entities. Finally, we saw how to debug our systems, check the queries they created to iterate entities in jobs, and see the system-job relationship and performance using the Unity Profiler.</p>
    <p class="normal">Of course, we<a id="_idIndexMarker1479"/> have just scratched<a id="_idIndexMarker1480"/> the DOTS<a id="_idIndexMarker1481"/> surface. In the next section, we will see how to create more interesting gameplay, like moving and spawning enemies.</p>
    <h1 id="_idParaDest-290" class="heading-1">Creating gameplay in DOTS</h1>
    <p class="normal">Lots of things we do in MonoBehaviours, like instantiating<a id="_idIndexMarker1482"/> objects or getting other object data (for example, their position), are quite differently implemented in DOTS. In this section, we will examine how to achieve these things in DOTS:</p>
    <ul>
      <li class="bulletList">Moving using input and tag components</li>
      <li class="bulletList">Creating seeking missiles using component lookups</li>
      <li class="bulletList">Destroying the character with entity command buffers</li>
      <li class="bulletList">Dealing with errors in bursted code</li>
      <li class="bulletList">Instantiating missiles with entity Prefabs</li>
      <li class="bulletList">Making the camera follow our character</li>
      <li class="bulletList">Exploring other DOTS features</li>
    </ul>
    <p class="normal">Let’s start by discussing how to modify our movement code to respond to input.</p>
    <h2 id="_idParaDest-291" class="heading-2">Moving using input and tag components</h2>
    <p class="normal">Let’s start creating gameplay<a id="_idIndexMarker1483"/> by using input to move the cube. We need to change our movement job to provide it with the input values. We will do this the same way as we provided delta time by passing the input values to the job. In the next image, you can see the needed changes:</p>
    <figure class="mediaobject"><img src="img/B21361_21_26.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.26: Moving our character based on our input</p>
    <p class="normal">While <code class="inlineCode">LocalTransform</code> has a <code class="inlineCode">Translate</code> method, it doesn’t move in relative coordinates. That’s why we needed to construct<a id="_idIndexMarker1484"/> the movement vectors by using the <code class="inlineCode">Right</code> and <code class="inlineCode">Forward</code> methods, which provide such directions relative to our object. We apply a similar update to our position for forward movement by adding a vector along the forward direction, multiplied by the current input’s <code class="inlineCode">Vertical</code> value and <code class="inlineCode">DeltaTime</code>.</p>
    <p class="normal">Finally, we modified our system to provide the input values like this:</p>
    <figure class="mediaobject"><img src="img/B21361_21_27.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.27: Providing input values to the move job</p>
    <p class="normal">We used the legacy input system here for simplicity. Feel free to use the new one. Now, you can play the game and control the cubes with input. We deleted all the extra cubes, leaving just one to represent our player.</p>
    <p class="normal">Something to consider is that while our movement system will move anything with the <code class="inlineCode">Velocity </code>component, there can be other objects with velocity that could move in different ways (for example, via AI). We need to differentiate the objects that will apply velocity via input and the ones that apply it differently. One way would be to rename our <code class="inlineCode">velocity</code> component to something like “<code class="inlineCode">PlayerVelocity</code>” and then create other velocity components for the other future movement methods. While that will work, it might not be the best approach, depending on your game requirements. Let’s say we have a velocity area that speeds up any entity in an area. If we use the multi-component approach, our area will need to consider all the different velocity components we have, complicating<a id="_idIndexMarker1485"/> our code.</p>
    <p class="normal">Another approach could be adding a unique component to our player entity to differentiate it from other entities, requesting such a component in our job. But such a component doesn’t need any data. Can we add a component with no data? Yes! We call them<a id="_idIndexMarker1486"/> tag components. As the name<a id="_idIndexMarker1487"/> suggests, they serve as a way to mark entities for systems to find them easily.</p>
    <div><p class="normal">If you read the archetypes link provided before, you should be aware that adding tag components will split entities into different chunks. Avoid adding too many unique tag components to individual entities to prevent having too many chunks with just a few entities inside. This phenomenon<a id="_idIndexMarker1488"/> is called archetype fragmentation.</p>
    </div>
    <p class="normal">First, let’s create the runtime component, authoring component, and baker for our <code class="inlineCode">Player</code> tag. Remember to add the <code class="inlineCode">PlayerAuthoring</code> component to our player entity (the cube).</p>
    <figure class="mediaobject"><img src="img/B21361_21_28.png" alt="" role="presentation"/></figure>
    <figure class="mediaobject">Figure 21.28: Scripts needed to create a player tag component</figure>
    <p class="normal">We didn’t create a new <code class="inlineCode">Player</code> component to add. Instead, we used the <code class="inlineCode">AddComponent&lt;Player&gt;</code> API specifying <code class="inlineCode">Player</code> as the component to add. Once added to the player entity, let’s use this tag component in our job to make it only move entities with it. While we can add <code class="inlineCode">Player</code> as a job’s <code class="inlineCode">execute</code> method parameter, as we did with the previous components, we won’t read or write data on it – it doesn’t have data after all. Instead, another way to tell our job to iterate entities with specific components is by using the <code class="inlineCode">WithAll</code> attribute, as seen in the next image:</p>
    <figure class="mediaobject"><img src="img/B21361_21_29.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.29: Making the job’s autogenerated query to look for entities with the Player tag.</p>
    <p class="normal">This way, we can reuse<a id="_idIndexMarker1489"/> the <code class="inlineCode">Velocity</code><code class="inlineCode"><a id="_idIndexMarker1490"/></code> component with the guarantee that each entity receives the required logic. Now, let’s add an enemy to our game.</p>
    <h2 id="_idParaDest-292" class="heading-2">Creating seeking missiles using component lookups</h2>
    <p class="normal">In this example project, we will make<a id="_idIndexMarker1491"/> the player evade seeking missiles<a id="_idIndexMarker1492"/> that will constantly spawn. To do so, we will need a missile entity with the following data:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Position and rotation</strong>: represented by <code class="inlineCode">LocalTransform</code>.</li>
      <li class="bulletList"><strong class="keyWord">Movement velocity</strong>: the same <code class="inlineCode">Velocity</code> we already have.</li>
      <li class="bulletList"><strong class="keyWord">Steering velocity</strong>: a new <code class="inlineCode">Steering</code> component we will create.</li>
      <li class="bulletList"><strong class="keyWord">A target entity to follow</strong>: a new <code class="inlineCode">Target</code> component we will create.</li>
    </ul>
    <p class="normal">Steering velocity should be a straightforward component to create. Just do the same as we did to create the movement velocity component, but name it differently. Regarding the Target component, it will look like the following figure:</p>
    <figure class="mediaobject"><img src="img/B21361_21_30.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.30: Creating the Target component</p>
    <p class="normal">The first thing to notice is that we<a id="_idIndexMarker1493"/> are using the <code class="inlineCode">Entity</code> type<a id="_idIndexMarker1494"/> as the <code class="inlineCode">Target</code> component value. This is the ECS equivalent of having a reference to a target GameObject. We use the entity reference to get data from it, like its position. Notice that the authoring component references a GameObject because, while editing, we still use GameObjects, so we are referencing the <code class="inlineCode">Player</code> GameObject that will be converted to an entity. Finally, the baker not only needs to call <code class="inlineCode">GetEntity</code> to get the entity we are converting to add components but also to get the converted entity of the target GameObject.</p>
    <p class="normal">Now, you can create a sphere called <code class="inlineCode">Missile</code> in the subscene and add the <code class="inlineCode">Velocity</code>, <code class="inlineCode">SteeringVelocity</code>, and <code class="inlineCode">Target</code> authoring components. Remember to configure the <code class="inlineCode">Target</code> component by dragging the player GameObject in the subscene to the <strong class="screenText">Value</strong> property.</p>
    <figure class="mediaobject"><img src="img/B21361_21_31.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.31: Creating the missile authoring GameObject</p>
    <p class="normal">Now, we can create a system to move the missiles towards the player. While we could create a <code class="inlineCode">Missile</code> tag component as we did with the player, we have enough components to make the steering system find the missiles. We will make this system iterate entities with <code class="inlineCode">Velocity</code>, <code class="inlineCode">SteeringVelocity</code>, and <code class="inlineCode">Target</code>, given that non-steering<a id="_idIndexMarker1495"/> entities are unlikely<a id="_idIndexMarker1496"/> to have this specific set of entities in our game so far.</p>
    <p class="normal">This is how the steering job will look:</p>
    <figure class="mediaobject"><img src="img/B21361_21_32.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.32: Steering job</p>
    <p class="normal">The first thing to notice is the <code class="inlineCode">TransformLookup</code> field of type <code class="inlineCode">ComponentLookup</code>. So far, for the data we read from the entities we are iterating, we used the <code class="inlineCode">ref</code> and <code class="inlineCode">in</code> parameters as ways to access them, but this time, we need access to data from entities other than the ones the job iterates, so we can’t use the parameters. As the name suggests, a lookup allows us to get data from other entities, meaning we can retrieve components from entities using them. We are using it to get the target’s transform into the <code class="inlineCode">targetTransform</code> variable, providing the target entity in brackets.</p>
    <p class="normal">Another thing to notice is that we have the <code class="inlineCode">LocalToWorld</code> lookup. The ECS transform systems use this other component to store the local-to-world matrices. This means that this component has the world position, rotation, and scale of the target entity, unlike <code class="inlineCode">LocalTransform</code>, which provides the local ones. This component allows us to get the world space entity position, regardless of where the parent transforms are.</p>
    <p class="normal">We also used this component<a id="_idIndexMarker1497"/> due to a tricky issue. Our job<a id="_idIndexMarker1498"/> is to modify the position of entities in relation to other entities’ positions. We also use <code class="inlineCode">ScheduleParallel</code> to schedule jobs, creating several jobs that handle different entities. This can lead to one job instance reading the position of an entity that another job instance is writing, which can cause several issues. Unity can detect such cases and warn us, but in this case, it is not needed, given we are reading the <code class="inlineCode">LocalToWorld</code> component to get the target’s position while we are modifying the missile entities’ positions via <code class="inlineCode">LocalTransform</code>. This way, we don’t risk reading and writing the same component simultaneously. Actually, <code class="inlineCode">LocalToWorld’s</code> data is derived from the <code class="inlineCode">LocalTransform</code> value by one of the several ECS transform systems. Also, notice how the lookup is declared as <code class="inlineCode">ReadOnly</code>, given we won’t modify other entities’ <code class="inlineCode">LocalToWorld</code>; we just read them. Modifying <code class="inlineCode">LocalToWorld</code> won’t make sense because, as we mentioned before, its value is calculated from <code class="inlineCode">LocalTransform</code> before rendering the entities.</p>
    <div><p class="normal">We tried to explain the transform <a id="_idIndexMarker1499"/>system as briefly as possible, but for more info about how it works, check this link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-concepts.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/transforms-concepts.html</a></p>
    </div>
    <p class="normal">Finally, we also check if the target entity is null, although we are not using the regular null, but <code class="inlineCode">Entity.Null</code>. Structs cannot be null, given they are not reference types; they always have a value. <code class="inlineCode">Entity.Null</code> is a special value that entity variables have when not referencing entities. The rest of the steering job uses regular vector math to apply steering.</p>
    <p class="normal">Finally, the system that schedules this job looks like this:</p>
    <figure class="mediaobject"><img src="img/B21361_21_33.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.33: Steering system scheduling the steering job</p>
    <p class="normal">We used the <code class="inlineCode">GetComponentLookup</code>method to provide the component lookup to our job. We used <code class="inlineCode">true</code> as the first parameter to let it know that we needed a read-only lookup. Component lookups are expensive to use, given they introduce indirection, causing cache misses. It is always preferred to use jobs to get entity data, but in this case, they are the only way to get other entity data.</p>
    <div><p class="normal">For more information about what a cache miss is and how DOTS deals with them, check the following blog post: <a href="https://blog.innogames.com/unitys-performance-by-default-under-the-hood/">https://blog.innogames.com/unitys-performance-by-default-under-the-hood/</a></p>
    </div>
    <p class="normal">Now, just play the game and observe the missile following the player. Consider setting a small velocity but a high steering<a id="_idIndexMarker1500"/> velocity (like <code class="inlineCode">2.0</code>) to let the missile<a id="_idIndexMarker1501"/> rotate fast enough to approach the player.</p>
    <p class="normal">Now that we have the missile, let’s make it destroy the player when it is close enough.</p>
    <h2 id="_idParaDest-293" class="heading-2">Destroying the character with entity command buffers</h2>
    <p class="normal">To let the missile destroy<a id="_idIndexMarker1502"/> the player, we need to detect<a id="_idIndexMarker1503"/> when it’s close enough. In regular GameObjects, we can implement this via triggers (<code class="inlineCode">OnTriggerEnter</code>), but discussing the DOTS physics package is out of the scope of this chapter. Instead, we are going to create a job with simple distance checks, as seen in the following image:</p>
    <figure class="mediaobject"><img src="img/B21361_21_34.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.34: Distance checks in ECS</p>
    <p class="normal">This job works similarly to the steering job but does squared distance checks. Now, the tricky part is destroying the entity. Given there could be several jobs running in parallel iterating entities, it’s not safe to delete an entity right away. The only safe place to delete, create, or modify entities’ components, operations also known as structural changes, is on the main<a id="_idIndexMarker1504"/> thread, and jobs run in job worker threads. When a system makes structural changes on the main thread, a sync point is generated, meaning that the main thread will be blocked until all jobs iterating entities finish, which can cause severe delays. Another issue is that, given we can have several systems that require structural changes, we run the risk of introducing several sync points. The best approach is to accumulate several structural changes and let specific systems execute them – ideally, just one. This way, we reduce the number of sync points, and that’s the exact purpose of <strong class="keyWord">Entity Command Buffer</strong> (<strong class="keyWord">ECB</strong>) systems.</p>
    <div><p class="normal">Structural changes<a id="_idIndexMarker1505"/> can be costly in terms of performance. For more details on them, check this link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-structural-changes.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-structural-changes.html</a></p>
    </div>
    <p class="normal">ECB systems have APIs<a id="_idIndexMarker1506"/> to create <strong class="keyWord">Entity Command Buffers</strong> (<strong class="keyWord">ECBs</strong>), allowing systems<a id="_idIndexMarker1507"/> and jobs to enqueue commands in them, such as to instantiate or destroy entities. Our destroy system will use them to enqueue the player destruction when the missile is near enough. Let’s start by modifying our job to receive an ECB and use it.</p>
    <figure class="mediaobject"><img src="img/B21361_21_35.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.35: Using ECBs to destroy the target entity</p>
    <p class="normal">We added a variable to pass the ECB to our job, which will be provided by the system when creating it. Then, we used the ECB’s <code class="inlineCode">DestroyEntity</code> method, specifying that we want to destroy the target entity. The zero we provide is a way to sort the commands before executing them, but in this case, we don’t need any specific order.</p>
    <div><p class="normal">To better understand<a id="_idIndexMarker1508"/> the need for a sorting key in ECBs, check this link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entity-command-buffer-playback.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entity-command-buffer-playback.html</a></p>
    </div>
    <p class="normal">Then, we need to create a system like the following image:</p>
    <figure class="mediaobject"><img src="img/B21361_21_36.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.36: Destroy close target system</p>
    <p class="normal">We accessed the <code class="inlineCode">Singleton</code> component<a id="_idIndexMarker1509"/> from an ECB system called <code class="inlineCode">EndSimulationEntityCommandBufferSystem</code>, using the <code class="inlineCode">GetSingleton</code> API. This method allows us to get the unique instance of an ECS<a id="_idIndexMarker1510"/> component, provided we are sure there’s only one. You might be wondering: can systems have components? And yes, they can. In data-driven games, all data sharing happens through components. Every system has an entity to which they can add components and share data with other systems and jobs. Given there’s only one instance of this ECB system, we know we have just one instance of the <code class="inlineCode">Singleton </code>component. It has the <code class="inlineCode">CreateCommandBuffer</code> method, which creates an ECB whose commands will be executed when the ECB system updates. The <code class="inlineCode">EndSimulationEntityCommandBufferSystem</code> system will execute its ECB commands at the end of the simulation system before the presentation of the ones that render our entities’ graphics. This way, our jobs can enable structural changes (like destroy) to be executed safely in the main thread later, along with commands from other systems that use the same ECB system.</p>
    <p class="normal">We need to provide the world our system lives in as the first parameter of this method. A world is a set of entities and systems that can run in parallel to other worlds. For example, in the <code class="inlineCode">Netcode for Entities </code>package, we can run the server and client worlds in parallel when the player acts as the game’s host. We have just one world in this case.</p>
    <div><p class="normal">Read more about<a id="_idIndexMarker1511"/> worlds here: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-worlds.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/concepts-worlds.html</a></p>
    </div>
    <p class="normal">We also called the <code class="inlineCode">AsParallelWriter</code> method, which returns an ECB version that allows it to be used in several threads. Remember that our job executes multiple instances in parallel, so the parallel writer version makes sure it’s safe to use in our job’s instances. Finally, we provided the ECB to the job.</p>
    <p class="normal">If you press play now and let the missile catch the player, you will see how it disappears! But wait! Now the console is spamming errors. While familiar, these errors are not quite the same as the ones we are used to receiving in GameObject-based projects; these are more cryptic. That’s because the error happened<a id="_idIndexMarker1512"/> in bursted code (short for Burst-compiled code), and errors<a id="_idIndexMarker1513"/> here behave a little bit differently. Let’s explore how to debug them.</p>
    <h2 id="_idParaDest-294" class="heading-2">Dealing with errors in bursted code</h2>
    <p class="normal">In the next image, you can<a id="_idIndexMarker1514"/> see the error we received in the<a id="_idIndexMarker1515"/> previous step.</p>
    <figure class="mediaobject"><img src="img/B21361_21_37.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.37: Burst error logs</p>
    <p class="normal">First is a familiar C# error, but the stack trace is very verbose. After carefully reading it, you can see that each stack trace line is prefixed by a “#” symbol, showing the name of the called method. Following these symbols, we can find our job in line 5, but not much more info. We can infer where our code failed by checking the next line – in this case, the <code class="inlineCode">ComponentLookup</code> call. Given our job uses lookups just once, we can infer that we are trying to get the transform of the target entity, but that it doesn’t exist anymore.</p>
    <figure class="mediaobject"><img src="img/B21361_21_38.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.38: Burst error stack trace</p>
    <p class="normal">To make stack traces clearer, you can<a id="_idIndexMarker1516"/> disable Burst in the editor. That will make the error logs<a id="_idIndexMarker1517"/> look like usual, indicating the line where the error happened. Disable it by unchecking the <strong class="screenText">Jobs | Burst | Enable Compilation</strong> option. Play again to see that now the logs indicate the line of the job where the error happens (line 21). I recommend getting familiar with the Burst errors log, as in builds, we cannot fall back into non-bursted code without recompiling our player after removing the <code class="inlineCode">BurstCompile </code>attributes. Moreover, disabling Burst while developing can help iteration times, given that compiling Burst code takes longer than regular code, and while developing, we don’t need peak performance all the time.</p>
    <p class="normal">Regarding the error, it happened because the entity the missile was steering to (the player) was destroyed when we got close to it. To solve this, we can modify the <code class="inlineCode">SteeringJob</code> job’s<code class="inlineCode"> Execute</code> method, like in the following image:</p>
    <figure class="mediaobject"><img src="img/B21361_21_39.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.39: Checking if the entity has LocalToWorld components</p>
    <p class="normal">We also need to do the same for the <code class="inlineCode">DestroyCloseTargetJob</code> job’s <code class="inlineCode">Execute</code> method:</p>
    <figure class="mediaobject"><img src="img/B21361_21_40.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.40: Checking if the entity has LocalToWorld components</p>
    <p class="normal">Now, we not only check if the target entity is null but also if it has a transform using the <code class="inlineCode">TryGetComponent</code> lookup method. This method returns a boolean indicating whether the requested entity has the requested component, returning it in the out parameter. If the entity doesn’t have the component or the entity doesn’t exist, the method will return <code class="inlineCode">false</code>. This way, we are quitting the job early if the target entity doesn’t have the component or was destroyed. In MonoBehaviours, a null check would be enough, but in DOTS, it isn’t. Leaving aside the specifics that allow that in MonoBehaviours, an <code class="inlineCode">Entity</code> variable like target, internally, is just an integer ID. ECS uses it in a lookup table to determine where the entity data is stored (which chunk). <code class="inlineCode">Entity.Null</code> is just an invalid ID, and given Unity won’t set all the entity references to have an invalid ID when it is destroyed, the null check is still successful. This way, even if the target entity is destroyed, the entity referenced in our <code class="inlineCode">Target</code> component still has a valid ID. Also, observe how we removed the line where we used the lookup, given the <code class="inlineCode">TryGetMethod</code> already gives<a id="_idIndexMarker1518"/> us the target’s <code class="inlineCode">LocalToWorld</code> component in the <code class="inlineCode">out</code> parameter, so there’s no need<a id="_idIndexMarker1519"/> to get the component twice.</p>
    <div><p class="normal">You can go the extra mile and set the target to <code class="inlineCode">Entity.Null</code> if the <code class="inlineCode">TryGetComponent</code> method fails. Given using lookups is performance-heavy, early-quitting the method before we use it would be better.</p>
    </div>
    <p class="normal">Now, let’s instantiate more missiles to make the game more interesting.</p>
    <h2 id="_idParaDest-295" class="heading-2">Instantiating missiles with entity Prefabs</h2>
    <p class="normal">We can approach the missile spawner<a id="_idIndexMarker1520"/> by creating <code class="inlineCode">spawner</code> entities – entities<a id="_idIndexMarker1521"/> with a <code class="inlineCode">Spawner</code> component that references the Prefab to instantiate and has the amount to instantiate and the frequency of instantiation. You might think, shouldn’t we create separate components for each piece of spawner data? We can do that, but there’s a performance overhead for each component used in a job and entity queries. We don’t have any reason to think that, in this example, any of our spawner data will be used in a different way, so this time we will use a single component. Try to mix data into a single component whenever you know all of it will be accessed at the same time.</p>
    <p class="normal">The <code class="inlineCode">Spawner</code> component will look like the following image:</p>
    <figure class="mediaobject"><img src="img/B21361_21_41.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.41: The Spawner component and baker</p>
    <p class="normal">Notice that our <code class="inlineCode">Spawner</code> runtime component has a <code class="inlineCode">Prefab</code> entity field. Before, we used such a field to reference the missile’s target, but now we are using it to reference the Prefab to instantiate. We will create the missile Prefab and reference<a id="_idIndexMarker1522"/> it in the spawner authoring component using a <code class="inlineCode">GameObject</code> field. The Prefab reference<a id="_idIndexMarker1523"/> can be converted using the <code class="inlineCode">GetEntity</code> method again. We also have a target reference, given we want the spawned missiles to follow the player. The spawner needs to provide the target reference to the missiles. Remember to create the <code class="inlineCode">spawner</code> GameObject with the <code class="inlineCode">spawner</code> components in the subscene and configure it, dragging the <code class="inlineCode">player</code> to the <code class="inlineCode">target</code> property and the missile <code class="inlineCode">Prefab</code> to the <code class="inlineCode">Prefab</code> property.</p>
    <div><p class="normal">The Prefabs referenced by an ECS component will also be converted as an entity in our subscene, but they will have the special Prefab tag component. This allows the Prefab entity to exist in the subscene but will make ECS ignore it to prevent rendering or updating it. For more information<a id="_idIndexMarker1524"/> about Prefab baking, check this: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/baking-prefabs.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/baking-prefabs.html</a></p>
    </div>
    <p class="normal">Now, we need a system and a job to iterate all spawner entities, using an ECB to instantiate missiles:</p>
    <figure class="mediaobject"><img src="img/B21361_21_42.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.42: The missile spawner job</p>
    <p class="normal">While we can instantiate<a id="_idIndexMarker1525"/> our Prefabs one by one, it is better to instantiate<a id="_idIndexMarker1526"/> several in one shot, so we instead created an array of entities and provided it to the Instantiate method. This Instantiate method overload creates as many instances as elements in the provided array, filling it with references to the soon-to-be-created instances (we are using ECBs). Then, we iterate that array and set the position of the missiles in a way that they spawn one separated from the others by 5 units. We also make them target the player by setting their target component. It might be confusing to change the value of a component by replacing it with a new component instance, but it’s a common practice in ECS. It is also very cheap, as components are structs.</p>
    <p class="normal">Finally, we need the system to schedule the job:</p>
    <figure class="mediaobject"><img src="img/B21361_21_43.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.43: The spawner system</p>
    <p class="normal">In the <code class="inlineCode">OnUpdate</code> method, the only new thing is the usage of <code class="inlineCode">Time.ElapsedTime</code> to get the current game time. But then you can see the addition of an <code class="inlineCode">OnCreate</code> method, the equivalent of <code class="inlineCode">Awake</code> for a system. Here, we use the <code class="inlineCode">RequireForUpdate</code> method to specify that we need the existence of at least one entity with the <code class="inlineCode">Player</code> component for this system to execute. This way, we prevent<a id="_idIndexMarker1527"/> the system from instantiating<a id="_idIndexMarker1528"/> missiles when the <code class="inlineCode">Player</code> is destroyed.</p>
    <p class="normal">Now that we have our spawner system, let’s make the camera follow our character.</p>
    <h2 id="_idParaDest-296" class="heading-2">Making the camera follow our character</h2>
    <p class="normal">Our camera is still a regular GameObject, but<a id="_idIndexMarker1529"/> our player is an entity. Systems<a id="_idIndexMarker1530"/> can access GameObjects in their <code class="inlineCode">OnUpdate</code> method, provided that the method has not been compiled with the Burst compiler. The system to make the camera follow our character will look like this:</p>
    <figure class="mediaobject"><img src="img/B21361_21_44.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 21.44: The system for the camera to follow the player</p>
    <p class="normal">As stated before, <code class="inlineCode">OnUpdate</code> is not burst (it doesn’t have the <em class="chapterRef">BurstCompile</em> attribute) and won’t use jobs, given it needs to access the main camera and its transform, which are non-HPC#-compatible reference types. Then, we used the <code class="inlineCode">TryGetSingletonEntity</code> API to retrieve the reference to the only entity we expect to have the <code class="inlineCode">Player</code> tag. Given missiles can destroy the player, we also use this API to check if the player entity still exists. Then, we use the <code class="inlineCode">GetComponent</code> method to get the position of the existing player entity. While we could have used component lookups as we did before, given we are writing code directly in the system, we can use this method as a short way to do the same.</p>
    <p class="normal">You have created your first DOTS<a id="_idIndexMarker1531"/> game! Remember, you can get access to the full project<a id="_idIndexMarker1532"/> made in this chapter in the book’s Git repository. Finally, as always, there is way more to learn about DOTS, so let’s do a brief exploration of some of the most important remaining APIs.</p>
    <h2 id="_idParaDest-297" class="heading-2">Exploring other DOTS features</h2>
    <p class="normal">Several topics in this book deserve<a id="_idIndexMarker1533"/> their own books, and ECS is no exception. Picking the most essential APIs to explain in this chapter and keeping the chapter as short as possible was quite difficult, as there is so much to explore. Because of that, aside from all the useful additional info we left in the info boxes, here I leave you a list of other DOTS concepts worth checking:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">SystemAPI.Query</strong>: A way to iterate entities<a id="_idIndexMarker1534"/> in a system without jobs. Useful for entity-iterating code that uses managed references or static variables. Also, for simple things that are fast<a id="_idIndexMarker1535"/> to execute, avoiding job scheduling costs. Link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-systemapi-query.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-systemapi-query.html</a></li>
      <li class="bulletList"><strong class="keyWord">Entity Queries</strong>: As explained before, the way jobs and other ECS APIs (like <code class="inlineCode">SystemAPI.Query</code>) iterate<a id="_idIndexMarker1536"/> entities. Link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entityquery-intro.html ">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-entityquery-intro.html</a></li>
      <li class="bulletList"><strong class="keyWord">Enableable Components</strong>: Components that can be disabled. Entity queries will ignore entities that have their required components disabled. Useful for toggling on and off entity behaviors without adding/removing tag components, which is expensive because they need structural <a id="_idIndexMarker1537"/>changes. Link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-enableable.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-enableable.html</a></li>
      <li class="bulletList"><strong class="keyWord">Cleanup Components</strong>: The ECS equivalent to the <code class="inlineCode">OnDestroy</code><code class="inlineCode"><a id="_idIndexMarker1538"/></code> event. Link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-cleanup.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-cleanup.html</a></li>
      <li class="bulletList"><strong class="keyWord">Dynamic Buffers</strong>: The ECS way to have array-like data in<a id="_idIndexMarker1539"/> components. Link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-buffer.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-buffer.html</a></li>
      <li class="bulletList"><strong class="keyWord">Blob Assets</strong>: The ECS equivalent of<a id="_idIndexMarker1540"/> scriptable objects. Link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/blob-assets-intro.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/blob-assets-intro.html</a></li>
      <li class="bulletList"><strong class="keyWord">Content Management</strong>: The ECS version<a id="_idIndexMarker1541"/> of Addressables. Link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/content-management-intro.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/content-management-intro.html</a></li>
      <li class="bulletList">Scene Loading: The ECS way<a id="_idIndexMarker1542"/> of loading subscenes. Link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/conversion-scene-overview.html">https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/conversion-scene-overview.html</a></li>
      <li class="bulletList">Physics and Collisions: The ECS version of the physics<a id="_idIndexMarker1543"/> system. Link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.physics@1.0/manual/index.html">https://docs.unity3d.com/Packages/com.unity.physics@1.0/manual/index.html</a></li>
      <li class="bulletList">Netcode for Entities: The ECS version of the networking<a id="_idIndexMarker1544"/> system. Link: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.netcode@1.0/manual/index.html">https://docs.unity3d.com/Packages/com.unity.netcode@1.0/manual/index.html</a></li>
      <li class="bulletList">DOTS Best Practices: An extensive guide about DOTS best practices<a id="_idIndexMarker1545"/> to maximize your game’s performance and understand DOTS internals: <a href="https://learn.unity.com/course/dots-best-practices">https://learn.unity.com/course/dots-best-practices</a></li>
      <li class="bulletList">ECS Samples: A Git repository containing<a id="_idIndexMarker1546"/> several ECS samples and tutorials: <a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples">https://github.com/Unity-Technologies/EntityComponentSystemSamples</a></li>
    </ul>
    <p class="normal">Most of the links provided point to the ECS documentation. It’s recommended to read it entirely to know about all the tools you have for creating ECS applications.</p>
    <p class="normal">In this section, we have used<a id="_idIndexMarker1547"/> input and tag components to move our player and component lookups to get info about other entities, and looked at diverse usages of entity command buffers to instantiate and destroy entities, and how to make our GameObject camera follow our ECS character. We also discussed different extra topics to deepen your DOTS knowledge.</p>
    <h1 id="_idParaDest-298" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we learned how to start using DOTS by creating our own components and systems to add gameplay to a simple game. We saw how to use input, and the DOTS transform API to move and rotate objects, and we also saw how to spawn and destroy objects.</p>
    <p class="normal">DOTS is a new engine on its own, running inside Unity. The way it works is vastly different, and except for a few systems like the rendering pipelines, almost all DOTS features work very differently from their GameObject counterparts. Also, DOTS is still quite new, meaning it still has missing features and could be subjected to substantial changes in the next versions. </p>
    <p class="normal">This makes it a possible risk for creating new projects, but on the other hand, the performance it can achieve could be decisive for big and ambitious projects. It is an interesting piece of technology that can revolutionize game development, and every day, it is getting more powerful and stable. It’s a good time to start learning about it and be prepared for the future.</p>
    <h1 id="_idParaDest-299" class="heading-1">Learn more on Discord</h1>
    <p class="normal">Read this book alongside other users, Unity game development experts, and the author himself. Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. Scan the QR code or visit the link to join the community:</p>
    <p class="normal"><a href="https://packt.link/unitydev">https://packt.link/unitydev</a></p>
    <p class="normal"><img src="img/QR_Code1498477041053909218.png" alt="" role="presentation"/></p>
  </div>
</body></html>