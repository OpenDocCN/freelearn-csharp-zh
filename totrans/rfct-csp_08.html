<html><head></head><body>
<div id="_idContainer112">
<h1 class="chapter-number" id="_idParaDest-174"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-175"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.2.1">Avoiding Code Anti-Patterns with SOLID</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The right design principles can keep your code from quickly going stale. </span><span class="koboSpan" id="kobo.3.2">While there are many right ways of writing code, there are anti-patterns and code smells that constitute the wrong way of </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">writing code.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Additionally, the community has identified several principles to keep in mind when building software that can help your code resist accumulating technical debt for as long as possible. </span><span class="koboSpan" id="kobo.5.2">In this chapter, we’ll cover a number of these principles, including the famous SOLID acronym, and see how they can help you build software that actively resists the gradual decline toward </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">legacy code.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we’ll cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Identifying anti-patterns in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">C# code</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Writing </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">SOLID code</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Considering other </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">architectural principles</span></span></li>
</ul>
<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.15.1">Identifying anti-patterns in C# code</span></h1>
<p><span class="koboSpan" id="kobo.16.1">I’ve often </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.17.1">found myself telling new programmers that to build good software, you have to first build a lot of really bad software and learn </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">from it.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">While</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.20.1"> this statement is somewhat in jest, there is some truth to it: almost every developer can recognize code that’s written the wrong way and discover things that make it difficult to work with, and doing so helps you write better code the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">next time.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">When your code is bad, there’s usually a part of you that knows it. </span><span class="koboSpan" id="kobo.22.2">You see little things that you don’t love: duplicated pieces of code, inconsistencies in naming or parameter ordering, passing too many parameters around, methods, or even classes that are just too big to </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">manage effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">These symptoms are what we commonly refer to as </span><strong class="bold"><span class="koboSpan" id="kobo.25.1">code smells</span></strong><span class="koboSpan" id="kobo.26.1">, and we’ll revisit them later in </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">Beyond code</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.29.1"> smells are something called </span><strong class="bold"><span class="koboSpan" id="kobo.30.1">anti-patterns</span></strong><span class="koboSpan" id="kobo.31.1">, which</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.32.1"> is code that significantly deviates from community recommendations. </span><span class="koboSpan" id="kobo.32.2">Unfortunately, not all anti-patterns are easy to notice or discover on your own, and some even seem like good ideas to individuals or teams until they’re </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">fully explored.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">A </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.35.1">few common C# anti-patterns I see include throwing and catching an </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">Exception</span></strong><span class="koboSpan" id="kobo.37.1"> error instead of a specific type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">Exception</span></strong><span class="koboSpan" id="kobo.39.1"> error, not </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.40.1">disposing of resources that implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">IDisposable</span></strong><span class="koboSpan" id="kobo.42.1">, and inefficient </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">Language-Integrated Query</span></strong><span class="koboSpan" id="kobo.44.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.45.1">LINQ</span></strong><span class="koboSpan" id="kobo.46.1">) statements. </span><span class="koboSpan" id="kobo.46.2">See the </span><em class="italic"><span class="koboSpan" id="kobo.47.1">Further reading</span></em><span class="koboSpan" id="kobo.48.1"> section of this chapter for more details on </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">these anti-patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">There are far too many anti-patterns to cover in this book, and the established practices of .NET development evolve over time. </span><span class="koboSpan" id="kobo.50.2">Because of this constant change, Visual Studio offers code analysis tools to help spot and fix violations of community standards. </span><span class="koboSpan" id="kobo.50.3">These tools include code analysis rulesets and </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.51.1">built-in </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">Roslyn Analyzers</span></strong><span class="koboSpan" id="kobo.53.1">, which we’ll cover at more length in </span><a href="B21324_12.xhtml#_idTextAnchor259"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.54.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.55.1">, </span><em class="italic"><span class="koboSpan" id="kobo.56.1">Code Analysis in </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.57.1">Visual Studio</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Not all issues in code are specific to C# code. </span><span class="koboSpan" id="kobo.59.2">Many issues in code stem from how classes interact, pass data around to one another, manage variables, and are generally structured. </span><span class="koboSpan" id="kobo.59.3">These issues emerge even in code that you intended to be “well structured” as you start to see your systems scale up in size as new capabilities </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">are added.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">Thankfully, even new developers have an innate ability to spot code that is difficult to follow, requires more work to maintain and expand than it should, or involves excessive duplication. </span><span class="koboSpan" id="kobo.61.2">These types of issues in code are commonly referred to as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.62.1">code smells</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.64.1">What are code smells?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.65.1">Code smells </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.66.1">are prime indicators that your current architecture has some drawbacks and refactoring might be in order. </span><span class="koboSpan" id="kobo.66.2">Pay attention to these symptoms when you encounter them in systems, including the code you write yourself. </span><span class="koboSpan" id="kobo.66.3">Learning what makes code difficult to work with will help you write better code and refactor existing code into </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">better forms.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">For now, let’s move on to talk about writing </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">SOLID code</span></strong><span class="koboSpan" id="kobo.70.1">, which can help you avoid some common code smells and build robust, maintainable, and </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">testable code.</span></span></p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.72.1">Writing SOLID code</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.73.1">SOLID</span></strong><span class="koboSpan" id="kobo.74.1"> is an </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.75.1">acronym introduced by Michael Feathers summarizing the words of Robert C. </span><span class="koboSpan" id="kobo.75.2">Martin. </span><span class="koboSpan" id="kobo.75.3">The intent of SOLID is to provide developers with a set of principles that will guide them toward more maintainable code that resists becoming </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">technical debt.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">The </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.78.1">five principles of SOLID </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">code are:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.80.1">Single Responsibility </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.81.1">Principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.82.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.83.1">SRP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.85.1">Open-Closed </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.86.1">Principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.87.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.88.1">OCP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.90.1">Liskov Substitution </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.91.1">Principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.92.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.93.1">LSP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.95.1">Interface Segregation </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.96.1">Principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.97.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.98.1">ISP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.100.1">Dependency Inversion </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.101.1">Principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.102.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.103.1">DIP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.105.1">In this section, we’ll cover all five of </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">these principles.</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.107.1">Single Responsibility Principle</span></h2>
<p><span class="koboSpan" id="kobo.108.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.110.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.111.1">SRP)</span></strong><span class="koboSpan" id="kobo.112.1"> says</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.113.1"> that a class </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.114.1">should be responsible for one thing and one thing only. </span><span class="koboSpan" id="kobo.114.2">Here are a few examples of classes that </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.115.1">follow </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">the SRP:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.117.1">A class responsible for saving application data to a specific </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">file format</span></span></li>
<li><span class="koboSpan" id="kobo.119.1">A database access class dedicated to executing queries against a database table or set </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">of tables</span></span></li>
<li><span class="koboSpan" id="kobo.121.1">An API controller providing REST methods to interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">flight data</span></span></li>
<li><span class="koboSpan" id="kobo.123.1">A class representing the user interface in a specific part of </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">your application</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.125.1">Classes violate the SRP by trying to do more than one type of thing in the same class. </span><span class="koboSpan" id="kobo.125.2">More formally, if there’s ever more than one reason to modify a class, the class violates </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">the SRP.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">For </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.128.1">example, if a class is responsible for tracking a set of items in a user interface, responding to button presses, parsing user input, and asynchronously fetching data, that class very likely violates </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">the SRP.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Classes that</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.131.1"> violate the SRP tend to be frequently modified, grow in complexity over time, and be very large classes compared to other classes in the system. </span><span class="koboSpan" id="kobo.131.2">These classes can be hard to fully understand or adequately test and can become brittle and buggy as they grow </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">in complexity.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">One of the things that I do to help detect violations of the SRP is to have a class-level comment talking about what the class is responsible for. </span><span class="koboSpan" id="kobo.133.2">For example, the following XML comment describes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.135.1"> class from </span><em class="italic"><span class="koboSpan" id="kobo.136.1">Part 1</span></em><span class="koboSpan" id="kobo.137.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">this book:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.139.1">/// &lt;summary&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.140.1">/// This class is responsible for tracking information</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.141.1">/// about current and pending flights</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.142.1">/// &lt;/summary&gt;</span></strong><span class="koboSpan" id="kobo.143.1">
public class FlightScheduler {
  // Details omitted
}</span></pre>
<p><span class="koboSpan" id="kobo.144.1">Here, the responsibility of </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.146.1"> is clear: it exists to track active and pending flights within the system. </span><span class="koboSpan" id="kobo.146.2">Reasons for modifying this class should be related to the tracking of these flights and not related to </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">other topics.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">For this reason, I tend to put class-level comments in all classes whenever I define a new class to help that class stay focused on its mission over the course of </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">its life.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">But what if you have a class that already exists and violates </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">the SRP?</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">When you have a class that’s responsible for multiple things, I like to look at everything the class is currently responsible for and group them into related groups of members. </span><span class="koboSpan" id="kobo.152.2">For example, if a class has 10 fields, 25 methods, and 6 properties, I might go through them and try to find common topics that those </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">things address.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">For example, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.156.1"> class violated the SRP, it might have members for </span><a id="_idIndexMarker472"/><span class="No-Break"><span class="koboSpan" id="kobo.157.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.158.1">Scheduling and </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">canceling flights</span></span></li>
<li><span class="koboSpan" id="kobo.160.1">Assigning crew </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">to flights</span></span></li>
<li><span class="koboSpan" id="kobo.162.1">Booking flights </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">for passengers</span></span></li>
<li><span class="koboSpan" id="kobo.164.1">Changing seat assignments </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">for passengers</span></span></li>
<li><span class="koboSpan" id="kobo.166.1">Moving passengers to </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">different flights</span></span></li>
<li><span class="koboSpan" id="kobo.168.1">Generating flight-scheduling documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">for management</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.170.1">This </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.171.1">class, clearly, is responsible for more than one type of thing. </span><span class="koboSpan" id="kobo.171.2">In a production system, this class might be 2,000 lines long or more and be difficult to fully understand and adequately test. </span><span class="koboSpan" id="kobo.171.3">Additionally, changes to one area of the class might impact other areas in </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">unexpected ways.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">By looking at the groups of things a class addresses, you can usually identify a few key groups. </span><span class="koboSpan" id="kobo.173.2">I like to do this and then focus on the largest group of related responsibilities that are not clearly related to the core goal of the class. </span><span class="koboSpan" id="kobo.173.3">Once you identify these groupings, you can extract a new class to manage these aspects. </span><span class="koboSpan" id="kobo.173.4">Your original class can reference this class or store it as a field if needed, or the new class could operate completely independently of the </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">old class.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">FlightScheduler</span></strong><span class="koboSpan" id="kobo.177.1">, I would say that scheduling and canceling flights is the core part of the class, and other aspects currently in the class might belong more elsewhere. </span><span class="koboSpan" id="kobo.177.2">Looking at those other areas, there are several things related to managing flight reservations for passengers, so in this case, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">FlightBookingManager</span></strong><span class="koboSpan" id="kobo.179.1"> class might be introduced to contain these related pieces </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">of logic.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">By iteratively introducing new classes from functionality not related to the core responsibility of a class, you can shrink large classes down to manageable sizes and resist the complexity, quality, and testability issues found in classes that ignore </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">the SRP.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">The SRP doesn’t apply just to classes but can apply to methods as well. </span><span class="koboSpan" id="kobo.183.2">A method should have a single core task it is responsible for, and that purpose should be communicated by the name of the method. </span><span class="koboSpan" id="kobo.183.3">When a method is responsible for multiple things or starts getting too large, it’s a good sign that you might need to extract a method and pull some logic out of the original method to keep the size of the </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">method maintainable.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">Personally, if there</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.186.1"> were one programming principle I could impart to my younger self –or most early/intermediate developers out there, it would be the importance of the SRP in keeping your code easy to understand, test, expand, </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">and maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">My personal guideline</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.189.1"> is to strive for classes under 200 lines of code long and methods under 20 lines of code long, but both can be challenging, and there are certainly exceptions to be made to these guidelines depending on the nature of the code you’re maintaining – remember that these are principles and guidelines, not firm rules </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">or commandments.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.191.1">If you only remember one part of SOLID, remember the SRP; it’s that important to the health of your application.</span></em><span class="koboSpan" id="kobo.192.1"> However, there are four more principles </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">to explore.</span></span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.194.1">Open-Closed Principle</span></h2>
<p><span class="koboSpan" id="kobo.195.1">Classes </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.196.1">are said</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.197.1"> to follow the </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">Open-Closed Principle (OCP)</span></strong><span class="koboSpan" id="kobo.199.1"> when they are </span><em class="italic"><span class="koboSpan" id="kobo.200.1">open to extension</span></em><span class="koboSpan" id="kobo.201.1"> but </span><em class="italic"><span class="koboSpan" id="kobo.202.1">closed </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.203.1">to modification</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">This principle was originally written for C++ modules, and it doesn’t translate as cleanly to C# as some of the other SOLID principles, but this is essentially a principle about following </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.207.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.208.1">OOP</span></strong><span class="koboSpan" id="kobo.209.1">) principles when designing </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">your classes.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">If you build something to follow the OCP, you are designing a class to have its behavior extended through other classes inheriting it, through customizable properties or parameters, or through composition where you compose your class of other objects that change how </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">it behaves.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">An example of using composition was covered in </span><a href="B21324_05.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.214.1">Chapter 5</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.215.1">: Object-oriented Refactoring</span></em><span class="koboSpan" id="kobo.216.1"> and involved providing different cargo items for </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">a flight.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">The rest of this section will focus on using inheritance to fulfill </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">the OCP.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">In C#, methods do not allow overriding by default. </span><span class="koboSpan" id="kobo.220.2">This means you’ll need to explicitly opt-in to allow others to override your methods by declaring them </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">virtual</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.224.1">Counterpoint</span></p>
<p class="callout"><span class="koboSpan" id="kobo.225.1">I’ve heard some developers argue that declaring methods as </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">virtual</span></strong><span class="koboSpan" id="kobo.227.1"> without any classes overriding them is confusing, adds unnecessary keywords to your code, and even slightly harms the performance of your code at runtime. </span><span class="koboSpan" id="kobo.227.2">All these things can be true, but if you are in a scenario where you cannot predict how others will use your code and you know they won’t be able to modify your source code, marking key methods as </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">virtual</span></strong><span class="koboSpan" id="kobo.229.1"> is usually a good idea. </span><span class="koboSpan" id="kobo.229.2">In these scenarios, </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">virtual</span></strong><span class="koboSpan" id="kobo.231.1"> adds </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">extra flexibility.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.233.1">Remember that SOLID principles </span><em class="italic"><span class="koboSpan" id="kobo.234.1">are guidelines to keep in mind</span></em><span class="koboSpan" id="kobo.235.1"> while building software, not firm rules you need to </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">always follow.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">As a </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.238.1">specific example of the OCP, let’s look at a sample </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">ItineraryManager</span></strong><span class="koboSpan" id="kobo.240.1"> class representing information about a passenger’s flight </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.241.1">itinerary as they travel via Cloudy </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">Skies Airlines:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.243.1">
public class ItineraryManager {
  public int MilesAccumulated {get; private set;}
  public FlightInfo? </span><span class="koboSpan" id="kobo.243.2">Flight {get; private set;}
  public virtual void FlightCompleted(FlightInfo? </span><span class="koboSpan" id="kobo.243.3">next) {
    if (Flight != null) {
      AccumulateMiles(Flight.Miles);
    }
    Flight = next;
  }
  public virtual void ChangeFlight(FlightInfo newFlight,
    bool isInvoluntary) =&gt;
    Flight = newFlight;
  public void AccumulateMiles(int miles) =&gt;
    MilesAccumulated += miles;
}</span></pre>
<p><span class="koboSpan" id="kobo.244.1">Here, we have a class that tracks the total miles a passenger has accrued, as well as the next flight the passenger is scheduled to fly (which may be </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">null</span></strong><span class="koboSpan" id="kobo.246.1"> when their trip is completed). </span><span class="koboSpan" id="kobo.246.2">The class has two </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">virtual</span></strong><span class="koboSpan" id="kobo.248.1"> methods related to handling completed flights as well as canceled flights. </span><span class="koboSpan" id="kobo.248.2">Additionally, the class has a non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">virtual</span></strong><span class="koboSpan" id="kobo.250.1"> method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">AccumulateMiles</span></strong><span class="koboSpan" id="kobo.252.1"> that updates the miles the passenger has accumulated on </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">this trip.</span></span></p>
<p><span class="koboSpan" id="kobo.254.1">While this</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.255.1"> class meets the needs of the airline, let’s </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.256.1">say that the airline wants to introduce a new logic for reward customers that gives them 100 extra miles for every flight they complete and rewards the scheduled mileage for a flight when the passenger is involuntarily moved to a </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">new flight.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">Under the OCP, we should be able to do this without having to modify our base class, assuming that the class is open to modification. </span><span class="koboSpan" id="kobo.258.2">It turns out we can do this with the following </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">RewardsItineraryManager</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.261.1">
public class RewardsItineraryManager : ItineraryManager {
  private const int BonusMilesPerFlight = 100;
  public </span><strong class="bold"><span class="koboSpan" id="kobo.262.1">override</span></strong><span class="koboSpan" id="kobo.263.1"> void FlightCompleted(FlightInfo? </span><span class="koboSpan" id="kobo.263.2">next) {
    </span><strong class="bold"><span class="koboSpan" id="kobo.264.1">base</span></strong><span class="koboSpan" id="kobo.265.1">.FlightCompleted(next);
    AccumulateMiles(BonusMilesPerFlight);
  }
  public </span><strong class="bold"><span class="koboSpan" id="kobo.266.1">override</span></strong><span class="koboSpan" id="kobo.267.1"> void ChangeFlight(FlightInfo newFlight,       bool isInvoluntary) {
    if (isInvoluntary &amp;&amp; Flight != null) {
       AccumulateMiles(Flight.Miles);
    }
    </span><strong class="bold"><span class="koboSpan" id="kobo.268.1">base</span></strong><span class="koboSpan" id="kobo.269.1">.ChangeFlight(newFlight, isInvoluntary);
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.270.1">Without modifying our base class, we can extend the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">ItineraryManager</span></strong><span class="koboSpan" id="kobo.272.1"> with our new class that follows a slightly different logic. </span><span class="koboSpan" id="kobo.272.2">Thanks to the magic of polymorphism, we can use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">RewardsItineraryManager</span></strong><span class="koboSpan" id="kobo.274.1"> class anywhere an </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">ItineraryManager</span></strong><span class="koboSpan" id="kobo.276.1"> class is accepted, further supporting the closed-to-modification aspect of </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">the OCP.</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.278.1">Liskov Substitution Principle</span></h2>
<p><span class="koboSpan" id="kobo.279.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">Liskov Substitution Principle </span></strong><span class="koboSpan" id="kobo.281.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.282.1">LSP</span></strong><span class="koboSpan" id="kobo.283.1">) says </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.284.1">that polymorphic code should not need to </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.285.1">be aware of what specific types of objects it is </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">working with.</span></span></p>
<p><span class="koboSpan" id="kobo.287.1">That’s still a somewhat vague description, so let’s take another look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">FlightCompleted</span></strong><span class="koboSpan" id="kobo.289.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">from earlier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
public virtual void FlightCompleted(</span><strong class="bold"><span class="koboSpan" id="kobo.292.1">FlightInfo? </span><span class="koboSpan" id="kobo.292.2">next</span></strong><span class="koboSpan" id="kobo.293.1">) {
  if (Flight != null) {
    AccumulateMiles(</span><strong class="bold"><span class="koboSpan" id="kobo.294.1">Flight.Miles</span></strong><span class="koboSpan" id="kobo.295.1">);
  }
  Flight = next;
}</span></pre>
<p><span class="koboSpan" id="kobo.296.1">This method takes in a flight that it stores in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">Flight</span></strong><span class="koboSpan" id="kobo.298.1"> property. </span><span class="koboSpan" id="kobo.298.2">If a prior flight was stored in that </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">Flight</span></strong><span class="koboSpan" id="kobo.300.1"> property, the code will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">AccumulateMiles</span></strong><span class="koboSpan" id="kobo.302.1"> method with that flight’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Miles</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.304.1"> property.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">The application has several classes that inherit from </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.307.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">PassengerFlightInfo</span></strong><span class="koboSpan" id="kobo.309.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">CargoFlightInfo</span></strong><span class="koboSpan" id="kobo.311.1">. </span><span class="koboSpan" id="kobo.311.2">That means our </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">next</span></strong><span class="koboSpan" id="kobo.313.1"> parameter may be any one of these three classes – or some other class that inherits </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">from them.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">The LSP says that </span><em class="italic"><span class="koboSpan" id="kobo.316.1">any</span></em><span class="koboSpan" id="kobo.317.1"> valid instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.319.1"> should not error when you call its </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">Miles</span></strong><span class="koboSpan" id="kobo.321.1"> property (or any other method). </span><span class="koboSpan" id="kobo.321.2">For example, this version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">CargoFlightInfo</span></strong><span class="koboSpan" id="kobo.323.1"> would be a violation of the LSP because its </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">Miles</span></strong><span class="koboSpan" id="kobo.325.1"> property errors </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">when called:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.327.1">
public class CargoFlightInfo : FlightInfo {
  public decimal TonsOfCargo { get; set; }
</span><strong class="bold"><span class="koboSpan" id="kobo.328.1">  public override int RewardMiles =&gt;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.329.1">    throw new NotSupportedException();</span></strong><span class="koboSpan" id="kobo.330.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.331.1">Essentially, when</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.332.1"> following the LSP, the method should not have any reason to need to know</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.333.1"> which subclass of </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.335.1"> it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">dealing with.</span></span></p>
<p><span class="koboSpan" id="kobo.337.1">Because the LSP is focused on polymorphism, it applies to both class inheritance and interface implementations in .</span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">NET code.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">Speaking of interfaces, let’s move on to </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">the ISP.</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.341.1">Interface Segregation Principle</span></h2>
<p><span class="koboSpan" id="kobo.342.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">Interface Segregation Principle</span></strong><span class="koboSpan" id="kobo.344.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.345.1">ISP</span></strong><span class="koboSpan" id="kobo.346.1">) is a</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.347.1"> fancy way of saying that you should prefer </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.348.1">many smaller specialized interfaces focused on related capabilities over one large interface that encompasses everything your </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">class does.</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">For example, imagine </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.351.1">we had a </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">FlightRepository</span></strong><span class="koboSpan" id="kobo.353.1"> class that managed database access to individual flights. </span><span class="koboSpan" id="kobo.353.2">In many systems, this class might implement an </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">IFlightRepository</span></strong><span class="koboSpan" id="kobo.355.1"> interface that could be defined as follows with all public members of the class as part of </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">the interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
public interface IFlightRepository {
  FlightInfo AddFlight(FlightInfo flight);
  FlightInfo UpdateFlight(FlightInfo flight);
  void CancelFlight(FlightInfo flight);
  FlightInfo? </span><span class="koboSpan" id="kobo.357.2">FindFlight(string id);
  IEnumerable&lt;FlightInfo&gt; GetActiveFlights();
  IEnumerable&lt;FlightInfo&gt; GetPendingFlights();
  IEnumerable&lt;FlightInfo&gt; GetCompletedFlights();
}</span></pre>
<p><span class="koboSpan" id="kobo.358.1">As you can see, this manages common operations related to flights and provides some means of finding information about many flights. </span><span class="koboSpan" id="kobo.358.2">In a more real-world example, there would likely be many additional methods that would need to be added over the years to support </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">new features.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">In my </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.361.1">experience with .NET code, it is very </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.362.1">common to have a large interface per major class that includes all public methods in this class. </span><span class="koboSpan" id="kobo.362.2">This interface is usually named after the class it was based on and exists mostly to support testability through </span><strong class="bold"><span class="koboSpan" id="kobo.363.1">dependency injection</span></strong><span class="koboSpan" id="kobo.364.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.365.1">DI</span></strong><span class="koboSpan" id="kobo.366.1">), as</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.367.1"> we’ll touch on in the </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">next chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">However, this approach is usually a violation of the ISP. </span><span class="koboSpan" id="kobo.369.2">Because our interfaces are designed around classes instead of discrete sets of capabilities, it becomes harder to introduce a new class that meets some of those capabilities but </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">not all.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">For example, let’s say that Cloudy Skies Airlines wants to integrate with another subsidiary airline’s systems. </span><span class="koboSpan" id="kobo.371.2">It doesn’t need to add, update, or delete flights, but it does want a way of searching for flights. </span><span class="koboSpan" id="kobo.371.3">Under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">IFlightRepository</span></strong><span class="koboSpan" id="kobo.373.1"> interface, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">AddFlight</span></strong><span class="koboSpan" id="kobo.375.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">UpdateFlight</span></strong><span class="koboSpan" id="kobo.377.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">CancelFlight</span></strong><span class="koboSpan" id="kobo.379.1"> methods would either need to do nothing or throw a </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">NotSupportedException</span></strong><span class="koboSpan" id="kobo.381.1"> error when called. </span><span class="koboSpan" id="kobo.381.2">By the way, throwing the exception on a not-supported method call as part of a larger interface would be a violation of the LSP </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">mentioned earlier.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">Instead of having one large interface per major type, the ISP advocates for small interfaces for tightly related capabilities. </span><span class="koboSpan" id="kobo.383.2">In the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">FlightRepository</span></strong><span class="koboSpan" id="kobo.385.1">, it’s essentially doing </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">two things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.387.1">Adding, editing, and </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">deleting flights</span></span></li>
<li><span class="koboSpan" id="kobo.389.1">Searching for </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">existing flights</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.391.1">If we wanted to introduce interfaces, we could introduce interfaces for these separate sets of related capabilities, as </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.393.1">
public interface </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">IFlightUpdater</span></strong><span class="koboSpan" id="kobo.395.1"> {
  FlightInfo AddFlight(FlightInfo flight);
  FlightInfo UpdateFlight(FlightInfo flight);
  void CancelFlight(FlightInfo flight);
}
public interface </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">IFlightProvider</span></strong><span class="koboSpan" id="kobo.397.1"> {
  FlightInfo? </span><span class="koboSpan" id="kobo.397.2">FindFlight(string id);
  IEnumerable&lt;FlightInfo&gt; GetActiveFlights();
  IEnumerable&lt;FlightInfo&gt; GetPendingFlights();
  IEnumerable&lt;FlightInfo&gt; GetCompletedFlights();
}</span></pre>
<p><span class="koboSpan" id="kobo.398.1">In this</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.399.1"> example, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">FlightRepository</span></strong><span class="koboSpan" id="kobo.401.1"> class would implement both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">IFlightUpdater</span></strong><span class="koboSpan" id="kobo.403.1"> interface and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">IFlightProvider</span></strong><span class="koboSpan" id="kobo.405.1"> interface. </span><span class="koboSpan" id="kobo.405.2">If we wanted to integrate with another airline’s systems but didn’t have the ability to modify their flights, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">IFlightProvider</span></strong><span class="koboSpan" id="kobo.407.1"> interface could</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.408.1"> be implemented without the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">IFlightUpdater</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.410.1"> interface.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">By segmenting our interfaces into small interfaces that denote distinct sets of capabilities, we make it easier to provide alternative implementations of those capabilities as well as test our </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">code later.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">We’ve touched on DI a few times now; let’s explore that topic in more detail by covering the DIP and rounding out our </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">SOLID principles.</span></span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.415.1">Dependency Inversion Principle</span></h2>
<p><span class="koboSpan" id="kobo.416.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.417.1">Dependency Inversion Principle </span></strong><span class="koboSpan" id="kobo.418.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.419.1">DIP</span></strong><span class="koboSpan" id="kobo.420.1">) states that</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.421.1"> your code should generally depend </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.422.1">on abstractions instead of on </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">specific implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">To illustrate</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.425.1"> this, let’s look at a </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">FlightBookingManager</span></strong><span class="koboSpan" id="kobo.427.1"> class that helps passengers book flights. </span><span class="koboSpan" id="kobo.427.2">This class needs to register booking requests and send confirmation messages for the booking. </span><span class="koboSpan" id="kobo.427.3">Here’s its </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">current code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.429.1">
public class FlightBookingManager {
  </span><strong class="bold"><span class="koboSpan" id="kobo.430.1">private readonly SpecificMailClient _email;</span></strong><span class="koboSpan" id="kobo.431.1">
  public FlightBookingManager(</span><strong class="bold"><span class="koboSpan" id="kobo.432.1">string connectionString</span></strong><span class="koboSpan" id="kobo.433.1">) {
    </span><strong class="bold"><span class="koboSpan" id="kobo.434.1">_email = new SpecificMailClient(connectionString);</span></strong><span class="koboSpan" id="kobo.435.1">
  }
  public bool BookFlight(Passenger passenger,
    PassengerFlightInfo flight, string seat) {
    if (!flight.IsSeatAvailable(seat)) {
      return false;
    }
    flight.AssignSeat(passenger, seat);
    string message = "Your seat is confirmed";
    </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">_email.SendMessage(passenger.Email, message);</span></strong><span class="koboSpan" id="kobo.437.1">
    return true;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.438.1">This code </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.439.1">allows passengers to book a flight by checking if a seat is available, then reserving that seat and sending a message using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">_email</span></strong><span class="koboSpan" id="kobo.441.1"> field. </span><span class="koboSpan" id="kobo.441.2">This field is set in the constructor to a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">SpecificMailClient</span></strong><span class="koboSpan" id="kobo.443.1">, which is a made-up class representing some very specific implementation of an email client. </span><span class="koboSpan" id="kobo.443.2">The constructor needs to get a connection string to instantiate </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">this class.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">This code </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.446.1">violates the DIP because our </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">FlightBookingManager</span></strong><span class="koboSpan" id="kobo.448.1"> class is tightly coupled with a specific email client. </span><span class="koboSpan" id="kobo.448.2">If we ever wanted to write unit tests against this class, the class would always try to send messages to that email client, which usually isn’t what you want </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">when testing.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">Additionally, if the organization wanted to change email providers and you needed to switch to a different email client, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">FlightBookingManager</span></strong><span class="koboSpan" id="kobo.452.1"> class would need to change along with anywhere else in the system where we were tightly coupled to use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">SpecificMailClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.454.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">Dependency inversion flips this on its head by having our classes instead depend on abstractions of the specific things they depend on. </span><span class="koboSpan" id="kobo.455.2">This is usually done by depending on a base class such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">EmailClientBase</span></strong><span class="koboSpan" id="kobo.457.1"> that is then inherited or through taking in an interface such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.459.1"> that specific clients </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">can implement.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">We typically </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.462.1">take in these dependencies in the constructor as a constructor parameter. </span><span class="koboSpan" id="kobo.462.2">This version </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.463.1">of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">FlightBookingManager</span></strong><span class="koboSpan" id="kobo.465.1"> class would look </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.467.1">
public class FlightBookingManager {
  </span><strong class="bold"><span class="koboSpan" id="kobo.468.1">private readonly IEmailClient _email;</span></strong><span class="koboSpan" id="kobo.469.1">
  public FlightBookingManager(</span><strong class="bold"><span class="koboSpan" id="kobo.470.1">IEmailClient email</span></strong><span class="koboSpan" id="kobo.471.1">) {
    </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">_email = email;</span></strong><span class="koboSpan" id="kobo.473.1">
  }
  public bool BookFlight(Passenger passenger,
    PassengerFlightInfo flight, string seat) {
    if (!flight.IsSeatAvailable(seat)) {
      return false;
    }
    flight.AssignSeat(passenger, seat);
    string message = "Your seat is confirmed";
    _email.SendMessage(passenger.Email, message);
    return true;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.474.1">Here, instead of taking in a connection string, we now take in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">IEmailClient</span></strong><span class="koboSpan" id="kobo.476.1"> class. </span><span class="koboSpan" id="kobo.476.2">This means our class doesn’t need to know which implementation it is dealing with or how to instantiate an instance of that class, doesn’t need a connection string, doesn’t need to change if the specific email provider ever changes, and can be tested easier by passing in a fake email client instead of a real one (we’ll talk more about this in the next chapter when </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">discussing Moq).</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">This process of </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.479.1">taking in a dependency from something else</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.480.1"> is called </span><strong class="bold"><span class="koboSpan" id="kobo.481.1">Dependency Inversion</span></strong><span class="koboSpan" id="kobo.482.1"> and is often an intimidating topic for new and intermediate developers, but at its core, Dependency Inversion is all about classes getting their dependencies passed into them instead of having to create specific </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">instances themselves.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">Following </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.485.1">the DIP leads to more maintainable, flexible, and </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">testable code.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">This concludes the five principles in SOLID, but we still have a few more design principles to cover before closing out </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">the chapter.</span></span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.489.1">Considering other architectural principles</span></h1>
<p><span class="koboSpan" id="kobo.490.1">Before we close out the chapter, let me share three brief principles that have helped me in my own journey toward </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">good software.</span></span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.492.1">Learning the DRY principle</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.493.1">Don’t Repeat Yourself</span></strong><span class="koboSpan" id="kobo.494.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.495.1">DRY</span></strong><span class="koboSpan" id="kobo.496.1">) is an</span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.497.1"> important tenant in software development. </span><span class="koboSpan" id="kobo.497.2">The DRY principle is</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.498.1"> oriented around making sure you don’t repeat the same patterns in code throughout your application. </span><span class="koboSpan" id="kobo.498.2">Code takes a while to write, read, and maintain, and bugs inevitably do occur at a certain rate per line of code. </span><span class="koboSpan" id="kobo.498.3">As a result, you want to strive to solve problems once in a centralized place and then reuse </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">that solution.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">Let’s look at some</span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.501.1"> sample code that violates the DRY principle. </span><span class="koboSpan" id="kobo.501.2">This code takes in a </span><strong class="bold"><span class="koboSpan" id="kobo.502.1">comma-separated value</span></strong><span class="koboSpan" id="kobo.503.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.504.1">CSV</span></strong><span class="koboSpan" id="kobo.505.1">) string such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">"CSA1234,CMH,ORD"</span></strong><span class="koboSpan" id="kobo.507.1"> and translates it into a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">FlightInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.509.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.510.1">
public FlightInfo ReadFlightFromCsv(string csvLine) {
  string[] parts = csvLine.Split(',');
  const string fallback = "Unknown";
  FlightInfo flight = new();
  if (parts.Length &gt; 0) {
    flight.Id = parts[0]?.Trim() ?? </span><span class="koboSpan" id="kobo.510.2">fallback;
  } else {
    flight.Id = fallback;
  }
  if (parts.Length &gt; 1) {
    flight.DepartureAirport = parts[1]?.Trim() ?? </span><span class="koboSpan" id="kobo.510.3">fallback;
  } else {
    flight.DepartureAirport = fallback;
  }
  if (parts.Length &gt; 2) {
    flight.ArrivalAirport = parts[2]?.Trim() ?? </span><span class="koboSpan" id="kobo.510.4">fallback;
  } else {
    flight.ArrivalAirport = fallback;
  }
  // Other parsing logic omitted
  return flight;
}</span></pre>
<p><span class="koboSpan" id="kobo.511.1">Notice how the </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.512.1">logic for parsing in each part of the CSV string is wrapped in checks against </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">null</span></strong><span class="koboSpan" id="kobo.514.1"> values and the array of parts is empty. </span><span class="koboSpan" id="kobo.514.2">This code</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.515.1"> is very repetitive, and it’s easy to imagine that if a new field got added to the CSV data, the developer making the change would just copy and paste those five lines </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">of code.</span></span></p>
<p><span class="koboSpan" id="kobo.517.1">There are a few problems with repeating code patterns such </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">as this:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.519.1">It encourages copying and pasting, which tends to produce poor code or results in bugs due to things that should have been changed on paste not </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">being changed</span></span></li>
<li><span class="koboSpan" id="kobo.521.1">If the logic for parsing an individual field needs to change (for example, to protect against empty strings), it now needs to be changed in </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">many places</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.523.1">We can fix</span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.524.1"> this</span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.525.1"> by extracting a method containing the logic for </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">parsing fields:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.527.1">private string ReadFromCsv(string[] parts, int index,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.528.1">  string fallback = "Unknown")</span></strong><span class="koboSpan" id="kobo.529.1"> {
  if (parts.Length &gt; index) {
    return parts[index]?.Trim() ?? </span><span class="koboSpan" id="kobo.529.2">fallback;
  } else {
    return fallback;
  }
}
public FlightInfo ReadFlightFromCsv(string csvLine) {
  string[] parts = csvLine.Split(',');
  FlightInfo flight = new();
</span><strong class="bold"><span class="koboSpan" id="kobo.530.1">  flight.Id = ReadFromCsv(parts, 0);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.531.1">  flight.DepartureAirport = ReadFromCsv(parts, 1);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.532.1">  flight.ArrivalAirport = ReadFromCsv(parts, 2);</span></strong><span class="koboSpan" id="kobo.533.1">
  // Other parsing logic omitted
  return flight;
}</span></pre>
<p><span class="koboSpan" id="kobo.534.1">Not only is this new version easier to maintain, but it also results in less code overall and helps focus your attention on parts of the logic that are different from section to section. </span><span class="koboSpan" id="kobo.534.2">This improves the readability of your code while also reducing your likelihood of </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">making mistakes.</span></span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.536.1">KISS principle</span></h2>
<p><span class="koboSpan" id="kobo.537.1">“</span><strong class="bold"><span class="koboSpan" id="kobo.538.1">Keep it simple, stupid</span></strong><span class="koboSpan" id="kobo.539.1">” (abbreviated as </span><strong class="bold"><span class="koboSpan" id="kobo.540.1">KISS</span></strong><span class="koboSpan" id="kobo.541.1"> and sometimes called “</span><strong class="bold"><span class="koboSpan" id="kobo.542.1">Keep it simple, silly</span></strong><span class="koboSpan" id="kobo.543.1">”) is a</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.544.1"> principle focused on the complexity of </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.545.1">software systems. </span><span class="koboSpan" id="kobo.545.2">As software engineers, we sometimes overthink things and make things incredibly complex when they don’t need to be. </span><span class="koboSpan" id="kobo.545.3">KISS encourages you to keep your code and classes as simple as possible and expand the complexity only when </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">truly necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">Typically, the more complexity you have in your systems, the longer it takes you to add new features, diagnose problems, onboard new team members, and resolve customer-facing issues. </span><span class="koboSpan" id="kobo.547.2">With more moving parts to your application, there are also more things that can break, meaning that complexity has a real chance of creating customer-facing issues—all for potential solutions to problems your organization won’t have for a </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">few years.</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">Complexity tends to grow over time and rarely ever decreases (particularly in database schemas). </span><span class="koboSpan" id="kobo.549.2">Keep it simple until you see a pressing and compelling reason to add </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">more complexity.</span></span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.551.1">Understanding high cohesion and low coupling</span></h2>
<p><span class="koboSpan" id="kobo.552.1">Finally, let’s close the chapter out by reviewing two terms you’ll hear occasionally in software engineering: </span><strong class="bold"><span class="koboSpan" id="kobo.553.1">cohesion</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.554.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.555.1">coupling</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">Cohesion </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.558.1">has to do with how related different parts of</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.559.1"> the class are to the same thing. </span><span class="koboSpan" id="kobo.559.2">In a high-cohesion class, almost all parts of the class are oriented on the same types of capabilities. </span><span class="koboSpan" id="kobo.559.3">Let’s look again at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">IFlightUpdater</span></strong><span class="koboSpan" id="kobo.561.1"> interface from earlier for </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.563.1">
public interface IFlightUpdater {
  FlightInfo </span><strong class="bold"><span class="koboSpan" id="kobo.564.1">AddFlight</span></strong><span class="koboSpan" id="kobo.565.1">(FlightInfo flight);
  FlightInfo </span><strong class="bold"><span class="koboSpan" id="kobo.566.1">UpdateFlight</span></strong><span class="koboSpan" id="kobo.567.1">(FlightInfo flight);
  void </span><strong class="bold"><span class="koboSpan" id="kobo.568.1">CancelFlight</span></strong><span class="koboSpan" id="kobo.569.1">(FlightInfo flight);
}</span></pre>
<p><span class="koboSpan" id="kobo.570.1">A class that implemented everything in this interface and added no other members would be a good</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.571.1"> example of </span><em class="italic"><span class="koboSpan" id="kobo.572.1">high cohesion</span></em><span class="koboSpan" id="kobo.573.1"> because all members in this interface are related to working with the same type of item. </span><span class="koboSpan" id="kobo.573.2">A </span><em class="italic"><span class="koboSpan" id="kobo.574.1">low-cohesion</span></em><span class="koboSpan" id="kobo.575.1"> class</span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.576.1"> would start with these methods but also add many methods related to booking flights, generating reports, searching data, or </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">other capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">Classes that have low cohesion usually also violate </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">the SRP.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">Coupling refers to how tightly paired together with other </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.581.1">classes a single class is. </span><span class="koboSpan" id="kobo.581.2">The more classes an individual class needs to know about to do its job, the more tightly coupled it is. </span><span class="koboSpan" id="kobo.581.3">Classes with higher coupling are harder to test due to a larger number of dependencies and need to be modified more frequently as their related classes evolve </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">The DIP provides a great way for classes to reduce </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">their coupling.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">So, when you </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.586.1">hear people talk about wanting high cohesion and low coupling, they’re advocating for classes that are very tightly focused on a specific area and rely on as few other classes as possible to achieve that objective. </span><span class="koboSpan" id="kobo.586.2">When this combination is met, classes tend to be very focused and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">to maintain.</span></span></p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.588.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.589.1">In this chapter, we discussed code smells and anti-patterns. </span><span class="koboSpan" id="kobo.589.2">The right design principles can help keep your code focused and minimal and slow the rate at which it naturally accumulates complexity. </span><span class="koboSpan" id="kobo.589.3">This helps keep your code in good form and resist accumulating </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">technical debt.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">The most common maxim for quality programming is SOLID, following the Single Responsibility Principle (SRP), making code open for extension while being closed to modification, the Liskov Substitution Principle (LSP) advocating for low coupling with polymorphic code, the interface segregation principle focused on several smaller interfaces over one larger interface, and the Dependency Inversion Principle (DIP) which talks about reducing coupling by having classes take in the things they need from outside of </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">the class.</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">Now that we’ve established how to write SOLID code, we’ll explore some advanced testing techniques that can help test code built using </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">these principles.</span></span></p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.595.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.596.1">How does the SRP </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">affect cohesion?</span></span></li>
<li><span class="koboSpan" id="kobo.598.1">Which areas of your code violate the SRP </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">or DRY?</span></span></li>
<li><span class="koboSpan" id="kobo.600.1">What are the advantages of DI? </span><span class="koboSpan" id="kobo.600.2">How does it </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">affect coupling?</span></span></li>
</ol>
<h1 id="_idParaDest-189"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.602.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.603.1">You can find more information about materials discussed in this chapter at </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">these URLs:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.605.1">SOLID Principles in C# with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.606.1">Examples</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">: </span></span><a href="https://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/"><span class="No-Break"><span class="koboSpan" id="kobo.608.1">https://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.609.1">15 of the Worst C# Anti-Patterns Developers Keep Using (And How to Avoid </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.610.1">Them)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">:</span></span><span class="No-Break"><em class="italic"> </em></span><a href="https://methodpoet.com/worst-anti-patterns/"><span class="No-Break"><span class="koboSpan" id="kobo.612.1">https://methodpoet.com/worst-anti-patterns/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.613.1">Top 10 Dotnet Exception Anti-Patterns in </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.614.1">C#</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">: </span></span><a href="https://newdevsguide.com/2022/11/06/exception-anti-patterns-in-csharp/"><span class="No-Break"><span class="koboSpan" id="kobo.616.1">https://newdevsguide.com/2022/11/06/exception-anti-patterns-in-csharp/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.617.1">Using objects that implement </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.618.1">IDisposable</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/using-objects"><span class="No-Break"><span class="koboSpan" id="kobo.620.1">https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/using-objects</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.621.1">LINQ: Caveats and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.622.1">pitfalls</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">: </span></span><a href="https://dev.to/samfieldscc/linq-37k3"><span class="No-Break"><span class="koboSpan" id="kobo.624.1">https://dev.to/samfieldscc/linq-37k3</span></span></a></li>
</ul>
</div>
</body></html>