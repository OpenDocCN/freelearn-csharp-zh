<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Advanced Database Design and Application Techniques</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we learned about reactive programming by discussing its principles and models. We also discussed and looked at examples of how reactive programming is all about data streams.</p>
<p>Database designing is a complex task and needs a lot of patience. In this chapter, we will discuss advanced database and application techniques, including applying <strong>Command Query Responsibility Segregation</strong> (<strong>CQRS</strong>) and ledger-style databases.</p>
<p>Similar to previous chapters, a requirement gathering session will be illustrated in order to determine the <strong>Minimum Viable Product</strong> (<strong>MVP</strong>). In this chapter, several factors will be used to lead the design to CQRS. We will be using a ledger-style approach that consists of increased tracking of changes to inventory levels, as well as wanting to provide public APIs for retrieving inventory levels. This chapter will cover why developers use ledger-style databases and why we should focus on CQRS implementation. In this chapter, we will see why we adapt the CQRS pattern.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Use case discussion</li>
<li>Database discussion</li>
<li>Ledger-style databases for inventory</li>
<li>Implementing the <span>CQRS pattern</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter contains various code examples to explain the concepts. The code is kept simple and is just for demo purposes. Most of the examples involve a .NET Core console application written in C#.</p>
<p>To run and execute the code, Visual Studio 2019 is a prerequisite (you can also use Visual Studio 2017 to run the application).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Visual Studio</h1>
                </header>
            
            <article>
                
<p>To run these code examples, you need to install Visual Studio (preferred IDE). To do so, follow these instructions:</p>
<ol>
<li>Download Visual Studio 2017 (or version 2019) from the following download link:<span> </span><a href="https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio">https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio</a>.<a href="https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio"/></li>
<li>Follow the installation instructions that are accessible through the previous link. <span>Multiple options are available for Visual Studio installation. Here, we are using </span>Visual Studio for Windows.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up .NET Core</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you do not have .NET Core installed, you will need to follow these instructions:</p>
<ol>
<li class="mce-root">Download .NET Core for Windows:<span> </span><a href="https://www.microsoft.com/net/download/windows">https://www.microsoft.com/net/download/windows</a>.<a href="https://www.microsoft.com/net/download/windows"/></li>
<li>For multiple versions and a related library, visit <a href="https://dotnet.microsoft.com/download/dotnet-core/2.2">https://dotnet.microsoft.com/download/dotnet-core/2.2</a>.<a href="https://dotnet.microsoft.com/download/dotnet-core/2.2"/></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing SQL Server</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you do not have SQL Server installed, you need to follow these instructions:</p>
<ol>
<li>Download SQL Server from the following link: <a href="https://www.microsoft.com/en-in/download/details.aspx?id=1695">https://www.microsoft.com/en-in/download/details.aspx?id=1695</a>.<a href="https://www.microsoft.com/en-in/download/details.aspx?id=1695"/></li>
<li>You can find the installation instructions at <a href="https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017">https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017</a>.<a href="https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017"/></li>
</ol>
<div class="mce-root packt_infobox">For troubleshooting and for more information, refer to the following link: <a href="https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm">https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm</a>.<a href="https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use case discussion</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will continue with our FlixOne inventory application. Throughout this chapter, we will discuss CQRS patterns and extend the web application that we developed in the previous chapters.</p>
<div class="packt_quote packt_infobox"><span>This chapter continues with the web application that was developed in the previous chapter. If you skipped the previous chapter, please revisit it in order to aid your understanding of the current chapter.</span></div>
<p>In this section, we will go through the process of requirement gathering, and then discuss the various challenges with our web application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project kickoff</h1>
                </header>
            
            <article>
                
<p class="mce-root">In <a href="232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml">Chapter 7</a>, <em>Implementing Design Patterns for Web Applications – Part 2</em>, we extended FlixOne Inventory and added authentication and authorization to the web application. We extended the application after considering the following points:</p>
<ul>
<li>The current application is open for all; therefore, any user can visit any page, even restricted pages.</li>
<li>Users should not access pages that require access or special access rights; these pages are also known as restricted pages or pages with limited access.</li>
<li>Users should be able to access pages/resources as per their roles.</li>
</ul>
<p>In <a href="84b551c9-fcee-4017-bea5-31c803184e9f.xhtml">Chapter 10</a>, <em>Reactive Programming Patterns and Techniques</em>, we further extended our FlixOne Inventory application and added paging, filtering, and sorting to all pages that show listings. The following points were considered while we extended the app:</p>
<ul>
<li><strong>Item filtering</strong>: Currently, users are unable to filter items by their categories. To extend this feature, users should be able to filter product items based on their categories.</li>
<li><strong>Item sorting</strong>: Currently, items are appearing in the order in which they have been added to the database. There is no mechanism that enables the user to sort items based on categories such as item name or price.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">After several meetings and discussions with management, <strong>Business Analyst</strong> (<strong>BA</strong>), and pre-sales staff, management decided to work on the following high-level requirements: business requirements and technical requirements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Business requirements</h1>
                </header>
            
            <article>
                
<p>On the basis of discussions with stakeholders and endusers, and as per the market survey, our business team has listed the following requirements:</p>
<ul>
<li><strong>Product expansion</strong>: The product is reaching different users. This is a good time to expand the application. <span>The application will robust to expand after having expanded it</span>.</li>
<li><strong>Product model</strong>: Being an inventory management application, users should feel freedom (<span>this mean no restriction at model level, without complicated validations</span>) and there should not be any restriction while users are interacting with the application. Every screen and page should be self-explanatory.</li>
<li><strong>Database design</strong>: The application's database should be designed in such a way that the expansion should not take much time.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The actual requirements that meet business needs are now ready for development. After several discussions with business staff, we concluded that the following are the requirements:</p>
<ul>
<li>The following are the requirements for the<strong> landing</strong> or <strong>home page</strong>:
<ul>
<li>Should be a dashboard that contains various widgets</li>
<li>Should show an at-a-glance picture of the store</li>
</ul>
</li>
<li><span>The following are the requirements for the</span><strong> product page</strong>:
<ul>
<li>Should have the capability to add, update, and delete products</li>
<li>Should have the capability to add, update, and delete product categories</li>
</ul>
</li>
</ul>
<div class="packt_infobox">The FlixOne Inventory Management web application is an imaginary product. We are creating this application to discuss the various design patterns that are required/used in web projects.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Challenges</h1>
                </header>
            
            <article>
                
<p class="mce-root">Although we have extended our existing web application, it has various challenges for both developers and businesses. In this section, we will discuss these challenges and then we will find out the solutions to overcome these challenges.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Challenges for developers</h1>
                </header>
            
            <article>
                
<p>The following are the challenges that arose due to a big change in the application. They were also a result of the major extensions associated with upgrading a console application to a web application:</p>
<ul>
<li><strong>No support for RESTful services</strong>: Currently, there is no support for RESTful services because no APIs have been developed.</li>
<li><strong>Limited security</strong>: In the current application, there is only one mechanism that can restrict/permit the user from/to gaining access to a particular screen or module of the application: that is, by the login. </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Challenges for businesses</h1>
                </header>
            
            <article>
                
<p>The following challenges occur as we adapt a new technology stack, and there are plenty of changes in the code. <span class="fontstyle0">Therefore, it takes time to achieve the final output, which delays the product, resulting in a loss for the business:</span></p>
<ul>
<li><strong>Loss of clientele</strong>: Here, we are still in the development stage but the demand for our business is very high. However, the development team is taking longer than expected to deliver the product.</li>
<li><strong>It takes more time to roll out the production updates</strong>: Development efforts are time-consuming at the moment and this delays the subsequent activities, leading to a delay in production.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing a solution to the problems/challenges</h1>
                </header>
            
            <article>
                
<p>After several meetings and brainstorming sittings, the development team came to the conclusion that we have to stabilize our web-based solution. To overcome these challenges and provide the solution, the tech team and business team got together to identify the various solutions and points.</p>
<p>The following are the points supported by the solution:</p>
<ul>
<li>Evolve RESTful webservices—there should be one API dashboard</li>
<li>Strictly following <strong>T</strong><strong>est-Driven Development</strong> (<strong>TDD</strong>)</li>
<li>Re-designing the <strong>user interface</strong> (<strong>UI</strong>) to meet the user experience expectations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Database discussion</h1>
                </header>
            
            <article>
                
<p>Before we start with the database discussion we have to consider the following points—a big picture of our FlixOne web application:</p>
<ul>
<li>One part of our application is inventory management, but another part of it is an e-commerce web application.</li>
<li>The challenging part is that our application would also serve as a <strong>Point Of Sale</strong> (<strong>POS</strong>). In this part/module, the user can pay for the items they have purchased from offline counters/outlets.</li>
<li>For the inventory part, we need to address which approach we will be taking to calculate and maintain accounts and transactions, and to determine the cost of any item sold.</li>
</ul>
<ul>
<li>To maintain stock for inventories, various options are available, with the two most commonly used options being <strong>First In First Out</strong> (<strong>FIFO</strong>) and <strong>Last In First Out</strong> (<strong>LIFO</strong>).</li>
<li>Most of the transactions involve financial data, hence these transactions require historical data. Every record should have the following information: current value, the value before current changes, and the changes made.</li>
<li>While we're maintaining inventory, we are also required to maintain the items purchased.</li>
</ul>
<p>There are more points that are important when designing a database for any e-commerce web application. We are limiting our scope for the FlixOne application in order to showcase the inventory and stock management.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Database processing</h1>
                </header>
            
            <article>
                
<p>Similar to the other topics we have covered in this book, there are a large number of databases ranging from basic patterns concerning the schema of a database to patterns that govern how database systems are put together. This section will cover two system patterns, <strong>Online Transaction Processing</strong> (<strong>OLTP</strong>) and <strong>Online Analytical Processing</strong> (<strong>OLAP</strong>). To further understand database design patterns, we will explore a specific pattern, ledger-style databases, in more detail.</p>
<div class="packt_infobox">A database schema is another word for the collection of tables, views, stored procedures, and other components that make up a database. Think of this as the <em>blueprint</em> of the database.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OLTP</h1>
                </header>
            
            <article>
                
<p>An OLTP database has been designed to handle large numbers of statements that cause changes to the database. Basically, the <kbd>INSERT</kbd>, <kbd>UPDATE</kbd>, and <kbd>DELETE</kbd> statements all cause changes and behave very differently from the <kbd>SELECT</kbd> statement. OLTP databases have been designed with this in mind. Because these databases record changes, they are typically the <em>main </em>or <em>master</em><em> </em>database, meaning that they are the repositories that hold the current data.</p>
<div class="packt_infobox"><span>The <kbd>MERGE</kbd> statement also qualifies as a statement that causes change. This is because it p</span>rovides a convenient syntax for the insertion of a record when a row does not exist, and <span>the insertion of </span>an update when a row does exist. It will update when a row does exist. The <kbd>MERGE</kbd> statement is not supported in all database providers or versions.</div>
<p>OLTP databases are typically designed to process change statements quickly. This is normally done by the careful planning of table structures. A simple way of viewing this is to consider a database table. This table can have fields for storing data, keys for looking up the data efficiently, indexes to other tables, triggers to respond to specific situations, and other table constructs. Each one of these constructs has a performance penalty. The design of OLTP databases is, therefore, a balance between using the minimum number of constructs on a table versus the desired behavior.</p>
<p>Let's consider a table that records the books in our inventory system. Each book might record the name, quantity, date published, and have references to author information, publishers, and other related tables. We could put an index on all columns and even add indexes for the data in related tables. The problem with this approach is that each index has to be stored and maintained for each statement that causes change. Database designers have to carefully plan and analyze databases in order to determine the optimal combination of adding and, just as importantly, not adding indexes and other constructs to tables.</p>
<div class="packt_infobox">A table index can be thought of like a virtual lookup table that provides the relational database with a faster way of looking up data.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OLAP</h1>
                </header>
            
            <article>
                
<p>Databases designed using the OLAP pattern are expected to have more <kbd>SELECT</kbd> statements than statements that cause change. These databases usually have a consolidated view of the data of one or more databases. Because of this, these databases are usually not the master database, but a database used to provide reporting and analysis separate from the master database. In some situations, this is provided on infrastructure isolated from other databases so as to not impact the performance of operational databases. This type of deployment is often referred to as a <strong>data warehouse</strong>.</p>
<p>A data warehouse<strong> </strong>can be used to provide a consolidated view of a system or collection of systems within an enterprise. The data <span>is traditionally fed</span> with slower periodical jobs to refresh the data from other systems, but with modern database systems, this is trending towards near real-time consolidation.</p>
<p>The major difference between OLTP and OLAP is around how the data is stored and organized. In many situations, this would require tables or persistent views—depending on the technology used—to be created in the OLAP database that supports specific reporting scenarios and duplicates the data. In OLTP databases, duplication of data is undesirable as it then introduces multiple tables that need to be maintained for a single statement that causes change.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ledger-style databases</h1>
                </header>
            
            <article>
                
<p>The ledger-style database design will be highlighted, as it is both a pattern that has been used in many financial databases for decades and it may not be known to some developers. The ledger-style database stems from an accountant's ledger, where transactions were added to a document and the quantities and/or amounts are tallied in order to arrive at a final quantity or amount. The following table shows a ledger of the sale of apples:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f1a0135c-e2a0-406c-8ce9-2c20c019ee12.png" style=""/></div>
<p>There are a couple of things to point out about the example. The <span class="packt_screen">Purchaser</span> information is written on separate rows instead of erasing their amounts and entering <span>a new amount</span>. Take the two purchases and one credit for <span class="packt_screen">West Country Produce</span>. This is typically different from many databases in which a single row contains the <span class="packt_screen">Purchaser</span> information with separate fields for the <span class="packt_screen">Amount</span> and <span class="packt_screen">Price</span>. </p>
<p>A ledger-style database takes this concept by having a separate row per transaction, thus removing the <kbd>UPDATE</kbd> and <kbd>DELETE</kbd> statements and only relying on <kbd>INSERT</kbd> statements. This has several benefits. Similarly to a ledger, once each transaction has been written it cannot be removed or changed. If a mistake or a change occurs, such as the credit to <span class="packt_screen">West Country Produce</span>, a new transaction needs to be written in order to arrive at the desired state. An interesting benefit of this is that the source table now has the immediate value of providing a detailed log of the activity. If we were to add a <em><span class="packt_screen">modified by</span></em> column, we could then have a comprehensive log of who or what made the change and what the change was.</p>
<div class="packt_infobox">This example is for a single-entry ledger, but in the real world, a double-entry ledger would be used. The difference is that in a double-entry ledger, each transaction is recorded as a credit in one table and a debit in another.</div>
<p>The next challenge is capturing the final or rolled-up version of the table. In this example, that is that amount of apples that have been purchased and for how much. The first approach could use a <kbd>SELECT</kbd> statement that simply performs <kbd>GROUP BY</kbd> on the purchaser, as follows:</p>
<pre>SELECT Purchaser, SUM(Amount), SUM(Price)<br/>FROM Apples<br/>GROUP BY Purchaser</pre>
<p>While this would be fine for smaller data sizes, the issue here is that the performance of the query would degrade over time as the number of rows increases. An alternative would be to aggregate the data into another form. There are two main ways of achieving this. The first is to perform this activity at the same time as you write the information from the ledger table into another table (or persistent view if supported) that holds the data in an aggregate form.</p>
<div class="packt_infobox">A <strong>persistent</strong> or <strong>materialized view</strong> is similar to a database view, but the results of the view are cached. This gives us the benefit of not requiring the view to be recalculated on each request, and it is either refreshed periodically or when the underlying data changes.</div>
<p>The second approach relies on another mechanism that is separate from the <kbd>INSERT</kbd> statement to retrieve the aggregated view when required. In some systems, the primary scenario of writing changes to a table and retrieving the result is performed less frequently. In this case, it would make more sense to optimize the database so that writes are faster than reads, therefore limiting the amount of processing required when new records are inserted.</p>
<p>The next section deals with an interesting pattern CQRS that can be applied at the database level. This could be used in the ledger-style database design.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the CQRS pattern</h1>
                </header>
            
            <article>
                
<p class="mce-root">CQRS simply works on the separation between queries (to read) and commands (to modify). <strong>Command-Query Separation</strong> (<strong>CQS</strong>) is an approach to <strong>Object-oriented Design</strong> (<strong>OOD</strong>).</p>
<div class="packt_infobox">CQRS was introduced for the first time by Bertrand Meyer (<a href="https://en.wikipedia.org/wiki/Bertrand_Meyer">https://en.wikipedia.org/wiki/Bertrand_Meyer</a>). He mentioned this term in his book, <em>Object-Oriented Software Construction</em>, during the late 1980s: <a href="https://www.amazon.in/Object-Oriented-Software-Construction-Prentice-hall-International/dp/0136291554">https://www.amazon.in/Object-Oriented-Software-Construction-Prentice-hall-International/dp/0136291554</a>.</div>
<p>CQRS does fit well with some scenarios and has some useful factors to it:</p>
<ul>
<li><strong>Model separation</strong>: In modeling terms, we are able to have multiple representations for our data model. The clear separation allows for choosing different frameworks or techniques over others that are more suitable for query or command. Arguably, this is achievable with <strong>create, read, update, and delete</strong> (<strong>CRUD</strong>)-style entities, although the single data layer assembly often emerges.</li>
<li><strong>Collaboration</strong>: In some enterprises, a separation between query and command would benefit the teams involved in building complex systems, particularly when some teams are more suited for different aspects of an entity. For example, a team that is more concerned about presentation could concentrate on the query model, while another team that is more focused on data integrity could maintain the command model.</li>
<li><strong>Independent scalability</strong>: Many solutions tend to either require more reads against the model, or more writes, depending on the business requirements.</li>
</ul>
<div class="packt_tip">For CQRS, remember that commands update data and queries read data.</div>
<p>Some important things to note while working on CQRS are as follows:</p>
<ul>
<li>Commands should be placed asynchronously rather than as synchronous operations.</li>
<li>Databases should never be modified with queries.</li>
</ul>
<p>CQRS simplifies the design with the use of separate commands and queries. Also, we can physically separate read data from write data operations. In this arrangement, a read database could use a separate database schema, or in other words, we can say that it could use a read-only database that is optimized for queries.</p>
<p>As the database uses a physical separation approach, we can visualize the CQRS flow of the application, as depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a303ee36-9fb8-411d-a49c-26b3f526b63d.png" style=""/></div>
<p>The preceding diagram depicts an imaginary workflow of the CQRS application, in which an application has physically separate databases for write operations and read operations. This imaginary application is based on RESTful web services (.NET Core APIs). No APIs have been exposed directly to the client/end user who is consuming these APIs. There is an API gateway exposed to users, and any requests for applications will come through the API gateway.</p>
<div class="packt_tip">The API Gateway provides an entry point to groups with similar types of services. You can also simulate it with the facade pattern, which is part of the distributed system.</div>
<p>In the previous diagram, we have the following:</p>
<ul>
<li><strong>User interface</strong>: This could be any client (who is consuming the APIs), web application, desktop application, <span>mobile application, </span>or any other application.</li>
<li><strong>API Gateway</strong>: Any request from UI and response to UI is delivered from the API Gateway. This is the main part of CQRS, as business logic can be incorporated by using the Commands and Persistence layers.</li>
<li><strong>Database(s)</strong>: The diagram shows two physically separated databases. In real applications, this depends upon the requirements of the product, and you can use the database for both write and read operations.</li>
<li>Queries are generated with <kbd>Read</kbd> operations that are <strong>Data Transfer Objects</strong> (<strong>DTOs</strong>).</li>
</ul>
<p>You can now go back to the <em>Use case</em> section, in which we discussed the new features/extensions of our FlixOne inventory application. In this section, we will create a new FlixOne application with the features discussed previously using the CQRS pattern. Please note that we will be developing APIs first. If you did not install the pre-requisites, I suggest revisiting the <em>Technical requirements</em> section, gathering all of the required software, and installing them onto your machine. If you have completed the pre-requisites, then let's start by following these steps:</p>
<ol>
<li>Open Visual Studio.</li>
<li>Click <span class="packt_screen">File</span> | <span class="packt_screen">New Project</span> to create a new project.</li>
<li>On the <span class="packt_screen">New Project</span> window, select <span class="packt_screen">Web</span> and then select <span class="packt_screen">ASP.NET Core Web Application</span>.</li>
<li>Give a name to your project. I have named our project <kbd>FlixOne.API</kbd> and ensured that the <span class="packt_screen">Solution Name</span> is <kbd>FlixOne</kbd>.</li>
</ol>
<ol start="5">
<li>Select the <span class="packt_screen">Location</span> of your <kbd>Solution</kbd> folder, then click on the <span class="packt_screen">OK</span> button as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/914c131b-65df-48fc-8f20-228eee0db8f6.png" style=""/></div>
<ol start="6">
<li>Now you should be on the <span class="packt_screen">New ASP.NET Web Core Application - FlixOne.API</span> <span>screen. </span>Make sure that on this screen, you select <span class="packt_screen">ASP.NET Core 2.2</span>. Select <span class="packt_screen">Web Application (Model-View-Controller)</span> from the available templates, and uncheck the <span class="packt_screen">Configure for HTTPS</span> checkbox, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/90477786-80eb-41aa-b030-2bf74fa836dd.png" style=""/></div>
<ol start="7">
<li>You will see a default page appear, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/193efeb2-573e-4ed9-a6d9-49ec51d1d571.png" style=""/></div>
<ol start="8">
<li>Expand <span class="packt_screen">Solution Explorer</span> and click on <span class="packt_screen">Show All files</span>. You will see the default folders/files created by <span class="packt_screen">Visual Studio</span>. Refer to the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/40563f44-0662-4c1b-aa6e-4901e13813ae.png" style=""/></div>
<p>We have selected the <span class="packt_screen">ASP.NET Core Web (Model-View-Controller)</span> template. Therefore, we have the default folders, <span class="packt_screen">Controllers</span>, <span class="packt_screen">Models</span>, and <span class="packt_screen">Views</span>. This is a default template provided by <span class="packt_screen">Visual Studio</span>. To check this default template, hit <em>F5</em> and run the project. Then, you will see the following default page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/61edea34-6458-48cb-b002-75bcbfa738a9.png" style=""/></div>
<p>The previous screenshot is the default <span class="packt_screen">Home</span> screen of our web application. You may be thinking <em>is it a website?</em> and be expecting an API documentation page here instead of a web page. This is because, when we select the template, <span class="packt_screen">Visual Studio</span> adds MVC Controller instead of API Controller <span>by default</span>. Please note that in ASP.NET Core, both MVC Controller and API Controller use the same Controller Pipeline (see the Controller class: <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller?view=aspnetcore-2.2">https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controller?view=aspnetcore-2.2</a>).</p>
<p>Before discussing API projects in detail, let's first add a new project to our FlixOne solution. To do so, expand <span class="packt_screen">Solution Explorer</span>, right-click on the <span class="packt_screen">Solution Name</span>, and then click on <span class="packt_screen">Add New Project</span>. Refer to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8b9834e5-e012-4982-932b-057a6510b41e.png" style=""/></div>
<p>In the <span class="packt_screen">New Project</span> window, add the new <kbd>FlixOne.CQRS</kbd> <span>project, </span>and click on the <kbd>OK</kbd> button. Refer to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/87ee0e48-d801-44b4-9c68-6e9201eb48e5.png" style=""/></div>
<p>The previous screenshot is of the <span class="packt_screen">Add New Project</span> window. On it, select .NET Core and then select the <span class="packt_screen">Class Library(.NET Core)</span> project. Enter the name <kbd>FlixOne.CQRS</kbd> and click the <span class="packt_screen">OK</span> button. A <span class="packt_screen">New Project</span> has been added to the solution. You can then add folders to the new solution, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cb3a872f-4b1b-486f-b858-b04df8b0855e.png" style=""/></div>
<p>The previous screenshot is showing that I have added four new folders: <kbd>Commands</kbd>, <kbd>Queries</kbd>, <kbd>Domain</kbd>, and <kbd>Helper</kbd>. In the <kbd>Commands</kbd> folder, I have the <kbd>Command</kbd> and <kbd>Handler</kbd> sub-folders. Similarly, for the <kbd>Queries</kbd> folder, I have added sub-folders called <kbd>Handler</kbd> and <kbd>Query</kbd>.</p>
<p>To get started with the project, let's first add two Domain Entities in the project. The following is the required code:</p>
<pre>public class Product<br/>{<br/>    public Guid Id { get; set; }<br/>    public string Name { get; set; }<br/>    public string Description { get; set; }<br/>    public string Image { get; set; }<br/>    public decimal Price { get; set; }<br/>}</pre>
<p>The preceding code is a <kbd>Product</kbd> domain entity that has the following properties:</p>
<ul>
<li><kbd>Id</kbd>: A unique identifier</li>
<li><kbd>Name</kbd>: A product name</li>
<li><kbd>Description</kbd>: A product description</li>
<li><kbd>Image</kbd>: An image of the product</li>
<li><kbd>Price</kbd>: The price of the product</li>
</ul>
<p>We also need to add the <kbd>CommandResponse</kbd> database. This plays an important role when interacting with database/repository, in that it ensures that the system gets a response. The f<span>ollowing is the code-snippet of the</span> <kbd>CommandResponse</kbd> <span>Entity Model:</span></p>
<pre>public class CommandResponse<br/>{<br/>    public Guid Id { get; set; }<br/>    public bool Success { get; set; }<br/>    public string Message { get; set; }<br/><br/>}</pre>
<p>The preceding <kbd>CommandResponse</kbd> <span>class </span>contains the following properties:</p>
<ul>
<li><kbd>Id</kbd>: Unique identifier.</li>
<li><kbd>Success</kbd>: With values of <kbd>True</kbd> or <kbd>False</kbd>, it tells us whether the operation is successful or not.</li>
<li><kbd>Message</kbd>: A message as a response to the operation. If <kbd>Success</kbd> if false, this message contains <kbd>Error</kbd>.</li>
</ul>
<p>Now, it's time to add interfaces for a query. To add interfaces, follow these steps:</p>
<ol>
<li>From <span class="packt_screen">Solution Explorer</span>, right-click on the <kbd>Queries</kbd> folder, click on <span class="packt_screen">Add</span>, and then click on <span class="packt_screen">New Item</span>, as per the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c7b79ebb-67b7-49ff-a003-26a089491ba5.png"/></div>
<ol start="2">
<li>From the <span class="packt_screen">Add New Item</span> window, choose <span class="packt_screen">Interface</span>, name it <span class="packt_screen">IQuery</span>, and click on the <span class="packt_screen">Add</span> button:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e055b30e-23f0-49bd-b246-49d682935ed7.png"/></div>
<ol start="3">
<li>Follow the previous steps and add the <kbd>IQueryHandler</kbd> interface as well. The following is the code from the <kbd>IQuery</kbd> interface:</li>
</ol>
<pre style="padding-left: 60px">public interface IQuery&lt;out TResponse&gt;<br/>{<br/>}</pre>
<ol start="4">
<li>The previous interface works as a skeleton for querying for any kind of operation. This is a generic interface using an <kbd>out</kbd> parameter of the <kbd>TResponse</kbd> type.</li>
</ol>
<p style="padding-left: 60px">The following is code from our <kbd>ProductQuery</kbd> class:</p>
<pre style="padding-left: 60px">public class ProductQuery : IQuery&lt;IEnumerable&lt;Product&gt;&gt;<br/>{<br/>}<br/><br/>public class SingleProductQuery : IQuery&lt;Product&gt;<br/>{<br/>    public SingleProductQuery(Guid id)<br/>    {<br/>        Id = id;<br/>    }<br/><br/>    public Guid Id { get; }<br/>    <br/>}</pre>
<p style="padding-left: 60px">The following is code from our <kbd>ProductQueryHandler</kbd> class:</p>
<pre style="padding-left: 60px">public class ProductQueryHandler : IQueryHandler&lt;ProductQuery, IEnumerable&lt;Product&gt;&gt;<br/>{<br/>    public IEnumerable&lt;Product&gt; Get()<br/>    {<br/>        //call repository<br/>        throw new NotImplementedException();<br/>    }<br/>}<br/>public class SingleProductQueryHandler : IQueryHandler&lt;SingleProductQuery, Product&gt;<br/>{<br/>    private SingleProductQuery _productQuery;<br/>    public SingleProductQueryHandler(SingleProductQuery productQuery)<br/>    {<br/>        _productQuery = productQuery;<br/>    }<br/><br/>    public Product Get()<br/>    {<br/>        //call repository<br/>        throw new NotImplementedException();<br/>    }<br/>}</pre>
<p style="padding-left: 60px"><span>The following</span> is code from our <kbd>ProductQueryHandlerFactory</kbd> class:</p>
<pre>public static class ProductQueryHandlerFactory<br/>{<br/>    public static IQueryHandler&lt;ProductQuery, IEnumerable&lt;Product&gt;&gt; Build(ProductQuery productQuery)<br/>    {<br/>        return new ProductQueryHandler();<br/>    }<br/><br/>    public static IQueryHandler&lt;SingleProductQuery, Product&gt; Build(SingleProductQuery singleProductQuery)<br/>    {<br/>        return  new SingleProductQueryHandler(singleProductQuery);<br/>    }<br/>}</pre>
<p>Similarly to <kbd>Query</kbd> interfaces and <kbd>Query</kbd> classes, we need to add interfaces for commands and their classes.</p>
<p>At the point by which we have created CQRS for a product domain entity, you can follow this workflow and add more entities as many times as you like. Now, let's move on to our <kbd>FlixOne.API</kbd> project and add a new API controller by following these steps:</p>
<ol>
<li>From <span class="packt_screen">Solution Explorer</span>, right-click on the <kbd>Controllers</kbd> folder.</li>
<li>Select <span class="packt_screen">Add</span> | <span class="packt_screen">New Item</span>.</li>
</ol>
<ol start="3">
<li>Select <span class="packt_screen">A</span><span class="packt_screen">PI Controller Class</span> and name it <kbd>ProductController</kbd>; refer to the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b9088f70-6e1b-4b33-a49f-2cff8620875d.png" style=""/></div>
<ol start="4">
<li>Add the following code in the API controller:</li>
</ol>
<pre style="padding-left: 60px">[Route("api/[controller]")]<br/>public class ProductController : Controller<br/>{<br/>    // GET: api/&lt;controller&gt;<br/>    [HttpGet]<br/>    public IEnumerable&lt;Product&gt; Get()<br/>    {<br/>        var query = new ProductQuery();<br/>        var handler = ProductQueryHandlerFactory.Build(query);<br/>        return handler.Get();<br/>    }<br/><br/>    // GET api/&lt;controller&gt;/5<br/>    [HttpGet("{id}")]<br/>    public Product Get(string id)<br/>    {<br/>        var query = new SingleProductQuery(id.ToValidGuid());<br/>        var handler = ProductQueryHandlerFactory.Build(query);<br/>        return handler.Get();<br/>    }</pre>
<p><span>The following</span> code is for saving the product:</p>
<pre style="padding-left: 60px"><br/>    // POST api/&lt;controller&gt;<br/>    [HttpPost]<br/>    public IActionResult Post([FromBody] Product product)<br/>    {<br/>        var command = new SaveProductCommand(product);<br/>        var handler = ProductCommandHandlerFactory.Build(command);<br/>        var response = handler.Execute();<br/>        if (!response.Success) return StatusCode(500, response);<br/>        product.Id = response.Id;<br/>        return Ok(product);<br/><br/>    }</pre>
<p><span>The following</span> code is for deletion of products:</p>
<pre style="padding-left: 60px"><br/>    // DELETE api/&lt;controller&gt;/5<br/>    [HttpDelete("{id}")]<br/>    public IActionResult Delete(string id)<br/>    {<br/>        var command = new DeleteProductCommand(id.ToValidGuid());<br/>        var handler = ProductCommandHandlerFactory.Build(command);<br/>        var response = handler.Execute();<br/>        if (!response.Success) return StatusCode(500, response);<br/>        return Ok(response);<br/>    }<br/><br/></pre>
<p>We have created Product APIs, and we are not going to creates UI in this section. To view what we have done, we will be adding <strong>Swagger</strong> support to our API project.</p>
<p>Swagger is a tool that can be used for documentation purposes, and provides all of the information regarding the API endpoints on one screen, where you can visualize the API and test it by setting parameters as well.</p>
<p>To get started with the implementation of Swagger in our API project, follow these steps:</p>
<ol>
<li>
<p>Open Nuget Package Manager.</p>
</li>
<li>
<p>Go to <span class="packt_screen">Nuget Package Manager</span> | <span class="packt_screen">Browse</span> and search for <kbd>Swashbuckle.ASPNETCore</kbd>; refer to the following screenshot:</p>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1704e800-d6c6-4e30-b6aa-ff6e38bde866.png" style=""/></div>
<ol start="3">
<li>Open the <kbd>Startup.cs</kbd> <span>file </span>and add the following code to the <kbd>ConfigureService</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">//Register Swagger<br/>            services.AddSwaggerGen(swagger =&gt;<br/>            {<br/>                swagger.SwaggerDoc("v1", new Info { Title = "Product APIs", Version = "v1" });<br/>            });</pre>
<ol start="4">
<li>Now, add the following code to the <kbd>Configure</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">// Enable middleware to serve generated Swagger as a JSON endpoint.<br/>app.UseSwagger();<br/><br/>// Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.), specifying the Swagger JSON endpoint.<br/>app.UseSwaggerUI(c =&gt;<br/>{<br/>    c.SwaggerEndpoint("/swagger/v1/swagger.json", "Product API V1");<br/>});</pre>
<p>We have now completed all of the changes that serve to showcase the power of CQRS in the application. Hit <em>F5</em> in <span class="packt_screen">Visual Studio</span> and open the Swagger documentation page by accessing the following URL: <a href="http://localhost:52932/swagger/">http://localhost:52932/swagger/</a> (please note that port number <kbd>52932</kbd> may vary as per your setting of the project). You will see the following <span class="packt_screen">Swagger Documentation</span> page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2a67a98c-096c-4475-8258-7a0ace3abfbd.png" style=""/></div>
<p>Here, you can test Product APIs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">This chapter introduced the CQRS pattern, which we then implemented into our application. The aim of the chapter was to go through the database techniques and look at how ledger-style databases work for inventory systems. To showcase the power of CQRS, we have created Product APIs and added support for Swagger documentation.</p>
<p>In the next chapter, we will discuss cloud services and look at microservices and serverless techniques in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>The following questions will allow you to consolidate the information contained in this chapter:</span></p>
<ol>
<li>What is a ledger-style database?</li>
<li>What is CQRS?</li>
<li>When should we use CQRS?</li>
</ol>


            </article>

            
        </section>
    </body></html>