- en: The Factory Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Factory Method is probably the most famous design pattern because it offers
    a solid structural base for most software architectures. There are two main variations
    of this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The Factory Method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main difference between both patterns is that the Factory Method is centered
    around a single Factory Method, while the Abstract Factory provides a way to encapsulate
    and group factories that have a familiar theme. These descriptions might sound
    abstract at the moment, but we will implement both of these variations in separate
    chapters so that we can better understand the core differences between each type
    of Factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: On a personal note, my only issue with the Factory pattern, in general, is that
    programmers tend to be irregular in the ways they implement it, and so sometimes
    consistency is lost because of personal style. But as we are going to see throughout
    this book, the most popular patterns tend to have significant alterations in the
    way they are implemented by professional programmers. We are going to try and
    take an approach that's always compatible with Unity's API and coding model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Factory Method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a **non-player characters** (**NPC**) spawn system while using
    the Factory Method as the foundation of our architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The core difference between the Factory and Prototype patterns is that the Factory pattern
    is useful when you want to delegate the creation process of objects, while the
    Prototype pattern is an optimal solution when creating new instances of objects
    is too costly.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is hands on; you will need to have a basic understanding of Unity
    and C# to continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following specific Unity engine and C# language concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're unfamiliar with these concepts, please review them before starting
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2WvN2vp](http://bit.ly/2WvN2vp)'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Factory Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Factory pattern is one of those patterns whose name is a good indication
    of its core purpose. There's a robust real-world correlation that can help us
    visualize its intent – imagine yourself ordering a new car at a dealership. During
    this process, does the dealer inform you of the manufacturing process of your
    new vehicle? The answer is probably no; usually, the dealer sends your order to
    the factory, and then they ship the requested final product back to you.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, as the consumer of a product, you should focus on ordering and
    receiving, not manufacturing and distributing. And that's the primary goal of
    the Factory pattern; it simplifies the *order* process of specific types of objects
    by providing an interface that's abstract to the inner workings of the *manufacturing*
    process of the requested objects.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the introduction, there are two main variations of the Factory,
    but in this chapter, we will review only the simplest form of this pattern, which
    is the Factory Method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by reviewing a UML diagram of a use case that''s using the Factory
    Method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/071dc34a-e237-45b8-999d-cfea94e4589c.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from this diagram, the `GetNPC()` method of the `NPCFactory` class
    is responsible for getting a specific type of NPC (**Beggar**, **Shopowner**,
    or **Farmer**). So, if a client requests a particular type of NPC, it needs to
    ask `NPCFactory` to produce it.
  prefs: []
  type: TYPE_NORMAL
- en: The core purpose of the Factory pattern is to abstract the creation and localize
    the creation process of a particular type of object.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Factory Method pattern has an excellent reputation and is often the cornerstone
    of a reliable code base. Let's have a look at a few of the benefits and drawbacks
    of the Factory Method.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loose coupling**: Because the client doesn''t need to know the details of
    the initialization process of a specific type of object, it reduces coupling and
    dependencies between classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation of the creation process**: The fact that the Factory Method
    takes the responsibility of creating specific object types, you can localize complex
    initialization processes in a single class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extra code complexity**: Code becomes harder to read because you are adding
    abstraction and additional classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open to interpretation**: Programmers often confuse the Factory Method and
    its cousin, the Abstract Factory. This issue might cause inconsistent implementations,
    which can provoke uncertainty and confusion between programmers working on the
    same code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's sometimes difficult to isolate recurrent drawbacks with a specific pattern
    because often it's a question of context. But a universal truth about design patterns
    is that they can become a regressive part of your architecture if you misapply
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of the Factory Method, let's build a
    game system with it. To stay consistent with our previous chapter, we are going
    to implement another spawn system, but this time for NPCs. Because the Factory
    Method is a Creational pattern, it's a natural fit for a spawn system. As we are
    going to see in the following code example, the Factory Method is a perfect pattern
    to use when you need to centralize the initialization pipeline of various entities.
  prefs: []
  type: TYPE_NORMAL
- en: In a professional game project, you might end up having to build separate spawn
    systems for different groups of entities. For example, in an open-world game,
    you might have a specific method to spawn civilians and one to generate cops because
    each primary type of AI character might have different requirements and loading
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned before, the Factory Method is the most straightforward approach
    to implementing a Factory pattern. As its name implies, it primarily focuses on
    providing a standard interface for the creation of specific object types through
    a Factory Method. So, if we have a `Client` class that needs to initialize an
    object of a particular kind (also known as a **product**) but we don''t know the
    exact class or the process to call, instead, we merely refer to a Factory to produce
    the requested product and return it to us. Let''s follow these steps to get started
    with our example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build a simple spawn system for NPCs using the Factory Method as our
    base. But before we do that, we need to declare our general NPC type. The best
    way to do this in code is to have a standard interface for all our NPC characters.
    For reasons of simplicity, all of our NPCs entities will have a common functionality;
    they can speak scripted dialogue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a standard interface for NPCs called `INPC`, we need concrete
    classes for each type of NPC that we might want to spawn. We will limit ourselves
    to the typical characters we might find in a farming village in a classical RPG
    game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First is our `Beggar`, who begs for precious coins:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then there''s our `Shopowner`, who''s always ready to sell us some goods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have our `Farmer`, with their words of wisdom:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now that we have concrete classes for each of our main NPC types, we need
    a way to refer to them when we need to. Let''s write a public `enum` that will
    be easily accessible. We will disclose a list of available NPC types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to implement our `NPCFactory` class with a public Factory
    Method that will create the requested instance (product) of an NPC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, our concrete implementation of the Factory Method is a function
    named `GetNPC()`, which is composed of a switch case that returns an `INPC` instance
    of a specified `NPCType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the benefits of this design are evident in our client, which, in this example,
    will be our `NPCSpawner` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this implementation of the Factory Method and the `NPCSpawner`
    with the following test class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We are now able to spawn instances of a specific NPC without having to know
    the location or the exact name of its concrete class. It might not look impressive
    when dealing with just three basic types, but imagine if every type of NPC had
    a different initializing process with multiple dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine a circumstance in which the `Beggar` NPC is not a character
    but a behavior component that can be attached to any civilian character in our
    scene, while the `Farmer` NPC type is a self-contained prefab. With a Factory
    Method, we don't have to keep in mind all of these specifications every time we
    want to spawn a specific NPC; instead, we let the Factory Method do the dirty
    work for us and decide the best way to create those particular entities.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between using an abstract or an interface when implementing a common
    parent for a specific family of objects can be daunting. In this example, I decided
    to go with an interface because I didn't want to share implementations – I wanted
    to declare a group type.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were introduced to the core principles of the Factory pattern
    and implemented its first variation, the Factory Method. With this pattern, we
    can localize the creation process of types of objects. This might be fine and
    dandy, but what happens if we want complex products that combine various kinds
    of objects each with their specific creation method? Are we going to need to know
    and call each factory separately and assemble them manually?
  prefs: []
  type: TYPE_NORMAL
- en: This issue is what we are going to solve in the next chapter by implementing
    a more advanced version of the Factory pattern; the **Abstract Factory**.
  prefs: []
  type: TYPE_NORMAL
- en: When you analyze the usefulness of a design pattern, always keep in mind that
    they are designed for teamwork. The Factory is a perfect example of this. As a
    solo developer, you might find most design patterns redundant, but imagine yourself
    working on a massive code base with dozens of programmers. In that case, layers
    of abstractions and common interfaces can help you maintain your sanity as your
    team and code base grows.
  prefs: []
  type: TYPE_NORMAL
- en: Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to design a spawn system by using the
    Prototype pattern as our base. Due to this, our system behaved basically like
    a Xerox machine; it made copies of existing instances. This mechanism reduced
    the initialization overhead, but this was only beneficial if we already had a
    reference in memory to copy.
  prefs: []
  type: TYPE_NORMAL
- en: But now, we have the Factory Method in our toolkit; we can localize the process
    of creating new objects of certain types. What would be interesting to try is
    combining both. Could you have the Factory Method check if an instance of that
    type of object already exists in memory?
  prefs: []
  type: TYPE_NORMAL
- en: Combining patterns is a good exercise and will give you a broader range of approaches
    to complex implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Game Programming Patterns* by Robert Nystrom: [http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma,
    John Vlissides, Ralph Johnson, and Richard Helm: [http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610](http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
