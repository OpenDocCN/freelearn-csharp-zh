<html><head></head><body>
		<div><h1 id="_idParaDest-115"><em class="italic"><a id="_idTextAnchor207"/>Chapter 14</em>: Creating a Custom ActionFilter</h1>
			<p>We will keep on customizing on the controller level in this chapter. We'll have a look into action filters and how to create your own <code>ActionFilter</code> class to keep your Actions small and readable. </p>
			<p>This chapter will cover the following topics:</p>
			<ul>
				<li>Introducing <code>ActionFilter</code></li>
				<li>Using <code>ActionFilter</code></li>
			</ul>
			<p>The topics of this chapter belong to the <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) layer of the ASP.NET Core architecture, depicted here:</p>
			<div><div><img src="img/Figure_14.1_B17996.jpg" alt="Figure 14.1 – ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1 – ASP.NET Core architecture </p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor208"/>Technical requirements</h1>
			<p>To follow the exercises in this chapter, you will need to create an ASP.NET Core MVC application. Open your console, shell, or Bash terminal and change to your working directory. Use the following command to create a new MVC application:</p>
			<pre>dotnet new web -n ActionFilterSample -o ActionFilterSample</pre>
			<p>Now, open the project in Visual Studio by double-clicking the project file or in <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>) by typing the following command in the already open console:</p>
			<pre>cd ActionFilterSample
code .</pre>
			<p>All of the code samples in this chapter can be found in the GitHub repository for this book at: <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter14">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter14</a>.</p>
			<h1 id="_idParaDest-117">I<a id="_idTextAnchor209"/><a id="_idTextAnchor210"/>ntroducing ActionFilter</h1>
			<p>Action filters are a little bit like middleware because they can manipulate the input and the output but are <a id="_idIndexMarker208"/>executed immediately on a specific action or on all actions of a specific controller on the MVC layer, and MiddleWare works directly on the request object on the hosting layer. An <code>ActionFilter</code> class is created to execute code right before or after an action is executed. They are introduced to execute aspects that are not part of the actual action logic: <code>AuthorizeAttribute</code> is used to allow users or groups to access specific Actions or Controllers. <code>AuthorizeAttribute</code> is an <code>ActionFilter</code>. It checks whether the logged-on user is authorized or not. If not, it redirects to the login page. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you apply an <code>ActionFilter</code> globally, it executes on all actions in your application.</p>
			<p>The next code sample shows the skeletons of a normal action filter and an async <code>ActionFilter</code>:</p>
			<pre>using Microsoft.AspNetCore.Mvc.Filters;
 
namespace ActionFilterSample;
public class SampleActionFilter : IActionFilter
{
    public void OnActionExecuting(
        ActionExecutingContext context)
    {
        // do something before the action executes
    }
    public void OnActionExecuted(
        ActionExecutedContext context)
    {
        // do something after the action executes
    }
}
public class SampleAsyncActionFilter : IAsyncActionFilter
{
    public async Task OnActionExecutionAsync(
        ActionExecutingContext context,
        ActionExecutionDelegate next)
    {
        // do something before the action executes
        var resultContext = await next();
        // do something after the action executes; 
        // resultContext.Result will be set
    }
}</pre>
			<p>As you can see here, there are always two methods to place code to execute before and after the target <a id="_idIndexMarker209"/>action is executed. These action filters cannot be used as attributes. If you want to use action filters as attributes in your Controllers, you need to derive them from <code>Attribute</code> or from <code>ActionFilterAttribute</code>, as shown in the following code snippet:</p>
			<pre>using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
 
namespace ActionFilterSample;
public class ValidateModelAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(
        ActionExecutingContext context)
    {
        if (!context.ModelState.IsValid)
        {
            context.Result = new BadRequestObjectResult(
                context.ModelState);
        }
    }
}</pre>
			<p>The preceding code snippet shows a simple <code>ActionFilter</code> that always returns <code>BadRequestObjectResult</code> if <code>ModelState</code> is not valid. This may be useful within a web <code>POST</code>, <code>PUT</code>, and <code>PATCH</code> requests. This could <a id="_idIndexMarker210"/>be extended with a lot more validation logic. We'll see how to use it later on.</p>
			<p>Another possible use case for an <code>ActionFilter</code> is logging. You don't need to log in controller actions directly. You can do this in an action filter to keep your actions readable with <a id="_idIndexMarker211"/>relevant code, as illustrated in the following snippet:</p>
			<pre>using Microsoft.AspNetCore.Mvc.Filters;
 
namespace ActionFilterSample;
public class LoggingActionFilter : IActionFilter
{
    ILogger _logger;
    public LoggingActionFilter(ILoggerFactory 
      loggerFactory)
    {
        _logger =
         loggerFactory.CreateLogger&lt;LoggingActionFilter&gt;();
    }
    public void OnActionExecuting(
        ActionExecutingContext context)
    {
        _logger.LogInformation(
          $"Action '{context.ActionDescriptor.DisplayName}'
            executing");
    }
    public void OnActionExecuted(
        ActionExecutedContext context)
    {
        _logger.LogInformation(
          $"Action '{context.ActionDescriptor.DisplayName}'
            executed");
    }
}</pre>
			<p>This logs an informational message out to the console. You can get more information about the current <a id="_idIndexMarker212"/>action out of <code>ActionExecutingContext</code> or <code>ActionExecutedContext</code>—for example, the arguments, the argument values, and so on. This makes action filters pretty useful.</p>
			<p>Let's see how action filters work in practi<a id="_idTextAnchor211"/><a id="_idTextAnchor212"/>ce.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor213"/>Using ActionFilter</h1>
			<p>Action filters that are <a id="_idIndexMarker213"/>actually attributes can be registered as an attribute of an Action or a Controller, as illustrated in the following code snippet:</p>
			<pre>[HttpPost]
[ValidateModel] // ActionFilter as attribute
public ActionResult&lt;Person&gt; Post([FromBody] Person model)
{
    // save the person
    return model; //just to test the action
}</pre>
			<p>Here, we use <code>ValidateModel</code> attribute that checks the <code>ModelState</code> and returns <code>BadRequestObjectResult</code> in case the <code>ModelState</code> is invalid; we don't need to check the <code>ModelState</code> in the actual Action.</p>
			<p>To register action filters globally, you need to extend the MVC registration in the <code>ConfigureServices</code> method of the <code>Startup.cs</code> file, as follows:</p>
			<pre>builder.Services.AddControllersWithViews()
    .AddMvcOptions(options =&gt;
    {
        options.Filters.Add(new SampleActionFilter());
        options.Filters.Add(new SampleAsyncActionFilter());
    });</pre>
			<p>Action filters <a id="_idIndexMarker214"/>registered like this will be executed on every action. This way, you are able to use action filters that don't derive from an attribute.</p>
			<p>The <code>LoggingActionFilter</code> we created previously is a little more special. It is dependent on <a id="_idIndexMarker215"/>an instance of <code>ILoggerFactory</code>, which needs to be passed <a id="_idIndexMarker216"/>into the constructor. This won't work well as an attribute, because <code>Attributes</code> don't support <code>ILoggerFactory</code> is registered in the ASP.NET Core DI container and needs to be injected into <code>LoggingActionFilter</code>.</p>
			<p>Because of this, there are some more ways to register action filters. Globally, we are able to register them as a type that gets instantiated by the DI container, and the dependencies can be solved by the container, as illustrated in the following code snippet:</p>
			<pre>builder.Services.AddControllersWithViews()
    .AddMvcOptions(options =&gt;
    {
        options.Filters.Add&lt;LoggingActionFilter&gt;();
    })</pre>
			<p>This works well. We now have <code>ILoggerFactory</code> in the filter.</p>
			<p>To support automatic resolution in <code>Attributes</code>, you need to use the <code>ServiceFilter</code> attribute on the Controller or Action level, as illustrated here:</p>
			<pre>[ServiceFilter(typeof(LoggingActionFilter))]
public class HomeController : Controller
{</pre>
			<p>In addition to the global filter registration, <code>ActionFilter</code> needs to be registered in <code>ServiceCollection</code> before we can use it with <code>ServiceFilter</code> attribute, as follows:</p>
			<pre>builder.Services.AddSingleton&lt;LoggingActionFilter&gt;();</pre>
			<p>To be complete, there is another way to use action filters that needs arguments passed into the constructor. You can <a id="_idIndexMarker217"/>use the <code>TypeFilter</code> attribute to automatically instantiate the filter. But using this attribute, the filter <em class="italic">isn't</em> instantiated by the DI container; the arguments need to be specified as arguments of the <code>TypeFilter</code> attribute. </p>
			<p>See the next snippet from the official documentation:</p>
			<pre>[TypeFilter(typeof(AddHeaderAttribute),
    Arguments = new object[] { "Author", "Juergen Gutsch 
      (@sharpcms)" })]
public IActionResult Hi(string name)
{
    return Content($"Hi {name}");
}</pre>
			<p>The type of the filter and the arguments are specified with the <code>TypeFilter</code> at<a id="_idTextAnchor214"/>tribute.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor215"/>Summary</h1>
			<p>Action filters give us an easy way to keep actions clean. If we find repeating tasks inside our Actions that are not really relevant to the actual responsibility of the Action, we can move those tasks out to an <code>ActionFilter</code>, or maybe a <code>ModelBinder</code> or some MiddleWare, depending on how it needs to work globally. The more relevant it is to an Action, the more appropriate it is to use an <code>ActionFilter</code>.</p>
			<p>There are more kinds of filters, all of which work in a similar fashion. To learn more about the different kinds of filters, reading the documentation is definitely recommended.</p>
			<p>In the next chapter, we speed up your web application by using<a id="_idTextAnchor216"/> caches.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor217"/>Further reading</h1>
			<ul>
				<li>Microsoft ASP.NET Core filters: <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters">https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters</a> </li>
			</ul>
		</div>
	</body></html>