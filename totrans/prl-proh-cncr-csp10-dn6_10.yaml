- en: '*Chapter 8*: Parallel Data Structures and Parallel LINQ'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 8 章*：并行数据结构和并行 LINQ'
- en: .NET provides many useful features and data constructs for developers who are
    introducing parallelism to their projects. This chapter will explore these features,
    including `SpinLock<T>` **synchronization primitive**, and **Parallel LINQ** (**PLINQ**).
    These features can improve the performance of your applications while maintaining
    safe threading practices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 为将并行性引入其项目的开发者提供了许多有用的功能和数据结构。本章将探讨这些功能，包括 `SpinLock<T>` **同步原语**和**并行
    LINQ**（**PLINQ**）。这些功能可以在保持安全线程实践的同时提高应用程序的性能。
- en: Most .NET developers are familiar with LINQ frameworks, including LINQ to Objects,
    LINQ to SQL, and LINQ to XML. There are even open source .NET LINQ libraries,
    such as LINQ to Twitter ([https://github.com/JoeMayo/LinqToTwitter](https://github.com/JoeMayo/LinqToTwitter)).
    We will take those LINQ skills and leverage them in parallel programming with
    PLINQ. Every LINQ developer can be a PLINQ developer after reading this chapter.
    Read ahead for some useful examples of working with PLINQ in C#.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 .NET 开发者熟悉 LINQ 框架，包括 LINQ to Objects、LINQ to SQL 和 LINQ to XML。甚至还有开源的
    .NET LINQ 库，例如 LINQ to Twitter ([https://github.com/JoeMayo/LinqToTwitter](https://github.com/JoeMayo/LinqToTwitter))。我们将利用这些
    LINQ 技巧，在 PLINQ 的并行编程中发挥其作用。阅读本章后，每个 LINQ 开发者都可以成为 PLINQ 开发者。继续阅读以获取一些使用 C# 操作
    PLINQ 的有用示例。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Introducing PLINQ
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 PLINQ
- en: Converting LINQ queries to PLINQ
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 LINQ 查询转换为 PLINQ
- en: Preserving data order and merging data with PLINQ
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PLINQ 保留数据顺序和合并数据
- en: Data structures for parallel programming in .NET
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 中用于并行编程的数据结构
- en: By the end of this chapter, you will have a new appreciation for LINQ when it
    comes to parallel programming.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对 LINQ 在并行编程方面的应用有新的认识。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows developers:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章中的示例，以下软件是 Windows 开发者推荐的：
- en: Visual Studio 2022 version 17.0 or later.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 版本 17.0 或更高版本。
- en: .NET 6.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6.
- en: To complete the WPF sample, you will need to install the .NET desktop development
    workload for Visual Studio.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要完成 WPF 示例，您需要为 Visual Studio 安装 .NET 桌面开发工作负载。
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later,
    JetBrains Rider, or Visual Studio Code will work just as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是推荐的，但如果您已安装 .NET 6，您可以使用您喜欢的编辑器。例如，macOS 10.13 或更高版本的 Visual Studio 2022
    for Mac、JetBrains Rider 或 Visual Studio Code 都可以正常工作。
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到：[https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08)。
- en: Let’s get started by discussing LINQ, PLINQ, and why the query language can
    be a great way to improve your parallel programming with C#.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论 LINQ、PLINQ 以及为什么查询语言可以成为改进 C# 并行编程的绝佳方式开始。
- en: Introducing PLINQ
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 PLINQ
- en: PLINQ is a set of .NET extensions for LINQ that allow part of the LINQ query
    to execute in parallel by leveraging the thread pool. The PLINQ implementation
    provides parallel versions of all of the available LINQ query operations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ 是一组 .NET 扩展，用于 LINQ，它允许部分 LINQ 查询通过利用线程池并行执行。PLINQ 实现提供了所有可用的 LINQ 查询操作并行版本。
- en: 'Like LINQ queries, PLINQ queries offer deferred execution. This means that
    the objects are not queried until they need to be enumerated. If you aren’t familiar
    with LINQ’s deferred execution, we will look at a simple example to illustrate
    the concept. Consider these two LINQ queries:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与 LINQ 查询类似，PLINQ 查询提供延迟执行。这意味着对象只有在需要枚举时才会被查询。如果您不熟悉 LINQ 的延迟执行，我们将通过一个简单的示例来阐述这个概念。考虑以下两个
    LINQ 查询：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the example, the LINQ query that populates `citiesWithS` is executed immediately
    because of the call to `ToList()`. The second query that populates `citiesWithT`
    is not immediately executed. The execution is deferred until the `IEnumerable`
    values are required. The `citiesWithT` values are not required until we iterate
    over them in the `foreach` loop. The same principle holds true for PLINQ queries.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，由于调用了`ToList()`，填充`citiesWithS`的LINQ查询立即执行。而填充`citiesWithT`的第二个查询并没有立即执行。执行被延迟，直到需要`IEnumerable`值。`citiesWithT`的值在我们遍历`foreach`循环时才需要。这个原则同样适用于PLINQ查询。
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are unfamiliar with LINQ concepts or the LINQ method syntax, the book
    *C# 10 and .NET 6 – Modern Cross-Platform Development – Sixth Edition* by *Mark
    J. Price* has a chapter dedicated to explaining LINQ syntax and several of its
    implementations. It is an excellent book for every .NET developer. You can find
    out more about the book here: [https://subscription.packtpub.com/product/mobile/9781801077361](https://subscription.packtpub.com/product/mobile/9781801077361).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对LINQ概念或LINQ方法语法不熟悉，由*马克·J·普赖斯*所著的《C# 10和.NET 6 – 现代跨平台开发 – 第六版》一书有一个章节专门用于解释LINQ语法及其几种实现方式。这是一本非常适合.NET开发者的优秀书籍。你可以在以下链接中了解更多关于这本书的信息：[https://subscription.packtpub.com/product/mobile/9781801077361](https://subscription.packtpub.com/product/mobile/9781801077361)。
- en: PLINQ is similar to LINQ in other ways, too. You can create PLINQ queries on
    any collection that implements `IEnumerable` or `IEnumerable<T>`. You can use
    all of the familiar LINQ operations such as `Where`, `FirstOrDefault`, `Select`,
    and so on. The primary difference is that PLINQ attempts to leverage the power
    of parallel programming by part or all of a query across multiple threads. Internally,
    PLINQ partitions the in-memory data into multiple segments and performs the query
    on each segment in parallel.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ在其他方面也与LINQ相似。你可以在实现`IEnumerable`或`IEnumerable<T>`的任何集合上创建PLINQ查询。你可以使用所有熟悉的LINQ操作，如`Where`、`FirstOrDefault`、`Select`等。主要区别在于PLINQ试图通过跨多个线程的部分或全部查询来利用并行编程的力量。内部，PLINQ将内存中的数据分割成多个段，并在每个段上并行执行查询。
- en: There are several factors that impact the performance gained by using PLINQ.
    Let’s explore those next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PLINQ获得性能提升受多种因素影响。让我们接下来探讨这些因素。
- en: PLINQ and performance
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PLINQ与性能
- en: When deciding which LINQ queries are good candidates to leverage the power of
    PLINQ, you must consider a number of factors. The primary factor to consider is
    whether the magnitude or complexity of the work to be performed is great enough
    to offset the overhead of threading. You should be operating on a large dataset
    and be performing an expensive operation on each item in the collection. The LINQ
    example that checked the first letter of a string is not a very good candidate
    for PLINQ, especially if the source collection only contains a handful of items.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定哪些LINQ查询适合利用PLINQ的力量时，你必须考虑许多因素。主要考虑的因素是执行的工作量的大小或复杂性是否足够大，以抵消线程的开销。你应该在大型数据集上操作，并对集合中的每个项目执行昂贵的操作。检查字符串第一个字母的LINQ示例并不是PLINQ的良好候选，尤其是如果源集合只包含少量项目。
- en: Another factor in the performance to potentially be gained with PLINQ is the
    number of cores available on the system where the queries will be running. The
    greater the number of cores that PLINQ can leverage, the better the potential
    gain. PLINQ can break down a large dataset into more units of work to be executed
    in parallel with many cores at its disposal.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ可能带来的性能提升的另一个因素是查询将在其上运行的系统上可用的核心数量。PLINQ可以利用的核心越多，潜在的提升就越好。PLINQ可以将大型数据集分解成更多的工作单元，以便在多个核心上并行执行。
- en: Ordering and grouping data can incur a larger amount of overhead than it would
    in a traditional LINQ query. The PLINQ data is segmented, but grouping and ordering
    must be performed across the entire collection. PLINQ is best suited for queries
    where the data sequence is not important.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据进行排序和分组可能比在传统的LINQ查询中产生更大的开销。PLINQ数据是分段的，但分组和排序必须在整个集合上执行。PLINQ最适合于数据序列不重要的情况。
- en: We will discuss some other factors that impact query performance in the *Preserving
    data order and merging data with PLINQ* section. Now, let’s start creating our
    first PLINQ queries.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“使用PLINQ保留数据顺序和合并数据”部分讨论影响查询性能的其他因素。现在，让我们开始创建我们的第一个PLINQ查询。
- en: Creating a PLINQ query
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建PLINQ查询
- en: The majority of the functionality of PLINQ is exposed through members of the
    `System.Linq.ParallelEnumerable` class. This class contains implementations of
    all of the LINQ operators that are available to in-memory object queries. There
    are some additional operators in this class that are specific to PLINQ queries.
    The two most important operators to understand are `AsParallel` and `AsSequential`.
    The `AsParallel` operator indicates that all subsequent LINQ operations should
    be attempted to be performed in parallel. In contrast, the `AsSequential` operator
    indicates to PLINQ that the LINQ operations that follow it should be performed
    in sequence.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ 的大多数功能都通过 `System.Linq.ParallelEnumerable` 类的成员公开。这个类包含所有可用于内存对象查询的 LINQ
    操作的实现。这个类中还有一些特定于 PLINQ 查询的附加操作。理解最重要的两个操作是 `AsParallel` 和 `AsSequential`。`AsParallel`
    操作指示所有后续的 LINQ 操作都应尝试并行执行。相比之下，`AsSequential` 操作指示 PLINQ，随后的 LINQ 操作应以顺序执行。
- en: 'Let’s look at an example that uses both of these PLINQ operators. Our query
    will be operating on `List<Person>` with the following definition:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用这两个 PLINQ 操作的示例。我们的查询将在以下定义的 `List<Person>` 上操作：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s consider that we are working with a dataset of thousands or even millions
    of people. We want to leverage PLINQ to query only the adults aged 18 or older
    from the data and then group them by their last name. We want to execute only
    the `Where` clause of the query in parallel. The `GroupBy` operation will be performed
    sequentially. This method will do exactly that:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们正在处理包含数千甚至数百万人的数据集。我们希望利用 PLINQ 仅从数据中查询年龄为 18 岁或以上的成年人，并按他们的姓氏对他们进行分组。我们只想并行执行查询的
    `Where` 子句。`GroupBy` 操作将按顺序执行。这种方法将正好做到这一点：
- en: '[PRE20]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `GroupBy` LINQ method will return `IEnumerable<IGrouping<string, Person>>`
    with each `IGrouping<string, Person>` instance containing all of the people with
    the same `LastName`. Whether or not this `GroupBy` operation would be faster to
    run in parallel or sequentially depends on the makeup of the data. You should
    always test your application to determine whether introducing parallelism is improving
    the performance when working with production data. We will cover ways to performance-test
    your code in [*Chapter 10*](B18552_10_ePub.xhtml#_idTextAnchor158).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupBy` LINQ 方法将返回 `IEnumerable<IGrouping<string, Person>>`，其中每个 `IGrouping<string,
    Person>` 实例都包含具有相同 `LastName` 的所有人。是否将此 `GroupBy` 操作并行运行或顺序运行更快取决于数据的组成。你应该始终测试你的应用程序，以确定在处理生产数据时引入并行化是否提高了性能。我们将在
    [*第 10 章*](B18552_10_ePub.xhtml#_idTextAnchor158) 中介绍测试代码性能的方法。'
- en: Next, let’s look at how PLINQ queries can be written with the **method syntax**
    that we have used thus far or by using LINQ **query syntax**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用我们迄今为止使用的 **方法语法** 或通过使用 LINQ **查询语法** 来编写 PLINQ 查询。
- en: Query syntax versus method syntax
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询语法与方法语法
- en: LINQ queries can be coded either by using method syntax or query syntax. Method
    syntax is where you string multiple methods together to build a query. This is
    what we have been doing throughout this section. Query syntax is slightly different,
    and it is akin to T-SQL query syntax. Let’s examine the same PLINQ query written
    both ways.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 查询可以通过使用方法语法或查询语法进行编码。方法语法是将多个方法串联起来构建查询的地方。这是我们一直在本节中做的事情。查询语法略有不同，类似于
    T-SQL 查询语法。让我们检查以两种方式编写的相同的 PLINQ 查询。
- en: 'Here is a simple PLINQ query to return only adults from a list of people written
    with method syntax:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的 PLINQ 查询，使用方法语法从人员列表中返回仅包含成年人的查询：
- en: '[PRE37]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here is the exact same PLINQ query written with query syntax:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用查询语法编写的完全相同的 PLINQ 查询：
- en: '[PRE38]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You should use whichever syntax you prefer. Throughout the rest of this chapter,
    we will be using method syntax for the examples.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用你喜欢的任何一种语法。在本章的其余部分，我们将使用方法语法进行示例。
- en: In the next section, we will continue to explore the operations available in
    PLINQ and create some parallel versions of LINQ queries.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续探讨 PLINQ 中可用的操作，并创建一些 LINQ 查询的并行版本。
- en: Converting LINQ queries to PLINQ
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 LINQ 查询转换为 PLINQ
- en: In this section, we will look at some additional PLINQ operators and show you
    how you can leverage them to turn existing LINQ queries into PLINQ queries. Your
    existing queries may have requirements for preserving the order of data. Perhaps
    your existing code doesn’t use LINQ at all. There could be an opportunity there
    to convert some logic in `foreach` loops into PLINQ operations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些额外的 PLINQ 操作符，并展示你如何利用它们将现有的 LINQ 查询转换为 PLINQ 查询。你的现有查询可能需要保留数据顺序。也许你的现有代码根本不使用
    LINQ。那里可能有机会将 `foreach` 循环中的某些逻辑转换为 PLINQ 操作。
- en: The way to convert a LINQ query to a PLINQ query is by inserting an `AsParallel()`
    statement into the query, as we did in the previous section. Everything that follows
    `AsParallel()` will run in parallel until an `AsSequential()` statement is encountered.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将 LINQ 查询转换为 PLINQ 查询的方法是在查询中插入一个 `AsParallel()` 语句，就像我们在前一个部分中所做的那样。在 `AsParallel()`
    之后的所有内容都将并行运行，直到遇到一个 `AsSequential()` 语句。
- en: 'If your queries require that the original order of objects be preserved, you
    can include an `AsOrdered()` statement:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的查询需要保留对象的原始顺序，你可以包含一个 `AsOrdered()` 语句：
- en: '[PRE41]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'However, this will not be as performant as queries that do not preserve the
    sequence of data. To explicitly tell PLINQ to not preserve data order, use the
    `AsUnordered()` statement:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不会像不保留数据顺序的查询那样高效。要明确告诉 PLINQ 不保留数据顺序，请使用 `AsUnordered()` 语句：
- en: '[PRE43]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The unordered version of the query will perform much better if the order of
    your data is not important; you should never use `AsOrdered()` with PLINQ.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据顺序不重要，无序版本的查询将表现得更好；你永远不应该与 PLINQ 一起使用 `AsOrdered()`。
- en: 'Let’s consider another example. We will start with a method that iterates over
    a list of people with a `foreach` loop and calls a method named `ProcessVoterActions`
    for each person aged 18 or older. We’re going to assume that this method is processor-intensive
    and also uses some I/O to save the voter information in a database. Here is the
    starting code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子。我们将从一个使用 `foreach` 循环遍历人员列表的方法开始，并为每个18岁或以上的人调用名为 `ProcessVoterActions`
    的方法。我们假设这个方法计算密集型，并且还需要一些I/O操作来将选民信息保存到数据库中。以下是起始代码：
- en: '[PRE45]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This will not leverage parallel processing at all. We could improve on this
    by using LINQ to filter out the children under 18 and then call `ProcessVoterActions`
    with a `Parallel.ForEach` loop:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根本不会利用并行处理。我们可以通过使用 LINQ 过滤出18岁以下的儿童，然后使用 `Parallel.ForEach` 循环调用 `ProcessVoterActions`
    来改进这一点：
- en: '[PRE58]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This will certainly improve the performance if `ProcessVoterActions` takes
    some time to run for each person. However, with PLINQ, we can improve the performance
    even further:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `ProcessVoterActions` 对每个人运行需要一些时间，这将肯定能提高性能。然而，使用 PLINQ，我们甚至可以进一步提高性能：
- en: '[PRE64]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, the `Where` query will run in parallel. This will certainly help performance
    if we expect to have thousands or millions of objects in the `people` collection.
    The `ForAll` extension method is another PLINQ operation that runs in parallel.
    It is meant to be used to perform an operation in parallel on each object in the
    query results.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Where` 查询将在并行中运行。如果我们预计 `people` 集合中有成千上万或数百万个对象，这将肯定有助于性能。`ForAll` 扩展方法是另一个并行运行的
    PLINQ 操作。它旨在用于在查询结果的每个对象上并行执行操作。
- en: 'The performance of `ForAll` will also be superior to the `Parallel.ForEach`
    operation in the previous example. One difference is the deferred execution of
    PLINQ. These calls to `ProcessVoterActions` will not be performed until the `IEnumerable`
    result is iterated over. The other advantage is the same advantage over performing
    a standard `foreach` loop with `IEnumerable` after completing a PLINQ query on
    your data. The data must be merged back from the multiple threads before it can
    be enumerated by either `foreach` or `Parallel.ForEach`. With a `ForAll` operation,
    the data can remain segmented by PLINQ and merged once at the end. This diagram
    illustrates the difference between `Parallel.ForEach` and `ForAll`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForAll` 的性能也将优于前一个例子中的 `Parallel.ForEach` 操作。一个区别是 PLINQ 的延迟执行。这些对 `ProcessVoterActions`
    的调用将不会执行，直到迭代 `IEnumerable` 结果。另一个优势是，在完成对数据的 PLINQ 查询后，与使用 `IEnumerable` 执行标准
    `foreach` 循环相比，数据必须从多个线程合并回来才能被 `foreach` 或 `Parallel.ForEach` 枚举。使用 `ForAll`
    操作，数据可以由 PLINQ 分段，并在最后合并一次。此图说明了 `Parallel.ForEach` 和 `ForAll` 之间的区别：'
- en: '![Figure 8.1 – Advantages of PLINQ, data segmentation, and ForAll ](img/Figure_8.1_B18552.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – PLINQ、数据分段和ForAll的优势](img/Figure_8.1_B18552.jpg)'
- en: Figure 8.1 – Advantages of PLINQ, data segmentation, and ForAll
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – PLINQ 的优势、数据分段和 ForAll
- en: Before we explore more details about data order and merging data, let’s discuss
    how to handle exceptions when working with PLINQ.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨更多关于数据顺序和合并数据细节之前，让我们讨论一下在处理 PLINQ 时如何处理异常。
- en: Handling exceptions with PLINQ queries
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PLINQ 查询处理异常
- en: Implementing good exception handling in your .NET projects is important. It’s
    one of the fundamental practices of software development. When working with parallel
    programming in general, exception handling can be more complicated. This is also
    true with PLINQ. When any exception is unhandled within a parallel operation inside
    a PLINQ query, the query will throw an exception of type `AggregateException`.
    So, at the very minimum, all of your PLINQ queries should run within a `try`/`catch`
    block that catches the `AggregateException` exception type.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 .NET 项目中实现良好的异常处理非常重要。这是软件开发的基本实践之一。在一般并行编程中，异常处理可能会更复杂。这对于 PLINQ 也是如此。当
    PLINQ 查询内部的并行操作中发生任何未处理的异常时，查询将抛出一个类型为 `AggregateException` 的异常。因此，至少你的所有 PLINQ
    查询都应该在一个捕获 `AggregateException` 异常类型的 `try`/`catch` 块中运行。
- en: 'Let’s take our PLINQ `ForAll` example with `ProcessVoterActions` and add some
    exception handling:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些异常处理到带有 `ProcessVoterActions` 的 PLINQ `ForAll` 示例中：
- en: 'We’re going to run this example in a .NET console application, so create a
    new project in Visual Studio and add a class named `Person`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在一个 .NET 控制台应用程序中运行这个示例，所以请在 Visual Studio 中创建一个新的项目并添加一个名为 `Person` 的类：
- en: '[PRE70]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Next, add a new class named `PlinqExceptionsExample`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为 `PlinqExceptionsExample` 的新类。
- en: Now add a private method to `PlinqExceptionsExample` named `ProcessVoterActions`.
    We’re going to throw `ArgumentException` for any person older than `120:`
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向 `PlinqExceptionsExample` 添加一个名为 `ProcessVoterActions` 的私有方法。我们将为任何年龄超过 `120:`
    的人抛出 `ArgumentException`。
- en: '[PRE71]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, add the `ProcessAdultsWhoVoteWithPlinq` method:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加 `ProcessAdultsWhoVoteWithPlinq` 方法：
- en: '[PRE72]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This method’s logic remains the same. It’s filtering out the children with a
    PLINQ `Where` clause and calling `ProcessVoterActions` as a delegate to `ForAll`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的逻辑保持不变。它使用 PLINQ 的 `Where` 子句过滤出儿童，并将 `ProcessVoterActions` 作为 `ForAll`
    的委托调用。
- en: Note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are following along with the sample code on GitHub for this chapter ([https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08/LINQandPLINQsnippets](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08/LINQandPLINQsnippets)),
    you will need to uncomment the lines of code in *Step 5*. You should also comment
    out the lines in the `Main` method that follow those lines to prevent other samples
    from executing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随 GitHub 上本章的示例代码（[https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08/LINQandPLINQsnippets](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter08/LINQandPLINQsnippets)），你需要取消注释
    *步骤 5* 中的代码行。你还应该注释掉 `Main` 方法中那些代码行后面的代码，以防止其他示例执行。
- en: 'Finally, open `Program.cs` and add some code to create an instance of `List<Person>`
    in an inline function called `GetPeople`. It can contain as many people as you
    like, but at least one of them needs to have an age greater than `120`. Call `ProcessAdultsWhoVoteWithPlinq`,
    passing the data from `GetPeople`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开 `Program.cs` 并在名为 `GetPeople` 的内联函数中添加一些代码来创建一个 `List<Person>` 实例。它可以包含任意多的人，但至少需要一个人年龄大于
    `120`。调用 `ProcessAdultsWhoVoteWithPlinq`，传递 `GetPeople` 的数据：
- en: '[PRE73]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, run the program and observe the console output. If Visual Studio breaks
    at the exception, just click **Continue**:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行程序并观察控制台输出。如果 Visual Studio 在异常处中断，只需点击 **继续**：
- en: '![Figure 8.2 – Receiving an exception in the console ](img/Figure_8.2_B18552.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 控制台中接收异常](img/Figure_8.2_B18552.jpg)'
- en: Figure 8.2 – Receiving an exception in the console
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 控制台中接收异常
- en: The problem with handling the exception from outside the PLINQ query is that
    the entire query is stopped. It isn’t able to run to completion. If you have an
    exception that shouldn’t stop the entire process, you should handle it from within
    the code inside the query and continue processing the remaining items.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 PLINQ 查询外部异常的问题在于整个查询会被停止。它无法运行到完成。如果你有一个不应该停止整个过程的异常，你应该在查询内部的代码中处理它，并继续处理剩余的项目。
- en: If you handle exceptions inside `ProcessVoterActions`, you have a chance to
    process them gracefully and continue.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能在 `ProcessVoterActions` 中处理异常，你就有机会优雅地处理它们并继续执行。
- en: Next, we are going to explore some examples of how to preserve the order of
    your data and handle different options for merging segments back together.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索一些示例，说明如何保留数据的顺序以及处理合并段的不同选项。
- en: Preserving data order and merging data with PLINQ
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留数据顺序和合并数据使用PLINQ
- en: When fine-tuning PLINQ queries for your applications, there are some extension
    methods that impact the sequencing of data that you can leverage. Preserving the
    original order of your items may be something that is required. We have touched
    on the `AsOrdered` method in this chapter, and we will experiment with it in this
    section. When PLINQ operations have been completed and items are returned as part
    of the final enumeration, the data is merged from the segments that were created
    to operate on multiple threads. The merge behavior can be controlled by setting
    `ParallelMergeOptions` with the `WithMergeOptions` extension method. We will discuss
    the behavior of the three available merge options provided.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当对应用程序中的PLINQ查询进行微调时，有一些扩展方法会影响数据的排序，你可以利用这些方法。保留项目的原始顺序可能是一个需要考虑的因素。我们在本章中提到了`AsOrdered`方法，我们将在本节中对其进行实验。当PLINQ操作完成后，项目作为最终枚举的一部分返回时，数据将从为多线程操作而创建的段中合并。可以通过设置`ParallelMergeOptions`与`WithMergeOptions`扩展方法来控制合并行为。我们将讨论三个可用合并选项的行为。
- en: Let’s get started by creating some samples with the `AsOrdered` and `AsUnordered`
    extension methods.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用`AsOrdered`和`AsUnordered`扩展方法创建一些示例开始。
- en: PLINQ data order samples
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PLINQ数据排序示例
- en: 'In this section, we will create five methods that each accept the same set
    of data and perform the same filtering on the input data. However, the ordering
    in each PLINQ query will be handled differently. We are going to be working with
    the same `Person` class from the previous section. So, you can either work with
    the same project or create a new .NET console application project and add the
    `People` class from the previous example. Let’s get started:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建五种方法，每种方法都接受相同的数据集并对输入数据进行相同的过滤。然而，每个PLINQ查询中的排序处理将不同。我们将使用上一节中的相同`Person`类。因此，你可以使用相同的项目，或者创建一个新的.NET控制台应用程序项目，并添加上一示例中的`People`类。让我们开始吧：
- en: 'First, open the `Person` class and add a new `bool` property named `IsImportant`.
    We are going to use this to add a second data point for filtering in the PLINQ
    queries:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`Person`类并添加一个名为`IsImportant`的新`bool`属性。我们将使用这个属性在PLINQ查询中添加第二个过滤数据点：
- en: '[PRE74]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Next, add a new class to the project named `OrderSamples`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向项目中添加一个名为`OrderSamples`的新类。
- en: 'Now it’s time to start adding the queries. In this first query, we are not
    specifying `AsOrdered` or `AsUnordered`. By default, PLINQ should not be attempting
    to preserve the original order of the data. In each of these queries, we are returning
    each `Person` object with `Age` less than 18 and with `IsImportant` set to `true`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候开始添加查询了。在这个第一个查询中，我们没有指定`AsOrdered`或`AsUnordered`。默认情况下，PLINQ不应该尝试保留数据的原始顺序。在这些查询中的每一个，我们都在返回年龄小于18岁且`IsImportant`设置为`true`的每个`Person`对象：
- en: '[PRE75]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the second example, we are explicitly adding `IsUnordered` to the query
    after `AsParallel`. The behavior should be the same as the first query, with PLINQ
    not concerning itself with the original order of the items:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们在`AsParallel`之后显式添加了`IsUnordered`到查询中。行为应该与第一个查询相同，PLINQ不会关心项目的原始顺序：
- en: '[PRE76]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The third example breaks up the filters into two separate `Where` clauses;
    `IsSequential` is added after the first `Where` clause. How do you think this
    will impact the item sequence? We will find out when we run the program:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个示例将过滤器拆分为两个单独的`Where`子句；`IsSequential`在第一个`Where`子句之后添加。你认为这会如何影响项目序列？我们将在运行程序时找到答案：
- en: '[PRE77]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In the fourth example, we are using `AsParallel().AsOrdered()` to signal to
    PLINQ that we want the original order of items to be preserved:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第四个示例中，我们使用`AsParallel().AsOrdered()`来通知PLINQ我们希望保留项目的原始顺序：
- en: '[PRE78]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In the fifth and final example, we are adding a `Reverse` method after `AsOrdered`.
    This should preserve the original order of items in reverse:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第五个和最后一个示例中，我们在`AsOrdered`之后添加了一个`Reverse`方法。这应该会以相反的顺序保留项目的原始顺序：
- en: '[PRE79]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, open `Program.cs` and add two local functions. One will create a list
    of `Person` objects to pass to each method. The other will iterate over `List<Person>`
    to output each `FirstName` to the console:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`Program.cs`并添加两个局部函数。一个将创建一个`Person`对象列表，传递给每个方法。另一个将遍历`List<Person>`并将每个`FirstName`输出到控制台：
- en: '[PRE80]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, we will add the code to call each method. The timestamp, including
    milliseconds, is being output to the console before each method call and again
    at the end. You can run the application multiple times to inspect the performance
    of each method call. Try running it on PCs with more or fewer cores and different-sized
    datasets to see how that impacts the output:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加调用每个方法的代码。在每次方法调用之前和之后，都会将包括毫秒在内的时间戳输出到控制台。您可以多次运行应用程序以检查每个方法调用的性能。尝试在具有更多或更少核心的PC上运行它，以及在不同大小的数据集上运行，以查看这对输出有何影响：
- en: '[PRE81]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, run the program and examine the output:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行程序并检查输出：
- en: '![Figure 8.3 – Comparing the order of items from five PLINQ queries ](img/Figure_8.3_B18552.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 比较五个PLINQ查询的项目顺序](img/Figure_8.3_B18552.jpg)'
- en: Figure 8.3 – Comparing the order of items from five PLINQ queries
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 比较五个PLINQ查询的项目顺序
- en: You can see from the output that the order of items is only predictable in the
    last two examples where we have specified `AsOrdered()` and `AsOrdered().Reverse()`.
    The impact of the different PLINQ operations is difficult to measure on such a
    small dataset. If you run this several times, you are likely to see different
    results in the timing. Try adding larger datasets on your own to experiment with
    the performance.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从输出中看到，只有在指定了`AsOrdered()`和`AsOrdered().Reverse()`的最后两个示例中，项目的顺序才是可预测的。在如此小的数据集上，不同PLINQ操作的影响很难衡量。如果您多次运行此程序，您可能会在时间上看到不同的结果。尝试添加更大的数据集以进行性能实验。
- en: Next, let’s discuss merging segments and test the different options in a sample.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论合并段并测试样本中的不同选项。
- en: Using WithMergeOptions in PLINQ queries
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在PLINQ查询中使用WithMergeOptions
- en: When we discuss merging data in PLINQ, it is the merge that happens as each
    segment of an operation completes its actions, and the results are merged back
    into the result on the calling thread. Most of the time, you will not need to
    specify any merge options. For times when you may need to do so, it’s important
    to understand the behavior of each of the options. Let’s review each of the members
    of the `ParallelMergeOptions` enumeration.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在PLINQ中讨论合并数据时，是指每个操作段完成其操作后发生的合并，并将结果合并回调用线程的结果。大多数时候，您不需要指定任何合并选项。在您可能需要这样做的时候，了解每个选项的行为非常重要。让我们回顾一下`ParallelMergeOptions`枚举的每个成员。
- en: ParallelMergeOptions.NotBuffered
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ParallelMergeOptions.NotBuffered
- en: Think of the `NotBuffered` option as streaming data. Each item is returned from
    the query immediately after it has finished processing. There are some PLINQ operations
    that cannot support this option and will ignore it. For instance, the `OrderBy`
    and `OrderByDescending` operations cannot return items until the sorting has completed
    on the merged data. These are always `FullyBuffered`. However, queries that use
    `AsOrdered` can use this option. Use this option if your application needs to
    consume items in a streaming manner.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将`NotBuffered`选项视为流式数据。每个项目在完成处理后会立即从查询中返回。有一些PLINQ操作不支持此选项，并将忽略它。例如，`OrderBy`和`OrderByDescending`操作必须在合并数据上完成排序后才能返回项目。这些总是`FullyBuffered`。然而，使用`AsOrdered`的查询可以使用此选项。如果您的应用程序需要以流式方式消费项目，请使用此选项。
- en: ParallelMergeOptions.AutoBuffered
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ParallelMergeOptions.AutoBuffered
- en: The `AutoBuffered` option returns sets of items as they are collected. The size
    of the item set and how frequently it is returned to clear the buffer are not
    configurable or known to your code. If you want to make your data available in
    this manner, this option may suit your needs. Once again, the `OrderBy` and `OrderByDescending`
    operations will not accept this option. This is the default for most PLINQ operations
    and is the fastest overall in most scenarios. The `AutoBuffered` option allows
    PLINQ the most flexibility to buffer items as necessary based on current system
    conditions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoBuffered`选项以收集到的项目集的形式返回项目。项目集的大小以及它返回以清除缓冲区的时间间隔是不可配置的，也不会被您的代码所知道。如果您想以这种方式使数据可用，此选项可能适合您的需求。再次提醒，`OrderBy`和`OrderByDescending`操作不接受此选项。这是大多数PLINQ操作默认的选项，并且在大多数情况下是最快的。`AutoBuffered`选项允许PLINQ根据当前系统条件灵活地根据需要缓冲项目。'
- en: ParallelMergeOptions.FullyBuffered
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ParallelMergeOptions.FullyBuffered
- en: The `FullyBuffered` option will not make any results available until they have
    all been processed and buffered by the query. The option will take the longest
    to make the first item available, but many times, it is the fastest to provide
    the entire dataset.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`FullyBuffered`选项不会在所有结果都被查询处理和缓冲之前提供任何结果。该选项将花费最长时间来提供第一个项目，但很多时候，它提供整个数据集的速度最快。'
- en: ParallelMergeOptions.Default
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ParallelMergeOptions.Default
- en: There is also the `ParallelMergeOptions.Default` value, which will act the same
    as not calling `WithMergeOptions` at all. You should choose your merge option
    based on how the data needs to be consumed. If you have no strict requirements,
    it is usually best to not set merge options.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`ParallelMergeOptions.Default`值，它将表现得与根本未调用`WithMergeOptions`一样。你应该根据数据需要如何被消费来选择合并选项。如果你没有严格的要求，通常最好不设置合并选项。
- en: WithMergeOptions in action
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WithMergeOptions的实际应用
- en: 'Let’s create examples of using the same `Person` query with each merge option
    and with no merge options set at all:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建使用每个合并选项以及没有任何合并选项设置的`Person`查询的示例：
- en: 'Start by adding a `MergeSamples` class to the console application project you
    previously created. First, add the following three methods to test the types of
    merges:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，向之前创建的控制台应用程序项目中添加一个`MergeSamples`类。首先，添加以下三个方法来测试合并的类型：
- en: '[PRE82]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Next, add the following two methods to the `MergeSamples` class:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向`MergeSamples`类中添加以下两个方法：
- en: '[PRE83]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Each of the methods in the last two steps performs a PLINQ query that filters
    for `IsImportant` equal to `true` and `Age` less than `18`. It then performs a
    `Take(3)` operation to return only the first three items from the query.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个步骤中的每个方法都执行一个PLINQ查询，该查询筛选`IsImportant`等于`true`和`Age`小于`18`。然后执行`Take(3)`操作，只返回查询中的前三个项目。
- en: 'Add code to `Program.cs` to call each method and output the timestamp before
    each call, as well as a final timestamp at the end. This is the same process we
    used when calling the methods to test ordering in the previous section:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中添加代码以调用每个方法，并在每次调用之前输出时间戳，以及在最后输出一个最终时间戳。这与我们在上一节中调用方法以测试排序时使用的过程相同：
- en: '[PRE84]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, run the program and examine the output:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行程序并检查输出：
- en: '![Figure 8.4 – Reviewing the output of the PLINQ merge options methods ](img/Figure_8.4_B18552.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 查看PLINQ合并选项方法的输出](img/Figure_8.4_B18552.jpg)'
- en: Figure 8.4 – Reviewing the output of the PLINQ merge options methods
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 查看PLINQ合并选项方法的输出
- en: The first option with no merge option specified takes the longest to run, but
    often, the first time you run a PLINQ query, it will be slower than subsequent
    executions. The remaining queries are all very fast. You should test these queries
    on some large sets of data from your own databases and see how the timings differ
    for different PLINQ operators and different merge options. You can even take timings
    between the output of each item to see how quickly the first item is returned
    for `NotBuffered` versus `FullyBuffered`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 没有指定合并选项的第一个选项运行时间最长，但通常，第一次运行PLINQ查询会比后续执行慢。其余的查询都非常快。你应该在自己的数据库中的一些大型数据集上测试这些查询，看看不同PLINQ运算符和不同合并选项的时间差异。你甚至可以测量每个项目输出之间的时间，看看`NotBuffered`与`FullyBuffered`返回第一个项目有多快。
- en: Before we review everything that we have learned in this chapter, let’s discuss
    a few .NET objects and data structures that complement parallel programming and
    PLINQ queries.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回顾本章所学内容之前，让我们讨论一些补充并行编程和PLINQ查询的.NET对象和数据结构。
- en: Data structures for parallel programming in .NET
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET中的并行编程数据结构
- en: When working with parallel programming in .NET, and with PLINQ, you should take
    advantage of the data structures, types, and primitives that .NET provides. In
    this section, we will touch on concurrent collections and **synchronization primitives**.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中处理并行编程和PLINQ时，你应该利用.NET提供的数据结构、类型和原语。在本节中，我们将简要介绍并发集合和**同步原语**。
- en: Concurrent collections
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发集合
- en: Concurrent collections are useful when working with parallel programming. We
    will cover them in great detail in [*Chapter 9*](B18552_09_ePub.xhtml#_idTextAnchor146),
    but let’s quickly discuss how we can leverage them when working with PLINQ queries.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 并行集合在处理并行编程时非常有用。我们将在[*第9章*](B18552_09_ePub.xhtml#_idTextAnchor146)中详细讨论它们，但让我们快速讨论一下如何在处理PLINQ查询时利用它们。
- en: If you are simply selecting and sorting data with PLINQ, it is not necessary
    to incur the overhead that is added with the collections in the `System.Collections.Concurrent`
    namespace. However, if you are calling a method with `ForAll` that modifies items
    in your source data, you should use one of these current collections, such as
    `BlockingCollection<T>`, `ConcurrentBag<T>`, or `ConcurrentDictionary<TKey, TValue>`.
    They can also guard against any simultaneous `Add` or `Remove` operations on the
    collections.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是使用PLINQ选择和排序数据，那么没有必要承担`System.Collections.Concurrent`命名空间中集合增加的开销。然而，如果你调用带有`ForAll`的方法来修改源数据中的项，你应该使用这些当前集合之一，例如`BlockingCollection<T>`、`ConcurrentBag<T>`或`ConcurrentDictionary<TKey,
    TValue>`。它们还可以防止对集合的任何同时`Add`或`Remove`操作。
- en: Synchronization primitives
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步原语
- en: If you are unable to introduce concurrent collections into your existing code
    base, another option to provide concurrency and performance is synchronization
    primitives. We covered many of these types in [*Chapter 1*](B18552_01_ePub.xhtml#_idTextAnchor014).
    These types in the `System.Threading` namespace, including `Barrier`, `CountdownEvent`,
    `SemaphoreSlim`, `SpinLock`, and `SpinWait`, provide the right balance of thread
    safety and performance. Other locking mechanisms, such as `lock` and `Mutex`,
    can be more expensive to implement, causing a greater performance impact.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法将并发集合引入现有的代码库，另一种提供并发性和性能的选项是同步原语。我们在第1章中介绍了许多这些类型。这些位于`System.Threading`命名空间中的类型，包括`Barrier`、`CountdownEvent`、`SemaphoreSlim`、`SpinLock`和`SpinWait`，提供了线程安全和性能的正确平衡。其他锁定机制，如`lock`和`Mutex`，可能更昂贵，从而造成更大的性能影响。
- en: 'If we want to guard one of our PLINQ queries that uses `ForAll` with `SpinLock`,
    we can simply wrap the method in a `try`/`finally` block and use the `Enter` and
    `Exit` calls on `SpinLock`. Take this example where we were checking where a person
    had an age greater than `120`. Let’s imagine that the code also modifies the age:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用`SpinLock`来保护使用`ForAll`的PLINQ查询，我们只需将方法包裹在`try`/`finally`块中，并在`SpinLock`上使用`Enter`和`Exit`调用。让我们以我们检查一个人是否有大于`120`岁的年龄的例子为例。让我们想象代码也修改了年龄：
- en: '[PRE85]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'To read more about synchronization primitives, check out this section in Microsoft
    Docs: [https://docs.microsoft.com/dotnet/standard/threading/overview-of-synchronization-primitives](https://docs.microsoft.com/dotnet/standard/threading/overview-of-synchronization-primitives).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于同步原语的信息，请查看Microsoft Docs中的这一部分：[https://docs.microsoft.com/dotnet/standard/threading/overview-of-synchronization-primitives](https://docs.microsoft.com/dotnet/standard/threading/overview-of-synchronization-primitives).
- en: Now, let’s wrap up by reviewing what we have learned in this chapter on parallel
    programming and PLINQ.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过回顾本章关于并行编程和PLINQ的内容来结束本章。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the power of PLINQ to introduce parallel processing
    to our LINQ queries. We started by looking at how PLINQ differs from standard
    LINQ queries. Next, we explored how to introduce PLINQ into existing code by converting
    some standard LINQ queries. It is important to understand how PLINQ is impacting
    the performance of your applications, and we examined some timings in our sample
    applications. (Later, in [*Chapter 10*](B18552_10_ePub.xhtml#_idTextAnchor158),
    we will discuss some tools to test your application performance while testing
    it locally.) We covered some optimizations you can make to your queries with merge
    options and data ordering. Finally, we wrapped up by touching on some other .NET
    data structures and types to help provide type safety and performance to your
    applications.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了PLINQ的强大功能，它可以将并行处理引入我们的LINQ查询。我们首先了解了PLINQ与标准LINQ查询的不同之处。接下来，我们探讨了如何通过转换一些标准LINQ查询将PLINQ引入现有代码。了解PLINQ如何影响应用程序的性能非常重要，我们在示例应用程序中检查了一些计时。（稍后，在第10章中，我们将讨论一些在本地测试时测试应用程序性能的工具。）我们介绍了你可以通过合并选项和数据排序对查询进行的一些优化。最后，我们简要介绍了其他.NET数据结构和类型，以帮助为你的应用程序提供类型安全和性能。
- en: In the next chapter, we will explore each of the concurrent collections in the
    `System.Collections.Concurrent` namespace in depth. The concurrent collections
    are key to ensuring that your parallel and concurrent code maintains type safety
    when operating on shared data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨`System.Collections.Concurrent`命名空间中的每个并发集合。并发集合对于确保在操作共享数据时并行和并发代码保持类型安全至关重要。
- en: Questions
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which PLINQ method signals that the query should start processing in parallel?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 PLINQ 方法表示查询应开始并行处理？
- en: Which PLINQ method signals that the query should not process in parallel any
    longer?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 PLINQ 方法表示查询不应再并行处理？
- en: Which method tells PLINQ to preserve the original order of the source data?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个方法告诉 PLINQ 保留源数据的原始顺序？
- en: Which PLINQ method will execute a delegate in parallel on each item in the query?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 PLINQ 方法会在查询中的每个项目上并行执行一个委托？
- en: What performance impact does `AsOrdered()` have on a PLINQ query?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AsOrdered()` 对 PLINQ 查询的性能有何影响？'
- en: Which PLINQ operations cannot be used with `ParallelMergeOptions.NotBuffered`?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些 PLINQ 操作不能与 `ParallelMergeOptions.NotBuffered` 一起使用？
- en: Is PLINQ always faster than an equivalent LINQ query?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PLINQ 是否总是比等效的 LINQ 查询更快？
- en: Which PLINQ merge option would you select if you want results to stream back
    from the query as they become available?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想在查询结果可用时流式传输回来，你会选择哪个 PLINQ 合并选项？
