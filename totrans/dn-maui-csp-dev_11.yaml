- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Exploring Advanced Topics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索高级主题
- en: You now have the knowledge and skills of an intermediate .NET MAUI programmer.
    You’ve seen how to lay out controls and manage and manipulate those controls.
    You then learned about the MVVM design pattern. These are the fundamentals.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你拥有了中级.NET MAUI程序员的技能和知识。你看到了如何布局控件以及管理和操作这些控件。然后你学习了MVVM设计模式。这些都是基础。
- en: After that, you advanced to Shell navigation, using SQLite for data persistence
    and the all-important skill of writing unit tests with mocks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你进阶到了Shell导航，使用SQLite进行数据持久化，以及编写单元测试的至关重要的技能。
- en: 'This final chapter will take you beyond that level into the realm of expert
    .NET MAUI knowledge. In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一章将带你超越这个水平，进入专家.NET MAUI知识的领域。在本章中，我们将涵盖以下主题：
- en: Selecting data templates at runtime
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时选择数据模板
- en: Managing visual state
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理视觉状态
- en: Utilizing Community Toolkit behaviors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用社区工具包的行为
- en: Taking action with triggers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用触发器采取行动
- en: Validating forms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证表单
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/AdvancedTopics](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/AdvancedTopics).
    If you wish to follow along, be sure to use the code from the previous chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/AdvancedTopics](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/AdvancedTopics)找到。如果你希望跟随，请确保使用上一章的代码。
- en: Selecting data templates at runtime
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时选择数据模板
- en: You saw data templates in use with collection views in [*Chapter 5*](B19723_05.xhtml#_idTextAnchor092).
    Let’s revisit that code and expand upon it to allow us to modify the display of
    each object at runtime, based on the data in the object itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[*第5章*](B19723_05.xhtml#_idTextAnchor092)中看到了数据模板在集合视图中使用的情况。现在让我们重新审视那段代码，并在此基础上进行扩展，以便我们能够在运行时根据对象本身的数据修改每个对象的显示。
- en: To recap, we started with `PreferenceService`, where we mocked getting a list
    of `Preference` objects. Now, we can get that from the API, with just a little
    work. Modify `IPreferenceService` to remove `GetPreferencesMock`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们是从`PreferenceService`开始的，我们模拟了获取`Preference`对象列表的过程。现在，我们只需稍作工作就可以从API中获取它。修改`IPreferenceService`以移除`GetPreferencesMock`。
- en: 'Next, we need to significantly rework `PreferenceService` to interact with
    the client. Delete what you have and use the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要对`PreferenceService`进行重大重构以与客户端交互。删除你有的内容，并使用以下内容：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There’s nothing new here; it is directly parallel to what we saw in [*Chapter
    10*](B19723_10.xhtml#_idTextAnchor187) when obtaining the *Buddies*. Now that
    we have a collection of `Preference` objects, we can display them in a `CollectionView`,
    just as we did in [*Chapter 5*](B19723_05.xhtml#_idTextAnchor092) (as shown here
    in `PreferencesPage`, as seen in the previous chapter):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的内容；它与我们在[*第10章*](B19723_10.xhtml#_idTextAnchor187)中获取*Buddies*时看到的内容直接平行。现在我们有一个`Preference`对象的集合，我们可以像在[*第5章*](B19723_05.xhtml#_idTextAnchor092)中那样（如前一章中在`PreferencesPage`中所示）在`CollectionView`中显示它们：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the CollectionView’s `ItemTemplate` is declared *inline*, in the
    declaration of `CollectionView` itself. That is not the only way to declare an
    `ItemTemplate`, however. Let’s see how to do it another way.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`CollectionView`的`ItemTemplate`是在`CollectionView`本身的声明中声明的，但这并不是声明`ItemTemplate`的唯一方式。让我们看看另一种方法。
- en: Declaring ItemTemplates as resources
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将ItemTemplates声明为资源
- en: 'You can take `ItemTemplate` out of the definition of `CollectionView` and move
    it up into a `ResourceDictionary`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`ItemTemplate`从`CollectionView`的定义中移除，并将其移动到`ResourceDictionary`中：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s look at what we’ve done here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在这里做了什么：
- en: '`[1]`: At the top of the file, we declared a `Resources` section with a `ResourceDictionary`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[1]`：在文件顶部，我们声明了一个`Resources`部分，包含一个`ResourceDictionary`'
- en: '`[2]`: We created `DataTemplate` and gave it a key so that we can refer to
    it later'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[2]`：我们创建了`DataTemplate`并为其提供了一个键，以便我们稍后可以引用它'
- en: '`[3]`: The rest of `DataTemplate` is just as it was inside `CollectionView`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[3]`：`DataTemplate`的其余部分与在`CollectionView`内部一样'
- en: '`CollectionView` is now much simpler – it simply declares its `ItemTemplate`
    property to be our created `StaticResource`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionView`现在要简单得多——它只是声明其`ItemTemplate`属性为我们创建的`StaticResource`：'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is valuable but is hardly all that exciting except that it opens up a new
    possibility.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有价值，但除了它开辟了新的可能性之外，几乎没有什么令人兴奋的。
- en: Where to put the DataTemplate
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模板的位置
- en: Here, we show `DataTemplate` in the resources section, but you can put it in
    a different file as well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在资源部分显示了 `DataTemplate`，但你也可以将其放在不同的文件中。
- en: The DataTemplate selection
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据模板选择
- en: You can create two or more additional DataTemplates in the same `ResourceDictionary`.
    This allows you to have .NET MAUI examine each *item* as it is about to display
    it and choose among the available DataTemplates based on a condition.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在同一个 `ResourceDictionary` 中创建两个或更多额外的 DataTemplates。这允许 .NET MAUI 在即将显示每个
    *项目* 时检查它，并根据条件在可用的 DataTemplates 中进行选择。
- en: 'We know that when we get the preferences, some will have values and some will
    not. Let’s say we want to tell the user to enter a value by turning the prompt
    red when the value is empty. We can create two DataTemplates:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道当我们获取首选项时，一些会有值，一些则没有。假设我们想告诉用户输入一个值，当值为空时将提示变成红色。我们可以创建两个 DataTemplates：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s take a look at this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个：
- en: '`[1]`: The first data template'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[1]`：第一个数据模板'
- en: '`[2]`: The normal text colors'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[2]`：正常文本颜色'
- en: '`[3]`: The second data template (with its own key)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[3]`：第二个数据模板（具有自己的键）'
- en: '`[4]`: The *empty* text colors'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[4]`：*空*文本颜色'
- en: Now, the obvious question is, how does .NET MAUI know which to display? For
    that, we need a `DataTemplateSelector`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，显然的问题是，.NET MAUI 如何知道显示哪个？为了这个，我们需要一个 `DataTemplateSelector`。
- en: The DataTemplateSelector class
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DataTemplateSelector 类
- en: 'The first thing you must do is create a class that will contain the logic as
    to which template to display. I’ve named that class `PreferenceDataTemplateSelector`.
    Since I only intend to have one, I put it in the `Services` folder:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须做的第一件事是创建一个包含显示哪个模板逻辑的类。我将其命名为 `PreferenceDataTemplateSelector`。由于我只打算有一个，所以我将其放在
    `Services` 文件夹中：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You must do the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须做以下事情：
- en: '`[1]`: Your class must derive from `DataTemplateSelector`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`[1]`：你的类必须从 `DataTemplateSelector` 继承。'
- en: '`[2]`: You need a public property for each of your DataTemplates.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`[2]`：你需要为每个 DataTemplates 创建一个公共属性。'
- en: '`[3]`: Override the `OnSelectTemplate` virtual method.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`[3]`：重写 `OnSelectTemplate` 虚拟方法。'
- en: '`[4]`: Add the logic as to which template to display.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`[4]`：添加确定显示哪个模板的逻辑。'
- en: With the class in place, we need to have a corresponding resource.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类已经就位，我们需要一个相应的资源。
- en: Adding the template selector to the page’s resources
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将模板选择器添加到页面的资源中
- en: 'Return to `PreferencesPage.xaml`. In the page declaration, add `Xmlns:services="clr-namespace:ForgetMeNotDemo.Services"`.
    Then, in `ResourceDictionary`, add the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `PreferencesPage.xaml`。在页面声明中添加 `Xmlns:services="clr-namespace:ForgetMeNotDemo.Services"`。然后，在
    `ResourceDictionary` 中添加以下内容：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This provides the link to the names in the class we just created. We now have
    the logic, but how do we hook it up to `CollectionView`?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们刚刚创建的类中的名称提供了链接。我们现在有了逻辑，但如何将其连接到 `CollectionView` 呢？
- en: Adding DataTemplateSelector to CollectionView
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 DataTemplateSelector 添加到 CollectionView
- en: 'Hooking all this into `CollectionView` is as simple as setting an `ItemTemplate`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些连接到 `CollectionView` 只需设置一个 `ItemTemplate`：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And it all comes together. `CollectionView` looks to `PreferenceDataTemplateSelector`
    in the resources, which is tied to the class we created that holds the logic as
    to which `DataTemplate` to show. The result is shown in *Figure 11**.1*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都汇集在一起。`CollectionView` 在资源中查找 `PreferenceDataTemplateSelector`，它与我们所创建的包含显示哪个
    `DataTemplate` 逻辑的类相关联。结果如 *图 11**.1* 所示：
- en: '![Figure 11.1 – DataTemplate selection'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – 数据模板选择'
- en: '](img/Figure_11.1_B19723.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B19723.jpg)'
- en: Figure 11.1 – DataTemplate selection
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 数据模板选择
- en: '`DataTemplateSelector` is a very powerful way to control what is displayed
    at runtime. A similar mechanism is encapsulated in the concept of Visual State.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataTemplateSelector` 是一种非常强大的方式来控制运行时显示的内容。类似的机制封装在视觉状态的概念中。'
- en: Managing Visual State
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理视觉状态
- en: Every `VisualElement` has a *Visual State* at any given moment (for example,
    does `VisualElement` have *focus*? Is it *selected*?). You can imagine responding
    to that state programmatically in C#, but there are advantages to responding to
    changes in visual state declaratively, in the XAML. Doing so puts more of the
    UI management in one place – your view (for example, `MainPage.xaml`).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定时刻，每个 `VisualElement` 都有一个 *视觉状态*（例如，`VisualElement` 是否有 *焦点*？它是否 *选中*？）。你可以想象在
    C# 中以编程方式响应这种状态，但在 XAML 中声明性地响应视觉状态的变化有优势。这样做将更多的 UI 管理集中在一个地方——你的视图（例如，`MainPage.xaml`）。
- en: VisualElement
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: VisualElement
- en: '`VisualElement` is the base class of all controls (and pages).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`VisualElement` 是所有控件（和页面）的基类。'
- en: The object that sets visual properties on `VisualElement` based on its state
    is the `VisualStates` and displays a `VisualElement` according to the properties
    set in the XAML.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其状态在`VisualElement`上设置视觉属性的`VisualStates`对象，并根据在XAML中设置的属性显示`VisualElement`。
- en: 'This forces the question: what are visual states?'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使人们提出问题：什么是视觉状态？
- en: Defining the common visual states
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义通用视觉状态
- en: '.NET MAUI defines a set of common visual states:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI为控件定义了一套通用视觉状态：
- en: '`Normal`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`正常`'
- en: '`Disabled`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`禁用`'
- en: '`Has focus`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`有焦点`'
- en: '`Is selected`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已选择`'
- en: '`Mouse over` (for Windows and macOS)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`鼠标悬停`（适用于Windows和macOS）'
- en: .NET MAUI also allows you to define your own visual states, though that is less
    common.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI还允许你定义自己的视觉状态，尽管这不太常见。
- en: You use these visual states to set properties on `VisualElement`. For example,
    you might change the appearance of a button based on its `VisualState`. An example
    will make this much clearer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用这些视觉状态来设置`VisualElement`上的属性。例如，你可能根据按钮的`VisualState`来改变按钮的外观。一个例子将使这一点更加清晰。
- en: A button VisualState example
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按钮视觉状态示例
- en: 'When you first go to the **Login** page, you will see that the **Submit** button
    is disabled. We’d like it to be gray. Once you fill in the **Your Email** and
    **Password** fields, the button should turn light green. If you tab to the button,
    it should signify that it has the focus by turning fully green. You can do all
    this declaratively by creating visual states, as shown in *Figure 11**.2*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次访问**登录**页面时，你会看到**提交**按钮是禁用的。我们希望它显示为灰色。一旦你填写了**您的电子邮件**和**密码**字段，按钮应该变为浅绿色。如果你将光标移至按钮，它应该通过变为全绿色来表示它具有焦点。你可以通过创建视觉状态来声明性地完成所有这些，如图*图11.2*所示。2*：
- en: '![](img/1.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1.jpg)'
- en: Figure 11.2 – Visual states of buttons
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 按钮的视觉状态
- en: 'You can set the visual state on an individual button, or, as we will do here,
    you can put the visual state’s XAML into a style and apply it to all the buttons.
    Here is the complete `Style` for buttons:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为单个按钮设置视觉状态，或者，正如我们将在这里做的那样，你可以将视觉状态的XAML放入样式并应用于所有按钮。以下是按钮的完整`Style`：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we have the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有以下内容：
- en: '`[1]`: We start by declaring a normal `Style` – in this case, it’s implicit
    for every button'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[1]`：我们首先声明一个正常的`Style`——在这种情况下，它适用于每个按钮'
- en: '`[2]`: You may have one or more groups of visual states (we have one)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[2]`：你可能有一个或多个视觉状态组（我们有一个）'
- en: '`[3]`: The first group (and in this case, the only one) is `CommonStates`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[3]`：第一个组（在这种情况下，只有一个）是`CommonStates`'
- en: '`[4]`: We declare each `VisualState` in turn (here, we’re starting with `Normal`)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[4]`：我们依次声明每个`VisualState`（在这里，我们从`Normal`开始）'
- en: '`[5]`: For each state, we can declare a set of Setters'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[5]`：对于每个状态，我们可以声明一组`Setter`'
- en: '`[6]`: Our first (and in this case, only) `Setter` sets the `BackgroundColor`
    property'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[6]`：我们的第一个（在这种情况下，唯一的）`Setter`设置了`BackgroundColor`属性'
- en: We then go on to set the Setters for all the other states. Notice that we did
    not set a `Setter` for `PointerOver`, which means that, on Windows and macOS,
    if you hover the mouse over the button, there will be no change.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们继续为所有其他状态设置`Setter`。注意，我们没有为`PointerOver`设置`Setter`，这意味着在Windows和macOS上，如果你将鼠标悬停在按钮上，将不会有任何变化。
- en: .NET MAUI defines specialized visual states for controls. For example, `Button`
    adds the *Pressed* state, while `CheckBox` adds the *IsChecked* state and `CollectionViews`
    adds *Selected*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI为控件定义了专门的视觉状态。例如，`Button`添加了*按下*状态，而`CheckBox`添加了*已选中*状态，`CollectionViews`添加了*已选择*。
- en: The .NET MAUI Community Toolkit provides further help for managing the appearance
    and behavior of your app with a large collection of behaviors.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI社区工具包为管理你的应用的外观和行为提供了进一步的帮助，它包含大量行为。
- en: Utilizing Community Toolkit behaviors
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用社区工具包行为
- en: We’ve already seen one *behavior* from the *Community Toolkit* that turns an
    event into a command (`EventToCommandBehavior`), allowing us to respond to these
    events in our `ViewModel`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了来自**社区工具包**的一个将事件转换为命令的行为（`EventToCommandBehavior`），这允许我们在`ViewModel`中对这些事件做出响应。
- en: The Community Toolkit is open source
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 社区工具包是开源的
- en: The Community Toolkit is not officially part of .NET MAUI and consists of code
    supplied by (surprise!) the community – that is, developers independent of Microsoft.
    That said, the Microsoft documentation includes and increasingly integrates the
    Community Toolkit.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 社区工具包不是.NET MAUI的官方部分，它由（惊喜！）社区提供的代码组成——也就是说，独立于微软的开发者。尽管如此，微软的文档包括并越来越多地整合了社区工具包。
- en: '`CommunityToolkit` provides a suite of behaviors to handle many other common
    programming needs. Many of these behaviors assist with validating input. For example,
    the `CommunityToolkit` includes the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommunityToolkit`提供了一套处理许多其他常见编程需求的行为。其中许多行为帮助验证输入。例如，`CommunityToolkit`包括以下内容：'
- en: Character validation
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符验证
- en: Numeric validation
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字验证
- en: Required string validation
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必需的字符串验证
- en: Text validation
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本验证
- en: URI validation
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI验证
- en: 'You attach behaviors to controls. For example, let’s add a rule to the **Login**
    page stating that the username must be a valid email address. First, in the header,
    add the needed namespace:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你将行为附加到控件上。例如，让我们为**登录**页面添加一条规则，说明用户名必须是一个有效的电子邮件地址。首先，在头文件中添加所需的命名空间：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You are then ready to test for a valid email using the Community Toolkit behavior:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你就可以使用Community Toolkit行为来测试有效的电子邮件：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Do the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: '`[1]`: Begin the `Behaviors` section of the `Entry` tag.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`[1]`: 开始`Entry`标签的`Behaviors`部分。'
- en: '`[2]`: Choose which behavior you want (in this case, email validation).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`[2]`: 选择你想要的行为（在这种情况下，电子邮件验证）。'
- en: '`[3]`: Identify the style for an invalid email address.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`[3]`: 识别无效电子邮件地址的样式。'
- en: '`[4]`: Identify the style for a valid email address.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`[4]`: 识别有效电子邮件地址的样式。'
- en: '`[5]`: Add validation behaviors. They have flags to indicate when to do the
    validation (in this case, when the value changes), as shown in the following figure:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`[5]`: 添加验证行为。它们有标志来指示何时进行验证（在这种情况下，当值改变时），如下面的图所示：'
- en: '![Figure 11.3 – Validation flags'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.3 – 验证标志'
- en: '](img/Figure_11.3_B19723.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.3_B19723.jpg)'
- en: Figure 11.3 – Validation flags
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 验证标志
- en: There are several other non-validating behaviors as well. These include behaviors
    to assist with animating views, progress bar animation, a behavior to assist with
    customizing the color and style of your device’s status bar, and a behavior to
    trigger an action when the user stops typing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几种非验证行为。这些包括帮助动画视图、进度条动画、帮助自定义设备状态栏颜色和样式的行为，以及当用户停止输入时触发动作的行为。
- en: 'The last of these can be very helpful when allowing the user to search a large
    set of data. Rather than having the search be incremental as the user types, or
    forcing the user to tap a **Search** button, you can have the search begin when
    the user stops typing for a specified period:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个在允许用户搜索大量数据时非常有用。与其让搜索在用户输入时增量，或者强迫用户点击**搜索**按钮，不如让搜索在用户停止输入指定时间后开始：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s look at what this code does:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码做了什么：
- en: '`[1]`: When the user stops typing, call this command in your `ViewModel`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[1]`: 当用户停止输入时，在您的`ViewModel`中调用此命令。'
- en: '`[2]`: Pass this parameter (the text of `Entry`) to the command'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[2]`: 将此参数（`Entry`的文本）传递给命令。'
- en: '`[3]`: Don’t execute the command unless at least this many characters have
    been entered'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[3]`: 除非至少输入这么多字符，否则不要执行命令。'
- en: '`[4]`: When you execute the command, put away the keyboard'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[4]`: 当你执行命令时，收起键盘。'
- en: '`[5]`: Wait this long (half a second) to indicate the user has stopped typing'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[5]`: 等待这么长时间（半秒）以表示用户已经停止输入。'
- en: 'When you add this to your XAML, and the user enters `Shoe` in the entry, the
    command is fired and the parameter is sent. *Figure 11**.4* shows the parameter
    being passed into the command handler in `PreferencesPageViewModel`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此添加到你的XAML中，并且用户在输入框中输入`Shoe`时，命令被触发，并传递参数。*图11**.4*显示了参数被传递到`PreferencesPageViewModel`中的命令处理器：
- en: '![Figure 11.4 – Passing in the search string'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.4 – 传递搜索字符串'
- en: '](img/Figure_11.4_B19723.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.4_B19723.jpg)'
- en: Figure 11.4 – Passing in the search string
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 传递搜索字符串
- en: Behaviors are a way to declare how the system should perform in XAML. Another
    powerful mechanism for moving responsive actions into the XAML triggers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 行为是一种声明系统在XAML中应该如何表现的方式。另一种将响应动作移动到XAML触发器中的强大机制。
- en: Taking action with triggers
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用触发器采取行动
- en: '*Triggers* allow you to declare how a control should appear in your XAML based
    on data changes. You can also use *state triggers* to change a control’s *Visual
    State*, as shown earlier.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*触发器*允许你根据数据变化在XAML中声明控件的外观。你还可以使用*状态触发器*来改变控件的*视觉状态*，如前面所示。'
- en: 'For example, we may want to enforce that the `DataTrigger`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能想强制执行`DataTrigger`：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s look at what this code does:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码做了什么：
- en: '`[1]`: This starts the `Triggers` collection of `Button`.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[1]`: 这开始于`Button`的`Triggers`集合。'
- en: '`[2]`: This creates a `DataTrigger` and sets it to bind to the length of the
    text in the entry control whose name is `passwordEntry`. Set `TargetType` to `Button`
    (required) and the value for it to trigger on (that is, if the length of the password
    entry text is `0`, then fire the trigger).'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[2]`：这创建了一个 `DataTrigger` 并将其绑定到名为 `passwordEntry` 的输入控件中的文本长度。将 `TargetType`
    设置为 `Button`（必需）并设置触发它的值（即，如果密码输入文本的长度为 `0`，则触发触发器）。'
- en: '`[3]`: This code uses a setter to declare what happens when the trigger fires.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[3]`：此代码使用设置器来声明触发器触发时会发生什么。'
- en: In short, when the **Password** field is empty, the **Create** button should
    be disabled and as soon as it is not empty, the button should be enabled.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当 **密码** 字段为空时，**创建** 按钮应被禁用，一旦它不为空，按钮应被启用。
- en: Unexpected behavior
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 预期之外的行为
- en: 'The field you are checking (`Password`) must have its text initialized to `""`
    for this to work. Otherwise, it will be null and the trigger may not act as expected.
    To solve this, initialize the property in `ViewModel`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在检查的字段（`密码`）必须将其文本初始化为 `""` 才能正常工作。否则，它将是 null，触发器可能不会按预期工作。为了解决这个问题，在 `ViewModel`
    中初始化属性：
- en: '`[``observableproperty]`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`[``可观察属性``]`'
- en: '`public string password =` `string.Empty;`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`public string password =` `string.Empty;`'
- en: The result of this trigger is shown in *Figure 11**.5* and *Figure 11**.6*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此触发器的结果在 *图11.5* 和 *图11.6* 中显示。
- en: '![](img/2.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/2.jpg)'
- en: Figure 11.5 – Trigger when the Password field is empty
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – 当密码字段为空时的触发器
- en: 'In *Figure 11**.5*, the **Password** field is empty, while in *Figure 11**.6*,
    a character has been typed into the **Password** field:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图11.5* 中，**密码** 字段为空，而在 *图11.6* 中，已经输入了字符到 **密码** 字段：
- en: '![](img/3.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/3.jpg)'
- en: Figure 11.6 – Trigger when the Password field is not empty
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 当密码字段不为空时的触发器
- en: For fun, change `Property` from `IsEnabled` to `IsVisible`. Now, the button
    is not there when you enter the page, but will appear when you put a character
    into the **Password** field.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，将 `Property` 从 `IsEnabled` 更改为 `IsVisible`。现在，当你进入页面时，按钮不会出现，但当你将字符输入到
    **密码** 字段时，它会出现。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we reviewed four key advanced topics that allow you to manage
    the behavior of your app declaratively:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了四个关键的高级主题，这些主题允许你声明式地管理应用程序的行为：
- en: Selecting data templates allows you to change the display of your data based
    on the specific content of each element in a collection
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择数据模板允许你根据集合中每个元素的特定内容来更改数据的显示。
- en: Managing the view state allows you to modify the appearance of a control based
    on the *state* of that control (for example, does it have focus?)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理视图状态允许你根据该控件的状态（例如，它是否有焦点）来修改控件的外观。
- en: Behaviors allow, among other things, data validation and otherwise assist in
    providing actions that you declare
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为允许（包括但不限于）数据验证，并协助提供你声明的操作。
- en: Triggers change the appearance of controls based on data values in other controls
    or based on the state of other controls
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器根据其他控件中的数据值或其他控件的状态来更改控件的外观。
- en: This brings us to the end of `.Net MAUI for C# Developers`. You are now fully
    equipped to create real-world professional .NET MAUI applications.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这就标志着 `.Net MAUI for C# Developers` 的结束。你现在已经完全准备好创建真实世界的专业 .NET MAUI 应用程序了。
- en: The key to success with .NET MAUI, as with so many programming skills, is hands-on
    experience. If you are not currently working on a .NET MAUI project, you will
    want to assign one to yourself while this information is front and center in your
    mind.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多编程技能一样，成功的关键在于动手经验。如果你目前没有在 .NET MAUI 项目上工作，你将想要在信息处于你脑海中心时为自己分配一个项目。
- en: 'Here’s an application idea I’ve had for years, which you are free to write
    (and sell if you want). I’ll give it to you without restriction:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我多年来一直有的一个应用想法，你可以自由地编写（如果你愿意，还可以出售）。我将无限制地给你：
- en: Create a nice-looking application that gathers all the books on an online bookstore
    (using their public API) that you rated with five stars. Next, gather all the
    people who have also rated a large percentage of those books five stars. Exclude
    anyone who gave any of those books less than five stars. Now, take those people
    who seem to agree with you, and find any books they rated as five stars that you’ve
    not read yet. Those are books you’ll want to read.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个看起来很棒的应用程序，收集你在网上书店（使用它们的公共API）上评分为五星的所有书籍。然后，收集那些也给出了大量书籍五星评价的人。排除任何给那些书籍评分为少于五星的人。现在，找到那些似乎与你意见一致的人，并找出他们评分为五星而你尚未阅读的任何书籍。这些是你想阅读的书籍。
- en: Enjoy the project! I hope you have enjoyed this book.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 享受这个项目！我希望你喜欢这本书。
- en: Quiz
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: Why would you use the Visual State Manager?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你会使用 Visual State Manager？
- en: How does .NET MAUI decide which data template to use?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET MAUI 如何决定使用哪个数据模板？
- en: Name a behavior that is not used for validation.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名一个不用于验证的行为。
- en: When a trigger fires, how does it know what to do?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个触发器被触发时，它是如何知道该做什么的？
- en: You try it
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你试试
- en: 'Modify the **Login** page so that it does the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 **登录** 页面，使其执行以下操作：
- en: Disables the **Login** button unless the username is a valid email address and
    the password has at least one character.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当用户名是有效的电子邮件地址且密码至少有一个字符时，才禁用 **登录** 按钮。
- en: Modifies the **Forgot Password** button to double in size and turn pink when
    you tab onto it (giving it the focus), and returns to its normal size and color
    when it loses focus
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 **忘记密码** 按钮的大小，使其在获得焦点时（即按下制表符键）加倍并变为粉色，失去焦点时恢复到正常大小和颜色。
- en: Assessments
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: This section contains answers to questions from all chapters.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含所有章节的问题答案。
- en: "Chapter 1, Assembling Your Tools and Creating Your \LFirst App"
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章，组装你的工具和创建你的第一个应用程序
- en: You can create a new project from the launch dialog by choosing **Create a new
    project**. If you’ve been brought directly into Visual Studio, by clicking on
    **File** | **New Project**.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过选择 **创建一个新项目** 从启动对话框创建一个新的项目。如果你是通过点击 **文件** | **新项目** 直接进入 Visual Studio
    的，也可以这样做。
- en: Use **View** | **Solution Explorer**.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **视图** | **解决方案资源管理器**。
- en: The `.xaml` extension indicates that the file contains XAML markup.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.xaml` 扩展名表示该文件包含 XAML 标记。'
- en: The code-behind file.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码隐藏文件。
- en: '`MauiProgram.cs`.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MauiProgram.cs`。'
- en: Chapter 3, XAML and Fluent C#
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章，XAML 和 Fluent C#
- en: XAML is a markup language based on XML.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XAML 是一种基于 XML 的标记语言。
- en: XAML is used in .NET MAUI for declaring layouts and controls.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 中使用 XAML 声明布局和控件。
- en: Rather than writing in XAML, you can create your layouts and controls in C#.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是使用 XAML 编写，你可以使用 C# 创建你的布局和控件。
- en: We nest a layout or a control inside a layout by using the `Children` property.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过使用 `Children` 属性在布局内部嵌套布局或控件。
- en: An event handler is a method that is registered to an event in the UI.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件处理程序是一个注册到 UI 事件的方法。
- en: The event handler is in the code-behind.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件处理程序位于代码隐藏中。
- en: Chapter 4, MVVM and Controls
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章，MVVM 和控件
- en: MVVM has two main advantages. First, it is nearly impossible to unit test a
    .NET MAUI application if your logic is in the code-behind file – putting the logic
    in `ViewModel` is essential, as we’ll see in the upcoming chapter on unit testing.
    Second, MVVM nicely decouples the UI from your logic, allowing you to change one
    without breaking the other.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVVM 有两个主要优点。首先，如果你的逻辑在代码隐藏文件中，那么几乎不可能对 .NET MAUI 应用程序进行单元测试 – 将逻辑放在 `ViewModel`
    中是至关重要的，正如我们将在即将到来的单元测试章节中看到的。其次，MVVM 很好地将 UI 与你的逻辑解耦，允许你更改一个而不破坏另一个。
- en: The all-important `BindingContext`. You typically assign `ViewModel` as the
    binding context for `View`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最重要的 `BindingContext`。通常将 `ViewModel` 作为 `View` 的绑定上下文。
- en: The `Entry` control and the `Editor` control.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Entry` 控件和 `Editor` 控件。'
- en: The `Label` control.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Label` 控件。'
- en: '`SnackBar` is a highly configurable `Toast` – a popup that comes up from the
    bottom of the page and then can disappear either by its timer running out or by
    a user clicking on it.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SnackBar` 是一个高度可配置的 `Toast` – 一个从页面底部弹出的弹出窗口，然后可以通过计时器耗尽或用户点击它来消失。'
- en: Chapter 5, Advanced Controls
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章，高级控件
- en: '`ActivityIndicator` shows that *something* is happening, while `ProgressBar`
    tells the user what fraction of the task is complete.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ActivityIndicator` 显示有 *某事* 正在进行，而 `ProgressBar` 告诉用户任务完成的百分比。'
- en: The essential difference as far as we are concerned is that events are typically
    handled in the code-behind, while commands are handled in `ViewModel`. Handling
    commands in `ViewModel` is preferable because it makes creating unit tests easier
    or possible.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们关心的基本区别是，事件通常在代码隐藏中处理，而命令在 `ViewModel` 中处理。在 `ViewModel` 中处理命令更可取，因为它使得创建单元测试更容易或成为可能。
- en: '`WeakReferenceManager` is the primary object used in messaging, allowing `ViewModel`
    to send notifications to `View` or another `ViewModel` without a reference to
    that object, thus supporting loose coupling.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WeakReferenceManager` 是在消息传递中使用的首要对象，允许 `ViewModel` 向 `View` 或另一个 `ViewModel`
    发送通知，而不需要对该对象的引用，从而支持松耦合。'
- en: Styles allow you to create a uniform appearance across instances of controls,
    centralizing the properties and providing all the advantages of well-factored
    code.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样式允许你在控件实例之间创建统一的外观，集中属性并提供良好设计的代码的所有优势。
- en: One way to refactor styles is to create a base style and then use `BasedOn`
    to create derived types, adding or overriding properties as needed.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构样式的 一种方法 是创建一个基本样式，然后使用`BasedOn`创建派生类型，根据需要添加或覆盖属性。
- en: Chapter 6, Layout
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章，布局
- en: Stars, `auto`, and the value in dpi
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 星号，`auto`和dpi中的值
- en: Allocate 100 dpi to the last column, the needed size for the second column,
    and then divide the first and third columns proportionally as 2:1
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将100 dpi分配给最后一列，这是第二列所需的大小，然后将第一列和第三列按比例2:1进行划分
- en: The row and column offsets are defined by enumerated constants
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行和列偏移量由枚举常量定义
- en: '`Grid` allows for more precise alignment and placement of controls'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Grid`允许更精确地对控件进行对齐和定位'
- en: '`BindableLayout` does not allow you to make selections'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BindableLayout`不允许你进行选择'
- en: Chapter 7, Understanding Navigation
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章，理解导航
- en: '`AppShell.xaml`'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AppShell.xaml`'
- en: '`Title`, `ContentTemplate`, and `Icon`'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Title`，`ContentTemplate`和`Icon`'
- en: '`AppShell.xaml.cs`'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AppShell.xaml.cs`'
- en: '`Shell.Current.GoToAsync`'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Shell.Current.GoToAsync`'
- en: URL syntax or using a dictionary
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: URL语法或使用字典
- en: Chapter 8, Storing and Retrieving Data
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章，存储和检索数据
- en: '`Preferences` (not to be confused with `UserPreferences`).'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Preferences`（不要与`UserPreferences`混淆）。'
- en: The key and a default value.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键和默认值。
- en: '**SQLite-net-pcl** and possibly **SQLitePCLRaw.bundle_green**, if not included
    with **SQLite-net-pcl**.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SQLite-net-pcl**和可能**SQLitePCLRaw.bundle_green**，如果它们没有包含在**SQLite-net-pcl**中。'
- en: '`SQLiteAsyncConnection`'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SQLiteAsyncConnection`'
- en: Chapter 9, Unit Testing
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章，单元测试
- en: Unit tests are critical for ensuring the quality of your code and allow you
    to add to and change your code with the confidence of knowing that if you break
    something, you’ll find out about it right away.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试对于确保代码质量至关重要，并允许你添加和更改代码，同时有信心知道，如果你破坏了某些东西，你将立即发现。
- en: Most of the testable code in a .NET MAUI application will be in the ViewModel
    or, possibly, the services.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET MAUI应用程序中的大部分可测试代码将在ViewModel中，或者可能是服务中。
- en: When you need a slower service to test a method in your code, a mock can stand
    in for that service and give you immediate responses.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你需要一个较慢的服务来测试你的代码中的方法时，一个模拟可以代替该服务并立即给出响应。
- en: In order to provide a mock to your test, you must be able to inject it into
    the code in lieu of the runtime object.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了向你的测试提供一个模拟，你必须能够将其注入代码中，以替代运行时对象。
- en: Chapter 10, Consuming REST Services
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章，消费REST服务
- en: A DTO is responsible for holding data that will be sent to and/or from the API.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个DTO负责持有将发送到API或从API发送的数据。
- en: The database is now in the cloud and managed through the API. As the client,
    we don’t know, nor need to know, what kind of database is in use.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库现在在云中，并通过API进行管理。作为客户端，我们不知道，也不需要知道正在使用哪种数据库。
- en: It wraps all the API calls so that a client can interact with the API as if
    it were a **Plain Old CLR** **Object** (**POCO**).
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它封装了所有的API调用，以便客户端可以像与一个**普通的CLR对象**（**POCO**）交互一样与API交互。
- en: Account creation is accomplished in the cloud via the API.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户创建通过API在云中完成。
- en: Authentication is accomplished in the cloud via the API.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证通过API在云中完成。
- en: Chapter 11, Exploring Advanced Topics
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章，探索高级主题
- en: To modify the appearance of a control based on its *state*, such as whether
    or not it has the focus.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据控件的状态（例如，是否有焦点）修改控件的外观。
- en: In the XAML, add a `DataTemplateSelector` to indicate the potential templates
    and then add a class that derives from `DataTemplateSelector` that overrides `OnSelectTemplate`
    and returns `DataTemplate` to be displayed.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在XAML中，添加一个`DataTemplateSelector`来指示潜在的模板，然后添加一个继承自`DataTemplateSelector`的类，重写`OnSelectTemplate`并返回要显示的`DataTemplate`。
- en: We have seen the `EventToCommand` behavior, which allows you to add commands
    to controls that only have events, allowing you to handle the event/command in
    `ViewModel`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经看到了`EventToCommand`行为，它允许你向只有事件的控件添加命令，让你可以在`ViewModel`中处理事件/命令。
- en: You add setters with the property to change and the value to set it to.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你添加带有属性的setter来改变值，并将其设置为指定的值。
