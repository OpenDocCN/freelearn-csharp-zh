- en: WPF Fundamentals
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing WPF Workload with Visual Studio 2017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating WPF applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and navigating from one window to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and navigating from one page to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dialog box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ownership between windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a single instance application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing arguments to WPF applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling unhandled exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Windows Presentation Foundation** (**WPF**) provides developers with a
    unified programming model to build dynamic, data-driven desktop applications for
    Windows. It was first released in 2006 along with .NET 3.0\. It is part of the
    .NET Framework itself.
  prefs: []
  type: TYPE_NORMAL
- en: WPF is a graphical subsystem, for rendering rich **user interfaces** (UIs),
    and is a resolution-independent framework that uses a vector-based rendering engine
    in the **Extensible Application Markup Language** (**XAML**) to create stunning
    user interfaces. It supports a broad set of features that includes application
    models, controls, layouts, graphics, resources, security, and more.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime libraries for it to execute have been included with Windows since
    Windows Vista and Windows Server 2008\. If you are using Windows XP with SP2/SP3
    and Windows Server 2003, you can optionally install the necessary libraries.
  prefs: []
  type: TYPE_NORMAL
- en: To begin learning the different recipes of WPF, you should have a clear understanding
    of the basic foundations. In this chapter, we will start with the architecture
    and syntaxes, and will guide you in creating a building block.
  prefs: []
  type: TYPE_NORMAL
- en: The WPF Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WPF uses a layered architecture that includes managed, unmanaged, and the core
    APIs in five different layers called **Presentation Framework**, **Presentation
    Core**, **Common Language Runtime**, **Media Integration Library**, and **OS Core**.
    The programming model is exposed through the managed code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, you can see a clear picture of the architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79d3ee57-66b2-4bf9-a826-f951c2d85758.png)'
  prefs: []
  type: TYPE_IMG
- en: Presentation Framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Presentation Framework**, which is part of `presentationframework.dll`,
    provides the basic required components (such as controls, layouts, graphics, media,
    styles, templates, animations, and more) to start building the UIs of your WPF
    applications. It is part of the managed layer.
  prefs: []
  type: TYPE_NORMAL
- en: Presentation Core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Presentation Core** layer, part of `presentationcore.dll`, provides you
    with the wrapper around the **Media Integration Library** (**MIL**). It present
    you with the public interfaces to access the MIL Core and the Visual System to
    develop the Visual Tree. It contains visual elements and rendering instructions
    to build applications for Windows using the XAML tools. This is also part of the
    managed code.
  prefs: []
  type: TYPE_NORMAL
- en: Common Language Runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Common Language Runtime**, commonly known as the **CLR** and part of the
    managed layer, provides you with several features to build robust applications
    covering **common type system** (**CTS**), error handling, memory management,
    and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Media Integration Library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Media Integration Library (MIL)**, which resides in `milcore.dll`, is
    part of the unmanaged layer used to display all graphics rendered through the
    DirectX engine. It provides you with basic support for 2D and 3D surfaces, and
    allows you to access the unmanaged components to enable tight integrations with
    DirectX. It also enables you to gain performance while rendering instructions
    from the Visual System to the **Common Language Runtime** (**CLR**).
  prefs: []
  type: TYPE_NORMAL
- en: OS Core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just after the MIL, the next layer is the **OS Core**, which provides you with
    access to the low-level APIs to handle the core components of the operating system.
    This layer includes Kernel, User32, DirectX, GDI, and device drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Types of WPF applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Though WPF is mainly used for desktop applications, you can also create web-based
    applications. Thus, WPF applications can be of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Desktop-based executables (EXE)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web-based applications (XBAP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The desktop applications are the normal `.exe` executables, which you normally
    run on any of your Windows-based systems, whereas the web-based applications are
    the `.xbap` files that can be deployed in web servers and can run inside any supported
    browser. The .NET Framework is mandatory to run any of these application types.
  prefs: []
  type: TYPE_NORMAL
- en: When you run a WPF application, it starts in two threads. The UI thread uses
    the `System.Threading.DispatcherObject` to create the messaging system and that
    maintains the UI operations queue. Just like the Win32 message pumping, it performs
    the UI operation based on the priority set for it.
  prefs: []
  type: TYPE_NORMAL
- en: The other thread is the background thread, which is used to handle the rendering
    engine being managed by WPF. It picks up a copy of the visual tree and performs
    actions to show the visual components in the Direct3D surface. Then it calls the
    UI elements to determine the size and arranges the child elements by their parents.
  prefs: []
  type: TYPE_NORMAL
- en: The XAML overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**XAML** stands for **Extensible Application Markup Language**. It is an XML-based
    markup language that is used to declaratively create the UI of any XAML-based
    application, such as **Windows Platform Foundation** (**WPF**), **Universal Windows
    Platform** (**UWP**), and **Xamarin.Forms**. You can create visible UI elements
    in a declarative XAML syntax to design the rich UI and then write the code behind
    to perform a runtime logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft recently introduced **XAML Standards**, which is a specification that
    defines a standard XAML vocabulary, which will allow the supported frameworks
    to share common XAML-based UI definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about this specification by visiting GitHub here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://aka.ms/xamlstandard.](http://aka.ms/xamlstandard)'
  prefs: []
  type: TYPE_NORMAL
- en: Though it is not mandatory to use the XAML markup to create a UI, it has been
    widely accepted as the smart option for the creation of the entire application's
    UI, as it makes things easier to create. You can create the UI by writing C# or
    VB.NET code too, but that makes it more difficult and tougher to maintain. Also,
    that makes it difficult for the designers to work independently.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an application UI using XAML is as easy as writing an XML node with
    a few optional attributes. Attributes are used to set additional styles, behaviors,
    and properties. To create a simple button in the UI, you can just write `<Button
    />` in your XAML file. Similarly, you can just write `<TextBox />` to create a
    user-input box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you can add more details to the controls. For example, to add
    a label to a button, use its `Content` property, and to set its dimension, use
    the `Height` and `Width` property, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In general, when you add XAML pages to your WPF application project, it compiles
    along with the project and produces a binary file in what is known as **Binary
    Application Markup Language** (**BAML**). The final output of the project (that
    is, the assembly file) contains this BAML file as a resource. When the application
    loads into the memory, the BAML is then parsed at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: You can also load an XAML into memory and directly render it on the UI. But,
    in this case, if it has any XAML syntax errors, it will throw those in runtime.
    If you compare the performance with the first process, the latter is slower, as
    it renders the entire XAML syntax onto UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a flow diagram, that demonstrates the ways to load and render/parse
    the XAML UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e089d867-7137-472b-b1af-a5f5274b31eb.png)'
  prefs: []
  type: TYPE_IMG
- en: XAML syntax terminologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XAML uses some syntax terminologies to define an element in the UI and create
    the instance of it. Before you start working on it, you must understand the different
    terminologies that it offers. Let's have a look at a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: Object element syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each instance of a type is defined using proper XAML syntax to create an object
    element in the UI. Each of these object elements starts with a left angular bracket
    (`<`) and defines the name of the element. You can optionally prefix the namespace
    when it is defined outside the default scope. You can use a self-closing angular
    bracket (`/>`) or a right angular bracket (`>`) to close the object element definition.
    If the object element does not have any child elements, the self-closing angular
    bracket is used. For example, (`<Button Content="Click Here" />`) uses a self-closing
    angular bracket. If you write the same with a child element, it closes with an
    end tag (`<Button>Click Here</Button>,`) as shown.
  prefs: []
  type: TYPE_NORMAL
- en: When you define the object element in an XAML page, the instruction to create
    the instance of the element gets generated and it creates the instance by calling
    the constructor of the element when you load it in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Property Attribute syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can define one or more properties to an element. These are done by writing
    an attribute called **Property Attribute syntax** to the element. It starts with
    the name of the property and an assignment operator (`=`), followed by the value
    within quotes. The following example demonstrates how easy it is to define a button
    element to have a label as its content, and how to set its dimension in UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Property Element syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another type of XAML syntax that allows you to define the property as
    an element. This is often used when you cannot assign the value of the property
    within quotes. If we take the previous example, the text `Click Here` can be assigned
    to the button content easily. But, when you have another element or a composite
    property value, you cannot write those within the quotes. For this, XAML introduces
    **Property Element syntax** to help you to define the property value easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'It starts with `<element.PropertyName>` and ends with `</element.PropertyName>`.
    The following example demonstrates how to assign a color to a button background
    with a `SolidColorBrush` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Content syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is another type of XAML syntax that is used to set the content of a UI
    element. It can be set as the value of child elements. The following example demonstrates
    how to set the text content property of a `Border` control to hold a `Button`
    control as its `child` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'While using **Content syntax**, you should remember the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The value of a `Content` property must be contiguous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot define an XAML `Content` property twice within a single instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, the following is invalid as it will throw XAML error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Collection syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you need to define a collection of elements to the parent root, the **Collection
    syntax** is used to make it easy to read. For example, to add elements inside
    `StackPanel`, we use its `Children` property, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be also written as follows, and the parser knows how to create and
    assign the elements to `StackPanel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Event Attribute syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you add a button, you need to associate an event listener to it, to perform
    some operation. The same is applicable for adding other controls and UI layouts.
    The XAML allows you to use the **Event Attribute syntax** to define events for
    a specific XAML object element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax looks like a property attribute, but it is used to associate the
    event listener to the element. The following example demonstrates how to assign
    the click event to a button control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The associated event gets generated from the code behind the XAML page, where
    you can perform the real action. Here is the code snippet for the event implementation
    of the preceding button-click event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Installing WPF Workload with Visual Studio 2017
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have learned the basic concepts of WPF Architecture and XAML syntax, we
    can start to learn different recipes to build applications for Windows using the
    XAML tools for WPF. But, before that, let's install the required workload/components
    for **Visual Studio 2017**. If you are using prior versions of Visual Studio,
    this step will be different.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install the required components for building WPF applications, run the Visual
    Studio 2017 installer. If you don't have the installer, you can go to [https://www.visualstudio.com/downloads](https://www.visualstudio.com/downloads)
    and download the correct edition. Let's download the Visual Studio Community 2017
    edition as it is a fully featured IDE and available free for students, open source,
    and individual developers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have downloaded the Visual Studio 2017 installer, follow these steps
    to install the correct workload:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have run the installer, it will show you the following screen. Click
    on Continue:![](img/df98e9b4-7568-43ff-9e5d-9ab4b9b34ede.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for a few minutes to let the installer prepare itself for the installation
    process. A progress bar will show you the status of the current progress:![](img/aabbe4d6-cfef-4ad4-a917-a481a46528a6.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then the following screen will pop up, where it will ask you to select the
    **workloads** or **components** that you want to install:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7d567681-2ef1-48f9-b9b0-474a1dc85336.png)'
  prefs: []
  type: TYPE_IMG
- en: To build WPF applications targeting .NET Framework, select the .NET desktop
    development workload, as shown in the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Install button to continue with the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screen will be displayed, showing the status of the installation.
    It will take some time, based on your internet bandwidth, as it''s going to download
    the required components, based on your selection, from the Microsoft servers and
    install them one by one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/72f4e0b5-14ac-450c-bd6e-7b1e85ef1fa9.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the installation has completed, you may have to restart your system for
    the changes to take effect. In this case, a popup will appear on the screen, asking
    you to reboot your PC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have installed the **.NET desktop development component** and restarted
    your system, you are good to go with building your first WPF application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating WPF applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The WPF development platform supports a broad set of features that includes
    UI controls, layouts, resources, graphics, data binding, application model, and
    more. Before using each of those features, you need to create the WPF project
    using Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this recipe is to create a WPF project and learn the basic project
    structure and components. Let's start building our first WPF application using
    the **XAML tools**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with the WPF application development, you must have Visual Studio
    running on your system with the required components already installed on it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create your first WPF application:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside your Visual Studio IDE, navigate to the File | New | Project... menu
    as shown in the following screenshot:![](img/a1106eca-997b-4c7c-b6eb-b1697f25d9b6.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will open the New Project dialog on the screen. You can alternatively open
    it by pressing the keyboard shortcut *Ctrl* + *Shift* + *N*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the New Project dialog, navigate to Installed | Templates | Visual C# |
    Windows Classic Desktop, as shown in the left-hand side of the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2064791d-46e8-4210-a9ad-8a325e3ca000.png)'
  prefs: []
  type: TYPE_IMG
- en: In the right-hand side panel, first select the .NET Framework that you want
    your application to target. We have selected .NET Framework 4.7 here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then select WPF App (.NET Framework), from the available list of templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give a name (in our case, it is `CH01.HelloWPFDemo`) to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, select the location of the project, where you want to create it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, you can also provide a different name for the Solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you are ready, click on the OK button to let Visual Studio create the project
    based on the template that you have selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the project has been created, Visual Studio will open the Solution Explorer,
    which lists the project with all the default files created on it. The project
    structure will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9daf5cb-7bf7-41cb-adfd-3775cd1def9a.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each WPF application project created by Visual Studio using the default template
    consists of the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`App.config`: This is the configuration file of your WPF application. By default,
    it contains the following lines that describe the supported runtime version for
    the application to run. This contains exactly the same runtime version that we
    selected during the project creation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `config` file can also contain application settings and other configuration
    settings that you want to use/refer in your application.
  prefs: []
  type: TYPE_NORMAL
- en: '`App.xaml`: Visual Studio automatically creates the `App.xaml` file when you
    create a WPF project. It is the declarative starting point of your application.
    The root element of this file is the `Application` instance, which defines application
    specific properties and events:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The instance of the `Application` class defines the `Window` or a `Page` that's
    going to be the startup UI, and is registered with the `StartupUri` property.
    In the preceding code, (`StartupUri="MainWindow.xaml"`) states that the `MainWindow.xaml`
    page will get loaded, once you run the application.
  prefs: []
  type: TYPE_NORMAL
- en: The application instance can also hold global/application-level resources (such
    as, Style, Template, and Converter) that can be used globally throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: '`App.xaml.cs`: This is the code-behind class file of the `App.xaml` and extends
    the `Application` class of the framework to write application-specific code. You
    can use this file to subscribe to the events such as `Startup`, `UnhandledException`
    to perform common operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This class is often used to manipulate command-line parameters and load different
    XAML pages based on that.
  prefs: []
  type: TYPE_NORMAL
- en: '`MainWindow.xaml`: This is the default UI page that Visual Studio generates
    on creation of the WPF project. It is the page that gets registered as the `StartupUri`
    in `App.xaml`. The root element of this page is `Window` and it contains a `Grid`
    layout by default. Here is the default code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `x:Class` attribute defines the associated partial class where the UI logic
    is being written. You can modify this XAML to provide a fresh look to your application
    start page. Various UI controls and layouts are going to be covered in the later
    chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '`MainWindow.xaml.cs`: This is the code-behind class of `MainWindow.xaml` and
    contains the logic related to UI operations. In general, developers write implementations
    of various UI operations in this class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever you add any UI elements to an XAML page, the control gets registered
    internally in a partial class file that has `.g.i.cs` as the extension. For example,
    if you add a control in the `MainWindow.xaml` file, it gets registered in the
    `MainWindow.g.i.cs` residing in the `obj` folder. If you open the file, you can
    observe the entire loading process inside the `InitializeComponent()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and navigating from one window to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WPF standalone applications, a window is used to host the UI elements to
    enable users to interact with the UI and data. The base class `Window` provides
    all the APIs to create and interact with the Window UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In WPF applications, the generic window layout is divided into multiple parts.
    Here is a screenshot of a basic window, containing its various parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78804e0a-8aa1-4b2d-b929-32561fbe99b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The various parts of the window are as mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The outer part of the window is a **Border**, which you can utilize to enable
    the resizing option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The outer border can contain a **resizing grip**, which enables you to resize
    the window diagonally
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The window contains a **Title bar** at the top, which consists of the following
    parts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **Icon** to provide a unique brand to your application window
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Title**, showing the identifiable name of the window
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A small panel, containing Minimize, Maximise/Restore, and Close buttons
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **System menu** with menu items to allow users to perform Minimize, Maximize/
    Restore, Move, Size, and Close operations on the window
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **client area** for the developers to add application/window specific layouts
    and controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with this recipe, open your Visual Studio instance and create
    a WPF project called `CH01.WindowDemo` based on the WPF App (.NET Framework) template.
    Once the project has been created, it will have files called `MainWindow.xaml`
    and `MainWindow.xaml.cs`, along with the other default files.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with creating a new window in the same project and invoke
    a button to open the new window from the `MainWindow`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new window, follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Solution Explorer and right-click on the project node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the right-click context menu, navigate to Add | Window... as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1edc768d-36bf-49fe-9967-818a9965c09c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following Add New Item dialog will appear on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/129ef68e-7943-4432-aa94-0f3555af8073.png)'
  prefs: []
  type: TYPE_IMG
- en: Make sure that the selected template is Window (WPF). Give it a name, `SecondWindow.xaml`,
    and click the Add button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will create the `SecondWindow.xaml` file and its associated code-behind
    file `SecondWindow.xaml.cs` in the project directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the XAML file (`SecondWindow.xaml`) and replace the entire contents with
    the following XAML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open the `MainWindow.xaml` file to add a button into it. Replace the entire
    `<Grid> </Grid>` block, with the following XAML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add the implementation for the button-click event. Simply open
    the `MainWindow.xaml.cs` file and add the following lines of code inside the class
    definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you run the application, you will see that the MainWindow opens on
    the screen, containing a button labeled Open Second Window. Clicking on this button
    opens the second window on the screen that has text content of Second Window Instance.
    Here's the screenshot for your reference:![](img/0b21988b-467a-4790-b633-95d1ed00471b.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please note that if you click the button again, it will create another instance
    of the second window because it's modeless.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create the instance of the `Window` class, it will not become visible
    to the user. It only becomes visible when you call the `Show()` method, which
    returns the handle to the originated caller without waiting for the window to
    close.
  prefs: []
  type: TYPE_NORMAL
- en: When you call the `Show()` method, it basically creates a modeless window, and
    hence you can interact with other windows within the same application when the
    same is already open. The `Window` class also exposes a method called `ShowDialog()`,
    which creates a model window and prevent users from interacting with other windows
    of the application. We will discuss the more later in this chapter, in the *Creating
    a dialog box* section.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Window` class provides you with a bunch of properties, methods, and events
    to customize the look of the window, and perform specific operations or to be
    notified of the current context. To ask the client area to support transparency,
    set the `AllowsTransparency` property of the window to `true`. This is often useful
    when you want to create a custom-shaped window or a skinned theme.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the default icon of the window by setting the `Icon` property
    and enable/disable the window resizing by setting the `ResizeMode` property. You
    can also set the window title, startup location, window state, window style, and
    taskbar visibility by settings the `Title`, `WindowStartupLocation`, `WindowState`,
    `WindowStyle`, and `ShowInTaskbar` properties, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Not only these but you can bring the window to the foreground by calling its
    `Activate()` method and close the window by calling the `Close()` method available
    in the `Window` class. Sometimes, when you want to hide the window instead of
    quitting it completely, you can utilize the `Hide()` method to make the window
    hidden and bring it back again by calling the `Show()` method on the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: The class also exposes some events to notify you of the current contextual information.
    You can use the `Activated`, `Deactivated`, `Closing`, `Closed`, and `StateChanged`,
    events in your code to get such notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and navigating from one page to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The WPF application supports a browser style navigation mechanism, which can
    be used in both standalone applications as well as in XBAP applications. To implement
    it, WPF provides the `Page` class to encapsulate the `Page` content that can be
    navigated to and hosted by the browser, a `NavigationWindow` and/or a `Frame`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with this recipe to build an application that supports navigations
    mechanisms from one WPF page to another, open the Visual Studio IDE and create
    a project based on the WPF App (.NET Framework) template. Give it a name (in our
    case, it's `CH01.PageDemo`).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have created your project based on the WPF App (.NET Framework) template,
    follow these steps to add pages to your project and integrate them with the `NavigationService`:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the project node where you want to create the pages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in this screenshot, navigate to Add | Page... from the context menu:![](img/7ccaf015-ab4e-4c0c-9afa-572ee435ff62.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will open the following Add New Item dialog window, where the item titled
    Page (WPF) is already selected. Give it a name, `Page1.xaml` and click Add. It
    will create the `Page1.xaml` and the associated code-behind file `Page1.xaml.cs`
    in your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a6477c0-0641-4e4b-9095-c52b1df97720.png)'
  prefs: []
  type: TYPE_IMG
- en: Now follow the same steps, 1 to 3, to create another page `Page2.xaml`, which
    will add both the XAML and associated C# code-behind file into the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Page1.xaml` file and replace the `Grid` with the following XAML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the associated code-behind file (`Page1.xaml.cs`), add the following button-click
    event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, add the following XAML into the `Page2.xaml` page, replacing the
    existing `Grid`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following button-click event handler into the `Page2.xaml.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open the `MainWindow.xaml` file and replace the XAML content with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now open the `MainWindow.xaml.cs` file and change its base class to `NavigationWindow`,
    instead of `Window`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the application, which will open the following screen containing Page 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/04c79e6b-840a-4609-a733-20da461b8e87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the Next button will navigate you to Page 2, as shown here, which
    contains the activated navigational button automatically provided by the WPF Framework:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eef15e0f-7da4-4351-887f-fb4bbcfa1ef1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, if you click on the Previous button or the back button in the navigation
    panel, it will navigate you to Page 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NavigationWindow`, which is defined in the `MainWindow.xaml` page, provides
    the basic mechanism to support the content navigation. The `Source` attribute
    (`Source="Page1.xaml"`), defined as `URI`, asks `NavigationWindow` to load the
    mentioned page (`Page1.xaml`) by default.
  prefs: []
  type: TYPE_NORMAL
- en: When you click on the Next button of `Page1`, the `NavigationService.Navigate`
    method executes, passing the `URI` of the page that you want to load next. The
    navigation buttons automatically activate based on the history of the navigation
    that you performed.
  prefs: []
  type: TYPE_NORMAL
- en: In `Page2`, when you click on the Previous button, it first checks whether the
    `NavigationService` has an immediate history item to navigate you to a previous
    page. If it finds a previous page, it then automatically navigates you to the
    desired page by calling the `NavigationService.GoBack()` method call. In this
    case, you don't have to pass the `URI` of the page.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`NavigationService` offers a variety of properties, methods, and events to
    perform navigation mechanisms on your page content. `CanGoBack()` and `CanGoForward()`
    return a `Boolean` value indicating whether there is at least one entry in the
    back and forward navigation history, respectively. The method `GoBack()` navigates
    you to the most recent entry from back navigation history, whereas the `GoForward()`
    method navigates you to the forward navigation history, if there''s one available.'
  prefs: []
  type: TYPE_NORMAL
- en: To refresh the current content, you can call the `Refresh()` method. The `StopLoading()`
    method stops the current execution from downloading/loading the content part of
    the current navigation context. You can also programmatically add or remove an
    entry from the navigation history. The `AddBackEntry` method takes a parameter
    for the `CustomContentState` object to add the entry into the back-navigation
    history. The `RemoveBackEntry()` method removes the most recent entry from the
    back-navigation history.
  prefs: []
  type: TYPE_NORMAL
- en: Events such as `Navigating`, `Navigated`, `NavigationFailed`, `NavigationStopped`,
    `NavigationProgress`, and `LoadCompleted` are there to notify you of the various
    statuses of the current navigation process. Use them wisely, based on your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dialog box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A dialog box is also a kind of window, and is generally used to get some inputs
    from the user or to show a message to the user. It uses a model window to prevent
    users from interacting with other windows of the same application when it is already
    open. In this recipe, we will learn how to create a model dialog and use the common
    dialog boxes that the framework provides.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with building and using dialog boxes in a WPF application, open
    your Visual Studio IDE and create a new WPF project, calling it `CH01.DialogBoxDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create the dialog window and invoke it from the `MainWindow`
    to show a message to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Solution Explorer and right-click on the project node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the context menu, select Add | Window... to open the Add New Item dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making sure that the Window (WPF) template is selected, give it the name `MessageDialog`,
    and click Add to continue. This will create `MessageDialog.xaml` and `MessageDialog.xaml.cs`
    files in the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `MessageDialog.xaml` file and replace the entire XAML content with
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `MessageDialog.xaml.cs` file, and add the following event implementations
    for the OK button and Cancel button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open the `MainWindow.xaml` page and replace the `Grid` with the following
    XAML content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the code-behind file, `MainWindow.xaml.cs`, and add the button event
    implementation as shared in the following code section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the application. The visible window will have a button labeled Show
    Message. Click on it to invoke the message dialog window that we have created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb4d328a-8a14-47ba-9975-c8609110c90e.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Cancel button, which will add You clicked 'Cancel' button text
    into the list present in the MainWindow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the message window again and click on the OK button. This will add You
    clicked 'OK' button in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you call the `ShowDialog()` method of the `Window` instance, it opens it
    as a model dialog and waits until the user provides an input to it. In this case,
    the user input is the interaction with the OK and Cancel button. When you click
    the OK button, the associated event handler assigns `true` to the `DialogResult`
    property and returns to the caller. Similarly, the Cancel button event handler,
    assigns `false` to the `DialogResult` property and returns.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the return value of the `ShowDialog()` method, which actually returns
    the value of `DialogResult`, you can decide whether the user clicked the OK or
    Cancel button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialog window has been customized by setting the following properties to
    the `Window` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ShowInTaskbar` property has been set to `False` to prevent the window from
    being visible in the Taskbar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `WindowStyle` property has been set to `SingleBorderWindow` to add a thin
    border to the window, removing the minimize and maximize buttons from the title
    bar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Topmost` property has been set to `True` to keep it always visible on top
    of other windows. This is optional, but good to have.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ResizeMode` property has been set to `NoResize` to prevent the user from
    resizing the dialog window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The operating system provides some reusable dialog boxes, which provide a user
    experience consistent with the version of the operating system in which the application
    is running. The experience also stays consistent across all applications to provide
    a unique interface for performing common operations such as opening files, saving
    files, printing files, color selection, and more.
  prefs: []
  type: TYPE_NORMAL
- en: WPF provides these reusable, common dialog boxes as managed wrapper classes,
    encapsulating the core implementation. This reduces the extra effort creating
    and managing the common operations.
  prefs: []
  type: TYPE_NORMAL
- en: Using the open file dialog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To open files in your WPF application, you can use the managed wrapper class
    `OpenFileDialog`, which is present under the `Microsoft.Win32` namespace. You
    just have to create the instance and call the `ShowDialog()` method by optionally
    setting a few properties for UI customization.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic open file dialog looks like the following screenshot, providing you
    with an option to select one or more files to open:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bf6052c-16a3-499a-a562-ce0bde65f88c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code snippet demonstrates how to initiate the open file dialog
    by optionally filling the file-extension filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `dialogResult` returned by the `ShowDialog()` method tells us whether the
    operation was performed successfully. Based on that, you can call the instance
    of the file dialog to get more details about the selected file.
  prefs: []
  type: TYPE_NORMAL
- en: Using the save file dialog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Along with the `OpenFileDialog` interface, the `Microsoft.Win32` namespace also
    provides the `SaveFileDialog` managed wrapper to perform file saving operations
    from your WPF application. Similar to the open file dialog, you need to create
    the instance of it by optionally filling its various properties to finally call
    the `ShowDialog()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The save file dialog looks like the following screenshot, where you can provide
    a name to save as a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/590ebada-3593-4c26-b9d0-5c4bfbbb352f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Optionally, you can set the extension filter, default file name, and other
    properties before launching the dialog window, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Based on the `dialogResult` returned by the `ShowDialog()` call you can decide
    whether the save was successful and retrieve more information about the saved
    file from the file dialog instance.
  prefs: []
  type: TYPE_NORMAL
- en: Using the print dialog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The managed wrapper `PrintDialog` is also present in the `Microsoft.Win32`
    namespace, and provides you with the interface to call the operating system''s
    printer properties and perform the `print` operation. The dialog gives you the
    option to Select Printer, configure the printing preferences, and select the page
    range and other parameters, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae68185b-389b-473c-ab48-eb8688efdd55.png)'
  prefs: []
  type: TYPE_IMG
- en: To invoke the same, just create the instance of the `PrintDialog` and call its
    `ShowDialog()` method. You can optionally set page range, printable area, and
    other properties. If the `dialogResult` returned by the `ShowDialog()` method
    is set to `true`, it confirms that the printing job has been queued up successfully,
    and based on that you can perform the next set of actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code snippet for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Other common dialogs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WPF also provides some other common dialog boxes to perform the selection of
    various formatting options, such as font, font style, font size, text effects,
    and color. You can use the `FontDialog` and `ColorDialog`, present under the `System.Windows.Forms`
    namespace, to add support for the font and color selections, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the screenshot presenting the font selector and color selector dialogs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b7bdd04-367f-4027-a237-8ad0cd93323c.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating ownership between windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the WPF application, the window objects that you create are independent of
    each other by default. But, sometimes, you may want to create an owner-owned relationship
    between them. For example, the toolbox window that you generally see in your Visual
    Studio IDE and/or in a Photoshop application.
  prefs: []
  type: TYPE_NORMAL
- en: When you set an owner of a window, it acts according to the owner instance.
    For example, if you minimize or close the owner window, the other window under
    the owner-owned relationship automatically minimizes or closes according to its
    owner.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin creating this recipe to have an owner-owned relationship between
    two windows.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with this recipe, open your Visual Studio IDE and create a new
    WPF project called `CH01.OwnershipDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a `ToolBox` window and assign its ownership
    to the `MainWindow`, so that it can act according to its owner:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the project node and select Add | Window... from the context
    menu. The Add New Item dialog will be shown on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Window (WPF) from the available list, give it the name `ToolBox`, and
    click Add to continue. This will add `ToolBox.xaml` and `ToolBox.xaml.cs` into
    your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `ToolBox.xaml` file and replace its content with the following XAML
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now open the `App.xaml` page and remove the property attribute `StartupUri`,
    defined as (`StartupUri="MainWindow.xaml"`) from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to its code-behind file `App.xaml.cs` and override the `OnStartup` event.
    We need to modify the implementation according to our needs. Replace the entire
    `OnStartup` event handler with the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Run the application to see the relationship between the two windows. The windows
    will look like the following screenshot:![](img/c5c3dddc-e526-4c17-89b2-f6468f098c25.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the ToolBox window and you can see that you are able to move it outside
    the MainWindow. Now perform some operations, such as minimizing and closing, on
    the MainWindow, and you will see that the ToolBox window also acts according to
    its owner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the owner of every `Window` object is set to null, and thus each
    window is independent of the other. But, when you set its owner, it follows the
    owner-owned relationship and acts with the owner window.
  prefs: []
  type: TYPE_NORMAL
- en: '`Window` ownership is not a feature of WPF, but a capability of the Win32 user
    API and, accessible from a WPF application.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make sure you display the owner window first, before setting it as the owner
    of some other window, otherwise the system will throw an `InvalidOperationException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/946e35e3-37e8-4a98-ba6a-2fe2977d54b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some points to note about window ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: The window that has an ownership relationship with another window always appears
    on top of that owner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can drag the window outside the owner window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you minimize or close the owner, the other window, which is related to
    it, will follow the owner and minimize or close respectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the window in a relationship gets displayed in the taskbar, but
    when you minimize the owner, it gets removed from the taskbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to break the relationship, just set the `Owner` property to `null`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a single instance application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you build applications for Windows, there are many reasons why you would
    want to restrict users from launching multiple instances of your application.
    Some common examples are installers, uninstallers, update utilities, media applications,
    utility tools, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In a normal application, when you launch the app, it creates a Windows process,
    and allocates its own memory space and resources. But, when you don't want to
    create multiple instances of the process for a single application that is already
    running, you want to silently quit the new instance and bring the running process
    into the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to achieve this using **Mutex** (**Mutual
    Exclusion**) and unmanaged code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with this, open your Visual Studio instance and create a new
    project based on the WPF application template. During the project creation, give
    it the name `CH01.SingleInstanceDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the WPF project has been created, follow these steps to create a single
    instance of the WPF application:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the application by pressing the *CTRL* + *F5* key combination. This will
    launch one instance of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *CTRL* + *F5* multiple times to launch multiple instances of the application.
    Now it's time to make the application a single instance application:![](img/123dcc2f-914c-4092-9c51-29ff7ccf41dd.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close all the running processes and then follow the next steps to implement
    the single instance behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` and add the window title to `Single Instance Demo`.
    Here you can find the entire XAML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Open the `App.xaml.cs` file and override the base implementation of the `OnStartup`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the code of the `OnStartup` method so that it looks like the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Add the `System.Threading` namespace declaration, so that the Mutex can be discoverable.
    The Mutex resides in the aforesaid namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now compile the project to make sure that there are no compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *CTRL* + *F5*, which will run the first instance of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now return to the Visual Studio, without closing the application, and then hit
    *CTRL* + *F5*. This time, instead of launching the application UI, an Application
    instance is already running! message will pop up on the screen. Clicking OK will
    close the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *CTRL* + *F5* again. Observe that no second instance of the UI is visible
    on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's a trick to handle the application to have only a single instance. The **Mutex**
    (**Mutual Exclusion**) object is used to define the instance with a unique name.
    Here we called it `SingleInstanceDemo`. The Boolean `out` parameter returns whether
    the current calling thread has been granted the initial ownership of the `mutex`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: A **Mutex** object is a synchronization object, which is generally used to synchronize
    access to a shared resource, so that only one thread can access that resource
    at a single point in time.
  prefs: []
  type: TYPE_NORMAL
- en: For the first instance of the application, it will be granted as the initial
    ownership. When the second instance runs, the calling thread will not get the
    initial ownership because the `mutex` object with the same name, `SingleInstanceDemo,`
    already exists and is running.
  prefs: []
  type: TYPE_NORMAL
- en: So, the Boolean value of `isNewInstance` will be `false` and the message box
    will get displayed on the screen. The second instance of the application is still
    running at that moment and calls the `Shutdown()` method when you click on the
    OK button to close the message box.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the second instance will be removed from the process list. The first instance
    will continue running on the system.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There could be a scenario where the application is running in a background process
    and the user tries to relaunch the application. In such a scenario, instead of
    showing a message to the user, you may want to activate the already running application
    and show its UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this by changing a bit of the existing code and integrating an unmanaged
    code call. To do so, open the `App.xaml.cs` file once again and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `using namespace` into the file: `System.Runtime.InteropServices`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, you need to add the following unmanaged code declaration from the `user32.dll`
    to the `App.xaml.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following method to activate the already running window, provided that
    the title of the window is static. In our case, it is Single Instance Demo, modified
    in the `MainWindow.xaml` page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of calling the `MessageBox`, call the `ActivateWindow()` method
    in the `OnStartup`. Here, you can find this new code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now run the application. It will launch the `MainWindow` titled Single Instance
    Demo on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to Visual Studio. This will put the application window in the background.
    Now run the application once again by pressing the keyboard shortcut *CTRL* +
    *F5*. This time, instead of running a different instance to show the UI, it will
    activate the existing window and push the running application to foreground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's not mandatory that the application window must always have a static title.
    In such cases, it will become more complex to handle said scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to WPF applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command-line arguments are used to take optional parameters or values from
    the user, while launching the application. These are generally used to perform
    specific commands on the application from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to pass command-line arguments to a WPF application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, open the Visual Studio IDE and create a WPF application project
    called `CH01.CommandLineArgumentDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now follow these steps to let the application support command line arguments
    and perform actions based on those:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` to add a `TextBlock` into the `Grid` panel. Replace
    the entire XAML content with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Create a new window in the project by right-clicking on the project node and
    then following the context menu path Add | Window... to open the Add New Item
    dialog window. Give it the name `OtherWindow` and click the Add button. This will
    add `OtherWindow.xaml` and `OtherWindow.xaml.cs` into the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now open the `OtherWindow.xaml` and change its UI to have different text. Let''s
    replace the entire XAML code with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now open the `App.xaml` and remove the `StartupUri="MainWindow.xaml"`. This
    has been done to control the launch of the proper window, based on the argument
    passed to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `App.xaml.cs` and override its `OnStartup` method to retrieve the
    arguments passed to it and open the desired window based on that. Let''s add the
    following code implementation for the `OnStartup` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now build the project. Navigate to the `bin\Debug` folder and launch a Command
    Window in that location. Alternatively, you can launch a **Command Window** (**cmd.exe**)
    and navigate to the `bin\Debug` path, where your application is available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the console window, enter the name of the application without passing any
    arguments to it, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will launch the `MainWindow` of our application, with this screen:![](img/cecf1ff2-aec9-4e33-a6a8-0d42e35dab66.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Close the application window and, from the console window, enter the application
    name by specifying the `/other` argument to it, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will launch the `OtherWindow` of the application, instead of the `MainWindow`:![](img/e63f0383-54d3-44f1-a74e-e8e1df7189f7.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OnStartup(StartupEventArgs e)` method signature contains `StartupEventArgs`
    as a method parameter. It contains a property, `Args`, that returns a string array
    of the command line arguments that were passed to the application. If no command
    line arguments were passed, the string array will have zero items in it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, by checking the condition, we launch the desired window that we want to
    show to the user. You can also take arguments such that the application launches
    in normal mode, maximized mode, or minimized. You can also use it to open the
    application as hidden, in some specific cases.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen how to launch the WPF application from the command line by passing
    the arguments, let's learn how to do this from Visual Studio itself to launch
    it in debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass a command line argument to your WPF application from Visual Studio
    in debug mode, right-click on the project node and click Properties from the context
    menu entry. This will open the project properties. Now navigate to the Debug tab.
    Please refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00535898-8b9a-4217-b475-a210524c2ed3.png)'
  prefs: []
  type: TYPE_IMG
- en: Under Start options, enter `/other` as the command line arguments. Now run the
    application in debug mode by pressing *F5*. You will see that the `OtherWindow`
    opens on the screen. To launch the `MainWindow`, just remove the `/other` argument
    from the project properties mentioned earlier and run the application again. This
    time you will see that the `MainWindow` opens instead of the `OtherWindow`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling unhandled exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception handling is a vital part of software development. When an exception
    occurs at runtime, due to any error in the code, we handle those with a `try {}
    catch {}` block. The `try {}` block contains the code where the exception occurred;
    the `catch {}` block knows how to handle that, based on the type of the exception.
    After the exception has been handled, the normal execution of the program continues
    without affecting the application.
  prefs: []
  type: TYPE_NORMAL
- en: Though, in most of the cases we handle, there could be cases that may go unnoticed
    and come into the picture at runtime. Such an unhandled exception crashes the
    application. In this recipe, we will learn how to catch the unhandled exceptions
    in the WPF application and close the application properly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, open the Visual Studio IDE. Now create a new project, based
    on the WPF Application template, and call it `CH01.UnhandledExceptionDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start the demonstration by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` page, and add two radio buttons and one button on
    it. The first radio button will cause an exception handled in a `try {} catch
    {}` block, whereas the second radio button will throw an exception that will go
    unhandled. Add the following code into your `MainWindow.xaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `MainWindow.xaml.cs` file to add the button-click event handler. Add
    the following code block inside the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the `App.xaml.cs` file and override the `OnStartup` method to have the
    application level `DispatcherUnhandledException` event registered as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `DispatcherUnhandledException` event handler into the `App.xaml.cs`
    and handle the exception as shown in the following code, but with an empty code
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let's build and run the application. You will see the following UI on the screen:![](img/1a8986f3-82a1-4168-b4d7-f20b6f322d48.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will have two radio selectors and one button in the application window.
    When the first radio button is checked and you click on the Throw Exception button,
    it will generate an exception in a `try {}` block, which will then immediately
    be handled by the associated `catch {}` block without crashing the application.
    The following message box will be shown on the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d36f20f5-4b66-4c7a-9b4f-df06339b82db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the second radio button, when checked, if you click on the Throw Exception
    button, the exception will go unhandled and will be caught in the `App.xaml.cs`
    file, under the `OnUnhandledException` event, and the application will crash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d16691e7-85f5-4a47-ba53-f69e8fac5521.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the `App.xaml.cs` once again and modify the `OnUnhandledException` event
    implementation, as follows, to handle the thrown exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now run the application once again, check the second radio button and click
    on the button. You will notice that the application will not crash this time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Throw Exception button multiple times. The application will continue
    as-is, without causing any crash of the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you handle this kind of uncaught/unhandled exception by specifying `e.Handled
    = true`, your application will not crash and will continue running. The best part
    of catching an unhandled exception is logging the unknown/unhandled errors, so
    that you can investigate the root cause behind these exceptions and fix them in
    future builds.
  prefs: []
  type: TYPE_NORMAL
- en: When there's a critical error, you can restart the application programmatically
    from this block.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also use the `AppDomain.CurrentDomain.UnhandledException` event handler
    to catch any unhandled exceptions, but you won't be able to handle it in a way
    to continue running the application. When used, you can log the error and terminate/restart
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Unhandled exceptions handled in the `DispatcherUnhandledException` event, by
    specifying `e.Handled = true` will not route to the `AppDomain.CurrentDomain.UnhandledException`.
  prefs: []
  type: TYPE_NORMAL
