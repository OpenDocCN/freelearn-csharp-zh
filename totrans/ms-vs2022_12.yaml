- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio Container Tools for Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the powerful integration of Docker with
    Visual Studio, a synergy that simplifies container management and accelerates
    your development workflow. We will begin by covering the basics of Docker and
    how it integrates with Visual Studio. We’ll understand the fundamental concepts
    of containerization and why it has become a cornerstone in modern development
    practices. Next, we will walk through the steps to configure our development environment
    for Docker. This includes installing necessary components, setting up Docker support
    in Visual Studio, and configuring your projects to use Docker. Then, we will dive
    into the practical aspects of converting your applications into Docker containers.
    Finally, we will explore the deployment phase. We’ll learn various methods to
    deploy our containerized applications, whether to a local Docker host, a remote
    server, or cloud platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Docker and Visual Studio integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Docker environments in Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerizing applications with Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying containerized applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have the knowledge and skills to harness
    Docker within Visual Studio, making your development process more efficient and
    scalable, without getting out of our favorite IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing this chapter, I used the following version of Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Enterprise 2022 Version 17.12.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To fully follow the chapter, you will also need to install Docker Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Docker and Visual Studio integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The integration of containerization technologies such as Docker with powerful
    IDEs such as Visual Studio has become essential for modern application development.
    This section introduces Docker and its seamless integration within Visual Studio,
    showcasing how this combination enhances the development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Docker, an open source platform, automates the deployment, scaling, and management
    of applications. Introduced in 2013, Docker utilizes containerization technology
    to package an application along with its environment and dependencies into a standardized
    unit called a **container** .
  prefs: []
  type: TYPE_NORMAL
- en: '**Containers** are lightweight, standalone, and executable packages that include
    everything needed to run a piece of software, including the code, runtime, system
    tools, libraries, and settings. Sharing the host **operating system’s** ( **OS’s**
    ) kernel, containers isolate application processes from the rest of the system,
    ensuring consistent performance across various environments. This abstraction
    optimizes system resource usage and simplifies deployment and scalability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker operates on a client-server model with three main components: the Docker
    client, the Docker host, and Docker Registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Docker client** : The primary user interface to Docker, accessible via
    **command-line interface** ( **CLI** ) commands. Users can build images, download
    images from a registry, run containers, and manage container networks and volumes.
    The Docker client communicates with the Docker daemon, which handles the heavy
    lifting of building, running, and managing containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Docker host** : The runtime environment for containers, comprising several
    key components:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker daemon** : This runs in the background on the host machine, managing
    the building, running, and distribution of Docker containers. It listens to API
    requests from the Docker client and manages Docker objects, such as images, containers,
    networks, and volumes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers** : Runnable instances of Docker images, encapsulating an application
    along with its environment, libraries, and dependencies.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Images** : Read-only templates used to create containers, containing the
    application and all its dependencies.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networks** : Custom networks configured for container communication.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage** : Managed through volumes that persist data generated and used
    by Docker containers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Registry** : Stores Docker images in a central repository, facilitating
    the sharing and deployment of images across different hosts. Registries can be
    public, such as Docker Hub, or private, for secure storage and management of organizational
    images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another key component of Docker is **Docker images** . Docker images are snapshots
    of a container’s configuration at a specific point in time, containing the application
    code, runtime, libraries, tools, and dependencies. They are immutable and serve
    as the basis for creating containers. Modifications to an image create new images,
    enabling consistent replication of application environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker uses Dockerfile to automate Docker image creation. **Dockerfile** is
    a script with instructions defining the environment in which an application will
    run. Common instructions include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FROM** : This specifies the base image (e.g., **FROM mcr.microsoft.com/dotnet/sdk:9.0**
    uses the .NET SDK image tagged with version 9.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RUN** : This executes commands in a new layer on top of the current image,
    often used for installing software packages (e.g., **RUN** **npm install** )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMD** : This provides defaults for executing a Docker container (e.g., **CMD
    ["** **npm", "start"]** )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerfiles streamline the setup and configuration of containers, ensuring efficient
    definition and replication of application environments across development stages.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio provides robust support for Docker, enabling developers to easily
    containerize their applications and manage container orchestration directly from
    the IDE. This integration simplifies the process of developing, testing, and deploying
    containerized applications, especially for projects targeting .NET Framework,
    .NET Core, ASP.NET, and ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore how to set up a Docker environment within Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Docker environments in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore how to leverage Docker support. Docker support
    in Visual Studio provides a seamless experience for developing applications that
    are intended to run inside Docker containers. Docker support can be added to a
    Visual Studio project during project creation or added to an existing project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project with Docker support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming you have Docker Desktop installed and running, the first thing to do
    is to create a new project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create an ASP.NET Core application as usual and in the **Additional
    information** window, we will check the **Enable container** **support** checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Enable container support](img/B22218_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Enable container support
  prefs: []
  type: TYPE_NORMAL
- en: 'Once checked, it enables the two text boxes, **Container OS** and **Container
    build type** , to configure the container type. We can select either **Windows**
    or **Linux** for the **Container OS** option based on our requirements. For **Container
    build type** , we can select either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dockerfile** : When you choose **Dockerfile** in an ASP.NET Core application,
    you are opting to manually define how your container image should be built using
    a Dockerfile. Using a Dockerfile gives you full control over the contents of your
    container image, including the base image, dependencies, environment variables,
    exposed ports, and the specific commands to run your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.Net SDK** : Choosing **.Net SDK** simplifies the process by leveraging Visual
    Studio’s built-in container support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the following example of this chapter, we will choose the **Dockerfile**
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Docker support to an existing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have an existing project and want to add Docker support to it, we follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add Docker support, right-click on the project in **Solution** **Explorer**
    and navigate to **Add** | **Docker** **Support...** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Adding Docker support](img/B22218_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Adding Docker support
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio will generate the necessary Docker files for our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Dockerfile](img/B22218_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: 'The following dialog will appear where you will have to configure the Docker
    settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Container Scaffolding Options](img/B22218_12_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Container Scaffolding Options
  prefs: []
  type: TYPE_NORMAL
- en: '**Container OS** : This setting allows us to choose the OS that will be used
    inside your Docker container. When we are adding Docker support when creating
    a new project, we have the choice between Linux and Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container Build Type** : As previously discussed, this setting determines
    how your Docker image will be built (e.g. Dockerfile / . Net SDK).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container Image Distro** : This setting refers to the base image distribution
    for your container. It’s particularly relevant when choosing a Linux-based container
    OS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Build Context** : The Docker build context refers to the set of files
    located in the specified patch or URL that Docker uses to build the image. Essentially,
    it defines the scope of files that Docker can access during the build process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Docker support added, we can now build and run our project within Docker
    containers. Visual Studio provides convenient buttons in the toolbar for building
    and running your Dockerized application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Container run/debug button](img/B22218_12_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Container run/debug button
  prefs: []
  type: TYPE_NORMAL
- en: Now we have set Docker support up, let’s learn about how it might improve our
    productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerizing applications with Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have set the Docker support up for our project, in this section,
    we will explore the Dockerizing of our application through the container window
    of Visual Studio. We can retrieve all the information of our container in the
    windows. To open this window, go to **View** | **Other Windows** | **Containers**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Open containers windows](img/B22218_12_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Open containers windows
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can find the information on **Solution Containers** as well as all
    containers in our Docker Desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – The Containers window](img/B22218_12_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – The Containers window
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Docker Desktop must be running on your computer to ensure that the
    Docker Engine is running and provides the necessary environment for building,
    managing, and running Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: The container window allows us to quickly access the containers’ information
    directly in Visual Studio in order to monitor container status, view logs, and
    manage the container life cycle without leaving Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'The toolbar allows us to manage the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Container toolbox](img/B22218_12_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Container toolbox
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand these toolbar options in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start/stop** : These options allow you to manage the life cycle of the container
    directly from Visual Studio, without needing to use Docker CLI commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attach debugger** : For containers running applications that support debugging
    (e.g., .NET Core applications), this option allows attaching a debugger to the
    container. This enables setting breakpoints and inspecting variables as if the
    application were running locally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open terminal** : This opens a terminal session inside the container. This
    is particularly useful for executing commands within the container’s environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remove container** : This allows you to delete the container. This is useful
    for cleaning up stopped containers that are no longer needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we can find panels on the right, allowing us to consult all the
    information about the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Logs** pane displays the container’s logs. It’s useful for debugging
    and monitoring the container’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Containers | Logs](img/B22218_12_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Containers | Logs
  prefs: []
  type: TYPE_NORMAL
- en: This display automatically shows when we are launching our container in debug.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can run our container without getting out of Visual Studio, let’s see
    how to deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying containerized applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the application is developed, the next step is to deploy it. In this section,
    we will see the built-in options offered by Visual Studio to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: First, we access the publish wizard by right-clicking on the project through
    **Solution Explorer** and then selecting the **Publish…** option.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Publish…](img/B22218_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Publish…
  prefs: []
  type: TYPE_NORMAL
- en: We already have seen in [*Chapter 8*](B22218_08.xhtml#_idTextAnchor132) and
    [*Chapter 10*](B22218_10.xhtml#_idTextAnchor152) that it will open a window allowing
    us to choose the destination of our publication. In this chapter, we will focus
    on two options, **Docker Container Registry** and **Azure** .
  prefs: []
  type: TYPE_NORMAL
- en: Deploying in Container Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin with a reminder of what a container registry is. A **container registry**
    is a centralized storage and distribution system for named Docker images and their
    associated tags. It acts as a repository for container images, allowing us to
    build, share, and deploy containerized applications efficiently. Container registries
    can be either public or private, depending on whether they are accessible to everyone
    or restricted to authorized users.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this case, in the **Target** window, we will choose **Docker** **Container
    Registry** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Docker Container Registry](img/B22218_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Docker Container Registry
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click **Next** to jump into the **Specific target** tab to select the
    host of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Specific target Container Registry](img/B22218_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Specific target Container Registry
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have three options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Container Registry** : The **Azure Container Registry** ( **ACR** )
    is a private, managed, and secured Docker Registry provided by Azure. It allows
    us to store and manage our Docker images and related artifacts in a central registry,
    enabling reliable, secure, and scalable deployments. ACR offers secure storage
    of Docker images behind Azure’s network security and access control mechanisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Hub** : **Docker Hub** is a public, cloud-based repository in which
    Docker users and partners create, test, store, and distribute container images.
    While not as secure or feature-rich as ACR for enterprise use, Docker Hub is widely
    used for sharing open source projects and base images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other Docker Container Registry** : Besides **ACR** and Docker Hub, there
    are several other container registries available, each with its own set of features
    and pricing models. Some notable ones include **Google Container Registry** (
    **GCR** ) and Amazon **Elastic Container** **Registry** ( **ECR** ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For ACR, Visual Studio will ask us to use a valid Azure subscription. On the
    other hand, it will prompt us to provide our Docker credentials if we choose Docker
    Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying as a service in Azure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back to the **Target** window, we select **Azure** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Target Azure](img/B22218_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Target Azure
  prefs: []
  type: TYPE_NORMAL
- en: This will bring us to the **Specific target** window where we find several options
    to deploy our application on our Azure subscription.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Specific target Azure](img/B22218_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – Specific target Azure
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on these container options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Container Apps (Linux)** : **Azure Container Apps** is a fully managed
    service designed to run containers directly, without the need for orchestrators,
    such as Kubernetes. It’s optimized for running microservices and serverless applications,
    offering built-in support for source code repositories, CI/CD pipelines, and automatic
    scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure App Service Container** : **Azure App Service** is a fully managed
    platform for building, deploying, and scaling web apps. The container option within
    App Service allows us to run Docker containers, providing a simple way to deploy
    and manage containerized applications or websites.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Container Registry** : Here, we retrieve the ACR, which is the private,
    managed, and secured Docker Registry provided by Azure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each option serves different needs, from serverless containers optimized for
    microservices to fully managed environments for web applications and secure, private
    registries for Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the robust integration between Docker and Visual
    Studio, a combination that significantly enhances your development workflow. We
    began with an introduction to Docker and Visual Studio integration, where we covered
    the basics of Docker and its significance in modern software development. The
    next section guided you through the steps to configure Docker within Visual Studio
    with Docker support. Next, we focused on the practical aspects of converting your
    applications into Docker containers. Finally, we discussed various deployment
    strategies available in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: By mastering these skills, you are now equipped to streamline your development
    process, improve deployment speed, and adopt modern DevOps practices effectively
    staying in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into crafting our own Visual Studio extensions,
    where we’ll learn how to customize and extend Visual Studio to fit your unique
    development needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Mastering Core Development Skills'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final part, we focus on customizing and enhancing your development environment.
    You’ll learn how to write your own project templates, create Visual Studio extensions,
    and build NuGet packages to share with the development community and within your
    organization. These skills will empower you to tailor Visual Studio to your needs,
    streamlining workflows and boosting productivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B22218_13.xhtml#_idTextAnchor182) , *Writing Your Own Project
    Template*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B22218_14.xhtml#_idTextAnchor191) , *Writing Your Own Visual
    Studio Extensions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B22218_15.xhtml#_idTextAnchor199) , *Creating and Publishing
    Powerful NuGet Packages for the Community*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
