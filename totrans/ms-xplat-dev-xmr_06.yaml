- en: Chapter 6. Platform Extras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter concentrates on platform-specific APIs and features. It explains
    some of the peripherals that can be employed in Xamarin applications. We will
    also discuss native libraries and how to include them in cross platform Xamarin
    applications. The following topics will be discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: Content sharing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peripherals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Location data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each Xamarin target platform implements a certain strategy to share formatted
    content between the applications. Sharing implementations increases the visibility
    of your applications by allowing users to open files from your application in
    any other app. In addition, these types of implementations provide added value
    to the quality of your cross platform projects from the nativity perspective.
  prefs: []
  type: TYPE_NORMAL
- en: The inter-application sharing occurs with the underlying runtime acting as a
    broker between the sharing source and target applications. On iOS and Windows
    Store applications, the sharing is facilitated in the form of abstract file elements.
    Android applications, however, can take it one step further by sharing formatted
    data that can be manipulated by the receiving application, which essentially allows
    the source application to almost act as a data repository.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Windows Store, applications can actively share content such as media elements,
    URIs, text content, and other types of data. However, in this implementation strategy,
    that is, sharing contact implementation, the source application has to initiate
    the sharing process. The content sharing scenarios described in this book are
    about target applications accessing the content via the source application.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows Runtime, applications interact with each other or with the operating
    system through the usage of so-called application contracts. With the help of
    contracts, applications can immerse into the runtime and get one step closer to
    become part of the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The same functionality is achieved by the implementation of the base `ContentProviders`
    on Android and the implementation of document provider extensions on the iOS platform.
  prefs: []
  type: TYPE_NORMAL
- en: File pickers and contracts (Windows Store apps)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most commonly used contracts is the File Open Picker contract on
    Windows Runtime. In this contract implementation, the source application has to
    implement the activation strategy for when it is called to provide file content
    for the target application. When the target application requires a certain type
    of file, the runtime lists all possible source applications that declares this
    type in their app manifest (for example, on a Windows Phone, when you want to
    attach a document on the mail client together along with a picture, the OneDrive
    application is displayed as one of the possible sources).
  prefs: []
  type: TYPE_NORMAL
- en: The user then selects the file that they want to use in the current application
    and the provider app is responsible for either creating or providing the file
    to the target application.
  prefs: []
  type: TYPE_NORMAL
- en: '![File pickers and contracts (Windows Store apps)](img/B04693_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: File picker contract in Windows Runtime
  prefs: []
  type: TYPE_NORMAL
- en: In this methodology, the file does not necessarily need to be an actual document
    item, but it can be a conceptual one. For instance, if we were to implement the
    File Open Picker in the TravelTrace app, we would not need to use actual documents
    in the File Open Picker to provide content. The shared content items could be
    the previous trips that the user kept track of and the selected trip could provide
    a generated scrap book or a collage of images in an image format or as a PDF document
    according to the type of document that is being requested by the consumer app.
  prefs: []
  type: TYPE_NORMAL
- en: Document Provider extensions (iOS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Document Provider extensions (introduced in iOS 8) allow applications, that
    is, consuming applications) to access documents outside their application sandbox.
    Document Provider extensions are twofold. The Document Picker View Controller
    extension provides a UI implementation for the operating system to display whenever
    the source application is selected as a document source in the document picker
    view. However, the File Provider extension is responsible for providing the document
    level operations.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a provider extension, we can use the existing project template
    in Xamarin Studio.
  prefs: []
  type: TYPE_NORMAL
- en: '![Document Provider extensions (iOS)](img/B04693_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Document Picker extension project template
  prefs: []
  type: TYPE_NORMAL
- en: Once the project is created, we are responsible for creating the view on the
    storyboard and implementing `DocumentPickerViewController` so that the available
    files are listed on the UI when our application is selected to provide files.
    `DocumentPickerViewController` initially has two methods that require our attention.
    The `PrepareForPresentation` method receives the picker mode (`Import`, `Open`,
    `ExportToService`, or `MoveToService`) so the user interface can be prepared according
    to the requested operation. The `OpenDocument` method is implemented just for
    our convenience to demonstrate the fact that once the user selects a document,
    we should prepare the corresponding file URL and pass it onto the runtime using
    the `DismissGrantingAccess` method.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to keep in mind that the URL provided from our Document Picker
    extension should already point to an actual file, or we should go on to implement
    the Document File Provider extension that will provide the files when either the
    consuming app displays the document picker and the user selects the file or the
    consuming app opens the file directly using the cached URL.
  prefs: []
  type: TYPE_NORMAL
- en: In the Document File Provider extension project, the crucial implementation
    is located in the `StartProvidingItemAtUrl` method. This method uses the `FileCoordinator`
    class provided to create the file at the target URL (for example, generates the
    file or downloads it from a remote location).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After the implementation of the extensions is complete, we have to prepare the
    project metadata entries. Each project (both extensions and the container application)
    needs to make use of the **App Groups** capability. This capability needs to be
    set up in the **Entitlements** option list. Other settings involve the base document
    storage URL, type of operations supported for the document picker, and so on.
    However, these configuration values are inserted in the `Info.plist` option list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Document Provider extensions (iOS)](img/B04693_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Entitlements for Document Provider extensions
  prefs: []
  type: TYPE_NORMAL
- en: In order to add the extensions to the containing application, the only thing
    we need to do is to add them as references to the main project. If you look at
    the project file of the main project, you will notice that the references are
    added with the `IsExtension` flag set to true.
  prefs: []
  type: TYPE_NORMAL
- en: ContentProvider and ContentResolver (Android)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Content providers on Android platform act as data repositories. These repositories
    are exposed to consuming applications through structured endpoint descriptions
    (similar to REST endpoints on web services). Using the metadata provided, providers'
    content is resolved by the consuming app through the implementation of `ContentResolvers`.
    Using content providers, applications can expose well-known data types such as
    contact list photos or calendar events, as well as custom data types and formatted
    data.
  prefs: []
  type: TYPE_NORMAL
- en: On the consumer side of this infrastructure, there are many content providers
    already implemented by default on Android runtime, such as `Contacts`, `MediaStore`,
    `UserDictionary`, and so on. These providers can be accessed by implementing base
    classes such as `ContentResolver` and `CursorAdapter`. `CursorAdapter` is used
    to feed the data that is retrieved by `ContentResolver` to a UI list view control.
    The `ContentProvider` API operations can involve list queries and CRUD operations
    on individual records.
  prefs: []
  type: TYPE_NORMAL
- en: Provider applications are responsible for registering an authority that is unique
    to the application. The authority entry can be described as the base content URI
    for a specific application. Either it can be added to the manifest file, or an
    attribute entry could be used on the class that is implementing `ContentProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Another important piece of metadata that the content provider needs to provide
    is the Mime-Type information. In order to facilitate the use of `CursorAdapter`
    on consumer applications, the content provider needs to provide a Mime-Type for
    a list of items (starting with `vnd.android.cursor.dir`) as well as for a single
    item (starting with `vnd.android.cursor.item`).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the content provider needs to expose the data columns for the data
    that is being made available to other applications. This is achieved by hiding
    the `InterfaceConstants` nested class from the base abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Another optional implementation would be to create a `UriMatcher` class that
    could ease the implementation process for the query methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The final implementation is related to the query, update, insert, and delete
    methods. Each of these methods needs to return the `ICursor` implementations according
    to the abstract class defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Overall, while providing more flexibility for content sharing, Android makes
    it a little more difficult for other applications to consume the data provided
    by the source application. The data provided by a content provider implementation
    on a Xamarin.Android application cannot be consumed by another without a specialized
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Peripherals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss several communication protocols that enable
    applications to communicate with other platforms and other devices.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Bluetooth communication protocol has become an invaluable feature on mobile
    devices. Especially with the emerging technologies related to **IoT** (**Internet
    of Things**), and various accessories we use in daily life, our dependency on
    the Bluetooth stack on mobile platforms has increased.
  prefs: []
  type: TYPE_NORMAL
- en: While Xamarin.Android applications and Windows Runtime applications can make
    use of both GATT (Bluetooth Low Energy) and RFCOMM (Bluetooth Serial), iOS applications
    can only communicate through the Bluetooth LE protocol. The main reason for this
    discrepancy is the fact that Android and Windows Runtime implement the serial
    communication port according to shared specifications. However, Apple implements
    a propriety communication stack using an encryption system. This, unfortunately,
    limits the serial communication to between only Apple produced/compliant accessories
    or devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Xamarin.Android, Bluetooth APIs reside in the `Android.Bluetooth` namespace.
    Using the provided classes, developers can enhance their applications with features
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for discoverable Bluetooth devices (including LE protocol)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting information on the local BT adapter and paired devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Serial Communication Sockets using the RFCOMM protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acting both as a GATT client or a GATT server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bluetooth protocols can be accessed only with the user permission manifest entry
    for Bluetooth.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: On Windows Runtime, Bluetooth-related features are implemented in the `Windows.Devices.Bluetooth`
    namespace. Similar to the feature-set in Android, Windows Runtime Bluetooth stack
    requires the applications to declare the adapter access requirement and the protocol
    to be used in the application manifest (for some specific devices and protocols,
    the Bluetooth capability declaration has to be inserted manually into the manifest).
    An important feature on this platform is that the Bluetooth connectivity can be
    facilitated and kept alive by background tasks, enabling the devices to continue
    their operations in the backgrounded or suspended states.
  prefs: []
  type: TYPE_NORMAL
- en: For Xamarin.iOS, Bluetooth LE related implementations would need to use the
    `CoreBluetooth` framework.
  prefs: []
  type: TYPE_NORMAL
- en: An important component that is currently in the Xamarin store for cross-platform
    peripherals integration is the Monkey.Robotics project. While implementing the
    basic APIs for Bluetooth LE and Wi-Fi, some other vendor-specific peripherals,
    such as health monitoring devices and smart watches, can be used with this component.
  prefs: []
  type: TYPE_NORMAL
- en: Wi-Fi Direct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wi-Fi Direct is another communication protocol that allows Wi-Fi enabled devices
    to create **peer-to-peer** (**P2P**) networks and exchange information using the
    Wi-Fi adapter without using a common provider network connection.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the Xamarin target platforms that are described in this book, only the
    Android platform supports this protocol. The Windows 10 platform will support
    Wi-Fi Direct; however, this implementation will be targeting only Windows based
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: On Android devices, with the introduction of Wi-Fi P2P, developers can create
    applications that can communicate with higher speeds and through much longer distances
    than with Bluetooth adapters. Wi-Fi P2P features were introduced in Android 4.0
    (API level 14) and they comply with the Wi-Fi Alliance's Wi-Fi Direct standards.
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to use this feature, the application manifest should contain
    permissions for `ACCESS_WIFI_STATE`, `CHANGE_WIFI_STATE`, and `INTERNET`.
  prefs: []
  type: TYPE_NORMAL
- en: Access to these services is provided with the WifiP2pManager, which is located
    in the Android.Net.Wifi.P2P namespace. Using this manager, applications can broadcast,
    create groups, request peers, and developers can create applications that can
    communicate over P2P sockets via Wi-Fi Direct.
  prefs: []
  type: TYPE_NORMAL
- en: Near Field Communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Near Field Communication** (**NFC**) protocol provides an easy alternative
    to Bluetooth for pairing and advertising scenarios (for example, NFC tags). With
    NFC, it is possible to create sockets and transfer data between mobile devices
    that are in proximity to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the NFC protocol is another unsupported communication protocol
    on iOS devices. (Reports suggest that iPhone 6 technically has the ability to
    use this protocol; however, this API is not made available to developers.)
  prefs: []
  type: TYPE_NORMAL
- en: The NFC stacks on Windows Phone and Android devices, however, implement most
    of the same profiles. In essence, it is technically possible to communicate over
    NFC across Windows and Android devices in proximity (by default, the tap and send
    feature works as a cross-platform feature). In spite of the fact that Windows
    devices use a propriety messaging scheme (`Windows:`), there are third-party frameworks
    for NDEF. NDEF is a cross-platform messaging scheme that is currently the default
    for Android.
  prefs: []
  type: TYPE_NORMAL
- en: Location data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, geo-context (location awareness) is becoming more and more crucial
    for applications, especially the ones running on mobile platforms. For instance,
    search engines optimize results according to the location information they gather
    from the client platform, social media and photo applications add geo-tags to
    posts and media items, and there are many more use cases for the data about *not
    how or on which platform the application is running, but where*.
  prefs: []
  type: TYPE_NORMAL
- en: On Xamarin platforms, the location information is provided making use of several
    different sources. The most accurate of these sources is **GPS** (**Global Position
    System**). This option consumes the most power and, generally, is only available
    for foreground applications. Other options that can provide somewhat less accurate
    data are network providers such as Wi-Fi or Cellular data. iBeacon is another
    technology introduced by Apple and applicable to iOS 7+ devices. iBeacon-compatible
    devices transmit location information using the Bluetooth LE protocol, and this
    transmission is then used by the Bluetooth adapter on mobile phones and tablets.
  prefs: []
  type: TYPE_NORMAL
- en: On Xamarin target platforms, location information can be accessed both proactively
    and through system events and triggers. In each platform, access to a location
    is limited by the privacy settings and it is always up to the user whether a certain
    (or every) application can access the location services.
  prefs: []
  type: TYPE_NORMAL
- en: Android location and Google Play services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In early versions of Android runtime, the `android.location` API was the framework-designated
    module for adding location awareness to applications. However, after the release
    of Google Play Services SDK (compatible with Android v2.2, API level 8, or higher),
    location APIs provided by Google became the preferred way to access location data
    on Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: '`LocationManager`, a `LocationServices` implementation, is a system-wide service
    and can be accessed through the application context in Xamarin.Android applications.
    In order to get location information, the application has to subscribe to the
    location updates with an implementation of `ILocationListener`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the location listener interface, there are several events that can be utilized.
    Other than the location change information, developers are provided with the updates
    related to different location provider status changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple location listener implementation used in the previous example would
    resemble this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The listener interface can be implemented on the current `Activity` itself or
    any other `JavaObject` class implementation. Using the backgrounding techniques
    defined in [Chapter 3](ch03.html "Chapter 3. Asynchronous Programming"), *Asynchronous
    Programming*, the listener interface can also be implemented on a custom started
    service and the application can receive background updates on the location changes
    through the service data directly (bound scenario) or through information persisted
    by the service.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing location information can be difficult on mobile applications. In order
    to facilitate GPS data testing and diagnostics, Android Emulator in Android SDK
    and Visual Studio Android Emulator are equipped with location emulation functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '![Android location and Google Play services](img/B04693_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Emulating a car travelling on a route
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Android Emulator also provides features to emulate the usage of
    an automobile, or other means of transport, on a route or GPS location changing
    according to the defined pins with defined intervals.
  prefs: []
  type: TYPE_NORMAL
- en: On top of the location information, using the location provider status information,
    location info can be gathered in a more efficient and reliable way (for example,
    switching between GPS and network provided information according to connectivity
    and requirement for accuracy). In order to get the optimal provider that is currently
    available for the application scope, you can use the `GetBestProvider` method
    with the desired criteria for accuracy (Coarse or Fine Location Info) and for
    power consumption (high, medium, and low).
  prefs: []
  type: TYPE_NORMAL
- en: This intelligent switch between location data providers is the main advantage
    of using the Fused Location Provider (Google Play Services SDK) and Google Location
    Services over the default location API.
  prefs: []
  type: TYPE_NORMAL
- en: '![Android location and Google Play services](img/B04693_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Google Play services Xamarin components
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin binding libraries to Google Play Services SDK, which are available as
    components for Xamarin.Android v4.8+ developers, provide an easy way to integrate
    various services, including location APIs, into Xamarin.Android applications.
    These components implement the Java Binding projects and take care of the cumbersome
    implementation and compilation of the Google provided Android libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the Google Play services'' location component, while trying
    to build the Xamarin.Android application, you might receive a compilation error
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"No resource found that matches the given name (at ''value'' with value ''@integer/google_play_services_version'')."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The reason for this error is the fact that the Xamarin component is dependent
    on the Google Play Services SDK and the SDK modules are supposed to be installed
    manually using the Android SDK Manager.
  prefs: []
  type: TYPE_NORMAL
- en: '![Android location and Google Play services](img/B04693_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Android Google Play SDK
  prefs: []
  type: TYPE_NORMAL
- en: After installing the SDK module, the Xamarin.Android application can be built
    without errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the setup and configuration is complete, the `GoogleApiClient` class can
    be initialized and used in Xamarin applications. `GoogleApiClient` requires the
    implementation of two interfaces to gather information about the client connection
    status: `GoogleApiClient.IConnectionCallbacks` and `GoogleApiClient.IOnConnectionFailedListener`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the application you are implementing does not depend on continuous updates
    of location data, but rather just the current location, you can use the `GetLastLocation`
    method provided on the `GoogleApiClient`. This method provides a one-time reading
    option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In order to receive real-time updates with the fused location provider, you
    must implement the `ILocationListener` interface for the Google Location Services
    API. This listener is different from the default one; it only contains a single
    event handler implementation for location changes. The events related to the data
    providers do not need to be implemented since the fused location provider itself
    is responsible for smart switching between the location data providers.
  prefs: []
  type: TYPE_NORMAL
- en: Although the type of provider and provider status changes are not relevant for
    us using the fused location provider, it is still possible to let the fused provider
    know which type of accuracy and priority our application scope demands. For this
    purpose, we can use the `SetPriority` method with the appropriate flag on `LocationRequest`
    while subscribing to the location updates.
  prefs: []
  type: TYPE_NORMAL
- en: '**High accuracy (100)**: Requests the finest location available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Balanced power/accuracy (102) (default)**: Requests the `block` level accuracy
    (~100m accuracy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low power (104)**: Requests the `city` level accuracy (~10km accuracy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No power (105)**: Sets the location updates to use passive mode; waits for
    location updates delivered to other client applications (also known as **piggybacking**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As well as the priority, a fused location provider lets developers set other
    important delineations of location updates, such as minimum interval, smallest
    displacement, and expiration time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, Google Play services are only preinstalled on Android SDK emulator
    and for the other emulators, the Google applications package has to be downloaded
    and installed on the emulator image.
  prefs: []
  type: TYPE_NORMAL
- en: Location services on iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the iOS platform, the location data is accessed through the `CoreLocation`
    library, and similar to the android location API, location changes are sent to
    the subscribing application with the help of event delegates. The `CLLocationManager`
    class makes it a trivial task to get location data updates from the mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Xamarin.iOS location data access implementation starts with creating the
    required `Info.plist` entries, which will explain why the application requires
    access to the user''s location. In order to do this, we have to edit the Info.plist
    file, adding one or both of the following entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Location services on iOS](img/B04693_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Info.plist entries for location info
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the Info.plist entry, you should also keep in mind that starting
    with iOS 8, applications have to explicitly ask for permission to use the location
    data. In order to get consent from the user, the location manager exposes two
    methods: one for authorizing the app for continuous local data updates and the
    other one just to be used when the application is in the foreground.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can subscribe to the `LocationsUpdated` event to receive the latest
    location update information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The location information can be further optimized for the application scope
    using the exposed criteria properties and methods. It is also possible to retrieve
    other types of information such as heading direction. However, it is important
    to first check if the service is available and request updates according to the
    system status information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Location data on Windows Runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On Windows Runtime (Windows Store apps), the `Windows.Device.Geolocation` namespace
    is dedicated for tracking the device's location over time. The `Geolocator` class
    replaces the main access points in the previous platforms and can give on-demand
    data and information updates through events.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to iOS access request, the application can request consent from the
    application user with the `RequestAccessAsync` method and according to the response,
    methods or events can be accessed through the `Geolocator` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Geofencing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A geofence is an abstract boundary that can be defined with location services
    so that the application which created the geofence receives an update from the
    mobile device whenever the user is entering or exiting this boundary. This eliminates
    the need for polling for the location info and opens up different implementation
    opportunities for mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: The use cases for geofences vary from simple reminders on certain locations
    to virtual tours created by showing certain images or information according to
    the current region.
  prefs: []
  type: TYPE_NORMAL
- en: All the Xamarin target platforms support the creation and usage of geofences.
    For instance, in order to create a geofence on an iOS platform, we would need
    to use `CLCircularRegion` and the location monitoring feature of the `CoreLocation`
    library. There are two events of interest that are fired when the mobile device
    enters and exists in the region.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This implementation creates a geofence around the described region (with a center
    defined by the coordinates and a radius of 600 m) and sends out a notification
    when the specified fence is entered, giving information about the location.
  prefs: []
  type: TYPE_NORMAL
- en: '![Geofencing](img/B04693_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Old town geofence
  prefs: []
  type: TYPE_NORMAL
- en: The same implementation on Android platform would use `LocationServices` in
    conjunction with the `GeofenceBuilder` class to create `IGeofence` type boundaries
    and add them to the watch list. One important difference on the Android platform
    is that the events are handled through delegates and are generally implemented
    by an intent service.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation starts with creating `GoogleApiClient` like in the previous
    examples, and once the API client is connected, we can go ahead and create the
    geofence(s) and the intent service that is going to handle the callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The intent service implementation for sending out a local toast notification
    on location updates would look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The classes used by Windows Store apps for geofences are the `GeofenceMonitor`
    and `Geofence`/`GeoCircle` descriptive classes. A simple `Geofence` class would
    consist of a `Geocircle` class and the associated ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once the geofence is initialized, we can use the `GeofenceMonitor` class to
    add the geofence and subscribe to the events.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to use the geofence status change events as triggers for
    a background task so that the registering application does not need to be in the
    foreground or even in the running state.
  prefs: []
  type: TYPE_NORMAL
- en: Native libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In spite of the fact that the Xamarin framework and .NET core implementations
    on Xamarin.Android and Xamarin.iOS platforms provide a vast amount of features,
    in some cases it is unavoidable to include native code in cross-platform implementations.
    Fortunately, it is possible to bind or link native libraries on both of these
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Managed callable wrappers (Android)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in previous chapters, managed callable wrappers are generated managed
    code libraries which provide a way to interact with the Java Runtime over the
    JNI bridge to execute code from certain Java libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Java libraries are often packaged in Java archive files (JAR files) and it is
    possible, using the compiled Java library project, to create a binding library
    which can be included in Xamarin.Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: In order to demonstrate this usage, we will be creating a MCW for a simple JSON
    parsing library. The first step of creating our binding library would be to use
    the built-in project template to create our binding project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Managed callable wrappers (Android)](img/B04693_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Binding library project
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the binding project is created, we can copy the JAR into the created Jars
    folder in the binding project. After the copying is completed, an important step
    would be to check the **Build Action** configuration for the JAR resource. The
    copied JAVA library files can be used in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**InputJar**: This is a Java library archive that is going to be used to generate
    the managed wrapper.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ReferenceJar**: This is a Java library archive that is only going to be used
    as a reference and not to generate a wrapper.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Managed callable wrappers (Android)](img/B04693_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Binding library structure and build action
  prefs: []
  type: TYPE_NORMAL
- en: After setting the **Build Action** field to `InputJar` (this simple library
    does not have any dependencies), we can build the library project. Once the build
    is successful, you can see the generated managed files in the `<Project Directory>\obj\Debug\generated\src`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the main parser file, you will notice that the definition for a class
    consists of an Android runtime registration and a class deriving from a Java object.
    Metadata about the class or class members also has a metadata comment, which defines
    the path of the item in the Java library package.
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to change the name of a namespace (by default, they are generated
    from the package names defined in the `api.xml` file), or the name of any members
    of a class or the class itself, we could make use of the `Metadata.xml` file that
    is located in the bindings project. The `Metadata.xml` file contains transforms
    on the api.xml document that is generated from the jar files. This API description
    document contains the class definitions and components in a format similar to
    that of GAPI that is used by mono compiler. With the transforms included in the
    Metadata.xml, we can redefine the managed names designated for the generated C#
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in order to change the namespace, we would use a description
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For changing the class names, the syntax is quite similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the generated class declaration would look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Linking versus binding (iOS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While dealing with native code on the Xamarin.iOS platform, there are several
    options developers can use.
  prefs: []
  type: TYPE_NORMAL
- en: If we were dealing with simple static utility libraries on C or Objective-C,
    it is possible to create so-called **fat binaries** and then link them at the
    compile time. Later in Xamarin runtime (remember there is no Xamarin runtime in
    iOS, everything is compiled into static code), methods from the native library
    can be invoked using the P/Invoke functionality in the Xamarin framework.
  prefs: []
  type: TYPE_NORMAL
- en: The other option, which enables users to create a stronger "bridge" (at the
    cost of performance) with native libraries, is to create bindings to Objective-C
    classes and methods. Using this approach, similar to managed callable wrappers
    in Android runtime, we would need to create a C# wrapper over the Objective-C
    framework library and use the managed wrapper to access the native implementation.
    Even though this approach creates a more intuitive and manageable access point
    to native code, since the managed wrapper is, in essence, a high-level implementation
    and the mono compiler actually generates the P/Invoke and Imports for accessing
    native functionality, it is inherently a little more costly than native linking.
  prefs: []
  type: TYPE_NORMAL
- en: Both implementations require the creation of the fat binary as a starting point.
    A fat binary is the colloquial term used to describe binary packages that contain
    native binary compilations for all possible CPU architectures (i386 for the Simulator
    and ARMv7/ARM64 for the devices). In order to create the universal binary that
    is suitable for use in all iOS development targets, one needs to make use of the
    command-line utility in Mac OS X.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After the universal binary is created, you can now copy the universal package
    into a project folder in the Xamarin.iOS application, set the build action to
    **None**, and instruct the mtouch compiler to link the binary in compile time.
    For build instructions, you would need to use the build arguments section in project
    properties and gcc flags.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Additional parameters might need to be included according to the frameworks
    being used or if the binary includes C++ code (for example, the `–cxx` flag for
    C++ code).
  prefs: []
  type: TYPE_NORMAL
- en: 'The other option is to create a `LinkWith` declaration (in most cases, this
    is created automatically) in an Objective-C binding project. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In an Objective-C binding project, you must first familiarize yourself with
    the types, methods, and other constructs in the native library to be able to start
    implementing the responding managed types in the binding library.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objective Sharpie is a useful tool for creating managed wrappers for Objective-C
    libraries. Initially, an internal tool used by the Xamarin team, it soon was released
    to public. Even though the implementation is not complete and it is not fully
    supported as an official product, it can help accelerate the implementation against
    native libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about some platform-specific features related to
    inter-app communications, peripherals, and location data.
  prefs: []
  type: TYPE_NORMAL
- en: Using platform-specific features can make your applications more attractive
    to platform users by providing scenarios that they are familiar with and increase
    the native look and feel of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific features related to different communication protocols, such
    as Bluetooth, NFC, and Wi-Direct, can be employed for various scenarios. However,
    most of the protocols and profiles described here target Android and Windows Phone.
    Xamarin.iOS applications can only benefit from the Bluetooth LE profile.
  prefs: []
  type: TYPE_NORMAL
- en: Location awareness is another platform-specific implementation that all mobile
    applications can benefit from. By adding a location context to the business logic
    of applications, developers can create a more personalized experience for users.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if needed, Xamarin provides important features for binding and linking
    native libraries for Android and iOS platforms, which transform a complex porting
    task into merely imports.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the user interface components on different
    platforms and how they correlate with each other.
  prefs: []
  type: TYPE_NORMAL
