- en: Chapter 5. Advanced Concurrency Support in F#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. F# 的高级并发支持
- en: We now have a basic understanding of F# concurrency features, including using
    and implementing the best practices of F# asynchronous workflow, and combining
    the asynchronous workflow with .NET APM, EAP, and TAP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对 F# 的并发特性有了基本了解，包括使用和实现 F# 异步工作流的最佳实践，以及将异步工作流与 .NET APM、EAP 和 TAP 结合使用。
- en: We have seen that `Control.Async` is the basic building block of all related
    asynchronous workflows, in terms of using it and also carefully deciding the best
    practices of using a returned object, especially when we have a nice construct
    of Disposable pattern in the asynchronous workflow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 `Control.Async` 是所有相关异步工作流的基本构建块，在它的使用和仔细决定返回对象的最佳实践方面，尤其是在异步工作流中有很好的可处置模式时。
- en: Know only that the asynchronous workflow features in F# are not unique, in that
    C#/VB already has them, and C#/VB's `async` construct is actually inspired by
    F#. We can further harness the F# advanced asynchronous workflow implementation
    of `MailboxProcessor`, as part of learning and leveraging the advanced concurrency
    support in F#.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 只要知道 F# 中的异步工作流特性并不独特，因为 C#/VB 已经有这些特性，而且 C#/VB 的 `async` 构造实际上受到了 F# 的启发。我们可以进一步利用
    F# 高级异步工作流实现中的 `MailboxProcessor`，作为学习和利用 F# 高级并发支持的一部分。
- en: Again, we will see that there are no silver bullets for all kinds of concurrency
    problems. We shall see this fact applies to `MailboxProcessor` usage and implementation
    as well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，对于各种并发问题，没有一劳永逸的解决方案。我们将看到这一事实同样适用于 `MailboxProcessor` 的使用和实现。
- en: This chapter describes the advanced concurrency features of F#, focusing on
    F# 4.0\. We are also introducing an overview of best practices to implement and
    optimize, such as combining asynchronous and parallelism, the F# message passing
    agent of `MailboxProcessor`, and further interoperability with .NET TPL.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了 F# 的高级并发特性，重点关注 F# 4.0。我们还介绍了实现和优化的最佳实践概述，例如结合异步和并行性、F# 的 `MailboxProcessor`
    消息传递代理，以及与 .NET TPL 的进一步互操作性。
- en: 'The introduction to concurrency in F# is covered in the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: F# 并发介绍的介绍
- en: Using F# `MailboxProcessor`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 F# `MailboxProcessor`
- en: Interoperability with .NET Task Parallel Library (TPL)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 .NET Task Parallel Library (TPL) 的互操作性
- en: Introduction to asynchronous workflows
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步工作流的介绍
- en: Using F# MailboxProcessor
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 F# MailboxProcessor
- en: F# has extensive features of asynchronous operations such as the way it uniquely
    separates and differentiates from other .NET-managed languages, such as C#/VB,
    Managed C++, Nemerle, IronPython, and IronRuby. But at the same time, it runs
    on top of .NET CLR, providing high compatibility with other languages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: F# 具有广泛的异步操作特性，它独特地与其他 .NET 管理语言（如 C#/VB、Managed C++、Nemerle、IronPython 和 IronRuby）区分开来。但与此同时，它运行在
    .NET CLR 之上，与其他语言具有高度的兼容性。
- en: F#'s own unique asynchronous features are not just the asynchronous workflows;
    it has a class that acts as a message passing agent or actor, `MailboxProcessor`.
    The `MailboxProcessor` feature was introduced at the same time as asynchronous
    workflow was released, and the implementation of `MailboxProcessor` itself is
    actually an implementation of a set of asynchronous workflows.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: F# 自身独特的异步特性不仅包括异步工作流；它还有一个充当消息传递代理或角色的类，`MailboxProcessor`。`MailboxProcessor`
    功能是在异步工作流发布的同时引入的，而 `MailboxProcessor` 本身的实现实际上是一组异步工作流的实现。
- en: Background case of having message agent
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息代理的背景情况
- en: The advantage of having an asynchronous model is the fact that we don't have
    to wait for the operation or task to be completely finished before doing something
    else, especially the next operations. The advantage that we don't have to wait
    for the completion of a task is related to the illustrations of blocking operations
    that we mentioned in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction
    to Concurrency in F#"), *Introduction to Concurrency in F#*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 异步模型的优势在于我们不必等待操作或任务完全完成后再做其他事情，尤其是接下来的操作。不必等待任务完成的优势与我们之前在 [第 4 章](fsp-hiperf_cu04.html#aid-11C3M2
    "第 4 章. F# 并发介绍") 中提到的阻塞操作示例相关。
- en: Introducing fire and forget pattern
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍“火速执行”模式
- en: The most common example of blocking operations is the I/O operation. This may
    include any network operation, including any data transfer-either incoming or
    outgoing. These data transfers take in many forms, ranging from a simple PING
    call (ICMP packets) to complex operations such as uploading files and sending
    emails. The operations, in most cases, are not guaranteed to have responses immediately
    and in many cases *don't need to have replies* as well. Some of the obvious cases
    need responses as soon as possible since most cases have operations that need
    real-time responses when the operations are in session.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞操作最常见的例子是I/O操作。这可能包括任何网络操作，包括任何数据传输——无论是传入还是传出。这些数据传输形式多样，从简单的PING调用（ICMP数据包）到复杂的操作，如上传文件和发送电子邮件。在大多数情况下，操作不能保证立即有响应，而且在很多情况下*也不需要响应*。一些明显的情况需要尽快响应，因为大多数情况下，当操作在进行时，需要实时响应。
- en: 'We can simply conclude that it is intuitive that asynchronous operations can
    be categorized further in terms of the necessity for responses:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地得出结论，异步操作可以根据响应的必要性进一步分类：
- en: Operations that are invoked by an external party and that don't need to have
    a response/reply back. In many cases, we can simply ignore the status of the completion;
    this is often called the *fire and forget* pattern or model. Once it is fired,
    we can simply forget about waiting for the reply, for example, when sending emails
    or sending commands as messages to an external party or agents expected to execute
    actions based on the commands.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由外部方调用的操作，且不需要响应/回复。在许多情况下，我们可以简单地忽略完成状态；这通常被称为*火焰和遗忘*模式或模型。一旦触发，我们就可以简单地忘记等待回复，例如，在发送电子邮件或将命令作为消息发送给外部方或预期根据命令执行操作的代理。
- en: Operations that are invoked by an external party or an internal process on your
    machine that needs a reply after the operations are completed, for example, when
    uploading files or downloading web content, the calling execution needs to be
    notified if the operation is completed. Another example is waiting for an elapsed
    event on a timer in the .NET EAP model. This is often (generally) called **Promises
    model**, in the form of callbacks. We have already covered this in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2
    "Chapter 4. Introduction to Concurrency in F#"), *Introduction to Concurrency
    in F#*.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由外部方或机器内部进程调用的操作，在操作完成后需要响应，例如，在上传文件或下载网页内容时，如果操作完成，调用执行需要得到通知。另一个例子是在.NET EAP模型中的计时器上等待超时事件。这通常（通常）被称为**承诺模型**，以回调的形式出现。我们已经在[第4章](fsp-hiperf_cu04.html#aid-11C3M2
    "第4章。F#并发简介")中介绍了这个模型，即*F#并发简介*。
- en: Both of these are still categorized as asynchronous because of the simplicity
    of not having to wait, and it's also highly predicted to have a non-blocking behavior.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都仍然被归类为异步，因为不需要等待，而且高度预测为非阻塞行为。
- en: 'Examples of fire and forget pattern (from simple to complex) are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 火焰和遗忘模式（从简单到复杂）的例子如下：
- en: Sending emails through SMTP.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SMTP发送电子邮件。
- en: Sending network broadcast messages.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送网络广播消息。
- en: Sending commands to a network printer queue server. This is different from sending
    a command directly to a connected network printer that has to reply, at least
    giving status updates of the out-of-paper status to print job completion.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向网络打印机队列服务器发送命令。这与直接向需要响应的已连接网络打印机发送命令不同，至少需要提供打印作业完成时的缺纸状态更新。
- en: Not all commands sent to a printer are always fire and forget. There are many
    cases where sending commands to a printer, especially sending commands to a printer
    directly connected to our machine, are not fire and forget.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有发送给打印机的命令都是火焰和遗忘。有很多情况，发送给打印机的命令，尤其是发送给直接连接到我们机器的打印机的命令，并不是火焰和遗忘。
- en: The operation of sending this command is usually asynchronous, with callbacks
    to notify the status of the finished/completed job.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 发送此命令的操作通常是异步的，通过回调来通知完成/完成的作业状态。
- en: On an OS such as Windows, sending a command to devices directly connected to
    our machine always requires replies or responses because it is expected that we
    have a response at least showing the status of the device in real time. It is
    normal to have this assumption as a requirement as the printer is directly connected
    to our machine and is also not shared. This is the reason why it is not part of
    fire and forget.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Windows 这样的操作系统上，向直接连接到我们机器的设备发送命令始终需要回复或响应，因为预期我们至少会有一个响应来显示设备在实时状态。将此假设作为要求是正常的，因为打印机直接连接到我们的机器，并且也不是共享的。这就是为什么它不是“火速遗忘”的一部分。
- en: For example, on Windows, all printing operations are handled by the Windows
    Printing API on top of the printer's device driver. In the implementation of the
    Printing API, the commands sent to the printer have the requirement of the availability
    of any printing device installed. It does not care about how many printers are
    installed; it only cares about the status of any printing device available, by
    always querying the availability of a printing device using a Windows Message
    (the `WM_XXX` API) in an event of *message loop*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Windows 上，所有打印操作都由打印机设备驱动程序之上的 Windows 打印机 API 处理。在 Printing API 的实现中，发送给打印机的命令要求任何已安装的打印设备可用。它不关心安装了多少打印机；它只关心任何可用打印设备的状态，通过在
    *消息循环* 事件中始终使用 Windows 消息（`WM_XXX` API）查询打印设备的可用性。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The term *message* in this message loop is different from the message in a
    message queue: the message is an encapsulation of a known system event to ease
    communication of system events. It always happens in loops and can be in the form
    of a looping queue (circular queue), instead of a queue in a message agent that
    does not operate in a loop (open ended queue).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在此消息循环中使用的术语 *message* 与消息队列中的消息不同：消息是已知系统事件的封装，以简化系统事件的通信。它总是在循环中发生，可以是以循环队列（循环队列）的形式，而不是在消息代理中不进行循环操作（开放式队列）的队列。
- en: 'For more information about the Windows message loop of Windows API, consult
    the MSDN Library at:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Windows API 中 Windows 消息循环的更多信息，请参阅 MSDN 库：
- en: '[https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927(v=vs.85).aspx)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927(v=vs.85).aspx)'
- en: 'It is common in Windows API to have this message loop of calling `GetMessage`,
    coded like this (this code is in C++):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows API 中，这种调用 `GetMessage` 的消息循环是常见的，代码如下（此代码是用 C++ 编写的）：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code will always loop by examining any incoming Windows `WM_XXX`
    messages. It will end the loop if there are implied errors, especially system
    errors. This common practice is also used in built-in Windows applets, such as
    the applets in the Control Panel (compiled as `.cpl`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将通过检查任何传入的 Windows `WM_XXX` 消息来循环。如果有隐含的错误，特别是系统错误，它将结束循环。这种常见的做法也用于内置的
    Windows 小工具，例如控制面板中的小工具（编译为 `.cpl`）。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can also implement the code of handling Win32 message loops in F#, but then,
    we have to hook into Win32 API calls by defining the entry point to Win32 API
    using P/Invoke. The P/Invoke declaration is required, but then, F# may lose HWND
    context if the message loop is handled within a non-UI thread. It is highly recommended
    to handle the Win32 message loop in a separate UI thread by explicitly executing
    it as invoking delegates. But interoperatibility with Win32 message API is beyond
    the scope of this book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 F# 中实现处理 Win32 消息循环的代码，但这样，我们必须通过使用 P/Invoke 定义 Win32 API 的入口点来挂钩 Win32
    API 调用。P/Invoke 声明是必需的，但这样，如果消息循环在非 UI 线程中处理，F# 可能会丢失 HWND 上下文。强烈建议通过显式执行调用委托来在单独的
    UI 线程中处理 Win32 消息循环。但与 Win32 消息 API 的互操作性超出了本书的范围。
- en: The queue used in this context can be a combination of an ordinary queue and
    the usage of round-robin, or it can be a simple queue, such as first come first
    served, and the incoming message is queued at the last line of the queue but the
    queue line itself always *moves forward*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中使用的队列可以是普通队列和轮询使用的组合，或者它可以是简单的队列，例如先到先得， incoming message 是在队列的最后一行排队，但队列行本身总是*向前移动*。
- en: '**Round-robin** is one of the examples of queue handlings. But round-robin
    has its own overhead: it moves the pointer of the queue and also the data within
    the queue line. If this overhead pointer movement is executed in memory, the overhead
    cost might be deferred by high speed access to memory. This is why round-robin
    is also popular in the operating system world, from the use of the message loop
    to the scheduling of running processes, threads, and *coroutines*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮询**是队列处理的一个例子。但轮询有其自己的开销：它移动队列的指针以及队列行中的数据。如果这种开销指针移动在内存中执行，通过高速访问内存可能会延迟开销成本。这就是为什么轮询在操作系统世界中也很受欢迎，从消息循环的使用到运行进程、线程和*协程*的调度。'
- en: The coroutine is quite common in many platforms, including .NET, Windows, and
    UNIX. In .NET, a sample coroutine is the yield iterator's implementation detail
    in C#/VB and F#. In Windows, a sample of a coroutine is the implementation of
    *fibers* in Windows (since Windows 2000). However, fiber in Windows and coroutine
    in .NET are different in semantics.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 协程在许多平台上都很常见，包括.NET、Windows和UNIX。在.NET中，一个示例协程是C#/VB和F#中yield迭代器的实现细节。在Windows中，一个示例协程是Windows中*纤程*的实现（自Windows
    2000以来）。然而，Windows中的纤程和.NET中的协程在语义上有所不同。
- en: 'What is coroutine? There are many definitions of coroutines but not all of
    them are correct in the sense of the concurrency and runtime of any managed language/platform.
    The cleanest and simplest definition is available from the MSDN Library. Coroutine
    is defined as:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是协程？关于协程有很多定义，但并不是所有定义在并发和任何托管语言/平台运行时意义上都是正确的。最干净、最简单的定义可以在MSDN库中找到。协程被定义为：
- en: '*Coroutine is a method that can stop in mid-execution and provide a value to
    the caller without returning program flow.*'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*协程是一种可以在执行过程中停止并提供值给调用者而不返回程序流程的方法。*'
- en: 'This definition is taken from this MSDN Magazine on the MSDN Library:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义是从MSDN库上的MSDN杂志中摘录的：
- en: '[http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineSeptember2003en-us.chm](http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineSeptember2003en-us.chm)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineSeptember2003en-us.chm](http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineSeptember2003en-us.chm)'
- en: It is quite the same as yield, where yield can stop in the middle of the execution
    and will continue as needed. C#/VB/F# yield and Windows fibers are very good sample
    implementations of coroutine that can have multiple entries and exits, depending
    on the state we are handling.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它与yield非常相似，其中yield可以在执行过程中停止，并在需要时继续。C#/VB/F#的yield和Windows纤程是协程的很好示例实现，可以根据我们处理的状态有多个入口和出口。
- en: 'For more information about fiber in Windows API, visit:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于Windows API中纤程的信息，请访问：
- en: '[https://msdn.microsoft.com/en-us/library/windows/desktop/ms682661(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682661(v=vs.85).aspx)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/windows/desktop/ms682661(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682661(v=vs.85).aspx)'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: We are not going to dive further into the implementation detail of coroutine
    in .NET, especially on yield. The implementation detail of the yield iterator
    may change in the future .NET versions after .NET 4.6\. However, it is important
    to at least have a basic understanding of coroutine.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们不会进一步深入探讨.NET中协程的实现细节，特别是关于yield。在.NET 4.6之后的.NET版本中，yield迭代器的实现细节可能会发生变化。然而，至少对协程有一个基本理解是很重要的。
- en: A simple evidence of this message loop in action, always querying printing devices,
    can be seen in how Windows displays the current status of a print job in the Print
    Management applet in Windows 8/8.1 and Windows 10.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息循环在动作中的简单证据，总是查询打印设备，可以在Windows 8/8.1和Windows 10中打印管理小程序显示打印作业当前状态的方式中看到。
- en: 'The Print Management applet in the legacy Control Panel always displays the
    current status of any available installed and connected printers:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版控制面板中的打印管理小程序始终显示任何可用的已安装和连接打印机的当前状态：
- en: '![Introducing fire and forget pattern](img/image00293.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![介绍“火与忘”模式](img/image00293.jpeg)'
- en: The Printing API is also a good sample of Promises in action because a reply
    to notify that a print job is completed; it is a promise to at least give response
    that a print job is either completed or failed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打印API也是Promises在动作中的好例子，因为打印作业完成的回复；它至少是一个承诺，告知打印作业已完成或失败。
- en: Other samples of Promises are the same as those of TPL, .NET EAP and APM. Basically,
    the semantics are mostly in the form of a notification when the action is completed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Promise的其他示例与TPL、.NET EAP和APM相同。基本上，其语义大多以操作完成时的通知形式存在。
- en: There is a mixture of the f*ire and forget* model and the *Promises* model,
    although the promise in this mix may not be a true promise in the implementation
    details.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有fire and forget模型和Promise模型的混合，尽管在这个混合中的Promise在实现细节上可能不是一个真正的Promise。
- en: For example, we want to have an asynchronous way of processing any of the incoming
    transactions against savings accounts, and the transactions are expected to have
    commenced across many kinds of savings accounts. Even in the same bank, a person
    can have multiple accounts that may have traffic of incoming and outgoing transfers,
    either scheduled or manual.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们希望有一种异步方式来处理任何针对储蓄账户的传入交易，并且预计这些交易将在许多种储蓄账户之间开始。即使在同一银行，一个人也可以拥有多个账户，这些账户可能有进出的转账流量，无论是计划内的还是手动的。
- en: It is optional to notify that the incoming transfer is successfully credited
    to the account. And this is also a promise, although it is not mandatory to be
    enforced to notify back a successful transaction. If it is mandatory, then a reply
    will be sent back later. But this reply can be made using an event triggered when
    the incoming transfer has been calculated as credited into the account. At the
    implementation detail, the notification on the receiving agent is not mandatory
    after all; the customization may be added as an event trigger.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通知传入转账成功存入账户是可选的。这同样也是一个承诺，尽管强制通知成功交易不是必须执行的。如果是强制性的，那么稍后将会发送回复。但这个回复可以使用当传入转账被计算为已存入账户时触发的事件来实现。在实现细节上，接收代理上的通知最终并不是强制的；可以添加自定义的事件触发器。
- en: In the case of online e-commerce, the response is mandatory, as the transactions
    of any purchase must have a reply immediately, as close to real time as possible.
    Then the promise is enforced, although it is not a pure promise after all, as
    the receiver is using an event trigger for any incoming successful transaction
    that it will send a notification back to inform a failed/successful transaction.
    The wait for any incoming transaction is continuous. It is similar to always listening
    to any incoming signal of an incoming operation. Therefore it is also often simply
    called a *listener*, to always listen for any incoming transactions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线电子商务的情况下，响应是强制性的，因为任何购买的交易都必须立即回复，尽可能接近实时。然后承诺得到执行，尽管它最终并不是一个纯粹的承诺，因为接收者正在使用事件触发器来对任何成功的交易发送通知，告知交易失败/成功。对任何传入交易的等待是持续的。这就像始终在监听任何传入操作的信号。因此，它也通常简单地被称为*监听器*，以始终监听任何传入的交易。
- en: 'This difference of having a promise is illustrated in the following simplified
    flow:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简化的流程图，说明了拥有Promise的差异：
- en: '![Introducing fire and forget pattern](img/image00294.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![介绍fire and forget模式](img/image00294.jpeg)'
- en: In the previous illustration, the wait for an incoming transaction usually happens
    on an agent. In the case of a standalone message queue manager, it is also a sophisticated
    or standalone listener.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的说明中，对传入交易的等待通常发生在代理上。在独立消息队列管理器的情况下，它也是一个复杂或独立的监听器。
- en: This is also a good sample of an agent to handle the transaction in the form
    of messages that contain the operation request to withdraw, transfer, or even
    receive a money transfer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个很好的代理示例，用于处理包含操作请求（提款、转账，甚至接收转账）的消息形式的交易。
- en: 'Consider this sample scenario of this agent:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下这个代理的示例场景：
- en: 'A data wrapper with the necessary information about the operations (any related
    bank account transactions) to be carried out that is then processed by a centralized
    process that is to be sent while waiting for any incoming data to be consumed.
    Usually, all of the data sent and received is stored and processed with first
    come first served or **first in first out** (**FIFO**) in a data structure: a
    queue.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据包装器，包含有关要执行的操作（任何相关的银行账户交易）的必要信息，然后由一个中央处理过程处理，在等待任何传入数据被消费的同时发送。通常，所有发送和接收的数据都存储和处理，采用先到先服务或**先进先出**（**FIFO**）的原则，在一个数据结构：队列中。
- en: The agent must be as scalable as possible. It means it must be able to serve
    a large number of requests per second. The initial website is usually assumed
    to be able to serve 500 to 1,000 requests per second, so the initial projected
    maximum requests to be served is 1,000 requests.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理必须尽可能具有可扩展性。这意味着它必须能够每秒处理大量请求。初始网站通常假设能够每秒处理500到1000个请求，因此初始预计的最大请求量是1000个。
- en: In the preceding scenario, why does it have to be a queue?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的场景中，为什么它必须是一个队列？
- en: The agent was initially planned to serve more than 1,000+ requests at a time.
    There is no guarantee that the web server can serve more than 1,000 requests *at
    a time and at the same time*. In order to do this precisely, we have to be sure
    that at least 1,000 requests are sent and received at the same time. This means
    we must have parallel I/O at the heart of the hardware side, which is very expensive
    and very difficult to implement and set up. Therefore, having parallel I/O to
    enforce this simulation is not quite scalable for the current needs, and it's
    also not quite feasible in terms of implementation speed (time to implement) and
    scalability.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最初计划让代理一次处理超过1000+个请求。无法保证Web服务器能够同时处理超过1000个请求。为了精确地做到这一点，我们必须确保至少有1000个请求同时发送和接收。这意味着我们必须在硬件方面实现并行I/O，这非常昂贵，也非常难以实现和设置。因此，为了强制进行这种模拟，拥有并行I/O并不完全适合当前的需求，而且在实现速度（实现时间）和可扩展性方面也不太可行。
- en: If we are relying on the scalability of the available I/O throughput, this is
    not an option because pure hardware scalability has more initial expensive costs.
    If we rely on serving the requests optimally by increasing the number of CPU cores,
    this is also not an optimal solution. Web requests usually consume less on CPU
    and more on network (hence I/O) bandwidth. On the consumer of the requests, there
    can be a wait on the I/O side, and this can block the next request to be processed,
    although handling this can be optimized using the asynchronous workflow that we
    described in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction
    to Concurrency in F#"), *Introduction to Concurrency in F#*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们依赖于可用I/O吞吐量的可扩展性，这不是一个选择，因为纯硬件的可扩展性有更高的初始成本。如果我们依赖于通过增加CPU核心数量来最佳地处理请求，这也不是一个最佳解决方案。Web请求通常在CPU上消耗较少，而在网络（因此是I/O）带宽上消耗较多。在请求的消费者方面，可能在I/O侧有等待，这可能会阻塞下一个请求的处理，尽管可以使用我们在[第4章](fsp-hiperf_cu04.html#aid-11C3M2
    "第4章。F#并发简介")中描述的异步工作流来优化处理，*F#并发简介*。
- en: The number of requests to be processed must be processed as first come first
    served. This fits into the FIFO model, and the best data structure to handle this
    is queue. The use of queues will always ensure that the first request is always
    to be processed first and then there are some actions processed afterwards.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 需要处理的请求数量必须按照先到先服务的原则进行处理。这符合FIFO模型，而处理这种数据结构最好的方式是队列。使用队列将始终确保第一个请求首先被处理，然后是后续的一些操作。
- en: The process of inserting new data is called *enqueue*, while removing the first
    item of the data is called *dequeue*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 插入新数据的过程称为*入队*，而移除数据中的第一个元素称为*出队*。
- en: 'The following is an illustration of the incoming of requests and processing
    in a queue:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对请求进入队列和处理过程的说明：
- en: '![Introducing fire and forget pattern](img/image00295.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![介绍fire-and-forget模式](img/image00295.jpeg)'
- en: The queue of requests is usually seen as a block of data to be sent and received,
    and this is often called as message, because of the conceptual similarity to sending
    and receiving emails.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请求队列通常被视为要发送和接收的数据块，这通常被称为消息，因为这与发送和接收电子邮件的概念相似。
- en: The one software component that is responsible for managing incoming requests
    as queue and sending replies when needed is usually called a message queue manager.
    From F# perspective, it is called a message agent, or in MSDN terms, it is often
    simply called an agent. It is also called an *actor*, and this actor model is
    discussed in the next section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 负责管理入队请求并在需要时发送回复的一个软件组件通常被称为消息队列管理器。从F#的角度来看，它被称为消息代理，或者用MSDN术语，通常简单地称为代理。它也被称为*actor*，这种actor模型将在下一节中讨论。
- en: Overview of a message agent
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息代理概述
- en: This agent/ manager handles every message that is sent from senders (also called
    *producers*) and receives each message, which is then processed. The receivers
    can be from one to many receivers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代理/管理器处理来自发送者（也称为*生产者*）发送的每条消息，并接收每条消息，然后进行处理。接收者可以是一个或多个。
- en: 'The overall main focuses in terms of the agent''s operations are on:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理操作方面，整体的主要关注点包括：
- en: Sending a message (including preparations before and after). Sending is simply
    a sending from message agent A to message agent B.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送消息（包括发送前后的准备工作）。发送只是从消息代理A到消息代理B的发送。
- en: Receiving a message (including storing, processing). Message agent B receives
    messages from message agent A.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收消息（包括存储、处理）。消息代理B从消息代理A接收消息。
- en: 'The following illustration depicts the sending of the message with the queue
    processing:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了带有队列处理的发送消息过程：
- en: '![Overview of a message agent](img/image00296.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![消息代理概述](img/image00296.jpeg)'
- en: The sending and receiving operations are handled in a different context, but
    both sending and receiving use queues.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 发送和接收操作在不同的上下文中处理，但发送和接收都使用队列。
- en: 'When a message agent is sending a message, these are the activities performed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息代理发送消息时，会执行以下活动：
- en: A queue is allocated. The main allocation to be considered is the available
    memory, then the physical storage.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个队列。需要考虑的主要分配是可用内存，然后是物理存储。
- en: 'The message to be sent is prepared with this convention first: the format of
    each message must have the same format, so the message will be processed in a
    predictable manner.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先按照这个约定准备要发送的消息：每个消息的格式必须相同，这样消息将以可预测的方式处理。
- en: The message to be processed before sending usually comes in many forms. In the
    case of F# or any other lightweight agent, the message can be in the form of any
    object.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送前需要处理的消息通常以多种形式存在。在F#或任何其他轻量级代理的情况下，消息可以以任何对象的形式存在。
- en: The object is then serialized as raw strings.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将对象序列化为原始字符串。
- en: Serialization of the objects is then to be wrapped in a certain format. For
    example, the message can have headers and footers with additional information
    on how to process the message further.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象序列化后需要封装在特定的格式中。例如，消息可以包含头部和尾部，包含如何进一步处理消息的附加信息。
- en: The end result of the wrapped message is ready to be sent. At this time, any
    additional checks may be run, such as checking the availability of the network.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装后的消息最终结果准备好发送。此时，可以运行任何额外的检查，例如检查网络的可用性。
- en: The agent sends the message. The transfer protocol used by the agent is the
    same protocol as the receiver.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理发送消息。代理使用的传输协议与接收者相同。
- en: 'The receiving side is illustrated as shown:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接收端如图所示：
- en: '![Overview of a message agent](img/image00297.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![消息代理概述](img/image00297.jpeg)'
- en: 'As illustrated, a queue on the agent that receives the messages is needed because:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，接收消息的代理需要一个队列，因为：
- en: The incoming messages may come in close intervals; therefore, a minimum waiting
    time or minimal latency is expected. Also, incoming messages need to be stored
    before being processed, and the order of receiving is very important, as implied
    by FIFO.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入的消息可能间隔很近；因此，期望有最小等待时间或最小延迟。此外，在处理之前需要存储进入的消息，接收的顺序非常重要，如FIFO所暗示的。
- en: The queue can be optimized further by processing it in memory as needed, and
    as much as possible, as long as it matches the available memory allocation with
    respect to the maximum available memory of the running agent. For example, a machine
    with 32 GB of RAM will of course process the queue more efficiently than a machine
    with 16 GB of RAM.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 队列可以通过按需在内存中处理进一步优化，尽可能多地匹配运行代理的最大可用内存。例如，具有32GB RAM的机器当然比具有16GB RAM的机器更有效地处理队列。
- en: By default, a queue is stored on heap but using a predefined size; therefore,
    there is minimal overhead in accessing a queue on heap. This is also the same
    for the queue when it comes to sending messages as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，队列存储在堆上，但使用预定义的大小；因此，在堆上访问队列的开销最小。发送消息时的队列也是如此。
- en: 'These are the activities that happen when receiving a message:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在接收消息时发生的活动：
- en: A queue is allocated. This step is actually the same as step 1 in the sending
    message previously.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个队列。这一步实际上与之前发送消息的步骤1相同。
- en: The incoming message is checked for deserialization problems according to the
    agreed format from message agent A. This validation is necessary because there
    is no guarantee that all incoming messages are valid. This is the first difference
    in handling messages between sending and receiving.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据与消息代理A约定的格式，对传入的消息进行检查以确定反序列化问题。这种验证是必要的，因为没有保证所有传入的消息都是有效的。这是发送和接收消息处理中的第一个差异。
- en: The receiving messages are not guaranteed to always arrive in the same sequence
    as they were sent. For example, it is not guaranteed that the first message sent
    will be received first. It is quite normal/common for the order of the message
    sent not to be the same as the message received. This is the second of the differences
    between sending and receiving messages.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收到的消息并不能保证总是按照发送的顺序到达。例如，并不能保证第一个发送的消息会首先被接收。消息发送的顺序与接收到的顺序不同是很正常/常见的情况。这是发送和接收消息之间的第二个差异。
- en: A valid incoming message is enqueued. The first incoming message will be processed
    first. This first incoming message might not be the first message sent.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个有效的传入消息将被入队。第一个传入的消息将被首先处理。这个第一个传入的消息可能不是第一个发送的消息。
- en: When it is ready to be dequeued (after a certain wait for the previous incoming
    message to be dequeued), the message content is waiting to be deserialized further.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当它准备好出队（在等待之前的传入消息出队之后），消息内容正等待进一步的反序列化。
- en: The content of the message is deserialized from `String` to an object, and can
    be processed further as resulting data.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息内容从`String`反序列化为对象，并可以进一步作为结果数据进行处理。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is up to the implementer to further process the queue to be ordered by certain
    conditions before being dequeued and this may vary. This can be the subject of
    evidence of being falsely treated as synchronous because the ordering of the queue
    will yield some process overhead and the consumer of the message will have to
    wait. The handling of received messages may vary in a sense that the queues may
    have raw FIFO without considering the order of the time the message was sent or
    will try to process the received messages in time order as long as it is guaranteed
    to proceed using certain configurations. However, using this sequence of enforcing
    the order of the message received by the time they were sent will defeat the nature
    of the message queue agent since the message received will be forced to wait for
    the earlier messages to arrive.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实现者负责在出队之前进一步处理队列，使其按照某些条件排序，这可能因情况而异。这可能是将队列错误地视为同步的证据，因为队列的排序会产生一些处理开销，并且消息的消费者将不得不等待。接收到的消息的处理可能会有所不同，队列可能没有考虑消息发送的时间顺序的原始FIFO，或者只要保证使用某些配置进行进程，就会尝试按时间顺序处理接收到的消息。然而，使用这种按发送时间顺序强制执行接收到的消息的顺序将违背消息队列代理的本质，因为接收到的消息将被迫等待更早的消息到达。
- en: 'This is not the same as the era of the legacy modem as the full connection
    on both sides is required to ensure continuous synchronous communication. If a
    message agent is supposed to have full real-time processing while always waiting
    for the result immediately, then a message agent will always be forced to wait
    indefinitely for incoming replies, and this will defeat the main purpose of a
    message agent itself: processing message asynchronously. Anything waitable, concerns
    (usually processes) is mostly blocking, and if the waiting is executed explicitly,
    then it will block the next operation or process to be executed.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这与传统的调制解调器时代不同，因为双方都需要全连接来确保持续的同步通信。如果一个消息代理需要在始终等待结果的同时进行完全实时处理，那么消息代理将被迫无限期地等待传入的回复，这将违背消息代理本身的主要目的：异步处理消息。任何可等待的（通常是进程）操作大多是阻塞的，如果等待操作是显式执行的，那么它将阻塞下一个要执行的操作或进程。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The synchronous operations on a modem are not related to how the communication
    channels the transfer, either half duplex or full duplex. Many of us are mixing
    synchronous with half duplex/full duplex, and it is wrong. These concepts are
    not related at all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 调制解调器上的同步操作与通信通道的传输方式无关，无论是半双工还是全双工。我们中的许多人将同步与半双工/全双工混合使用，这是错误的。这些概念根本不相关。
- en: The receiving of the message handling can also use a temporary storage to hold
    received messages if necessary. This is crucial if each message may contain certain
    operations or instructions to be processed heavily, for example, instructions
    to calculate the current positions of a pricing forecast.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，消息处理也可以使用临时存储来保存接收到的消息。如果每个消息可能包含需要大量处理的特定操作或指令，例如计算定价预测的当前位置的指令，这一点至关重要。
- en: The handling of the messages to be sent is processed in queues, the first message
    to be sent being processed first. This is the same as handling the received messages
    where the first message received is processed first. One of the important factors
    in handling the messages is **serialization**. There might be overhead on the
    serialization and deserialization of the object in the message.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送的消息的处理是在队列中进行的，首先处理要发送的第一个消息。这与处理接收到的消息的方式相同，即首先处理接收到的第一个消息。在处理消息的一个重要因素是**序列化**。在消息中的对象序列化和反序列化可能会有开销。
- en: Overview of serialization
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列化概述
- en: 'Serialization and deserialization are often described as simply serialization.
    It is defined as how an object is flattened to a string of properties and values
    and the reverse: the construction of an object from a string of properties and
    values. The serialization part is actually an operation of flattening an object
    (or class in the type system), which is also called deconstruction of an object
    because the semantics of an object are translated into a string that describes
    the class, property, and values. The value of the properties must be serialized
    successfully too because we have to be able to deserialize back into the original
    object representation without changing the semantic value.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化和反序列化通常被描述为简单的序列化。它被定义为如何将对象扁平化为属性和值的字符串，以及其逆过程：从属性和值的字符串构建对象。序列化部分实际上是一个将对象（或类型系统中的类）扁平化的操作，这也被称为对象的解构，因为对象的语义被转换为一个描述类、属性和值的字符串。属性的值也必须成功序列化，因为我们必须能够将它们反序列化回原始对象表示，而不改变语义值。
- en: 'Serialization and deserialization are illustrated (simplified) in the following
    image:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化和反序列化在以下图像中（简化地）进行了说明：
- en: '![Overview of serialization](img/image00298.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![序列化概述](img/image00298.jpeg)'
- en: The simplest example of a working serialization is available in how we create
    our own custom serialization to translate an object's properties and its value's
    implementation using a basic override of the `ToString` method, which is available
    in `System.Object`. This `System.Object` class is inherited by all classes in
    .NET because `System.Object` is the parent object of all types in .NET. We can
    override the `ToString()` method to represent the content of the class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的工作序列化的例子可以在我们如何创建自己的自定义序列化中找到，该序列化使用基本重写`ToString`方法来转换对象的属性及其值的实现，该方法是`System.Object`中可用的。由于`System.Object`是.NET中所有类型的父对象，因此所有.NET中的类都继承自`System.Object`类。我们可以重写`ToString()`方法来表示类的内容。
- en: 'For example, we have a `Person` class, defined as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个`Person`类，定义如下：
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following are the explanations for the preceding code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的解释：
- en: The `Person` class overrides the `ToString()` method with the necessary `StringBuilder.Append`
    operations to construct a string representation of `Person`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Person`类使用必要的`StringBuilder.Append`操作重写了`ToString()`方法，以构建`Person`的字符串表示形式。'
- en: The `StringBuilder` of `sb` is used as mutable because it is fine to have mutability
    in a locally scoped function/method because this symbol is not used outside the
    scope of the function and the side effect is still transparent. The property values
    are separated with `|`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sb`的`StringBuilder`被用作可变的，因为在局部作用域的函数/方法中具有可变性是可以的，因为此符号不在函数的作用域之外使用，并且副作用仍然是透明的。属性值用`|`分隔。'
- en: The code uses the `val` keyword in the property member declaration because the
    property is using the auto setter and getter.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码在属性成员声明中使用`val`关键字，因为该属性使用自动设置器和获取器。
- en: 'A semantic description of the auto properties of setter-getter syntaxes for
    F# is beyond the scope of this book. For more information on the auto properties
    of F#, consult this MSDN Library page:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: F#的setter-getter语法的语义描述超出了本书的范围。有关F#自动属性的更多信息，请参阅此MSDN库页面：
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/properties](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/properties)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[F# 语言参考 - 成员 - 属性](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/properties)'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The semantics of F# auto properties (auto setter and getter with backing fields
    automatically generated by compiler) are same as C#/VB auto properties. Only the
    internal naming of the backing properties has different implementation details,
    but this should not be our concern at all since we do not care about the backing
    field.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: F# 自动属性（由编译器自动生成的具有自动设置器和获取器的后置字段）的语义与 C#/VB 自动属性相同。只是后置属性的内部命名实现细节不同，但这根本不是我们的关注点，因为我们不关心后置字段。
- en: 'We then add the code to display the serialization representation:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加代码来显示序列化表示：
- en: '[PRE2]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s run the code, and we will see that it will display the output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码，我们将看到它将显示以下输出：
- en: '![Overview of serialization](img/image00299.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![序列化概述](img/image00299.jpeg)'
- en: The cost of serialization is usually cheaper than deserialization, as it tries
    to flatten the object (the attributes or properties of the object) into strings
    that define the property name and the values. The property value is then converted
    to `String` by implicitly or explicitly calling the `ToString()` method. This
    is actually a simplified sample that we can also write our own serializer to further
    optimize or to fully streamline the process.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化的成本通常比反序列化低，因为它试图将对象（对象的属性或属性）扁平化为定义属性名称和值的字符串。然后，属性值通过隐式或显式调用 `ToString()`
    方法转换为 `String`。这实际上是一个简化的示例，我们也可以编写自己的序列化器来进一步优化或完全简化流程。
- en: Deserialization is more expensive because it tries to construct a type based
    on the string value, because we must maintain the semantics of the properties
    and the properties values from the serialized `String`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化更昂贵，因为它试图根据字符串值构建一个类型，因为我们必须维护从序列化 `String` 中获取的属性和属性值的语义。
- en: 'The following is a simplified sample of deserialization (add this code below
    the `Person` type declaration):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简化的反序列化示例（在 `Person` 类型声明下方添加此代码）：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To test this function, we now modify the `EntryPoint` code to test `Deserialize`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个函数，我们现在修改 `EntryPoint` 代码来测试 `Deserialize`：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We mark `Deserialize` as `static` because the main intention is to deserialize,
    not depend on the object that does the deserialization. We can test this deserialization
    by calling `Deserialize` with the existing serialized `ToString()` result with
    its parameter as demonstrated.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Deserialize` 标记为 `static`，因为主要目的是反序列化，而不是依赖于执行反序列化的对象。我们可以通过使用现有的序列化 `ToString()`
    结果并以其参数进行演示来测试这个反序列化。
- en: 'The following is the display output of the result of `anyperson3.ToString()`
    combined with the previous `anyPerson1` and `anyPerson2`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将 `anyperson3.ToString()` 的结果与之前的 `anyPerson1` 和 `anyPerson2` 结合后的显示输出：
- en: '![Overview of serialization](img/image00300.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![序列化概述](img/image00300.jpeg)'
- en: The resulting display output now has proven that we have successfully constructed
    the object from the serialized `String` by checking the same value of `anyPerson1`
    with `anyperson3`. This sample is too simple for this demonstration, but it truly
    demonstrates that there are certain requirements that have to be met before having
    successful deserializations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示现在已经证明我们通过检查 `anyPerson1` 与 `anyperson3` 的相同值，成功地从序列化的 `String` 中构建了对象。这个示例对于这个演示来说太简单了，但它确实证明了在进行成功的反序列化之前必须满足某些要求。
- en: 'These are the mandatory requirements for successful deserializations:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是成功反序列化的强制性要求：
- en: The serialized format must be agreed upon and must have the same structure format
    as the serializer. In terms of implementation, the type of serialization object
    must be the same type.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列化的格式必须达成一致，并且必须与序列化器具有相同的结构格式。在实现方面，序列化对象的类型必须相同。
- en: The serialization and deserialization must have as simple type as possible;
    otherwise, complex serialization and deserialization will occur. For example,
    serializing the object that implements the COM object, whereas implicit marshalling
    will always occur and crossing the thread boundary across *STA* and *MTA* threads
    will always yield unpredictable results, often yielding errors not in the form
    of a thrown exception.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列化和反序列化必须尽可能简单；否则，将发生复杂的序列化和反序列化。例如，序列化实现 COM 对象的对象，而隐式封送处理将始终发生，并且跨越 *STA*
    和 *MTA* 线程的线程边界将始终产生不可预测的结果，通常会产生非抛出异常的错误形式。
- en: The serialization of an object has to be a concrete object (a class); otherwise,
    an overhead of type check casting will occur. For example, serializing an interface
    is not recommended as the deserialization will always try to create an instance
    of a concrete class, and a runtime error will occur.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的序列化必须是一个具体的对象（一个类）；否则，将发生类型检查转换的开销。例如，不建议序列化接口，因为反序列化将始终尝试创建一个具体类的实例，并可能导致运行时错误。
- en: In common/daily practice, it is recommended to use an existing serializer with
    an already commonly-used format such as JSON, for example, `DataContractJsonSerializer`
    in the WCF class libraries, under the namespace of `System.Runtime.Serialization.Json`,
    and the commonly used third party serializer, NewtonSoft JSON serializer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见的/日常实践中，建议使用现有的序列化程序，例如使用已经广泛使用的格式，如 JSON，例如在 WCF 类库中的 `DataContractJsonSerializer`，位于
    `System.Runtime.Serialization.Json` 命名空间下，以及常用的第三方序列化程序，NewtonSoft JSON 序列化程序。
- en: Introduction to F# MailboxProcessor
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# MailboxProcessor 简介
- en: Now, we have the basic knowledge of what a message agent is, and we have also
    highlighted how this agent operates as to how it sends and receive messages. It
    is time to find out more about the F# message agent, F# `MailboxProcessor`. For
    the rest of this book, we will simply use `MailboxProcessor` as a class and as
    an agent.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了消息代理的基本知识，并且我们也强调了该代理如何操作，即如何发送和接收消息。现在是时候了解更多关于 F# 消息代理，F# `MailboxProcessor`
    的信息了。在本书的其余部分，我们将简单地使用 `MailboxProcessor` 作为类和代理。
- en: The `MailboxProcessor` is actor based. It may have multiple threads spawned
    or just a single thread. In a sense it is an actor because as an actor, it can
    have its own role. In their implementation detail, the actors can act on their
    own without depending on other actors (although they might have the same responsibilities
    or same behaviors). Actors can be implemented to have the same responsibilities,
    such as an actor/agent to process incoming requests or to process sending requests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailboxProcessor` 是基于演员的。它可能产生多个线程，也可能只有一个线程。从某种意义上说，它是一个演员，因为作为一个演员，它可以有自己的角色。在它们的实现细节中，演员可以独立行动，而不依赖于其他演员（尽管它们可能有相同的责任或行为）。演员可以被实现为具有相同的责任，例如处理传入请求或发送请求的演员/代理。'
- en: The writer of `MailboxProcessor` can also be seen as a producer while the reader
    can be seen as a consumer.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailboxProcessor` 的编写者也可以被视为生产者，而读者可以被视为消费者。'
- en: 'The lightweight aspects of `MailboxProcessor` are unique. It is not just lightweight
    in terms of being standalone and built-in to the core F#, but also:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailboxProcessor` 的轻量级特性是独特的。它不仅轻量级，独立且内置于核心 F# 中，而且：'
- en: It is quite easy to start using it because it operates without dependency on
    how the underlying operating system does asynchronous operations.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用它非常简单，因为它不依赖于底层操作系统如何执行异步操作。
- en: It will not store the messages, so they are not persistent
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会存储消息，因此它们不是持久的
- en: It can be further combined with F# asynchronous workflow
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以进一步与 F# 异步工作流结合使用
- en: It does not have an advanced infrastructure that has many configurable environment
    settings such as IBM Websphere MQ and MSMQ
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有像 IBM Websphere MQ 和 MSMQ 那样具有许多可配置环境设置的先进基础设施。
- en: Other than those unique traits, the concept of F# `MailboxProcessor` queue agent
    is similar to famous message queue manager software such as IBM Websphere MQ (formerly
    IBM MQ Series) and Microsoft MQ (also called MSMQ). It is used to handle asynchronous
    message transfers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些独特的特性之外，F# `MailboxProcessor` 队列代理的概念与著名的消息队列管理软件类似，例如 IBM Websphere MQ（以前称为
    IBM MQ Series）和 Microsoft MQ（也称为 MSMQ）。它用于处理异步消息传输。
- en: 'For more information about IBM Websphere MQ, visit:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 IBM Websphere MQ 的信息，请访问：
- en: '[http://www-03.ibm.com/software/products/en/ibm-mq](http://www-03.ibm.com/software/products/en/ibm-mq)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[IBM MQ](http://www-03.ibm.com/software/products/en/ibm-mq)'
- en: 'For more information about MSMQ, visit:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 MSMQ 的信息，请访问：
- en: '[https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx)'
- en: F# `MailboxProcessor` as agent is not completely standalone (not external) because
    `MailboxProcessor` is part of F# core libraries, so we can use and leverage it
    quickly instead of having an assessment and installation setup activities before
    using it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中的 `MailboxProcessor` 作为代理并不是完全独立的（不是外部的），因为 `MailboxProcessor` 是 F# 核心库的一部分，因此我们可以快速使用和利用它，而不是在使用它之前进行评估和安装设置活动。
- en: 'The disadvantages are:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不利之处包括：
- en: If many messages are sent or received, we must implement our own storage to
    store them. This means we maintain our own storage of a queue of messages as,
    by default, `MailboxProcessor` messages are not persistent.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发送或接收许多消息，我们必须实现自己的存储来存储它们。这意味着我们维护自己的消息队列存储，因为默认情况下，`MailboxProcessor` 消息不是持久的。
- en: We must manage how we further optimize the queue operations as `MailboxProcessor`,
    by default, relies on operating at runtime with no offline storage feature to
    hold the queues.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须管理如何进一步优化队列操作，因为默认情况下，`MailboxProcessor` 依赖于运行时操作而没有离线存储功能来保存队列。
- en: If the order of prioritization is critical, we cannot further customize how
    `MailboxProcessor` is going to use the thread affinity of the underlying machine
    on Windows because there is no way to do this. This is intentional, as the lightweight
    of `MailboxProcessor` always hides the implementation details of the synchronization
    of prioritization on the thread executions.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果优先级顺序至关重要，我们无法进一步自定义 `MailboxProcessor` 在 Windows 上如何使用底层机器的线程亲和性，因为没有方法可以做到这一点。这是故意的，因为
    `MailboxProcessor` 的轻量级总是隐藏了线程执行上优先级同步的实现细节。
- en: In the realm of F#, `MailboxProcessor` has the ability to write messages to
    send (*writer*) and to read incoming messages (*reader*).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 领域，`MailboxProcessor` 有能力将消息写入以发送（*写入者*）和读取传入的消息（*读取者*）。
- en: 'The writer-reader model is often mentioned in the MSDN Library on the MSDN
    landing page of `Control.MailboxProcessor`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 写入者-读取者模型经常在 MSDN 图书馆的 `Control.MailboxProcessor` 的 MSDN 登录页面中提到：
- en: '[https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.mailboxprocessor%5b%27msg%5d-class-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.mailboxprocessor%5b%27msg%5d-class-%5bfsharp%5d)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.mailboxprocessor%5b%27msg%5d-class-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.mailboxprocessor%5b%27msg%5d-class-%5bfsharp%5d)'
- en: This reader-writer model shows that `MailboxProcessor` only focuses as an agent
    on writing a message and then sending it, and reading incoming messages. It may
    focus on one responsibility to only send, receive, or both.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种读写者模型表明 `MailboxProcessor` 只关注作为代理写入消息并发送，然后读取传入的消息。它可能只专注于一个责任，即仅发送、接收或两者兼具。
- en: If we set `MailboxProcessor` to have both send and receive, the sending and
    receiving processes cannot both be guaranteed to be at the same time.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `MailboxProcessor` 设置为同时具有发送和接收功能，则无法保证发送和接收过程可以同时进行。
- en: 'Let''s look at a simplified sample of `MailboxProcessor` by constructing and
    simulating an email message. The sample code in the landing page of F# `Control.MailboxProcessor`
    is actually a script file instead of a common code file because we need to evaluate
    and test the result immediately, a good practice for REPL interactive of F# interactive:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过构建和模拟一封电子邮件消息来查看 `MailboxProcessor` 的简化示例。F# `Control.MailboxProcessor`
    的登录页面中的示例代码实际上是一个脚本文件，而不是一个常见的代码文件，因为我们需要立即评估和测试结果，这是 F# 交互式环境的一个良好实践：
- en: '[PRE5]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Start evaluating the previous code by pressing *Alt* + *Enter*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按 *Alt* + *Enter* 开始评估前面的代码。
- en: 'The F# Interactive will evaluate the code sequentially, and this is the walkthrough
    of the semantics:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: F# 交互式环境将按顺序评估代码，这是语义的遍历：
- en: Open the `System` namespace and `Microsoft.Fsharp.Control`. The `Microsoft.FSharp.Control`
    namespace is needed for `MailboxProcessor`. We are using `System` namespace because
    we are going to use `Console` to display the output later.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `System` 命名空间和 `Microsoft.Fsharp.Control`。`Microsoft.FSharp.Control` 命名空间对于
    `MailboxProcessor` 是必需的。我们使用 `System` 命名空间，因为我们将在稍后使用 `Console` 显示输出。
- en: We create `EmailMessage` type to wrap the message we are going to use. The message
    is simple as it contains the sender (`From`), the destination, the optional CC,
    subject, and the content of the message. The properties are initialized in the
    default constructor.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建 `EmailMessage` 类型来封装我们将要使用的消息。消息很简单，它包含发送者（`From`）、目的地、可选的 CC、主题和消息内容。属性在默认构造函数中初始化。
- en: All of the properties use the explicit type declaration for more clarity.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有属性都使用了显式类型声明以提高清晰度。
- en: The mailbox symbol is inferred as a `MailboxProcessor` instance with the parameterized
    type of `EmailMessage` as the message type.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 邮箱符号被推断为一个 `MailboxProcessor` 实例，其消息类型为参数化的 `EmailMessage` 类型。
- en: The constructor of `MailboxProcessor` is a lambda that contains the loop of
    receiving messages.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MailboxProcessor` 构造函数是一个包含接收消息循环的 lambda 表达式。'
- en: This lambda contains a recursive function of loop, and it uses `return!` to
    signify that the returning call of loop is within the asynchronous workflow boundary.
    In the implementation details, `return!` is further translated to calls to `AsyncBuilder.Return`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 lambda 包含一个循环的递归函数，并使用 `return!` 来表示循环的返回调用在异步工作流边界内。在实现细节中，`return!` 进一步被转换成对
    `AsyncBuilder.Return` 的调用。
- en: Received messages are handled by asynchronously getting results by calling the
    type inferred by the parameter of the lambda, `inbox`. `inbox` is actually typed
    as `MailboxProcessor<Message>`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收到的消息通过调用 lambda 参数推断出的类型异步获取结果来处理，该类型为 `inbox`。`inbox` 实际上被类型化为 `MailboxProcessor<Message>`。
- en: The use of `return!` is crucial because the nature of the recursive function
    of a loop is contained inside an asynchronous workflow. If we use only `return`
    instead of `return!`, it will leak the call state outside the boundary of the
    `async` construct, which can then yield memory leaks in crossing the context.
    This `return!` is translated into calls to one of the F# asynchronous workflow
    builders, `AsyncBuilder.Return`, before it actually returns the call of `loop`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`return!` 的使用至关重要，因为循环递归函数的本质包含在一个异步工作流中。如果我们只使用 `return` 而不是 `return!`，它将泄露调用状态到
    `async` 构造之外的边界，这可能导致在跨上下文时出现内存泄漏。这个 `return!` 在实际返回循环调用之前被转换成对 F# 异步工作流构建器之一
    `AsyncBuilder.Return` 的调用。'
- en: 'The internal implementation detail is available in the IL. Compile and start
    ILDASM, then if we open the compiled exe, we can examine the generated classes
    of loop. In one of the loops, we shall see it calls the `FSharp.Control.FSharpAsyncBuilder.Return`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 内部实现细节可以在 IL 中找到。编译并启动 ILDASM，然后如果我们打开编译后的 exe，我们可以检查生成的循环类。在其中一个循环中，我们将看到它调用了
    `FSharp.Control.FSharpAsyncBuilder.Return`：
- en: '[PRE6]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It has the `FSharpAsyncBuilder.Return` call before it actually returns to outside
    scope.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际返回到外部作用域之前，它包含了一个 `FSharpAsyncBuilder.Return` 调用。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All of the F# `AsyncBuilder` is compiled under the name of `FSharpAsyncBuilder`.
    This is also reflected in the generated IL.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 F# `AsyncBuilder` 都在名为 `FSharpAsyncBuilder` 的名称下编译。这也在生成的 IL 中得到了反映。
- en: 'Then, let''s see `MailboxProcessor` in action:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们看看 `MailboxProcessor` 的实际应用：
- en: '[PRE7]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is the output of the previous code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前代码的输出：
- en: '![Introduction to F# MailboxProcessor](img/image00301.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![F# MailboxProcessor 简介](img/image00301.jpeg)'
- en: 'Let''s dive further into the code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步深入代码：
- en: The mailbox symbol is in fact an instance of `MailboxProcessor` with a default
    constructor of one parameter and the body of the message typed as `Message`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 邮箱符号实际上是一个 `MailboxProcessor` 实例，具有一个参数化构造函数和一个类型为 `Message` 的消息体。
- en: After we have the `MailboxProcessor` instance, we can begin to initialize the
    mailbox as an agent by calling the `Start()` method.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们获得 `MailboxProcessor` 实例后，我们可以通过调用 `Start()` 方法开始初始化邮箱作为代理。
- en: We can then send messages by calling `Post()` with the message as the parameter;
    each call of the `Post()` method is guaranteed to be asynchronous.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `Post()` 并将消息作为参数来发送消息；`Post()` 方法的每次调用都保证是异步的。
- en: From the perspective of `MailboxProcessor`, the writer operation is represented
    by calling `Post()`, and this is also the sending operation; the reader is represented
    by calling `Receive()`, and this is also the receiving operation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `MailboxProcessor` 的角度来看，写入操作是通过调用 `Post()` 来表示的，这同时也是发送操作；读取操作是通过调用 `Receive()`
    来表示的，这同时也是接收操作。
- en: This is why the type name starts with *Mailbox* because it is quite similar
    to the mailbox as a starting container to send and receive letters that contain
    messages in everyday life.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么类型名称以 *Mailbox* 开头，因为它在日常生活中的邮箱作为发送和接收包含消息的起始容器非常相似。
- en: Now let's dive into `MailboxProcessor` features.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来深入了解`MailboxProcessor`的功能。
- en: Overview of MailboxProcesor features
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MailboxProcessor功能概述
- en: '`MailboxProcessor` has two constructors, the simplest constructor being the
    one that takes one parameter of delegate. The second one takes two parameters:
    a delegate and a `CancellationToken` object.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailboxProcessor`有两个构造函数，最简单的构造函数是接受一个委托参数的构造函数。第二个构造函数接受两个参数：一个委托和一个`CancellationToken`对象。'
- en: 'The following are the syntaxes of the constructors:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些构造函数的语法：
- en: '[PRE8]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previous sample, we called the constructor with a delegate. This delegate
    is the main entry of the read loop when `MailboxProcessor` starts (as initialized
    by calling the `Start()` method).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用委托调用了构造函数。当`MailboxProcessor`启动时（通过调用`Start()`方法初始化），这个委托是读取循环的主要入口。
- en: Not all of the operations in `MailboxProcessor` are useful for all cases; that
    depends on the usage and the detail of the asynchronous operations we want to
    use. In fact, similar to the other message agents, `MailboxProcessor` does not
    guarantee that the sequence of the received messages will always be the same as
    the sequence of sent messages.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 并非`MailboxProcessor`中的所有操作都对所有情况都很有用；这取决于使用情况和我们要使用的异步操作的细节。实际上，与其他消息代理类似，`MailboxProcessor`不保证接收到的消息的顺序始终与发送消息的顺序相同。
- en: 'The following are the interesting functions/methods of `MailboxProcessor`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`MailboxProcessor`的有趣函数/方法：
- en: '| **Function** | **Quick Remark** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **快速说明** |'
- en: '| `Post` | Posts a message to the message queue of `MailboxProcessor` asynchronously.
    Should not be mixed with non-F# `async` such as C#/VB `async`. The posting of
    a message does not mandate `MailboxProcessor` to return any success/failure status
    of the posting action. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `Post` | 异步地将消息发送到`MailboxProcessor`的消息队列。不应与非F# `async`（如C#/VB `async`）混合使用。发送消息不强制`MailboxProcessor`返回任何发送操作的成功/失败状态。|'
- en: '| `PostAndAsyncReply` | Posts a message to an agent and awaits a reply on the
    channel, asynchronously. Should not be confused with non-F# `async` such as C#/VB
    `async`. It requires us to always handle the reply of the message. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `PostAndAsyncReply` | 向代理发送消息并异步等待通道上的回复。不应与非F# `async`（如C#/VB `async`）混淆。它要求我们始终处理消息的回复。|'
- en: '| `PostAndReply` | Posts a message to an agent and awaits a reply on the channel,
    synchronously. The sending of the message is still asynchronous. Should not be
    mixed with non F# `async` such as C#/VB `async`. It requires us to always handle
    the reply of the message. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `PostAndReply` | 向代理发送消息并同步等待通道上的回复。消息的发送仍然是异步的。不应与非F# `async`（如C#/VB `async`）混合使用。它要求我们始终处理消息的回复。|'
- en: '| `PostAndTryAsyncReply` | Similar to `PostAndAsyncReply` but returns `None`
    if there is no reply within the timeout period. Should not be mixed with non-F#
    `async` such as C#/VB `async`. It requires us to always handle the reply of the
    message. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `PostAndTryAsyncReply` | 与`PostAndAsyncReply`类似，但在超时时间内没有回复时返回`None`。不应与非F#
    `async`（如C#/VB `async`）混合使用。它要求我们始终处理消息的回复。|'
- en: '| `Receive` | Waits for a message. This will consume the first message in the
    arrival order. Should not be mixed with non-F# `async` such as C#/VB `async`.This
    `Receive` action has the same type of object as defined by the sending action.
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `Receive` | 等待消息。这将消耗到达顺序中的第一个消息。不应与非F# `async`（如C#/VB `async`）混合使用。这个`Receive`操作具有与发送操作定义的相同类型的对象。|'
- en: '| `Scan` | Scans for a message by looking through messages in arrival order
    until the scanner returns a `Some` value. Other messages remain in the queue.This
    scanning action will mostly block the message replies of `Receive` and `TryReceive`.
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `Scan` | 通过按到达顺序遍历消息来查找消息，直到扫描器返回`Some`值。其他消息保留在队列中。这种扫描操作将主要阻塞`Receive`和`TryReceive`的消息回复。|'
- en: '| `Start` | Starts the agent. The start of the agent may be included within
    a parallel loop, such as `Parallel.For` or `Parallel.ForEach`. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `Start` | 启动代理。代理的开始可能包含在并行循环中，例如`Parallel.For`或`Parallel.ForEach`。|'
- en: '| `TryPostAndReply` | Similar to `PostAndReply` but returns `None` if there
    is no reply within the timeout period. Should not be mixed with non-F# `async`
    such as C#/VB `async`. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `TryPostAndReply` | 与`PostAndReply`类似，但在超时时间内没有回复时返回`None`。不应与非F# `async`（如C#/VB
    `async`）混合使用。|'
- en: '| `TryReceive` | Waits for a message. This will consume the first message in
    the arrival order. It also enforces synchronicity instead of receiving asynchronously.
    Returns `false` if the receiving message fails. Should not be mixed with non-F#
    `async` such as C#/VB `async`.The `Receive` action has the same type of object
    as defined by the sending action |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `TryReceive` | 等待消息。这将消耗到达顺序中的第一条消息。它还强制同步而不是异步接收。如果接收消息失败，则返回`false`。不应与非F#的`async`（如C#/VB的`async`）混合使用。`Receive`操作具有与发送操作定义的相同类型的对象|'
- en: '| `TryScan` | Scans for a message by looking through the messages in the arrival
    order until scanner returns a `Some` value. Other messages remain in the queue.
    The queue is only stored in memory. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `TryScan` | 通过按到达顺序查看消息来扫描消息，直到扫描器返回`Some`值。其他消息保留在队列中。队列仅存储在内存中。|'
- en: In the previous table, all of the standard posts and replies, such as `Post`,
    `PostAndReply`, and `PostAndAsyncReply`, should not be used within the C#/VB `async`
    construct. The post and reply operations implemented in F# have their own thread
    synchronizer. This F# synchronizer often has unpredictable results when used within
    C#/VB `async` construct; mixing this different asynchronous model will make the
    F# synchronizer have race condition when switching back and forth between different
    execution contexts.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个表中，所有标准帖子（如`Post`）和回复操作（如`PostAndReply`和`PostAndAsyncReply`），都不应在C#/VB的`async`构造中内部使用。F#中实现的帖子（post）和回复操作有自己的线程同步器。当在C#/VB的`async`构造中使用时，这个F#同步器往往会有不可预测的结果；混合不同的异步模型会使F#同步器在切换不同的执行上下文时出现竞争条件。
- en: Further implementations of MailboxProcessor
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步实现`MailboxProcessor`
- en: 'Based on the previous table, `MailboxProcesor` can also send messages and wait
    for replies, not just send (post) messages. The following operations that do the
    sending and waiting for reply immediately after sending:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上一个表，`MailboxProcesor`不仅可以发送消息并等待回复，而不仅仅是发送（帖子）消息。以下操作在发送后立即执行发送和等待回复：
- en: '`PostAndAsyncReply`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostAndAsyncReply`'
- en: '`PostAndReply`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostAndReply`'
- en: '`PostAndTryAsyncReply`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostAndTryAsyncReply`'
- en: '`TryPostAndReply`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryPostAndReply`'
- en: All these send and receive operations require a handle in F#. It is called `AsyncReplyChannel`,
    contained in the `Control.AsyncReplyChannel` class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些发送和接收操作在F#中都需要一个句柄。它被称为`AsyncReplyChannel`，包含在`Control.AsyncReplyChannel`类中。
- en: 'These are the common steps for using `MailboxProcessor`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用`MailboxProcessor`的常见步骤：
- en: We must plan the format of the message to be transferred and received. The format
    of the message has to be as simple as possible.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须计划要传输和接收的消息格式。消息的格式必须尽可能简单。
- en: The agent is created by instantiating it. At this stage, we have to decide whether
    the operation of sending and receiving messages can be canceled anytime by calling
    the `MailboxProcessor` constructor, which has the delegate and `CancellationToken`
    passed.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理是通过实例化创建的。在这个阶段，我们必须决定是否可以通过调用具有委托和`CancellationToken`的`MailboxProcessor`构造函数来随时取消发送和接收消息的操作。
- en: The delegate may contain both the sending and receiving message operations,
    or just receiving operations.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 委托可以包含发送和接收消息操作，或者只是接收操作。
- en: If we require it to send and wait for replies, we must carefully construct the
    delegate to include `AsyncReplyChannel`. It is recommended to embed this handler
    inside the message itself because, then, we can enforce that the reply of the
    sent message is closely related.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们需要它发送并等待回复，我们必须仔细构造委托以包含`AsyncReplyChannel`。建议将此处理程序嵌入到消息本身中，因为这样我们可以确保发送消息的回复紧密相关。
- en: To see this sample of sending and waiting for reply in action, we also use the
    F# flexible type declaration to add more flexibility when handling messages.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到发送和等待回复的示例，我们还使用F#灵活的类型声明来在处理消息时增加更多灵活性。
- en: 'At the declarations of the message, `AsyncReplyChannel` is embedded in the
    message itself:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息的声明中，`AsyncReplyChannel`嵌入到消息本身中：
- en: '[PRE9]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is an excerpt of the code that creates the instance of `MailboxProcessor`
    and performs the receiving using handles:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建`MailboxProcessor`实例并使用句柄进行接收的代码摘录：
- en: '[PRE10]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is also nice to know that type inference not only flows nicely not just as
    an inferred type declaration and inferred return type but also accommodates the
    d*iscriminated unions* that infers the constructor of the type.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 还知道类型推断不仅流畅地作为推断类型声明和推断返回类型，而且还适应了推断类型的构造函数的*区分联合*。
- en: For example, let's see the declaration of the `ComplexMessage` type that has
    discriminated unions with our own previous `EmailMessage` embedded.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看具有判别联合和我们的先前 `EmailMessage` 嵌入的 `ComplexMessage` 类型的声明。
- en: 'We can now combine this with pattern matching that checks for any Query as
    its *subtype*:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将此与检查任何查询作为其 *子类型* 的模式匹配相结合：
- en: '[PRE11]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is also very nice to know that again this feature is unique to F#, as the
    current release of C#/VB does not have this discriminated union feature yet.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个很好的消息，即这个特性也是 F# 独有的，因为当前 C#/VB 的发布还没有这个判别联合特性。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are rough plans to have discriminated union supported in C#/VB, but it
    is still debated. Also pattern matching is due in the upcoming version of C# 7,
    and VB 15 does not have the same automatic type inferences as F#. Consult Microsoft's
    Roslyn repo on GitHub to keep up with the latest developments in C#/VB language
    design.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有计划在 C#/VB 中支持判别联合，但仍在讨论中。此外，模式匹配预计将在 C# 7 的下一个版本中推出，而 VB 15 没有与 F# 相同的自动类型推断。请咨询
    GitHub 上的 Microsoft Roslyn 仓库，以了解 C#/VB 语言设计的最新发展。
- en: 'A detailed description of the discriminated union is beyond the scope of this
    book because we cannot further optimize discriminated union. For more information
    on F#''s discriminated union, visit:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对判别联合的详细描述超出了本书的范围，因为我们无法进一步优化判别联合。有关 F# 的判别联合的更多信息，请访问：
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions)'
- en: The pattern matching in the sample code can be further optimized. We will describe
    the optimizations of pattern matching as part of the F# language constructs (beside
    asynchronous workflow) later in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language
    Features and Constructs Optimization"), *Language Features and Constructs Optimization*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 样本代码中的模式匹配可以进一步优化。我们将在 [第 7 章](fsp-hiperf_cu07.html#aid-1ENBI1 "第 7 章。语言特性和结构优化")
    中描述模式匹配的优化，作为 F# 语言结构（除异步工作流外）的一部分，*语言特性和结构优化*。
- en: 'To test the sending and receiving in action simultaneously, we can send (post)
    the message while at the same time waiting to receive the message:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了同时测试发送和接收，我们可以在发送（发布）消息的同时等待接收消息：
- en: '[PRE12]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since we have embedded the channel inside the message, we can have a quick guarantee
    that for each message we receive, we can always try to relate the message we receive
    to the message we send because we are using the same `AsyncReplyChannel`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在消息中嵌入了通道，我们可以快速保证对于每个接收到的消息，我们都可以尝试将接收到的消息与我们发送的消息相关联，因为我们使用的是相同的 `AsyncReplyChannel`。
- en: Looking back at the definition of the delegate inside the constructor of `marketMaker`,
    it matches the query pattern of a `Message` type, which then returns the related
    asset based on the message posted by `PostAndReply`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下 `marketMaker` 构造函数内部的委托定义，它与 `Message` 类型的查询模式相匹配，然后根据 `PostAndReply` 发送的消息返回相关资产。
- en: Now, we have extended our understanding of `MailboxProcessor` using the sample
    of an order and sell transaction. It is still similar to a bank account model
    transaction, but we do not care how many parts or asset balances we have.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过订单和卖出交易的示例扩展了对 `MailboxProcessor` 的理解。它仍然类似于银行账户模型交易，但我们不关心有多少部分或资产余额。
- en: Managing side effects inside MailboxProcessor and asynchronous workflows
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 MailboxProcessor 和异步工作流中管理副作用
- en: We may have been tempted to use a `MailboxProcessor` instantiation wrapped within
    an asynchronous workflow. *It is not recommended to have this overly complex wrapper
    as MailboxProcessor already has its own asynchronous context*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能曾想使用一个封装在异步工作流中的 `MailboxProcessor` 实例化。*不建议使用这个过于复杂的包装器，因为 MailboxProcessor
    已经有自己的异步上下文*。
- en: This is also applied to interoperability with the UI thread as well as asynchronous
    context should not be mixed with the UI thread directly. Mixing the UI thread
    with asynchronous contexts will yield unpredictable results.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于与 UI 线程的互操作性，以及异步上下文不应直接与 UI 线程混合。将 UI 线程与异步上下文混合会产生不可预测的结果。
- en: If we must use Windows forms, it is best to have asynchronous workflow and the
    UI coded in F#. Using WPF, we can use WPF Dispatcher to ensure we will not have
    cross-thread violation.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须使用Windows窗体，最好是使用异步工作流，并且用F#编写UI代码。使用WPF，我们可以使用WPF的Dispatcher来确保我们不会出现跨线程违规。
- en: On managing side effects, using `MailboxProcessor` to do side effects activity
    must be handled carefully.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理副作用方面，使用`MailboxProcessor`进行副作用活动必须谨慎处理。
- en: 'Consider these scenarios and the reasons:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这些场景和原因：
- en: Upon receiving the messages inside the delegate parameter of a `MailboxProcessor`
    instantiation, we have calls to get web content asynchronously. These multiple
    asynchronous contexts are not recommended because there can be race conditions
    on which processes are to be finished and return the call back to the calling
    delegate. This added complexity will add overhead to the stack because there is
    no guarantee that `MailboxProcessor` will handle the asynchronous scheduling correctly.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MailboxProcessor`实例化的委托参数内部接收消息时，我们有异步获取网页内容的调用。这些多个异步上下文不建议使用，因为可能会出现关于哪些进程应该完成并返回回调给调用委托的竞争条件。这种额外的复杂性会给堆栈增加开销，因为没有保证`MailboxProcessor`能正确处理异步调度。
- en: If we still want to do this, every call to get the web content must be handled
    using the Disposable pattern as far as possible in order to minimize the pointer
    leak of the call stack.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们仍然想这样做，获取网页内容的每个调用都必须尽可能使用可丢弃模式来处理，以最大限度地减少调用栈的指针泄漏。
- en: The original intent of `MailboxProcessor` is to have a role as message agent.
    The delegate and the payload of the message should be constructed to be as simple
    as possible. If we want to use `AsyncReplyChannel`, it is recommended to embed
    it as part of the message.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MailboxProcessor`的原始意图是充当消息代理的角色。消息的委托和有效负载应该尽可能简单。如果我们想使用`AsyncReplyChannel`，建议将其作为消息的一部分嵌入。'
- en: Wrapping `MailboxProcessorPost` and `Reply` in a parallel loop such as `Parallel.ForEach()`
    does not really guarantee that `MailboxProcessor` will send the message fully
    parallel unless the instantiation of `MailboxProcessor` itself is encoded within
    a parallel loop. This will ensure that there will be no breach outside the context
    of the `MailboxProcessor` delegate when `MailboxProcessor` starts.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MailboxProcessorPost`和`Reply`包装在并行循环，如`Parallel.ForEach()`中，并不能真正保证`MailboxProcessor`会完全并行地发送消息，除非`MailboxProcessor`的实例化本身是在并行循环中编码的。这将确保在`MailboxProcessor`委托的上下文之外不会有任何越界，当`MailboxProcessor`启动时。
- en: It is not recommended to have a nested recursive function of `async` calling
    another recursive `async` function. The level of unpredictability will increase
    by many orders of magnitude, especially as it will be considered as a long-lived
    object, but it will also put a burden on `Gen0` and `Gen1` of the CLR. Normally,
    long-lived objects should live on `Gen1`, but the asynchronous workflow might
    consider it as short-lived object; therefore, the burden will be put on both `Gen0`
    and `Gen1`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不建议嵌套递归的`async`函数调用另一个递归的`async`函数。不可预测性将增加许多数量级，特别是当它被视为一个长期对象时，但它也会给CLR的`Gen0`和`Gen1`带来负担。通常，长期对象应该存在于`Gen1`中，但异步工作流可能会将其视为短期对象；因此，负担将放在`Gen0`和`Gen1`上。
- en: We have seen from many sample cases that it's important to profile the application,
    especially when the code contains many asynchronous workflows, including the implied
    `MailboxProcessor`. The result of testing how many objects live in `Gen0` and
    `Gen1` will determine where and how the GC may experience unnecessary overheads
    of garbage collections and heap allocations.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从许多示例案例中看到，对应用程序进行性能分析非常重要，特别是当代码包含许多异步工作流，包括隐含的`MailboxProcessor`时。测试`Gen0`和`Gen1`中存在多少对象的结果将决定垃圾收集和堆分配可能遇到的不必要开销在哪里以及如何发生。
- en: There may happen to be unnecessary overheads because of an object being short-lived
    but profiled as long lived; the GC `Gen0` and `Gen1` profiling reports should
    be the basis for actually finding out where the `Gen0` and `Gen1` continues. However,
    premature GC will not definitely help increase the performance because if there
    is aggressive garbage collection at `Gen0`, then the cost of garbage collection
    will affect the initial run time of your code, especially when `GC.Collect` is
    called within a loop of `for` and `foreach`. Each time `GC.Collect` is called,
    any exception that might happen during the call of `GC.Collect` will also affect
    the state of the current stack frame and heap allocations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对象生命周期短但被配置为长期存在，可能会出现不必要的开销；GC 的 `Gen0` 和 `Gen1` 分析报告应该是实际找出 `Gen0` 和 `Gen1`
    继续所在的基础。然而，过早的垃圾回收并不一定能提高性能，因为如果 `Gen0` 有激进的垃圾回收，那么垃圾回收的成本将影响代码的初始运行时间，尤其是在 `for`
    和 `foreach` 循环中调用 `GC.Collect` 时。每次调用 `GC.Collect` 时，`GC.Collect` 调用过程中可能发生的任何异常也会影响当前栈帧的状态和堆分配。
- en: Again, there is no single solution for uncommon implementations of your asynchronous
    workflow.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，对于您异步工作流的非标准实现，没有单一的解决方案。
- en: Parallel programming with .NET TPL
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .NET TPL 进行并行编程
- en: We have a basic knowledge of asynchronous, parallel asynchronous, and interoperability
    of asynchronous workflows with .NET EAP and APM. We have finished discussing .NET
    Task based Asynchronous Programming (TAP) in the form of interoperability between
    F# asynchronous workflows and .NET TAP. We are now discussing more about interoperability
    with .NET TPL.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对异步、并行异步以及异步工作流与 .NET EAP 和 APM 的互操作性有基本了解。我们已经以 F# 异步工作流与 .NET TAP 互操作性的形式完成了
    .NET 基于任务的异步编程（TAP）的讨论。我们现在将更多地讨论与 .NET TPL 的互操作性。
- en: F# does not just have its own implementations of asynchronous supports and parallel
    asynchronous but is fully compatible with .NET BCL hence .NET TPL.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: F# 不仅有自己的异步支持和并行异步实现，而且与 .NET BCL 完全兼容，因此与 .NET TPL 兼容。
- en: '.NET TPL is not just an infrastructure of a combination of implied asynchronous
    and parallelism. It focuses on these three features:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: .NET TPL 不仅仅是隐式异步和并行组合的基础设施。它专注于以下三个特性：
- en: Task-based parallelism
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于任务的并行
- en: Data parallelism
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据并行
- en: PLINQ, an implementation of LINQ in parallel, also called Parallel LINQ
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PLINQ，LINQ 的并行实现，也称为 Parallel LINQ
- en: 'Let''s learn more .NET TPL by visiting the MSDN Library .NET TPL landing page:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问 MSDN 图书馆 .NET TPL 登录页面，让我们更深入地了解 .NET TPL：
- en: '[https://msdn.microsoft.com/en-us/library/dd460693(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dd460693(v=vs.110).aspx)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/dd460693(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dd460693(v=vs.110).aspx)'
- en: 'According to MSDN, this is the overall high-level picture of .NET 4 TPL:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 MSDN，这是 .NET 4 TPL 的整体高级视图：
- en: '![Parallel programming with .NET TPL](img/image00302.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![使用 .NET TPL 进行并行编程](img/image00302.jpeg)'
- en: 'On the syntactic level, .NET TPL is conceptually divided into two:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法层面，.NET TPL 从概念上分为两个部分：
- en: Declarative parallel queries (for example, PLINQ)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式并行查询（例如，PLINQ）
- en: Imperative parallel (for example, `Parallel.ForEach`, with an additional parameter
    to maintain state consistency)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制性并行（例如，`Parallel.ForEach`，带有额外的参数以保持状态一致性）
- en: This picture is valid for .NET 4.5 and it is still valid for .NET 4.6/4.6.1
    as it illustrates the high-level of .NET TPL that includes data flow parallelism,
    which starts in .NET 4.5.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图适用于 .NET 4.5，并且对于 .NET 4.6/4.6.1 仍然有效，因为它说明了包括数据流并行（从 .NET 4.5 开始）在内的 .NET
    TPL 的高级视图。
- en: 'It is also worth noting that since .NET 4.5, there are the following new features
    in parallelism support:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，自 .NET 4.5 以来，在并行支持方面有以下新特性：
- en: Debugging parallelism is easier with parallel debugging support.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并行调试支持进行并行调试更容易。
- en: Dataflow libraries is essentially the same as F# `MailboxProcessor`.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据流库本质上与 F# 的 `MailboxProcessor` 相同。
- en: Coordinating data structures makes the existing concurrent data structures more
    concurrent-aware. This is essentially the same as the concurrent data structures
    that improve performance in .NET 4.5 and later.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调数据结构使现有的并发数据结构更加并发感知。这本质上与在 .NET 4.5 及以后版本中提高性能的并发数据结构相同。
- en: 'For more information on what''s new in .NET 4.5, 4.6 and 4.6.1, visit:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 .NET 4.5、4.6 和 4.6.1 中新功能的信息，请访问：
- en: '[https://msdn.microsoft.com/en-us/library/ms171868(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms171868(v=vs.110).aspx)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/ms171868(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms171868(v=vs.110).aspx)'
- en: 'For more information on what''s new in .NET 4.5 specific to parallel programming,
    visit this Microsoft MSDN blog by .NET parallel team (formerly ParallelFX):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有关.NET 4.5中针对并行编程的新功能的更多信息，请访问.NET并行团队（以前称为ParallelFX）的Microsoft MSDN博客：
- en: '[https://blogs.msdn.microsoft.com/pfxteam/2011/09/17/whats-new-for-parallelism-in-net-4-5/](https://blogs.msdn.microsoft.com/pfxteam/2011/09/17/whats-new-for-parallelism-in-net-4-5/)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://blogs.msdn.microsoft.com/pfxteam/2011/09/17/whats-new-for-parallelism-in-net-4-5/](https://blogs.msdn.microsoft.com/pfxteam/2011/09/17/whats-new-for-parallelism-in-net-4-5/)'
- en: There is a comparable message-passing agent library in .NET TPL; it is called
    *Dataflow*. The Dataflow library is not included in the original runtime distribution
    of .NET runtime and SDK. It is available to be downloaded as a separate NuGet
    package.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET TPL中有一个类似的消息传递代理库；它被称为*数据流*。数据流库不包括在.NET运行时和SDK的原始运行时分布中。它可以作为一个单独的NuGet包下载。
- en: Throughout this chapter, we are not going to discuss Dataflow libraries because
    we are focusing on F# `MailboxProcessor`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会讨论数据流库，因为我们专注于F#的`MailboxProcessor`。
- en: Note
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although .NET 4.0 is the starting release of .NET that has .NET TPL, some of
    the internal implementations of .NET TPL have bugs that have been fixed in .NET
    4.5 and later, especially the parallel debugging support. Beginning with [Chapter
    5](#aid-164MG2 "Chapter 5. Advanced Concurrency Support in F#"), *Advanced Concurrency
    Support in F#* all .NET TPL-related discussion should only be applied to .NET
    4.5 and later.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然.NET 4.0是.NET的起始版本，其中包含.NET TPL，但.NET TPL的一些内部实现中存在bug，这些bug已在.NET 4.5及以后的版本中修复，特别是并行调试支持。从[第5章](#aid-164MG2
    "第5章。F#的高级并发支持")开始，*F#的高级并发支持*中所有与.NET TPL相关的讨论仅适用于.NET 4.5及以后的版本。
- en: In the next section, we will discuss more about the TPL, from task-based parallelism
    to data parallelism.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地讨论TPL，从基于任务的并行性到数据并行性。
- en: Overview of task-based parallelism
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于任务的并行性概述
- en: 'Let''s visit task-based parallelism. The term *task* is actually the same concept
    of task as in the **Task based Asynchrony Pattern** (**TAP**) with one additional
    trait: it can run independently, as a concurrent unit. The consequence of a parallelized
    task as a concurrent unit is that it can run in parallel or may run as a chain
    of tasks some time in the future.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看基于任务的并行性。术语*任务*实际上与**基于任务的异步模式**（**TAP**）中的任务概念相同，但有一个额外的特性：它可以独立运行，作为一个并发单元。并行化任务作为并发单元的后果是它可以并行运行，或者可能在未来的某个时间作为任务链运行。
- en: All the parallel task operations are available from the `System.Threading.Tasks.Parallel`
    class, under the `mscorlib.dll` assembly. This means that we can use it immediately
    without referencing any assembly other than `mscorlib.dll`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 所有并行任务操作都可通过`System.Threading.Tasks.Parallel`类在`mscorlib.dll`程序集下访问。这意味着我们可以立即使用它，而无需引用除`mscorlib.dll`之外的任何程序集。
- en: This `Parallel` class has many `static` methods that provide support for task
    parallelism and data parallelism.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Parallel`类有许多`static`方法，为任务并行性和数据并行性提供支持。
- en: The task parallelism-related method in the `Parallel` class is the `Parallel.Invoke`
    method.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel`类中与任务并行性相关的方法是`Parallel.Invoke`方法。'
- en: 'This method has the following overloaded signatures; the first signature is
    as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有以下重载签名；第一个签名如下：
- en: '[PRE13]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The second signature of `Parallel.Invoke` is as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.Invoke`的第二个签名如下：'
- en: '[PRE14]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first signature defines `Invoke` to have one parameter-the parameter arrays
    of `Action` delegates. The `[<ParamArrayAttribute>]` is the same semantic as C#'s
    `param` keyword, but it has to be defined as an attribute parameter in F# to be
    used in a manner similar to `param` in C#.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个签名将`Invoke`定义为一个参数——`Action`委托的参数数组。`[<ParamArrayAttribute>]`与C#的`param`关键字具有相同的语义，但在F#中必须定义为属性参数，才能以类似于C#中`param`的方式使用。
- en: 'The second signature defines two parameters: `ParallelOptions`, a class to
    further configure the behavior of the parallelism we want to run, and the parameter
    arrays of `Action` delegates.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个签名定义了两个参数：`ParallelOptions`，一个用于进一步配置我们想要运行的并行行为的一个类，以及`Action`委托的参数数组。
- en: 'The documentation on the `Parallel.Invoke` method is available at:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.Invoke`方法的文档可在以下位置找到：'
- en: '[https://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.invoke(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.invoke(v=vs.110).aspx)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.invoke(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.invoke(v=vs.110).aspx)'
- en: Using `Parallel.Invoke` in F# is quite simple. For example, we can parallelize
    two different processes, the first process being factorial, and the second process
    getting all of the running processes on your local machine.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中使用 `Parallel.Invoke` 非常简单。例如，我们可以并行化两个不同的过程，第一个过程是阶乘，第二个过程是获取本地机器上所有正在运行的过程。
- en: 'The full sample code is as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例代码如下：
- en: '[PRE15]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The interesting fact about this code is how we interoperate with .NET `Action`
    delegate by simply instantiating a new `Action` delegate with the process we want
    to wrap as an `Action` delegate.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的有趣之处在于我们如何通过简单地实例化一个新的 `Action` 委托来与 .NET `Action` 委托进行交互，该委托将我们想要包装为 `Action`
    委托的过程包装起来。
- en: If we want to wrap a recursive function as an `Action` delegate, we need to
    wrap the function inside another function that always ignores the result, just
    as the `factwrap` function does. This is crucial, because `Action` delegate is
    a delegate that has no return value, or it returns a unit (`void` in C#).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将递归函数作为 `Action` 委托包装，我们需要将函数包装在另一个函数内部，该函数始终忽略结果，就像 `factwrap` 函数所做的那样。这是至关重要的，因为
    `Action` 委托是一个没有返回值的委托，或者它返回一个单元（在 C# 中为 `void`）。
- en: 'We can then add the line to run `Parallel.Invoke` and our delegates of `factwrap`
    and `runningprocesses` in our existing `EntryPoint` of `main`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在现有的 `main` 的 `EntryPoint` 中添加运行 `Parallel.Invoke` 和我们的 `factwrap` 和
    `runningprocesses` 委托的行：
- en: '[PRE16]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The sample `Parallel.Invoke` contains two delegates to be parallelized. But
    we can add many delegates as well, more than one as implied by `ParamArrayAttribute`
    marking.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 `Parallel.Invoke` 包含两个要并行化的委托。但我们可以添加更多的委托，比 `ParamArrayAttribute` 标记所暗示的更多。
- en: The parameter type of the array is the `Action[]` array. This means all of our
    functions must have a function body and return `void`, not just a result of a
    process. This is why the `fact` function must be wrapped into another function
    that runs `fact` and ignores the returning result, and the `runningProcesses`
    function body is explicitly contained within a lambda function that takes a unit
    as its parameter.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的参数类型是 `Action[]` 数组。这意味着我们所有的函数都必须有一个函数体并返回 `void`，而不仅仅是过程的返回结果。这就是为什么 `fact`
    函数必须被包装在另一个函数中，该函数运行 `fact` 并忽略返回结果，而 `runningProcesses` 函数体被显式包含在一个以单元作为其参数的
    lambda 函数中。
- en: If we do not declare `runningProcesses` as explicitly declared within lambda,
    this function will be inferred to have a generic type as its parameter because
    F# needs an explicit declaration of the parameter type. And we will catch other
    compile errors because the `Action` delegate also requires a signature of a function
    that takes no parameter and returns nothing.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在 lambda 表达式中显式声明 `runningProcesses`，则此函数将被推断为具有泛型类型作为其参数，因为 F# 需要显式声明参数类型。我们还将遇到其他编译错误，因为
    `Action` 委托还需要一个没有参数且无返回值的函数签名。
- en: 'The following is the signature of the `Action` delegate:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 `Action` 委托的签名：
- en: '[PRE17]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `delegate` keyword in this sense is the .NET BCL delegate, not F# delegate.
    The delegate of F# represents an F# function, and this F# function will be compiled
    as an inheritance of F# `FastFunction`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，`delegate` 关键字是 .NET BCL 委托，而不是 F# 委托。F# 委托代表一个 F# 函数，这个 F# 函数将被编译为 F#
    `FastFunction` 的继承。
- en: 'Let''s dive into the IL of the `factwrap` function and the inside declaration
    of `Action`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入到 `factwrap` 函数的 IL 和 `Action` 的内部声明：
- en: '[PRE18]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We now can see that it extends ``Microsoft.Core.FSharpFunc<`T1,`T2>``, which
    takes two generic type parameters. `T1` is the parameter of the delegate and `T2`
    is the returning type. `T1` is typed as unit and `T2` is typed as unit as well.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到它扩展了 `Microsoft.Core.FSharpFunc<`T1,`T2>`，它接受两个泛型类型参数。`T1` 是委托的参数，`T2`
    是返回类型。`T1` 被标记为单元类型，`T2` 同样也是单元类型。
- en: Let's visit the second overload of `Parallel.Invoke` that has `ParallelOptions`
    as its parameter.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们访问 `Parallel.Invoke` 的第二个重载，它以 `ParallelOptions` 作为其参数。
- en: 'The documentation of the `Parallel.Options` class is available at:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.Options` 类的文档可在以下位置找到：'
- en: '[https://msdn.microsoft.com/en-us/library/system.threading.tasks.paralleloptions(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.threading.tasks.paralleloptions(v=vs.110).aspx)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/system.threading.tasks.paralleloptions(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.threading.tasks.paralleloptions(v=vs.110).aspx)'
- en: The `ParallelOptions` class is basically a class to configure `Parallel.Invoke`
    further to meet custom concurrency requirements.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelOptions` 类基本上是一个用于进一步配置 `Parallel.Invoke` 以满足自定义并发需求的类。'
- en: 'The following are the properties of `ParallelOptions`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 `ParallelOptions` 的属性：
- en: '`CancellationToken`, to pass `CancellationToken` to cancel the running of invoked
    actions.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CancellationToken`，用于传递 `CancellationToken` 以取消正在运行的操作。'
- en: '`MaxDegreeOfParallelism`, to get or set the maximum number of concurrent tasks
    enabled by this `ParallelOptions` instance.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxDegreeOfParallelism`，用于获取或设置由此 `ParallelOptions` 实例启用的最大并发任务数。'
- en: '`TaskScheduler`, to get or set `TaskScheduler` associated with this `ParallelOptions`
    instance. Setting this property to null indicates that the current scheduler of
    the running thread from the current `threadpool` should be used.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskScheduler`，用于获取或设置与此 `ParallelOptions` 实例关联的 `TaskScheduler`。将此属性设置为 `null`
    表示应使用当前 `threadpool` 中运行线程的当前调度器。'
- en: We can also force the parallelism context to have a maximum degree of parallelism
    of `5` by passing this value to the property of `ParallelOptions.MaxDegreeOfParallelism`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过将此值传递给 `ParallelOptions.MaxDegreeOfParallelism` 属性来强制并行上下文具有最大并行度为 `5`。
- en: 'A quick sample of this (using our existing sample delegates) is as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个快速示例（使用我们现有的示例委托）：
- en: '[PRE19]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have now set the maximum degree of parallelism to `5`, and this is not a
    pessimistic value because we are only passing two `Action` delegates. Setting
    this value to `-1` will instruct `Parallel.Invoke` to run as parallelized to use
    available cores and available threads in the thread pool as often as possible.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将最大并行度设置为 `5`，这不是一个悲观值，因为我们只传递了两个 `Action` 委托。将此值设置为 `-1` 将指示 `Parallel.Invoke`
    尽可能地并行运行，以使用可用的核心和线程池中的可用线程。
- en: 'Be careful when setting a value for the `MaxDegreeOfParallelism` property.
    MSDN Library has additional cautions:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 `MaxDegreeOfParallelism` 属性的值时要小心。MSDN 库有额外的注意事项：
- en: 'On many cores:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多核心上：
- en: When you know that a particular algorithm you're using won't scale beyond a
    certain number of cores. You can set the property to avoid wasting cycles on additional
    cores.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你知道你使用的特定算法不会扩展到一定数量的核心之外时。你可以设置该属性以避免在额外的核心上浪费周期。
- en: 'On the implementation detail of the allocation of `thread` and `threadpool`
    resources:'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `thread` 和 `threadpool` 资源分配的实现细节：
- en: When you're running multiple algorithms concurrently and want to manually define
    how much of the system each algorithm can utilize. You can set a MaxDegreeOfParallelism
    value for each.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你同时运行多个算法并希望手动定义每个算法可以使用的系统资源量时。你可以为每个算法设置一个 `MaxDegreeOfParallelism` 值。
- en: When the thread pool's heuristics are unable to determine the right number of
    threads to use and could end up injecting too many threads. For example, in long-running
    loop body iterations, the thread pool might not be able to tell the difference
    between reasonable progress or livelock or deadlock, and might not be able to
    reclaim threads that were added to improve performance. In this case, you can
    set the property to ensure that you don't use more than a reasonable number of
    threads.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当线程池的启发式算法无法确定要使用多少线程，并可能导致注入过多的线程时。例如，在长时间运行的循环体迭代中，线程池可能无法区分合理的进度或活锁或死锁，并且可能无法回收为提高性能而添加的线程。在这种情况下，你可以设置该属性以确保你不会使用超过合理数量的线程。
- en: The lock in the parallel invocation (in the last bullet) implies that any global
    and shared state, if used inside a `Parallel.Invoke` delegate, is prone to an
    unpredictable state; therefore, a lock should be used. But locking objects in
    the middle of parallelism might bring deadlock itself because many threads are
    racing to modify and there is no guarantee which one will have an exclusive lock
    and will not block others.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行调用（在最后一个要点中）中的锁意味着任何全局和共享状态，如果在使用 `Parallel.Invoke` 委托内部使用，则容易处于不可预测的状态；因此，应该使用锁。但并行过程中在中间锁定对象可能会带来死锁本身，因为许多线程都在争相修改，并且无法保证哪个线程将获得独占锁并且不会阻塞其他线程。
- en: To see further what goes on when we invoke delegates to be parallelized, we
    could leverage the existing parallel debugging tool in Visual Studio, available
    since Visual Studio 2012.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步了解当我们调用要并行化的委托时发生了什么，我们可以利用 Visual Studio 中现有的并行调试工具，该工具自 Visual Studio
    2012 以来可用。
- en: Quick start-using the parallel debugging tool in Visual Studio
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速入门 - 使用 Visual Studio 中的并行调试工具
- en: Now let's use the parallel debugging capability of Visual Studio and .NET 4.5+.
    Put breakpoint in the line of `Parallel.Invoke` and inside `factwrap` and `runningProcesses`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用 Visual Studio 和 .NET 4.5+ 的并行调试功能。在 `Parallel.Invoke` 行以及 `factwrap`
    和 `runningProcesses` 内设置断点。
- en: Press *F5* to run with debugging.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *F5* 运行时进行调试。
- en: 'When it stops at `Parallel.Invoke`, open the **Parallel Stacks** visualizer
    by choosing **Debug** | **Windows** | **Parallel Stacks**. We also open **Tasks**
    by choosing **Debug** | **Windows** | **Tasks**:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当它停在`Parallel.Invoke`时，通过选择**调试** | **窗口** | **并行堆栈**来打开**并行堆栈**可视化工具。我们还可以通过选择**调试**
    | **窗口** | **任务**来打开**任务**：
- en: '![Quick start-using the parallel debugging tool in Visual Studio](img/image00303.jpeg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio中并行调试工具的快速入门](img/image00303.jpeg)'
- en: As visualized in the screenshot, the **Tasks** window already displays the current
    task of the active task.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如截图所示，**任务**窗口已经显示了当前任务的活动任务。
- en: 'Press `F11` to step into the next function. At the first round, it will go
    through `factwrap` and a new thread is created:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 按`F11`键进入下一个函数。在第一轮中，它将通过`factwrap`并创建一个新线程：
- en: '![Quick start-using the parallel debugging tool in Visual Studio](img/image00304.jpeg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio中并行调试工具的快速入门](img/image00304.jpeg)'
- en: As `factwrap` is calling `fact`, the `fact` function body is also debugged for
    the number or parameter we passed into `factwrap`, in this case it is 5, as factorial
    of 5.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`factwrap`正在调用`fact`，因此对于传递给`factwrap`的数字或参数，也会调试`fact`函数体，在这种情况下是5，即5的阶乘。
- en: 'This is pictured nicely in **Parallel Stacks**:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这在**并行堆栈**中表现得很好：
- en: '![Quick start-using the parallel debugging tool in Visual Studio](img/image00305.jpeg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio中并行调试工具的快速入门](img/image00305.jpeg)'
- en: In the preceding screenshot, we can nicely see that it spawns a new thread to
    hold the `runningProcesses` delegate. In terms of the thread pool, all of these
    threads are in one thread pool, so it is efficiently executed within the same
    context of running the thread of the code that runs `Parallel.Invoke`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以清楚地看到它创建了一个新线程来持有`runningProcesses`代理。在线程池方面，所有这些线程都在一个线程池中，因此它们在运行`Parallel.Invoke`代码的线程的同一上下文中高效执行。
- en: 'As we go further into the `fact` function and leave the recursive, we can also
    see that **Parallel Stacks** displays the related call stack with the matched
    debug breakpoint:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进一步进入`fact`函数并离开递归时，我们还可以看到**并行堆栈**显示与匹配的调试断点相关的调用堆栈：
- en: '![Quick start-using the parallel debugging tool in Visual Studio](img/image00306.jpeg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![Visual Studio中并行调试工具的快速入门](img/image00306.jpeg)'
- en: After it finishes executing the `Parallel.Invoke`, the current thread will go
    back to our entrypoint of `main`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行完`Parallel.Invoke`后，当前线程将返回到我们的`main`入口点。
- en: 'For more information on using parallel debugging (including multithread debugging)
    in Visual Studio, consult the following MSDN Library page:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在Visual Studio中使用并行调试（包括多线程调试）的更多信息，请参阅以下MSDN库页面：
- en: '[https://msdn.microsoft.com/en-us/library/ms164746.aspx](https://msdn.microsoft.com/en-us/library/ms164746.aspx)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/ms164746.aspx](https://msdn.microsoft.com/en-us/library/ms164746.aspx)'
- en: 'For more information about **Parallel Stacks**, consult the following MSDN
    Library page:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**并行堆栈**的更多信息，请参阅以下MSDN库页面：
- en: '[https://msdn.microsoft.com/en-us/library/dd998398.aspx](https://msdn.microsoft.com/en-us/library/dd998398.aspx)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/dd998398.aspx](https://msdn.microsoft.com/en-us/library/dd998398.aspx)'
- en: Note
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The current offline documentation of the MSDN Library in Visual Studio 2015
    (opened with MS Help) section of Visual Studio debugging is not updated. It is
    not in sync with the latest documentation of Visual Studio in the online MSDN
    Library. It is highly recommended to always have the offline MSDN Library installed
    and updated first, but we should check the online MSDN Library for the latest
    update.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2015（通过MS帮助打开）中Visual Studio调试的当前离线文档未更新。它与在线MSDN库中Visual Studio的最新文档不同步。强烈建议始终先安装并更新离线MSDN库，但我们也应检查在线MSDN库的最新更新。
- en: Also, since we already know that F# documentation is open source, we should
    also always check the online documentation for the latest update. Starting from
    this chapter, more resources will be emphasized on online MSDN Library.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们已经知道F#文档是开源的，因此我们也应始终检查在线文档的最新更新。从本章开始，将强调更多在线MSDN库的资源。
- en: Overview of data parallelism
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据并行概述
- en: Data parallelism in .NET TPL is actually a library of functions/methods that
    have parallel operations on certain data operations, such as enumerating data.
    It is can also be seen as declarative because it is very closely related to the
    existing language features of how F# iterates a collection (using F# `for` loop).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: .NET TPL 中的数据并行实际上是一组函数/方法库，它们在特定的数据操作上具有并行操作，例如枚举数据。它也可以被视为声明性的，因为它与 F# 如何迭代集合（使用
    F# `for` 循环）的现有语言特性非常紧密相关。
- en: It is also clearly stated in the MSDN Library that this data parallelism is
    only for a collection (such as IEnumerable) and array, not for encapsulating operations
    to be parallelized, such as task parallelism. The main focus of data parallelism
    is parallelizing `for`, either `for` with counter or `foreach`, to directly iterate
    through the elements of the collection.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN 库中也明确指出，这种数据并行性仅适用于集合（如 IEnumerable）和数组，不适用于封装要并行化的操作，如任务并行性。数据并行性的主要重点是并行化
    `for` 循环，无论是带有计数器的 `for` 还是 `foreach`，以直接遍历集合的元素。
- en: In F#, `foreach` is represented by the for .. in construct, and it's conceptually
    and contextually the same as `foreach` in C#/VB, although it is semantically different.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，`foreach` 由 for .. in 构造表示，在概念和上下文中与 C#/VB 中的 `foreach` 相同，尽管在语义上有所不同。
- en: 'The following methods are the operations of data parallelism:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法执行数据并行操作：
- en: '`Parallel.For`, to have loops with counter (it may act as a starting value
    when incremented), and this `For` does not run sequentially as compared with the
    basic for'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parallel.For`，用于具有计数器的循环（它可能在增加时充当起始值），与基本的 `for` 相比，这个 `For` 循环不按顺序运行'
- en: '`Parallel.ForEach`, to have `foreach` in parallel when iterating elements'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parallel.ForEach`，在迭代元素时实现并行 `foreach`'
- en: The `Parallel.For` is related to the `for` loop of F# that has predefined from
    and stopping values to be counter for the loop.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.For` 与 F# 中具有预定义的起始和停止值的 `for` 循环相关联，该循环用于循环计数器。'
- en: 'For example, consider the following code snippet:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码片段：
- en: '[PRE20]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `function1` will run sequentially from `1` to `10`, and it will always run
    synchronously, which means that the first iteration has to be finished first before
    running the next iterations. The rest of the iterations still have to wait; therefore,
    it is intentional and it is also trivial that the execution behavior of the first
    iteration blocks the next remaining iterations.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`function1` 将按顺序从 `1` 到 `10` 运行，并且它总是同步运行，这意味着必须先完成第一次迭代，然后才能运行下一次迭代。其余的迭代仍然需要等待；因此，这是故意的，并且很明显，第一次迭代的执行行为会阻塞后续的迭代。'
- en: The `parallelFunction1` is a parallel version of `function1`. In the function
    body, we add the display of the current iterations by passing the counter into
    the output display.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallelFunction1` 是 `function1` 的并行版本。在函数体中，我们通过将计数器传递到输出显示来添加当前迭代的显示。'
- en: 'We shall put the code as F# script, run the script inside Visual Studio **F#
    Interactive**, and immediately see the result:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将代码作为 F# 脚本，在 Visual Studio **F# Interactive** 中运行脚本，并立即看到结果：
- en: '![Overview of data parallelism](img/image00307.jpeg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![数据并行概述](img/image00307.jpeg)'
- en: Here, we can see the proof that there is no guarantee that the loop will execute
    sequentially. This is intentional because in parallelism, we do not care about
    the order of the executions, as we explored in the section, *Introducing concurrency
    support in F# 4* in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction
    to Concurrency in F#"), *Introduction to Concurrency in F#*.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到没有保证循环将按顺序执行的证据。这是故意的，因为在并行处理中，我们并不关心执行顺序，正如我们在第 4 章中探讨的，*在 F# 4 中引入并发支持*，在
    [第 4 章](fsp-hiperf_cu04.html#aid-11C3M2 "第 4 章。F# 并发简介")，*F# 并发简介*。
- en: Now, we visit the parallel pair of the F# `for .. in` loop, and the `Parallel.ForEach`
    method.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来探讨 F# 的 `for .. in` 循环和 `Parallel.ForEach` 方法的并行对。
- en: 'We now start from the simple sample of iterating a collection in F# using the
    `for .. in` loop and put it into parallel:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在从简单的 F# 使用 `for .. in` 循环迭代集合的示例开始，并将其并行化：
- en: '[PRE21]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, run the code in **F# Interactive**, and we can compare the output:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在 **F# Interactive** 中运行代码，我们可以比较输出：
- en: '![Overview of data parallelism](img/image00308.jpeg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![数据并行概述](img/image00308.jpeg)'
- en: Now, we have interoperability of .NET TPL's data parallelism in F#. As long
    as we carefully keep the process as simple as possible (without shared state),
    we can have a successful implementation of parallelism with a highly predictable
    result.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在F#中有了.NET TPL的数据并行性的互操作性。只要我们尽可能保持过程简单（没有共享状态），我们就可以成功实现并行性，并得到高度可预测的结果。
- en: This is also a good example of minimizing unpredictability by keeping the side
    effects as minimal as possible. We can still use shared state, but then, we have
    to implement locking as well, and this will decrease the performance. The background
    reason for this decreasing performance is the same as having locks in an asynchronous
    workflow.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个通过尽可能减少副作用来最小化不可预测性的好例子。我们仍然可以使用共享状态，但那时，我们必须实现锁定，这将降低性能。这种性能降低的背景原因与在异步工作流中使用锁是相同的。
- en: Common potential pitfalls in parallel programming
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行编程中的常见潜在陷阱
- en: There are common pitfalls for parallel programming in .NET, and we should pay
    attention to these.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，并行编程存在一些常见的陷阱，我们应该注意这些。
- en: 'We know that we should avoid the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道应该避免以下情况：
- en: Side effects in mutable states of an object. If a mutable state is used, a lock
    has to be implemented to ensure concurrency of the object state. This is also
    applied to shared states, because any shared state is also mutable as well.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的可变状态中的副作用。如果使用可变状态，必须实现锁来确保对象状态的并发性。这也适用于共享状态，因为任何共享状态也是可变的。
- en: A side effect in the possibility of having an exception. If we do not catch
    any possible exception (especially exceptions related to blocking operations such
    as I/O), any exceptions thrown in the middle of any parallel processes will cancel
    the whole pipeline of the parallel process.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能抛出异常的可能性中存在副作用。如果我们没有捕获任何可能的异常（特别是与阻塞操作（如I/O）相关的异常），任何在并行过程中抛出的异常都将取消整个并行过程的管道。
- en: COM objects, because we have to be careful when handling an object that has
    a different apartment model, such as COM objects.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: COM对象，因为我们处理具有不同公寓模型的对象时必须小心，例如COM对象。
- en: Side effects of mixing a UI thread with the current thread from a non-UI thread.
    In WPF, this can be mitigated by using WPF Dispatcher.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将UI线程与来自非UI线程的当前线程混合的副作用。在WPF中，可以通过使用WPF分发器来减轻这种影响。
- en: Now, let's try to handle mutable states in the next section.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在下一节中处理可变状态。
- en: Overview of handling mutable state
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变状态的概述
- en: If we want to really have a mutable state, we can enclose it in a pair of `Monitor.Enter`
    and `Monitor.Exit` loops.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想要一个可变状态，我们可以将其封装在`Monitor.Enter`和`Monitor.Exit`循环对中。
- en: 'For example, we can code this using a simplified sample of how the lock in
    C#/VB is actually implemented:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过以下简化的示例来编写代码，展示C#/VB中锁的实际实现方式：
- en: '[PRE22]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This watching state is the reason why .NET names the object to watch the state
    as `Monitor`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这种监视状态是.NET将监视状态的对象命名为`Monitor`的原因。
- en: 'We will not describe the `Monitor` object further because Monitor is part of
    an object locking mechanism that is not recommended in many cases of F# concurrency
    implementation. We shall focus only on the functional aspects of F# concurrency
    rather than dealing with mutable state, which is common for non-functional programming
    style code. For more information on .NET Monitor, visit the following link:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会进一步描述`Monitor`对象，因为`Monitor`是对象锁定机制的一部分，在许多F#并发实现的场景中并不推荐。我们将只关注F#并发的功能方面，而不是处理非功能性编程风格代码中常见的可变状态。有关.NET
    Monitor的更多信息，请访问以下链接：
- en: '[https://msdn.microsoft.com/en-us/library/system.threading.monitor(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.threading.monitor(v=vs.110).aspx)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/system.threading.monitor(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.threading.monitor(v=vs.110).aspx)'
- en: There is also a class in .NET BCL to allow mixing mutable state for simple operations,
    such as increment and decrement inside a parallel loop. The class is `System.Threading.Interlocked`,
    and it is also used internally in F# to implement asynchronous workflows in `Control.Async`
    and builders in the `FSharpAsyncBuilder` class.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: .NET BCL中还有一个类允许在简单操作中混合可变状态，例如在并行循环中执行增加和减少操作。该类是`System.Threading.Interlocked`，它也在F#内部用于实现`Control.Async`中的异步工作流和`FSharpAsyncBuilder`类中的构建器。
- en: 'The implementation of using `Interlocked` is not common, and we should be careful.
    This is why it has a limited kind of allowable operations. We can see a good sample
    implementation of leveraging `Interlocked` in the internal implementation of F#
    `Async.Parallel` code:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Interlocked`的实现并不常见，我们应该小心。这就是为什么它有有限种类的允许操作。我们可以在F# `Async.Parallel`代码的内部实现中看到利用`Interlocked`的一个很好的示例实现：
- en: '[PRE23]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this code, `Interlocked.Decrement` is used to maintain or keep track of the
    state of the counter of the number of parallelized asynchronous workflows. The
    code flows nicely because F# has its own parallel asynchronous operation without
    depending on the .NET TPL `Parallel` class.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，使用`Interlocked.Decrement`来维护或跟踪并行化异步工作流计数的状态。代码流畅，因为F#有自己的并行异步操作，而不依赖于.NET
    TPL的`Parallel`类。
- en: 'In the MSDN Library, there are additional aspects of common pitfalls of parallel
    programming available at the following page:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在MSDN库中，有关并行编程常见陷阱的更多方面，可在以下页面找到：
- en: '[https://msdn.microsoft.com/en-us/library/dd997392(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dd997392(v=vs.110).aspx)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/dd997392(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dd997392(v=vs.110).aspx)'
- en: 'Among those points, we should pay attention to the following examples in the
    MSDN Library article, in addition to the many samples of asynchrony and parallelism
    that we explored:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些要点中，我们应关注MSDN库文章中的以下示例，除了我们探索的许多异步和并行化的示例：
- en: Avoid over-parallelization. By using parallel loops, you incur the overhead
    costs of partitioning the source collection and synchronizing the worker threads.
    The benefits of parallelization are further limited by the number of processors
    and the cores on the computer. There is no speedup to be gained by running multiple
    compute-bound threads on just one processor. Therefore, you must be careful not
    to over-parallelize a loop. Also, too many parallelizations increase the overheads
    on the task scheduler and it may lead to a race condition on the thread affinities
    being obtained. Also, having overheads on a task scheduler will decrease the responsiveness
    of the running application.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免过度并行化。通过使用并行循环，你需要承担分割源集合和同步工作线程的开销成本。并行化的好处还受到计算机处理器和核心数量的限制。在单个处理器上运行多个计算密集型线程并不能获得速度提升。因此，你必须小心不要过度并行化循环。此外，过多的并行化会增加任务调度器的开销，可能会导致线程亲和力上的竞争条件。此外，任务调度器上的开销会降低运行应用程序的响应性。
- en: Avoid calls to non-thread-safe methods! This is extremely important, because
    writing to non-thread-safe instance methods from a parallel loop can lead to data
    corruption, which may or may not go undetected in your program. It can also lead
    to exceptions, for example, multiple parallel threads of calling `FileStream.WriteByte`.
    This point is closely related to avoiding mixing I/O operations. It is also necessary
    to be aware that almost all of the operations in `Stream`, `File`, and `System.Web`
    classes are not thread-safe at all.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免调用非线程安全的方法！这一点非常重要，因为从并行循环中写入非线程安全的实例方法可能会导致数据损坏，这可能在你的程序中不被检测到。它也可能导致异常，例如，多个并行线程调用`FileStream.WriteByte`。这一点与避免混合I/O操作密切相关。还需要意识到，`Stream`、`File`和`System.Web`类中的几乎所有操作都不是线程安全的。
- en: Avoid changing thread affinity in the middle of any parallel operation. This
    might yield exceptions and not just unpredictable results/behaviors.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在任何并行操作过程中更改线程亲和力。这可能会产生异常，而不仅仅是不可预测的结果/行为。
- en: 'The most common scenario in which over-parallelization can occur is in nested
    loops. In most cases, it is best to parallelize only the outer loop unless one
    or more of the following conditions apply:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 过度并行化最常见的情况发生在嵌套循环中。在大多数情况下，最好只并行化外部循环，除非以下条件之一适用：
- en: The inner loop is known to be very long. You are performing an *expensive computation*
    on each order. The term expensive computation in this context means having complex
    calculations that will consume a lot of CPU cycles and also having a parallel
    computation inside a parallel computation or *complex nested parallelizations*.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内循环已知非常长。你正在对每个订单执行*昂贵的计算*。在这个上下文中，昂贵的计算意味着有复杂的计算，将消耗大量的CPU周期，并且在并行计算内部进行并行计算或*复杂的嵌套并行化*。
- en: The target system is known to have enough processors to handle the number of
    threads that will be produced by parallelizing the operation. Having too many
    degrees of parallelism, especially if the number of parallelism is higher than
    the number of CPU core, will enforce other processes to wait indefinitely, and
    this waiting will also result in a deadlock condition.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知目标系统有足够的处理器来处理由并行化操作产生的线程数量。如果并行化的程度过高，尤其是当并行化的数量超过 CPU 核心数时，将迫使其他进程无限期地等待，这种等待也将导致死锁条件。
- en: 'We can also have a further reference to .NET parallelism from Microsoft by
    downloading the white paper titled *Patterns for Parallel Programming: Understanding
    and Applying Parallel Patterns with the .NET Framework 4* from the following official
    download link:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还可以通过从以下官方下载链接下载微软的关于 .NET 并行性的白皮书来进一步参考 .NET 并行性：*Patterns for Parallel
    Programming: Understanding and Applying Parallel Patterns with the .NET Framework
    4*：'
- en: '[https://www.microsoft.com/en-us/download/details.aspx?id=19222](https://www.microsoft.com/en-us/download/details.aspx?id=19222)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.microsoft.com/en-us/download/details.aspx?id=19222](https://www.microsoft.com/en-us/download/details.aspx?id=19222)'
- en: Summary
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have explored the advanced concurrency support in F# and .NET TPL. We also
    have enough knowledge about how we should handle side effects and also on using
    asynchronous for various cases and scenarios.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了 F# 和 .NET TPL 的高级并发支持。我们也对如何处理副作用以及在不同情况和场景中使用异步编程有了足够的了解。
- en: The main conclusion when implementing the best practices of leveraging concurrency
    in F# is that there is no silver bullet for all concurrency needs, and this includes
    avoiding the assumption that parallelized code always runs faster than non-parallel
    code after examining cases that may bring down the performance of parallel implementation
    in .NET TPL. These warning cases can be applied not just in F# but also in VB/C#.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施 F# 中利用并发最佳实践的主要结论是，对于所有并发需求来说，并没有一劳永逸的解决方案，这包括避免在检查可能导致 .NET TPL 并行实现性能下降的案例后，认为并行化代码总是比非并行代码运行得更快。这些警告案例不仅适用于
    F#，也适用于 VB/C#。
- en: We have understood asynchrony and parallelism. We will use this knowledge to
    optimize the type providers and avoid the pitfalls of implementing them in [Chapter
    6](fsp-hiperf_cu06.html#aid-19UOO2 "Chapter 6. Optimizing Type Provider"), *Optimizing
    Type Provider* .
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经理解了异步和并行性。我们将利用这些知识来优化类型提供者，并避免在[第 6 章](fsp-hiperf_cu06.html#aid-19UOO2
    "第 6 章。优化类型提供者") *优化类型提供者* 中实现它们的陷阱。
