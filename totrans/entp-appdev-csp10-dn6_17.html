<html><head></head><body>
		<div id="_idContainer196">
			<h1 id="_idParaDest-239"><em class="italic"><a id="_idTextAnchor1531"/>Chapter 13</em>: Implementing Authorization in .NET 6</h1>
			<p>One of the important aspects of building secure applications is to ensure that users have access only to the resources that they need. In the real world, when you check in to a hotel, a front-desk employee validates your ID and credit card and assigns a key card to access your room. Based on the type of room you have chosen, you may have privileges, such as access to the lounge, pool, or gym, among others. Here, the validation of your ID and credit card and assigning a key card is called <strong class="bold">authentication</strong>, and permitting you to access the various resources is called <strong class="bold">authorization</strong>. So, to explain it further, using a key card, we cannot identify who you are but can determine what you can do.</p>
			<p>Authorization is a mechanism by which you determine what users can do and grant or deny access to a resource of your application. For instance, users of our e-commerce application should be able to browse products, add them to the cart, and check out to buy them, and only admin or back-office users should be able to add or update product information, update the price of products, and approve or reject orders.</p>
			<p>In this chapter, we will learn what authorization is and the various ways to implement authorization using the ASP.NET Core framework. The following topics are covered in this chapter:</p>
			<ul>
				<li>Understanding authorization in .NET 6</li>
				<li>Simple authorization</li>
				<li>Role-based authorization</li>
				<li>Claims-based authorization</li>
				<li>Policy-based authorization</li>
				<li>Custom authorization</li>
				<li>Authorization in client and server applications</li>
			</ul>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor1532"/><a id="_idTextAnchor1533"/>Technical requirements</h1>
			<p>For this chapter, you need basic knowledge of Azure, Azure AD B2C, C#, .NET Core, and Visual Studio 2022.</p>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor1534"/><a id="_idTextAnchor1535"/>Back to a few basics</h1>
			<p>Before we dig<a id="_idIndexMarker1203"/> into <a id="_idIndexMarker1204"/>more details, let's understand the differences between authentication and authorization.</p>
			<p>Authenticatio<a id="_idTextAnchor1536"/>n and authorizati<a id="_idTextAnchor1537"/>on may look similar and be used interchangeably, but fundamentally they are different. The following table illustrate<a id="_idTextAnchor1538"/>s the differences:<a id="_idTextAnchor1539"/></p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/Table_13.1.jpg" alt="Table 13.1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 13.1</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Refer to <a href="B18507_12_Epub.xhtml#_idTextAnchor1389"><em class="italic">Chapter 12</em></a>,<em class="italic"> Understanding Authentication</em>, for more details on how authentication works in ASP.NET 6.</p>
			<p>To summarize this, authentication and authorization go hand in hand. Authorization works only after the identity of the user has been established, and an authentication challenge is triggered by authorization when a user tries to access a secure resource. In the upcoming sections of this chapter, we will understand how to implement authorization in ASP.NET 6 applications.<a id="_idTextAnchor1540"/><a id="_idTextAnchor1541"/></p>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor1542"/>Understanding authorization</h1>
			<p>Authorization<a id="_idTextAnchor1543"/><a id="_idIndexMarker1205"/> in ASP.NET Core is handled by a <strong class="bold">middleware</strong>. When your application receives the first request from an unauthenticated user to a secured resource, an authentication challenge is invoked by the middleware, and depending on the authentication scheme, the user is either redirected to log in or access is forbidden. Once the identity of the user has been established after authentication, the authorization middleware checks whether the user can access the resource or not. In subsequent requests, the authorization middleware uses the identity of the user to determine whether access is allowed or forbidden.</p>
			<p>To configure authorization middleware in your project, you need to invoke <strong class="source-inline">UseAuthorization()</strong> in <strong class="source-inline">Program.cs</strong>. It is mandatory to register authorization middleware only after authentication middleware, as authorization can be performed only after establishing the user's identity. Refer to the following code:</p>
			<pre class="source-code">var builder = WebApplication.CreateBuilder(args);</pre>
			<pre class="source-code">..</pre>
			<pre class="source-code">var app = builder.Build();</pre>
			<pre class="source-code">a<a id="_idTextAnchor1544"/>pp.UseAuthentication();</pre>
			<pre class="source-code">app.<strong class="bold">UseAuthorization</strong>();</pre>
			<pre class="source-code">app.UseEndpoints(endpoints =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">endpoints.MapControllerRoute(</pre>
			<pre class="source-code">    name: "default",</pre>
			<pre class="source-code">    pattern: "{controller=Home}/{action=Index}/{id?}");</pre>
			<pre class="source-code">    endpoints.MapRazorPages();</pre>
			<pre class="source-code">});</pre>
			<p>In the preceding code block, you'll notice that <strong class="source-inline">app.UseAuthorization()</strong> is invoked after <strong class="source-inline">app.UseAuthentication()</strong> and before <strong class="source-inline">app.UseEndpoints()</strong>.</p>
			<p>ASP.NET 6 provides simple, declarative role- and claims-based authorization models and rich policy-based <a id="_idIndexMarker1206"/>models. In the following sections, we will learn more details about thes<a id="_idTextAnchor1545"/><a id="_idTextAnchor1546"/>e.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor1547"/>Simple authorization</h2>
			<p>In ASP.NET Core, authorizati<a id="_idTextAnchor1548"/>on is configured using <strong class="source-inline">AuthorizationAttribute</strong>. <a id="_idTextAnchor1549"/>You can apply the <strong class="source-inline">[Authorize]</strong> attribute on a controller, action, or Razor page. When you add this attri<a id="_idTextAnchor1550"/>bute, access to that component is restricted only to authenticated users. Refer to<a id="_idIndexMarker1207"/> the following code block:</p>
			<pre class="source-code">public class HomeController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">[<strong class="bold">Authorize</strong>]</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public IActionResult Privacy()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code, you'll notice that the <strong class="source-inline">[Authorize]</strong> attribute is added to the <strong class="source-inline">Index</strong> action. When a user tries to access <strong class="source-inline">/Home/Index</strong> from the browser, the middleware checks whether the user is authenticated or not. If not, the user is redirected to the login page.</p>
			<p>If we add the <strong class="source-inline">[Authorize]</strong> attribute to a controller, access to any action under that controller is restricted only to authenticated users. In the following code, you'll notice that the <strong class="source-inline">[Authorize]</strong> attribute is added to <strong class="source-inline">HomeController</strong>, making all actions under it secure:</p>
			<pre class="source-code">[<strong class="bold">Authorize</strong>]</pre>
			<pre class="source-code">public class HomeController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">[<strong class="bold">AllowAnonymous</strong>]</pre>
			<pre class="source-code">public IActionResult Privacy()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>At times, you<a id="_idTextAnchor1551"/> may want to allow a few areas of your application<a id="_idTextAnchor1552"/> to be accessible to any user; for <a id="_idIndexMarker1208"/>example, the login or reset password page should be open to all, regardless of whether the user is authenticated or not. To meet such requirements, you can add the <strong class="source-inline">[AllowAnonymous]</strong> attribute to a controller or an action and make them available to unauthenticated users as well.</p>
			<p>In the preceding code, you'll notice that the <strong class="source-inline">[AllowAnonymous]</strong> attribute is added to the <strong class="source-inline">Privacy</strong> action, though we have the <strong class="source-inline">[Authorize]</strong> attribute on the controller. That requirement is overridden by the <strong class="source-inline">[AllowAnonymous]</strong> attribute on the action method and so the <strong class="source-inline">Privacy</strong> action is accessible by all users.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">[AllowAnonymous]</strong> attribute overrides all authorization configurations. If you set <strong class="source-inline">[AllowAnonymous]</strong> on a controller, setting the <strong class="source-inline">[Authorize]</strong> attribute on any action methods under it will have no impact. In this case, the <strong class="source-inline">Authorize</strong> attribute on the action methods is completely ignored.</p>
			<p>So far, we have seen ho<a id="_idTextAnchor1553"/>w to secure a controller or an action method. In<a id="_idTextAnchor1554"/> the next section, we will <a id="_idIndexMarker1209"/>see how to enable authorization globally in an ASP.NET Core applica<a id="_idTextAnchor1555"/><a id="_idTextAnchor1556"/>tion.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor1557"/>Enabling authorization globally</h2>
			<p>So far, we have <a id="_idIndexMarker1210"/>seen<a id="_idTextAnchor1558"/> how to secure a controller or an action method using the <strong class="source-inline">[Authorize]</strong> attribute. Setting the <strong class="source-inline">authorize</strong> attribute on every controller or action is not sustainable in large projects; you may miss configuring it on newly added controllers or action methods, which can lead to a security vulnerability.</p>
			<p>ASP.NET Core allows you to enable authorization globally by adding a fallback policy in your application. You can define a fallback policy in <strong class="source-inline">Program.cs</strong>. The fallback policy will be applied to all requests where no explicit authorization requirement is defined:</p>
			<pre class="source-code">var builder = WebApplication.CreateBuilder(args);</pre>
			<pre class="source-code">builder.Services.AddAuthorization(options =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">options.FallbackPolicy = new AuthorizationPolicyBuilder()</pre>
			<pre class="source-code">        .RequireAuthenticatedUser()</pre>
			<pre class="source-code">        .Build();</pre>
			<pre class="source-code">});</pre>
			<p>Adding a policy globally enforces users to be authenticated to access any action method in your application. This option is beneficial as you don't have to specify the <strong class="source-inline">[Authorize]</strong> attribute for every controller/action in your application.</p>
			<p>You can still set the <strong class="source-inline">[AllowAnonymous]</strong> attribute on a controller or action method to override the fallback behavior and make it anonymously accessible.</p>
			<p>Now that we understand how to implement simple authorization, in the next section, let's understand what role-based authorization is and how it simplifies implement<a id="_idTextAnchor1559"/><a id="_idTextAnchor1560"/>ation.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor1561"/>Role-based authorization</h1>
			<p>It is quite common<a id="_idIndexMarker1211"/> for certain a<a id="_idTextAnchor1562"/>reas of your application to be a<a id="_idTextAnchor1563"/>vailable to only certain users. Instead of granting access at the user level, general practice is to group users into roles and grant access to roles. Let's consider a typical e-commerce application, in which <em class="italic">users</em> can place orders, <em class="italic">support</em> staff can view, update, or cancel orders and resolve user queries, and the <em class="italic">admin</em> role approves or rejects orders, manages inventory, and so on.</p>
			<p>Role-based authorization can address such requirements. When you create a user, you may assign it to one or more roles, and when we configure the <strong class="source-inline">[Authorize]</strong> attribute, we can pass one or more role names to the <strong class="source-inline">Roles</strong> property of the <strong class="source-inline">Authorize</strong> attribute.</p>
			<p>The following code restricts access to all action methods under the <strong class="source-inline">Admin</strong> controller to users who belong to the <strong class="source-inline">Admin</strong> role:</p>
			<pre class="source-code">[Authorize(Roles ="Admin")]</pre>
			<pre class="source-code">public class AdminController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>Similarly, you can specify comma-separated role names in the <strong class="source-inline">Roles</strong> property of the <strong class="source-inline">Authorize</strong> attribute, so that users who belong to either of the configured roles will have access to the action methods under that controller.</p>
			<p>In the following code, you'll notice <strong class="source-inline">User,Support</strong> is supplied as a value of the <strong class="source-inline">Roles</strong> property of the <strong class="source-inline">[Authorize]</strong> attribute; users belonging to the <strong class="source-inline">User</strong> or <strong class="source-inline">Supp<a id="_idTextAnchor1564"/>ort</strong> roles ca<a id="_idTextAnchor1565"/>n access the action methods of <strong class="source-inline">OrdersController</strong>:</p>
			<pre class="source-code">[Authorize(Roles ="User,Support")]</pre>
			<pre class="source-code">public class OrdersController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>You can also specify multiple authorization attributes. If you do so, the user must be a member of all roles specified to access it.</p>
			<p>In the following code, multiple <strong class="source-inline">[Authorize]</strong> attributes are configured on <strong class="source-inline">InventoryController</strong> for the <strong class="source-inline">InventoryManager</strong> and <strong class="source-inline">Admin</strong> roles. To access the <strong class="source-inline">Inventory</strong> controller, a user<a id="_idIndexMarker1212"/> must have the <strong class="source-inline">InventoryManager</strong> and <strong class="source-inline">Admin</strong> roles:</p>
			<pre class="source-code">[Authorize(Roles ="InventoryManager")]</pre>
			<pre class="source-code">[Authorize(Roles ="Admin")]</pre>
			<pre class="source-code">public class InventoryController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">[Authorize(Roles ="Admin")]</pre>
			<pre class="source-code">public IActionResult Approve()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>You can<a id="_idTextAnchor1566"/> further restrict access to the action methods under the <strong class="source-inline">Inventory</strong> controller by specifying authorization attributes. In the preceding cod<a id="_idTextAnchor1567"/>e, users must have the <strong class="source-inline">InventoryManager</strong> and <strong class="source-inline">Admin</strong> roles to acce<a id="_idTextAnchor1568"/>ss the <strong class="source-inline">Approve</strong> action.</p>
			<p>Programmatically, if you want to check whether a user belongs to a role, you can use the <strong class="source-inline">IsInRole</strong> method of <strong class="source-inline">ClaimsPrinciple</strong>. In the following example, you'll notice that <strong class="source-inline">User.IsInRole</strong> accepts <strong class="source-inline">roleName</strong> and, based on the user's role, it returns <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>:</p>
			<pre class="source-code">public ActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">if (User.IsInRole("Admin"))</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    // Handle your logic</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">return View();</pre>
			<pre class="source-code">}</pre>
			<p>So far, we<a id="_idIndexMarker1213"/> have seen how to secure a controller or an action by specifying role names in an authorization attribute. In the next section, we will see how to centralize these configurations in one place using policy-based role autho<a id="_idTextAnchor1569"/><a id="_idTextAnchor1570"/>rization.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor1571"/>Policy-based role authorization</h2>
			<p>We can also <a id="_idIndexMarker1214"/>d<a id="_idTextAnchor1572"/>efine role requirements as policies in <strong class="source-inline">Progr<a id="_idTextAnchor1573"/>am.cs</strong>. This approach is quite useful, as you can create and manage your role-based access requirements in one place and use policy names instead of role names to control access. To define a policy-based role authorization, we need to register an authorization policy with one or more role requirements in <strong class="source-inline">Program.cs</strong> and provide a policy name to the <strong class="source-inline">Policy</strong> property of the <strong class="source-inline">Authorize</strong> attribute.</p>
			<p>In the following code, <strong class="source-inline">AdminAccessPolicy</strong> is created by adding a requirement with the <strong class="source-inline">Admin</strong> role:</p>
			<pre class="source-code">var builder = WebApplication.CreateBuilder(args);</pre>
			<pre class="source-code">builder.Services.AddAuthorization(options =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    options.AddPolicy("AdminAccessPolicy",</pre>
			<pre class="source-code">        policy =&gt; policy.RequireRole("Admin"));</pre>
			<pre class="source-code">});</pre>
			<p>In your controller, you can specify the policy to be applied as follows, and access to <strong class="source-inline">AdminController</strong> is restricted<a id="_idIndexMarker1215"/> to users with the <strong class="source-inline">Admin</strong> role:</p>
			<pre class="source-code">[Authorize(<strong class="bold">Policy</strong> ="AdminAccessPolicy")]</pre>
			<pre class="source-code">public class AdminController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>You can specify multiple roles while defining a policy. Users belonging to any one of the roles can access resources when that policy is used to authorize users. For example, the following code will allow a user with the <strong class="source-inline">User</strong> or <strong class="source-inline">Support</strong> roles to access resources:</p>
			<pre class="source-code">options.AddPolicy("OrderAccessPolicy",</pre>
			<pre class="source-code">        policy =&gt; policy.RequireRole("User","Support"));</pre>
			<p>You can use an <strong class="source-inline">OrderAccessPolicy</strong> policy with the <strong class="source-inline">Authorize</strong> attribute either on the controll<a id="_idTextAnchor1574"/>er or action methods to control access.</p>
			<p>Now that we understand how to use role-based authorization, in the next section, we will create a simple application and configure it to use role-based aut<a id="_idTextAnchor1575"/><a id="_idTextAnchor1576"/>horization.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor1577"/>Implementing role-based authorization</h2>
			<p>Let'<a id="_idTextAnchor1578"/>s cre<a id="_idTextAnchor1579"/>ate a <a id="_idIndexMarker1216"/>sample application implementi<a id="_idTextAnchor1580"/>ng role-based authorization using ASP.NET Core Identity:</p>
			<ol>
				<li>Create a new ASP.NET Core project. You can use the following <strong class="source-inline">dotnet</strong> <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) command<a id="_idIndexMarker1217"/> to create it. This will create a new ASP.NET Core <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) application <a id="_idIndexMarker1218"/>using <strong class="source-inline">Individual</strong> accounts as the <strong class="source-inline">Authentication</strong> mode and <strong class="source-inline">SQLite</strong> as the database store:<p class="source-code"><strong class="bold">dotnet new mvc --auth Individual -o AuthSample</strong></p></li>
				<li>You need to enable role services by invoking <strong class="source-inline">AddRoles&lt;IdentityRole&gt;()</strong> in <strong class="source-inline">Program.cs</strong>. You can refer to the following code to enable it. You'll also notice <strong class="source-inline">RequireConfirmedAccount</strong> is set to <strong class="source-inline">false</strong>. This is required for this sample as we create users programmatically:<p class="source-code">{</p><p class="source-code">var builder = WebApplication.CreateBuilder(args);</p><p class="source-code">var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");</p><p class="source-code">builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;</p><p class="source-code">    options.UseSqlite(connectionString));</p><p class="source-code">builder.Services.AddDatabaseDeveloperPageExceptionFilter();</p><p class="source-code">builder.Services.AddDefaultIdentity&lt;IdentityUser&gt;(options =&gt;</p><p class="source-code">    <strong class="bold">options.SignIn.RequireConfirmedAccount = false)</strong></p><p class="source-code"><strong class="bold">    .AddRoles&lt;IdentityRole&gt;()</strong></p><p class="source-code">    .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();</p><p class="source-code">builder.Services.AddControllersWithViews();   </p><p class="source-code">}</p></li>
				<li>Next, we need to create roles and users. For this, we will add two methods, <strong class="source-inline">SetupRoles</strong> and <strong class="source-inline">SetupUsers</strong>, to <strong class="source-inline">Program.cs</strong>. We can make use of the <strong class="source-inline">RoleManager</strong> and <strong class="source-inline">UserManager</strong> services to create roles and users. In the fol<a id="_idTextAnchor1581"/>lowing code, we create three roles. Using <strong class="source-inline">IServiceProvider</strong>, we get an instance of the <strong class="source-inline">roleManager</strong> serv<a id="_idTextAnchor1582"/>ice and then we make use of the <strong class="source-inline">RoleExisysAsync</strong> and <strong class="source-inline">CreateAsync</strong> methods<a id="_idIndexMarker1219"/> to create it:<p class="source-code">//Add this method to Program.cs</p><p class="source-code">async Task SetupRoles(IServiceProvider serviceProvider)</p><p class="source-code">{</p><p class="source-code">var rolemanager = serviceProvider</p><p class="source-code">    .GetRequiredService&lt;RoleManager&lt;IdentityRole&gt;&gt;();</p><p class="source-code">string[] roles = { "Admin", "Support", "User" };</p><p class="source-code">foreach (var role in roles)</p><p class="source-code">{</p><p class="source-code">    var roleExist = await rolemanager.RoleExistsAsync(role);</p><p class="source-code">    if (!roleExist)</p><p class="source-code">    {</p><p class="source-code">        await rolemanager.CreateAsync(new </p><p class="source-code">          IdentityRole(role));</p><p class="source-code">    }</p><p class="source-code">   }<a id="_idTextAnchor1583"/></p><p class="source-code">}</p></li>
				<li>Similarly, we create users and as<a id="_idTextAnchor1584"/>sign one of the roles using the <strong class="source-inline">userManager</strong> service. In the following code, we create two users – <strong class="source-inline">admin@abc.com</strong>, assigned<a id="_idIndexMarker1220"/> the <strong class="source-inline">admin</strong> role, and <strong class="source-inline">support@abc.com</strong>, assigned the <strong class="source-inline">support</strong> role:<p class="source-code">//Add this method to Program.cs</p><p class="source-code">async Task SetupUsers(IServiceProvider serviceProvider)</p><p class="source-code">{</p><p class="source-code">var userManager = serviceProvider</p><p class="source-code">    .GetRequiredService&lt;UserManager&lt;IdentityUser&gt;&gt;();</p><p class="source-code">var adminUser = await userManager.<strong class="bold">FindByEmailAsync</strong>("admin@abc.com");</p><p class="source-code">if (adminUser == null)</p><p class="source-code">{</p><p class="source-code">    var newAdminUser = new IdentityUser</p><p class="source-code">    {</p><p class="source-code">        UserName = "admin@abc.com",</p><p class="source-code">        Email = "admin@abc.com",</p><p class="source-code">    };</p><p class="source-code">var result = await userManager</p><p class="source-code">    .<strong class="bold">CreateAsync</strong>(newAdminUser, "Password@123");</p><p class="source-code">if (result.Succeeded)</p><p class="source-code">    await userManager.<strong class="bold">AddToRoleAsync</strong>(newAdminUser, </p><p class="source-code">      "Admin");</p><p class="source-code">}</p><p class="source-code">var supportUser = await userManager</p><p class="source-code">    .<strong class="bold">FindByEmailAsync</strong>("support@abc.com");</p><p class="source-code">if (supportUser == null)</p><p class="source-code">{</p><p class="source-code">    var newSupportUser = new IdentityUser</p><p class="source-code">    {</p><p class="source-code">        UserName = "support@abc.com",</p><p class="source-code">        Email = "support@abc.com",</p><p class="source-code">    };</p><p class="source-code">var result = await userManager</p><p class="source-code">    .<strong class="bold">CreateAsync</strong>(newSupportUser, "Password@123");</p><p class="source-code">if (result.Succeeded)</p><p class="source-code">    await userManager.<strong class="bold">AddToRoleAsync</strong>(newSupportUser, </p><p class="source-code">      "Support");</p><p class="source-code">}</p><p class="source-code">}</p></li>
				<li>To <a id="_idTextAnchor1585"/>invoke these <a id="_idIndexMarker1221"/>two methods, we need an instance of <strong class="source-inline">IserviceProvider</strong>. The following code gets the instance to <strong class="source-inline">IServiceProvider</strong> to set up roles and users data:<p class="source-code">//</p><p class="source-code">//</p><p class="source-code">var app = builder.Build();</p><p class="source-code">using (var scope = app.Services.CreateScope())</p><p class="source-code">{</p><p class="source-code">    var services = scope.ServiceProvider;</p><p class="source-code">    await SetupRoles(services);</p><p class="source-code">    await SetupUsers(services);</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">Home</strong> controller, add the following code. To simplify the implementation, we are using the <strong class="source-inline">Index</strong> view. In a real-life scenario, you need to return the <a id="_idIndexMarker1222"/>view that is created for the respective action methods:<p class="source-code">[Authorize(Roles = "Admin")]</p><p class="source-code">public IActionResult Admin()</p><p class="source-code">{</p><p class="source-code">return View("Index");</p><p class="source-code">}</p><p class="source-code">[Authorize(Roles = "Support")]</p><p class="source-code">public IActionResult Support()</p><p class="source-code">{</p><p class="source-code">return View("Index");</p><p class="source-code">}</p></li>
				<li>Optionally, we can add logic to <strong class="source-inline">Layout.cshtml</strong> to display links to nav<a id="_idTextAnchor1586"/>igate based on the logged-in user's <a id="_idTextAnchor1587"/>role. The following sample makes use of <strong class="source-inline">IsInRole</strong> to check the user's role and display a link:<p class="source-code">&lt;li class="nav-item"&gt;</p><p class="source-code">&lt;a class="nav-link text-dark" asp-area="" asp-controller="Home" asp-action="Index"&gt;Home&lt;/a&gt;</p><p class="source-code">&lt;/li&gt;</p><p class="source-code">@if (<strong class="bold">User.IsInRole("Admin"))</strong></p><p class="source-code">{</p><p class="source-code">&lt;li class="nav-item"&gt;</p><p class="source-code">    &lt;a class="nav-link text-dark" asp-area="" asp-controller="Home" asp-action="Admin"&gt;Admin&lt;/a&gt;</p><p class="source-code">&lt;/li&gt;</p><p class="source-code">}</p><p class="source-code">@if (<strong class="bold">User.IsInRole("Support"))</strong></p><p class="source-code">{</p><p class="source-code">&lt;li class="nav-item"&gt;</p><p class="source-code">    &lt;a class="nav-link text-dark" asp-area="" asp-controller="Home" asp-action="Support"&gt;Support&lt;/a&gt;</p><p class="source-code">&lt;/li&gt;</p><p class="source-code">}<a id="_idTextAnchor1588"/></p></li>
			</ol>
			<p>With the preceding <a id="_idIndexMarker1223"/>step, the sampl<a id="_idTextAnchor1589"/>e implementation is complete, and you can run the application to see how it works. </p>
			<p>Run the application, log in with <strong class="source-inline">admin@abc.com</strong>, and you will notice that the <strong class="bold">Admin</strong> menu item is visible and <strong class="bold">Support</strong> is hidden:</p>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="image/Figure_13.1_B18507.jpg" alt="Figure 13.1 – Admin user login view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – Admin user login view</p>
			<p>When you log in with <strong class="source-inline">support@abc.com</strong>, you will notice the <strong class="bold">Support</strong> menu item is visible and the <strong class="bold">Admin</strong> item is hidden:</p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/Figure_13.2_B18507.jpg" alt="Figure 13.2 – Support user login view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – Support user login view</p>
			<p>In the next<a id="_idIndexMarker1224"/> section, we will see how to use claims <a id="_idTextAnchor1590"/><a id="_idTextAnchor1591"/>for authorization.</p>
			<h1 id="_idParaDest-248">Claims-based au<a id="_idTextAnchor1592"/>thorization</h1>
			<p>A <strong class="bold">claim</strong> is a key-value <a id="_idIndexMarker1225"/>pair associated with identity after successful authentication. A claim can be a date of birth, gender, or zip code, for example. One or more claims can be assigned to a user. Claims-based authorization uses the value of a claim and determines whether access to a resource can be granted or not. You can use two approaches to validate a claim; one way is to just check whether the claim exists or not and the other approach is to check whether the claim exists with a parti<a id="_idTextAnchor1593"/>cular value.</p>
			<p>To use claims-based authorization, we need to register a policy in <strong class="source-inline">Program.cs</strong>. You need t<a id="_idTextAnchor1594"/>o pass a claim name and optional values to the <strong class="source-inline">RequireClaim</strong> method to register. For example, the following code registers <strong class="source-inline">PremiumContentPolicy</strong> with the requirement of the<a id="_idTextAnchor1595"/> <strong class="source-inline">PremiumUser</strong> claim:</p>
			<pre class="source-code">var builder = WebApplication.CreateBuilder(args);</pre>
			<pre class="source-code">builder.Services.AddAuthorization(options =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    options.AddPolicy("PremiumContentPolicy",</pre>
			<pre class="source-code">        policy =&gt; policy.<strong class="bold">RequireClaim</strong>("PremiumUser"));</pre>
			<pre class="source-code">});</pre>
			<p>In the following code, the <strong class="source-inline">PremiumContentPolicy</strong> authorization policy is used on <strong class="source-inline">PremiumContentController</strong>. It checks whether the <strong class="source-inline">PremiumUser</strong> claim exists in the user claims to authorize the user's request; it doesn't care what value is in the claim:</p>
			<pre class="source-code">[Authorize(Policy ="PremiumContentPolicy")]</pre>
			<pre class="source-code">public class PremiumContentController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        return View(<a id="_idTextAnchor1596"/>);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>You can also<a id="_idIndexMarker1226"/> specify a list of values while defining a claim. Th<a id="_idTextAnchor1597"/>ey will be validated to grant access to a resource. For example, as per the following code, the user request is authorized if the user has the <strong class="source-inline">Country</strong> claim with the values of <strong class="source-inline">US</strong>, <strong class="source-inline">UK</strong>, or <strong class="source-inline">IN</strong>:</p>
			<pre class="source-code">var builder = WebApplication.CreateBuilder(args);</pre>
			<pre class="source-code">builder.Services.AddAuthorization(options =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    options.AddPolicy("ExpressShippingPolicy",</pre>
			<pre class="source-code">        policy =&gt; policy.<strong class="bold">RequireClaim</strong>(ClaimTypes.Country, </pre>
			<pre class="source-code">          "US", "UK", "IN"));</pre>
			<pre class="source-code">});</pre>
			<p>Programmatically, if you want to check whether a user has a claim, you use the <strong class="source-inline">HasClaim</strong> method of <strong class="source-inline">ClaimsPrinciple</strong> by specifying a match condition. </p>
			<p>To fetch a claim value, you can use the <strong class="source-inline">FindFirst</strong> method. The following code illustrates an example:</p>
			<pre class="source-code">@if (User.<strong class="bold">HasClaim</strong>(x =&gt; x.Type == "PremiumUser"))</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    &lt;h1&gt;Yay, you are Premium User!!!, @User.<strong class="bold">FindFirst</strong>(x =&gt; </pre>
			<pre class="source-code">        x.Type == ClaimTypes.Country)?<a id="_idTextAnchor1598"/>.Value&lt;/h1&gt;</pre>
			<pre class="source-code">}</pre>
			<p>As seen in the <em class="italic">Implementing role-based authorization</em> section<a id="_idTextAnchor1599"/>, while adding a user to an application, you can also add a claim to the user using the <strong class="source-inline">UserManager</strong> service. In the following code, you'll <a id="_idIndexMarker1227"/>notice the <strong class="source-inline">AddClaimAsync</strong> method is invoked with <strong class="source-inline">IdentityUser</strong> and <strong class="source-inline">Claim</strong>:</p>
			<pre class="source-code">var user = await userManager.FindByEmailAsync("user@abc.com");</pre>
			<pre class="source-code">if (user == null)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">var newUser = new IdentityUser</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    UserName = "user@abc.com",</pre>
			<pre class="source-code">    Email = "user@abc.com",</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">var result = await userManager.CreateAsync(newUser, "Password@123");</pre>
			<pre class="source-code">if (result.Succeeded)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">await userManager</pre>
			<pre class="source-code">    .AddToRoleAsync(newUser, "User");</pre>
			<pre class="source-code">await userManager</pre>
			<pre class="source-code">    .<strong class="bold">AddClaimAsync</strong>(newUser, new Claim("PremiumUser", </pre>
			<pre class="source-code">       "true"));</pre>
			<pre class="source-code">await userManager</pre>
			<pre class="source-code">    .<strong class="bold">AddClaimAsync</strong>(newUser, new Claim(ClaimTypes.Country, </pre>
			<pre class="source-code">       "US"));</pre>
			<pre class="source-code">await userManager</pre>
			<pre class="source-code">                .AddClaimAsync(newUser, new Claim(ClaimTypes.DateOfBirth, "1-<a id="_idTextAnchor1600"/>5-2003"));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding <a id="_idIndexMarker1228"/>code, you will notice two claims created a<a id="_idTextAnchor1601"/>nd associated with the user using the <strong class="source-inline">AddClaimAsync</strong> method. In the next section, we will see how to use polic<a id="_idTextAnchor1602"/><a id="_idTextAnchor1603"/>y-based authorization.</p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor1604"/>Policy-based authorization</h1>
			<p>Policy-bas<a id="_idTextAnchor1605"/>ed <a id="_idIndexMarker1229"/>authorization a<a id="_idTextAnchor1606"/>llows you to write your own logic to handle authorization requirements that suit your needs. For example, you have a requirement to verify a user's age and authorize the placing of an order only if the user is above 14 years of age. You can use the policy-based authorization model to handle such requirements.</p>
			<p>To configure policy-based authorization, we need to define a requirement and a handler, and then register<a id="_idIndexMarker1230"/> the policy with the requirement. Let's understand these components:</p>
			<ul>
				<li>A <strong class="bold">policy</strong> is defined with one or more requirements.</li>
				<li>A <strong class="bold">requirement</strong> is a collection of data parameters used by the policy to evaluate the user's identity.</li>
				<li>A <strong class="bold">handler</strong> is responsible for evaluating data from the requirement against the context and determining whether access can be granted or not.</li>
			</ul>
			<p>In the following section, we will see how to create a requirement and a handler, and register <a id="_idTextAnchor1607"/><a id="_idTextAnchor1608"/>an authorization policy.<a id="_idTextAnchor1609"/></p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor1610"/>Requirements</h2>
			<p>To create a <a id="_idIndexMarker1231"/>requirement, you need to implement the <strong class="source-inline">IAuthorizationRequirement</strong> interface. This is a marker interface, so you don't have any members to implement. For example, the following code creates <strong class="source-inline">MinimumAgeRequirement</strong>, with <a id="_idTextAnchor1611"/><strong class="source-inline">MinimumAge</strong> as a data parameter:</p>
			<pre class="source-code">public class MinimumAgeRequirement: IAuthorizationRequirement</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public int MinimumAge { get; set; }</pre>
			<pre class="source-code">public MinimumAgeRequirement(int minimumAge)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    this.Min<a id="_idTextAnchor1612"/><a id="_idTextAnchor1613"/>imumAge = minimumAge;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<h2 id="_idParaDest-251">Require<a id="_idTextAnchor1614"/>ment handlers</h2>
			<p>Requirement <a id="_idIndexMarker1232"/>handlers encapsulate logic to allow or deny a request. They use requirement properties against <strong class="source-inline">AuthorizationHandlerContext</strong> to determine access. A handler may inherit <strong class="source-inline">Authorizationhandler&lt;TRequirement&gt;</strong>, where <strong class="source-inline">TRequirement</strong> is of the <strong class="source-inline">IauthorizationRequirement</strong> type, or implement <strong class="source-inline">IAuthorizationHandler</strong>.</p>
			<p>In the following example, <strong class="source-inline">MinimumAgeAuthorizationHandler</strong> is created by inheriting <strong class="source-inline">AuthorizationHandler</strong> with <strong class="source-inline">MinimumAgeRequirement</strong> as <strong class="source-inline">TRequirement</strong>. We need to override <strong class="source-inline">HandleRequirementAsync</strong> to write custom authorization logic where the user's age is calculated from the <strong class="source-inline">DateOfBirth</strong> claim. If the user's age is greater than or equal to <strong class="source-inline">MinimumAge</strong>, we invoke <strong class="source-inline">context.Succeed</strong> to grant access. If the claim is not present or doesn't meet the age criteria, access is forbidden:</p>
			<pre class="source-code">public class MinimumAgeAuthorizationHandler</pre>
			<pre class="source-code">: <a id="_idTextAnchor1615"/>AuthorizationHandler&lt;MinimumAgeRequirement&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">protected override Task HandleRequirementAsync(</pre>
			<pre class="source-code">AuthorizationHandlerContext context,</pre>
			<pre class="source-code">MinimumAgeRequirement requirement)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    if (context.User.HasClaim(</pre>
			<pre class="source-code">        c =&gt; c.Type == ClaimTypes.DateOfBirth))</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        var dateOfBirth = Convert.ToDateTime(</pre>
			<pre class="source-code">            context.User.FindFirst(x =&gt;</pre>
			<pre class="source-code">            x.Type == ClaimTypes.DateOfBirth).Value);</pre>
			<pre class="source-code">        </pre>
			<pre class="source-code">        var age = DateTime.Today.Year - dateOfBirth.Year;</pre>
			<pre class="source-code">        </pre>
			<pre class="source-code">        if (dateOfBirth &gt; DateTime.Today.AddYears(-age)) </pre>
			<pre class="source-code">          age--;</pre>
			<pre class="source-code">        </pre>
			<pre class="source-code">        if (age &gt;= requirement.MinimumAge)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            context.Succeed(requirement);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">       else</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            context.Fail();</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">            return Task.Co<a id="_idTextAnchor1616"/>mpletedTask;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>To mark a requirement as successful, you need to invoke <strong class="source-inline">context.Succeed</strong> by passing a requirement as a parameter. You don't have to handle failure, as another handler for the same<a id="_idIndexMarker1233"/> requirement may succeed. If you want to forbid a request, you can invoke <strong class="source-inline">context.Fail</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Handlers must be registered for servic<a id="_idTextAnchor1617"/><a id="_idTextAnchor1618"/>e collection in <strong class="source-inline">Program.cs</strong>.</p>
			<h2 id="_idParaDest-252">Regi<a id="_idTextAnchor1619"/>stering a policy</h2>
			<p>A policy is <a id="_idIndexMarker1234"/>registered with a name and a requirement in <strong class="source-inline">Program.cs</strong>. You can register one or more requirements while defining a policy.</p>
			<p>In the following example, a policy with a requirement is created by invoking <strong class="source-inline">policy.Requirements.Add()</strong> and passing a new instance of <strong class="source-inline">MinimumAgeRequirement</strong>. You'll also notice <strong class="source-inline">MinimumAgeAuthorizationHandler</strong> is added to the service collection with a singleton scope:</p>
			<pre class="source-code">var builder = WebApplication.CreateBuilder(args);</pre>
			<pre class="source-code">builder.Services.AddAuthorization(options =&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">options.AddPolicy("Over14", policy =&gt;</pre>
			<pre class="source-code">    policy.Requirements.Add(new </pre>
			<pre class="source-code">      MinimumAgeRe<a id="_idTextAnchor1620"/>quirement(14)));</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">builder.Services.AddSingleton&lt;IAuthorizationHandler,</pre>
			<pre class="source-code">    MinimumAgeAuthorizationHandler&gt;();</pre>
			<p>We can then configure an authorization policy on the controller or action to restrict access based on the user's age:</p>
			<pre class="source-code">[Authorize(Policy ="Over14")]</pre>
			<pre class="source-code">public class OrdersController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        return <a id="_idTextAnchor1621"/>View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>If we register a policy with more than one requirement, then all requirements must be satisfied for<a id="_idIndexMarker1235"/> successful authorization.</p>
			<p>In the next section, we will learn how to fur<a id="_idTextAnchor1622"/><a id="_idTextAnchor1623"/>ther customize authorization<a id="_idTextAnchor1624"/>.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor1625"/>Custom authorization</h1>
			<p>In the previous <a id="_idIndexMarker1236"/>section, we <a id="_idTextAnchor1626"/>learned how to use policy-based authorization and implement custom logic to handle authorization requirements. But, it is not always possible to register authorization policies in <strong class="source-inline">Program.cs</strong> like that. In this section, we will see how to use <strong class="source-inline">IAuthorizationPolicyProvider</strong> to dynamically build policy configurations in your application.</p>
			<p>The <strong class="source-inline">IAuthorizationPolicyProvider</strong> interface has three methods to be implemented:</p>
			<ul>
				<li><strong class="source-inline">GetDefaultPolicyAsync</strong>: This method returns the default authorization policy to be used.</li>
				<li><strong class="source-inline">GetFallbackPolicyAsync</strong>: This method returns the fallback authorization policy. It is used when no explicit authorization requirement is defined.</li>
				<li><strong class="source-inline">GetPolicyAsync</strong>: This method is used to build and return an authorization policy for the provided policy name.</li>
			</ul>
			<p>Let's look into an example where you want to authorize a request to several controllers/actions based on different age criteria, say <strong class="source-inline">Over14</strong>, <strong class="source-inline">Over18</strong>, <strong class="source-inline">Over21</strong>, <strong class="source-inline">Over60</strong>, and so on. One way to implement it is to register all these requirements as policies and use them on your controllers or actions. But, using this approach, the code is less maintainable and not sustainable in a large application with many policies. Let's see how we can make use of the authorization policy provider.</p>
			<p>We need to create a class implementing <strong class="source-inline">IAuthorizationPolicyProvider</strong> and also implement <strong class="source-inline">GetPolicy</strong> and other methods.</p>
			<p>In the following example, the <strong class="source-inline">MinimumAgePolicyProvider</strong> class implements <strong class="source-inline">GetPolicyAsync</strong>. The input for this method is the policy name. Since our policy name is something<a id="_idIndexMarker1237"/> such as <strong class="source-inline">Over14</strong> or <strong class="source-inline">Over18</strong>, we can use string functions and e<a id="_idTextAnchor1627"/>xtract the age from them, and a requirement is initi<a id="_idTextAnchor1628"/>alized with the req<a id="_idTextAnchor1629"/>uired age and registered as a new policy:</p>
			<pre class="source-code">public class MinimumAgePolicyProvider : IAuthorizationPolicyProvider</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        const string PREFIX = "Over";</pre>
			<pre class="source-code">        public Task&lt;AuthorizationPolicy?&gt; </pre>
			<pre class="source-code">          GetPolicyAsync(string policyName)</pre>
			<pre class="source-code">        {</pre>
			<pre class="source-code">            if (policyName.StartsWith(PREFIX, </pre>
			<pre class="source-code">              StringComparison.OrdinalIgnoreCase) &amp;&amp;</pre>
			<pre class="source-code">            int.TryParse(policyName.Substring(</pre>
			<pre class="source-code">              PREFIX.Length), out var age))</pre>
			<pre class="source-code">            {</pre>
			<pre class="source-code">                var policy = new </pre>
			<pre class="source-code">                  AuthorizationPolicyBuilder();</pre>
			<pre class="source-code">                policy.<strong class="bold">AddRequirements</strong>(new </pre>
			<pre class="source-code">                  <strong class="bold">MinimumAgeRequirement</strong>(<strong class="bold">age</strong>));</pre>
			<pre class="source-code">                return Task.FromResult </pre>
			<pre class="source-code">                  &lt;AuthorizationPolicy?&gt;(policy.Build());</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            return </pre>
			<pre class="source-code">              Task.FromResult&lt;AuthorizationPolicy?&gt;(null);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">For the implementation of <strong class="source-inline">MinimumAgeRequirement</strong>, please refer to the <em class="italic">Policy-based aut<a id="_idTextAnchor1630"/>horization</em> section.</p>
			<p>ASP.NET Core <a id="_idIndexMarker1238"/>uses only one instance of <strong class="source-inline">IAuthorizationPolicyProvider</strong>. So, you should either customize a <strong class="source-inline">Default</strong> a<a id="_idTextAnchor1631"/>nd <strong class="source-inline">Fallback</strong> authorization policy or, alternatively, use a backup provider.</p>
			<p>In the following code, you'll see a sample implementation of the <strong class="source-inline">GetDefaultPolicyAsync</strong> and <strong class="source-inline">GetFallbackPolicyAsync</strong> methods in the <strong class="source-inline">MinimumAgePolicyProvider</strong> class.</p>
			<p><strong class="source-inline">AuthorizationOptions</strong> is injected into the constructor, and it is used to initialize <strong class="source-inline">DefaultAuthorizationPolicyProvider</strong>. The <strong class="source-inline">BackupPolicyProvider</strong> object is used to implement the <strong class="source-inline">GetDefaultPolicyAsync</strong> and <strong class="source-inline">GetFallbackPolicyAsync</strong> methods:</p>
			<pre class="source-code">public MinimumAgePolicyProvider(IOptions&lt;AuthorizationOptions&gt; options)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">this.<strong class="bold">BackupPolicyProvider</strong> =</pre>
			<pre class="source-code">    new <strong class="bold">DefaultAuthorizationPolicyProvider</strong>(options);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">Private DefaultAuthori<a id="_idTextAnchor1632"/>zationPolicyProvider BackupPolicyProvider { get; }</pre>
			<pre class="source-code">public Task&lt;AuthorizationPolicy&gt; GetDefaultPolicyAsync()</pre>
			<pre class="source-code">=&gt; this.BackupPolicyProvider.<strong class="bold">GetDefaultPolicyAsync</strong>();</pre>
			<pre class="source-code">public Task&lt;AuthorizationPolicy?&gt; GetFallbackPolicyAsync()</pre>
			<pre class="source-code">=&gt; this.BackupPolicyProvider.<strong class="bold">GetFallbackPolicyAsync</strong>();</pre>
			<p>This concludes<a id="_idIndexMarker1239"/> the implementation of <strong class="source-inline">MinimumAgePolicyProvider</strong>. You can now use the authorization policy on your controller or action methods. In the following code, you'll notice two policies are used, one with <strong class="source-inline">Over14</strong> on top of the controller and another with <strong class="source-inline">Over18</strong>, on the <strong class="source-inline">Index</strong> action method:</p>
			<pre class="source-code">[Authorize(Policy ="<strong class="bold">Over14</strong>")]</pre>
			<pre class="source-code">public class OrdersController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    [Authorize(Policy ="<strong class="bold">Over18</strong>")]</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        ret<a id="_idTextAnchor1633"/>urn View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>Users with an age above 14 will <a id="_idTextAnchor1634"/>have access to any action methods under <strong class="source-inline">OrdersController</strong>, and <a id="_idIndexMarker1240"/>users older than 18 will only have access to the <strong class="source-inline">Index</strong> action.</p>
			<p>In the next section, we will learn how to create and use<a id="_idTextAnchor1635"/><a id="_idTextAnchor1636"/> a custom authorization attribute.</p>
			<h2 id="_idParaDest-254">Custom author<a id="_idTextAnchor1637"/>ization attributes</h2>
			<p>In the previous <a id="_idIndexMarker1241"/>example, a policy name with an age was passed as a string, but the code is not clean that way. It would be good if you could pass <strong class="source-inline">age</strong> as a parameter to the authorization attribute. For this, you need to create a custom authorization attribute inheriting the <strong class="source-inline">AuthorizeAttribute</strong> class.</p>
			<p>In the following sample code, the <strong class="source-inline">AuthorizeAgeOverAttribute</strong> class is inherited from the <strong class="source-inline">AuthorizeAttribute</strong> class. The constructor of this class accepts <strong class="source-inline">age</strong> as input. In the setter, we construct and s<a id="_idTextAnchor1638"/>et a policy name by concatenating <strong class="source-inline">PREFIX</strong> and <strong class="source-inline">Age</strong>:</p>
			<pre class="source-code">public class AuthorizeAgeOverAttribute : AuthorizeAttribute</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">const string PREFIX = "Over";</pre>
			<pre class="source-code">public AuthorizeAgeOverAttribute(int age) =&gt; Age = age;</pre>
			<pre class="source-code">public int Age</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    get</pre>
			<pre class="source-code">            {</pre>
			<pre class="source-code">                if </pre>
			<pre class="source-code">            (int.TryParse(Policy.Substring(PREFIX.Length), </pre>
			<pre class="source-code">            out var age))</pre>
			<pre class="source-code">                {</pre>
			<pre class="source-code">                    return age;</pre>
			<pre class="source-code">                }</pre>
			<pre class="source-code">                return default(int);</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            set</pre>
			<pre class="source-code">            {</pre>
			<pre class="source-code">                Policy = $"{PREFIX}{value.ToString()}";</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">}</pre>
			<p>To use the <strong class="source-inline">AuthorizeAgeOver</strong> attribute, we must register the <strong class="source-inline">AuthorizationHandler</strong> and <strong class="source-inline">AuthorizationPolicyProvider</strong> services in <strong class="source-inline">Program.cs</strong>. In the following code, the <strong class="source-inline">MinimumAgeAuthorizationHandler</strong> and <strong class="source-inline">MinimumAgePolicyProvider</strong> types <a id="_idIndexMarker1242"/>are registered as <strong class="source-inline">Singleton</strong> for <strong class="source-inline">IAuthorizationHandler</strong> and <strong class="source-inline">IauthorizationPolicyProvider</strong>, respectively:</p>
			<pre class="source-code">builder.Services.AddSingleton&lt;IAuthorizationHandler,</pre>
			<pre class="source-code">        MinimumAgeAuthorizationHandler&gt;();</pre>
			<pre class="source-code">builder.Services.AddSingleton&lt;IAuthorizationPolicyProvider,</pre>
			<pre class="source-code">        MinimumAgePolicyProvider&gt;();</pre>
			<p>Now that the custom attribute implementation is complete, we can use it on controller or action methods. In the following example, you can see a<a id="_idTextAnchor1639"/> sample implementation<a id="_idTextAnchor1640"/>, where age is passed as a parameter to our custom authorization attribute, <strong class="source-inline">AuthorizeAgeOver</strong>:</p>
			<pre class="source-code">[<strong class="bold">AuthorizeAgeOver</strong>(14)]</pre>
			<pre class="source-code">public class OrdersController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">[<strong class="bold">AuthorizeAgeOver</strong>(18)]</pre>
			<pre class="source-code">public IActionResult Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">        return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>In the next section, we will learn how to configure roles in an Azure AD applicatio<a id="_idTextAnchor1641"/><a id="_idTextAnchor1642"/>n and use role-based<a id="_idIndexMarker1243"/> authentication.</p>
			<h1 id="_idParaDest-255">Authorization<a id="_idTextAnchor1643"/> in client and server applications</h1>
			<p>In previous<a id="_idIndexMarker1244"/> chapters, we<a id="_idIndexMarker1245"/> learned how to<a id="_idIndexMarker1246"/> use <strong class="bold">Azure Active Directory</strong> (<strong class="bold">AAD</strong>) as an identity service to authenticate users, but to use role-based authorization, we need to make a few configuration changes in Azure AD. In this section, we will see how to enable and create custom roles in an Azure AD application and do so in our e-commerce application to authorize users.</p>
			<p>When a user logs in to an application, Azure AD adds assigned roles and claims to the user's identity.</p>
			<p class="callout-heading">Prerequisites</p>
			<p class="callout">You should already have Azure AD and an AD app set up. If you don't, you can refer to the <em class="italic">Introduction to Azure Active Directory</em> section of <a href="B18507_12_Epub.xhtml#_idTextAnchor1389"><em class="italic">Chapter 12</em></a>, <em class="italic">Understanding Authentic<a id="_idTextAnchor1644"/>ation</em>, to get set up.</p>
			<p>Let's look into the ste<a id="_idTextAnchor1645"/>ps that need to be performed on an Azure AD application to enable roles:</p>
			<ol>
				<li value="1">In the Azure portal, navigate to your <strong class="bold">Active Directory</strong> tenant.</li>
				<li>In the left menu, <a id="_idTextAnchor1646"/>under <strong class="bold">Manage</strong>, select <strong class="bold">App registrations</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/Figure_13.3_B18507.jpg" alt="Figure 13.3 – Azure AD application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3 – Azure AD application</p>
			<ol>
				<li value="3">Search<a id="_idIndexMarker1247"/> and <a id="_idIndexMarker1248"/>select your AD application from the <strong class="bold">App registrations</strong> <a id="_idTextAnchor1647"/>page. Refer to the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/Figure_13.4_B18507.jpg" alt="Figure 13.4 – Azure AD application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4 – Az<a id="_idTextAnchor1648"/>ure AD application</p>
			<ol>
				<li value="4">Click on <strong class="bold">Manifes<a id="_idTextAnchor1649"/>t</strong> from the <a id="_idIndexMarker1249"/>left <a id="_idIndexMarker1250"/>menu to edit<a id="_idTextAnchor1650"/> it, as shown in the previous screenshot.</li>
			</ol>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/Figure_13.5_B18507.jpg" alt="Figure 13.5 – Editing the manifest&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.5 <a id="_idTextAnchor1651"/>– Editing the manifest</p>
			<ol>
				<li value="5">Locate <strong class="source-inline">appR<a id="_idTextAnchor1652"/>oles</strong> to<a id="_idIndexMarker1251"/> configure<a id="_idIndexMarker1252"/> multiple roles. Refer to the following code to add a role:<p class="source-code">{</p><p class="source-code">"allowedMemberTypes": [</p><p class="source-code">        "User"</p><p class="source-code">    ],</p><p class="source-code">    "description": "Admin Users",</p><p class="source-code">    "displayName": "Admin",</p><p class="source-code">    "id": "6ef9b400-0219-463c-a542-5f4693c4e286",</p><p class="source-code">    "isEnabled": true,</p><p class="source-code">    "lang": null,</p><p class="source-code">    "origin": "Application",</p><p class="source-code">    "value": "Admin"</p><p class="source-code">}</p></li>
			</ol>
			<p>You need to provide values for <strong class="source-inline">displayName</strong>, <strong class="source-inline">value</strong>, <strong class="source-inline">description</strong>, and <strong class="source-inline">id</strong>. The value for <strong class="source-inline">id</strong> is <strong class="source-inline">Guid</strong>, and it must be unique for each role you add. Similarly, for <strong class="source-inline">value</strong>, you need to provide the role name that you refer to in your code, and it should be unique.</p>
			<ol>
				<li value="6">Save th<a id="_idTextAnchor1653"/>e manifest to complete it.</li>
			</ol>
			<p>Saving a manifest <a id="_idIndexMarker1253"/>with<a id="_idIndexMarker1254"/> th<a id="_idTextAnchor1654"/>e required details will enable custom roles in an Azure AD application. In the next section, we will lea<a id="_idTextAnchor1655"/><a id="_idTextAnchor1656"/>rn how to assign users to these custom roles.</p>
			<h2 id="_idParaDest-256">Assigning r<a id="_idTextAnchor1657"/>oles to users</h2>
			<p>The next <a id="_idIndexMarker1255"/>step is to assign roles to<a id="_idIndexMarker1256"/> use<a id="_idTextAnchor1658"/>rs. The assignment of roles to users can be done using the Azure portal or programmatically using the Graph API. In this section, we'll use the Azure portal to assign roles, and the same can also be achieved using theGraph API. For more information, you can refer to <a href="https://docs.microsoft.com/en-us/graph/azuread-identity-access-management-concept-overview">https://docs.microsoft.com/en-us/graph/azuread-identity-access-management-concept-overview</a>:</p>
			<ol>
				<li value="1">In the Azure portal, navigate to the <strong class="bold">Azure Active Directory</strong> tenant.</li>
				<li>Click on <strong class="bold">Enterprise applications</strong> from the left menu and search for and select your AD application.</li>
				<li>Go to <strong class="bold">Manage</strong> | <strong class="bold">Users and Groups</strong> | <strong class="bold">Add User</strong>.</li>
				<li>Search for and select the user, and click on <strong class="bold">Ok</strong>.</li>
				<li>Click on <strong class="bold">Select Role</strong> to choose the role you want to assign.</li>
				<li>Click <strong class="bold">Assign</strong> to save the selection.</li>
			</ol>
			<p>You can continue these steps to assign roles to multiple users.</p>
			<p>To secure controllers or actions, you can add an <strong class="source-inline">Authorize</strong> attribute along with the roles. In the following code, the <strong class="source-inline">Admin</strong> controller is accessible only to users with the <strong class="source-inline">Admin</strong> role:</p>
			<pre class="source-code">[Authorize(Roles ="Admin")]</pre>
			<pre class="source-code">public class AdminController : Controller</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public IActionResult <a id="_idTextAnchor1659"/>Index()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    return View();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">}</pre>
			<p>So far, we have learned how to<a id="_idTextAnchor1660"/> enable roles in Azure AD and use the role-based model for <a id="_idIndexMarker1257"/>authorization. In the next section, we<a id="_idIndexMarker1258"/> will see how to access rol<a id="_idTextAnchor1661"/><a id="_idTextAnchor1662"/>es and claims using the user's identity in vi<a id="_idTextAnchor1663"/>ews.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor1664"/>User identity in views</h2>
			<p>A user claim<a id="_idIndexMarker1259"/> principle can be used in views<a id="_idIndexMarker1260"/> to conditionally show or hide data as required. For example, the following code checks the <strong class="source-inline">IsAuthenticated</strong> property of the user identity to determine whether the user is authenticated or not. If the user is not authenticated, a link to <strong class="source-inline">Sign in</strong> is displayed; otherwise, the username with a <strong class="source-inline">Sign out</strong> link is displayed:</p>
			<pre class="source-code">&lt;ul class="navbar-nav"&gt;</pre>
			<pre class="source-code">    @if (User.Identity.<strong class="bold">IsAuthenticated</strong>)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        //// HTML code goes here</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  <a id="_idTextAnchor1665"/>  else</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        ////</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">&lt;/ul&gt;</pre>
			<p>Similarly, we can use <strong class="source-inline">IsInRole</strong> or <strong class="source-inline">HasClaim</strong> and write our logic to show content to or hide content from the user:</p>
			<pre class="source-code">@if (User.<strong class="bold">HasClaim</strong>(x =&gt; x.Type == "PremiumUser"))</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    &lt;h1&gt;Yay, you are Premium User!!!, @User.<strong class="bold">FindFirst</strong>(x =&gt; x.Type == ClaimTypes.Country)?.Value&lt;/h1&gt;</pre>
			<pre class="source-code">}</pre>
			<p>For <a id="_idIndexMarker1261"/>more<a id="_idIndexMarker1262"/> details, you can refer to <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-add-app-roles-in-azure-ad-apps">https://docs.microsoft.com/en-us/azure/active-di<span id="_idTextAnchor1666"/><span id="_idTextAnchor1667"/>rectory/develop/howto-add-app-roles-in-azure-ad-apps</a>.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor1668"/>Summary</h1>
			<p>In this chapter, we learned what authorization is and the different ways to implement it using the ASP.NET Core framework. We learned how to restrict or anonymously allow users to access resources using simple, declarative role- and claims-based models, and we learned how to implement custom logic to authorize user requests using a rich policy-based authorization model.</p>
			<p>We learned how to dynamically add authorization policies using authorization policy providers and build custom authorized attributes. We also learned how to configure custom roles in Azure AD and use them in an ASP.NET Core application. Depending on your authorization requirements, you can use one or more authorization models to secure your applications.</p>
			<p>In the next chapter, we will learn how to monitor the h<a id="_idTextAnchor1669"/><a id="_idTextAnchor1670"/>ealth and performance of an ASP.NET Core application.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor1671"/>Questions</h1>
			<p>After reading the chapter, you should be able to answer the following questions:</p>
			<ol>
				<li value="1">Which of the following is the primary service that determines whether authorization is successful or not?</li>
			</ol>
			<p>a. <strong class="source-inline">IAuthorizationHandler</strong></p>
			<p>b. <strong class="source-inline">IAuthorizationRequirement</strong></p>
			<p>c. <strong class="source-inline">IAuthorizationService</strong></p>
			<p>d.<strong class="source-inline">IAuthorizationPolicyProvider</strong></p>
			<p><strong class="bold">Answer: c</strong></p>
			<ol>
				<li value="2">In the following code, access to the <strong class="source-inline">Support</strong> action is restricted to only the <strong class="source-inline">Support</strong> role:<p class="source-code">[AllowAnonymous]</p><p class="source-code">public class HomeController : Controller</p><p class="source-code">{</p><p class="source-code">      public IactionResult Index()</p><p class="source-code">{</p><p class="source-code">    return View();</p><p class="source-code">}</p><p class="source-code">[Authorize(Roles ="Support")]</p><p class="source-code">public IactionResult Support()</p><p class="source-code">{</p><p class="source-code">        return View();</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>a. True</p>
			<p>b. False</p>
			<p><strong class="bold">Answer: b</strong></p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor1672"/>Further reading</h1>
			<p>To learn more about authorization, you can refer to <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/introduction?view=aspnetcore-6.0">https://docs.microsoft.com/en-us/aspnet/core/security/authorization/introduction?view=aspnetcore-6.0</a>.</p>
		</div>
	</body></html>