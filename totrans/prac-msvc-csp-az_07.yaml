- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flexible Configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET offers flexible configurations using a provider-based model to read configurations
    from different sources. In the last chapter, we configured environment variables
    with Azure Container Apps to override the JSON file configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to use the app configuration with .NET
    and how to add a configuration provider to use a central configuration store:
    **Azure App Configuration**. For secrets, we have another Azure service available:
    **Azure Key Vault**. In this chapter, you’ll also learn how to combine Azure Key
    Vault with Azure App Configuration and reduce the number of secrets you need to
    store by using **Azure** **managed identities**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore the functionality of .NET configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store configurations with Azure App Configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store secrets with Azure Key Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the number of secrets needed using managed identities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use environments with Azure App Configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the previous chapter, an Azure subscription, the Azure CLI, Azure
    Developer CLI, and Docker Desktop are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in the following GitHub repository:
    [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ch07` folder, you’ll see these projects with the final result of this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConfigurationPrototype` – This is a new project that shows some concepts with
    configuration before implementing this with the games API and the bot service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.InitializeAppConfig` – This is a new project to initialize values
    with Azure App Configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.AppHost` – The app model defined with this project is enhanced
    to include the `ConfigurationPrototype` and `Codebreaker.InitializeAppConfig`
    projects and add App Configuration and Azure Key Vault resources to the app model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs` – The games API project we used in the previous chapter
    is enhanced using App Configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Bot` – This is the implementation of the bot service that plays
    games. This project is enhanced with App Configuration as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can start with the results from the previous chapter to work on your own
    through this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To publish the solution to Azure (which is needed later in this chapter when
    we use managed identities), use the Azure Developer CLI with the current directory
    set to the `solution` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With `azd init`, select to analyze the code in the folder, accept to deploy
    Azure Container Apps, specify an environment such as `codebreaker-07`, and select
    the game APIs, the bot, and the configuration prototype to be accessible from
    the Ingress controller. With `azd up`, the resources are deployed to your configured
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Check the README file of the `ch07` folder of the repository for the latest
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: Experiencing .NET configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will create a new Web API project to try out .NET configuration
    features before adding configuration features to the game APIs and the bot service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: .NET is flexible in how to read configuration values. Configuration values can
    be retrieved from different sources such as JSON files, environment variables,
    and command-line arguments. Depending on the environment (for example, production
    and development), different configuration values are also retrieved. Using this
    core .NET feature, it’s easily possible to add other configuration sources and
    customize environments.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, the `ConfigurationManager` class is used to configure sources
    for the application configuration. This configuration is done at application startup
    when invoking `WebApplication.CreateBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: With .NET 8, other builder methods, such as `CreateSlimBuilder` and `CreateEmptyBuilder`,
    are available. With these builders, the number of services registered is reduced
    to increase performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the default configuration as done by `WebApplicationBulder.CreateBuilder`,
    a list of configuration providers has already been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '`webroot` key is set to the path of the web directory. Instead of using other
    APIs to get this information, you can retrieve it using configuration keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ASPNETCORE_` and `DOTNETCORE_` prefixes to have them available early in the
    process, which allows overriding the values by all providers following. Another
    environment variable configuration provider adds all other environment variables.
    The `ASPNETCORE_HTTP_PORTS` and `ASPNETCORE_HTTPS_PORTS` environment variables
    are new since .NET 8 to easily change the listening ports of the Kestrel server.
    .NET Aspire passes environment variables to the configured projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appsettings.json` and `appsettings.{environmentName}.json`. In case the environment
    name is `Development`, the values from `appsettings.Development.json` are retrieved.
    This overwrites settings from the previously loaded `appsettings.json` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In your environment, you can use multiple JSON files (for example, `connectionstrings.json`)
    in case you prefer to have all the connection strings separated:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `AddJsonFile` extension method adds the filename as another JSON configuration
    provider. If the `optional` parameter is not configured to be `true`, an exception
    is thrown in case the file cannot be found.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Command-line configuration provider**: The command-line provider allows overriding
    all the settings (because it is last in the providers’ list). Starting the application,
    you can pass configuration values to overwrite other settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Imagine a case where a hierarchical setting is specified with JSON, such as
    this connection string:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In such a case, you can pass the value using command-line arguments with a
    `:` separator:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `:` is not possible with environment variables. As you saw in the previous
    chapter, when passing environment variables for hierarchical configurations, two
    underscores (`__`) are used as separators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`UserSecretsId` is set with the project file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: dotnet user-secrets -h to see the other commands available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Running a .NET Aspire solution on the development system, the app model with
    its dependencies is used to create environment variables containing referenced
    information with the processes running the services. When deploying the solution
    to Microsoft Azure, with Azure Container Apps, environment variables and secrets
    are created. Because environment variables by default are configured as configuration
    providers, nothing special needs to be done running the services.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving configuration values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How can we access configuration values? To get custom configuration values,
    let’s enhance the `appsettings.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigurationPrototype/appsettings.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Config1` key is added to the root elements of the file. With `Service1`,
    we use a parent-child relationship and define multiple child elements, `Config1`
    and `Config2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve configuration values, we just need to inject the `IConfiguration`
    interface, as shown in the following code snippet. You need to add this code snippet
    before the `app.Run` method:'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigurationPrototype/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `IConfiguration` interface is injected in the `GET` request of the API implementation.
    Using a C# indexer, we retrieve the value for the `Config1` key. To retrieve child
    elements, we can use the `GetSection` method and use the indexer from the returned
    section. `GetSection` returns an object implementing the `IConfigurationSection`
    interface. This interface itself derives from `IConfiguration`, thus the members
    of the `IConfiguration` interface are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it out: start the `ConfigurationPrototype` app, and with the OpenAPI test
    page, test the `/``readconfig` endpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve the children, we’ll use a different approach with options next.
  prefs: []
  type: TYPE_NORMAL
- en: Using options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When configuration values are needed, many .NET services make use of the **options
    pattern**. This adds some flexibility in where to get these values – this can
    be the configuration, but these service configuration values can also be assigned
    programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strongly typed configuration values are another feature of this pattern. Add
    this class to map the configuration values:'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigurationPrototype/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The class to map the configuration values needs a parameter-less constructor
    and properties that match the configuration values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fill the values, the `Service1Options` class is configured with the `builder.Build`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigurationPrototype/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `IServiceCollection` `Configure` extension method offers two overloads.
    With one overload, a delegate can be assigned to fill the `Service1Options` instance
    programmatically. The second overload – which is used here – receives an `IConfiguration`
    parameter. Remember – in the configuration file created earlier, a `Service1`
    parent element was defined. The `GetSection` method retrieves the values within
    this section. Because the configuration keys map to the class, the values are
    filled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A new .NET 8 feature with a binding configuration is a source generator. Using
    native AOT (see [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110)), this source
    generator is enabled by default. With non-AOT projects, `EnableConfigurationBindingGenerator`
    can be added to the project file to turn off this source generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this configuration in place, let’s retrieve these configuration values.
    Add this code before `app.Run` to configure the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigurationPrototype/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `IOptions` interface with the `Service1Options` generic parameter is injected,
    and with this, the configured values can be used.
  prefs: []
  type: TYPE_NORMAL
- en: After you have made these code changes, run the `ConfigurationPrototype` project
    again. Use the `/readoptions` endpoint to retrieve the configured values.
  prefs: []
  type: TYPE_NORMAL
- en: Using environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the application runs in different environments (for example, production,
    staging, and development), there’s a need for different configuration values.
    For example, in the development environment, you don’t want to use the production
    database. The .NET configuration easily supports different environments.
  prefs: []
  type: TYPE_NORMAL
- en: With the default configuration, an `appsettings.{environment}.json` file is
    loaded to specify environment-specific configuration values – for example, `appsettings.staging.json`
    in the staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from using different filenames to load environment-specific configuration
    values, we can programmatically verify the current environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template-generated code contains this code:'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigurationPrototype/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `IsDevelopment` extension method compares the environment with the `Development`
    string. `Environment` is a property of the `WebApplication` class. Other methods
    available are `IsProduction`, `IsStaging`, and `IsEnvironment`. Invoking the `IsEnvironment`
    method, any string can be passed to check if the application is running in the
    specified environment. Instead of using the `IsEnvironment` method, you can also
    create a custom extension method extending the `IHostEnvironment` type to compare
    with the environment.
  prefs: []
  type: TYPE_NORMAL
- en: What environment the application is running in is defined by the `ASPNETCORE_ENVIRONMENT`
    environment variable, as mentioned earlier. While debugging locally, the `launchsettings.json`
    file (in the `Properties` folder) defines the environment to the `Development`
    value. If the environment variable is not set, the default environment is `Production`.
    For all other environments, you need to set this environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Using configurations with Azure Container Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Container Apps supports specifying environment variables, and secrets.
    In [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137), when we created the container
    app, we configured environment variables and secrets. Environment variables of
    a container app can be configured on creating the application or afterward when
    updating the application – for example, using `az` `containerapp update`.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables may be visible in log files. For secrets, this can be
    a security issue. Security sniffers can catch secrets that are configured in environment
    variables and alert system administrators when these are found. With container
    apps, secrets are stored within the scope of an application but independent of
    revisions of the application.
  prefs: []
  type: TYPE_NORMAL
- en: To get even better security for secrets, container app secrets can be connected
    to secrets with the Azure Key Vault service. The Key Vault service and additional
    features we get for secrets are discussed later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When you use multiple Azure services (for example, Azure App Service, Azure
    Functions, Azure Container Apps…), how configuration is managed is different from
    service to service. Also if you just run a large list of services within only
    container apps, you might prefer a central place where all the configuration is
    managed. Azure App Configuration offers this functionality without the need to
    create a custom configuration service.
  prefs: []
  type: TYPE_NORMAL
- en: Using configurations with Azure App Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we add Azure App Configuration and Azure Key Vault to the
    solution, as shown in *Figure 7**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Azure services](img/B21217_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Azure services
  prefs: []
  type: TYPE_NORMAL
- en: Both of these services can be used with any service that needs configuration
    values. The Key Vault service is used to store secrets and adds great features
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an Azure App Configuration resource.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure App Configuration service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use .NET Aspire to create an Azure App Configuration service. To use the
    .NET Aspire `AppHost` configuration from the `ConfigurationPrototype` project,
    add `AppHost` project and references the project with the app model definition):'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For using the Azure App Configuration resource with the `AppHost` project, we
    also need to add the `Aspire.Hosting.Azure.AppConfiguration` NuGet package. Calling
    the `AddAzureAppConfiguration` method adds the resource to the app model. In case
    you don’t use any App Configuration features with your Azure subscription yet,
    you can set the `sku` value to `Free` to use a free version of the App Configuration
    service. The free version does not offer any SLAs and is limited to 1,000 invocations
    per day, but for development, this limit can be fine. The App Configuration service
    is referenced from the `ConfigurationPrototype` project with the `WithReference`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting the `AppHost` project, the resources are provisioned. Remember to
    have user secrets configured with the `AppHost` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Change the subscription ID to your subscription ID and change the location to
    your chosen Azure region. It can also be helpful to specify the source of credentials
    used to create Azure resources. Setting the value to `AzureCli`, the same account
    is used that you used to log in with the Azure CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Because user secrets store the configuration inside the user profile, when using
    the same `UserSecretsId` value with multiple projects, this information might
    already show up. .NET Aspire also adds information about resources created to
    user secrets.
  prefs: []
  type: TYPE_NORMAL
- en: When you start the application, an additional Azure resource will be created.
    After this is completed successfully, as you can see with the .NET Aspire dashboard,
    let’s add some configuration values.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring values with Azure App Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the creation process of the App Configuration service is completed, we
    can define configuration values using the Configuration explorer in the Azure
    portal (see *Figure 7**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Configuration explorer](img/B21217_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Configuration explorer
  prefs: []
  type: TYPE_NORMAL
- en: With App Configuration, key-value pairs are stored. Creating a `ConfigurationPrototype:ConnectionStrings:SqlServer`
    key, we define a string value for a database connection. As the configuration
    values for all `Codebreaker` services can be configured in one place, it’s good
    practice to use the first part of the key with the name of the service – this
    way, we know which configuration values belong to which service. It’s also possible
    to use JSON content with the value, as we’ll do later with the games API. This
    reduces the number of requests for this service and can simplify the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s get the configuration from the `ConfigurationPrototype` project.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing app configuration values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also add configuration values programmatically when the application is
    deployed. To do this, let’s create a background service that runs once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new background worker service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To publish a worker project as a Docker image, you also need to enable SDK
    container support:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.InitializeAppConfig/Codebreaker.InitializeAppConfig.csproj
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When creating worker projects, without this setting, a Docker image cannot be
    created using `dotnet publish`.
  prefs: []
  type: TYPE_NORMAL
- en: Add this project to the .NET Aspire orchestration (use .NET Aspire Orchestrator
    Support, or add a reference to the `ServiceDefaults` project and add a project
    reference from the `AppHost` project to this project). Rename the `Worker` class
    that’s created from this template to `AppConfigInitializer`.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `Azure.Data.AppConfiguration` and `Microsoft.Extensions.Azure` NuGet
    packages. The `Azure.Data.AppConfiguration` package offers functionality to access
    the App Configuration API to create, read, and update settings. `Microsoft.Extensions.Azure`
    provides integration with the **dependency injection** (**DI**) system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write configuration settings, add this code to the `AppConfigInitializer`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.InitializeAppConfig/AppConfigInitializer.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With the constructor of the `AppConfigInitializer` class, the `ConfigurationClient`
    class and the `IHostApplicationLifetime` interface are injected. `ConfigurationClient`
    is the class to communicate with App Configuration. We add settings by invoking
    the `AddConfigurationSettingAsync` method. `IHostApplicationLifetime` is the interface
    for background services to be informed about start and stop events and is used
    to stop the service at the end. After the settings are written, the application
    ends, invoking the `StopApplication` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can configure the `AppConfigInitializer` class with the DIC configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.InitializeAppConfig/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `AddHostedService` method requires an object to implement the `IHostedService`
    interface. This interface is implemented with the base class of the `AppConfigInitializer`
    class, `BackgroundService`. When the service is started, the `StartAsync` method
    of `BackgroundService` is invoked, which in turn invokes the `ExecuteAsync` method
    of `AppConfigInitializer` where the configuration values are set.
  prefs: []
  type: TYPE_NORMAL
- en: '`AddAzureClients` is an extension method that allows configuring clients to
    access many of the Azure services. Here, we use the `AddConfigurationClient` extension
    method, passing the URL of the App Configuration resource.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting this initializer project now adds configuration settings to the App
    Configuration service. The game APIs service can now be changed to read colors
    for games from the configuration, which allows easy changes of colors without
    recompiling.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before .NET Aspire was available, I configured non-secret configuration values
    such as URLs to different Azure resources with Azure App Configuration. As the
    orchestration of .NET Aspire covers this aspect and makes it easy to run the solution
    with different environments and automatically configures these dependencies, App
    Configuration is now mainly used for other application-specific configuration
    values.
  prefs: []
  type: TYPE_NORMAL
- en: With this initialization in place, let’s continue to read configuration values
    from the application.
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure App Configuration from the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use the Azure App Configuration service from the .NET application, we need
    to add the `Microsoft.Azure.AppConfiguration.AspNetCore` NuGet package. This NuGet
    package offers a configuration provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'This provider is configured with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigurationPrototype/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `AddAzureAppConfiguration` extension method adds the App Configuration service
    to the configuration providers. One overload uses a string parameter to pass a
    connection string including a secret. The default orchestration configuration
    of .NET Aspire just passes the URL from the App Configuration service without
    the secret. `DefaultAzureCredential` class. This class uses a defined order to
    try different credentials, including *Visual Studio credentials*, *Azure CLI credentials*,
    and *Azure Developer CLI credentials*. The first credentials that are successfully
    retrieved are used to access the configuration service. The URL to the App Configuration
    service is forwarded from the .NET Aspire orchestrator and retrieved with the
    configuration API. After this, invoking the `Connect` method of the `AzureAppConfigurationOptions`
    class, the URL of the configuration service as well as the credentials are used
    to connect. After adding this configuration provider, App Configuration can be
    used like any other configuration provider.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When a solution is deployed to Azure, the local credentials cannot be used.
    A managed identity is used when the solution is running within Azure. This is
    covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all that needs to be done is to retrieve the configuration values. There’s
    no difference where the configuration is coming from:'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigurationPrototype/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the `IConfiguration` interface is injected. The key configured with
    App Configuration has a hierarchical name: `ConfigurationPrototype:ConnectionStrings:SqlServer`.
    The first hierarchy is accessed using the `GetSection` method. Next, the `GetConnectionString`
    method is used. This accesses the section named `ConnectionString` and then uses
    the `SqlServer` key to get its value.'
  prefs: []
  type: TYPE_NORMAL
- en: With this last change, you can run the application and retrieve the configuration
    value from the App Configuration service!
  prefs: []
  type: TYPE_NORMAL
- en: Using the environment on your local system uses **user secrets**. In the production
    environment, you already know from the previous chapter how to configure secrets
    with Azure Container Apps to add a connection string to App Configuration in a
    secure manner with secrets of container apps. The Azure Key Vault service covered
    next offers an even more secure environment.
  prefs: []
  type: TYPE_NORMAL
- en: Storing secrets with Azure Key Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get secret configuration values, the Azure Key Vault service can be used.
    The Key Vault service can be used to store secrets such as **passwords**, **certificates**,
    and **keys**. This service adds hardware-level encryption, automatic certificate
    renewals, and granular access control. With predefined roles, the service decides
    who is allowed to read secrets (*Key Vault Secrets User*, the application), who
    is allowed to create and update secrets but not read secrets (*Key Vault Contributor*),
    and who is allowed to monitor which users use secrets but not to create and read
    secrets (*Key Vault* *Secrets Officer*).
  prefs: []
  type: TYPE_NORMAL
- en: With .NET applications, the Key Vault service can be added as a configuration
    provider, as with Azure App Configuration. Another way to use this service is
    to link secrets stored with Key Vault to an Azure App Configuration instance.
    We will use the second option.
  prefs: []
  type: TYPE_NORMAL
- en: When you add a key to App Configuration, instead of just supplying a key and
    value, the key can be linked to a secret stored within the Key Vault service.
    While the same API as used with App Configuration can be used with secrets, the
    user running the service needs access to the Key Vault service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a key vault using the .NET Aspire app model:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `AddAzureKeyVault` method adds a Key Vault resource to the app model. This
    resource is referenced from the following project configuration to pass the URL.
    As with the App Configuration before, secret information is not part of this URL
    passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application to create the resource. Then, you can verify the **Access
    configuration** page (in the **Settings** section) to verify the permission model,
    as shown in *Figure 7**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Key Vault access configuration](img/B21217_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Key Vault access configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'The Azure Key Vault service supports two access permission models: **vault
    access policy** is the older (legacy) option. **Azure role-based access control**
    is the preferred configuration. User roles are defined to allow read or write
    access to different Key Vault objects such as keys, secrets, and certificates.
    Another setting in this category is for allowing **Azure Resource Manager** (**ARM**)-based
    deployment (which includes Bicep); for this specific resource, access needs to
    be granted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the key vault creation succeeds, you can create and import **secrets**,
    **keys**, and **certificates**. In this chapter, we just use the secrets from
    the Key Vault service. Create a secret, as shown in *Figure 7**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Creating a secret](img/B21217_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Creating a secret
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the name and the secret value, you can set activation and expiration
    dates.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the secret, we can switch back to the Azure App Configuration
    service. Create a Key Vault reference to map a configuration value to a value
    from the Azure Key Vault service (as shown in *Figure 7**.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Mapping Key Vault secrets with App Configuration](img/B21217_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Mapping Key Vault secrets with App Configuration
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Key Vault reference from the Configuration explorer, key values can
    be specified that correspond to the configuration keys, but for the value, a Key
    Vault resource and a secret are referenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect the App Configuration service to the Key Vault service, the App
    Configuration service needs to be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigurationPrototype/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `Connect` method of the `AzureAppConfigurationOptions` class is a fluent
    API that returns the same options type. With this, the `ConfigureKeyVault` method
    is now invoked to connect the Key Vault service to the same App Configuration
    resource. The `SetCredential` method defines the credentials that should be used
    to access the secrets. Here, we use the same credentials as used with the App
    Configuration service, but it’s also possible to use different credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this configuration in place, secrets can be accessed in the same way as
    other configuration values:'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigurationPrototype/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Having the Key Vault service connected to the App Configuration service, we
    can use the same configuration API we used previously. Behind the scenes, different
    access mechanisms are used.
  prefs: []
  type: TYPE_NORMAL
- en: Run the application and check how secrets can be retrieved successfully using
    the `DefaultAzureCredential` type.
  prefs: []
  type: TYPE_NORMAL
- en: Before we integrate the App Configuration and Key Vault services with our game
    APIs and bot services, we can get rid of some needed secrets with configuration
    values using managed identities.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the need for secrets with managed identities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managed identities (now known by the full name **Microsoft Entra managed identities
    for Azure resources**) remove the hassles we had with service principals. Managed
    identities abstract service principals, creating and deleting them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Azure service (such as Azure Container Apps), the identity of the service
    can be configured to run with a managed identity. Services that are accessed (such
    as Azure App Configuration) use role management, whereby you configure who has
    access to this resource – which includes a simple option to select a managed identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kinds of managed identities that are available are **system-assigned managed
    identities** and **user-assigned** **managed identities**:'
  prefs: []
  type: TYPE_NORMAL
- en: A system-assigned managed identity is directly associated with the Azure resource.
    If the Azure resource is deleted, the managed identity and its role-based access
    are removed as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user-assigned managed identity is created independent of an Azure service.
    As with other Azure resources, user-assigned managed identities are resources
    within a resource group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these two options has advantages but also disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties and advantages of system-assigned managed identities include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: They have the same lifetime as the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the service also deletes the managed identity and its role assignments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advantages of user-assigned managed identities include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: One user-assigned managed identity can be used by multiple services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the service does not delete the managed identity – it can be used from
    other services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple services can use the same managed identity. If multiple services need
    the same permissions, you only need to specify this once with the shared managed
    identity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One service can use multiple user-assigned managed identities. This also includes
    a disadvantage: using a user-assigned managed identity requires you to configure
    the principal ID to specify which managed identity to use.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.6* shows a user-assigned managed identity that is used with the
    bot service and the games API to access the App Configuration and Key Vault services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Assigning managed identities](img/B21217_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Assigning managed identities
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a managed identity and assign permissions to this managed identity.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a managed identity and assigning roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running the application from the local system, managed identities are not used.
    To use managed identities within Azure, let’s deploy the solution to Azure, as
    described in the *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the resources are successfully deployed, open the Azure Container App
    service for the game APIs with the Azure portal and select **Identity** in the
    **Settings** section, as shown in *Figure 7**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Managed identity](img/B21217_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Managed identity
  prefs: []
  type: TYPE_NORMAL
- en: The system-assigned identity is turned off, but a user-assigned managed identity
    is created. If you open the identity configuration with the other container apps,
    you can see that the same managed identity is assigned to all these apps, making
    it easy to define permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on this managed identity, select **Add role assignment**, as shown
    in *Figure 7**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Role-based access for the managed identity](img/B21217_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Role-based access for the managed identity
  prefs: []
  type: TYPE_NORMAL
- en: Here, you see that this managed identity already has several roles assigned
    – it can pull Docker images from the Azure Container Registry service, which is
    needed on deployment of the Azure Container App service, it can access the Azure
    Key Vault, and it has access to the Azure App Configuration service with the **App
    Configuration Data Owner** role. This allows setting configuration values that
    could be changed to read access if the configuration values are not set by an
    application running with this identity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why the managed identity has the administrator role assigned
    to the Key Vault service and the **App Configuration Data Owner** role with the
    App Configuration service. This managed identity is also used during deployment.
    When the Azure Container Apps service is deployed, a secret containing the connection
    string of the Azure Cosmos DB database is added to the Key Vault service. Specifying
    configuration values can be supplied to the App Configuration service.
  prefs: []
  type: TYPE_NORMAL
- en: To support the **principle of least privilege** (**PoLP**), only the necessary
    permissions should be applied. You can create multiple managed identities for
    different container apps or use system-assigned managed identities, whereby every
    container app has a different identity, and specify the required roles for every
    identity. A container app can have just one system-assigned managed identity but
    multiple user-assigned managed identities. Different identities can be used for
    deployment and while running the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get back to some C# code – the games API, the bot service, and the configuration
    prototype startup code to configure Azure App Configuration with a managed identity.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Azure App Configuration provider with managed identities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, with the `ConfigurationPrototype` project, we already used the `AddAzureAppConfiguration`
    method overload, which doesn’t require a connection string containing a secret.
    Invoking the `Connect` method, we supplied a `DefaultAzureCredential` instance.
    Using a user-assigned managed identity, a change is needed here. An application
    can have just one system-assigned managed identity assigned but multiple user-assigned
    managed identities. The one we use needs to be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check the configuration that has been applied to Azure Container Apps.
    Open the configuration prototype container app in the Azure portal, and within
    the **Settings** category, open **Secrets**, as shown in *Figure 7**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Secrets with Azure Container Apps](img/B21217_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Secrets with Azure Container Apps
  prefs: []
  type: TYPE_NORMAL
- en: The connection strings to the Azure App Configuration and Azure Key Vault services
    are stored with the **Secrets** configuration. This wouldn’t really be required
    as secret keys are not part of these links – but it would help if the configuration
    were changed to not only the endpoint link but also the connection string containing
    the endpoint and the secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the secret is not part of this secret configuration, check the environment
    variables configured. This setting is available in the **Application** category.
    Click on **Containers** and select **Environment variables**, as shown in *Figure
    7**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Environment variables with Azure Container Apps](img/B21217_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Environment variables with Azure Container Apps
  prefs: []
  type: TYPE_NORMAL
- en: 'The identifier of the user-assigned managed ID is passed as an environment
    variable named `AZURE_CLIENT_ID`. This environment variable can be used to select
    the managed identity. Let’s use this to configure the `DefaultAzureCredential`
    object. We used this class earlier, but now it’s time to investigate the different
    options offered. `DefaultAzureCredential` uses accounts in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EnvironmentCredential` – This authentication needs environmental variables
    containing client IDs, tenant IDs, and secrets to be set. We don’t use this here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorkloadIdentityCredential` – When running on **Azure Kubernetes Service**
    (**AKS**), Microsoft Entra workload identities can be enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ManagedIdentityCredential` – This is the authentication used when the application
    runs with managed identities configured within Microsoft Azure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SharedTokenCacheCredential` – This is a legacy mechanism that has been replaced
    by `VisualStudioCredential`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VisualStudioCredential` – Using Visual Studio, in the options dialog, you
    can configure the account to be used with Azure Service authentication. This is
    the account used with `VisualStudioCredential`. Just make sure within Visual Studio
    that you don’t need to re-authenticate – otherwise, authentication via `DefaultAzureCredential`
    might not succeed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VisualStudioCodeCredential` – This is a similar mechanism to `VisualStudioCredential`
    for Visual Studio Code but doesn’t work with the current version of the *Azure
    Account extension*. A new authentication mechanism is going to be built for Visual
    Studio Code, but this requires some time before it’s ready. Using Visual Studio
    Code, use the next option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AzureCliCredential` – This is the account used by the Azure CLI. With the
    `az account list` command, you can see the Azure accounts and subscriptions you
    are logged in to. `az account show` gives you the default account and subscription
    that will be used. If this is not the correct one, use `az account set` to set
    the current active subscription.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you have issues using the `DefaultAzureCredential` class in your development
    environment, you can enable diagnostic information and also enable or disable
    specific accounts explicitly to find the issues. Check this troubleshooting guide
    in case you have any errors: [https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/TROUBLESHOOTING.md](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/TROUBLESHOOTING.md).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the configuration to use Azure App Configuration while the application
    is running within Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigurationPrototype/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`DefaultAzureCredential` not only works in the development environment but
    also when the application runs within Azure. Using system-assigned managed identities,
    a change would not be required. With user-assigned managed identities, the `ManagedIdentityClientId`
    property needs to be set to the ID of the managed identity. We do this by reading
    the `AZURE_CLIENT_ID` environment variable and passing the value to this setting.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Select` method with the `AzureAppConfigurationOptions` class returned
    from the `Connect` method filters the configuration value. Because configuration
    values are specified for all services of the solution, we just need the ones that
    start with the `ConfigurationPrototype` key. With the bot and the game API services,
    the filtering is done with the `bot` and `gameapis` keys.
  prefs: []
  type: TYPE_NORMAL
- en: Run the configuration prototype with these changes, and then let’s continue
    using .NET environments with App Configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Using environments with Azure App Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Azure container apps are deployed and running, using all the Azure services
    we have created so far. What’s missing with App Configuration are the different
    environments that are supported with the .NET configuration. Is the application
    running in the local development environment, in the Azure test environment, or
    on the production server? Running in the test environment, the production database
    should not be used.
  prefs: []
  type: TYPE_NORMAL
- en: .NET configuration supports different environments – depending on the environment,
    either `appsettings.development.json` or `appsettings.production.json` is loaded.
    Similar functionality is possible with Azure App Configuration using **labels**.
    We can specify development, production, and testing labels to differentiate environment
    configurations. This can be mapped to .NET environments.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s a good practice to separate the production and the development environments
    across different Azure subscriptions, probably also using different Azure Active
    Directory services. Here, you also use separate Azure App Configuration services.
    Some environments can use the same subscription; for example, the production and
    the staging environments can be configured to run in the same subscription. In
    such cases, labels can be used to map different configuration values to environments.
  prefs: []
  type: TYPE_NORMAL
- en: Using App Configuration labels to map .NET environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Azure portal, open the Azure App Configuration service again. Create
    a new key-value pair and use the `BotService` key again, but this time, set the
    label to `Development`. The default setting of this key should contain the `ApiBase`
    configuration to the games API running in the container app, whereas the `Development`
    label should reference `localhost`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the startup code of the bot service, we can now change the filtering code:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Bot/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Invoking the `Select` method multiple times works the same way as you saw at
    the beginning of this chapter with multiple configuration providers. If a setting
    is configured multiple times, the last one wins. The first `Select` method loads
    all configuration values where the key starts with `BotService`, and no label
    filter is applied. Next, all configuration values where, again, the key starts
    with the name `BotService` are loaded, but this time, only values where a label
    with the same name as the current environment name are loaded. All configuration
    values that are not overwritten from the specific environment label are unchanged
    – the value is the active one. With all keys with a matching label, the new value
    is now active.
  prefs: []
  type: TYPE_NORMAL
- en: This is all that needs to be done to map different environment configuration
    values with the Azure App Configuration service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t need the Azure resources for some time, delete the resource group.
    In the next chapter, we’ll re-create the services again. `azd up` makes this easy!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was quite a journey around using Azure services for common needs such as
    Azure App Configuration and Azure Key Vault in relation to configuration with
    .NET. You learned how .NET configuration offers features to attach different providers
    and used Azure App Configuration for storing configuration values for a large
    list of services. The Azure Key Vault service was used to store secrets. In addition
    to this, you learned about using managed identities, which can help get rid of
    a lot of secrets.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we used the Azure Developer CLI to create Docker images, publish
    them to the Azure Container Registry service, and create new replicas of Azure
    container apps using the new image. While `azd up` makes this easy, this can be
    automated. This is of special interest in testing, staging, and production environments.
    In the next chapter, we will automate these activities using GitHub Actions. There’s
    also more that can be done with Azure App Configuration – using feature flags
    with modern deployment patterns. This is covered in [*Chapter 8*](B21217_08.xhtml#_idTextAnchor183)
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration providers in .NET: [https://learn.microsoft.com/en-us/dotnet/core/extensions/configuration-providers](https://learn.microsoft.com/en-us/dotnet/core/extensions/configuration-providers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Options pattern in .NET: [https://learn.microsoft.com/dotnet/core/extensions/options](https://learn.microsoft.com/dotnet/core/extensions/options)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft Entra managed identities: [https://learn.microsoft.com/azure/active-directory/managed-identities-azure-resources/](https://learn.microsoft.com/azure/active-directory/managed-identities-azure-resources/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Troubleshooting with `AzureDefaultCredential`: [https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/TROUBLESHOOTING.md](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/TROUBLESHOOTING.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Built-in roles: [https://learn.microsoft.com/azure/role-based-access-control/built-in-roles](https://learn.microsoft.com/azure/role-based-access-control/built-in-roles)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Key Vault keys, secrets, and certificates: [https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates](https://learn.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PoLP: [https://learn.microsoft.com/en-us/entra/identity-platform/secure-least-privileged-access](https://learn.microsoft.com/en-us/entra/identity-platform/secure-least-privileged-access)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft Entra Workload ID: [https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview](https://learn.microsoft.com/en-us/azure/aks/workload-identity-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
