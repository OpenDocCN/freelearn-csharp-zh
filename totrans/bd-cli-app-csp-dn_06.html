<html><head></head><body>
		<div><h1 id="_idParaDest-81" class="chapter-number"><a id="_idTextAnchor084"/>6</h1>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor085"/>Error Handling and Logging</h1>
			<p>Logging<a id="_idIndexMarker160"/> and error handling<a id="_idIndexMarker161"/> are two important concepts to consider (and implement) when building any application, and CLI applications are no exceptions.</p>
			<p>While error handling ensures graceful behavior of the application in the face of unexpected events, logging provides crucial insights into the applicationâ€™s runtime behavior and facilitates troubleshooting and debugging.</p>
			<p>Thatâ€™s why, in this chapter, we will cover these two concepts, starting with error handling.</p>
			<p>Specifically, weâ€™ll cover the following main topics in this chapter:</p>
			<ul>
				<li>Error handling in CLI applications</li>
				<li>Logging in CLI applications</li>
			</ul>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor086"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this book, <a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06</a>.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor087"/>Handling errors in CLI applications</h1>
			<p>Error <a id="_idIndexMarker162"/>handling may take<a id="_idIndexMarker163"/> two forms:</p>
			<ul>
				<li>An exception is raised, due to an <a id="_idIndexMarker164"/>unexpected event (such as an invalid input or an inaccessible dependency)</li>
				<li>The program is terminated, and we want to prevent it crashing by allowing it to gracefully shut down</li>
			</ul>
			<p>In this section, we will cover both topics. Letâ€™s start with exception handling.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor088"/>Handling exceptions</h2>
			<p>There is <a id="_idIndexMarker165"/>nothing special about handling exceptions in a CLI application compared to other kinds of applications, as it follows the same guidelines and best practices. Thatâ€™s why, in this section, you might find that you already know all the concepts that we are going to talk about, and thatâ€™s perfectly normal because youâ€™d likely have implemented them in other applications, whether web, APIs, or desktop applications.</p>
			<p>However, it is important to note that a robust error-handling strategy will have a significant impact on the quality, reliability, and resilience of your application. This is why it is worth taking the time to design a good error-handling strategy.</p>
			<p>As you certainly know, every error-handling<a id="_idIndexMarker166"/> strategy relies on a <code>try-catch-finally</code> block. But not always! Not every method needs to implement a <code>try-catch-finally</code> block. In fact, best practices of error handling state that only the <em class="italic">caller</em> method (usually the top-level method) should handle exceptions, while the <em class="italic">callee</em> method should let the exceptions bubble up to be caught, and handled, by the <em class="italic">caller</em> method. This results in leaner, cleaner, and more focused methods.</p>
			<p>Another best practice is to never swallow exceptions unless it is absolutely necessary. Why? Because swallowing exceptions hides errors, making code appear functional while it fails. This obscures valuable error information, allowing unpredictable behavior and data corruption. It complicates debugging and violates the principle of failing fast. In other words, it leads to silent failures that are hard to detect and fix, making it a poor practice.</p>
			<p>The <code>finally</code> block<a id="_idIndexMarker167"/> is important, although I see it often forgotten. It is important to remember that this block is used to ensure that resources are freed, even if an exception occurs.</p>
			<p>When catching exceptions, use<a id="_idIndexMarker168"/> multiple <code>catch</code> blocks, catching exceptions from the most specific to the most generic. This will ensure far better error handling than catching all exceptions as a generic exception and applying the same error-handling processing to all of them. An example of that is when working with files: we donâ€™t want to handle the situation where the file is not found the same way as handling the situation where the file cannot be written to, because of a lack of permissions. By distinguishing each of these situations, we can apply a specific error-handling process and, ultimately, provide the user with appropriate details of what happened rather than having generic processing and telling the user that we couldnâ€™t write to the file.</p>
			<p>We can also create our own exceptions. I do this often because it helps improve code readability. It is easy to understand what happens when the <code>CreateNewUser</code> method throws an instance of the <code>UserAlreadyExistsException</code> exception, isnâ€™t it?</p>
			<p>Hereâ€™s how this custom<a id="_idIndexMarker169"/> exception would look:</p>
			<pre class="source-code">
public class UserAlreadyExistsException : Exception
{
Â Â Â Â public string UserId { get; }
Â Â Â Â public UserAlreadyExistsException(string userId)
Â Â Â Â Â Â Â Â : base($"User with ID '{userId}' already exists.")
Â Â Â Â {
Â Â Â Â Â Â Â Â UserId = userId;
Â Â Â Â }
Â Â Â Â public UserAlreadyExistsException(string userId, Exception 
Â Â Â Â innerException)
Â Â Â Â Â Â Â Â : base($"User with ID '{userId}' already exists.", 
Â Â Â Â Â Â Â Â innerException)
Â Â Â Â {
Â Â Â Â Â Â Â Â UserId = userId;
Â Â Â Â }
}</pre>			<p class="callout-heading">To catch or not to catch exceptions?</p>
			<p class="callout">Thereâ€™s a movement nowadays that is going against throwing exceptions because of the performance cost this may have, and I totally understand this. One great video about this topic is the one by Nick Chapsas, titled <em class="italic">Donâ€™t throw exceptions in C#. Do this instead</em>, which you can find on YouTube. I encourage you to go and watch it and make up your own mind.</p>
			<p class="callout">However, whether you choose to throw the exception or handle it without throwing it, you will likely be dealing with exceptions. Also, keep in mind that both the .NET framework and some other libraries that you might be using are probably throwing exceptions, and you will need to catch these to handle them. Because of that, the principles described here are still valid and worth knowing.</p>
			<p>When catching<a id="_idIndexMarker170"/> exceptions, you can also filter them. This is because some exceptions may require a different handling mechanism depending on the reason they were thrown.</p>
			<p>A good example of this is the <code>HttpResponseException</code> exception type, as illustrated here:</p>
			<pre class="source-code">
try
{
Â Â Â Â using var client = new HttpClient();
Â Â Â Â var response = await client.GetAsync("https://api.packtpub.com/
Â Â Â Â data");
Â Â Â Â response.EnsureSuccessStatusCode();
}
catch (HttpRequestException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)
{
Â Â Â Â Console.WriteLine("Resource not found (404)");
}
catch (HttpRequestException ex) when (ex.StatusCode == System.Net.HttpStatusCode.Unauthorized)
{
Â Â Â Â Console.WriteLine("Server error (401)");
}</pre>			<p>As you can <a id="_idIndexMarker171"/>see here, we are catching the same exception (<code>HttpResponseException</code>) twice, but in each <code>catch</code> block, we focus on a very specific situation: in the first one, we are handling the situation where the resource was not found, whereas, in the second one, we are handling the situation where the user accessing the resource was not authenticated.</p>
			<p>One final best practice when handling exceptions is to avoid losing the stack trace of the exception when throwing it.</p>
			<p>To illustrate this principle, letâ€™s consider this example:</p>
			<pre class="source-code">
try
{
Â Â Â Â Â Â // Attempt to read from a file
Â Â Â Â Â Â string content = File.ReadAllText(fileName);
Â Â Â Â Â Â Console.WriteLine($Â»File content: {content}Â»);
}
catch (FileNotFoundException ex)
{
Â Â Â Â Â Â // Handle the specific exception
Â Â Â Â Â Â Console.WriteLine($"File not found: {fileName}");
Â Â Â Â Â Â Console.WriteLine($"Exception details: {ex.Message}");
Â Â Â Â Â Â // Rethrow the exception
Â Â Â Â Â Â throw ex;
}</pre>			<p>If we <a id="_idIndexMarker172"/>throw the exception using the <code>throw ex;</code> statement, we lose the stack trace containing the details of what happened up to this point. The proper way to do this is to simply use <code>throw</code> to ensure the stack trace is preserved.</p>
			<p>However, in some cases, we may need to catch the exception, handle it, and rethrow it by encapsulating it into another exception type, as shown here:</p>
			<pre class="source-code">
// Rethrow the exception by encapsulating it while preserving the 
// stack trace
throw new IOException($"File process error{fileName}", ex);</pre>			<p>In this case, the stack trace is preserved.</p>
			<p>Now, letâ€™s apply these principles to <em class="italic">Bookmarkr</em>, and more specifically, to the ability to export bookmarks out of <em class="italic">Bookmarkr</em>.</p>
			<p>If you recall from the previous chapter, the export handler method (<code>OnHandleExportCommand</code>) looked like this:</p>
			<pre class="source-code">
static void OnExportCommand(FileInfo outputfile)
{
Â Â Â Â var bookmarks = service.GetAll();
Â Â Â Â string json = JsonSerializer.Serialize(bookmarks, new 
Â Â Â Â JsonSerializerOptions { WriteIndented = true });
Â Â Â Â File.WriteAllText(outputfile.FullName, json);
}</pre>			<p>However, note that the <code>WriteAllText</code> method may throw many exceptions, such as the following:</p>
			<ul>
				<li><code>UnauthorizedAccessException</code> will be thrown in the case of insufficient permissions to access the file</li>
				<li><code>DirectoryNotFoundException</code> will be thrown if the path is invalid</li>
				<li><code>PathTooLongException</code> will be thrown if the path exceeds the system-defined maximum length</li>
			</ul>
			<p>So, letâ€™s<a id="_idIndexMarker173"/> handle these exceptions. The code would look like this:</p>
			<pre class="source-code">
static void OnExportCommand(FileInfo outputfile)
{
Â Â Â Â try
Â Â Â Â {
Â Â Â Â Â Â Â Â Â var bookmarks = service.GetAll();
Â Â Â Â Â Â Â Â Â string json = JsonSerializer.Serialize(bookmarks, new 
Â Â Â Â Â Â Â Â Â JsonSerializerOptions { WriteIndented = true });
Â Â Â Â Â Â Â Â Â File.WriteAllText(outputfile.FullName, json);
Â Â Â Â }
Â Â Â Â catch(JsonException ex)
Â Â Â Â {
Â Â Â Â Â Â Â Â Helper.ShowErrorMessage([$"Failed to serialize bookmarks to 
Â Â Â Â Â Â Â Â JSON.",
Â Â Â Â Â Â Â Â $"Error message {ex.Message}"]);
Â Â Â Â }
Â Â Â Â catch (UnauthorizedAccessException ex)
Â Â Â Â {
Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage([$"Insufficient permissions to access
Â Â Â Â Â Â Â Â Â the file {outputfile.FullName}",
Â Â Â Â Â Â Â Â Â Â $"Error message {ex.Message}"]);
Â Â Â Â }
Â Â Â Â catch (DirectoryNotFoundException ex)
Â Â Â Â {
Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage([$"The file {outputfile.FullName} 
Â Â Â Â Â Â Â Â Â cannot be found due to an invalid path",
Â Â Â Â Â Â Â Â Â $"Error message {ex.Message}"]);
Â Â Â Â }
Â Â Â Â catch (PathTooLongException ex)
Â Â Â Â {
Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage([$"The provided path is exceeding the 
Â Â Â Â Â Â Â Â Â maximum length.",
Â Â Â Â Â Â Â Â Â Â Â $"Error message {ex.Message}"]);
Â Â Â Â Â }
Â Â Â Â Â catch (Exception ex)
Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Helper.ShowErrorMessage([$"An unknown exception occurred.",
Â Â Â Â Â Â Â Â Â Â Â $"Error message {ex.Message}"]);
Â Â Â Â Â }
}</pre>			<p>In the preceding example, we are handling the most common exceptions, and we are also handling the general exception in case of an unexpected exception (yes, exceptions are exceptional situations but are nonetheless expected to happen, at least most of the time).</p>
			<p>Note that we <a id="_idIndexMarker174"/>handled exceptions for both the serialization process and the file-writing process.</p>
			<p>If you want to learn <a id="_idIndexMarker175"/>more about best practices for handling exceptions, I recommend that you visit this page: <a href="https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions">https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions</a>.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor089"/>Handling errors doesnâ€™t necessarily mean handling exceptions</h2>
			<p>As surprising as it may seem, this is true, and exceptions might be avoided (at least most of the time) by applying defensive programming techniques.</p>
			<p>By validating inputs, enforcing preconditions, and proactively identifying potential failure scenarios, we can significantly reduce error occurrences and enhance the overall resilience of our application.</p>
			<p>Letâ€™s see what we can do here in<a id="_idIndexMarker176"/> terms of defensive programming:</p>
			<ul>
				<li><strong class="bold">Validate inputs</strong>: We could ensure that the input file exists, hence avoiding an exception being raised if the file doesnâ€™t exist.</li>
				<li><code>bookmarks</code> list is not null. Otherwise, <code>JsonSerializer</code> will throw a <code>NullReferenceException</code>. We can also ensure that the list is not empty because, if it is empty, although the serialization will return an empty JSON array, we may not want to write this to a file, especially if this means overwriting the existing file.</li>
				<li><strong class="bold">Identify potential failure scenarios</strong>: We have already done this by catching the most common exceptions and handling them.</li>
			</ul>
			<p>Okay. So, at this point, we know how to handle exceptions in our CLI applications, and we implemented this in <em class="italic">Bookmarkr</em>.</p>
			<p>However, there exists one other kind of unexpected event that represents, in fact, normal behavior. Iâ€™m talking about <strong class="bold">program termination</strong>.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor090"/>Handling program termination</h2>
			<p>A program might be<a id="_idIndexMarker177"/> terminated at any moment by pressing a specific keyboard combination (usually <em class="italic">Ctrl</em> + <em class="italic">C</em> or <em class="italic">Ctrl</em> + <em class="italic">Break</em>). When this happens, the operating system sends a signal to the program, instructing it to immediately stop its execution. This signal, often referred to as an interrupt or a termination signal, allows the program to perform any necessary cleanup operations, such as closing files, releasing resources, or saving state, before it exits. If the program has a signal handler for this specific signal, it can execute custom code to handle the termination gracefully. Otherwise, the program will terminate abruptly, and any unsaved data or incomplete operations may be lost.</p>
			<p>Program termination allows one to gracefully stop a program that is taking too long to execute or that has become unresponsive.</p>
			<p><code>System.CommandLine</code> provides a mechanism to handle program termination and execute custom code, allowing our CLI application to gracefully terminate.</p>
			<p>Letâ€™s implement it to handle the situation where the user terminates the program while the export operation is ongoing.</p>
			<p>In order to handle program<a id="_idIndexMarker178"/> termination, we will need to modify the delegate of the <code>SetHandler</code> method to retrieve the cancellation token and pass it to the handler method itself:</p>
			<pre class="source-code">
exportCommand.SetHandler(async (context) =&gt;
{
Â Â Â Â FileInfo? outputfileOptionValue = context.ParseResult.
Â Â Â Â GetValueForOption(outputfileOption);
Â Â Â Â var token = context.GetCancellationToken();
Â Â Â Â await OnExportCommand(outputfileOptionValue!, token);
});</pre>			<p>Now, we can modify the handler method so it handles the program termination (i.e., catching the <code>OperationCanceledException</code> exception):</p>
			<pre class="source-code">
static async Task OnExportCommand(FileInfo outputfile, CancellationToken token)
{
Â Â Â Â Â try
Â Â Â Â Â {
Â Â Â Â Â Â Â Â var bookmarks = service.GetAll();
Â Â Â Â Â Â Â Â string json = JsonSerializer.Serialize(bookmarks, new 
Â Â Â Â Â Â Â Â JsonSerializerOptions { WriteIndented = true });
Â Â Â Â Â Â Â Â await File.WriteAllTextAsync(outputfile.FullName, json, 
Â Â Â Â Â Â Â Â token);
Â Â Â Â Â }
Â Â Â Â Â catch(OperationCanceledException ex)
Â Â Â Â Â {
Â Â Â Â Â Â Â Â var requested = ex.CancellationToken.IsCancellationRequested ? 
Â Â Â Â Â Â Â Â "Cancellation was requested by you.": "Cancellation was NOT 
Â Â Â Â Â Â Â Â requested by you.";
Â Â Â Â Â Â Â Â Helper.ShowWarningMessage(["Operation was cancelled.", 
Â Â Â Â Â Â Â Â requested, $"Cancellation reason: {ex.Message}"]);
Â Â Â Â Â }
Â Â Â Â Â catch(JsonException ex)
// The rest of the method has been removed for brevity.</pre>			<p>If we run the program now <a id="_idIndexMarker179"/>and then terminate it by pressing the  <em class="italic">Ctrl</em> + <em class="italic">C</em> keyboard combination, we get the following console output:</p>
			<div><div><img src="img/B22400_06_01.jpg" alt="Figure 6.1 â€“ Handling program termination"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 â€“ Handling program termination</p>
			<p>One thing worth mentioning<a id="_idIndexMarker180"/> here is that we need to use the asynchronous version of the <code>WriteAllText</code> method (aka <code>WriteAllTextAsync</code>) in order to be able to pass the cancellation token we received as a parameter, and for that reason, we needed to declare the <code>OnExportCommand</code> method as <code>async</code>.</p>
			<p>Note that by handling program termination, we can gracefully handle the situation where the user abruptly stops the program. This results in a graceful shutdown of the program and release of the used resources, hence avoiding a crash and an error message.</p>
			<p class="callout-heading">Why are we passing the cancellation token as a parameter to the handler method and not using it?</p>
			<p class="callout">This is an excellent question! As you have noticed, even though we receive the <code>CancellationToken</code> object as a parameter to the <code>OnExportCommand</code> method, we seem not to be using it. Then, why did we pass it in the first place?</p>
			<p class="callout">This is related to how cancellation tokens work in .NET. Let me explain!</p>
			<p class="callout">When <code>OperationCanceledException</code> is created in response to a cancellation request, it typically includes information about the <code>CancellationToken</code> object that triggered the cancellation.</p>
			<p class="callout">For that matter, the <code>OperationCanceledException</code> exception class has a constructor that takes a <code>CancellationToken</code> object as a parameter.</p>
			<p class="callout">When .NET framework asynchronous methods create this exception, they usually use this constructor and pass the cancellation token that triggered the cancellation request.</p>
			<p class="callout">The <code>OperationCanceledException</code> class has a <code>CancellationToken </code>property that can be then accessed to get the token associated with the cancellation request.</p>
			<p class="callout">In our case, we are accessing it to check whether the cancellation was requested by the user or not.</p>
			<p class="callout">Having established a robust framework for error handling, it is equally important to ensure that these errors are recorded and monitored. Thatâ€™s where logging comes into play!</p>
			<p>Effective logging not only helps in<a id="_idIndexMarker181"/> diagnosing and resolving issues but also provides valuable insights into the applicationâ€™s behavior, performance, and usage. In the upcoming section, we will dive into the best practices and strategies for implementing comprehensive logging mechanisms that complement our error-handling strategy.</p>
			<p>At this point, we have covered a lot of information on error handling. However, error handling works together with logging to improve application reliability and maintainability. So, letâ€™s shift our focus to logging, and explore how to capture and preserve valuable information not only about errors but also about other significant events that will happen during program execution.</p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor091"/>Logging in CLI applications</h1>
			<p>While error<a id="_idIndexMarker182"/> handling is more of a â€œjust-in-timeâ€ compensation <a id="_idIndexMarker183"/>mechanism when an unexpected event or error occurs, we may want to keep track of what happened so we can reproduce the issue, analyze it, understand why it happened in the first place, and fix it.</p>
			<p>By â€œkeeping track of what happened,â€ we either mean the sequence of events that led to that unexpected behavior or error and/or the call stack of the exception raised when the error occurred.</p>
			<p>Selecting a logging format is important. We want to find a balance between the amount of data we are logging (and storing) and the usage we intend to do with it. Logging unnecessary information will complexify log analysis, increase storage (and retention) costs, and may also slow down the logging process. We will also need to ensure that we are not logging sensitive information (such as credit card data), and if we do, that we are doing it in a safe manner. Some of the popular log formats include XML, JSON, CSV, and syslog.</p>
			<p>Choosing the logging destination is equally important. We need to understand that there are no good or bad options, only appropriate and inappropriate options depending on our context and needs. If our intent is to analyze the logs, we may want to store these logs in a solution that provides log analysis mechanisms out of the box, so we donâ€™t need to write code for that. Examples of such solutions are Azure Log Analytics, Splunk, Datadog, Dynatrace, Serilog, and Elasticsearch.</p>
			<p>However, note that by relying on cloud solutions (such as Azure Log Analytics), our application needs either to be running in the cloud or to have a constant connection to the internet. Sure, we can also build our application to follow the <strong class="bold">occasionally connected application</strong> (<strong class="bold">OCA</strong>) pattern<a id="_idIndexMarker184"/> so it keeps logs locally when it is running offline and sends them to Azure Log Analytics when it goes back online, but the idea here is that we should select a logging solution that is coherent with the usage pattern of our application. So, for an application that is intended to run locally, we will favor a logging mechanism that runs locally as well.</p>
			<p>Finally, it is also important to define the log retention period. This can either be enforced by the organizationâ€™s compliance rules or by the relevance of the logged data: do you still need to analyze data from a bug or customer behavior that occurred three years ago? If not, you donâ€™t need to keep this data.</p>
			<p>Either way, it is important to separate the logging format from the solution you use to store and analyze these logs.</p>
			<p>Since our application is intended to run locally, we will select JSON as a logging format and Serilog as a logging mechanism.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor092"/>Why JSON?</h2>
			<p>JSON-structured logs<a id="_idIndexMarker185"/> are easy to read and can easily be parsed by machines. Many modern log management solutions can ingest logs in JSON format, making it a good choice for structured logging.</p>
			<p>In addition, JSON<a id="_idIndexMarker186"/> is less verbose than XML, which results in files that are lightweight in size, which, in turn, reduces the amount of storage we need to store them.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor093"/>Why Serilog?</h2>
			<p>Serilog is a <a id="_idIndexMarker187"/>diagnostic logging library for .NET. It is built with powerful structured event data in mind and supports various â€œsinks,â€ which are the destinations where log events can be written to. Examples of such sinks include files, the console, databases or log management tools (such as Elasticsearch, Application Insights, Datadog, and Splunk). Itâ€™s easy to set up, has a clean API, and is portable.</p>
			<p>One of the key features of Serilog is its ability to log structured data, which allows for more meaningful and queryable logs. It uses message templates, a simple DSL extending .NET format strings, which can capture properties along with the log event.</p>
			<p>I do like the way the NuGet packages for Serilog are structured. First, there is the base package, which provides Serilogâ€™s functionalities in our code. Then, there are â€œsinkâ€ packages, one for each sink, and there are tons of them. We can even create our very own sink should we need it. I havenâ€™t found a usage for that as there are already sinks for almost everything you can think ofâ€¦</p>
			<p>Oh! And, by the way, the Serilog NuGet package has been downloaded (to this day) more than 1.24 billion times! That should mean something, right? ğŸ˜‰</p>
			<p>Before we add Serilog to our CLI application, we need to modify our code to expose the <code>IServiceCollection</code> property so we can configure our services.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor094"/>Accessing IServiceCollection</h2>
			<p>The first step we need<a id="_idIndexMarker188"/> to take is to add the <code>System.CommandLine.Hosting</code> NuGet package to our project. From the Visual Studio Code terminal, we can do so by typing this command:</p>
			<pre class="console">
dotnet add package System.CommandLine.Hosting --prerelease</pre>			<p>Then, we need to update our instantiation of the <code>CommandLineBuilder</code> class as follows:</p>
			<pre class="source-code">
using System.CommandLine.Hosting;
using Microsoft.Extensions.Hosting;
var parser = new CommandLineBuilder(rootCommand)
Â Â Â Â Â Â Â Â Â Â Â Â .UseHost(_ =&gt; Host.CreateDefaultBuilder(),
Â Â Â Â Â Â Â Â Â Â Â Â host =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â host.ConfigureServices(services =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â Â Â Â Â .UseDefaults()
Â Â Â Â Â Â Â Â Â Â Â Â .Build();
return await parser.InvokeAsync(args);</pre>			<p>We now have access to <code>IServiceCollection</code> and can thus add services to this collection and configure their behavior.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor095"/>Adding Serilog to IServiceCollection</h2>
			<p>Adding Serilog to <a id="_idIndexMarker189"/>this <a id="_idIndexMarker190"/>collection will require the <code>Serilog.Extensions.Hosting</code> NuGet package. So, letâ€™s add it!</p>
			<pre class="console">
dotnet add package Serilog.Extensions.Hosting</pre>			<p>This allows us to add Serilog to <code>IServiceCollection</code> by adding this line of code to the preceding code sample:</p>
			<pre class="source-code">
services.AddSerilog();</pre>			<h2 id="_idParaDest-93"><a id="_idTextAnchor096"/>Adding (and configuring) the required Serilog sinks</h2>
			<p>As mentioned earlier, there are tons of sinks<a id="_idIndexMarker191"/> available with Serilog. However, since we are building a CLI application, we will only use two sinks: <code>Console</code> and <code>File</code>.</p>
			<p>We also mentioned that Serilog is structured in such a way that each sink has its own NuGet package. We will then need to add the appropriate NuGet packages using these commands:</p>
			<pre class="console">
dotnet add package Serilog.Sinks.Console
dotnet add package Serilog.Sinks.File</pre>			<p>We can start using Serilog at this point by configuring the sinks in the code. The updated code for the instantiation of the <code>CommandLineBuilder</code> class would then be as follows:</p>
			<pre class="source-code">
using Serilog;
using System.CommandLine.Hosting;
using Microsoft.Extensions.Hosting;
var parser = new CommandLineBuilder(rootCommand)
Â Â Â Â Â Â Â Â Â Â Â Â .UseHost(_ =&gt; Host.CreateDefaultBuilder(),
Â Â Â Â Â Â Â Â Â Â Â Â host =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â host.ConfigureServices(services =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â services.AddSerilog((config) =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â config.MinimumLevel.Information();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â config.WriteTo.Console();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â config.WriteTo.File("logs/bookmarkr-.txt", 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â rollingInterval:RollingInterval.Day,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â restrictedToMinimumLevel:Serilog.Events.
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â LogEventLevel.Error);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â config.CreateLogger();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â Â Â Â Â })
Â Â Â Â Â Â Â Â Â Â Â Â .UseDefaults()
Â Â Â Â Â Â Â Â Â Â Â Â .Build();
return await parser.InvokeAsync(args);</pre>			<p>Letâ€™s take a closer look at the<a id="_idIndexMarker192"/> part of the code where Serilog is configured (i.e., the delegate function within the <code>AddSerilog</code> method):</p>
			<ol>
				<li>This code acts on an instance of the <code>LoggerConfiguration</code> class that is used to configure the behavior of Serilog and its sinks.</li>
				<li>We define the minimum log level as <code>Information</code>. This means that every event that is informational or above (such as warnings and errors) will be logged unless overridden by a specific sink.</li>
				<li>We notice that the <code>File</code> sink has overridden the log level in a way that only errors or higher severity events (such as <code>Fatal</code>) are logged.</li>
				<li>We can also notice that the <code>File</code> sink has defined the location of the files (the <code>logs</code> folder) and the naming convention for the log files (<code>bookmark-.txt</code>). The dash symbol in the filename is not a misspelling but rather intentional! It is there because Serilog will append a unique identifier to that filename. Since we defined our rolling interval to be on a daily basis, Serilog will create a new log file every day. Hence, our log folder will contain files that will be named <code>bookmark-20240705.txt</code>, <code>bookmark-20240706.txt</code>, and so on.</li>
				<li>We notice that we are also explicitly telling Serilog to log to the console. This is because even though we added a reference to the <code>Serilog.Sinks.Console</code> NuGet package, we still need to tell Serilog to actually use this sink.</li>
				<li>Finally, we call the <code>CreateLogger</code> method so<a id="_idIndexMarker193"/> that all this configuration is taken into account.</li>
			</ol>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor097"/>Configuring sinks in appsettings.json</h2>
			<p>Although<a id="_idIndexMarker194"/> configuring the behavior of Serilog and its sinks directly in the code works perfectly fine, it is less flexible.</p>
			<p>What if we want to add a new sink or update the configuration of an existing one? Well, you guessed it, we need to update and redeploy the code.</p>
			<p>Moving this configuration into a configuration file (such as <code>appsettings.json</code>) brings more flexibility to our application.</p>
			<p>Letâ€™s see how we can do this!</p>
			<p>We first need to add the <code>Serilog.Settings.Configuration</code> NuGet package to our application by typing this command into the Visual Studio Code terminal:</p>
			<pre class="console">
dotnet add package Serilog.Settings.Configuration</pre>			<p>We then need to add an <code>appsettings.json</code> file to our application. This can easily be done by adding a new file to the project in Visual Studio Code or in your favorite code editor.</p>
			<p>For the <code>appsettings.json</code> file to be deployed with our application, we need to ensure that its latest version is always copied to the output directory. This can be done in the <code>bookmarkr.csproj</code> file by <a id="_idIndexMarker195"/>adding this snippet just before the closing <code>&lt;/</code><code>Project&gt;</code> element:</p>
			<pre class="source-code">
&lt;ItemGroup&gt;
Â Â Â Â &lt;None Update="appsettings.json"&gt;
Â Â Â Â Â Â Â Â Â Â &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;
Â Â Â Â &lt;/None&gt;
&lt;/ItemGroup&gt;</pre>			<p>Now, letâ€™s move the configuration of Serilog and its sinks from the code to the <code>appsettings.json</code> configuration file. The content of this file will then be the following:</p>
			<pre class="source-code">
{
Â Â "Serilog": {
Â Â Â Â "Using": [ "Serilog.Sinks.Console", "Serilog.Sinks.File" ],
Â Â Â Â "MinimumLevel": {
Â Â Â Â Â Â "Default": "Information",
Â Â Â Â Â Â "Override": {
Â Â Â Â Â Â Â Â "Microsoft": "Warning",
Â Â Â Â Â Â Â Â "System": "Warning"
Â Â Â Â Â Â }
Â Â Â Â },
Â Â Â Â "WriteTo": [
Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â "Name": "Console",
Â Â Â Â Â Â Â Â "Args": {
Â Â Â Â Â Â Â Â Â Â "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] 
Â Â Â Â Â Â Â Â Â Â {Message:lj}{NewLine}{Exception}"
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â },
Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â "Name": "File",
Â Â Â Â Â Â Â Â "Args": {
Â Â Â Â Â Â Â Â Â Â "path": "logs/log-.txt",
Â Â Â Â Â Â Â Â Â Â "rollingInterval": "Day",
Â Â Â Â Â Â Â Â Â Â "outputTemplate": "[{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} 
Â Â Â Â Â Â Â Â Â Â {Level:u3}] {Message:lj}{NewLine}{Exception}"
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â }
Â Â Â Â ],
Â Â Â Â "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ]
Â Â }
}</pre>			<p>This <a id="_idIndexMarker196"/>file is easy to read and pretty self-explanatory. It describes the sinks to be used and their configuration and defines the minimum log level. There is one thing to pay attention to here, however! Notice that we have overridden the minimum log level for libraries of the <code>Microsoft</code> and <code>System</code> namespaces. This is because these libraries tend to be chatty, which may result in a large amount of log data that is not very useful. By setting their minimum log level to <code>Warning</code>, we can ensure to only capture relevant events such as warnings or errors.</p>
			<p>The <code>Enrich</code> section is a new one, however. As the name suggests, it is there to enrich the log data with extra information such as the machine name and the thread ID. If your CLI application is intended to be executed on multiple computers within your organization, knowing on which machine you got the error helps you narrow the search area. If that application is intended to run in multiple instances on the same machine, the thread ID will let you know which instance logged that information. This can be helpful in a concurrent execution scenario.</p>
			<p>Are we done?</p>
			<p>Not exactlyâ€¦ We still need to update the code inside the <code>ConfigureServices</code> method.</p>
			<p>Since all the configuration has been moved to the <code>appsettings.json</code> file, the code becomes simpler, as you can see here:</p>
			<pre class="source-code">
using Microsoft.Extensions.Configuration;
// Only the body of the ConfigureServices is shown here for clarity.
// To see the full version of the code, please refer to the GitHub 
// repo of the book.
services.AddSerilog((config) =&gt;
{
Â Â Â Â Â Â var configuration = new ConfigurationBuilder()
Â Â Â Â Â Â Â Â Â Â Â Â Â Â .SetBasePath(Directory.GetCurrentDirectory())
Â Â Â Â Â Â Â Â Â Â Â Â Â Â .AddJsonFile("appsettings.json")
Â Â Â Â Â Â Â Â Â Â Â Â Â Â .Build();
Â Â Â Â Â Â config.ReadFrom.Configuration(configuration);
});</pre>			<p class="callout-heading">Configuration in code or in a file?</p>
			<p class="callout">You may be wondering whether to configure your logger in the code or in a configuration file. That is a great question!</p>
			<p class="callout">I personally rely on both: I configure my sinks in the code and the log level in the <code>appsettings.json</code> file. This way, I can ensure that my â€œbase sinksâ€ are always in use even though more may be added later.</p>
			<p class="callout">This is a personal choice, however. You are, of course, welcome to use whatever works best for you.</p>
			<p class="callout">Keep in mind that configuration in the code takes precedence over configuration in the configuration file.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor098"/>Letâ€™s log something!</h2>
			<p>Finally! Up to this point, all we did was configure our logger and its sinks. Letâ€™s now see how this works!</p>
			<p>Once everything is in place and well<a id="_idIndexMarker197"/> configured, logging information using Serilog is quite straightforward.</p>
			<p>To illustrate this, letâ€™s take an example.</p>
			<p>When we implemented the <code>import</code> command back in <a href="B22400_05.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a>, if an existing bookmark was to be updated (because a bookmark with the same URL but a different name already existed in the list of bookmarks held by the application), we had no way to track the name of that conflicting bookmark before the update.</p>
			<p>If this was a piece of critical information (for compliance reasons, for example), logging would come in handy.</p>
			<p>We will revisit this functionality and implement logging to keep track of the name before and after the update, along with its URL and the date and time of the update.</p>
			<p>The log format would then be as follows:</p>
			<pre class="source-code">
&lt;date and time&gt; | Bookmark updated | name changed from '&lt;old name&gt;' to '&lt;new name&gt;' for URL '&lt;Url&gt;'</pre>			<p>The first thing we will do is to<a id="_idIndexMarker198"/> create a new version of the <code>import</code> method for the <code>BookmarkService</code> class. This new version will take a bookmark as a parameter and check whether a bookmark with the same URL but with a different name already exists in the list of bookmarks held by the application. If this is actually the case, it replaces the existing bookmark with the new name and then returns an instance of the <code>BookmarkConflictModel</code> type, which contains the original and updated name and the URL. If no conflict is detected, the method simply adds the bookmark and returns <code>null</code>.</p>
			<p>Here is the code for this method:</p>
			<pre class="source-code">
public BookmarkConflictModel? Import(Bookmark bookmark)
{
Â Â Â Â var conflict = _bookmarks.FirstOrDefault(b =&gt; b.Url == bookmark.
Â Â Â Â Url &amp;&amp; b.Name != bookmark.Name);
Â Â Â Â if(conflict is not null)
Â Â Â Â {
Â Â Â Â Â Â Â Â var conflictModel = new BookmarkConflictModel { OldName = 
Â Â Â Â Â Â Â Â conflict.Name, NewName = bookmark.Name, Url = bookmark.Url };
Â Â Â Â Â Â Â Â conflict.Name = bookmark.Name; // this updates the name of the 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // bookmark.
Â Â Â Â Â Â Â Â Â return conflictModel;
Â Â Â Â }
Â Â Â Â else
Â Â Â Â {
Â Â Â Â Â Â Â Â _bookmarks.Add(bookmark);
Â Â Â Â Â Â Â Â return null;
Â Â Â Â }
}</pre>			<p>The code of the <code>BookmarkConflictModel</code> class is as follows:</p>
			<pre class="source-code">
public class BookmarkConflictModel
{
Â Â Â Â public string? OldName { get; set; }
Â Â Â Â public string? NewName { get; set; }
Â Â Â Â public string? Url { get; set; }
}</pre>			<p>Finally, the code of the handler<a id="_idIndexMarker199"/> method of the <code>Import</code> command is updated to process each bookmark read from the file such that if a conflict is detected, Serilog is used to keep track of it.</p>
			<p>Here is the updated code:</p>
			<pre class="source-code">
static void OnImportCommand(FileInfo inputfile)
{
Â Â Â Â string json = File.ReadAllText(inputfile.FullName);
Â Â Â Â List&lt;Bookmark&gt; bookmarks = JsonSerializer.
Â Â Â Â Deserialize&lt;List&lt;Bookmark&gt;&gt;(json) ?? new List&lt;Bookmark&gt;();
Â Â Â Â foreach(var bookmark in bookmarks)
Â Â Â Â {
Â Â Â Â Â Â Â Â var conflict = service.Import(bookmark);
Â Â Â Â Â Â Â Â if (conflict is not null)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Log.Information($"{DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")} | Bookmark updated | name changed from '{conflict.OldName}' to '{conflict.NewName}' for URL '{conflict.Url}'");
Â Â Â Â Â Â Â Â }
Â Â Â Â }
}</pre>			<p>Now, if we run this<a id="_idIndexMarker200"/> program, we can see that was logged in case of a conflict:</p>
			<div><div><img src="img/B22400_06_02.jpg" alt="Figure 6.2 â€“ Logging in case of a conflict"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 â€“ Logging in case of a conflict</p>
			<p>As we can see, this information was both logged to the console and to the file.</p>
			<p>We are now able to use Serilog to log important information. But what happens if the application is closed or is terminated? In such a situation, we can rely on the <code>CloseAndFlush</code> method.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor099"/>Closing and gracefully disposing of Serilog</h2>
			<p>When using Serilog, the <code>Log.CloseAndFlush</code> method is called to ensure that all pending log event messages <a id="_idIndexMarker201"/>are flushed out to the sinks and that the logging system is properly shut down. This is particularly important in applications that have a definite end to their life cycle, such as console applications or batch jobs, to make sure that no log entries are missed due to the application closing before the logs are fully written out.</p>
			<p>When calling this method, two things happen:</p>
			<ul>
				<li><strong class="bold">Close</strong>: This sends a signal to the logging subsystem to stop accepting new log events. This is important to prevent any new logs from being generated after we have decided to shut down the logging system.</li>
				<li><strong class="bold">Flush</strong>: This ensures that all log events that have been captured and are currently buffered are written out to their respective sinks. Serilog may buffer events in memory for efficiency, and flushing ensures that these buffered events are not lost.</li>
			</ul>
			<p>I recommend calling <a id="_idIndexMarker202"/>this method when exiting the application, either by shutting it down or by terminating it.</p>
			<p>For that matter, I always create a method (which I call <code>FreeSerilogLoggerOnShutdown</code>) that will subscribe to two events:</p>
			<ul>
				<li><code>AppDomain.CurrentDomain.ProcessExit</code>: This event is raised when the process is about to exit, allowing us to perform cleanup tasks or save data.</li>
				<li><code>Console.CancelKeyPress</code>: This event is triggered when the user presses <em class="italic">Ctrl</em> + <em class="italic">C</em> or <em class="italic">Ctrl</em> + <em class="italic">Break</em>, terminating the currently running application.</li>
			</ul>
			<p>In both cases, these subscription calls the same delegate method (which I call <code>ExecuteShutdownTasks</code>) that will call the <code>CloseAndFlush</code> method from Serilog.</p>
			<p>Here is the code for these two methods:</p>
			<pre class="source-code">
static void FreeSerilogLoggerOnShutdown()
{
Â Â Â Â // This event is raised when the process is about to exit, 
Â Â Â Â // allowing you to perform cleanup tasks or save data.
Â Â Â Â AppDomain.CurrentDomain.ProcessExit += (s, e) =&gt; 
Â Â Â Â ExecuteShutdownTasks();
Â Â Â Â // This event is triggered when the user presses Ctrl+C or 
Â Â Â Â // Ctrl+Break. While it doesn't cover all shutdown scenarios, it's 
Â Â Â Â // useful for handling user-initiated terminations.
Â Â Â Â Console.CancelKeyPress += (s, e) =&gt; ExecuteShutdownTasks();
}
// Code to execute before shutdown
static void ExecuteShutdownTasks()
{
Â Â Â Â Console.WriteLine("Performing shutdown tasks...");
Â Â Â Â // Perform cleanup tasks, save data, etc.
Â Â Â Â Log.CloseAndFlush();
}</pre>			<p>The call to the <code>FreeSerilogLoggerOnShutDown</code> method is the first instruction of the <code>Main</code> method of the <code>Program</code> class.</p>
			<p>While this is not a book about Serilog (which, in my opinion, deserves a book on its own), in this section, we covered the basics, which is enough for the purpose of the book. If you want to find more information about Serilog, visit <a href="https://serilog.net/">https://serilog.net/</a>.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor100"/>Summary</h1>
			<p>In this chapter, we improved our CLI application, <em class="italic">Bookmarkr</em>, by adding error handling and logging into the application.</p>
			<p>With error handling, we implemented graceful degradation into our CLI application. This means that our application is now more fault-tolerant and will not crash abruptly should an unexpected event occur.</p>
			<p>With logging, we can record application activities, errors, and exceptions so that they can be analyzed at a later point in time in order to understand the sequence of events that led up to that error or unexpected behavior. But logging also enables the monitoring of application health and performance over time.</p>
			<p>In the upcoming chapter, we will see how to make our CLI application more interactive and user-friendly.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor101"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn through practice.</p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to improve the <em class="italic">Bookmarkr</em> application by adding the following features.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor102"/>Task #1 â€“ Handling errors for the Import command</h2>
			<p>If the input file cannot be accessed, or if its content cannot be deserialized, it is likely that the code will throw exceptions. Your mission is to identify what exceptions are likely to be thrown and handle them accordingly.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor103"/>Task #2 â€“ Logging errors to a file</h2>
			<p>In the previous task, the goal was to handle the exceptions. However, it might be useful to log the details of these exceptions to a file so we can review them later and use this information to improve the robustness of our application.</p>
			<p>Your mission here is to use Serilog to log exception data on a daily rolling interval and store these log files in the <code>logs/errors</code> folder.</p>
			<p>You are also asked to customize the output template so that logs contain the following information:</p>
			<ul>
				<li>Date and time of the event</li>
				<li>The name of the machine on which the event happened</li>
				<li>The type of event (warning, error, and so on)</li>
				<li>The exceptionâ€™s details, including its stack trace</li>
			</ul>
		</div>
	

		<div><h1 id="_idParaDest-101" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor104"/>Part 3: Advanced Topics in CLI Application Development</h1>
			<p>In this part, you will explore the world of interactive command-line applications, learning how to create engaging user experiences using libraries like <code>Spectre.Console</code>. You'll discover techniques for implementing rich prompts, colorful output, and interactive menus that enhance user interaction. Next, you'll delve into building modular and extensible CLI applications, focusing on architectural patterns that promote maintainability and scalability. This includes structuring your code and organizing your project into logical components. Finally, you'll learn about integrating external APIs and services into your CLI applications. By the end of this part, you'll have the skills to develop sophisticated CLI tools that can consume various external services and APIs.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B22400_07.xhtml#_idTextAnchor105"><em class="italic">Chapter 7</em></a><em class="italic">, Interactive CLI Applications</em></li>
				<li><a href="B22400_08.xhtml#_idTextAnchor120"><em class="italic">Chapter 8</em></a><em class="italic">, Building Modular and Extensible CLI Applications</em></li>
				<li><a href="B22400_09.xhtml#_idTextAnchor136"><em class="italic">Chapter 9</em></a><em class="italic">, Working with External APIs and Services</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>