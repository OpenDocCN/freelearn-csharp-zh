<html><head></head><body>
<div><h1 class="chapterNumber">5</h1>
<h1 class="chapterTitle" id="_idParaDest-106">Implementing Code Reusability in C# 12</h1>
<p class="normal"><strong class="keyWord">Code reusability</strong> is one of the most important topics in software architecture. This chapter aims to discuss ways to enable code reuse, as well as help you understand how .NET 8 solves the problem of managing and maintaining a reusable library.</p>
<p class="normal">The following topics will be covered in this chapter:</p>
<ul>
<li class="bulletList">Understanding the principles of code reuse</li>
<li class="bulletList">The advantages of working with .NET 8</li>
<li class="bulletList">Creating reusable libraries using .NET 8</li>
</ul>
<p class="normal">Although code reuse is an exceptional practice, as a software architect, you must be aware of when this is important for the scenario you are dealing with. Many good software architects agree that there is a lot of overengineering due to trying to make things reusable even though they are often single-use or not understood well enough, leading to unnecessary complexity and slowing down the development process.</p>
<h1 class="heading-1" id="_idParaDest-107">Technical requirements</h1>
<p class="normal">For this chapter, you will need the free Visual Studio 2022 Community Edition or above, with all the database tools installed.</p>
<h1 class="heading-1" id="_idParaDest-108">Understanding the principles of code reusability</h1>
<p class="normal">There is a single reason that you<a id="_idIndexMarker306"/> can always use to justify code reuse – you cannot spend your valuable time reinventing the wheel if it is already running well in other scenarios. That is why most engineering domains are based on reusability principles like modularity, standardization, abstraction, and documentation. Think about the light switches you have in your house. You can only change them without modifying other components of your house because it was built based on a standard, abstracting the idea of what a switch is according to a specification, providing modularity as a result.</p>
<p class="normal">Can you imagine the number of applications that can be made with the same interface components? The fundamentals of code reuse are the same. Again, it is a matter of planning a good solution so part of it can be reused later.</p>
<p class="normal">In software engineering, code reuse is one of the techniques that can bring a bunch of advantages to a software project, such as the following:</p>
<ul>
<li class="bulletList">There is confidence in the <a id="_idIndexMarker307"/>software, considering that the reused piece of code was already tested in another application.</li>
<li class="bulletList">There is more efficient usage of software architects and the senior team since they can be dedicated to solving this kind of problem.</li>
<li class="bulletList">There is the possibility of bringing to the project a pattern that is already accepted by the market.</li>
<li class="bulletList">Development speed goes up due to the already-implemented components.</li>
<li class="bulletList">Maintenance is easier.</li>
</ul>
<p class="normal">These aspects suggest that code reuse should be done whenever possible. However, creating reusable components does carry higher costs initially. That is why you need to focus on creating it in situations where you recognize that this piece of code will really be reused in the future or where you are trying to reuse code that has not been created as a component. It is your responsibility, as a software architect, to ensure the preceding advantages are utilized and, more than that, that you incentivize your team to enable reuse in the software they are creating.</p>
<p class="normal">In the next section, we will discuss what can be considered code reuse and what cannot. The main purpose of discussing it is to help you define a code reuse strategy that will transform the efficiency of your team.</p>
<h2 class="heading-2" id="_idParaDest-109">What code reuse is not</h2>
<p class="normal">The first thing you must <a id="_idIndexMarker308"/>understand is that code reuse does not mean copying and pasting code from one class to another. Even if this code was written by another team or project, this does not indicate that you are properly working with reusability principles. Let us imagine a <a id="_idIndexMarker309"/>scenario that we will find in this book’s use case, the <strong class="keyWord">WWTravelClub</strong> evaluation.</p>
<p class="normal">In this project scenario, you may want to evaluate different kinds of subjects, such as the <strong class="keyWord">Package</strong>, <strong class="keyWord">DestinationExpert</strong>, <strong class="keyWord">City</strong>, <strong class="keyWord">Comments</strong>, and so on. The process for getting the evaluation average is the same, no matter which subject you are referring to. Due to this, you may want to <em class="italic">enable</em> reuse by copying and pasting the code for each evaluation. The (bad) result will be something like this:</p>
<figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="img/B19820_05_01.png"/></figure>
<p class="packt_figref">Figure 5.1: Bad implementation – there is no code reuse here</p>
<p class="normal">In the preceding diagram, the process of calculating the evaluation average is decentralized, which means that the same code will be duplicated in different classes. This will cause a lot of trouble, especially if the same approach is used in other applications. For instance, if there is a new specification covering how you must calculate the average, or even if you just get a bug in the calculation formula, you will have to fix it in all instances of the code. If you do not remember to update it everywhere, you will possibly <a id="_idIndexMarker310"/>end up with an inconsistent implementation.</p>
<p class="normal">In the next section, we will reorganize this code to respect some principles that you, as a software architect, should follow to avoid the issues we have mentioned here.</p>
<h2 class="heading-2" id="_idParaDest-110">What code reuse is</h2>
<p class="normal">The solution to the problem<a id="_idIndexMarker311"/> mentioned in the previous section is quite simple: you must analyze your code and select the parts of it that would be good to decouple from your application.</p>
<p class="normal">The most compelling reason you should decouple them is related to how you are sure that this code can be reused in other parts of the application or even in another application. This is exactly what Andrew Hunt and David Thomas present as the DRY principle (don’t repeat yourself):</p>
<figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="img/B19820_05_02.png"/></figure>
<p class="packt_figref">Figure 5.2: An implementation focused on code reuse</p>
<p class="normal">The centralization of the code brings with it a different responsibility for software architects such as yourself. You must keep in mind that if there is a mistake or problem in this code, it can cause issues in many parts of the application or even other applications that use it. On the other hand, once you have this code tested and running, you will be able to reuse this code again in new projects with no worries. Besides, let’s remember the use case we are implementing here: you may want to evaluate different kinds of subjects, such as the <strong class="keyWord">Package</strong>, <strong class="keyWord">DestinationExpert</strong>, <strong class="keyWord">City</strong>, <strong class="keyWord">Comments</strong>, and so on. The process for getting the evaluation<a id="_idIndexMarker312"/> average is the same, no matter which subject you are referring to. What if you need to evolve the average calculation process? In the design now provided, you will have to change the code in a single class. Considering what we have already learned, we could also:</p>
<ul>
<li class="bulletList">Make a base class implementing the logic of the method.</li>
<li class="bulletList">Inherit all other classes from the newly created base class and eventually augment/modify the method’s behavior.</li>
<li class="bulletList">Turn the inheritance into an association (as discussed in the previous chapter).</li>
</ul>
<p class="normal">It is worth mentioning that the more you use the same code, the cheaper this development will become. Although it might seem like developing reusable code costs more initially, the more you use it, the more cost-effective and efficient the development process becomes over time. Cost needs to be mentioned because, in general, the concept of reusable software costs more in the beginning.</p>
<h2 class="heading-2" id="_idParaDest-111">Reusability in the development life cycle</h2>
<p class="normal">If you understand that code <a id="_idIndexMarker313"/>reusability will take you to another level of coding, improving the way you write and use code, then it’s time to think about how to make this technique available in your development life cycle.</p>
<p class="normal">As a matter of fact, creating and <a id="_idIndexMarker314"/>maintaining a component library is not very easy due to the responsibility you will take on and the lack of good tools to support the search for existing components.</p>
<p class="normal">On the other hand, there are some practices that you may consider implementing in your software development process every time you initiate a new development:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Use</strong> the already-implemented components from your user library, selecting features that need them in the software requirements specification.</li>
<li class="bulletList"><strong class="keyWord">Identify</strong> features in the software requirements specification that are candidates to be designed as library components.</li>
<li class="bulletList"><strong class="keyWord">Modify</strong> the specification, considering that these features will be developed using reusable components.</li>
<li class="bulletList"><strong class="keyWord">Design</strong> the reusable components and be sure that they have the appropriate interfaces to be used in many projects.</li>
<li class="bulletList"><strong class="keyWord">Build</strong> the project architecture with the new component library version.</li>
<li class="bulletList"><strong class="keyWord">Document</strong> the component library version so that every developer and team knows about it.</li>
</ul>
<p class="normal">The <em class="italic">use-identify-modify-design-build</em> process is a<a id="_idIndexMarker315"/> technique that you may <a id="_idIndexMarker316"/>consider implementing every time you need to enable software reuse. As soon as you have the components you need to write for this library, you will need to decide on the technology that will provide these components.</p>
<p class="normal">During the history of software development, there have been many approaches to enable code reuse, from <strong class="keyWord">dynamic link libraries</strong> (<strong class="keyWord">DLLs</strong>) to<a id="_idIndexMarker317"/> microservices, as we will discuss in <em class="chapterRef">Chapter 11</em>, <em class="italic">Applying a Microservice Architecture to Your Enterprise Application</em>, in the <em class="italic">Microservices and the evolution of the concept of modules</em> section. The methodology explained in the <a id="_idIndexMarker318"/>section can be used by you, as a software architect, to implement this strategy to accelerate <a id="_idIndexMarker319"/>software development. Now, let us check how .NET 8 can help us with it.</p>
<h1 class="heading-1" id="_idParaDest-112">Using .NET 8 for code reuse</h1>
<p class="normal"><strong class="keyWord">.NET</strong> has evolved a lot since its first <a id="_idIndexMarker320"/>version. This evolution is related not only to the number of commands and performance issues but also to the supported platforms. As we discussed in <em class="chapterRef">Chapter 1</em>, <em class="italic">Understanding the Importance of Software Architecture</em>, you can run C# .NET on billions of devices, even if they are running Linux, Android, macOS, or iOS. For this reason, .NET Standard was first announced together with .NET <a id="_idIndexMarker321"/>Core 1.0, but .NET Standard became particularly important with .NET Standard 2.0 when .NET Framework 4.7.2, .NET Core, and Xamarin became compatible with it.</p>
<p class="normal">The key point is that .NET Standard was not only a Visual Studio project. More than that, it was a formal specification available to all .NET implementations. As you can see in the following table, .NET Standard 2.0, which is recommended by Microsoft, covers everything in .NET. You can find a full .NET Standard overview at <a href="https://docs.microsoft.com/en-us/dotnet/standard/net-standard">https://docs.microsoft.com/en-us/dotnet/standard/net-standard</a>.</p>
<table class="table-container" id="table001">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">.NET implementation</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Version support</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">.NET and .NET Core</p>
</td>
<td class="table-cell">
<p class="normal">2.0, 2.1, 2.2, 3.0, 3.1, 5.0, 6.0, 7.0, 8.0</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">.NET Framework 1</p>
</td>
<td class="table-cell">
<p class="normal">4.6.1 2, 4.6.2, 4.7, 4.7.1, 4.7.2, 4.8, 4.8.1</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Mono</p>
</td>
<td class="table-cell">
<p class="normal">5.4, 6.4</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Xamarin.iOS</p>
</td>
<td class="table-cell">
<p class="normal">10.14, 12.16</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Xamarin.Mac</p>
</td>
<td class="table-cell">
<p class="normal">3.8, 5.16</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Xamarin.Android</p>
</td>
<td class="table-cell">
<p class="normal">8.0, 10.0</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Universal Windows Platform</p>
</td>
<td class="table-cell">
<p class="normal">10.0.16299, TBD</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Unity</p>
</td>
<td class="table-cell">
<p class="normal">2018.1</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 5.1: .NET Standard 2.0 support</p>
<p class="normal">This indicates that if you build a class library that is compatible with this standard, you will be able to reuse it on any of the platforms presented. Think about how fast your development process could become if you plan to do this in all your projects.</p>
<p class="normal">Obviously, some components are<a id="_idIndexMarker322"/> not included in .NET Standard, but its evolution is continuous. It is worth mentioning that Microsoft’s official documentation indicates that <em class="italic">the higher the version, the more APIs are available to you</em>.</p>
<p class="normal">The initiative of having a single<a id="_idIndexMarker323"/> framework for all platforms brought us to .NET 5. Microsoft indicated that from .NET 5.0, the framework would run everywhere. The next question you, as a software architect, might have is <em class="italic">what is going to happen to .NET Standard?</em></p>
<p class="normal">The answer to this question is well explained by Immo Landwerth at the dotnet blog: <a href="https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/">https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/</a>. The basic answer is that .NET 5.0 (and future versions) needs to be<a id="_idIndexMarker324"/> thought of as the foundation for sharing code moving forward. Considering .NET 8 is an <strong class="keyWord">LTS</strong> (<strong class="keyWord">Long-Term Support</strong>) version, we can now understand the framework as the best option to share code for new applications.</p>
<p class="normal">Bearing this scenario in mind, it is time to check how to create reusable class libraries. So, let us move to the next topic.</p>
<h2 class="heading-2" id="_idParaDest-113">Creating a reusable class library</h2>
<p class="normal">If you want to make useful functionalities to be<a id="_idIndexMarker325"/> used by multiple applications, you will need to<a id="_idIndexMarker326"/> create a <strong class="keyWord">class library</strong> project. So, creating class libraries is the best way to reuse code using .NET. It is quite simple to create a <strong class="keyWord">class library</strong>. Basically, you need to choose the following project when creating the library:</p>
<figure class="mediaobject"><img alt="Texto  Descrição gerada automaticamente" src="img/B19820_05_03.png"/></figure>
<p class="packt_figref">Figure 5.3: Creating a class library</p>
<p class="normal">Once you have concluded this part, you <a id="_idIndexMarker327"/>will notice that the project file keeps the information about the <strong class="keyWord">target framework moniker</strong> (<strong class="keyWord">TFM</strong>). The idea of the TFM is to define the set of APIs that will be<a id="_idIndexMarker328"/> available to the library. You can find a list of the available TFMs at <a href="https://docs.microsoft.com/en-us/dotnet/standard/frameworks">https://docs.microsoft.com/en-us/dotnet/standard/frameworks</a>:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;
</code></pre>
<p class="normal">As soon as your project is loaded, you can start coding the classes that you intend to reuse. The advantage of building reusable classes using this approach is that you will be able to reuse the written code in all the project types we checked previously. On the other hand, you will find out that some APIs that are available in .NET Framework do not exist in this type of project.</p>
<p class="normal">Considering that you already have the correct project type selected for creating reusable code, let us check how C# deals with code reuse in the next section.</p>
<h2 class="heading-2" id="_idParaDest-114">How does C# deal with code reuse?</h2>
<p class="normal">Considering you are writing class<a id="_idIndexMarker329"/> libraries using C#.NET, there are many approaches where <strong class="keyWord">C#</strong> helps us deal with code reuse. The ability to build libraries, as we did in the previous section, is one of them. One of the most important ones is the fact that the language is <strong class="keyWord">object-oriented</strong>. Besides this, it is also worth mentioning the facilities that generics brought to the C# language. This section will discuss object-oriented analysis<a id="_idIndexMarker330"/> and generics principles.</p>
<h3 class="heading-3" id="_idParaDest-115">Object-oriented analysis</h3>
<p class="normal">The object-oriented analysis approach gives us the ability to reuse code in different ways, from the facility of inheritance to the <a id="_idIndexMarker331"/>changeability of polymorphism. Complete adoption of object-oriented programming will let you implement abstraction and encapsulation, too.</p>
<p class="normal">It is important to mention that in <em class="chapterRef">Chapter 4</em>, <em class="italic">Best Practices in Coding C# 12</em>, we discuss how inheritance can cause complexity in your code. Although the following example presents a valid way to reuse code, consider using composition over inheritance in real-life applications.</p>
<p class="normal">The following diagram shows how using the object-oriented approach makes reuse easier. As you can see, there are different ways to calculate the grades of an evaluation, considering that you can be a basic or a prime user of this example system:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_05_04.png"/></figure>
<p class="packt_figref">Figure 5.4: Object-oriented case analysis</p>
<p class="normal">There are two aspects to be analyzed as code reuse in this design. The first is that there is no need to declare the <a id="_idIndexMarker332"/>properties in each child class since inheritance does it for you.</p>
<p class="normal">The second is the opportunity to use polymorphism, enabling different behaviors for the same method:</p>
<pre class="programlisting code"><code class="hljs-code">public class PrimeUsersEvaluation : Evaluation
{
    /// &lt;summary&gt;
/// The business rule implemented here indicates that grades
/// that came from prime users have 20% of increase
/// &lt;/summary&gt;
/// &lt;returns&gt;the final grade from a prime user&lt;/returns&gt;
public override double CalculateGrade()
    {
         return Grade * 1.2;
    }
}
</code></pre>
<p class="normal">In the preceding code, you can see the usage of the polymorphism principle, where the calculation of evaluation for prime users will increase by 20%. Now, look at how easy it is to call different objects inherited by the same class. Since the collection content implements the same interface, <code class="inlineCode">IContentEvaluated</code>, it can have basic and prime users, too:</p>
<pre class="programlisting code"><code class="hljs-code">public class EvaluationService
{
    public IContentEvaluated Content { get; set; }
    /// &lt;summary&gt;
/// No matter the Evaluation, the calculation will always get
/// values from the method CalculateGrade
/// &lt;/summary&gt;
/// &lt;returns&gt;The average of the grade from
/// Evaluations
/// &lt;/returns&gt;
public double CalculateEvaluationAverage()
    {
            return Content.Evaluations
                .Select(x =&gt; x.CalculateGrade())
                .Average();
    }
}
</code></pre>
<p class="normal">Object-oriented adoption can be considered mandatory when using C#. However, more specific usage requires study and practice. You, as a software architect, should always incentivize your team to<a id="_idIndexMarker333"/> study object-oriented analysis. The more abstract abilities they have, the easier code reuse will become.</p>
<h3 class="heading-3" id="_idParaDest-116">Generics</h3>
<p class="normal"><strong class="keyWord">Generics</strong> were introduced in <a id="_idIndexMarker334"/>C# in version 2.0 and are considered an approach that increases code reuse. It also maximizes type safety and performance.</p>
<p class="normal">The basic principle of generics is that<a id="_idIndexMarker335"/> you can define in an interface, class, method, property, event, or even delegate a placeholder that will be replaced with a specific type later when one of the preceding entities is used. The opportunity you have with this feature is incredible since you can use the same code to run different generic versions of the type.</p>
<p class="normal">The following code is a modification of <code class="inlineCode">EvaluationService</code>, which was presented in the previous section. The idea here is to enable the generalization of the service, giving us the opportunity to define the goal of evaluation since its creation:</p>
<pre class="programlisting code"><code class="hljs-code">public class EvaluationService&lt;T&gt; where T: IContentEvaluated, new()
</code></pre>
<p class="normal">This declaration indicates that any class that implements the <code class="inlineCode">IContentEvaluated</code> interface can be used for this service. The new constraint indicates this class must have a public parameter-less default constructor.</p>
<p class="normal">The service will be responsible for creating the evaluated content:</p>
<pre class="programlisting code"><code class="hljs-code">public EvaluationService()
{
    var name = GetTypeOfEvaluation();
    content = new T();
}
</code></pre>
<p class="normal">It is worth mentioning that this code works because all the classes are in the same assembly. The result of this modification can be checked in the instance creation of the service:</p>
<pre class="programlisting code"><code class="hljs-code">var service = new EvaluationService&lt;CityEvaluation&gt;();
</code></pre>
<p class="normal">The good news is that now, you have a generic service that will automatically instantiate the <code class="inlineCode">list</code> object with the evaluations of the content you need. It’s worth mentioning that generics will obviously need more time dedicated to the first project’s construction. However, once the design is <a id="_idIndexMarker336"/>done, you will have good, fast, and easy-to-maintain<a id="_idIndexMarker337"/> code. This is what we call reuse!</p>
<h2 class="heading-2" id="_idParaDest-117">What if the code is not reusable?</h2>
<p class="normal">In fact, any code can be reusable. The key point here is that the code you intend to reuse must be well-written and follow<a id="_idIndexMarker338"/> good patterns for reuse. There are several reasons why code should be considered not ready for reuse:</p>
<ul>
<li class="bulletList"><strong class="keyWord">The code has not been tested before</strong>: Before reusing code, it is a good approach to guarantee that it works.</li>
<li class="bulletList"><strong class="keyWord">The code is duplicated</strong>: If you have duplicate code, you will need to find each place where it is used so you only have a single version of the code being reused. If you find different versions of the code duplicated, you will need to define the best version of it to be considered the reusable one, and, at the same time, you will need to retest every replacement of the duplicated code to guarantee that the functionality of the software remains the same.</li>
<li class="bulletList"><strong class="keyWord">The code is too complex to understand:</strong> Code that is reused in many places needs to be written with simplicity to enable easy understanding.</li>
<li class="bulletList"><strong class="keyWord">The code has tight coupling</strong>: This is a discussion related to composition versus inheritance when building separate class libraries. Classes (with interfaces) are usually much easier to reuse than base classes that can be inherited.</li>
</ul>
<p class="normal">In any of these cases, considering a refactoring strategy can be a great approach. When you refactor code, you write it in a better way, guaranteeing the code standards, reducing complexity, and respecting the input and output data that this code will process. This enables more comprehensive and lower-cost changes to be made to the code when the time comes. Martin Fowler, in his book <em class="italic">Refactoring</em> of 2018, indicates some reasons why you should consider refactoring:</p>
<ul>
<li class="bulletList"><strong class="keyWord">It improves software design</strong>: The more <a id="_idIndexMarker339"/>expert your team becomes, the better the design will be. A better software design will not only deliver faster coding but also bring us the opportunity to process more tasks in less time.</li>
<li class="bulletList"><strong class="keyWord">It makes the software easier to understand</strong>: Regardless of whether we are talking about juniors or seniors, good software needs to be understood by every developer in your team.</li>
<li class="bulletList"><strong class="keyWord">It helps us find bugs</strong>: While you are refactoring, you are reviewing code. During this process, you will find <a id="_idIndexMarker340"/>business rules that may not have been well programmed, so you will probably find bugs. However, do not forget that the basis of <a id="_idIndexMarker341"/>refactoring is keeping the behavior, so be sure that it is the correct moment for fixing issues.</li>
<li class="bulletList"><strong class="keyWord">It makes our program quicker</strong>: The result of refactoring will be code that will enable faster development in the future.</li>
</ul>
<p class="normal">When refactoring, we can guarantee good results and minimize the errors that occur during the journey by following these steps:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Be sure you have a set of tests to guarantee the correct processing</strong>: This set of tests will eliminate the fear of breaking the code.</li>
<li class="bulletList"><strong class="keyWord">Eliminate duplication</strong>: Refactoring is a good opportunity to eliminate code duplication.</li>
<li class="bulletList"><strong class="keyWord">Minimize complexity</strong>: Given that one goal is to make the code more understandable, following the best practices of programming, as mentioned in <em class="chapterRef">Chapter 4</em>, <em class="italic">Best Practices in Coding C# 12</em>, will help you reduce the complexity of the code.</li>
<li class="bulletList"><strong class="keyWord">Clean up the design</strong>: Refactoring is a good time to reorganize the design of your libraries, too. Do not forget to update them as well. This can be a great way to eliminate bugs and security issues.</li>
</ul>
<p class="normal">As a software architect, you will receive many refactoring demands from your team. The incentive for refactoring must be continuous, but you must remind your team that refactoring without following the preceding steps might be risky once it may cause bugs during the process. So, it is your responsibility to ensure that refactoring happens in a way that both enables fast programming and reduces the impact of unnecessary bugs caused by the refactoring process, thus delivering real business value.</p>
<h2 class="heading-2" id="_idParaDest-118">I have my libraries. How do I promote them?</h2>
<p class="normal">Once you have made all the necessary effort to guarantee you have good libraries that can be reused in many of your <a id="_idIndexMarker342"/>projects, you will find another difficult situation arises when enabling reusability: it is not so easy to let programmers know you have libraries ready to reuse.</p>
<p class="normal">There are some simple approaches to documenting a library. As we mentioned when we talked about the development life cycle, documenting is a good way to help developers take notice of the libraries they have. There are two examples of documenting reusable code that we would like to mention in the following subsections.</p>
<h3 class="heading-3" id="_idParaDest-119">Documenting .NET libraries using DocFX</h3>
<p class="normal">DocFX is a good option for <a id="_idIndexMarker343"/>documenting a library using comments made in its code. By <a id="_idIndexMarker344"/>simply adding the <code class="inlineCode">docfx.console</code> NuGet package, the tool allows you to create a task that will run once your library has been built:</p>
<figure class="mediaobject"><img alt="Interface gráfica do usuário, Texto  Descrição gerada automaticamente" src="img/B19820_05_05.png"/></figure>
<p class="packt_figref">Figure 5.5: docfx.console NuGet library</p>
<p class="normal">The output of this compilation is a stylish static website that contains the documentation of your code:</p>
<figure class="mediaobject"><img alt="" role="presentation" src="img/B19820_05_06.png"/></figure>
<p class="packt_figref">Figure 5.6: DocFx result</p>
<p class="normal">This website is useful because you can distribute the documentation to your team so that they can search for the<a id="_idIndexMarker345"/> libraries you have. You can <a id="_idIndexMarker346"/>check the customizations of the output and find more information about it at <a href="https://dotnet.github.io/docfx/">https://dotnet.github.io/docfx/</a>.</p>
<h3 class="heading-3" id="_idParaDest-120">Documenting a web API using Swagger</h3>
<p class="normal">There is no doubt that a web API is one<a id="_idIndexMarker347"/> of the technologies that facilitates and <a id="_idIndexMarker348"/>promotes code reuse. For this reason, ensuring good documentation and, more than that, respecting a standard is good practice and indicates that you are up to date with the approach to delivering reusable<a id="_idIndexMarker349"/> APIs. To do this, we have <strong class="keyWord">Swagger</strong>, which respects the <strong class="keyWord">OpenAPI Specification</strong>.</p>
<p class="normal">The OpenAPI Specification is known as the <a id="_idIndexMarker350"/>standard for describing modern APIs. One of the most widely used tools for documenting APIs in an <strong class="keyWord">ASP.NET Core Web API</strong> is <code class="inlineCode">Swashbuckle.AspNetCore</code>.</p>
<p class="normal">The good thing about using the <code class="inlineCode">Swashbuckle.AspNetCore</code> library is where you can set the <strong class="keyWord">Swagger UI</strong> viewer for your web API, which <a id="_idIndexMarker351"/>is a good, graphical way to distribute the APIs.</p>
<p class="normal">We will learn how to use this library in <a id="_idIndexMarker352"/>ASP.NET Core web APIs <a id="_idIndexMarker353"/>in <em class="chapterRef">Chapter 15</em>, <em class="italic">Applying Service-Oriented Architectures with .NET</em>. Until <a id="_idIndexMarker354"/>then, it is important to understand that this documentation will help not only your team but any developer who might use the APIs you are developing.</p>
<h1 class="heading-1" id="_idParaDest-121">Summary</h1>
<p class="normal">This chapter aimed to help you understand the advantages of code reuse. It also gave you an idea about what code is not appropriate for reuse. This chapter also presented approaches for reusing and refactoring code.</p>
<p class="normal">Considering that technology without processes does not take you anywhere, a process was presented that helps enable code reuse. This process is related to using already completed components from your library, identifying features in the software requirements specification that are candidates to be designed as library components, modifying the specification considering these features, designing the reusable components, and building the project architecture with the new component library version.</p>
<p class="normal">Concluding this chapter, we presented .NET Standard libraries as an approach to reusing code for different C# platforms, indicating that .NET 8 and new versions allow the reuse of code across different platforms. This chapter also reinforced the principles of object-oriented programming when reusing code and presented generics as a sophisticated implementation to simplify the treatment of objects with the same characteristics.</p>
<h1 class="heading-1" id="_idParaDest-122">Questions</h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Can copy-and-paste be considered code reuse? What are the impacts of this approach?</li>
<li class="numberedList">How can you reuse code without copying and pasting it?</li>
<li class="numberedList">Is there a process that can help with code reuse?</li>
<li class="numberedList">What is the difference between .NET Standard and .NET Core?</li>
<li class="numberedList">What are the advantages of creating a .NET Standard library?</li>
<li class="numberedList">How does object-oriented analysis help with code reuse?</li>
<li class="numberedList">How do generics help with code reuse?</li>
<li class="numberedList">Will .NET Standard be replaced by .NET 6?</li>
<li class="numberedList">What are the challenges related to refactoring?</li>
</ol>
<h1 class="heading-1" id="_idParaDest-123">Further reading</h1>
<p class="normal">The following are some books and websites where you will find more information about the topics covered in this chapter:</p>
<ul>
<li class="bulletList"><em class="italic">Clean Code: A Handbook of Agile Software Craftmanship</em> by Martin, Robert C. Pearson Education, 2012.</li>
<li class="bulletList"><em class="italic">Clean Architecture: A Craftsman’s Guide to Software Structure and Design</em> by Martin, Robert C. Pearson Education, 2018.</li>
<li class="bulletList"><em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em> by Eric Gamma [et al.] Addison-Wesley, 1994.</li>
<li class="bulletList"><em class="italic">Design Principles and Design Patterns</em> by Robert C. Martin, 2000.</li>
<li class="bulletList"><em class="italic">Refactoring</em> by Martin Fowler, 2018.</li>
<li class="bulletList">If you need more information about .NET Standard:<ul>
<li class="bulletList"><a href="https://devblogs.microsoft.com/dotnet/introducing-net-standard/">https://devblogs.microsoft.com/dotnet/introducing-net-standard/</a></li>
<li class="bulletList"><a href="https://www.packtpub.com/application-development/net-standard-20-cookbook">https://www.packtpub.com/application-development/net-standard-20-cookbook</a></li>
<li class="bulletList"><a href="https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/">https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/</a></li>
<li class="bulletList"><a href="https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/">https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/</a></li>
</ul>
</li>
<li class="bulletList">A great guide for programming using the generics concept: <a href="https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/">https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/</a></li>
<li class="bulletList">Some links that may help you with the documentation of libraries and APIs:<ul>
<li class="bulletList"><a href="https://dotnet.github.io/docfx/">https://dotnet.github.io/docfx/</a></li>
<li class="bulletList"><a href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore">https://github.com/domaindrivendev/Swashbuckle.AspNetCore</a></li>
<li class="bulletList"><a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger">https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger</a></li>
</ul>
</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_Code175081751210902046.png"/></p>
</div>
</body></html>