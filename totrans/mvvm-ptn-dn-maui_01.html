<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer009">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>What Is the MVVM Design Pattern?</h1>
<p>The <strong class="bold">MVVM</strong> or <strong class="bold">Model-View-ViewModel</strong> pattern is a<a id="_idIndexMarker000"/> very commonly used design pattern in the .NET ecosystem, where it has proven to be a good fit for front-end frameworks that utilize <strong class="bold">XAML</strong> to build graphical user interfaces. And it’s not hard to <span class="No-Break">see why.</span></p>
<p>This book will provide a good understanding of the MVVM design pattern and how to effectively apply it in <strong class="bold">.NET MAUI</strong> projects. It’s important to note that while we will focus on applying MVVM in the context of .NET MAUI, the MVVM pattern itself is not exclusive to the .NET ecosystem. It is a widely used design pattern that has gained popularity across various software development ecosystems, including frameworks like WPF, WinUI, and others. We’ll delve into various aspects of .NET MAUI to understand how it supports and enables the use of MVVM. Throughout the book, we’ll be building the “<em class="italic">Recipes!</em>” app as a practical example, showcasing various aspects of the MVVM pattern applied in .<span class="No-Break">NET MAUI.</span></p>
<p>In this chapter, we’ll learn about the MVVM design pattern and its core components. We will look into what added value the pattern brings in terms of separation of concerns and why this is so important. A sample application will demonstrate the added value MVVM can bring to your code. Finally, we’ll discuss some common misconceptions <span class="No-Break">about MVVM.</span></p>
<p>By the end of this chapter, you will understand what MVVM is, what its main components are, and what each component’s role is. You will also see what value MVVM adds in terms of the testability and maintainability of <span class="No-Break">your code.</span></p>
<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
<ul>
<li>MVVM’s <span class="No-Break">core components</span></li>
<li>Separation of <span class="No-Break">concerns matters</span></li>
<li>MVVM <span class="No-Break">in action</span></li>
<li>Common misconceptions <span class="No-Break">about MVVM</span></li>
</ul>
<p>Before diving into the details of MVVM in .NET MAUI, it’s essential to familiarize ourselves with the core components of the MVVM pattern. In the following section, we’ll define the key terminologies to ensure we have a solid foundation and a shared understanding <span class="No-Break">moving forward.</span></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Technical requirements</h1>
<p>Although this chapter gives a theoretical overview of MVVM, later there is some code showing MVVM in action so you can start seeing the value this pattern brings. To implement this sample yourself, you’ll need the following: <em class="italic">Visual Studio 2022 (17.3 or greater), or any IDE that allows you to create .NET MAUI apps</em>. Near the end of <a href="B20941_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><em class="italic">, What Is .NET MAUI?</em>, we’ll be looking at how to get your machine ready for developing .NET MAUI apps. The sample code can also be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI"><span class="No-Break">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Looking at MVVM’s core components</h1>
<p>MVVM provides a very clear<a id="_idIndexMarker001"/> way to separate UI from business logic, promoting code reusability, maintainability, and testability while allowing flexible UI design <span class="No-Break">and changes.</span></p>
<p>Having business<a id="_idIndexMarker002"/> logic living in the code-behind quickly becomes challenging as applications grow in size and complexity. Code-behind refers to the practice of placing the business logic within the same file as the user interface elements, often resulting in a significant amount of code being invoked through event handlers. This frequently results in a tight coupling between UI elements and the underlying business logic, as UI elements are directly referenced and manipulated within the code. As a result, making adjustments to the UI and performing unit testing can become more difficult. Later on in this chapter, in the <em class="italic">MVVM in action</em> section, we will see what it means to have business logic in the code-behind and how that complicates maintainability, testing, <span class="No-Break">et cetera.</span></p>
<p>At first glance, MVVM might be slightly overwhelming or confusing. In order to fully understand what the pattern is all about and why it is so popular with XAML developers, we first need to dissect the MVVM pattern and look at its <span class="No-Break">core components.</span></p>
<p>The name of the pattern already gives away three essential core components: the <strong class="bold">Model</strong>, the <strong class="bold">View</strong>, and the <strong class="bold">ViewModel</strong>. There are also two supporting elements that are<a id="_idIndexMarker003"/> crucial for efficiently using MVVM: <strong class="bold">Commands</strong> and <strong class="bold">data binding</strong>. Each of these elements <a id="_idIndexMarker004"/>has its own distinct role <span class="No-Break">and</span><span class="No-Break"><a id="_idIndexMarker005"/></span><span class="No-Break"> responsibilities.</span></p>
<p>The following diagram shows<a id="_idIndexMarker006"/> MVVM’s core components and how they interact with <span class="No-Break">each other:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<img alt="Figure 1.1 – Core components of MVVM" height="79" src="image/B20941_01_01.jpg" width="605"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Core components of MVVM</p>
<p>If you want to use the MVVM pattern effectively, it’s important that you understand not only the responsibilities of each component but also how they interact with each other. At a high level, the View knows about the ViewModel, and the ViewModel knows about the Model, but the Model is unaware of the ViewModel. This separation prevents tight coupling between the UI and <span class="No-Break">business logic.</span></p>
<p>In order to use the MVVM pattern efficiently and effectively, it is important that you understand how to organize your app code into suitable classes and how these classes interact with each other. Now, let’s look into the <span class="No-Break">core components.</span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Model</h2>
<p>The Model is <a id="_idIndexMarker007"/>responsible for representing the data and business logic of the application. It encapsulates the data and provides a way to manipulate it. The Model <a id="_idIndexMarker008"/>can communicate with other components within the application, such as a database or a <span class="No-Break">web service.</span></p>
<p>It is often implemented using classes that represent the objects in the application’s domain, such as customers, orders, or products. These classes typically contain properties that represent the attributes of the objects and methods that define the behavior of <span class="No-Break">the objects.</span></p>
<p>The Model is designed to be independent of the UI framework used in the application. As a result, it can be reused in other applications if needed. It can be maintained and tested in isolation, separately from the <span class="No-Break">application’s UI.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">Often, it’s unclear to developers who are new to MVVM what type of object the Model can or should be: <strong class="bold">Data Transfer Objects</strong> (<strong class="bold">DTOs</strong>), <strong class="bold">Plain Old CLR Objects</strong> (<strong class="bold">POCOs</strong>), domain entities, proxy objects, services, and so on. All these types of objects can be seen as <span class="No-Break">the Model.</span></p>
<p>Moreover, in most<a id="_idIndexMarker009"/> cases, the Model is a combination of different types of objects. Don’t see the Model as a single <a id="_idIndexMarker010"/>thing. In fact, it’s everything ‘outside’ the View and ViewModel – it’s the application’s domain and business logic. Ultimately, the choice of Model type will depend on the specific requirements, use case, and architecture of the application. Some developers may prefer to use DTOs for simplicity and ease of use, while others may prefer to use domain entities for better encapsulation and consistency with the <span class="No-Break">domain model.</span></p>
<p>However, regardless of the specific type of Model being used, it’s important to keep the business logic within the Model ‘layer’ and avoid it in the ViewModel. This helps to maintain separation of concerns and keeps the ViewModel focused on presentation logic, while the Model focuses on <span class="No-Break">business logic.</span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>View</h2>
<p>The View is<a id="_idIndexMarker011"/> responsible for presenting the data to the user. It consists of (UI) elements, such as buttons, labels, collections, and inputs. The View receives input or <a id="_idIndexMarker012"/>actions from the user and communicates with the ViewModel so it can react to <span class="No-Break">those interactions.</span></p>
<p>In .NET MAUI, the View is often implemented using XAML, which is a markup language used to define the UI elements and layouts. The XAML file defines the structure of the UI and its bindings to the ViewModel. It’s important to note that while the MVVM pattern is often associated with XAML-based UIs, its principles are not limited to a specific UI framework. The MVVM pattern can be applied in other UI frameworks as well. In .NET MAUI, most apps use XAML for defining the UI, but it’s also possible to create the UI entirely in C#. Even when taking this approach, developers can still effectively apply the MVVM pattern to separate the concerns of the View, ViewModel, <span class="No-Break">and Model.</span></p>
<p>The most important aspect of the View is that it should be designed to be as simple as possible, without any business rules or logic. Its main purpose is to present data to the user and receive input from them. The View’s focus should be on presentation logic, including formatting and layout, and it should not include any business logic or application logic to maintain <a id="_idIndexMarker013"/>proper separation of concerns <span class="No-Break">in MVVM.</span></p>
<p class="callout-heading">Tip</p>
<p class="callout">By keeping the View simple and focused on presentation logic, the code can be easier to maintain and test. It also enables the UI to be changed without affecting the underlying business logic, allowing for greater flexibility in adapting and evolving the application <span class="No-Break">over time.</span></p>
<p>The View, whether it is<a id="_idIndexMarker014"/> implemented using XAML or C#, is the application’s UI layer. Essentially, it is the collection of UI components, such as pages and controls, that make up the <span class="No-Break">user interface.</span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>ViewModel</h2>
<p>The ViewModel sits in between the Model and the View. It’s the “glue” between the UI and the business logic. Its <a id="_idIndexMarker015"/>responsibility is to expose data to the View for display and to handle any user input or UI events. It provides an interface for the View to interact with the Model, which contains the<a id="_idIndexMarker016"/> actual data and business logic of the <a id="_idIndexMarker017"/>application. Let’s delve into what the ViewModel does, step <span class="No-Break">by step:</span></p>
<ol>
<li><strong class="bold">Exposing data</strong>: The ViewModel retrieves data from the Model and exposes it to the View through public <a id="_idIndexMarker018"/>properties. These properties are usually bound to elements in the View, such as text boxes or labels. This way, the data from the Model gets displayed on <span class="No-Break">the screen.</span></li>
<li><strong class="bold">Reflecting changes</strong>: Now, you <a id="_idIndexMarker019"/>might be wondering what happens when the user changes something on the screen. That’s where data binding comes in. Data binding is like a live channel of communication between the View and the ViewModel. When the user modifies data in the View, the ViewModel is instantly notified and updates its properties accordingly. Similarly, if something changes in the ViewModel, the View gets <span class="No-Break">updated too.</span></li>
<li><strong class="bold">Handling user interactions</strong>: The ViewModel doesn’t just passively provide data; it’s also responsible<a id="_idIndexMarker020"/> for dealing with user interactions, such as button clicks and text input. For example, if there’s a <strong class="bold">Save</strong> button on the View, the ViewModel needs to know what to do when the user clicks <span class="No-Break">on it.</span></li>
<li><strong class="bold">Updating the Model</strong>: When the user interacts with the UI and makes changes, the ViewModel plays an essential role in <a id="_idIndexMarker021"/>updating the Model. The ViewModel takes the user’s changes and translates them into actions that the Model can understand <span class="No-Break">and process.</span></li>
</ol>
<p>The ViewModel acts <a id="_idIndexMarker022"/>as an intermediary that handles the flow of data and actions between the View and the Model, ensuring that the user interface accurately represents the underlying data and responds correctly to user interactions. This modular approach, where it handles specific responsibilities separately from the View <a id="_idIndexMarker023"/>and Model, contributes to cleaner and more maintainable code. Finally, it’s essential to understand that the ViewModel should not be tied to any specific UI framework. Being independent of a UI framework allows it to be shared across different applications and facilitates easier testing in isolation from the rest of <span class="No-Break">the application.</span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Commands</h2>
<p>Commands are an<a id="_idIndexMarker024"/> important concept used to represent actions that can be triggered by the UI. They are a way for the View to communicate user actions to the <a id="_idIndexMarker025"/>ViewModel. A Command is an object that implements the <strong class="source-inline">ICommand</strong> interface, which defines two methods: <strong class="source-inline">Execute</strong> and <strong class="source-inline">CanExecute</strong>. The <strong class="source-inline">Execute</strong> method is called when the Command is triggered, while the <strong class="source-inline">CanExecute</strong> method is used to determine whether the Command can be executed in its <span class="No-Break">current state.</span></p>
<p>Commands can be seen as the equivalent of events in traditional event-driven programming. Both Commands and events serve as mechanisms to handle user actions or other triggers in an application. For instance, when the user clicks a button in the View, a Command in the ViewModel gets triggered, and the ViewModel takes appropriate actions such as saving data or fetching new information. Commands are highly versatile and are not limited to buttons. They can be associated with various UI elements such as menu items, toolbar buttons, or even gesture controls. Let’s take a practical example: suppose you have a text editor application. You could have a Command associated with the <strong class="bold">Save</strong> button, another one for the <strong class="bold">Copy</strong> menu item, and yet another for a gesture control that triggers the <strong class="bold">Paste</strong> action. In each case, when the UI element is interacted with, the associated Command’s <strong class="source-inline">Execute</strong> method is called and then performs the <a id="_idIndexMarker026"/><span class="No-Break">necessary action.</span></p>
<p>One of the key benefits of using Commands in the MVVM pattern is that they allow for better separation of concerns between the View and the ViewModel. By using Commands, the<a id="_idIndexMarker027"/> View can be designed without knowing anything about the underlying functionality that is associated with a particular UI element. This means that the ViewModel can handle the entire logic associated with the Command, without having to be tightly coupled to <span class="No-Break">the UI.</span></p>
<p>In order to bind a Command to a UI element in the View, the Command needs to be exposed by the ViewModel as a public property. The View can then bind to this property using data binding. When a Command is bound to a UI element in the View, the UI element is listening for an event such as a button click to occur. When that event is triggered, the Command’s <strong class="source-inline">Execute</strong> method, which contains the code that should be executed in response to the event, <span class="No-Break">is called.</span></p>
<p>Overall, Commands are a powerful and flexible concept in the MVVM pattern, which enables better separation of concerns between the View and <span class="No-Break">the ViewModel.</span></p>
<p class="callout-heading">More about Commands</p>
<p class="callout">We’ll dive into much more detail about Commands and how to use them in practice in <a href="B20941_03.xhtml#_idTextAnchor051"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><em class="italic">, Data Binding Building Blocks in .</em><span class="No-Break"><em class="italic">NET MAUI</em></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Data binding</h2>
<p>Data binding is a core<a id="_idIndexMarker028"/> feature of MVVM that enables the ViewModel to <a id="_idIndexMarker029"/>communicate with the View and the View with the ViewModel in a loosely coupled manner. Data binding allows you to bind data properties in the ViewModel to UI elements in the View, such as entry fields, labels, and list views. It is used to synchronize the data between the View and the ViewModel. When the data in the ViewModel changes, the data binding engine updates the View, and vice versa, depending on how the binding is configured. This allows the UI to reflect the current state of <span class="No-Break">the application.</span></p>
<p>The binding process involves<a id="_idIndexMarker030"/> three components: a <strong class="bold">source</strong> object (the ViewModel), a <strong class="bold">target</strong> object (the UI element), and a <strong class="bold">binding expression</strong> that specifies how the two objects should <span class="No-Break">be connected.</span></p>
<p>Data can <a id="_idIndexMarker031"/>flow in different directions: from the ViewModel to the View, the other way around, or both. Here are the ways data <span class="No-Break">can flow:</span></p>
<ul>
<li><strong class="bold">One-way</strong>: From the ViewModel to the View, this allows the values of the properties on the ViewModel to<a id="_idIndexMarker032"/> be displayed on the View. This type of binding is typically used when updates on the ViewModel should automatically update the value on <span class="No-Break">the View.</span></li>
<li><strong class="bold">One-way-to-source</strong>: The exact opposite of one-way, the data only flows from the View to the ViewModel. Values<a id="_idIndexMarker033"/> entered in the View will automatically be reflected on <span class="No-Break">the ViewModel.</span></li>
<li><strong class="bold">One-time</strong>: Like one-way, the data flows from the ViewModel to the View, but the data binding engine will not listen for any changes that occur on the bound property. Once the initial <a id="_idIndexMarker034"/>value is displayed on the UI, any subsequent changes to the property will not be reflected on the View. This can have a significant positive performance impact when doing a lot of <span class="No-Break">data binding.</span></li>
<li><strong class="bold">Two-way</strong>: Data flows in two ways; from<a id="_idIndexMarker035"/> the View to the ViewModel and from the ViewModel to the View. Changes made to the data in the UI are automatically propagated back to the ViewModel. A common scenario for using two-way data binding is when displaying a property in the View that the user can modify. In this case, the property is typically bound to an input field using two-way data binding. This allows the initial value of the property to be displayed in the input field, and any changes made by the user to be automatically<a id="_idIndexMarker036"/> reflected to the ViewModel, without the need for additional event handling or <span class="No-Break">manual updates.</span></li>
</ul>
<p>Data binding is a very powerful concept and an essential component in the MVVM pattern. It allows the ViewModel to expose data and behavior as simple properties to the View, in a way that is independent of the UI framework. Through data binding, these properties can be bound to the <a id="_idIndexMarker037"/>UI in a loosely coupled manner. By using data binding, the View and ViewModel in MVVM can be synchronized seamlessly without the need for any manual code. The binding mode determines how changes in the data are propagated between the<a id="_idIndexMarker038"/> View and ViewModel. Additionally, data binding allows the View to communicate user input back to the ViewModel through Commands, which can then update <span class="No-Break">the Model.</span></p>
<p class="callout-heading">More about data binding</p>
<p class="callout">Everything you need to know <a id="_idIndexMarker039"/>about data binding and how to effectively use it in .NET MAUI is covered thoroughly in <a href="B20941_03.xhtml#_idTextAnchor051"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><em class="italic">, Data Binding Building Blocks in .NET MAUI</em>, and <a href="B20941_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><em class="italic">, Data Binding in .</em><span class="No-Break"><em class="italic">NET MAUI</em></span><span class="No-Break">.</span></p>
<p>Now that we have a good understanding of MVVM’s core components and have gained insights into each component’s responsibility, let’s discuss in a bit more detail why MVVM matters and what value <span class="No-Break">it adds.</span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Separation of concerns matters</h1>
<p><strong class="bold">Separation of concerns</strong> is an<a id="_idIndexMarker040"/> important principle in software development that aims to divide software design and implementation into distinct parts, each with a specific and well-defined responsibility. This principle helps developers create more maintainable and flexible applications by reducing the complexity of each individual component and allowing for more modular and <span class="No-Break">reusable code.</span></p>
<p>In practical terms, separation of concerns means that different aspects of a system are separated and dealt with independently, without overlapping concerns. This is achieved by creating distinct layers or modules, each with its own well-defined responsibilities and interfaces, and minimizing the dependencies <span class="No-Break">between them.</span></p>
<p>Let’s consider the example of a restaurant’s management system. In such a system, there could be several concerns like table reservation, order taking, kitchen operations, and billing. According to the principle of separation of concerns, each of these areas should be handled by a <span class="No-Break">separate module.</span></p>
<p>Each module has its own set of responsibilities and would communicate with others through well-defined interfaces. For example, when a customer orders a dish, the order-taking module communicates with the kitchen operations module so that the dish can <span class="No-Break">be prepared.</span></p>
<p>This separation means that if you need to make changes to how table reservations work, you can do so without affecting kitchen operations or billing. This separation keeps the codebase more organized, easier to maintain, and allows for focused testing of <span class="No-Break">individual modules.</span></p>
<p>Let’s explore how <a id="_idIndexMarker041"/>separation of concerns enhances both maintainability and testability. These are the two crucial aspects that are vital to the long-term success of any <span class="No-Break">software application.</span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Maintainability</h2>
<p>By applying MVVM, we are<a id="_idIndexMarker042"/> separating the UI from the business logic and loosely coupling the ViewModel with the View. This improves maintainability greatly as each component has its distinct role and its <span class="No-Break">distinct concern.</span></p>
<p>The View, for example, can be easily altered or updated. UI elements can be moved around or replaced with newer, more modern ones without requiring changes to the ViewModel, as long as no additional data needs to be displayed. This is because the only interface between the View and the ViewModel is through data binding. Therefore, updating the View should not affect the ViewModel unless additional or altered data needs to <span class="No-Break">be displayed.</span></p>
<p>Additionally, when the View requires additional data to be displayed or a UI element is updated and requires further data, the ViewModel may need to be updated as well. However, if the required data is already available in the Model, the ViewModel can translate it between the Model and the View without affecting the Model itself. The ViewModel is responsible for managing data flow between the Model and the View, ensuring a clear separation of concerns between the different layers of <span class="No-Break">the application.</span></p>
<p>In addition, any changes in the Model’s business logic should not have a significant impact on the ViewModel or the View. Since the ViewModel acts as a mediator between the Model and the View, it’s responsible for translating the data from the Model to be used by the View. Therefore, if any underlying business logic should change, the ViewModel can handle the translation without affecting the View, ensuring that any changes made to the Model are transparent to <span class="No-Break">the user.</span></p>
<p>Even when an update to the Model or ViewModel is needed, thanks to the nature of the MVVM pattern, these changes <a id="_idIndexMarker043"/>can be easily tested in isolation from each other and, most importantly, independently of the UI. This separation enables efficient and <span class="No-Break">focused testing.</span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Testability</h2>
<p>Testability is a very important factor in software development. Not only do tests ensure that the tested code<a id="_idIndexMarker044"/> performs its intended function, but it also guarantees that it continues to operate as initially designed. When a successful set of tests is run, feedback is provided immediately after a code update inadvertently breaks the functionality. This is undoubtedly vital for maintaining the quality and stability of the codebase. In essence, comprehensive testing plays a crucial role in preserving the code’s maintainability, allowing for efficient modifications and improvements <span class="No-Break">over time.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">By designing an application with testability in mind, developers can create code that is more reliable, maintainable, <span class="No-Break">and scalable.</span></p>
<p>Separation of concerns is crucial to achieving testability because it allows developers to isolate and test individual components of the application without worrying about dependencies on other parts of <span class="No-Break">the system.</span></p>
<p>From the perspective of the MVVM design pattern, separation of concerns and testability are closely related. As the View, ViewModel, and Model are being treated as distinct components, each component is able to be written and tested independently of the others. Because the ViewModel is decoupled from the View and is agnostic of any specific UI framework, it is very easy to write automated unit tests for it. These automated tests are faster and more reliable than manual or automated UI testing, which allows developers to identify errors and regressions early in the development process before they<a id="_idIndexMarker045"/> become more difficult and expensive to fix. Similarly, the Model logic can also be effectively tested in isolation, independently of the ViewModel and <span class="No-Break">the View.</span></p>
<p>That’s the theory. Now, let’s take a look at an <span class="No-Break">MVVM example!</span></p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>MVVM in action</h1>
<p>Let’s look at a very <a id="_idIndexMarker046"/>simple application that shows the user a quote of the day on the screen. When the user clicks a button on the screen, the application will fetch a quote of the day from an API and show it onscreen. Once the button is clicked, it should be hidden. The code-behind approach will show you how this app can be written without using the MVVM pattern, whereas the second example shows the same functionality implemented using MVVM with testability <span class="No-Break">in mind.</span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>The code-behind approach</h2>
<p>In the following code<a id="_idIndexMarker047"/> snippet, there is no separation of concerns; all the code is handled in the code-behind of the XAML page. While this code seems to be doing what is expected, there is no easy, fast, or robust way to test whether it works. This is because all the logic is handled in the click event handler of <span class="No-Break">the button.</span></p>
<p>In <strong class="source-inline">MainPage.xaml</strong>, we define a <strong class="source-inline">Button</strong> and <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">Label</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;Grid&gt;
    &lt;Button
        x:Name="GetQuoteButton"
        Clicked="Button_Clicked"
        Text="Get Quote of the day" /&gt;
    &lt;Label
        x:Name="QuoteLabel"
        HorizontalOptions="Center"
        IsVisible="false"
        Style="{DynamicResource TitleStyle}"
        VerticalOptions="Center" /&gt;
&lt;/Grid&gt;</pre> <p>Both button and label controls have a <strong class="source-inline">Name</strong> so that they can be referenced from the code-behind. The label, is <a id="_idIndexMarker048"/>not visible <span class="No-Break">by default.</span></p>
<p>In the code-behind (<strong class="source-inline">MainPage.xaml.cs</strong>), we handle the button click event <span class="No-Break">as follows:</span></p>
<pre class="source-code">
private async void Button_Clicked(
    object sender, EventArgs e)
{
    GetQuoteButton.IsVisible = false;
    try
    {
        var client = new HttpClient();
        var quote = await
            client.GetStringAsync(
            "https://my-quotes-api.com/quote-of-the-day");
        QuoteLabel.Text = quote;
        QuoteLabel.IsVisible = true;
    }
    catch (Exception)
    {
    }
}</pre> <p>On the button click, the <strong class="source-inline">GetQuoteButton</strong> is being hidden and a call to fetch a quote is being made. The <strong class="source-inline">QuoteLabel</strong>’s <strong class="source-inline">Text</strong> property is assigned the value of the <span class="No-Break">retrieved quote.</span></p>
<p>Note that there’s a subtle bug in this code: if the API call fails, the exception being thrown would be silently<a id="_idIndexMarker049"/> caught, but the <strong class="source-inline">GetQuoteButton</strong>’s visibility won’t be restored to being visible, leaving the application unusable. But as there is no easy way to test this code, chances are high that this scenario is left unnoticed until the application gets to QA where, hopefully, a manual test might pick this <span class="No-Break">issue up.</span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Using MVVM</h2>
<p>Now, let’s look at<a id="_idIndexMarker050"/> how we could transform this application using the MVVM pattern, keeping separation of concerns and testability in mind. It might be that not everything in this example is clear yet and that’s perfectly fine. While going through this book, all of these aspects should become clear <span class="No-Break">very rapidly.</span></p>
<p>Let’s start off by looking at what the Model in this app <span class="No-Break">would be.</span></p>
<h3>The Model</h3>
<p>In our sample application, the<a id="_idIndexMarker051"/> primary data we are working with is the quote that we fetch from an API. The logic that communicates with this API to fetch the data can be thought of as the Model. Instead of making the HTTP request directly in the code-behind as we previously did, we can encapsulate this logic into a separate class. This class will be responsible for fetching the quote and will act as our Model. Here’s what that might <span class="No-Break">look like:</span></p>
<pre class="source-code">
public class QuoteService : IQuoteService
{
    private readonly HttpClient httpClient;
    public QuoteService()
    {
        httpClient = new HttpClient();
    }
    public async Task&lt;string&gt; GetQuote()
    {
        var response = await
        httpClient.GetAsync("https://my-quotes-api.com/
        quote-of-the-day");
        if (response.IsSuccessStatusCode)
        {
            return await
            response.Content.ReadAsStringAsync();
        }
        throw new Exception("Failed to retrieve quote.");
    }
}
public interface IQuoteService
{
    Task&lt;string&gt; GetQuote();
}</pre> <p>As you can see, we have created a <strong class="source-inline">QuoteService</strong> class, which contains the logic for fetching the quote from the API. This class implements an interface called <strong class="source-inline">IQuoteService</strong>. By defining an interface, we are making it easier to swap out the implementation or mock this service for testing <span class="No-Break">purposes later.</span></p>
<p>By having this logic, which was previously in our code-behind, encapsulated in a dedicated class already<a id="_idIndexMarker052"/> gives us a cleaner separation <span class="No-Break">of concerns.</span></p>
<p>This covers the Model part of the Model-View-ViewModel pattern. Let’s see what the ViewModel could <span class="No-Break">look like.</span></p>
<h3>The ViewModel</h3>
<p>The ViewModel acts as an intermediary between the View and the Model. It holds the data and the Commands<a id="_idIndexMarker053"/> that the View will bind to. For our simple application, we need the following things in <span class="No-Break">our ViewModel:</span></p>
<ul>
<li>A property to hold the quote of the day once it <span class="No-Break">is retrieved</span></li>
<li>Two properties to control the visibility of the button and <span class="No-Break">the label</span></li>
<li>A Command that will be triggered when the button is clicked; this will be responsible for fetching <span class="No-Break">the quote</span></li>
</ul>
<p>We also need to have a constructor that takes a parameter of type <strong class="source-inline">IQuoteService</strong>. This is where dependency injection comes <span class="No-Break">into play.</span></p>
<p class="callout-heading">More about dependency injection</p>
<p class="callout">Dependency injection is key to making classes testable and modular, and is used very commonly in MVVM. <a href="B20941_07.xhtml#_idTextAnchor119"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><em class="italic">, Dependency Injection, Services, and Messaging</em>, covers this concept <span class="No-Break">in depth.</span></p>
<p>Let’s take a look at what this might look like <span class="No-Break">in code:</span></p>
<pre class="source-code">
public class MainPageViewModel : INotifyPropertyChanged
{
    private readonly IQuoteService quoteService;
    public MainPageViewModel(IQuoteService quoteService)
    {
        this.quoteService = quoteService;
    }
    public event PropertyChangedEventHandler
    PropertyChanged;
}</pre> <p>The constructor takes an instance of <strong class="source-inline">IQuoteService</strong> as a parameter. This instance is assigned to the <strong class="source-inline">quoteService</strong> field within the class. This way, the ViewModel has access to the quote-fetching service, allowing it to retrieve quotes <span class="No-Break">when needed.</span></p>
<p>Also note that this class implements the <strong class="source-inline">INotifyPropertyChanged</strong> interface, and therefore needs to implement the <strong class="source-inline">PropertyChanged</strong> event. Its purpose is essentially to make sure the<a id="_idIndexMarker054"/> UI gets notified when data on the ViewModel changes so the View and ViewModel stay in sync. <a href="B20941_03.xhtml#_idTextAnchor051"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><em class="italic">, Data Binding Building Blocks in .NET MAUI, </em>covers this in much <span class="No-Break">more depth!</span></p>
<p><strong class="source-inline">QuoteOfTheDay</strong> is the property that holds the retrieved quote. This is just a simple property holding a string value. The only thing “special” about it is that it triggers the <strong class="source-inline">PropertyChanged</strong> event to inform the data binding engine about the <span class="No-Break">updated value:</span></p>
<pre class="source-code">
private string quoteOfTheDay;
public string QuoteOfTheDay
{
    get =&gt; quoteOfTheDay;
    set
    {
        quoteOfTheDay = value;
        <strong class="bold">PropertyChanged?.Invoke(this,</strong>
<strong class="bold">            new PropertyChangedEventArgs(</strong>
<strong class="bold">            nameof(QuoteOfTheDay)));</strong>
    }
}</pre> <p>The two properties that control the visibility of the button and the label are <strong class="source-inline">IsButtonVisible</strong> and <strong class="source-inline">IsLabelVisible</strong>, respectively. Again, these are simple public properties that trigger<a id="_idIndexMarker055"/> the <span class="No-Break"><strong class="source-inline">PropertyChanged</strong></span><span class="No-Break"> event:</span></p>
<pre class="source-code">
private bool isButtonVisible = true;
public bool IsButtonVisible
{
    get =&gt; isButtonVisible;
    set
    {
        isButtonVisible = value;
        PropertyChanged?.Invoke(this,
            new PropertyChangedEventArgs(
            nameof(IsButtonVisible)));
    }
}
bool isLabelVisible;
public bool IsLabelVisible
{
    get =&gt; isLabelVisible;
    set
    {
        isLabelVisible = value;
        PropertyChanged?.Invoke(this,
            new PropertyChangedEventArgs(
            nameof(IsLabelVisible)));
    }
}</pre> <p>Before we<a id="_idIndexMarker056"/> implement the Command that should be invoked when the user clicks the buttons, let’s first implement the logic that needs to be executed by <span class="No-Break">said Command:</span></p>
<pre class="source-code">
private async Task GetQuote()
{
    IsButtonVisible = false;
    try
    {
        var quote = await quoteService.GetQuote();
        QuoteOfTheDay = quote;
        IsLabelVisible = true;
    }
    catch (Exception)
    {
    }
}</pre> <p>The <strong class="source-inline">GetQuote</strong> method is asynchronous, meaning it allows for non-blocking execution, which is especially important when fetching data from a network source. It starts by setting the <strong class="source-inline">IsButtonVisible</strong> property to <strong class="source-inline">false</strong>, which should hide the button on the screen. Next, we’re calling the <strong class="source-inline">GetQuote</strong> method of the <strong class="source-inline">quoteService</strong> field, which will go out and fetch a quote. What this service actually does to retrieve the quote isn’t important here, as that isn’t the concern of our ViewModel. Once we receive a quote back from the <strong class="source-inline">GetQuote</strong> method of <strong class="source-inline">quoteService</strong>, we assign this value to the <strong class="source-inline">QuoteOfTheDay</strong> property. The <strong class="source-inline">IsLabelVisible</strong> property is set to <strong class="source-inline">true</strong> so that the label displaying the quote <span class="No-Break">becomes visible.</span></p>
<p>Finally, we can create a<a id="_idIndexMarker057"/> Command that triggers <span class="No-Break">this method:</span></p>
<pre class="source-code">
public ICommand GetQuoteCommand =&gt; new Command(async _ =&gt; await GetQuote());</pre> <p>Through <strong class="source-inline">GetQuoteCommand</strong>, we can now call the <strong class="source-inline">GetQuote</strong> method defined on <span class="No-Break">the ViewModel.</span></p>
<p>With the Model and the ViewModel in place, let’s finally have a look at <span class="No-Break">the View.</span></p>
<h3>The View</h3>
<p>Essentially, not a<a id="_idIndexMarker058"/> lot of changes are needed to the UI: we still need a button that should trigger the retrieval of the <strong class="source-inline">QuoteOfTheDay</strong> and a label to show it. As we are no longer going to be accessing the label from the code-behind, there is no need to set the <span class="No-Break"><strong class="source-inline">x:Name</strong></span><span class="No-Break"> property:</span></p>
<pre class="source-code">
&lt;Grid&gt;
    &lt;Button
        Text="Get Quote of the day" /&gt;
    &lt;Label
        HorizontalOptions="Center"
        IsVisible="false"
        Style="{DynamicResource TitleStyle}"
        VerticalOptions="Center" /&gt;
&lt;/Grid&gt;</pre> <p>Also, the <strong class="source-inline">Button_Clicked</strong> event handler that we had earlier can be removed from the code-behind. And while we are there, we can also assign the <strong class="source-inline">BindingContext</strong> of the page to an<a id="_idIndexMarker059"/> instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">MainPageViewModel</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
public partial class MainPage_MVVM : ContentPage
{
    public MainPage_MVVM()
    {
        InitializeComponent();
        <strong class="bold">BindingContext = new MainPageViewModel(</strong>
<strong class="bold">            new QuoteService());</strong>
    }
}</pre> <p><strong class="source-inline">BindingContext</strong> is essentially the source that we are going to bind to. With this in place, we make some final adjustments to our XAML to include <span class="No-Break">data-binding statements:</span></p>
<pre class="source-code">
&lt;Grid&gt;
    &lt;Button
        <strong class="bold">Command="{Binding GetQuoteCommand}"</strong>
        <strong class="bold">IsVisible="{Binding IsButtonVisible}"</strong>
        Text="Get Quote of the day" /&gt;
    &lt;Label
        HorizontalOptions="Center"
        <strong class="bold">IsVisible="{Binding IsLabelVisible}"</strong>
        Style="{DynamicResource TitleStyle}"
        <strong class="bold">Text="{Binding QuoteOfTheDay}"</strong>
        VerticalOptions="Center" /&gt;
&lt;/Grid&gt;</pre> <p>These binding statements ‘link’ the public properties exposed on our ViewModel to the properties on the UI elements. When the user clicks the button, <strong class="source-inline">GetQuoteCommand</strong> on <strong class="source-inline">MainPageViewModel</strong> will be invoked, which in turn will execute the <strong class="source-inline">GetQuote</strong> method. While the <strong class="source-inline">GetQuote</strong> method is executed, the <strong class="source-inline">IsButtonVisible</strong> and <strong class="source-inline">IsLabelVisible</strong> properties are being updated, and a quote retrieved from <strong class="source-inline">QuoteService</strong> will be set<a id="_idIndexMarker060"/> as the value of the <strong class="source-inline">QuoteOfTheDay</strong> property. Through data binding, these changes will instantly and automatically be reflected on <span class="No-Break">the View.</span></p>
<p>That’s it! This is basically the same application as we had before. However, this time it is written using the MVVM pattern while keeping separation of concerns and testability <span class="No-Break">in mind.</span></p>
<p>The first thing that immediately stands out is the fact that the MVVM example has more code to it. That’s mostly because of the ViewModel. Luckily, ViewModels should be pretty simple. They should not contain any business logic. In this example, the business logic is inside the <strong class="source-inline">QuoteService</strong> class, which the ViewModel calls into to get the <strong class="source-inline">QuoteOfTheDay</strong> value. The properties on the ViewModel are there to represent the state of the View, such as for controlling the visibility of the button and the label, and for holding the <strong class="source-inline">Quote</strong> that <strong class="source-inline">QuoteService</strong> <span class="No-Break">will return.</span></p>
<p>It should be clear by now that every piece in this example has its <span class="No-Break">own responsibility:</span></p>
<ul>
<li>The View – <strong class="source-inline">MainPage_MVVM</strong> – is responsible for the UI layer. It contains the visual elements such as a <strong class="source-inline">Label</strong> and a <strong class="source-inline">Button</strong> and lays <span class="No-Break">them out.</span></li>
<li>The single responsibility of <strong class="source-inline">QuoteService</strong> – the Model in this scenario – is to fetch <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">Quote</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">MainPageViewModel</strong> glues it all together. It provides the properties and values that the View needs to display, as well as any Commands for <span class="No-Break">handling interactions.</span></li>
</ul>
<p>Every component has only one reason to change, which makes this code much more maintainable, compared to<a id="_idIndexMarker061"/> having everything in the code-behind. Not only maintainability, but also testability is improved a lot compared to the previous example. Don’t take my word for it; let’s explore how we can test the functionality of <span class="No-Break">our app.</span></p>
<h3>Testing your ViewModel</h3>
<p>Finally, let’s take a quick look at what this means for testability. The following code sample shows some<a id="_idIndexMarker062"/> unit tests for <strong class="source-inline">MainPageViewModel</strong>. Again, not everything in here might be clear, but everything will be covered thoroughly throughout this book. Moreover, <a href="B20941_13.xhtml#_idTextAnchor223"><span class="No-Break"><em class="italic">Chapter 13</em></span></a><em class="italic">, Unit Testing</em>, is entirely dedicated to writing unit tests for your ViewModels. In these tests, we’re using the <strong class="bold">Moq</strong> framework to<a id="_idIndexMarker063"/> create mock instances of the <strong class="source-inline">IQuoteService</strong> interface. Mocking is a technique used in unit testing to create a fake or simulated object that mimics the behavior of a real object. This is especially useful for isolating the code being tested and removing dependencies on external elements such as databases or APIs. In the constructor of our test class, which runs before each test, we create a new mock instance that returns an empty string as a result of the <span class="No-Break"><strong class="source-inline">GetQuote</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
private Mock&lt;IQuoteService&gt; quoteServiceMock;
public MainPageViewModelTests()
{
    quoteServiceMock = new Mock&lt;IQuoteService&gt;();
    quoteServiceMock.Setup(m =&gt; m.GetQuote())
      .ReturnsAsync(string.Empty);
}</pre> <p>This mocked instance can be passed in as a parameter when creating a new instance of the <strong class="source-inline">MainPageViewModel</strong> class. This allows us to test the ViewModel without any <span class="No-Break">external dependencies.</span></p>
<p>The first snippet shows two<a id="_idIndexMarker064"/> tests that test the value of the <span class="No-Break"><strong class="source-inline">IsButtonVisible</strong></span><span class="No-Break"> property:</span></p>
<pre class="source-code">
[Fact]
public void ButtonShouldBeVisible()
{
    var sut = new
        MainPageViewModel(quoteServiceMock.Object);
    Assert.True(sut.IsButtonVisible);
}
[Fact]
public void GetQuoteCommand_ShouldSetButtonInvisible()
{
    var sut = new
        MainPageViewModel(quoteServiceMock.Object);
    sut.GetQuoteCommand.Execute(null);
    Assert.False(sut.IsButtonVisible);
}</pre> <p>The first of the preceding tests checks whether the initial value of the <strong class="source-inline">IsButtonVisible</strong> property is <strong class="source-inline">true</strong>. We create a new instance of <strong class="source-inline">MainPageViewModel</strong>, passing in the mocked <strong class="source-inline">IQuoteService</strong> instance. We can now use our <strong class="source-inline">sut</strong> variable (for system under test) to do assertions and see whether everything works as expected. The second test checks that as soon as <strong class="source-inline">GetQuoteCommand</strong> is invoked, the <strong class="source-inline">IsButtonVisible</strong> property <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
<p>The next test checks whether the <strong class="source-inline">Quote</strong> value returned by the injected <strong class="source-inline">IQuoteService</strong>’s <strong class="source-inline">GetQuote</strong> method is being set as the value of the <span class="No-Break"><strong class="source-inline">QuoteOfTheDay</strong></span><span class="No-Break"> property:</span></p>
<pre class="source-code">
[Fact]
public void GetQuoteCommand_GotQuote_ShowQuote()
{
    var quote = "My quote of the day";
    quoteServiceMock.Setup(m =&gt;
        m.GetQuote()).ReturnsAsync(quote);
    var sut = new
        MainPageViewModel(quoteServiceMock.Object);
    sut.GetQuoteCommand.Execute(null);
    Assert.Equal(quote, sut.QuoteOfTheDay);
}</pre> <p>In the preceding test, we define that the <strong class="source-inline">GetQuote</strong> method of the mocked <strong class="source-inline">IQuoteSerivce</strong> should<a id="_idIndexMarker065"/> return a particular value. After executing <strong class="source-inline">GetQuoteCommand</strong>, the <strong class="source-inline">QuoteOfTheDay</strong> property should have the <span class="No-Break">same value.</span></p>
<p>And finally, we have a test that doesn’t test the application’s happy path. Instead, it tests whether the <strong class="source-inline">IsButtonVisible</strong> property is set to <strong class="source-inline">true</strong> after the <strong class="source-inline">quoteService</strong> failed to retrieve a quote, allowing the user to <span class="No-Break">try again:</span></p>
<pre class="source-code">
[Fact]
public void GetQuoteCommand_ServiceThrows_ShouldShowButton()
{
    quoteServiceMock.Setup(m =&gt;
        m.GetQuote()).ThrowsAsync(new Exception());
    var sut = new
        MainPageViewModel(quoteServiceMock.Object);
    sut.GetQuoteCommand.Execute(null);
    Assert.True(sut.IsButtonVisible);
}</pre> <p>This test fails, revealing an issue in the implementation: the <strong class="source-inline">GetQuote</strong> method of the ViewModel handles any exception from <strong class="source-inline">IQuoteService</strong> silently, but fails to re-enable the button, leaving the app in a useless state. Without even running the app once, needing to deploy any other components, or needing to rely on the availability of the quote of the day API, the app’s behavior is effectively being tested and a simple bug could already be identified very early on in the development process. These tests ensure that the application is behaving as it was intended to, but also that it keeps working like this in the future. If a<a id="_idIndexMarker066"/> change to the code would introduce different (unexpected) behavior, automated tests would fail, informing the developer that they have broken something and need to fix it before publishing the app. Unit tests like these are so valuable and very easy to write, as long as there is a clear separation of concerns and the application is written with testability in mind. The MVVM pattern is perfect for this! Like in this example, the ViewModel can be tested in complete isolation as it isn’t tied to the View or any specific UI framework. This ViewModel will work in any kind of .<span class="No-Break">NET application!</span></p>
<p>Compared to the previous example with code-behind implementation, testing becomes significantly more challenging: the app has to be deployed, and a UI testing framework must be used to launch the app, interact with the UI controls, and validate whether the UI shows what is expected. Automated UI tests can be time-consuming to write, run, and maintain. However, would you instead want to depend exclusively on manual testing and QA, rather than leveraging the benefits of automated testing to ensure the quality and reliability of your <span class="No-Break">app’s behavior?</span></p>
<p>When using the MVVM pattern, it becomes very easy to write unit tests that test different areas of the application, as it promotes separation of concerns and should be UI framework independent. Testing business logic through automated UI tests when everything is in the code-behind becomes very complex, hard to maintain, and error-prone very fast. UI tests have their purpose as they can test whether the user interface of an application behaves <a id="_idIndexMarker067"/>as expected. Both types of tests are important and serve different purposes in ensuring the quality of an application. But (automated) UI tests should just do that: test the UI. Your ViewModels and business logic should already be tested by other <span class="No-Break">automated tests.</span></p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Common misconceptions about MVVM</h1>
<p>There are several<a id="_idIndexMarker068"/> common misconceptions about MVVM that can lead to misunderstandings of its principles and best practices. Let’s dispel some of these and provide clarity on <span class="No-Break">the pattern.</span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>There should be no code in the code-behind</h2>
<p>While it is true that the main purpose of MVVM is to separate the presentation logic from the application logic, it is not necessarily the case that there should be <em class="italic">no</em> code in the code-behind. The code-behind can still be used to handle simple UI-related events or for any logic that is tightly coupled with <span class="No-Break">the View.</span></p>
<p>In fact, there are scenarios where putting some code in the code-behind can be more efficient and maintainable than trying to move everything to the ViewModel. For example, handling UI animations, scrolling, and controlling focus or complex visual behaviors may be easier to implement in the code-behind rather than trying to do it through <span class="No-Break">data binding.</span></p>
<p>To ensure proper separation of concerns in MVVM, it is imperative to avoid including business logic in the code-behind of the View. The code-behind should be kept to a minimum and remain as simple as possible to maintain the separation between the View and <span class="No-Break">the ViewModel.</span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>The Model should exclusively be a DTO, a domain entity, or a POCO</h2>
<p>Although the type of object used for the Model in MVVM has been a topic of debate, in my opinion, it is not a critical factor. The main principle of MVVM is to keep the business logic out of the View and only have simple validation logic in the ViewModel. Thus, the Model can be any object type and is often a combination of different types of objects. The Model isn’t a single type of thing; it is everything ‘outside’ the View and ViewModel that contains the application’s entities, business logic, repositories, and so on. The important thing to remember is that the View and ViewModel should not contain any business or <span class="No-Break">persistence logic.</span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>The View and the ViewModel should not know each other</h2>
<p>While the ViewModel should not have any knowledge of the View in order to maintain separation of concerns, the View can have a reference to the ViewModel. It is important to note that this does not violate the principles of MVVM, as long as the ViewModel is not dependent on the <a id="_idIndexMarker069"/>View. The use of ‘compiled bindings’ in platforms such as .NET MAUI can provide significant performance improvements, but in order for them to work, the View must have knowledge of the type it is <span class="No-Break">binding to.</span></p>
<p class="callout-heading">More about compiled bindings</p>
<p class="callout">Curious to find out more <a id="_idIndexMarker070"/>about compiled bindings? <a href="B20941_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><em class="italic">, Data Binding in .NET MAUI</em>, has got <span class="No-Break">you covered.</span></p>
<p>Also, there may be some situations where it’s necessary for the View to directly invoke a method on the ViewModel from the code-behind. This can be necessary in cases where the UI is very complex, and the Command can’t be <span class="No-Break">easily bound.</span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>MVVM is too complex and used only for large applications</h2>
<p>MVVM itself is not necessarily complex, but it may require some learning and practice to become proficient with it. Understanding the concept of the separation of concerns and implementing it in MVVM can be a bit challenging for developers who are not used to working with this design pattern. Additionally, getting the bindings right can require some effort, especially when working with large and complex Views. However, once you understand it, you will notice that the development process becomes simpler and the code becomes more maintainable and testable. Even though there might be a learning curve, it is worthwhile to adopt MVVM in application development, even for small and simple applications. These kinds of apps need to be maintained and updated over time. In the course of time, their business logic would also benefit from unit <span class="No-Break">testing, right?</span></p>
<p>That said, MVVM might be overkill for applications that have a very minimal UI, with only a handful of UI elements and little to no business logic being reflected on the UI. But then again, looking<a id="_idIndexMarker071"/> at the previous sample that only had two UI controls, we noticed that it benefited from being testable through applying the MVVM <span class="No-Break">design pattern.</span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Summary</h1>
<p>To summarize, the MVVM pattern separates the concerns of data, UI, and logic, which makes the application easier to test, modify, and extend. By using the Model to represent the data and business logic, the View to present the data to the user, and the ViewModel to mediate between the Model and the View, the MVVM pattern promotes a clear separation of responsibilities that makes it easier to develop and maintain complex applications. Additionally, the use of Commands and data binding provides a powerful way to handle user input and keep the UI in sync with the application’s state. Understanding the components of MVVM is crucial for building successful .NET MAUI applications that are maintainable, scalable, and easy <span class="No-Break">to test.</span></p>
<p>In <a href="B20941_02.xhtml#_idTextAnchor036"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><em class="italic">, What Is .NET MAUI?</em>, we’ll dive into .NET MAUI so that you have a good understanding of this framework. If you already have a thorough knowledge of .NET MAUI, you can skip this chapter. If you know the basics of it, it should be a <span class="No-Break">good refresher.</span></p>
</div>
</div></body></html>