<html><head></head><body>
<div id="sbo-rt-content"><div>
<div class="Content" id="_idContainer197">
</div>
</div>
<div class="Content" id="_idContainer198">
<h1 id="_idParaDest-312"><a id="_idTextAnchor350"/>9. Creating API Services</h1>
</div>
<div class="Content" id="_idContainer254">
<p class="callout-heading">Overview</p>
<p class="callout">In modern software development, most logic is served through distinct web services. This is essential to be able to both call and make new web services as a developer. </p>
<p class="callout">In this chapter, you will be creating your own RESTful web service using the ASP.NET Core Web API template. You will learn not only how to do it but also some of the best practices for designing and building a Web API. You will also learn how to protect an API using Azure Active Directory (AAD), centralize error handling, troubleshoot errors, generate documentation, and more.</p>
<p class="callout">By the end of this chapter, you will be able to create professional Web APIs that are secured with AAD, hosted on the cloud, scalable, and able to serve thousands of users.</p>
<h1 id="_idParaDest-313"><a id="_idTextAnchor351"/>Introduction</h1>
<p>ASP.NET Core is a part of the .NET Core framework that is targeted at creating web apps. Using it, you can create both frontend (such as Razor or Blazor) and backend (such as Web API or gRPC) applications. However, in this chapter, you will be focusing on creating RESTful Web APIs. Creating a new web service for the first time might sound like a daunting task, but don't worry too much; for most scenarios, there is a template to get you started. In this chapter, you will create a few Web APIs using ASP.NET Core 6.0.</p>
<h1 id="_idParaDest-314"><a id="_idTextAnchor352"/>ASP.NET Core Web API</h1>
<p>In <em class="italic">Chapter 8</em>, <em class="italic">Creating and Using Web API Clients</em>, you learned how to call RESTful APIs. In this chapter, you will be making one. Web API is a template for creating RESTful Web APIs in .NET. It contains routing, Dependency Injection (DI), an example controller, logging, and other useful components to get you started.</p>
<h2 id="_idParaDest-315"><a id="_idTextAnchor353"/>Creating a New Project</h2>
<p>In order to create a new Web API, follow these steps:</p>
<ol>
<li>Create a new directory.</li>
<li>Name it after a project you want to create.</li>
<li>Navigate to that directory using the <strong class="source-inline">cd</strong> command.</li>
<li>Execute the following at the command line:<p class="source-code">dotnet new webapi</p></li>
</ol>
<p>That is all it takes to get started.</p>
<ol>
<li value="5">To see whether this is executing as expected, run the following and see your application come to life (<em class="italic">Figure 9.1</em>):<p class="source-code">dotnet run --urls=https://localhost:7021/</p><div class="IMG---Figure" id="_idContainer199"><img alt="Figure 9.1: Terminal window showing the port the application is hosted on " height="147" src="image/B16835_09_01.jpg" width="1199"/></div></li>
</ol>
<p> </p>
<p class="figure-caption">Figure 9.1: Terminal window showing the port the application is hosted on</p>
<p>In <em class="italic">Figure 9.1</em>, you will see port 7021 for the <strong class="source-inline">https</strong> version of the application. There may be multiple ports, especially if you are hosting both <strong class="source-inline">HTTP</strong> and <strong class="source-inline">HTTPs</strong> versions of an application. However, the key thing to remember is that you can the port where an application runs (for example, through the command line).</p>
<p>A port is a channel through which you allow a certain application to be called by all other applications. It is a number that appears after a base URL and it allows a single application through. Those applications don't have to be outsiders; the same rules also apply to internal communication.</p>
<p>Localhost refers to an application hosted locally. Later in this chapter, you will configure the service to bind to whatever port you want.</p>
<p class="callout-heading">Note</p>
<p class="callout">There are 65,535 ports available on a single machine. Ports zero through 1023 are called well-known ports because usually, the same parts of the system listen on them. Typically, if a single application is hosted on one machine, the port will be 80 for <strong class="source-inline">http</strong> and 443 for <strong class="source-inline">https</strong>. If you are hosting multiple applications, the ports will vary drastically (usually starting from port 1024).</p>
<h3 id="_idParaDest-316"><a id="_idTextAnchor354"/>Web API Project Structure</h3>
<p>Every Web API is made of at least two classes—<strong class="source-inline">Program</strong> and one or more controllers (<strong class="source-inline">WeatherForecastController</strong> in this case):</p>
<ul>
<li>Program: This is the <strong class="bold">starting point</strong> of an application. It serves as a low-level runner of an application and manages dependencies.</li>
<li>Controller: This is a <strong class="bold">REST API endpoint</strong> in .NET. It usually follows a pattern of <strong class="source-inline">[Model]Controller</strong>. In this example case, <strong class="source-inline">WeatherForecastController</strong> will be called using a <strong class="source-inline">/weatherforecast</strong> endpoint.</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer200">
<img alt="Figure 9.2: The newly created MyProject structure in VS Code with key parts highlighted " height="507" src="image/B16835_09_02.jpg" width="1255"/>
</div>
</div>
<p class="figure-caption">Figure 9.2: The newly created MyProject structure in VS Code with key parts highlighted</p>
<h3 id="_idParaDest-317"><a id="_idTextAnchor355"/>An In-Depth Look at WeatherForecastController</h3>
<p>The controller from the default template is preceded by two attributes:</p>
<ul>
<li><strong class="source-inline">[ApiController]</strong>: This attribute adds common, convenient (yet opinionated) Web API functionality.</li>
<li><strong class="source-inline">[Route("[controller]")]</strong>: This attribute is used to provide a routing pattern of a given controller.</li>
</ul>
<p>For example, in cases where these attributes are absent or the request is complex, you would need to validate an incoming HTTP request yourself without routing out of the box:</p>
<p class="source-code">[ApiController]</p>
<p class="source-code">[Route("[controller]")]</p>
<p class="source-code">public class WeatherForecastController : ControllerBase</p>
<p class="source-code">{</p>
<p>This controller has <strong class="source-inline">/WeatherForecast</strong> as the route. The route is usually made of the word that precedes the word <strong class="source-inline">Controller</strong> unless specified otherwise. When developing APIs professionally, or when you have a client- and server-side application, it is recommended to preappend <strong class="source-inline">/api</strong> to the route, making it <strong class="source-inline">[Route("api/[controller]")]</strong>.</p>
<p>Next, you'll learn about the controller class declaration. Common controller functions come from a derived <strong class="source-inline">ControllerBase</strong> class and a few components (usually a logger) and services. The only interesting bit here is that, instead of <strong class="source-inline">Ilogger</strong>, you use <strong class="source-inline">ILogger&lt;WeatherForecastController&gt;</strong>:</p>
<p class="source-code">    private readonly ILogger&lt;WeatherForecastController&gt; _logger;</p>
<p class="source-code">    public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger)</p>
<p class="source-code">    {</p>
<p class="source-code">        _logger = logger;</p>
<p class="source-code">    }</p>
<p>The reason behind using the generic part is solely for getting the context from the place where the log was called. Using a generic version of a logger, you use a fully qualified name of a class that is supplied as a generic argument. Calling <strong class="source-inline">logger.Log</strong> will prefix it with a context; in this case, it will be <strong class="source-inline">Chapter09.Service.Controllers.WeatherForecastController[0]</strong>.</p>
<p>Lastly, look at the following controller method:</p>
<p class="source-code">    [HttpGet]</p>
<p class="source-code">    public IEnumerable&lt;WeatherForecast&gt; Get()</p>
<p class="source-code">    {</p>
<p class="source-code">        return new List&lt;WeatherForecast&gt;(){new WeatherForecast()};</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>The <strong class="source-inline">[HttpGet]</strong> attribute binds the <strong class="source-inline">Get</strong> method with the root controller endpoint's (<strong class="source-inline">/WeatherForecast</strong>) HTTP GET method. There is a version of that attribute for every HTTP method, and they are <strong class="source-inline">HttpGet</strong>, <strong class="source-inline">HttpPost</strong>, <strong class="source-inline">HttpPatch</strong>, <strong class="source-inline">HttpPut</strong>, and <strong class="source-inline">HttpDelete</strong>. To check whether the service works, run the application using the following command:</p>
<p class="source-code">dotnet run --urls=https://localhost:7021/</p>
<p>Here, the <strong class="source-inline">-urls=https://localhost:7021/</strong> argument is not a requirement. This argument simply makes sure that the port picked by .NET is the same as is indicated in this example during execution.</p>
<p>To see the output, navigate to <strong class="source-inline">https://localhost:7021/weatherforecast/</strong> in the browser. This will return a single default <strong class="source-inline">WeatherForecast</strong> upon calling HTTP GET:</p>
<p><strong class="source-inline">[{"date":"0001-01-01T00:00:00","temperatureC":0,"temperatureF":32,"summary":null}].</strong></p>
<p class="callout-heading">Note</p>
<p class="callout">When <strong class="source-inline">https://localhost:7021/weatherforecast/</strong> displays an error message (<strong class="source-inline">localhost refused to connect</strong>), it means that the application is likely running, but on a different port. So, always remember to specify a port as described in the <em class="italic">Creating a New Project</em> section (<em class="italic">Step 5</em>).</p>
<h3 id="_idParaDest-318"><a id="_idTextAnchor356"/>Responding with Different Status Codes</h3>
<p>Find out what status codes can <strong class="source-inline">public IEnumerable&lt;WeatherForecast&gt; Get()</strong> respond with. Using the following steps, you can play around with it and inspect what happens in the browser:</p>
<ol>
<li value="1">Navigate to <strong class="source-inline">https://localhost:7021/weatherforecast/</strong> in the browser.</li>
<li>Click on <strong class="source-inline">More tools</strong>.</li>
<li>Select the <strong class="source-inline">Developer tools</strong> option. Alternatively, you can use the <strong class="source-inline">F12</strong> key to launch the developer tools.</li>
<li>Next, click on the <strong class="source-inline">Network</strong> tab.</li>
<li>Click on the <strong class="source-inline">Headers</strong> tab. You will see that <strong class="source-inline">https://localhost:7021/weatherforecast/</strong> responds with <strong class="source-inline">200</strong> <strong class="source-inline">Status Code</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer201">
<img alt="Figure 9.3: Dev tools Network tab—inspecting response headers of a successful response " height="653" src="image/B16835_09_03.jpg" width="1514"/>
</div>
</div>
<p class="figure-caption">Figure 9.3: Dev tools Network tab—inspecting response headers of a successful response</p>
<ol>
<li value="6">Create a new endpoint called <strong class="source-inline">GetError</strong> that throws an exception if a rare circumstance arises while a program is running:<p class="source-code">        [HttpGet("error")]</p><p class="source-code">        public IEnumerable&lt;WeatherForecast&gt; GetError()</p><p class="source-code">        {</p><p class="source-code">            throw new Exception("Something went wrong");</p><p class="source-code">        }</p></li>
<li>Now, call <strong class="source-inline">https://localhost:7021/weatherforecast/error</strong>. It responds with a status code of <strong class="source-inline">500</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer202">
<img alt="Figure 9.4: Dev tools Network tab—inspecting a response with an exception " height="655" src="image/B16835_09_04.jpg" width="1255"/>
</div>
</div>
<p class="figure-caption">Figure 9.4: Dev tools Network tab—inspecting a response with an exception</p>
<p>What should you do if you want a different status code to be returned? For that, the <strong class="source-inline">BaseController</strong> class contains utility methods for returning any kind of status code you require. For example, if you wanted to explicitly return an OK response, instead of returning a value right away, you could return <strong class="source-inline">Ok(value)</strong>. However, if you try changing the code, you will get the following error:</p>
<p class="source-code">Cannot implicitly convert type 'Microsoft.AspNetCore.Mvc.OkObjectResult' to 'Chapter09.Service.Models.WeatherForecast'</p>
<p>This does not work because you do not return an HTTP status code from a controller; you either return some value or throw some error. To return any status code of your choice, you need to change the return type. For that reason, a controller should never have a return type of some value. It should always return the <strong class="source-inline">IActionResult</strong> type—a type that supports all status codes.</p>
<p>Create one more method for getting the weather for any day of the week. If the day is not found (a value less than <strong class="source-inline">1</strong> or more than <strong class="source-inline">7</strong>), you will explicitly return <strong class="source-inline">404 – not found</strong>:</p>
<p class="source-code">[HttpGet("weekday/{day}")]</p>
<p class="source-code">public IActionResult GetWeekday(int day)</p>
<p class="source-code">{</p>
<p class="source-code">    if (day &lt; 1 || day &gt; 7)</p>
<p class="source-code">    {</p>
<p class="source-code">        return NotFound($"'{day}' is not a valid day of a week.");</p>
<p class="source-code">    }</p>
<p class="source-code">    return Ok(new WeatherForecast());</p>
<p class="source-code">}</p>
<p>Here, you added one new <strong class="source-inline">{day}</strong> at the end of the endpoint. This is a placeholder value, which comes from a matching function argument (in this case, <strong class="source-inline">day</strong>). Rerunning the service and navigating to <strong class="source-inline">https://localhost:7021/weatherforecast/weekday/8</strong> will result in a <strong class="source-inline">404 – not found</strong> status code because it is more than the max allowed day value, which is <strong class="source-inline">7</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer203">
<img alt="Figure 9.5: The response to finding a weather forecast for a non-existent day of the week " height="658" src="image/B16835_09_05.jpg" width="1142"/>
</div>
</div>
<p class="figure-caption">Figure 9.5: The response to finding a weather forecast for a non-existent day of the week</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/SCudR">https://packt.link/SCudR</a>.</p>
<p>This concludes the theoretical portion of this topic. In the following section, you will put this into practice with an exercise.</p>
<h2 id="_idParaDest-319"><a id="_idTextAnchor357"/>Exercise 9.01: .NET Core Current Time Service</h2>
<p>Once you have managed to run a Web API once, adding new controllers should be trivial. Often, whether a service is running or not, it is checked using the most basic logic; whether it is returning OK or getting the current <strong class="source-inline">DateTime</strong> value. In this exercise, you will create a simple current time service returning the current time in ISO standard. Perform the following steps to do so:</p>
<ol>
<li value="1">Create a new controller called <strong class="source-inline">TimeController</strong> to get the local time and further add functions for testing purposes:<p class="source-code">    [ApiController]</p><p class="source-code">    [Route("[controller]")]</p><p class="source-code">    public class TimeController : ControllerBase</p><p class="source-code">    {</p></li>
</ol>
<p>The controller shown here isn't just for testing; it acts as business logic too.</p>
<ol>
<li value="2">Add an endpoint for HTTP GET called <strong class="source-inline">GetCurrentTime</strong> that points to the <strong class="source-inline">time/current</strong> route. You will use it to get the current time:<p class="source-code">        [HttpGet("current")]</p><p class="source-code">        public IActionResult GetCurrentTime()</p><p class="source-code">        {</p></li>
<li>Return the current <strong class="source-inline">DateTime</strong> converted to a string in ISO format:<p class="source-code">            return Ok(DateTime.Now.ToString("o"));</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
<li>Navigate to <strong class="source-inline">https://localhost:7021/time/current</strong> and you should see the following response:<p class="source-code">2022-07-30T15:06:28.4924356+03:00</p></li>
</ol>
<p>As mentioned in the <em class="italic">Web API Project Structure</em> section, you can use the endpoint to determine whether a service is running or not. If it is running, then you will get the <strong class="source-inline">DateTime</strong> value, which you saw in the preceding output. If it is not running, then you would get a response with a status code of <strong class="source-inline">404 – not found</strong>. If it is running but with problems, then you would get the <strong class="source-inline">500</strong> status code.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/OzaTd">https://packt.link/OzaTd</a>.</p>
<p>So far, all your focus was on a controller. It's time you shift your attention to another crucial part of a Web API—the <strong class="source-inline">Program</strong> class.</p>
<h2 id="_idParaDest-320"><a id="_idTextAnchor358"/>Bootstrapping a Web API</h2>
<p>The <strong class="source-inline">Program</strong> class wires up the whole API together. In layman's terms, you register the implementations for all the abstractions used by controllers and add all the necessary middleware.</p>
<h3 id="_idParaDest-321"><a id="_idTextAnchor359"/>Dependency Injection</h3>
<p>In <em class="italic">Chapter 2</em>, <em class="italic">Building Quality Object-Oriented Code</em>, you explored the concept of DI. In <em class="italic">Chapter 7</em>, <em class="italic">Creating Modern Web Applications with ASP.NET</em>, you had a look at an example of DI for logging services. In this chapter, you will get hands-on experience in DI and the Inversion of Control (IoC) container—a component used to wire up and resolve all the dependencies in a central place. In .NET Core and later, the default container is <strong class="source-inline">Microsoft.Extensions.DependencyInjection</strong>. You will learn more about that a bit later.</p>
<h3 id="_idParaDest-322"><a id="_idTextAnchor360"/>Program.cs and Minimal API</h3>
<p>The simplest Web API in .NET 6 looks like this:</p>
<p class="source-code">// In<a id="_idTextAnchor361"/>ject dependencies (DI)</p>
<p class="source-code">var builder = WebApplication.CreateBuilder(args);</p>
<p class="source-code">builder.Services.AddControllers();</p>
<p class="source-code">// Add middleware</p>
<p class="source-code">var app = builder.Build();</p>
<p class="source-code">if (builder.Environment.IsDevelopment())</p>
<p class="source-code">{</p>
<p class="source-code">    app.UseDeveloperExceptionPage();</p>
<p class="source-code">}</p>
<p class="source-code">app.MapControllers();</p>
<p class="source-code">app.Run();</p>
<p>This is a minimal API because it makes use of the top-level statements feature. Prior to .NET 6, you would have two methods within a <strong class="source-inline">Startup</strong> class (<strong class="source-inline">Configure</strong> and <strong class="source-inline">ConfigureService</strong>) and a <strong class="source-inline">Program</strong> class. Now you have a single file, <strong class="source-inline">Program.cs</strong>, and no classes or methods. You can still use the old way of starting an application. In fact, .NET 6 will generate similar classes under the hood. However, if you are making a new app in .NET 6, then using a minimal API should be preferred.</p>
<p>Break down the preceding code snippet. To start the application, you first need to build it. So, you will create a builder using the following line of code:</p>
<p class="source-code">var builder = WebApplication.CreateBuilder(args);</p>
<p><strong class="source-inline">builder.Services</strong> specifies which services are to be injected. In this case, you registered the implementation of the controllers. So, here you have just one controller calling—that is, <strong class="source-inline">WeatherForecastController</strong>:</p>
<p class="source-code">builder.Services.AddControllers();</p>
<p>When you use <strong class="source-inline">builder.Build()</strong>, you can access the <strong class="source-inline">app</strong> object and further configure the application by adding middleware. For example, to add controller routing, call the following:</p>
<p class="source-code">app.MapControllers();</p>
<p>Lastly, <strong class="source-inline">builder.Environment.IsDevelopment()</strong> checks whether the environment is developed. If it is developed, it calls <strong class="source-inline">app.UseDeveloperExceptionPage();</strong>, which adds detailed errors when something fails.</p>
<p>Logging is not mentioned anywhere; yet you still use it. A common pattern is to group all the related injections under the same extension method for <strong class="source-inline">IServiceCollection</strong>. An example of an extension method for all the controller-related functionality, including logging, is the <strong class="source-inline">AddControllers</strong> method.</p>
<p>You already saw the logging messages sent through the console logger right after you ran the API. Under the hood, the <strong class="source-inline">builder.Services.AddLogging</strong> method is called. This method clears all the logging providers:</p>
<p class="source-code">builder.Services.AddLogging(builder =&gt;</p>
<p class="source-code">{</p>
<p class="source-code">    builder.ClearProviders();</p>
<p class="source-code">});</p>
<p>If you run the application now, you will not see anything appear in the console (<em class="italic">Figure 9.6</em>):</p>
<div>
<div class="IMG---Figure" id="_idContainer204">
<img alt="Figure 9.6: Running an application with no logs displayed " height="111" src="image/B16835_09_06.jpg" width="1424"/>
</div>
</div>
<p class="figure-caption">Figure 9.6: Running an application with no logs displayed</p>
<p>However, if you modify <strong class="source-inline">AddLogging</strong> to include <strong class="source-inline">Console</strong> and <strong class="source-inline">Debug</strong> logging in the following way, you will see the logs as in <em class="italic">Figure 9.7</em>:</p>
<p class="source-code">builde<a id="_idTextAnchor362"/>r.Services.AddLogging(builder =&gt;</p>
<p class="source-code">{</p>
<p class="source-code">    builder.ClearProviders();</p>
<p class="source-code">    builder.AddConsole();</p>
<p class="source-code">    builder.AddDebug();</p>
<p class="source-code">});</p>
<p>Now, add an error logging functionality to the error endpoint of <strong class="source-inline">WeatherForecastController</strong>. This will throw an exception when a rare circumstance arises while a program is running:</p>
<p class="source-code">[HttpGet("error")]</p>
<p class="source-code">public IEnumerable&lt;WeatherForecast&gt; GetError()</p>
<p class="source-code">{</p>
<p class="source-code">    _logger.LogError("Whoops");</p>
<p class="source-code">    throw new Exception("Something went wrong");</p>
<p class="source-code">}</p>
<p>Restart the API with the following command:</p>
<p class="source-code">dotnet run --urls=https://localhost:7021/</p>
<p>Now, call <strong class="source-inline">https://localhost:7021/weatherforecast/error</strong> and this will show the logged message (compare <em class="italic">Figure 9.6</em> and <em class="italic">Figure 9.7</em>):</p>
<div>
<div class="IMG---Figure" id="_idContainer205">
<img alt="Figure 9.7: The error message, Whoops, displayed on the terminal " height="274" src="image/B16835_09_07.jpg" width="1591"/>
</div>
</div>
<p class="figure-caption">Figure 9.7: The error message, Whoops, displayed on the terminal</p>
<h2 id="_idParaDest-323"><a id="_idTextAnchor363"/>The Inner Workings of the AddLogging Method</h2>
<p>How does the <strong class="source-inline">AddLogging</strong> method work? The decompiled code of the <strong class="source-inline">AddLogging</strong> method looks like this:</p>
<p class="source-code">services.AddSingleton&lt;ILoggerFactory, LoggerFactory&gt;();</p>
<p>It is best practice not to initialize loggers by yourself. <strong class="source-inline">ILoggerFactory</strong> provides that functionality as a single place from which you may create loggers. While <strong class="source-inline">ILoggerFactory</strong> is an interface, <strong class="source-inline">LoggerFactory</strong> is an implementation of that interface. <strong class="source-inline">AddSingleton</strong> is a method that specifies that a single instance of <strong class="source-inline">LoggerFactory</strong> will be created and used whenever <strong class="source-inline">ILoggerFactory</strong> is referenced.</p>
<p>Now the question arises: why wasn't <strong class="source-inline">ILoggerFactory</strong> used in a controller? <strong class="source-inline">ILoggerFactory</strong> is used under the hood when resolving an implementation of a controller. When exposing a controller dependency such as a <strong class="source-inline">logger</strong>, you no longer need to care about how it gets initialized. This is a great benefit because it makes the class holding a dependency both more simple and more flexible.</p>
<p>If you do want to use <strong class="source-inline">ILoggerFactory</strong> instead of <strong class="source-inline">Ilogger</strong>, you could have a constructor accepting the factory, as follows:</p>
<p class="source-code">public WeatherForecastController(ILoggerFactory logger)</p>
<p>You can then use it to create a <strong class="source-inline">logger</strong>, as follows:</p>
<p class="source-code">_logger = logger.CreateLogger(typeof(WeatherForecastController).FullName);</p>
<p>This latter <strong class="source-inline">logger</strong> functions the same as the former.</p>
<p>This section dealt with the <strong class="source-inline">AddSingleton</strong> method for managing service dependencies in a central place. Proceed to the next section to solve dependency complexities with DI.</p>
<h3 id="_idParaDest-324"><a id="_idTextAnchor364"/>The Lifetime of an Injected Component</h3>
<p>The <strong class="source-inline">AddSingleton</strong> method is useful because complex applications have hundreds, if not thousands, of dependencies often shared across different components. It would be quite a challenge to manage the initialization of each. DI solves that problem by providing a central place for managing dependencies and their lifetimes. Before proceeding further, you'll need to learn more about DI lifetimes.</p>
<p>There are three injected object lifetimes in .NET:</p>
<ul>
<li>Singleton: Object initialized once per application lifetime</li>
<li>Scoped: Object initialized once per request</li>
<li>Transient: Object initialized every time it is referenced</li>
</ul>
<p>To better illustrate DI and different service lifetimes, the next section will refactor the existing <strong class="source-inline">WeatherForecastController</strong> code.</p>
<h2 id="_idParaDest-325"><a id="_idTextAnchor365"/>DI Examples within a Service</h2>
<p>A service is a holder for logic at the highest level. By itself, a controller should not do any business logic and just delegate a request to some other object that is able to handle it. Apply this principle and refactor the <strong class="source-inline">GetWeekday</strong> method using DI.</p>
<p>First, create an interface for the service to which you will move all the logic. This is done to create an abstraction for which you will later provide an implementation. An abstraction is needed because you want to move out as much logic as possible from the controller into other components:</p>
<p class="source-code">public interface IWeatherForecastService</p>
<p class="source-code">{</p>
<p class="source-code">    WeatherForecast GetWeekday(int day);</p>
<p class="source-code">}</p>
<p>As you move a portion away from a controller, you would like to handle error scenarios as well. In this case, if a provided day is not between <strong class="source-inline">1</strong> and <strong class="source-inline">7</strong>, you will return a <strong class="source-inline">404 – not found</strong> error. However, at the service level, there is no concept of HTTP status codes. Therefore, instead of returning an HTTP message, you will be throwing an exception. For the exception to be handled properly, you will create a custom exception called <strong class="source-inline">NoSuchWeekdayException</strong>:</p>
<p class="source-code">public class NoSuchWeekdayException : Exception</p>
<p class="source-code">{</p>
<p class="source-code">    public NoSuchWeekdayException(int day) </p>
<p class="source-code">        : base($"'{day}' is not a valid day of a week.") { }</p>
<p class="source-code">}</p>
<p>Next, create a class that implements the service. You will move your code here:</p>
<p class="source-code">public class WeatherForecastService : IWeatherForecastService</p>
<p class="source-code">{</p>
<p class="source-code">    public WeatherForecast GetWeekday(int day)</p>
<p class="source-code">    {</p>
<p class="source-code">        if (day &lt; 1 || day &gt; 7)</p>
<p class="source-code">        {</p>
<p class="source-code">            throw new NoSuchWeekdayException(day);</p>
<p class="source-code">        }</p>
<p class="source-code">        return new WeatherForecast();</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>The only difference here as compared to the previous code is that, instead of returning <strong class="source-inline">NotFound</strong>, you have used <strong class="source-inline">throw new NoSuchWeekdayException</strong>.</p>
<p>Now, inject the service into a controller:</p>
<p class="source-code">private readonly IWeatherForecastService _weatherForecastService;</p>
<p class="source-code">private readonly Ilogger _logger;</p>
<p class="source-code">public WeatherForecastController(IloggerFactory logger, IWeatherForecastService weatherForecastService)</p>
<p class="source-code">{</p>
<p class="source-code">    _weatherForecastService = weatherForecastService;</p>
<p class="source-code">    _logger = logger.CreateLogger(typeof(WeatherForecastController).FullName);</p>
<p class="source-code">}</p>
<p>The cleaned-up controller method, in the <em class="italic">Responding with Different Status Codes</em> section, with minimum business logic, now looks like this:</p>
<p class="source-code">[HttpGe<a id="_idTextAnchor366"/>t("weekday/{day}")]</p>
<p class="source-code">public IActionResult GetWeekday(int day)</p>
<p class="source-code">{</p>
<p class="source-code">    try<a id="_idTextAnchor367"/></p>
<p class="source-code">    {</p>
<p class="source-code">        var result = _weatherForecastService.GetWeekday(day);</p>
<p class="source-code">        return Ok(result);</p>
<p class="source-code">    }</p>
<p class="source-code">    catch(NoSuchWeekdayException exception)</p>
<p class="source-code">    {</p>
<p class="source-code">        return NotFound(exception.Message);</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>It might still seem like the same code; however, the key point here is that the controller no longer does any business logic. It simply maps results from the service back to an HTTP response.</p>
<p class="callout-heading">Note</p>
<p class="callout">In the <em class="italic">Error Handling</em> section, you will return to this and further remove code from the controller, making it as light as possible.</p>
<p>If you run this code, you would get the following exception when calling any of the controller's endpoints:</p>
<p class="source-code">Unable to resolve service for type 'Chapter09.Service.Examples.TemplateApi.Services.IweatherForecastService' while attempting to activate 'Chapter09.Service.Examples.TemplateApi.Controllers.WeatherForecastController'</p>
<p>This exception shows that there is no way that <strong class="source-inline">WeatherForecastController</strong> can figure out the implementation for <strong class="source-inline">IWeatherForecastService</strong>. So, you need to specify which implementation fits the needed abstraction. For example, this is done inside the <strong class="source-inline">Program</strong> class as follows:</p>
<p class="source-code">builder.Services.AddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;();</p>
<p>The <strong class="source-inline">AddSingleton</strong> method reads this as for the <strong class="bold">abstraction</strong> of <strong class="source-inline">IWeatherForecastService</strong>, <strong class="bold">register</strong> the<strong class="bold"> </strong><strong class="source-inline">WeatherForecastService</strong> <strong class="bold">implementation</strong>. In the following paragraphs, you will learn how exactly it works.</p>
<p>Now that you have a service to be injected, you can explore what effect each injection has on service calls when calling the following controller method. For that point, you will slightly modify <strong class="source-inline">WeatherForecastService</strong> and <strong class="source-inline">WeatherForecastController</strong>.</p>
<p>Within <strong class="source-inline">WeatherForecastService</strong>, do the following:</p>
<ol>
<li value="1">Inject a <strong class="source-inline">logger</strong>:<p class="source-code">        private readonly ILogger&lt;WeatherForecastService&gt; _logger;</p><p class="source-code">        public WeatherForecastService(ILogger&lt;WeatherForecastService&gt; logger)</p><p class="source-code">        {</p><p class="source-code">            _logger = logger;</p><p class="source-code">        }</p></li>
<li>When the service is initialized, log a random <strong class="source-inline">Guid</strong> that changes the constructor to look like this:<p class="source-code">        public WeatherForecastService(ILogger&lt;WeatherForecastService&gt; logger)</p><p class="source-code">        {</p><p class="source-code">            _logger = logger;</p><p class="source-code">            _logger.LogInformation(Guid.NewGuid().ToString());</p><p class="source-code">        }</p></li>
</ol>
<p>Within <strong class="source-inline">WeatherForecastController</strong>, do the following:</p>
<ol>
<li value="1">Inject the second instance of <strong class="source-inline">WeatherForecastService</strong>:<p class="source-code">    public class WeatherForecastController : ControllerBase</p><p class="source-code">    {</p><p class="source-code">        private readonly IWeatherForecastService _weatherForecastService1;</p><p class="source-code">        private readonly IWeatherForecastService _weatherForecastService2;</p><p class="source-code">        private readonly ILogger _logger;</p><p class="source-code">        public WeatherForecastController(ILoggerFactory logger, IWeatherForecastService weatherForecastService1, IWeatherForecastService weatherForecastService2)</p><p class="source-code">        {</p><p class="source-code">            _weatherForecastService1 = weatherForecastService1;</p><p class="source-code">            _weatherForecastService2 = weatherForecastService2;</p><p class="source-code">            _logger = logger.CreateLogger(typeof(WeatherForecastController).FullName);</p><p class="source-code">        }</p></li>
<li>Call both instances when getting a weekday:<p class="source-code">        [HttpGet("weekday/{day}")]</p><p class="source-code">        public IActionResult GetWeekday(int day)</p><p class="source-code">        {</p><p class="source-code">            try</p><p class="source-code">            {</p><p class="source-code">                var result = _weatherForecastService1.GetWeekday(day);</p><p class="source-code">                result = _weatherForecastService1.GetWeekday(day);</p><p class="source-code">                return Ok(result);</p><p class="source-code">            }</p><p class="source-code">            catch (NoSuchWeekdayException exception)</p><p class="source-code">            {</p><p class="source-code">                return NotFound(exception.Message);</p><p class="source-code">            }</p><p class="source-code">        }</p></li>
</ol>
<p>The <strong class="source-inline">GetWeekday</strong> method is called twice because it will help illustrate DI lifetimes better. Now it is time to explore different DI lifetimes.</p>
<h2 id="_idParaDest-326"><a id="_idTextAnchor368"/>Singleton</h2>
<p>Register the service as a singleton in <strong class="source-inline">Program.cs</strong> in the following way:</p>
<p class="source-code">builder.Services.AddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;();</p>
<p>After calling the application, you will see the following logs generated while running the code:</p>
<p class="source-code">info: Chapter09.Service.Services.WeatherForecastService[0]</p>
<p class="source-code">      2b0c4e0c-97ff-4472-862a-b6326992d9a6</p>
<p class="source-code">info: Chapter09.Service.Services.WeatherForecastService[0]</p>
<p class="source-code">      2b0c4e0c-97ff-4472-862a-b6326992d9a6</p>
<p>If you call the application again, you will see the same GUID logged:</p>
<p class="source-code">info: Chapter09.Service.Services.WeatherForecastService[0]</p>
<p class="source-code">      2b0c4e0c-97ff-4472-862a-b6326992d9a6</p>
<p class="source-code">info: Chapter09.Service.Services.WeatherForecastService[0]</p>
<p class="source-code">      2b0c4e0c-97ff-4472-862a-b6326992d9a6</p>
<p>This proves that the service was initialized only once.</p>
<h2 id="_idParaDest-327"><a id="_idTextAnchor369"/>Scoped</h2>
<p>Register the service as scoped in <strong class="source-inline">Program.cs</strong> in the following way:</p>
<p class="source-code">builder.Services.AddScoped&lt;IWeatherForecastService, WeatherForecastService&gt;();</p>
<p>After calling the application, you will see the following logs generated while running the code:</p>
<p class="source-code">info: Chapter09.Service.Services.WeatherForecastService[0]</p>
<p class="source-code">      921a29e8-8f39-4651-9ffa-2e83d2289f29</p>
<p class="source-code">info: Chapter09.Service.Services.WeatherForecastService[0]</p>
<p class="source-code">      921a29e8-8f39-4651-9ffa-2e83d2289f29</p>
<p>On calling <strong class="source-inline">WeatherForecastService</strong> again, you will see the following:</p>
<p class="source-code">info: Chapter09.Service.Services.WeatherForecastService[0]</p>
<p class="source-code">      974e082d-1ff5-4727-93dc-fde9f61d3762</p>
<p class="source-code">info: Chapter09.Service.Services.WeatherForecastService[0]</p>
<p class="source-code">      974e082d-1ff5-4727-93dc-fde9f61d3762</p>
<p>This is a different GUID that has been logged. This proves that the service was initialized once per request, but a new instance was initialized on a new request.</p>
<h2 id="_idParaDest-328"><a id="_idTextAnchor370"/>Transient</h2>
<p>Register the service as transient in <strong class="source-inline">Program.cs</strong> in the following way:</p>
<p class="source-code">builder.Services.AddTransient&lt;IWeatherForecastService, WeatherForecastService&gt;();</p>
<p>After calling the application, you should see the following in the logs generated while running the code:</p>
<p class="source-code">info: Chapter09.Service.Services.WeatherForecastService[0]</p>
<p class="source-code">      6335a0aa-f565-4673-a5c4-0590a5d0aead</p>
<p class="source-code">info: Chapter09.Service.Services.WeatherForecastService[0]</p>
<p class="source-code">      4074f4d3-5e50-4748-9d6f-15fb6a782000</p>
<p>That there are two different GUIDs logged proves that both services were initialized using different instances. It is possible to use DI and IoC outside of the Web API. DI through IoC is just another library with a few extras given by the Web API template.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you want to use IoC outside of ASP.NET Core, install the following NuGet (or other IoC container): <strong class="source-inline">Microsoft.Extensions.DependencyInjection</strong>.</p>
<h3 id="_idParaDest-329"><a id="_idTextAnchor371"/>TryAdd</h3>
<p>So far, you have wired implementations to their abstractions using an <strong class="source-inline">Add[Lifetime]</strong> function. However, that is not the best practice in most cases. Usually, you'll want a single implementation to be wired for a single abstraction. However, if you repeatedly call <strong class="source-inline">Add[Lifetime]</strong>, for example, the <strong class="source-inline">AddSingleton</strong> function, you will create a collection of implementing instances (duplicates) underneath. This is rarely the intention and therefore you should protect yourself against that.</p>
<p>The cleanest way to wire dependencies is through the <strong class="source-inline">TryAdd[Lifetime]</strong> method. In the case of a duplicate dependency, it will simply not add a duplicate. To illustrate the difference between the two versions of DIs, compare the injected service counts using different methods. Here, you will inject two identical services as a singleton.</p>
<p>Here you are using the <strong class="source-inline">Add[Lifetime]</strong> service as a singleton:</p>
<p class="source-code">builder.Services.AddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;();</p>
<p class="source-code">Debug.WriteLine("Services count: " + services.Count);</p>
<p class="source-code">builder.services.AddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;();</p>
<p class="source-code">Debug.WriteLine("Services count: " + services.Count);</p>
<p>The command will display the following output:</p>
<p class="source-code">Services count: 156</p>
<p class="source-code">Services count: 157</p>
<p>Here you are using the <strong class="source-inline">TryAdd[Lifetime]</strong> service as a singleton:</p>
<p class="source-code">builder.Services.TryAddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;();</p>
<p class="source-code">Debug.WriteLine("Services count: " + services.Count);</p>
<p class="source-code">builder.Services.TryAddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;();</p>
<p class="source-code">Debug.WriteLine("Services count: " + services.Count);</p>
<p>The command will display the following output:</p>
<p class="source-code">Services count: 156</p>
<p class="source-code">Services count: 156</p>
<p>Observe that <strong class="source-inline">Add[Lifetime]</strong> added a duplicate in the output, while <strong class="source-inline">TryAdd[Lifetime]</strong> did not. Since you don't want duplicate dependencies, it's recommended that you use the <strong class="source-inline">TryAdd[Lifetime]</strong> version.</p>
<p>You can do an injection for a concrete class as well. Calling <strong class="source-inline">builder.Services.AddSingleton&lt;WeatherForecastService, WeatherForecastService&gt;();</strong> is a valid C# code; however, it does not make much sense. DI is used to inject an implementation into an abstraction. This will not work when bootstrapping the service because the following error will be displayed:</p>
<p class="source-code">Unable to resolve a controller</p>
<p>The error occurs because there is still an abstraction-implementation binding to be provided. It would only work if a concrete implementation, rather than an abstraction, were exposed in the constructor of the controller. In practice, this scenario is rarely used.</p>
<p>You have learned that the cleanest way of wiring dependencies is through the <strong class="source-inline">TryAdd[Lifetime]</strong> method. You will now create a service that accepts primitive arguments (<strong class="source-inline">int</strong> and <strong class="source-inline">string</strong>) and see how it manages its non-primitive dependencies in an IoC container.</p>
<h3 id="_idParaDest-330"><a id="_idTextAnchor372"/>Manual Injection Using an IoC Container</h3>
<p>There are scenarios in which you will need to create an instance of a service before injecting it. An example use case could be a service with primitive arguments in a constructor, in other words, a weather forecast service for a specific city with a configured interval for forecast refreshes. So, here, you cannot inject a string or an integer, but you can create a service with an integer and a string and inject that instead.</p>
<p>Modify <strong class="source-inline">WeatherForecastService</strong> with the said features:</p>
<p class="source-code">public <a id="_idTextAnchor373"/>class WeatherForecastServiceV2 : IWeatherForecastService</p>
<p class="source-code">{</p>
<p class="source-code">    pri<a id="_idTextAnchor374"/>vate readonly string _city;</p>
<p class="source-code">    private readonly int _refreshInterval;</p>
<p class="source-code">    public WeatherForecastService(string city, int refreshInterval)</p>
<p class="source-code">    {</p>
<p class="source-code">        _city = city;</p>
<p class="source-code">        _refreshInterval = refreshInterval;</p>
<p class="source-code">    }</p>
<p>Return to the <strong class="source-inline">Program</strong> class and try to inject a service for <strong class="source-inline">New York</strong> with a refresh interval of <strong class="source-inline">5</strong> (hours):</p>
<p class="source-code">builder<a id="_idTextAnchor375"/>.Services.AddSingleton&lt;IWeatherForecastService, WeatherForecastService&gt;(BuildWeatherForecastService);</p>
<p class="source-code">static <a id="_idTextAnchor376"/>WeatherForecastServiceV2 BuildWeatherForecastService(IServiceProvider _)</p>
<p class="source-code">{</p>
<p class="source-code">    return new WeatherForecastServiceV2("New York", 5);</p>
<p class="source-code">}</p>
<p>In order to inject the service, as always, you use a version of the <strong class="source-inline">builder.Services.Add[Lifetime]</strong> method. However, on top of that, you provided an argument—a delegate specifying how a service should be created. The service provider can be accessed by calling the <strong class="source-inline">BuildServices</strong> method on <strong class="source-inline">IServiceCollection</strong>. This delegate takes <strong class="source-inline">IServiceProvider</strong> as input and uses it to build a new service.</p>
<p>In this case, you did not use it and thus named the argument after the discard operator (<strong class="source-inline">_</strong>). The remaining contents of the function are just a simple return with the values from the previous paragraph (for brevity, you will not add any extra logic to use the new values). If you had a more complex service, for example, a service that requires another service, you could call the <strong class="source-inline">.GetService&lt;ServiceType&gt;</strong> method from <strong class="source-inline">IServiceProvider</strong>.</p>
<p><strong class="source-inline">Build</strong> and <strong class="source-inline">Create</strong> are two common method names. However, they should not be used interchangeably. Use <strong class="source-inline">Build</strong> when building a single dedicated object, while <strong class="source-inline">Create</strong> is used when the intention is to produce many objects of diverse types.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/fBFRQ">https://packt.link/fBFRQ</a>.</p>
<h2 id="_idParaDest-331"><a id="_idTextAnchor377"/>Exercise 9.02: Displaying Current Time in a Country API Time Zone</h2>
<p>In this exercise, you are tasked with creating a Web API that provides the date and time at different time zones of UTC. Through a URL, you will pass a number between <strong class="source-inline">-12</strong> and <strong class="source-inline">+12</strong> and return the time in that time zone.</p>
<p>Perform the following steps:</p>
<ol>
<li value="1">Create an interface called <strong class="source-inline">ICurrentTimeProvider</strong> with a method called <strong class="source-inline">DateTime GetTime(string timezone)</strong>:<p class="source-code">public interface ICurrentTimeProvider</p><p class="source-code">{</p><p class="source-code">    DateTime GetTime(string timezoneId);</p><p class="source-code">}</p></li>
<li>Create a class called <strong class="source-inline">CurrentTimeUtcProvider</strong> implementing <strong class="source-inline">ICurrentTimeProvider</strong> to implement the logic required for the application:<p class="source-code">public class CurrentTimeUtcProvider : ICurrentTimeProvider</p><p class="source-code">{</p></li>
<li>Implement the method of converting the current <strong class="source-inline">DateTime</strong> to <strong class="source-inline">Utc</strong> and then offsetting that based on the time zone passed:<p class="source-code">    public DateTime GetTime(string timezoneId)</p><p class="source-code">    {</p><p class="source-code">        var timezoneInfo = TimeZoneInfo.FindSystemTimeZoneById(timezoneId);</p><p class="source-code">        var time = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, timezoneInfo);</p><p class="source-code">        return time;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Create a <strong class="source-inline">CurrentTimeProviderController</strong> controller to make sure it accepts <strong class="source-inline">ICurrentTimeProvider</strong> in the constructor:<p class="source-code">[ApiController]</p><p class="source-code">[Route("[controller]")]</p><p class="source-code">public class CurrentTimeController : ControllerBase</p><p class="source-code">{</p><p class="source-code">    private readonly ICurrentTimeProvider _currentTimeProvider;</p><p class="source-code">    public CurrentTimeController(ICurrentTimeProvider currentTimeProvider)</p><p class="source-code">    {</p><p class="source-code">        _currentTimeProvider = currentTimeProvider;</p><p class="source-code">    }</p></li>
<li>Create an <strong class="source-inline">HttpGet</strong> endpoint called <strong class="source-inline">IActionResult Get(string timezoneId)</strong>, which calls the current time provider and returns the current time:<p class="source-code">    [HttpGet]</p><p class="source-code">    public IActionResult Get(string timezoneId)</p><p class="source-code">    {</p><p class="source-code">        var time = _currentTimeProvider.GetTime(timezoneId);</p><p class="source-code">        return Ok(time);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>Please note that <strong class="source-inline">{timezoneId}</strong> is not specified in the <strong class="source-inline">HttpGet</strong> attribute. This is because the pattern is used for REST parts on an endpoint; however, in this scenario, it is passed as an argument of a query string. If a string contains whitespaces or other special characters, it should be encoded before being passed. You can URL-encode a string using this tool: <a href="https://meyerweb.com/eric/tools/dencoder/">https://meyerweb.com/eric/tools/dencoder/</a>.</p>
<ol>
<li value="6">In the <strong class="source-inline">Program</strong> class, inject the service:<p class="source-code">builder.Services.AddSingleton&lt;ICurrentTimeProvider, CurrentTimeUtcProvider&gt;();</p></li>
</ol>
<p>Here, you injected the service as a singleton because it is stateless.</p>
<ol>
<li value="7">Call the <strong class="source-inline">https://localhost:7021/CurrentTime?timezone=[yourtimezone]</strong> endpoint with a <strong class="source-inline">timezoneid</strong> value of your choice. For example, you can call the following endpoint: <strong class="source-inline">https://localhost:7021/CurrentTime?timezoneid=Central%20Europe%20Standard%20Time</strong>.</li>
</ol>
<p>You will get the response showing the date and time at that time zone:</p>
<p class="source-code">"2021-09-18T20:32:29.1619999"</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/iqGJL">https://packt.link/iqGJL</a>.</p>
<h2 id="_idParaDest-332"><a id="_idTextAnchor378"/>OpenAPI and Swagger</h2>
<p>OpenAPI is a <strong class="bold">REST API</strong> description format. It is a specification of an API with the endpoints it has, the authentication methods it supports, the arguments it accepts, and the example requests and responses it informs. The REST API works with both JSON and XML formats; however, JSON is chosen frequently. Swagger is a collection of tools and libraries implementing the OpenAPI standard. Swagger generates two things:</p>
<ul>
<li>A web page to make calls to your API</li>
<li>Generate client code</li>
</ul>
<p>In .NET, there are two libraries for working with Swagger:</p>
<ul>
<li><strong class="source-inline">NSwag</strong></li>
<li><strong class="source-inline">Swashbuckle</strong></li>
</ul>
<h3 id="_idParaDest-333"><a id="_idTextAnchor379"/>Using Swagger Swashbuckle</h3>
<p>In this section, you will use <strong class="source-inline">Swashbuckle</strong> to demonstrate one of many ways to test APIs and generate API documentation. So, install the <strong class="source-inline">Swashbuckle.AspNetCore</strong> package by running the following command:</p>
<p class="source-code">dotnet add package Swashbuckle.AspNetCore</p>
<p>Just before the <strong class="source-inline">builder.Build()</strong> call, add the following line of code in <strong class="source-inline">Program.cs</strong>:</p>
<p class="source-code">builder.Services.AddSwaggerGen();</p>
<p>This injects the Swagger services needed to generate the Swagger schema and the documentation test page.</p>
<p>After <strong class="source-inline">builder.Build()</strong> in <strong class="source-inline">Program.cs</strong>, add the following:</p>
<p class="source-code">app.UseSwagger();</p>
<p class="source-code">app.UseSwaggerUI(c =&gt; { c.SwaggerEndpoint("/swagger/v1/swagger.json", "My API V1"); }); </p>
<p>The first line supports reaching the OpenAPI Swagger specification and the second one allows accessing the specification on a user-friendly web page.</p>
<p>Now, run the program as follows:</p>
<p class="source-code">dotnet run --urls=https://localhost:7021/</p>
<p>When you navigate to <strong class="source-inline">https://localhost:7021/swagger/</strong>, you will see the following screen:</p>
<div>
<div class="IMG---Figure" id="_idContainer206">
<img alt="Figure 9.8: A user-friendly Swagger endpoint " height="941" src="image/B16835_09_08.jpg" width="1615"/>
</div>
</div>
<p class="figure-caption">Figure 9.8: A user-friendly Swagger endpoint</p>
<p>Clicking on any of the endpoints will allow you to send an HTTP request to them. This page can be configured to include common information about the project, such as the contact information, licenses it is under, description, terms of services, and more.</p>
<p>The benefits of Swagger do not end here. If you had comments, you could include them on this page as well. You could also include all the possible response types that the endpoint produces. You can even include example requests and set them as defaults when calling an API.</p>
<p>Create a new endpoint to save a weather forecast and then another one to retrieve it. Document both the methods one by one. So, first, update the <strong class="source-inline">IWeatherForecastService</strong> interface to include the two new methods, <strong class="source-inline">GetWeekday</strong> and <strong class="source-inline">GetWeatherForecast</strong>, as follows:</p>
<p class="source-code">    public interface IWeatherForecastService</p>
<p class="source-code">    {</p>
<p class="source-code">        WeatherForecast GetWeekday(int day);</p>
<p class="source-code">        void SaveWeatherForecast(WeatherForecast forecast);</p>
<p class="source-code">        WeatherForecast GetWeatherForecast(DateTime date);</p>
<p class="source-code">    }</p>
<p>Next, add implementations of those methods to <strong class="source-inline">WeatherForecastService</strong>. To save the weather forecast, you will need storage, and the simplest storage would be <strong class="source-inline">IMemoryCache</strong>. Here, you will need a new field for <strong class="source-inline">IMemoryCache</strong>:</p>
<p class="source-code">private readonly IMemoryCache _cache;</p>
<p>Now, update the constructor to inject <strong class="source-inline">IMemoryCache</strong>:</p>
<p class="source-code">public WeatherForecastService(ILogger&lt;WeatherForecastService&gt; logger, string city, int refreshInterval, IMemoryCache cache)</p>
<p class="source-code">        {</p>
<p class="source-code">            _logger = logger;</p>
<p class="source-code">            _city = city;</p>
<p class="source-code">            _refreshInterval = refreshInterval;</p>
<p class="source-code">            _serviceIdentifier = Guid.NewGuid();</p>
<p class="source-code">            _cache = cache;</p>
<p class="source-code">        }</p>
<p>Then, create the <strong class="source-inline">SaveWeatherForecast</strong> method to save a weather forecast:</p>
<p class="source-code">        public void SaveWeatherForecast(WeatherForecast forecast)</p>
<p class="source-code">        {</p>
<p class="source-code">            _cache.Set(forecast.Date.ToShortDateString(), forecast);</p>
<p class="source-code">        }</p>
<p>Create a <strong class="source-inline">GetWeatherForecast</strong> method to get a weather forecast:</p>
<p class="source-code">        public WeatherForecast GetWeatherForecast(DateTime date)</p>
<p class="source-code">        {</p>
<p class="source-code">            var shortDateString = date.ToShortDateString();</p>
<p class="source-code">            var contains = _cache.TryGetValue(shortDateString, out var entry);</p>
<p class="source-code">            return !contains ? null : (WeatherForecast) entry;</p>
<p class="source-code">        }</p>
<p>Now, go back to <strong class="source-inline">WeatherForecastController</strong> and create an endpoint for each method so that you can test it using the HTTP requests:</p>
<p class="source-code">        <a id="_idTextAnchor380"/>[HttpGet("{date}")]</p>
<p class="source-code">        public IActionResult GetWeatherForecast(DateTime date)</p>
<p class="source-code">        {</p>
<p class="source-code">            var weatherForecast = _weatherForecastService1.GetWeatherForecast(date);</p>
<p class="source-code">            if (weatherForecast == null) return NotFound();</p>
<p class="source-code">            return Ok(weatherForecast);</p>
<p class="source-code">        }</p>
<p class="source-code">        [HttpPost]</p>
<p class="source-code">        public IActionResult SaveWeatherForecast(WeatherForecast weatherForecast)</p>
<p class="source-code">        {</p>
<p class="source-code">            _weatherForecastService1.SaveWeatherForecast(weatherForecast);</p>
<p class="source-code">            return CreatedAtAction("GetWeatherForecast", new { date = weatherForecast.Date.ToShortDateString()}, weatherForecast);</p>
<p class="source-code">        }</p>
<p>Please note that when creating a new weather forecast, you return a <strong class="source-inline">CreatedAtAction</strong> result. This returns an HTTP status code of <strong class="source-inline">201</strong> with a URI used to get the created resource. It was specified that, in order to get the created forecast later, you can use <strong class="source-inline">GetWeatherForecast</strong>. The anonymous <strong class="source-inline">new { date = weatherForecast.Date.ToShortDateString()}</strong> object specifies the arguments needed to call that action. You passed <strong class="source-inline">Date.ToShortDateString()</strong> and not just a date because a full <strong class="source-inline">DateTime</strong> contains more than what you need. Here, you need only a date; therefore, you explicitly cut what you don't need.</p>
<p>Document each method by describing what it does and what status codes it can return. You will then add this information above each endpoint:</p>
<p class="source-code">        /// &lt;summary&gt;</p>
<p class="source-code">        /// Gets weather forecast at a specified date.</p>
<p class="source-code">        /// &lt;/summary&gt;</p>
<p class="source-code">        /// &lt;param name="date"&gt;Date of a forecast.&lt;/param&gt;</p>
<p class="source-code">        /// &lt;returns&gt;</p>
<p class="source-code">        /// A forecast at a specified date.</p>
<p class="source-code">        /// If not found - 404.</p>
<p class="source-code">        /// &lt;/returns&gt;</p>
<p class="source-code">        [HttpGet("{date}")]</p>
<p class="source-code">        [ProducesResponseType(StatusCodes.Status404NotFound)]</p>
<p class="source-code">        [ProducesResponseType(StatusCodes.Status200OK)]</p>
<p class="source-code">        public IActionResult GetWeatherForecast(DateTime date)</p>
<p class="source-code">        /// &lt;summary&gt;</p>
<p class="source-code">        /// Saves a forecast at forecast date.</p>
<p class="source-code">        /// &lt;/summary&gt;</p>
<p class="source-code">        /// &lt;param name="weatherForecast"&gt;Date which identifies a forecast. Using short date time string for identity.&lt;/param&gt;</p>
<p class="source-code">        /// &lt;returns&gt;201 with a link to an action to fetch a created forecast.&lt;/returns&gt;</p>
<p class="source-code">        [HttpPost]</p>
<p class="source-code">        [ProducesResponseType(StatusCodes.Status201Created)]</p>
<p class="source-code">        public IActionResult SaveWeatherForecast(WeatherForecast weatherForecast)</p>
<p>You have now added XML docs to the two endpoints. Using <strong class="source-inline">ProducesResponseType</strong>, you specified what status codes the endpoints could return. If you refresh the Swagger page, you will see the <strong class="source-inline">SaveWeatherForecast</strong> endpoint in Swagger:</p>
<div>
<div class="IMG---Figure" id="_idContainer207">
<img alt="Figure 9.9: SaveWeatherForecast endpoint in Swagger " height="644" src="image/B16835_09_09.jpg" width="1604"/>
</div>
</div>
<p class="figure-caption">Figure 9.9: SaveWeatherForecast endpoint in Swagger</p>
<p>If you refresh the Swagger page, you will see the <strong class="source-inline">GetWeatherForecast</strong> endpoint in Swagger:</p>
<div>
<div class="IMG---Figure" id="_idContainer208">
<img alt="Figure 9.10: GetWeatherForecast endpoint in Swagger " height="890" src="image/B16835_09_10.jpg" width="1598"/>
</div>
</div>
<p class="figure-caption">Figure 9.10: GetWeatherForecast endpoint in Swagger</p>
<p>You can see the status code addition, but where did the comments go? By default, Swagger does not pick XML docs. You need to specify what it has to do by configuring your project file. To do so, add the following piece of code inside <strong class="source-inline">&lt;Project&gt;</strong> below the property group of a target framework:</p>
<p class="source-code">  &lt;PropertyGroup&gt;</p>
<p class="source-code">    &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;</p>
<p class="source-code">    &lt;NoWarn&gt;$(NoWarn);1591&lt;/NoWarn&gt;</p>
<p class="source-code">  &lt;/PropertyGroup&gt;</p>
<p> </p>
<div>
<div class="IMG---Figure" id="_idContainer209">
<img alt="Figure 9.11: Swagger configuration to include XML docs " height="449" src="image/B16835_09_11.jpg" width="1474"/>
</div>
</div>
<p class="figure-caption">Figure 9.11: Swagger configuration to include XML docs</p>
<p>Lastly, go to the <strong class="source-inline">Program.cs</strong> file and replace <strong class="source-inline">service.AddSwaggerGen()</strong> with this:</p>
<p class="source-code">            builder.Services.AddSwaggerGen(cfg =&gt;</p>
<p class="source-code">            {</p>
<p class="source-code">                var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";</p>
<p class="source-code">                var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);</p>
<p class="source-code">                cfg.IncludeXmlComments(xmlPath);</p>
<p class="source-code">            });</p>
<p>This is the last piece of code needed to include XML comments in the Swagger docs. Now, refresh the page and you should see the comments included:</p>
<div>
<div class="IMG---Figure" id="_idContainer210">
<img alt="Figure 9.12: WeatherForecast Swagger docs with XML docs included " height="519" src="image/B16835_09_12.jpg" width="1618"/>
</div>
</div>
<p class="figure-caption">Figure 9.12: WeatherForecast Swagger docs with XML docs included</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/iQK5X">https://packt.link/iQK5X</a>.</p>
<p>There is a lot more that you can do with Swagger; you can include an example request and response and give default values to parameters. You can even create your own API specification standards and decorate a project namespace to apply the same conventions to every controller and their endpoints, but that is beyond the scope of this book.</p>
<p>The last thing to mention is the ability to generate a client out of the Swagger docs. To do so, follow these steps:</p>
<ol>
<li value="1">In order to download the <strong class="source-inline">swagger.json</strong> OpenAPI documentation artifact, navigate to <strong class="source-inline">https://localhost:7021/swagger/v1/swagger.json</strong>.</li>
<li>Right-click anywhere on the page and select the <strong class="source-inline">Save as</strong> option.</li>
<li>Then, press the <strong class="source-inline">Enter</strong> key.</li>
<li>Next, you will use this JSON to generate client code. So, register and log in to <a href="https://app.swaggerhub.com/home">https://app.swaggerhub.com/home</a> (you can use your GitHub account).</li>
<li>In the new window, click the <strong class="source-inline">Create New</strong> button (<strong class="source-inline">1</strong>):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer211">
<img alt="Figure 9.13: SwaggerHub and the Import API window " height="693" src="image/B16835_09_13.jpg" width="1413"/>
</div>
</div>
<p class="figure-caption">Figure 9.13: SwaggerHub and the Import API window</p>
<ol>
<li value="6">Select the <strong class="source-inline">Import and document API</strong> option.</li>
<li>Select the Swagger file you have just downloaded by clicking the <strong class="source-inline">Browse</strong> button (<strong class="source-inline">2</strong>).</li>
<li>Then, hit the <strong class="source-inline">UPLOAD FILE</strong> button:<p class="callout-heading">Note</p><p class="callout">When you select the file, the <strong class="source-inline">IMPORT</strong> button (<strong class="source-inline">3</strong> in <em class="italic">Figure 9.13</em>) changes to the <strong class="source-inline">UPLOAD FILE</strong> button (<strong class="source-inline">3</strong> in <em class="italic">Figure 9.14</em>).</p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer212">
<img alt="Figure 9.14: SwaggerHub IMPORT button changed to UPLOAD FILE button " height="547" src="image/B16835_09_14.jpg" width="1065"/>
</div>
</div>
<p class="figure-caption">Figure 9.14: SwaggerHub IMPORT button changed to UPLOAD FILE button</p>
<ol>
<li value="9">On the next screen, leave the name of the service and the version with default values.</li>
<li>Next, click the <strong class="source-inline">IMPORT DEFINITION</strong> button:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer213">
<img alt="Figure 9.15: SwaggerHub import Swagger service definition " height="480" src="image/B16835_09_15.jpg" width="950"/>
</div>
</div>
<p class="figure-caption">Figure 9.15: SwaggerHub import Swagger service definition</p>
<ol>
<li value="11">Now that the <strong class="source-inline">Swagger.json</strong> API scheme is imported, you can use it to generate a strongly typed C# client code to call the API. So, click the <strong class="source-inline">Export</strong> option (<strong class="source-inline">1</strong>).</li>
<li>Then, click the <strong class="source-inline">Client SDK</strong> option (<strong class="source-inline">2</strong>).</li>
<li>Select the <strong class="source-inline">csharp</strong> option (<strong class="source-inline">3</strong>):<div class="IMG---Figure" id="_idContainer214"><img alt="Figure 9.16: Exporting a new client in the C# client from SwaggerHub " height="643" src="image/B16835_09_16.jpg" width="1232"/></div></li>
</ol>
<p> </p>
<p class="figure-caption">Figure 9.16: Exporting a new client in the C# client from SwaggerHub</p>
<p>A <strong class="source-inline">csharp-client-generated.zip</strong> file will be downloaded.</p>
<ol>
<li value="14">Extract the <strong class="source-inline">csharp-client-generated.zip</strong> file.</li>
<li>Navigate the extracted folder and open the <strong class="source-inline">IO.Swagger.sln</strong> file. You should see the following:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer215">
<img alt="Figure 9.17: Files generated for the client using SwaggerHub " height="691" src="image/B16835_09_17.jpg" width="1309"/>
</div>
</div>
<p class="figure-caption">Figure 9.17: Files generated for the client using SwaggerHub</p>
<p>The generated client code not only has a strongly typed HTTP client but also includes tests. It also has a <strong class="source-inline">README.md</strong> file on how to call the client and many more common development scenarios.</p>
<p>Now, the question that arises is whether you should use Swagger when you already have Postman. While Postman is one of the most popular tools used for testing different kinds of Web APIs, Swagger is so much more than just a client to test whether the API works. Primarily, Swagger is a tool for documenting the API. From a conventional code, it allows you to generate all that you might need to:</p>
<ul>
<li>Test page</li>
<li>Test the client code</li>
<li>Test the documentation page</li>
</ul>
<p>Till now, you have learned that Swagger is a collection of tools and libraries implementing OpenAPI standards that are helpful for testing and documenting your APIs. You can now proceed to grasp error handling.</p>
<h2 id="_idParaDest-334"><a id="_idTextAnchor381"/>Error Handling</h2>
<p>You have already learned that the code within a controller should be as minimalistic as possible due to it being the highest level in code (direct call). Specific error handling should not be included in the controller code because it adds complexity to already-complex code. Fortunately, there is a way to map exceptions to HTTP status codes and set up all of them in one place—that is, via the <strong class="source-inline">Hellang.Middleware.ProblemDetails</strong> package. To do so, first install the package by running this command:</p>
<p class="source-code">dotnet add package <strong class="source-inline">Hellang.Middleware.ProblemDetails</strong></p>
<p>Map <strong class="source-inline">NoSuchWeekdayException</strong> to HTTP status code <strong class="source-inline">404</strong>. In the <strong class="source-inline">Program.cs</strong> file, before <strong class="source-inline">builder.Build()</strong>, add the following code:</p>
<p class="source-code">            builder.Services.AddProblemDetails(opt =&gt;</p>
<p class="source-code">            {</p>
<p class="source-code">                opt.MapToStatusCode&lt;NoSuchWeekdayException&gt;(404);</p>
<p class="source-code">                opt.IncludeExceptionDetails = (context, exception) =&gt; false;</p>
<p class="source-code">            });</p>
<p>This not only converts an exception to the right status code but also uses <strong class="source-inline">ProblemDetails</strong>—a standard response model based on RFC 7807—to provide faults in an HTTP response. Also, this excludes exception details in the error message.</p>
<p>When developing a service locally, knowing what went wrong is invaluable. However, exposing the stack trace and other information needed to determine the error can expose exploits of your Web API. Thus, it's better to hide it when moving toward the release stage. By default, the <strong class="source-inline">Hellang</strong> library already excludes the exception details in upper environments, so it is better that you don't include that line. For demo purposes and a simplified response message, it was included here.</p>
<p>Before you build a demo, you also need to turn off the default developer exceptions page because it overrides the exceptions in <strong class="source-inline">ProblemDetails</strong>. Simply remove the following block of code from the <strong class="source-inline">Configure</strong> method:</p>
<p class="source-code">        if (builder.Environment.IsDevelopment())</p>
<p class="source-code">        {</p>
<p class="source-code">            app.UseDeveloperExceptionPage();</p>
<p class="source-code">        }</p>
<p>Since you already have a central place for handling <strong class="source-inline">NoSuchWeekdayException</strong>, you can simplify the controller method for getting <strong class="source-inline">WeatherForecast</strong> for a given date:</p>
<p class="source-code">        [HttpGet("weekday/{day}")]</p>
<p class="source-code">        public IActionResult GetWeekday(int day)</p>
<p class="source-code">        {</p>
<p class="source-code">            var result = _weatherForecastService.GetWeekday(day);</p>
<p class="source-code">            return Ok(result);</p>
<p class="source-code">        }</p>
<p>When calling the endpoint with an invalid day value (for example, <strong class="source-inline">9</strong>), you get the following response:</p>
<p class="source-code">{</p>
<p class="source-code">    "type": "/weatherforecast/weekday/9",</p>
<p class="source-code">    "title": "Not Found",</p>
<p class="source-code">    "status": 404,</p>
<p class="source-code">    "traceId": "|41dee286-4c5efb72e344ee2d."</p>
<p class="source-code">}</p>
<p>This centralized error handling approach allows the controllers to be rid of all the <strong class="source-inline">try-catch</strong> blocks.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/CntW6">https://packt.link/CntW6</a>.</p>
<p>You can now map exceptions to HTTP status codes and set them all up in one place. This next section will take a look at another addition to an API, which is request validation.</p>
<h2 id="_idParaDest-335"><a id="_idTextAnchor382"/>Request Validation</h2>
<p>Another useful addition to an API is request validation. By default, ASP.NET Core has a request validator based on the required attributes. However, there might be complex scenarios where a combination of properties results in an invalid request or a custom error message for which validation is required.</p>
<p>.NET has a great NuGet package for that: <strong class="source-inline">FluentValidation.AspNetCore</strong>. Perform the following steps to learn how to carry out request validation. Before you continue, install the package by running the following command:</p>
<p class="source-code">dotnet add package <strong class="source-inline">FluentValidation.AspNetCore</strong></p>
<p>This package allows registering custom validators per model. It makes use of existing ASP.NET Core middleware, so all you must do is inject a new validator. Create a validator for <strong class="source-inline">WeatherForecast</strong>.</p>
<p>A validator should inherit the <strong class="source-inline">AbstractValidator</strong> class. This is not obligatory, but it is highly recommended because it implements the common methods for functionality and has a default implementation for generic validation:</p>
<p class="source-code">public class WeatherForecastValidator : AbstractValidator&lt;WeatherForecast&gt;</p>
<p>Through a generic argument, you specified that this is a validator for <strong class="source-inline">WeatherForecast</strong>.</p>
<p>Next is the validation itself. This is done in a constructor of a validator:</p>
<p class="source-code">        public WeatherForecastValidator()</p>
<p class="source-code">        {</p>
<p class="source-code">            RuleFor(p =&gt; p.Date)</p>
<p class="source-code">                .LessThan(DateTime.Now.AddMonths(1))</p>
<p class="source-code">                .WithMessage("Weather forecasts in more than 1 month of future are not supported");</p>
<p class="source-code">            RuleFor(p =&gt; p.TemperatureC)</p>
<p class="source-code">                .InclusiveBetween(-100, 100)</p>
<p class="source-code">                .WithMessage("A temperature must be between -100 and +100 C.");</p>
<p class="source-code">        }</p>
<p><strong class="source-inline">FluentValidation</strong> is a .NET library and is all about fluent API, with self-explanatory methods. Here, you require a weather forecast date to be no more than one month in the future. The next validation is to have the temperature between <strong class="source-inline">-100 C</strong> and <strong class="source-inline">100 C</strong>.</p>
<p>If you ping your API through Swagger, the following request gets displayed:</p>
<p class="source-code">{</p>
<p class="source-code">  "date": "2022-09-19T19:34:34.511Z",</p>
<p class="source-code">  "temperatureC": -111,</p>
<p class="source-code">  "summary": "string"</p>
<p class="source-code">}</p>
<p>The response will be displayed as follows:</p>
<p class="source-code">{</p>
<p class="source-code">  "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",</p>
<p class="source-code">  "title": "One or more validation errors occurred.",</p>
<p class="source-code">  "status": 400,</p>
<p class="source-code">  "traceId": "|ade14b9-443aaaf79026feec.",</p>
<p class="source-code">  "errors": {</p>
<p class="source-code">    "Date": [</p>
<p class="source-code">      "Weather forecasts in more than 1 month of future are not supported"</p>
<p class="source-code">    ],</p>
<p class="source-code">    "TemperatureC": [</p>
<p class="source-code">      "A temperature must be between -100 and +100 C."</p>
<p class="source-code">    ]</p>
<p class="source-code">  }</p>
<p class="source-code">}</p>
<p>You don't have to use <strong class="source-inline">FluentValidation</strong>, especially if your API is simple and does not have complex rules. But in an enterprise setting, it is highly recommended that you do use it because the level of detail you can add to your validation is unlimited.</p>
<p>You learned about <strong class="source-inline">FluentValidation</strong> and the scenarios where it is useful. The next section will touch upon the two options for reading configuration in ASP.NET.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/uOGOe">https://packt.link/uOGOe</a>.</p>
<h2 id="_idParaDest-336"><a id="_idTextAnchor383"/>Configuration</h2>
<p>In ASP.NET Core Web API, you have two options for reading configuration:</p>
<ul>
<li><strong class="source-inline">IConfiguration</strong>: This is a global configuration container. Even though it allows access to all the configuration properties, injecting it directly into other components is inefficient. This is because it is weakly typed and has a risk of you trying to get a non-existing configuration property.</li>
<li><strong class="source-inline">IOptions</strong>: This is strongly typed and convenient because the configuration is fragmented into just the pieces that a component needs.</li>
</ul>
<p>You can choose either of the two options. It is best practice to use <strong class="source-inline">IOptions</strong> in ASP.NET Core, as the configuration examples will be based on it. Whichever option you choose, you need to store the configuration in the <strong class="source-inline">appsettings.json</strong> file.</p>
<p>Move the hardcoded configuration from a constructor (weather forecast city and refresh interval) and move it into a configuration section in the <strong class="source-inline">appsettings.json</strong> file:</p>
<p class="source-code">  "WeatherForecastConfig": {</p>
<p class="source-code">    "City": "New York",</p>
<p class="source-code">    "RefreshInterval":  5 </p>
<p class="source-code">  }</p>
<p>Create a model representing this configuration section:</p>
<p class="source-code">    public class WeatherForecastConfig</p>
<p class="source-code">    {</p>
<p class="source-code">        public string City { get; set; }</p>
<p class="source-code">        public int RefreshInterval { get; set; }</p>
<p class="source-code">    }</p>
<p>You no longer have to inject the two primitive values into the component. Instead, you will inject <strong class="source-inline">IOptions&lt;WeatherForecastConfig&gt;</strong>:</p>
<p class="source-code">public WeatherForecastService(Ilogger&lt;WeatherForecastService&gt; logger, Ioptions&lt;WeatherForecastConfig&gt; config, ImemoryCache cache)</p>
<p>Before the JSON section is useable, you need to bind to it. This can be done by finding the section through <strong class="source-inline">IConfiguration</strong> (via the <strong class="source-inline">builder.Configuration</strong> property):</p>
<p class="source-code">builder.Services.Configure&lt;WeatherForecastConfig&gt;(builder.Configuration.GetSection(nameof(WeatherForecastConfig)));</p>
<p>In this case, <strong class="source-inline">WeatherForecastConfig</strong> has a matching section in the configuration file. Therefore, <strong class="source-inline">nameof</strong> was used. So, <strong class="source-inline">nameof</strong> should be preferred when using the alternative <strong class="source-inline">string</strong> type. That way, if the name of a type changes, the configuration will change consistently (or else the code won't compile).</p>
<p>Remember the <strong class="source-inline">BuildWeatherForecastService</strong> method you used previously? The beauty of it all is that the method can be removed altogether because the service can be created without the need for custom initialization. If you compile and run the code, you will get the same response.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/xoB0K">https://packt.link/xoB0K</a>.</p>
<p>ASP.NET Core Web API is just a collection of libraries on top of the .NET Core framework. You can use <strong class="source-inline">appsettings.json</strong> in other types of applications as well. It is better to use individual libraries regardless of the project type you choose. In order to use the configuration through JSON, all you need to do is to install the following NuGet packages:</p>
<ul>
<li><strong class="source-inline">Microsoft.Extensions.Configuration</strong></li>
<li><strong class="source-inline">Microsoft.Extensions.Configuration.EnvironmentVariables</strong></li>
<li><strong class="source-inline">Microsoft.Extensions.Configuration.FileExtensions</strong></li>
<li><strong class="source-inline">Microsoft.Extensions.Configuration.Json</strong></li>
<li><strong class="source-inline">Microsoft.Extensions.Options</strong></li>
</ul>
<p>In this section, you learned how to use <strong class="source-inline">IConfiguration</strong> and <strong class="source-inline">IOptions</strong>. Your API is now ready, and it already includes many standard components of a typical Web API. The next section will detail how you can handle this complexity in code.</p>
<h3 id="_idParaDest-337"><a id="_idTextAnchor384"/>Development Environments and Configuration</h3>
<p>Applications often need to have two environments—production and development. You want the application development environment to have premade settings, more detailed error messages (if possible), more detailed logging, and lastly, debugging enabled. All of that is not needed for a production environment and you would want to keep it clean.</p>
<p>Other than the build configuration, you manage environments through different configuration files. The <strong class="source-inline">appsettings.json</strong> file is a base configuration file and is used across all environments. This configuration file should contain the configuration you would like for production.</p>
<p>The <strong class="source-inline">Appsettings.development.json</strong> file is a configuration file that will be applied when you build your application in debug mode. Here, <strong class="bold">applied</strong> doesn't mean a complete overwrite of settings; <strong class="source-inline">appsettings.json</strong> will still be used with the development settings overriding the matching sections. A common example is described here.</p>
<p>Say <strong class="source-inline">appsettings.json</strong> has the following:</p>
<p class="source-code">{</p>
<p class="source-code">  "Logging": {</p>
<p class="source-code">    "LogLevel": {</p>
<p class="source-code">      "Default": "Information",</p>
<p class="source-code">      "Microsoft": "Information",</p>
<p class="source-code">      "Microsoft.Hosting.Lifetime": "Information"</p>
<p class="source-code">    }</p>
<p class="source-code">  },</p>
<p class="source-code">  "AllowedHosts": "*",</p>
<p class="source-code">  "WeatherForecastConfig": {</p>
<p class="source-code">    "City": "New York",</p>
<p class="source-code">    "RefreshInterval": 5</p>
<p class="source-code">  },</p>
<p class="source-code">  "WeatherForecastProviderUrl": "https://community-open-weather-map.p.rapidapi.com/",</p>
<p class="source-code">  "AzureAd": {</p>
<p class="source-code">    "Instance": "https://login.microsoftonline.com/",</p>
<p class="source-code">    "ClientId": "2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb",</p>
<p class="source-code">    "TenantId": "ddd0fd18-f056-4b33-88cc-088c47b81f3e",</p>
<p class="source-code">    "Audience": "api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb"</p>
<p class="source-code">  }</p>
<p class="source-code">}</p>
<p>And <strong class="source-inline">appsettings.development.json</strong> has the following:</p>
<p class="source-code">{</p>
<p class="source-code">  "Logging": {</p>
<p class="source-code">    "LogLevel": {</p>
<p class="source-code">      "Default": "Trace",</p>
<p class="source-code">      "Microsoft": "Trace",</p>
<p class="source-code">      "Microsoft.Hosting.Lifetime": "Trace"</p>
<p class="source-code">    }</p>
<p class="source-code">  }</p>
<p class="source-code">}</p>
<p>Then, the settings used will be the merged file with override matching sections, as shown here:</p>
<p class="source-code">{</p>
<p class="source-code">  "Logging": {</p>
<p class="source-code">    "LogLevel": {</p>
<p class="source-code">      "Default": "Trace",</p>
<p class="source-code">      "Microsoft": "Trace",</p>
<p class="source-code">      "Microsoft.Hosting.Lifetime": "Trace"</p>
<p class="source-code">    }</p>
<p class="source-code">  },</p>
<p class="source-code">  "AllowedHosts": "*",</p>
<p class="source-code">  "WeatherForecastConfig": {</p>
<p class="source-code">    "City": "New York",</p>
<p class="source-code">    "RefreshInterval": 5</p>
<p class="source-code">  },</p>
<p class="source-code">  "WeatherForecastProviderUrl": "https://community-open-weather-map.p.rapidapi.com/",</p>
<p class="source-code">  "AzureAd": {</p>
<p class="source-code">    "Instance": "https://login.microsoftonline.com/",</p>
<p class="source-code">    "ClientId": "2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb",</p>
<p class="source-code">    "TenantId": "ddd0fd18-f056-4b33-88cc-088c47b81f3e",</p>
<p class="source-code">    "Audience": "api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb"</p>
<p class="source-code">  }</p>
<p class="source-code">}</p>
<p>In the next section, you will learn how to manage DI more cleanly.</p>
<h2 id="_idParaDest-338"><a id="_idTextAnchor385"/>Bootstrapping</h2>
<p>Complexity needs to be handled and the complexity referred to here is the <strong class="source-inline">Program</strong> class. You'll need to break it out into smaller pieces and form a Bootstrapping directory specifying the components the service is made of.</p>
<p>When breaking down code within <strong class="source-inline">Program.cs</strong>, it is recommended to use a fluent API pattern. This is a pattern where you can chain multiple function calls from a single root object. In this case, you will create several extension methods for the <strong class="source-inline">IServiceCollection</strong> type and chain all the module injections one by one.</p>
<p>To reduce the complexity of the <strong class="source-inline">Program</strong> class, move the DI of different logical sections into different files. Each step that follows will do just that. So, split the controller and API baseline setup to a new file named <strong class="source-inline">ControllersConfigurationSetup.cs</strong>:</p>
<p class="source-code">    public static class ControllersConfigurationSetup</p>
<p class="source-code">    {</p>
<p class="source-code">        public static IserviceCollection AddControllersConfiguration(this IserviceCollection services)</p>
<p class="source-code">        {</p>
<p class="source-code">            services</p>
<p class="source-code">                .AddControllers()</p>
<p class="source-code">                .AddFluentValidation();</p>
<p class="source-code">            return services;</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p>Now, move the code for logging to a new file named <strong class="source-inline">LoggingSetup.cs</strong>:</p>
<p class="source-code">    public static class LoggingSetup</p>
<p class="source-code">    {</p>
<p class="source-code">        public static IServiceCollection AddLoggingConfiguration(this IServiceCollection services)</p>
<p class="source-code">        {</p>
<p class="source-code">            services.AddLogging(builder =&gt;</p>
<p class="source-code">            {</p>
<p class="source-code">                builder.ClearProviders();</p>
<p class="source-code">                builder.AddConsole();</p>
<p class="source-code">                builder.AddDebug();</p>
<p class="source-code">            });</p>
<p class="source-code">            return services;</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p>Next, move the request validation logic to a new file named <strong class="source-inline">RequestValidatorsSetup.cs</strong>:</p>
<p class="source-code">    public static class RequestValidatorsSetup</p>
<p class="source-code">    {</p>
<p class="source-code">        public static IServiceCollection AddRequestValidators(this IServiceCollection services)</p>
<p class="source-code">        {</p>
<p class="source-code">            services.AddTransient&lt;Ivalidator&lt;WeatherForecast&gt;, WeatherForecastValidator&gt;();</p>
<p class="source-code">            return services;</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p>Move the Swagger setup logic to a new file named <strong class="source-inline">SwaggerSetup.cs</strong>:</p>
<p class="source-code">    public static class SwaggerSetup</p>
<p class="source-code">    {</p>
<p class="source-code">        public static IServiceCollection AddSwagger(this IServiceCollection services)</p>
<p class="source-code">        {</p>
<p class="source-code">            services.AddSwaggerGen(cfg =&gt;</p>
<p class="source-code">            {</p>
<p class="source-code">                var xmlFile = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";</p>
<p class="source-code">                var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);</p>
<p class="source-code">                cfg.IncludeXmlComments(xmlPath);</p>
<p class="source-code">            });</p>
<p class="source-code">            return services;</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p>Move the injection of the <strong class="source-inline">WeatherForecast</strong>-related classes' code to a new file named  <strong class="source-inline">WeatherServiceSetup.cs</strong>:</p>
<p class="source-code">    public static class WeatherServiceSetup</p>
<p class="source-code">    {</p>
<p class="source-code">        public static IServiceCollection AddWeatherService(this IServiceCollection services, IConfiguration configuration)</p>
<p class="source-code">        {</p>
<p class="source-code">            services.AddScoped&lt;IWeatherForecastService, WeatherForecastService&gt;(BuildWeatherForecastService);</p>
<p class="source-code">            services.AddSingleton&lt;ICurrentTimeProvider, CurrentTimeUtcProvider&gt;();</p>
<p class="source-code">            services.AddSingleton&lt;ImemoryCache, MemoryCache&gt;();</p>
<p class="source-code">            services.Configure&lt;WeatherForecastConfig&gt;(configuration.GetSection(nameof(WeatherForecastConfig)));</p>
<p class="source-code">            return services;</p>
<p class="source-code">        }</p>
<p class="source-code">        private static WeatherForecastService BuildWeatherForecastService(IserviceProvider provider)</p>
<p class="source-code">        {</p>
<p class="source-code">            var logger = provider</p>
<p class="source-code">                .GetService&lt;IloggerFactory&gt;()</p>
<p class="source-code">                .CreateLogger&lt;WeatherForecastService&gt;();</p>
<p class="source-code">            var options = provider.GetService&lt;Ioptions&lt;WeatherForecastConfig&gt;&gt;();</p>
<p class="source-code">            return new WeatherForecastService(logger, options, provider.GetService&lt;ImemoryCache&gt;());</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p>Finally, move the exception mapping of HTTP status codes to a new file named <strong class="source-inline">ExceptionMappingSetup.cs</strong>:</p>
<p class="source-code">    public static class ExceptionMappingSetup</p>
<p class="source-code">    {</p>
<p class="source-code">        public static IServiceCollection AddExceptionMappings(this IServiceCollection services)</p>
<p class="source-code">        {</p>
<p class="source-code">            services.AddProblemDetails(opt =&gt;</p>
<p class="source-code">            {</p>
<p class="source-code">                opt.MapToStatusCode&lt;NoSuchWeekdayException&gt;(404);</p>
<p class="source-code">            });</p>
<p class="source-code">            return services;</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p>Now move all the new classes under <strong class="source-inline">/Bootstrap</strong> folder:</p>
<div>
<div class="IMG---Figure" id="_idContainer216">
<img alt="Figure 9.18: Bootstrap folder with the fragmented services injection " height="461" src="image/B16835_09_18.jpg" width="1274"/>
</div>
</div>
<p> </p>
<p class="figure-caption">Figure 9.18: Bootstrap folder with the fragmented services injection</p>
<p><em class="italic">Figure 9.18</em> displays the <strong class="source-inline">Bootstrap</strong> folder. This project structure itself demonstrates what the API is made up of. So, DI becomes as simple as the following:</p>
<p class="source-code">builder.Services</p>
<p class="source-code">    .AddControllersConfiguration()</p>
<p class="source-code">    .AddLoggingConfiguration()</p>
<p class="source-code">    .AddRequestValidators()</p>
<p class="source-code">    .AddSwagger()</p>
<p class="source-code">    .AddWeatherService(builder.Configuration)</p>
<p class="source-code">    .AddExceptionMappings();</p>
<p>In some cases, you may want to pass the configuration or environment from a builder to other bootstrap methods or app methods multiple times. If you find yourself repeatedly calling <strong class="source-inline">builder.X</strong>, then consider storing each property in a local variable, as shown here:</p>
<p class="source-code">var services = builder.Services;</p>
<p class="source-code">var configuration = builder.Configuration;</p>
<p class="source-code">var environment = builder.Environment;</p>
<p>With this, you will no longer repeatedly access the builder and will instead be able to use the needed builder properties directly. This is especially useful if you migrate from .NET Core to .NET 6. <strong class="source-inline">Environment</strong> and <strong class="source-inline">Configuration</strong> used to be properties of a <strong class="source-inline">Program</strong> class, while <strong class="source-inline">Services</strong> would be injected into the <strong class="source-inline">ConfigureServices</strong> method. In .NET 6, <strong class="source-inline">Services</strong> is accessed through a <strong class="source-inline">builder</strong> object. However, with this approach, you can still use those properties or arguments as they were.</p>
<p>From now on, when referring to services, environments, or configurations, you will assume that you are accessing them from <strong class="source-inline">builder.Services</strong>, <strong class="source-inline">builder.Environment</strong>, and <strong class="source-inline">builder.Configuration</strong>, accordingly.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/iQK5X">https://packt.link/iQK5X</a>.</p>
<h2 id="_idParaDest-339"><a id="_idTextAnchor386"/>Calling Another API</h2>
<p>A working product is usually made of many APIs communicating with each other. To communicate effectively, one web service often needs to call another service. For example, a hospital may have a website (frontend) that calls a Web API (backend). This Web API orchestrates things by making calls to a booking Web API, a billing Web API, and a staff Web API. A staff Web API may make calls to an inventory API, holidays API, etc.</p>
<h3 id="_idParaDest-340"><a id="_idTextAnchor387"/>RapidAPI</h3>
<p>As discussed in <em class="italic">Chapter 8</em>, <em class="italic">Creating and Using Web API Clients</em>, there are various ways of making HTTP calls to other services (though HTTP is not the only way to call another service). This time, you will try to get weather forecasts from an existing API and format it in your way. For doing so, you will use the RapidAPI Weather API, which can be found at <a href="https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/">https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/</a>.</p>
<p class="callout-heading">Note</p>
<p class="callout">RapidAPI is a platform that supports many APIs. The site <a href="https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/">https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/</a> is just one example. Many of the APIs present there are free; however, be aware that an API that is free today might become paid tomorrow. If that happens by the time you read this chapter, go through the examples, and explore the <em class="italic">Weather APIs</em> section at <a href="https://rapidapi.com/category/Weather">https://rapidapi.com/category/Weather</a>. You should be able to find similar alternatives there.</p>
<p>This API requires a GitHub account for use. Perform the following steps to use the RapidAPI Weather API:</p>
<ol>
<li value="1">Log in to the website <a href="https://rapidapi.com/community/api/open-weather-map/">https://rapidapi.com/community/api/open-weather-map/</a>.<p class="callout-heading">Note</p><p class="callout">You can navigate to <a href="https://rapidapi.com/community/api/open-weather-map/">https://rapidapi.com/community/api/open-weather-map/</a> only if you are logged in. So, signup at <a href="https://rapidapi.com/">https://rapidapi.com/</a> and create an account. This is required if you need an API key. Next login and select <strong class="source-inline">Weather</strong> category and choose <strong class="source-inline">Open Weather</strong> link.</p></li>
</ol>
<p>After you log in to the website, you will see the following window:</p>
<div>
<div class="IMG---Figure" id="_idContainer217">
<img alt="Figure 9.19: Unsubscribed test page of the Visual Crossing Weather API on rapidapi.com " height="622" src="image/B16835_09_19.jpg" width="1313"/>
</div>
</div>
<p class="figure-caption">Figure 9.19: Unsubscribed test page of the Visual Crossing Weather API on rapidapi.com</p>
<ol>
<li value="2">Click the <strong class="source-inline">Subscribe to Test</strong> button to get access (for free) to making calls to the Web API. A new window will open.</li>
<li>Select the <strong class="source-inline">Basic</strong> option, which will allow you to make 500 calls a month to that API. For educational purposes, the basic plan should be enough:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer218">
<img alt="Figure 9.20: RapidAPI subscription fees with a free Basic plan highlighted " height="580" src="image/B16835_09_20.jpg" width="1349"/>
</div>
</div>
<p class="figure-caption">Figure 9.20: RapidAPI subscription fees with a free Basic plan highlighted</p>
<p>You will be redirected to the test page with the <strong class="source-inline">Test Endpoint</strong> button available (instead of the <strong class="source-inline">Subscribe to Test</strong> button).</p>
<ol>
<li value="4">Now, configure the request. The first configuration asks you to enter the intervals for getting the weather forecast. You want an hourly forecast, so enter <strong class="source-inline">1</strong> hour beside <strong class="source-inline">aggregateHours</strong> (<strong class="source-inline">1</strong>).</li>
<li>Next up is the <strong class="source-inline">location</strong> address (<strong class="source-inline">2</strong>).</li>
</ol>
<p>In <em class="italic">Figure 9.21</em>, you can observe that the city, state, and country are specified. These fields ask you to enter your address. However, typing your city name would also work.</p>
<ol>
<li value="6">Choose the default <strong class="source-inline">contentType</strong> option as <strong class="source-inline">csv</strong> for this API (<strong class="source-inline">3</strong>):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer219">
<img alt="Figure 9.21: GET weather forecast data request configuration " height="674" src="image/B16835_09_21.jpg" width="1432"/>
</div>
</div>
<p class="figure-caption">Figure 9.21: GET weather forecast data request configuration</p>
<p>This API is interesting because it allows you to return data in different formats—JSON, XML, and CSV. It is still a Web API and not so RESTful because the data response type is natively CSV. If you choose JSON, it will look unnatural and significantly more difficult to work with.</p>
<ol>
<li value="7">On the next screen, click <strong class="source-inline">Code Snippets</strong> (<strong class="source-inline">1</strong>) and then <strong class="source-inline">(C#) HttpClient</strong> (<strong class="source-inline">2</strong>) to see the example client code generated for you.</li>
<li>Next, click <strong class="source-inline">Test Endpoint</strong> (<strong class="source-inline">3</strong>) to send a request.</li>
<li>Click the <strong class="source-inline">Results</strong> tab (<strong class="source-inline">4</strong>) to view the response (in <em class="italic">Figure 9.22</em>, other endpoints are collapsed):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer220">
<img alt="Figure 9.22: rapidapi.com with test request page and example code  in C# for making the request " height="576" src="image/B16835_09_22.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 9.22: rapidapi.com with test request page and example code in C# for making the request</p>
<p>This window provides a nice API. It is also a great way to learn how to make calls to it by giving multiple examples of creating clients using a variety of languages and technologies.</p>
<p>As always, you will not initialize this client directly in a client but inject the client somehow. In <em class="italic">Chapter 8</em>, <em class="italic">Creating and Using Web API Clients</em>, it was mentioned that to have a static <strong class="source-inline">HttpClient</strong> over one constantly disposed is an efficient practice. However, for a Web API, there is an even better alternative—<strong class="source-inline">HttpClientFactory</strong>.</p>
<ol>
<li value="10">Before you do all that, you need to prepare a few things. First, update the <strong class="source-inline">appsettings.json</strong> file with the inclusion of the base URL of an API:<p class="source-code">"WeatherForecastProviderUrl": "https://visual-crossing-weather.p.rapidapi.com/"</p></li>
</ol>
<p>Next, you will need to create another class for fetching the weather details from the said API. For that purpose, you will need an API key. You can find it in the example code snippet on the API website:</p>
<div>
<div class="IMG---Figure" id="_idContainer221">
<img alt="Figure 9.23: RapidAPI API key in the example code snippet " height="606" src="image/B16835_09_23.jpg" width="1124"/>
</div>
</div>
<p class="figure-caption">Figure 9.23: RapidAPI API key in the example code snippet</p>
<ol>
<li value="11">Save the API key as an environment variable because it is a secret and storing secrets in code is bad practice. So, name it as <strong class="source-inline">x-rapidapi-key</strong>.</li>
<li>Lastly, the returned weather forecast might be quite different from yours. You can see the example response by clicking the <strong class="source-inline">Test Endpoint</strong> button:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer222">
<img alt="Figure 9.24: RapidAPI example response from GET current weather data endpoint " height="372" src="image/B16835_09_24.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 9.24: RapidAPI example response from GET current weather data endpoint</p>
<ol>
<li value="13">Copy the results received after clicking the <strong class="source-inline">Test Endpoint</strong> button.</li>
<li>Paste the results in <a href="https://toolslick.com/generation/code/class-from-csv">https://toolslick.com/generation/code/class-from-csv</a>.</li>
<li>Give the class name as <strong class="source-inline">WeatherForecast</strong> and leave the rest of the settings as the defaults.</li>
<li>Finally, press the <strong class="source-inline">GENERATE</strong> button:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer223">
<img alt="Figure 9.25: Response content pasted to  https://toolslick.com/generation/code/class-from-csv " height="739" src="image/B16835_09_25.jpg" width="1377"/>
</div>
</div>
<p class="figure-caption">Figure 9.25: Response content pasted to <a href="https://toolslick.com/generation/code/class-from-csv">https://toolslick.com/generation/code/class-from-csv</a></p>
<p>This will create two classes, <strong class="source-inline">WeatherForecast</strong> and <strong class="source-inline">WeatherForecastClassMap</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer224">
<img alt="Figure 9.26: Generated data model and mapping classes (simplified for brevity) " height="278" src="image/B16835_09_26.jpg" width="1005"/>
</div>
</div>
<p class="figure-caption">Figure 9.26: Generated data model and mapping classes (simplified for brevity)</p>
<p><strong class="source-inline">WeatherForecast</strong> represents the object to which the data from this API will be loaded.</p>
<ol>
<li value="17">Create a file called <strong class="source-inline">WeatherForecast.cs</strong> under the <strong class="source-inline">Dtos</strong> folder (DTO will be described in detail in the <em class="italic">DTO and Mapping Using AutoMapper</em> section) and paste the class there.</li>
<li>Remove the bits that do not have a connection to an already-existing <strong class="source-inline">WeatherForecast</strong> model. The cleaned-up model will look as follows:<p class="source-code">public class WeatherForecast</p><p class="source-code">{</p><p class="source-code">    public DateTime Datetime { get; set; }</p><p class="source-code">    public string Temperature { get; set; }</p><p class="source-code">    public string Conditions { get; set; }</p><p class="source-code">}</p></li>
</ol>
<p>You should know that <strong class="source-inline">WeatherForecastClassMap</strong> is a special class. It is used by the <strong class="source-inline">CsvHelper</strong> library, which is used for parsing CSV files. You could parse CSV files yourself; however, <strong class="source-inline">CsvHelper</strong> makes it a lot easier to parse.</p>
<ol>
<li value="19">To use <strong class="source-inline">CsvHelper</strong>, install its NuGet package:<p class="source-code">dotnet add package CsvHelper</p></li>
</ol>
<p><strong class="source-inline">WeatherForecastCsv</strong> represents a mapping from a CSV to a C# object.</p>
<ol>
<li value="20">Now, create a file called <strong class="source-inline">WeatherForecastClassMap.cs</strong> under the <strong class="source-inline">ClassMaps</strong> folder and paste the class there.</li>
<li>Keep only the mappings that match the <strong class="source-inline">WeatherForecast</strong> class that was edited in <em class="italic">Step 17</em>:<p class="source-code">public class WeatherForecastClassMap : ClassMap&lt;WeatherForecast&gt;</p><p class="source-code">{</p><p class="source-code">    public WeatherForecastClassMap()</p><p class="source-code">    {</p><p class="source-code">        Map(m =&gt; m.Datetime).Name("Date time");</p><p class="source-code">        Map(m =&gt; m.Temperature).Name("Temperature");</p><p class="source-code">        Map(m =&gt; m.Conditions).Name("Conditions");</p><p class="source-code">    }</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">You can find the code used for this example at <a href="https://packt.link/dV6wX">https://packt.link/dV6wX</a> and <a href="https://packt.link/mGJMW">https://packt.link/mGJMW</a>.</p></li>
</ol>
<p>In the previous section, you learned how to get weather forecasts from an existing API and format them your way using the RapidAPI Weather API. Now it is time to proceed to the service client and use the models created, along with the settings, parse the API response, and return the current time weather.</p>
<h3 id="_idParaDest-341"><a id="_idTextAnchor388"/>Service Client</h3>
<p>Now you have all the ingredients that are needed to create the provider class. You learned in <em class="italic">Chapter 8</em>, <em class="italic">Creating and Using Web API Clients</em>, that when communicating with another API, it's best to create a separate component for it. So, here you will start from an interface abstraction, <strong class="source-inline">IWeatherForecastProvider</strong>:</p>
<p class="source-code">    public interface IWeatherForecastProvider</p>
<p class="source-code">    {</p>
<p class="source-code">        Task&lt;WeatherForecast&gt; GetCurrent(string location);</p>
<p class="source-code">    }</p>
<p>Next, create an implementation of that interface—that is, a class taking <strong class="source-inline">HttpClient</strong> for DI:</p>
<p class="source-code">public class WeatherForecastProvider : IWeatherForecastProvider</p>
<p class="source-code">    {</p>
<p class="source-code">        private readonly HttpClient _client;</p>
<p class="source-code">        public WeatherForecastProvider(HttpClient client)</p>
<p class="source-code">        {</p>
<p class="source-code">            _client = client;</p>
<p class="source-code">        }</p>
<p>To implement an interface, start with writing a method definition for getting the current weather:</p>
<p class="source-code">public async Task&lt;WeatherForecast&gt; GetCurrent(string location)</p>
<p class="source-code">{</p>
<p>Next, create a request to call HTTP GET with a relative URI for getting a forecast of the CSV type at a given location:</p>
<p class="source-code">var request = new HttpRequestMessage</p>
<p class="source-code">{</p>
<p class="source-code">    	Method = HttpMethod.Get,</p>
<p class="source-code">    	RequestUri = new Uri($"forecast?aggregateHours=1&amp;location={location}&amp;contentType=csv", UriKind.Relative),</p>
<p class="source-code">};</p>
<p>Now, send a request and verify that it was a success:</p>
<p class="source-code">using var response = await _client.SendAsync(request);</p>
<p class="source-code">response.EnsureSuccessStatusCode();</p>
<p>If the status code is not in the range of <strong class="source-inline">200-300</strong>, the <strong class="source-inline">response.EnsureSuccessStatusCode();</strong> throws an exception. Set up a CSV reader to prepare for deserializing weather forecasts:</p>
<p class="source-code">var body = await response.Content.ReadAsStringAsync();</p>
<p class="source-code">using var reader = new StringReader(body);</p>
<p class="source-code">using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);</p>
<p class="source-code">csv.Context.RegisterClassMap&lt;WeatherForecastClassMap&gt;();</p>
<p>You are adding a <strong class="source-inline">using</strong> statement to <strong class="source-inline">StringReader</strong> and <strong class="source-inline">CsvReader</strong> because both implement the <strong class="source-inline">IDisposable</strong> interface for disposing unmanaged resources. This happens when you use the <strong class="source-inline">using</strong> statement within a function after it returns.</p>
<p>Lastly, deserialize the forecasts:</p>
<p class="source-code">var forecasts = csv.GetRecords&lt;WeatherForecast&gt;();</p>
<p>This way, you request the API to return forecasts starting from today and stopping a few days in the future with 1-hour intervals. The first returned forecast is the forecast of the current hour—that is, the forecast that you need:</p>
<p class="source-code">return forecasts.First();</p>
<p class="source-code">}</p>
<p>Now, you will use <strong class="source-inline">Newtonsoft.Json</strong> for deserialization. Install the following package to do so:</p>
<p class="source-code">dotnet add package Microsoft.AspNetCore.Mvc.NewtonsoftJson</p>
<p>Update the <strong class="source-inline">AddControllersConfiguration</strong> method by appending the following line on the services object:</p>
<p class="source-code">.AddNewtonsoftJson();</p>
<p>This line replaces the default serializer with <strong class="source-inline">Newtonsoft.Json</strong>. Now, <strong class="source-inline">Newtonsoft.Json</strong> doesn't have to be used; however, it is a much more popular and complete library for serialization compared to the default one.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/jmSwi">https://packt.link/jmSwi</a>.</p>
<p>Till now, you have learned how to create a service client and make basic HTTP calls using it. It's effective for grasping the basics; however, the classes the API uses should be coupled with the classes of the APIs it consumes. In the next section, you will learn how to decouple the API from third-party API models using a DTO and mapping via <strong class="source-inline">AutoMapper</strong>.</p>
<h3 id="_idParaDest-342"><a id="_idTextAnchor389"/>DTO and Mapping Using AutoMapper</h3>
<p>The weather forecast model from RapidAPI is a Date Transfer Object (DTO)—a model used just for transferring data and convenient serialization. RapidAPI may change its data model and, if that happens, the DTO will change as well. If you are just presenting the data you had received and don't need to perform any logical operations on it, then any change may be alright.</p>
<p>However, you will usually apply business logic to a data model. You already know that references to a data model are scattered across multiple classes. With every change to a DTO, a class may have to change as well. For example, the DTO property that was called <strong class="source-inline">weather</strong> has now changed to <strong class="source-inline">weathers</strong>. Another example is of a property that was previously called <strong class="source-inline">description</strong> will now be called a <strong class="source-inline">message</strong>. So, renaming a DTO property like this will require you to make changes everywhere they are referenced. The bigger the project, the worse of an issue this becomes.</p>
<p>The advice of the SOLID principles is to avoid such changes (refer to <em class="italic">Chapter 2</em>, <em class="italic">Building Quality Object-Oriented Code</em>). One of the ways to achieve this is by having two kinds of models—one for domain and the other for outside calls. This will require a mapping between foreign objects (coming from outside APIs) into your own.</p>
<p>Mapping can be done either manually or by using some popular libraries. One of the most popular mapping libraries is AutoMapper. It allows you to map from one object to another using property names. You can also make your own mappings. Now, you will use this library to configure a mapping between a weather forecast DTO and a weather forecast model.</p>
<p>So, first install NuGet:</p>
<p class="source-code">dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection</p>
<p>This library allows you to inject <strong class="source-inline">AutoMapper</strong> into <strong class="source-inline">ServiceCollection</strong>. Here, <strong class="source-inline">AutoMapper</strong> uses the <strong class="source-inline">Profile</strong> class to define a mapping.</p>
<p>A new mapping should inherit the <strong class="source-inline">Profile</strong> class. So, inside the constructor of the new profile, use a <strong class="source-inline">CreateMap</strong> method to provide a mapping:</p>
<p class="source-code">    public class WeatherForecastProfile : Profile</p>
<p class="source-code">    {</p>
<p class="source-code">        public WeatherForecastProfile()</p>
<p class="source-code">        {</p>
<p class="source-code">            CreateMap&lt;Dtos.WeatherForecast, Models.WeatherForecast&gt;()</p>
<p>Next, in order to map every property from the <strong class="source-inline">CreateMap</strong> method, call the <strong class="source-inline">ForMember</strong> method and specify how to do a mapping:</p>
<p class="source-code">                .ForMember(to =&gt; to.TemperatureC, opt =&gt; opt.MapFrom(from =&gt; from.main.temp));</p>
<p>Here, the value of <strong class="source-inline">TemperatureC</strong> comes from <strong class="source-inline">main.temp</strong> inside the DTO.</p>
<p>For the other property, you will concatenate all the weather descriptions into one string and call that a summary (<strong class="source-inline">BuildDescription</strong>):</p>
<p class="source-code">        private static string BuildDescription(Dtos.WeatherForecast forecast)</p>
<p class="source-code">        {</p>
<p class="source-code">            return string.Join(",",</p>
<p class="source-code">                forecast.weather.Select(w =&gt; w.description));</p>
<p class="source-code">        }</p>
<p>Now, use the lambda method, <strong class="source-inline">ForMember</strong>, when building a weather forecast summary mapping:</p>
<p class="source-code">.ForMember(to =&gt; to.Summary, opt =&gt; opt.MapFrom(from =&gt; BuildDescription(from)))</p>
<p>Create a <strong class="source-inline">MapperSetup</strong> class and inject <strong class="source-inline">AutoMapper</strong> from the <strong class="source-inline">AddModelMappings</strong> method to provide different mapping profiles:</p>
<p class="source-code">public static class MapperSetup</p>
<p class="source-code">{</p>
<p class="source-code">    public static IServiceCollection AddModelMappings(this IServiceCollection services)</p>
<p class="source-code">    {</p>
<p class="source-code">        services.AddAutoMapper(cfg =&gt;</p>
<p class="source-code">        {</p>
<p class="source-code">            cfg.AddProfile&lt;WeatherForecastProfile&gt;();</p>
<p class="source-code">        });</p>
<p class="source-code">        return services;</p>
<p class="source-code">    }</p>
<p class="source-code">}</p>
<p>Append <strong class="source-inline">.AddModelMappings()</strong> to the <strong class="source-inline">services</strong> object calls. With this, you can call <strong class="source-inline">mapper.Map&lt;Model.WeatherForecast&gt;(dtoForecast);</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/fEfdw">https://packt.link/fEfdw</a> and <a href="https://packt.link/wDqK6">https://packt.link/wDqK6</a>.</p>
<p>The <strong class="source-inline">AutoMapper</strong> mapping library allows you to map from one object to another by default mapping matching property names. The next section will detail how you can use DI to reuse <strong class="source-inline">HttpClient</strong>.</p>
<h3 id="_idParaDest-343"><a id="_idTextAnchor390"/>HttpClient DI</h3>
<p>Continuing with DI, you now want to get into the habit of using the fragmented <strong class="source-inline">ConfigureServices</strong> approach. So, first, create a class called <strong class="source-inline">HttpClientsSetup</strong> and then create a method for adding the configured <strong class="source-inline">HttpClients</strong>:</p>
<p class="source-code">    public static class HttpClientsSetup</p>
<p class="source-code">    {</p>
<p class="source-code">        public static IServiceCollection AddHttpClients(IServiceCollection services)</p>
<p class="source-code">        {</p>
<p>Next, for the injection itself, use the <strong class="source-inline">AddHttpClient</strong> method:</p>
<p class="source-code">services.AddHttpClient&lt;IWeatherForecastProvider, WeatherForecastProvider&gt;((provider, client) =&gt;</p>
<p class="source-code">            {</p>
<p>In the preceding section, it was mentioned that the keys should be hidden and stored in environment variables. To set a default start URI of every call, set <strong class="source-inline">BaseAddress</strong> (<strong class="source-inline">WeatherForecastProviderUrl</strong> used in <em class="italic">Step 10</em> of the <em class="italic">RapidAPI</em> section).</p>
<p>To append the API key on every request, get the API key that you stored in environment variables and assign it to default headers as <strong class="source-inline">x-rapidapi-key</strong>:</p>
<p class="source-code">                client.BaseAddress = new Uri(config["WeatherForecastProviderUrl"]);</p>
<p class="source-code">                var apiKey = Environment.GetEnvironmentVariable("x-rapidapi-key", EnvironmentVariableTarget.User);</p>
<p class="source-code">                client.DefaultRequestHeaders.Add("x-rapidapi-key", apiKey);</p>
<p class="source-code">            });</p>
<p>To finish the injection-builder pattern, you need to return the <strong class="source-inline">services</strong> object, as follows:</p>
<p class="source-code">return services;</p>
<p>Now, go back to <strong class="source-inline">services</strong> in <strong class="source-inline">Program</strong> and append the following:</p>
<p class="source-code">.AddHttpClients(Configuration)</p>
<p>To integrate the client you have just set up, go to <strong class="source-inline">WeatherForecastService</strong>, and inject the <strong class="source-inline">mapper</strong> and <strong class="source-inline">provider</strong> components:</p>
<p class="source-code">public WeatherForecastService(..., IWeatherForecastProvider provider, IMapper mapper)</p>
<p>Change the <strong class="source-inline">GetWeatherForecast</strong> method to either get the cached forecast of this hour or fetch a new one from the API:</p>
<p class="source-code">        public async Task&lt;WeatherForecast&gt; GetWeatherForecast(DateTime date)</p>
<p class="source-code">        {</p>
<p class="source-code">            const string DateFormat = "yyyy-MM-ddthh";</p>
<p class="source-code">            var contains = _cache.TryGetValue(date.ToString(DateFormat), out var entry);</p>
<p class="source-code">            if(contains){return (WeatherForecast)entry;}</p>
<p class="source-code">            </p>
<p class="source-code">            var forecastDto = await _provider.GetCurrent(_city);</p>
<p class="source-code">            var forecast = _mapper.Map&lt;WeatherForecast&gt;(forecastDto);</p>
<p class="source-code">            forecast.Date = DateTime.UtcNow;</p>
<p class="source-code">            _cache.Set(DateTime.UtcNow.ToString(DateFormat), forecast);</p>
<p class="source-code">            return forecast;</p>
<p class="source-code">        }</p>
<p>This method, just like the preceding one, first tries to get a value from the cache. If the value exists, then the method returns a value. However, if the value does not exist, the method calls the API for the preconfigured city, maps the DTO forecast to the model forecast, and saves it in the cache.</p>
<p>If you send an HTTP GET request to <strong class="source-inline">https://localhost:7021/WeatherForecast/</strong>, you should see the following response:</p>
<p class="source-code">{"date":"2021-09-21T20:17:47.410549Z","temperatureC":25,"temperatureF":76,"summary":"clear sky"}</p>
<p>Calling the same endpoint results in the same response. However, the response times are significantly faster due to the cache being used rather than repeating a call to the forecast API.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/GMFmm">https://packt.link/GMFmm</a>.</p>
<p>This concludes the theoretical portion of this topic. In the following section, you will put this into practice with an exercise.</p>
<h2 id="_idParaDest-344"><a id="_idTextAnchor391"/>Exercise 9.03: Performing File Operations by Calling Azure Blob Storage</h2>
<p>A common task with a Web API is to perform a variety of operations on files, such as download, upload, or delete. In this exercise, you will reuse a portion of <strong class="source-inline">FilesClient</strong> from <em class="italic">Activity 8.04</em> of <em class="italic">Chapter 8</em>, <em class="italic">Building Quality Object-Oriented Code</em>, to serve as a baseline client for calling Azure Blob storage and call its methods via REST endpoints to do the following operations on a file:</p>
<ul>
<li>Download a file.</li>
<li>Get a shareable link with expiration time.</li>
<li>Upload a file.</li>
<li>Delete a file.</li>
</ul>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">Extract an interface for <strong class="source-inline">FilesClient</strong> and call it <strong class="source-inline">IFilesService</strong>:<p class="source-code">public interface IFilesService</p><p class="source-code">    {</p><p class="source-code">        Task Delete(string name);</p><p class="source-code">        Task Upload(string name, Stream content);</p><p class="source-code">        Task&lt;byte[]&gt; Download(string filename);</p><p class="source-code">        Uri GetDownloadLink(string filename);</p><p class="source-code">    }</p></li>
</ol>
<p>The new interface is simplified as you will work on a single container. However, as per the requirements, you have added a few new methods: <strong class="source-inline">Delete</strong>, <strong class="source-inline">Upload</strong>, <strong class="source-inline">Download</strong>, and <strong class="source-inline">GetDownloadLink</strong>. The <strong class="source-inline">Download</strong> method is for downloading a file in its raw form—that is, bytes.</p>
<ol>
<li value="2">Create a new class called <strong class="source-inline">Exercises/Exercise03/FilesService.cs</strong>.</li>
<li>Copy the following parts of <a href="https://packt.link/XC9qG%20">https://packt.link/XC9qG </a>there.</li>
<li>Rename <strong class="source-inline">Client</strong> to <strong class="source-inline">Service</strong>.</li>
<li>Also change the <strong class="source-inline">Exercise04</strong> reference (used in <em class="italic">Chapter 8</em>, <em class="italic">Building Quality Object-Oriented Code</em>) to <strong class="source-inline">Exercise03</strong> (a new one to be used for this chapter):<p class="source-code-heading">FilesService.cs</p><p class="source-code">public class FilesService : IFilesService</p><p class="source-code">    {</p><p class="source-code">        private readonly BlobServiceClient _blobServiceClient;</p><p class="source-code">        private readonly BlobContainerClient _defaultContainerClient;</p><p class="source-code">        public FilesClient()</p><p class="source-code">        {</p><p class="source-code">            var endpoint = "https://packtstorage2.blob.core.windows.net/";</p><p class="source-code">            var account = "packtstorage2";</p><p class="source-code">            var key = Environment.GetEnvironmentVariable("BlobStorageKey", EnvironmentVariableTarget.User);</p><p class="source-code">            var storageEndpoint = new Uri(endpoint);</p><p class="source-code">            var storageCredentials = new StorageSharedKeyCredential(account, key);</p><p class="source-code">            _blobServiceClient = new BlobServiceClient(storageEndpoint, storageCredentials);</p><p class="source-code">            _defaultContainerClient = CreateContainerIfNotExists("Exercise03).Result;</p><p class="source-code">        }</p><p class="source-code">        private async Task&lt;BlobContainerClient&gt; CreateContainerIfNotExists(string container)</p></li>
</ol>
<p class="source-code-link">You can find the complete code here: <a href="https://packt.link/fNQAX">https://packt.link/fNQAX</a>.</p>
<p>The constructor initializes <strong class="source-inline">blobServiceClient</strong> to get <strong class="source-inline">blobClient</strong>, which allows you to do operations in the <em class="italic">Exercice03</em> directory in the Azure Blob Storage Account. If the folder doesn't exist, <strong class="source-inline">blobServiceClient</strong> will create it for you:</p>
<p class="source-code">        {</p>
<p class="source-code">            var lowerCaseContainer = container.ToLower();</p>
<p class="source-code">            var containerClient = _blobServiceClient.GetBlobContainerClient(lowerCaseContainer);</p>
<p class="source-code">            if (!await containerClient.ExistsAsync())</p>
<p class="source-code">            {</p>
<p class="source-code">                containerClient = await _blobServiceClient.CreateBlobContainerAsync(lowerCaseContainer);</p>
<p class="source-code">            }</p>
<p class="source-code">            return containerClient;</p>
<p class="source-code">        }</p>
<p class="callout-heading">Note</p>
<p class="callout">For the preceding step to work, you will need an Azure Storage Account. So, refer to <em class="italic">Activity 8.04</em> of <em class="italic">Chapter 8</em>, <em class="italic">Building Quality Object-Oriented Code</em>.</p>
<ol>
<li value="6">Create the <strong class="source-inline">ValidateFileExists</strong> method to validate whether a file exists in the storage, else throw an exception (a small helper method that did not exist before):<p class="source-code">private static void ValidateFileExists(BlobClient blobClient)</p><p class="source-code">{</p><p class="source-code">    if (!blobClient.Exists())</p><p class="source-code">    {</p><p class="source-code">        throw new FileNotFoundException($"File {blobClient.Name} in default blob storage not found.");</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Now, create the <strong class="source-inline">Delete</strong> method to delete a file:<p class="source-code">public Task Delete(string name)</p><p class="source-code">{</p><p class="source-code">    var blobClient = _defaultContainerClient.GetBlobClient(name);</p><p class="source-code">    ValidateFileExists(blobClient);</p><p class="source-code">    return blobClient.DeleteAsync();</p><p class="source-code">}</p></li>
</ol>
<p>Here, you will first get a client for the file and then check whether the file exists. If not, then you will throw a <strong class="source-inline">FileNotFoundException</strong> exception. If the file exists, then you will delete the file.</p>
<ol>
<li value="8">Create the <strong class="source-inline">UploadFile</strong> method to upload a file:<p class="source-code">public Task UploadFile(string name, Stream content)</p><p class="source-code">{</p><p class="source-code">    var blobClient = _defaultContainerClient.GetBlobClient(name);</p><p class="source-code">    return blobClient.UploadAsync(content, headers);</p><p class="source-code">}</p></li>
</ol>
<p>Once again, you first get a client that allows you to perform operations on a file. Then, feed the content and headers to it to upload.</p>
<ol>
<li value="9">Create the <strong class="source-inline">Download</strong> method to download a file in bytes:<p class="source-code">        public async Task&lt;byte[]&gt; Download(string filename)</p><p class="source-code">        {</p><p class="source-code">            var blobClient = _defaultContainerClient.GetBlobClient(filename);</p><p class="source-code">            var stream = new MemoryStream();</p><p class="source-code">            await blobClient.DownloadToAsync(stream);</p><p class="source-code">            return stream.ToArray();</p><p class="source-code">        }</p></li>
</ol>
<p>This method creates a memory stream and downloads the file to it. Please note that this is not going to work on large files.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you would like to learn more on how to process large files, please refer to <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming">https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming</a>.</p>
<p>There is a way to present raw downloaded bytes as an image or JSON, rather than as generic downloadable content. With an HTTP request or response, you can send a header specifying the way the content should be interpreted. This header is called Content-Type. Each application will process this differently. In the context of Swagger, <strong class="source-inline">image/png</strong> will be displayed as an image, while <strong class="source-inline">application/json</strong> will be shown as JSON.</p>
<ol>
<li value="10">Create a <strong class="source-inline">GetUri</strong> method to get a URI of <strong class="source-inline">blobClient</strong>:<p class="source-code">        private Uri GetUri(BlobClient blobClient)</p><p class="source-code">        {</p><p class="source-code">            var sasBuilder = new BlobSasBuilder</p><p class="source-code">            {</p><p class="source-code">                BlobContainerName = _defaultContainerClient.Name,</p><p class="source-code">                BlobName = blobClient.Name,</p><p class="source-code">                Resource = "b",</p><p class="source-code">                ExpiresOn = DateTimeOffset.UtcNow.AddHours(1)</p><p class="source-code">            };</p><p class="source-code">            sasBuilder.SetPermissions(BlobSasPermissions.Read);</p><p class="source-code">            var sasUri = blobClient.GenerateSasUri(sasBuilder);</p><p class="source-code">            return sasUri;</p><p class="source-code">        }</p></li>
</ol>
<p>Getting a URI requires the use of <strong class="source-inline">BlobSasBuilder</strong>, through which you can generate a shareable URL to a blob. Through the builder, specify the kind of resource you are trying to share (<strong class="source-inline">"b"</strong> stands for blob) and the expiry time. You need to set the permissions (to read) and pass the <strong class="source-inline">sasBuilder</strong> builder to the <strong class="source-inline">blobClient</strong> client to generate <strong class="source-inline">sasUri</strong>.</p>
<ol>
<li value="11">Now, use a filename to create a file download link:<p class="source-code">        public Uri GetDownloadLink(string filename)</p><p class="source-code">        {</p><p class="source-code">            var blobClient = _defaultContainerClient.GetBlobClient(filename);</p><p class="source-code">            var url = GetUri(blobClient);</p><p class="source-code">            return url;</p><p class="source-code">        }</p></li>
<li>Inside the <strong class="source-inline">ExceptionMappingSetup</strong> class and the <strong class="source-inline">AddExceptionMappings</strong> method, add the following mapping:<p class="source-code">opt.MapToStatusCode&lt;FileNotFoundException&gt;(404);</p></li>
<li>Create an extension method to inject a module of <strong class="source-inline">FileUploadService</strong>:<p class="source-code">public static class FileUploadServiceSetup</p><p class="source-code">{</p><p class="source-code">    public static IServiceCollection AddFileUploadService(this IServiceCollection services)</p><p class="source-code">    {</p><p class="source-code">        services.AddScoped&lt;IFilesService, FilesService&gt;();</p><p class="source-code">        return services;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>An extension method is a simplified way of showing a new method to an existing interface.</p>
<ol>
<li value="14">Append it to <strong class="source-inline">services</strong> in <strong class="source-inline">Program.cs</strong> to use the <strong class="source-inline">FileUploadService</strong> module:<p class="source-code">.AddFileUploadService();</p></li>
<li>Now, create a controller for files:<p class="source-code">    [Route("api/[controller]")]</p><p class="source-code">    [ApiController]</p><p class="source-code">    public class FileController : ControllerBase</p><p class="source-code">    {</p></li>
</ol>
<p>Controller creation is standard on MVC architecture, and this allows users to access <strong class="source-inline">FileService</strong> through HTTP requests.</p>
<ol>
<li value="16">Then, inject <strong class="source-inline">IFilesService</strong> to provide an interface through which file-related functionality could be accessed:<p class="source-code">        private readonly IFilesService _filesService;</p><p class="source-code">        public FileController(IFilesService filesService)</p><p class="source-code">        {</p><p class="source-code">            _filesService = filesService;</p><p class="source-code">        }</p></li>
<li>Next, create an endpoint to delete a file:<p class="source-code">        [HttpDelete("{file}")]</p><p class="source-code">        public async Task&lt;IActionResult&gt; Delete(string file)</p><p class="source-code">        {</p><p class="source-code">            await _filesService.Delete(file);</p><p class="source-code">            return Ok();</p><p class="source-code">        }</p></li>
<li>Create an endpoint to download a file:<p class="source-code">  [HttpGet("Download/{file}")]</p><p class="source-code">        public async Task&lt;IActionResult&gt; Download(string file)</p><p class="source-code">        {</p><p class="source-code">            var content = await _filesService.Download(file);</p><p class="source-code">            return new FileContentResult(content, "application/octet-stream ");</p><p class="source-code">        }</p></li>
<li>Create an endpoint for getting a shareable file download link:<p class="source-code">        [HttpGet("Link")]</p><p class="source-code">        public IActionResult GetDownloadLink(string file)</p><p class="source-code">        {</p><p class="source-code">            var link = _filesService.GetDownloadLink(file);</p><p class="source-code">            return Ok(link);</p><p class="source-code">        }</p></li>
<li>Create an endpoint for uploading a file:<p class="source-code">        [HttpPost("upload")]</p><p class="source-code">        public async Task&lt;IActionResult&gt; Upload(IFormFile file)</p><p class="source-code">        {</p><p class="source-code">            await _filesService.UploadFile(file.FileName, file.OpenReadStream());</p><p class="source-code">            return Ok();</p><p class="source-code">        }</p></li>
</ol>
<p><strong class="source-inline">IFormFile</strong> is a common way of passing small files to a controller. However, from <strong class="source-inline">IFormFile</strong>, you need file contents as a stream. You can get this using the <strong class="source-inline">OpenReadStream</strong> method. Swagger allows you to use the File Explorer window to choose the file you want to upload.</p>
<ol>
<li value="21">Now you run the API.</li>
</ol>
<p>Your Swagger documentation will have a new section with the controller methods. Here are the responses of each:</p>
<ul>
<li>Upload file request:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer225">
<img alt="Figure 9.27: Upload file request in Swagger " height="769" src="image/B16835_09_27.jpg" width="1275"/>
</div>
</div>
<p class="figure-caption">Figure 9.27: Upload file request in Swagger</p>
<ul>
<li>Upload file response:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer226">
<img alt="Figure 9.28: Upload file response in Swagger " height="298" src="image/B16835_09_28.jpg" width="1015"/>
</div>
</div>
<p class="figure-caption">Figure 9.28: Upload file response in Swagger</p>
<ul>
<li>Get download link request:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer227">
<img alt="Figure 9.29: Get download link request in Swagger " height="564" src="image/B16835_09_29.jpg" width="1084"/>
</div>
</div>
<p class="figure-caption">Figure 9.29: Get download link request in Swagger</p>
<ul>
<li>Get download link response:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer228">
<img alt="Figure 9.30: Get download link response in Swagger " height="501" src="image/B16835_09_30.jpg" width="1023"/>
</div>
</div>
<p class="figure-caption">Figure 9.30: Get download link response in Swagger</p>
<ul>
<li>Download file request:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer229">
<img alt="Figure 9.31: Download file request in Swagger " height="542" src="image/B16835_09_31.jpg" width="1072"/>
</div>
</div>
<p class="figure-caption">Figure 9.31: Download file request in Swagger</p>
<ul>
<li>Download file response:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer230">
<img alt="Figure 9.32: Download file response in Swagger " height="404" src="image/B16835_09_32.jpg" width="1013"/>
</div>
</div>
<p class="figure-caption">Figure 9.32: Download file response in Swagger</p>
<ul>
<li>Delete file request:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer231">
<img alt="Figure 9.33: Delete file request in Swagger " height="551" src="image/B16835_09_33.jpg" width="1065"/>
</div>
</div>
<p class="figure-caption">Figure 9.33: Delete file request in Swagger</p>
<ul>
<li>Delete file response:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer232">
<img alt="Figure 9.34: Delete file response in Swagger " height="300" src="image/B16835_09_34.jpg" width="1006"/>
</div>
</div>
<p class="figure-caption">Figure 9.34: Delete file response in Swagger</p>
<p>This exercise illustrated the remaining aspects of what you can do with a Web API.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/cTa4a">https://packt.link/cTa4a</a>.</p>
<p>The volume of functionality you can serve through the web is immense. However, this comes with its own big problem. How do you ensure that your API is consumed only by the intended identities? In the next section, you will explore how to secure a Web API.</p>
<h2 id="_idParaDest-345"><a id="_idTextAnchor392"/>Securing a Web API</h2>
<p>Every now and then, you'll hear about a major security breach on the news. In this section, you will learn how to protect a public API using AAD.</p>
<h3 id="_idParaDest-346"><a id="_idTextAnchor393"/>Azure Active Directory</h3>
<p>Azure Active Directory (AAD) is Microsoft's cloud identity and access management service that is used to sign in to well-known applications, such as Visual Studio, Office 365, and Azure, and to internal resources. AAD uses OpenID to provide user identity through a JavaScript Web Token.</p>
<h3 id="_idParaDest-347"><a id="_idTextAnchor394"/>JWT</h3>
<p>A JavaScript Web Token (JWT) is a collection of personal data encoded and sent over as a mechanism of authentication. A single field encoded in a JWT is called a claim.</p>
<h3 id="_idParaDest-348"><a id="_idTextAnchor395"/>OpenID Connect</h3>
<p>OpenID Connect (OIDC) is the protocol used for getting the ID token, which provides user identity or an access token. It's a layer on top of OAuth 2 to get an identity.</p>
<p>OAuth serves as a means of getting an access token on behalf of some user. With OIDC, you get an identity; this has a role and access comes from that role. When a user wants to log in to a website, OpenID might require them to input their credentials. This might sound exactly the same as OAuth; however, don't mix the two. OpenID is all about acquiring and verifying the user's identity and granting access coming with a role. OAuth, on the other hand, gives access to a user to do a limited set of functionalities.</p>
<p>A real-life analogy would be as follows:</p>
<ul>
<li>OpenID: You come to an airport and present your passport (which is issued by the government) confirming your role (passenger) and identity that way. You are <strong class="bold">granted</strong> a <strong class="bold">passenger</strong> role and allowed to board an airplane.</li>
<li>OAuth: You come to an airport and the staff asks you to take part in an emotional state tracking event. With your <strong class="bold">consent</strong>, the staff (<strong class="bold">others</strong>) at the airport can now track more of your personal data.</li>
</ul>
<p>The following is a summary:</p>
<ul>
<li>OpenID provides authentication and <strong class="bold">verifies who you are</strong>.</li>
<li>OAuth is authorization that allows others to do <strong class="bold">things on your behalf</strong>.</li>
</ul>
<h2 id="_idParaDest-349"><a id="_idTextAnchor396"/>Application Registration</h2>
<p>The first step in securing a Web API using Azure is to create an application registration in AAD. Perform the following steps to do so:</p>
<ol>
<li value="1">Navigate to <strong class="source-inline">Azure Active Directory</strong> by typing <strong class="source-inline">active dir</strong> in the search bar:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer233">
<img alt="Figure 9.35: Azure Active Directory being searched in portal.azure " height="795" src="image/B16835_09_35.jpg" width="1299"/>
</div>
</div>
<p class="figure-caption">Figure 9.35: Azure Active Directory being searched in portal.azure</p>
<ol>
<li value="2">In the new window, click the <strong class="source-inline">App registrations</strong> option (<strong class="source-inline">1</strong>).</li>
<li>Then, click the <strong class="source-inline">New registration</strong> button (<strong class="source-inline">2</strong>):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer234">
<img alt="Figure 9.36: Azure app registration " height="452" src="image/B16835_09_36.jpg" width="1515"/>
</div>
</div>
<p class="figure-caption">Figure 9.36: Azure app registration</p>
<ol>
<li value="4">In the new window, enter <strong class="source-inline">Chapter09WebApi</strong> as the name.</li>
<li>Keep the other settings as the default and click the <strong class="source-inline">Register</strong> button:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer235">
<img alt="Figure 9.37: The new app registration named Chapter09WebApi " height="740" src="image/B16835_09_37.jpg" width="913"/>
</div>
</div>
<p class="figure-caption">Figure 9.37: The new app registration named Chapter09WebApi</p>
<ol>
<li value="6">To access an API, you need at least one scope or role. In this example, you will create a scope called <strong class="source-inline">access_as_user</strong>.</li>
<li>Scopes in general can be used to control which part of an API is accessible to you. For the scope to be available for all users, you will need to select <strong class="source-inline">Admins and users</strong>.</li>
<li>In this trivial example, given the token is valid, you will allow access to everything. So, select the <strong class="source-inline">Access all as a user</strong> option. The exact values of the other fields do not matter:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer236">
<img alt="Figure 9.38: The access_as_user scope available for all users " height="723" src="image/B16835_09_38.jpg" width="789"/>
</div>
</div>
<p class="figure-caption">Figure 9.38: The access_as_user scope available for all users</p>
<p>The first step in securing a Web API using Azure was to create an application registration in AAD. The next topic will cover how you can implement security within a Web API in .NET.</p>
<h2 id="_idParaDest-350"><a id="_idTextAnchor397"/>Implementing Web API Security</h2>
<p>This section will focus on the details of how, programmatically, you can get the token and work with it. So, first, install NuGet, which does JWT validation using the Microsoft identity platform:</p>
<p class="source-code">dotnet add package Microsoft.Identity.Web</p>
<p>In the Bootstrap folder, create the <strong class="source-inline">SecuritySetup</strong> class:</p>
<p class="source-code">    public static class SecuritySetup</p>
<p class="source-code">    {</p>
<p class="source-code">        public static IServiceCollection AddSecurity(this IServiceCollection services, IConfiguration configuration, IWebHostEnvironment env)</p>
<p class="source-code">        {</p>
<p class="source-code">            services.AddMicrosoftIdentityWebApiAuthentication(configuration);</p>
<p class="source-code">            return services;</p>
<p class="source-code">        }</p>
<p class="source-code">    }</p>
<p>Then, in <strong class="source-inline">Program.cs</strong>, append this to <strong class="source-inline">services</strong>:</p>
<p class="source-code">.AddSecurity()</p>
<p>The injected services are needed by the authorization middleware. So, add the following on an <strong class="source-inline">app</strong> to add authorization middleware:</p>
<p class="source-code">    app.UseAuthentication();</p>
<p class="source-code">    app.UseAuthorization();</p>
<p>This will be triggered on all endpoints decorated with the <strong class="source-inline">[Authorize]</strong> attribute. Make sure the preceding two lines are placed before <strong class="source-inline">app.MapControllers();</strong> or else the middleware will not be wired with your controllers.</p>
<p>Within <strong class="source-inline">appsettings.json</strong>, add the following configuration to link to your <strong class="source-inline">AzureAd</strong> security configuration:</p>
<p class="source-code">  "AzureAd": {</p>
<p class="source-code">    "Instance": "https://login.microsoftonline.com/",</p>
<p class="source-code">    "ClientId": "2d8834d3-6a27-47c9-84f1-0c9db3eeb4ba",</p>
<p class="source-code">    "TenantId": "ddd0fd18-f056-4b33-88cc-088c47b81f3e",</p>
<p class="source-code">    "Audience": "api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb"</p>
<p class="source-code">  }</p>
<p>Lastly, add the <strong class="source-inline">Authorize</strong> attribute above each controller for any kind of security you choose:</p>
<p class="source-code">    [Authorize]</p>
<p class="source-code">    [ApiController]</p>
<p class="source-code">    [RequiredScope("access_as_user")]</p>
<p class="source-code">    [Route("[controller]")]</p>
<p class="source-code">    public class WeatherForecastController : ControllerBase</p>
<p>The <strong class="source-inline">Authorize</strong> attribute is essential for any type of security implementation. This attribute will perform the generic token validation, while <strong class="source-inline">[RequiredScope("access_as_user")]</strong> will check whether the <strong class="source-inline">access_as_user</strong> scope was included or not. What you now have is a secured API. If you try calling the <strong class="source-inline">WeatherForecast</strong> endpoints, you will get a <strong class="source-inline">401 – Unauthorised</strong> error.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/ruj9o">https://packt.link/ruj9o</a>.</p>
<p>In the next section, you will learn how to generate a token through the token generator app and use it to securely access your API.</p>
<h3 id="_idParaDest-351"><a id="_idTextAnchor398"/>Token Generator App</h3>
<p>To call the API, you need to generate a token by creating a console application. Before you do that, however, you need to configure one more thing in your app registration. Your console application is considered a desktop app. So, when signing in, you need a redirect URI. This URI, returned with the code, is used to get the access token. To achieve this, perform the following steps:</p>
<ol>
<li value="1">From the left pane in AAD, select the <strong class="source-inline">Authentication</strong> option (<strong class="source-inline">1</strong>) to view all configurations with outside applications.</li>
<li>Next, click the <strong class="source-inline">Add a platform</strong> button (<strong class="source-inline">2</strong>) to configure a new application (token generator):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer237">
<img alt="Figure 9.39: Authentication window with options to configure a new application " height="515" src="image/B16835_09_39.jpg" width="1552"/>
</div>
</div>
<p class="figure-caption">Figure 9.39: Authentication window with options to configure a new application</p>
<ol>
<li value="3">In the <strong class="source-inline">Configure platforms</strong> section, select the <strong class="source-inline">Mobile and desktop applications</strong> button (<strong class="source-inline">3</strong>) to register a console application token generator:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer238">
<img alt="Figure 9.40: Selecting the Mobile and desktop applications platform for authentication " height="686" src="image/B16835_09_40.jpg" width="1163"/>
</div>
</div>
<p class="figure-caption">Figure 9.40: Selecting the Mobile and desktop applications platform for authentication</p>
<p>A new window will open on the screen.</p>
<ol>
<li value="4">Type your <strong class="source-inline">Custom redirect URIs</strong> that specify where you will return after the successful login to AAD when requesting the token. In this case, it doesn't matter so much. So, type any URL.</li>
<li>Then, click the <strong class="source-inline">Configure</strong> button (<strong class="source-inline">4</strong>):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer239">
<img alt="Figure 9.41: Configuring the redirect URI " height="486" src="image/B16835_09_41.jpg" width="1173"/>
</div>
</div>
<p class="figure-caption">Figure 9.41: Configuring the redirect URI</p>
<p>That completes the configuration of AAD. Now that you have all the infrastructure for security, build a console application to generate an access token from AAD:</p>
<ol>
<li value="1">First, create a new project called <strong class="source-inline">Chapter09.TokenGenerator</strong>. It will allow you to generate authorization tokens needed to call your API.</li>
<li>Then, make it a console app on .NET Core to keep it simple and display a generated token.</li>
<li>Add <strong class="source-inline">Microsoft.Identity.Client</strong> by running the following command:<p class="source-code">dotnet add package Microsoft.Identity.Client</p></li>
</ol>
<p>This will allow you to request a token later.</p>
<ol>
<li value="4">Next, in <strong class="source-inline">Program.cs</strong>, create a method to initialize an AAD application client. This will be used to prompt browser login, as if you were to log in to the Azure portal:<p class="source-code">static IPublicClientApplication BuildAadClientApplication()</p><p class="source-code">{</p><p class="source-code">    const string clientId = "2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb"; // Service</p><p class="source-code">    const string tenantId = "ddd0fd18-f056-4b33-88cc-088c47b81f3e";</p><p class="source-code">    const string redirectUri = "http://localhost:7022/token";</p><p class="source-code">    string authority = string.Concat("https://login.microsoftonline.com/", tenantId);</p><p class="source-code">    var application = PublicClientApplicationBuilder.Create(clientId)</p><p class="source-code">        .WithAuthority(authority)</p><p class="source-code">        .WithRedirectUri(redirectUri)</p><p class="source-code">        .Build();</p><p class="source-code">    return application;</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">The values used in the preceding code will differ, depending upon the AAD subscription.</p></li>
</ol>
<p>As you can see, the application uses the <strong class="source-inline">clientId</strong> and <strong class="source-inline">tenantId</strong> configured in AAD.</p>
<ol>
<li value="5">Create another method to use the application that requires a user login on Azure to get an auth token:<p class="source-code">static async Task&lt;string&gt; GetTokenUsingAzurePortalAuth(IPublicClientApplication application)</p><p class="source-code">{</p></li>
<li>Now, define the scopes you need:<p class="source-code">            var scopes = new[] { $"api://{clientId}/{scope}" };</p></li>
</ol>
<p>Replace <strong class="source-inline">api://{clientId}/{scope}</strong> with your own application ID URI if you are not using a default value.</p>
<ol>
<li value="7">Then, attempt to get a cached token:<p class="source-code">            AuthenticationResult result;</p><p class="source-code">            try</p><p class="source-code">            {</p><p class="source-code">                var accounts = await application.GetAccountsAsync();</p><p class="source-code">                result = await application.AcquireTokenSilent(scopes, accounts.FirstOrDefault()).ExecuteAsync();</p><p class="source-code">            }</p></li>
</ol>
<p>The cached token retrieval is required if the login was done earlier. If you haven't signed in before to get a token, you will need to log in to Azure AD:</p>
<p class="source-code">            catch (MsalUiRequiredException ex)</p>
<p class="source-code">            {</p>
<p class="source-code">                result = await application.AcquireTokenInteractive(scopes)</p>
<p class="source-code">                    .WithClaims(ex.Claims)</p>
<p class="source-code">                    .ExecuteAsync();</p>
<p class="source-code">            }</p>
<ol>
<li value="8">Return the access token as the result of a logged-in user so that you can use it later to access your APIs:<p class="source-code">            return result.AccessToken;</p></li>
<li>Now, call the two methods and print the result (using the minimal API):<p class="source-code">var application = BuildAadClientApplication();</p><p class="source-code">var token = await GetTokenUsingAzurePortalAuth(application);</p><p class="source-code">Console.WriteLine($"Bearer {token}");</p></li>
<li>Finally, when you run the token app, it will ask you to sign in:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer240">
<img alt="Figure 9.42: Sign-in request from Azure " height="685" src="image/B16835_09_42.jpg" width="1166"/>
</div>
</div>
<p class="figure-caption">Figure 9.42: Sign-in request from Azure</p>
<p>A successful sign-in redirects you to a configured redirect URI with the following message:</p>
<p class="source-code">Authentication complete. You can return to the application. Feel free to close this browser tab.</p>
<p>You will see that the token will be returned in the console window:</p>
<div>
<div class="IMG---Figure" id="_idContainer241">
<img alt="Figure 9.43: Generated token from the app registration in the console app " height="475" src="image/B16835_09_43.jpg" width="1591"/>
</div>
</div>
<p class="figure-caption">Figure 9.43: Generated token from the app registration in the console app</p>
<p>Now, you can inspect the token using the <a href="https://jwt.io/">https://jwt.io/</a> website. The following screen is displayed, showing two parts: <strong class="source-inline">Encoded</strong> and <strong class="source-inline">Decoded</strong>. The <strong class="source-inline">Decoded</strong> part is divided into the following sections:</p>
<ul>
<li><strong class="source-inline">HEADER</strong>: This contains a type of token and the algorithm used to encrypt the token.</li>
<li><strong class="source-inline">PAYLOAD</strong>: The claims encoded within the token contain information, such as who requested the token and what access has been granted:</li>
</ul>
<p> </p>
<div>
<div class="IMG---Figure" id="_idContainer242">
<img alt="Figure 9.44: Encoded and decoded JWT version on the jwt.io website  using your app registration " height="658" src="image/B16835_09_44.jpg" width="1157"/>
</div>
</div>
<p class="figure-caption">Figure 9.44: Encoded and decoded JWT version on the jwt.io website using your app registration</p>
<p>In this section, you learned how to secure an unsecured API. Security is not limited to just an authorization token. As a professional developer, you must be aware of the most common vulnerabilities in APIs. A list of the top 10 most common security issues is updated every four years based on the trends in the industry. This list is called the Open Web Application Security Project (OWASP) and can be reached at <a href="https://owasp.org/www-project-top-ten/">https://owasp.org/www-project-top-ten/</a>.</p>
<p>In the next section, you will apply the changes needed for Swagger to work with the authorization token.</p>
<h3 id="_idParaDest-352"><a id="_idTextAnchor399"/>Configuring Swagger Auth</h3>
<p>To pass an authorization header through Swagger, you will need to add some configuration. Follow these steps to do so:</p>
<ol>
<li value="1">In order to render an authorization button, add the following block of code inside the <strong class="source-inline">SwaggerSetup</strong> class, the <strong class="source-inline">AddSwagger</strong> method, and the <strong class="source-inline">services.AddSwaggerGen(cfg =&gt;</strong> section:<p class="source-code">                cfg.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme()</p><p class="source-code">                {</p><p class="source-code">                    Name = "Authorization",</p><p class="source-code">                    Type = SecuritySchemeType.ApiKey,</p><p class="source-code">                    Scheme = "Bearer",</p><p class="source-code">                    BearerFormat = "JWT",</p><p class="source-code">                    In = ParameterLocation.Header,</p><p class="source-code">                    Description = $"Example: \"Bearer YOUR_TOKEN&gt;\"",</p><p class="source-code">                });</p></li>
<li>In order to forward the value of a bearer token with an authorization header, add the following code snippet:<p class="source-code">                cfg.AddSecurityRequirement(new OpenApiSecurityRequirement</p><p class="source-code">                {</p><p class="source-code">                    {</p><p class="source-code">                        new OpenApiSecurityScheme</p><p class="source-code">                        {</p><p class="source-code">                            Reference = new OpenApiReference</p><p class="source-code">                            {</p><p class="source-code">                                Type = ReferenceType.SecurityScheme,</p><p class="source-code">                                Id = "Bearer"</p><p class="source-code">                            }</p><p class="source-code">                        },</p><p class="source-code">                        new string[] {}</p><p class="source-code">                    }</p><p class="source-code">                });</p></li>
<li>When you navigate to <a href="https://localhost:7021/index.xhtml">https://localhost:7021/index.xhtml</a>, you will see that it now contains the <strong class="source-inline">Authorize</strong> button:</li>
</ol>
<p> </p>
<div>
<div class="IMG---Figure" id="_idContainer243">
<img alt="Figure 9.45: Swagger docs with Authorize button " height="363" src="image/B16835_09_45.jpg" width="897"/>
</div>
</div>
<p class="figure-caption">Figure 9.45: Swagger docs with Authorize button</p>
<ol>
<li value="4">Click the <strong class="source-inline">Authorize</strong> button to allow you to input the bearer token:</li>
</ol>
<p> </p>
<div>
<div class="IMG---Figure" id="_idContainer244">
<img alt="Figure 9.46: Bearer token input after clicking the Authorize button " height="511" src="image/B16835_09_46.jpg" width="1096"/>
</div>
</div>
<p class="figure-caption">Figure 9.46: Bearer token input after clicking the Authorize button</p>
<ol>
<li value="5">Now, send a request:</li>
</ol>
<p> </p>
<div>
<div class="IMG---Figure" id="_idContainer245">
<img alt="Figure 9.47: Swagger-generated request with a status of 200 generated in response " height="840" src="image/B16835_09_47.jpg" width="895"/>
</div>
</div>
<p class="figure-caption">Figure 9.47: Swagger-generated request with a status of 200 generated in response</p>
<p>You will see that the authorization header is added, and the <strong class="source-inline">ok</strong> response (HTTP status code <strong class="source-inline">200</strong>) is returned.</p>
<p>In this section, you added some configuration to pass an authorization header through Swagger.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/hMc2t">https://packt.link/hMc2t</a>.</p>
<p>If you make a mistake and your token validation fails, you will get either a <strong class="source-inline">401 – unauthorized</strong> or <strong class="source-inline">403 – forbidden</strong> status code returned (often without any details). Fixing this error might be a headache. However, it is not too difficult to get more information on what went wrong. The next section provides more details.</p>
<h3 id="_idParaDest-353"><a id="_idTextAnchor400"/>Troubleshooting Token Validation Errors</h3>
<p>To simulate this scenario, try invalidating the client-id in <strong class="source-inline">appsettings.json</strong> by changing any single symbol (for example, the last letter to <strong class="source-inline">b</strong>). Run the request and see how the response is displayed as <strong class="source-inline">401</strong>, with nothing else appearing in the logs.</p>
<p>All the validations and incoming and outcoming requests can be tracked through a pipeline. All you must do is change the default minimum logged level from <strong class="source-inline">info</strong> to <strong class="source-inline">Trace</strong>. You can do this by replacing the <strong class="source-inline">appsettings.development.json</strong> file contents with the following:</p>
<p class="source-code">{</p>
<p class="source-code">  "Logging": {</p>
<p class="source-code">    "LogLevel": {</p>
<p class="source-code">      "Default": "Trace",</p>
<p class="source-code">      "Microsoft": "Trace",</p>
<p class="source-code">      "Microsoft.Hosting.Lifetime": "Trace"</p>
<p class="source-code">    }</p>
<p class="source-code">  }</p>
<p class="source-code">}</p>
<p>Do not mix <strong class="source-inline">appsettings.development.json</strong> with <strong class="source-inline">appsettings.json</strong>. The former is used for configuration as a whole and the latter overrides the configuration but only in certain environments—development (local) in this case.</p>
<p>If you run the same request again, you will now see a verbose log in the console:</p>
<p class="source-code">Audience validation failed. Audiences: 'api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb'. Did not match: validationParameters.ValidAudience: 'api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bc' or validationParameters.ValidAudiences: 'null'.</p>
<p>Inspecting it deeper reveals the error as the following:</p>
<p><strong class="source-inline">Audience validation failed; Audiences: 'api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb'. Did not match validationParameters</strong></p>
<p>This error indicates a mismatched audience configured in the JWT:</p>
<div>
<div class="IMG---Figure" id="_idContainer246">
<img alt="Figure 9.48: Token validation error with the error highlighted " height="892" src="image/B16835_09_48.jpg" width="1194"/>
</div>
</div>
<p class="figure-caption">Figure 9.48: Token validation error with the error highlighted</p>
<p>Now it is time for you to learn about the SOA architecture where components of a system are hosted as separate services.</p>
<h2 id="_idParaDest-354"><a id="_idTextAnchor401"/>Service-Oriented Architecture</h2>
<p>Software architecture has come a long way—evolving from monolithic to Service-Oriented Architecture (SOA). SOA is an architecture where major layers of applications are hosted as separate services. For example, there would be one or more Web APIs for data access, one or more Web APIs for business logic, and one or more client applications consuming it all. The flow would be like this: the client app calls the business Web API, which calls another business Web API or a data access Web API.</p>
<p>However, modern software architecture goes one step further to bring a more evolved architecture, called microservice architecture.</p>
<h3 id="_idParaDest-355"><a id="_idTextAnchor402"/>Microservice Architecture</h3>
<p>Microservice architecture is SOA with a single-responsibility principle applied. This means that, instead of service-as-a-layer, you now have hosted self-contained modules that have a single responsibility. A self-contained service has both data access and business logic layers. Instead of many services per layer, in this approach, you have many services per module.</p>
<p>The purpose of those self-contained modules is to allow multiple teams to work on different parts of the same system simultaneously without ever stepping on each other's toes. On top of that, parts in a system can be scaled and hosted independently and there is no single point of failure. Also, each team is free to use whatever technology stack they are most familiar with, as all the communication happens through HTTP calls.</p>
<p>This concludes the theoretical portion of this topic. In the following section, you will put all that you have learned into practice with an activity.</p>
<h2 id="_idParaDest-356"><a id="_idTextAnchor403"/>Activity 9.01: Implementing the File Upload Service Using Microservice Architecture</h2>
<p>A microservice should be self-contained and do just one thing. In this activity, you will sum up the steps needed for extracting a piece of code into a microservice that manages how you work with files through the web (delete, upload, and download). This should serve as an overall effective checklist of what needs to be done when creating a new microservice.</p>
<p>Perform the following steps to do this:</p>
<ol>
<li value="1">Create a new project. In this case, it will be a <strong class="source-inline">.NET Core Web API</strong> project on the .NET 6.0 framework.</li>
<li>Name it <strong class="source-inline">Chapter09.Activity.9.01</strong>.</li>
<li>Now, add the commonly used NuGet packages:<ul><li><strong class="source-inline">AutoMapper.Extensions.Microsoft.DependencyInjection</strong></li>
<li><strong class="source-inline">FluentValidation.AspNetCore</strong></li>
<li><strong class="source-inline">Hellang.Middleware.ProblemDetails</strong></li>
<li><strong class="source-inline">Microsoft.AspNetCore.Mvc.NewtonsoftJson</strong></li>
<li><strong class="source-inline">Microsoft.Identity.Web</strong></li>
<li><strong class="source-inline">Swashbuckle.AspNetCore</strong></li>
</ul></li>
<li>Next, include the Azure Blobs Client package as <strong class="source-inline">Azure.Storage.Blobs</strong>.</li>
<li>Create one or more controllers for communication with the Web API. In this case, you will move <strong class="source-inline">FileController</strong> to the <strong class="source-inline">Controllers</strong> folder.</li>
<li>In order to create one or more services for business logic, move <strong class="source-inline">FilesService</strong> to the <strong class="source-inline">Services</strong> folder and <strong class="source-inline">FileServiceSetup</strong> to the <strong class="source-inline">Bootstrap</strong> folder.</li>
<li>Then document API using XML docs and Swagger.</li>
<li>Update the <strong class="source-inline">csproj</strong> file to include XML docs.</li>
<li>Copy <strong class="source-inline">SwaggerSetup</strong> to the <strong class="source-inline">Bootstrap</strong> folder.</li>
<li>Configure <strong class="source-inline">Controllers</strong>. In this scenario, it will be a plain one-line <strong class="source-inline">services.AddControllers()</strong> under the <strong class="source-inline">ControllersConfigurationSetup</strong> class and the <strong class="source-inline">AddControllersConfiguration</strong> method.</li>
<li>Configure the problem details error mappings. In this case, there are no exceptions that you will explicitly handle. So, you will keep it as a one-liner within the <strong class="source-inline">ExceptionMappingSetup</strong> class and the <strong class="source-inline">AddExceptionMappings</strong> and <strong class="source-inline">services.AddProblemDetails()</strong> methods.</li>
<li>Secure the API.</li>
<li>Create AAD app registration for the new service. Refer to the <em class="italic">Application Registration</em> subsection in the <em class="italic">Securing the Web API</em> section.</li>
<li>Update the configuration of the new service based on the Azure AD app registration client, <strong class="source-inline">tenant</strong>, and <strong class="source-inline">app</strong> IDs.</li>
<li>Inject the needed services and configure the API pipeline.</li>
<li>Copy the <strong class="source-inline">Program</strong> class.</li>
<li>Since the <strong class="source-inline">ConfigureServices</strong> method contains extra services, you don't need to remove them. Leave the <strong class="source-inline">Configure</strong> method as is.</li>
<li>Run the service through Swagger and upload a test file. Don't forget to generate a bearer token first using the token generator app from the updated values learned earlier.</li>
<li>After that, try to get a test file that you just uploaded. You should see the status code <strong class="source-inline">200</strong>:<ul><li>Get download link request:</li>
</ul></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer247">
<img alt="Figure 9.49: Get download link request in Swagger " height="351" src="image/B16835_09_49.jpg" width="675"/>
</div>
</div>
<p class="figure-caption">Figure 9.49: Get download link request in Swagger</p>
<ul>
<li>Get download link response:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer248">
<img alt="Figure 9.50: Get download link response in Swagger " height="331" src="image/B16835_09_50.jpg" width="676"/>
</div>
</div>
<p class="figure-caption">Figure 9.50: Get download link response in Swagger</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<p>All the services that have been created so far require considerations such as hosting, scaling, and availability. In the following section, you will learn about serverless and Azure Functions.</p>
<h2 id="_idParaDest-357"><a id="_idTextAnchor404"/>Azure Functions</h2>
<p>In the preceding section, you learned that microservice architecture is a self-contained service with both data access and business logic layers. With this approach, you have many services per module. However, working with microservices, especially at the start, might seem like a hassle. It might raise doubts such as the following:</p>
<ul>
<li>What does not big enough mean?</li>
<li>Should you host on different servers or on the same machine?</li>
<li>Is another cloud hosting model better?</li>
</ul>
<p>These questions might be overwhelming. So, a simple way of calling your code through HTTP is by using Azure Functions. Azure Functions is a serverless solution that allows you to call your functions on the cloud. Serverless does not mean that there is no server; you just do not need to manage it by yourself. In this section, you will try to port <strong class="source-inline">CurrentTimeController</strong> from <em class="italic">Exercise 9.02</em> to an Azure Function.</p>
<p class="callout-heading">Note</p>
<p class="callout">Before proceeding with the steps, install Azure Functions Core Tools first using the instructions here: <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=v3%2Cwindows%2Ccsharp%2Cportal%2Cbash%2Ckeda#install-the-azure-functions-core-tools">https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=v3%2Cwindows%2Ccsharp%2Cportal%2Cbash%2Ckeda#install-the-azure-functions-core-tools</a>. Azure Functions Core Tools also requires the Azure CLI to be installed (if you want to publish an Azure Functions application and not on a server). Follow the instructions here: <a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli">https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli</a>.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li value="1">In VS Code, click the <strong class="source-inline">Extenstions</strong> icon (<strong class="source-inline">1</strong>).</li>
<li>Then search for <strong class="source-inline">azure function</strong> in the search text box (<strong class="source-inline">2</strong>).</li>
<li>Then, install the <strong class="source-inline">Azure Functions</strong> extension (<strong class="source-inline">3</strong>):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer249">
<img alt="Figure 9.51: Searching for the Azure Functions extension in VS Code " height="607" src="image/B16835_09_51.jpg" width="1176"/>
</div>
</div>
<p class="figure-caption">Figure 9.51: Searching for the Azure Functions extension in VS Code</p>
<p>A new Azure tab will appear on the left.</p>
<ol>
<li value="4">Click the new Azure tab.</li>
<li>On the new page, click the <strong class="source-inline">Add</strong> button (<strong class="source-inline">1</strong>).</li>
<li>Select the <strong class="source-inline">Create Function…</strong> option (<strong class="source-inline">2</strong>):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer250">
<img alt="Figure 9.52: The new Azure Functions extension in VS Code  with the Create Function… button " height="273" src="image/B16835_09_52.jpg" width="976"/>
</div>
</div>
<p class="figure-caption">Figure 9.52: The new Azure Functions extension in VS Code with the Create Function… button</p>
<ol>
<li value="7">In the Create Function window, select <strong class="source-inline">HTTP trigger</strong>.</li>
<li>Enter the name <strong class="source-inline">GetCurrentTime.Get</strong>.</li>
<li> Name the project where it is held <strong class="source-inline">Pact.AzFunction</strong>.</li>
<li>On the last screen, select <strong class="source-inline">anonymous</strong>.</li>
</ol>
<p>At this point, there is no need to go into too much detail about this configuration. The key point to be considered here is that the function will be reachable publicly, through HTTP requests. A new project created through these steps will include the new Azure Function.</p>
<ol>
<li value="11">Now, navigate to the root of the new project folder to run the project.</li>
<li>Next, press <strong class="source-inline">F5</strong> or click the <strong class="source-inline">Start debugging to update this list…</strong> message:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer251">
<img alt="Figure 9.53: Azure Extension window with the to-be-built project " height="193" src="image/B16835_09_53.jpg" width="1132"/>
</div>
</div>
<p class="figure-caption">Figure 9.53: Azure Extension window with the to-be-built project</p>
<p>You will notice that upon a successful build, the message changes to the function name:</p>
<div>
<div class="IMG---Figure" id="_idContainer252">
<img alt="Figure 9.54: Azure Extension window with post-build project " height="185" src="image/B16835_09_54.jpg" width="1134"/>
</div>
</div>
<p class="figure-caption">Figure 9.54: Azure Extension window with post-build project</p>
<p>The terminal output window, displayed at the bottom of VS Code, shows the following details:</p>
<div>
<div class="IMG---Figure" id="_idContainer253">
<img alt="Figure 9.55: The terminal output after a successful build " height="509" src="image/B16835_09_55.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 9.55: The terminal output after a successful build</p>
<ol>
<li value="13">Next, in VS Code Explorer, open <strong class="source-inline">GetCurrentTime.cs</strong>:</li>
<li>Note that in <em class="italic">Exercise 9.01</em>, you worked with the <strong class="source-inline">GetCurrentTime</strong> code. You will reuse the same code here:<p class="source-code">namespace Pact.Function</p><p class="source-code">{</p><p class="source-code">    public static class GetCurrentTime</p><p class="source-code">    {</p><p class="source-code">        [Function("GetCurrentTime")]</p><p class="source-code">        public static HttpResponseData Run([HttpTrigger(AuthorizationLevel.Anonymous, "get", "post")] HttpRequestData request,</p><p class="source-code">            FunctionContext executionContext)</p></li>
</ol>
<p>The template names are generated based on your configuration from before. An Azure Function is bound to an HTTP endpoint through the <strong class="source-inline">[Function("GetCurrentTime")]</strong> attribute.</p>
<p>Before you proceed, you might have noticed that, even though the function for getting the current time consumed a variable for <strong class="source-inline">timezoneid</strong>, there is no such variable here (yet). Unlike the previous REST APIs you created to pass parameters to an Azure Function, here you pass it through either a request body or query variables. The only problem here is that you will have to parse it yourself, as there are no bindings through attributes just like with the controller methods. The argument you need is just a simple string that can be passed as a query argument. This line parses the URI from the request and gets a <strong class="source-inline">timezoneId</strong> variable from the query string.</p>
<ol>
<li value="15">Use the <strong class="source-inline">timezoneId</strong> variable to get the current time in a specific zone:<p class="source-code">        {</p><p class="source-code">            var timezoneId = HttpUtility.ParseQueryString(request.Url.Query).Get("timezoneId");</p></li>
<li>Next up is the business logic. So, use the <strong class="source-inline">timezoneId</strong> variable to get the current time in a specified time zone:<p class="source-code">var timezoneInfo = TimeZoneInfo.FindSystemTimeZoneById(timezoneId);</p><p class="source-code">            var time = TimeZoneInfo.ConvertTimeFromUtc(DateTime.UtcNow, timezoneInfo);</p></li>
<li>Finally, serialize the results in <strong class="source-inline">HTTP 200 Ok</strong> as the <strong class="source-inline">text/plain</strong> content type:<p class="source-code">var response = request.CreateResponse(HttpStatusCode.OK);</p><p class="source-code">            response.Headers.Add("Content-Type", "text/plain; charset=utf-8");</p><p class="source-code">            response.WriteString(time.ToString());</p><p class="source-code">            return response;</p><p class="source-code">}</p></li>
<li>Run this code and navigate to <strong class="source-inline">http://localhost:7071/api/GetCurrentTime?timezoneId=Central%20European%20Standard%20Time</strong>.</li>
</ol>
<p>You will get the current time of that time zone, as follows:</p>
<p class="source-code">2022-08-07 16:02:03</p>
<p>You have now grasped the workings of Azure Functions—a serverless solution to call your functions on the cloud.</p>
<p>It has been a long path through this book, but with the conclusion of this final activity, you have mastered all the concepts and skills required to create your own modern C# applications.</p>
<h1 id="_idParaDest-358"><a id="_idTextAnchor405"/>Summary</h1>
<p>In this chapter, you learned how to build your own REST Web API using the ASP.NET Core Web API template. You learned how to tackle the ever-growing complexity of configuration using bootstrap classes. You were introduced to the OpenAPI standard and Swagger, a tool used for calling an API to see whether it has successfully rendered the documentation. You also delved into mapping exceptions to specific HTTP status codes, along with how to map DTOs to domain objects and vice versa. In the second half of the chapter, you practiced securing the Web API using AAD, learned the concept of microservices, and created one yourself—both through a new dedicated Web API and through an Azure Function.</p>
<p>Knowing how to create and consume Web APIs is important because that's what most of the software development is all about. You either consume or create Web APIs at some point. Even if you don't have to create one yourself, grasping the ins and outs of it will help you as a professional developer.</p>
<p>This brings a close to <em class="italic">The C# Workshop</em>. Throughout this book, you have learned the basics of programming in C#, starting with simple programs that used arithmetic and logical operators, followed by the increasingly complex concepts of clean coding, delegates and lambdas, multithreading, client and server Web APIs, and Razor Pages applications.</p>
<p>This concludes the print copy of this book, but it is not the end of your journey. Visit the GitHub repository at <a href="https://packt.link/sezEm">https://packt.link/sezEm</a> for bonus chapters—<em class="italic">Chapter 10</em>, <em class="italic">Automated Testing</em>, and <em class="italic">Chapter 11</em>, <em class="italic">Production-Ready C#: From Development to Deployment</em>—covering such topics as different forms of testing before you take an in-depth look at unit testing using Nunit (the most popular third-party testing library for C#), getting acquainted with Git and using GitHub to keep a remote backup of your code, enabling Continuous Deployment (CD) and deployment from your code to the cloud, studying the cloud using Microsoft Azure, in addition to learning how to use GitHub Actions to perform CI and CD to push application changes live in production.</p>
</div>
</div>


<div id="sbo-rt-content"><div>
<div class="Content" id="_idContainer255">
</div>
</div>
<div>
<div id="_idContainer258">
<div id="_idContainer256">
<img alt="Rayon" height="187" src="image/Jason_Hales.png" width="244"/>
</div>
<div class="Basic-Text-Frame" id="_idContainer257">
<p class="Paragraph-Style-1"><strong class="bold">Jason Hales</strong></p>
</div>
</div>
</div>
<div>
<div id="_idContainer261">
<div id="_idContainer259">
<img alt="Rayon" height="187" src="image/Almantas_Karpavicius.png" width="244"/>
</div>
<div class="Basic-Text-Frame" id="_idContainer260">
<p class="Paragraph-Style-1"><strong class="bold">Almantas Karpavicius</strong></p>
</div>
</div>
</div>
<div>
<div id="_idContainer264">
<div id="_idContainer262">
<img alt="Rayon" height="187" src="image/Mateus_Viegas.png" width="244"/>
</div>
<div class="Basic-Text-Frame" id="_idContainer263">
<p class="Paragraph-Style-1"><strong class="bold">Mateus Viegas</strong></p>
</div>
</div>
</div>
<div>
<div id="_idContainer265">
</div>
</div>
<div>
<div class="Content" id="_idContainer266">
</div>
</div>
<div class="Content" id="_idContainer268">
<h2 id="_idParaDest-359"><a id="_idTextAnchor406"/>Hey!</h2>
<p>We are Jason Hales, Almantas Karpavicius, and Mateus Viegas the authors of this book. We really hope you enjoyed reading our book and found it useful for learning C#.</p>
<p>It would really help us (and other potential readers!) if you could leave a review on Amazon sharing your thoughts on <em class="italic">The C# Workshop</em>.</p>
<p>Go to the link <a href="https://packt.link/r/1800566492">https://packt.link/r/1800566492</a>.</p>
<p>OR</p>
<p>Scan the QR code to leave your review.</p>
<div>
<div class="IMG---Figure" id="_idContainer267">
<img alt="Barcode" height="150" src="image/qrcode.jpg" width="516"/>
</div>
</div>
<p>Your review will help us to understand what's worked well in this book and what could be improved upon for future editions, so it really is appreciated.</p>
<p>Best wishes,</p>
<p>Jason Hales, Almantas Karpavicius, and Mateus Viegas</p>
</div>
<div>
<div id="_idContainer269">
<img alt="Packt Logo" height="55" src="image/Packt_Logo-1.png" width="218"/>
</div>
</div>
</div>
</body></html>