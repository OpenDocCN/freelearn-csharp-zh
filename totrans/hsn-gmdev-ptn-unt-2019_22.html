<html><head></head><body>
        

                            
                    <h1 class="header-title">Service Locator</h1>
                
            
            
                
<p class="mce-root">The Service Locator is a very straightforward pattern, and its name implies perfectly its purpose, which is locating services. In game development, services are usually game-mechanics-related systems that provide specific functionality—for example: spawners, save states, and online connectivity. Because games are mainly composed of layers of in-game systems communicating, functioning, and synchronizing with one another to simulate an interactive experience, the Service Locator creates a large number of dependencies between system components.</p>
<p class="mce-root">So, having a way for services to find one another through a central locator can streamline communication between components, while avoiding explicit references to the location of dependencies that a system might need to be able to run correctly. And that's what the Service Locator pattern offers: a global access point and registry to the core services of a program.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The basics of the Service Locator pattern</li>
<li>Implementing a global service locator that will act as a runtime linker</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>The following chapter is hands on, so you will need to have a basic understanding of Unity and C#.</p>
<p>We will be using the following Unity-specific engine and C# language concepts:</p>
<ul>
<li>Generics</li>
<li>Singleton</li>
</ul>
<p>If you are unfamiliar with these concepts, please review <a href="b8d60568-5961-4e57-b722-36028db5d1a9.xhtml">Chapter 6</a>, <em>Singleton</em>.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2U8Mb6H">http://bit.ly/2U8Mb6H</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">An overview of the Service Locator</h1>
                
            
            
                
<p>The Service Locator is a straightforward pattern and doesn't have much academic theory behind it, so we can safely say it falls into the category of pragmatic patterns. As its name implies, it locates services for a client; it achieves this by maintaining a central registry of classes that offer specific services. This registry can be updated dynamically at runtime by having services register themselves when available.</p>
<p>Another common component of the Service Locator is its local cache, which uses the same principles as the Object Pool. A Service Locator might hold instances of its most-requested services in memory to avoid using too much memory.</p>
<p>Let's review a diagram of a typical Service Locator implementation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a7a4dcba-0fc5-432d-a9e7-67707cca2edc.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As we can see, we could easily say that the <strong>Service Locator</strong> is acting like a proxy between the clients (requestors) and the service providers, and this means that the relationship between both is a decoupled one. A client will only need to call the <strong>Service Locator</strong> when it has a dependency to resolve.</p>
<p>It's important to remember that the software architecture term <em>client</em> is often used to describe a class using the functionalities of another class, or other classes—it has nothing to do with the end user of an application. Systems can be clients of other systems without any human input.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits and drawbacks</h1>
                
            
            
                
<p>The Service Locator is a young pattern; its reputation in the industry is quite limited compared to more traditional patterns.</p>
<p>The following are the benefits of using the Service Locator:</p>
<ul>
<li><strong>Runtime optimization</strong>: A Service Locator can optimize an application at runtime by dynamically detecting better libraries or components to use, depending on the context.</li>
<li><strong>Contextual run-time locators</strong>: It's possible to have multiple Service Locators in memory, each configured for a specific runtime context, such as testing, staging, and production.</li>
<li><strong>Simpler than Dependency Injection</strong>: A Service Locator is simpler to implement than a <strong>Dependency Injection</strong> (<strong>DI</strong>)-driven architecture, mainly because it's a centralized approach to managing dependencies.</li>
</ul>
<p>The following are the drawbacks of using the Service Locator:</p>
<ul>
<li><strong>Blackboxing</strong>: Services contained in the registry can become invisible to other components in a system. This approach can make it harder to detect errors or regressions.</li>
<li><strong>Security hole</strong>: Depending on the overall architecture of the code base, the Service Locator could permit the injection code that could exploit your systems.</li>
<li><strong>Globally accessible</strong>: If implemented as a Singleton, the Service Locator can suffer from the same issues of globally accessible managers and components, making them harder to unit test.</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Use case example</h1>
                
            
            
                
<p>Our use case will be straightforward, and we will not focus on a specific in-game system. Instead, we will concentrate on building a simple Service Locator that will offer the ability to <em>link</em> a client to the following services dynamically:</p>
<ul>
<li><strong>Currency converter</strong>: A service that converts in-game currency to a real-world value</li>
<li><strong>Lighting</strong> <strong>coordinator</strong>: A system that manages the lights in our scenes</li>
<li><strong>Lobby coordinator</strong>: A service that coordinates with the multiplayer lobby to set up "death matches"</li>
</ul>
<p>But, of course, we could add many available services to the registry, but for this example, we will focus on just those three.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Code example</h1>
                
            
            
                
<p>As we are going to see from the following code example, implementing a basic Service Locator is a straightforward process:</p>
<ol>
<li>Let's start by implementing the most important ingredient: the <kbd>ServiceLocator</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">using System;<br/>using System.Collections.Generic;<br/><br/>public class ServiceLocator : Singleton&lt;ServiceLocator&gt;<br/>{<br/>    private IDictionary&lt;object, object&gt; m_Services;<br/><br/>    public override void Awake()<br/>    {<br/>        base.Awake();<br/>        FillRegistry();<br/>    }<br/><br/>    private void FillRegistry()<br/>    {<br/>        m_Services = new Dictionary&lt;object, object&gt;();<br/><br/>        m_Services.Add(typeof(LobbyCoordinator), new <br/>        LobbyCoordinator());<br/>        m_Services.Add(typeof(CurrencyConverter), new <br/>        CurrencyConverter());<br/>        m_Services.Add(typeof(LightingCoordinator), new <br/>        LightingCoordinator());<br/>    }<br/><br/>    public T GetService&lt;T&gt;()<br/>    {<br/>        try<br/>        {<br/>            return (T)m_Services[typeof(T)];<br/>        }<br/>        catch<br/>        {<br/>            throw new ApplicationException("The requested service is not found.");<br/>        }<br/>    }<br/>}</pre>
<ol start="2">
<li>This version of a Service Locator has two primary responsibilities:
<ul>
<li>Managing the registry with the <kbd>FillRegistry()</kbd> function</li>
<li>Returning a specified service to the client with the <kbd>GetService(T)</kbd> function</li>
</ul>
</li>
</ol>
<p style="padding-left: 60px">Those two functions refer to the central registry that's in the form of a <kbd>Dictionary</kbd>. Of course, we could separate these responsibilities into individual classes, instead of encapsulating them inside local functions, but for this example, we are keeping it simple.</p>
<p style="padding-left: 60px">Now that we have our Service Locator set up, we can now start implementing some services for our clients.</p>
<ol start="3">
<li>Our first service is <kbd>Currencyconverter</kbd>; this is essential for modern games when we consider that they usually include an in-game purchase and lootbox mechanics:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class CurrencyConverter<br/>{<br/>    public void ConvertToUsDollar(int inGameCurrency)<br/>    {<br/>        Debug.Log("Players in-game currency is worth 100$ US");<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<ol start="4">
<li>Our second service is <kbd>LightingCoordinator</kbd>; it's responsible for managing all the lights in our scenes:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class LightingCoordinator<br/>{<br/>    public void TurnOffLights()<br/>    {<br/>        Debug.Log("Turning off all the lights.");<br/>    }<br/>}</pre>
<ol start="5">
<li>Our last service is <kbd>LobbyCoordinator</kbd>; this is responsible for making sure that our player can join an active lobby when required:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class LobbyCoordinator<br/>{<br/>    public void AddPlayerToLobby()<br/>    {<br/>        Debug.Log("Adding a player to the lobby.");<br/>    }<br/>}</pre>
<p style="padding-left: 60px">We now have three services, each with specific responsibilities, available to our clients if need be. But we have an apparent limitation: at the moment, we are adding services to the central registry only by hand, and this is, of course, not the best approach for production code; however, it is acceptable for us to test our first pass implementation of a Service Locator. Later on, as a practical exercise, it would be wise to add the option for service providers to register themselves dynamically into the service registry:</p>
<pre>    // TODO: We need to be able to fill the registry dynamically.    <br/>    private void FillRegistry()<br/>    {<br/>        m_Services = new Dictionary&lt;object, object&gt;();<br/>        m_Services.Add(typeof(LobbyCoordinator), new <br/>        LobbyCoordinator());<br/>        m_Services.Add(typeof(CurrencyConverter), new <br/>        CurrencyConverter());<br/>        m_Services.Add(typeof(LightingCoordinator), new <br/>        LightingCoordinator());<br/>    }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="6">
<li>And now, for our final class, we are going to implement the client:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class ClientServiceLocator : MonoBehaviour<br/>{<br/>    void Update()<br/>    {<br/>        if (Input.GetKeyDown("o"))<br/>        {<br/>            ServiceLocator.Instance.GetService&lt;LightingCoordinator&gt;<br/>            ().TurnOffLights();<br/>        }<br/><br/>        if (Input.GetKeyDown("c"))<br/>        {<br/>            ServiceLocator.Instance.GetService&lt;CurrencyConverter&gt;<br/>            ().ConvertToUsDollar(10);<br/>        }<br/><br/>        if (Input.GetKeyDown("l"))<br/>        {<br/>            ServiceLocator.Instance.GetService&lt;LobbyCoordinator&gt;<br/>            ().AddPlayerToLobby();<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Once we have implemented the client-side code, we can appreciate the benefits of the Service Locator. We are now able to have access to any core service of our code base without having to know the location of its class or how to initialize it. We have a global but straightforward interface that we can query from anywhere that dynamically links a client with a service while decoupling the entire process of localizing a service and initializing it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we reviewed the Service Locator, a pattern that is a global solution that can resolve the recurring challenge of managing dependencies between objects that rely on services (functionalities) that other objects offer. In its simplest form, the Service Locator decouples the relationship between a client (requester) and a service provider. But in its most advanced form, it can also optimize memory usage if extended with a local cache that will reuse instances of providers when required.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the next chapter, we will explore the DI pattern, which we could say is somewhat the opposite of the Service Locator in its approach but has a similar intent.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercise</h1>
                
            
            
                
<p>In the code example, we implemented a simple version of the Service Locator so we could have a clear overview of its core intent and design. But for an exercise, I would recommend you take this basic draft of the Service Locator and expand it into something that could be production ready, by doing the following:</p>
<ul>
<li>Encapsulate the registry and cache components into self-contained classes.</li>
<li>Implement the cache with a combination of the Factory and Prototype patterns.</li>
<li>Implement the ability for services to add themselves dynamically to the registry.</li>
<li>Write a standard interface for your service providers so you can effectively manage them.</li>
</ul>
<p>It's good practice to approach design patterns like a jazz musician approaches a melody. Once you understand the core theme of a pattern, extend it, improvise on it, and make it your own, while staying accurate to its fundamental design.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p><em>Inversion of Control Containers and the Dependency Injection</em> <em>pattern</em>, by Martin Fowler<strong><br/></strong>(<a href="https://martinfowler.com/articles/injection.html#UsingAServiceLocator">https://martinfowler.com/articles/injection.html#UsingAServiceLocator</a>)<a href="https://martinfowler.com/articles/injection.html#UsingAServiceLocator"/></p>
<p> </p>


            

            
        
    </body></html>