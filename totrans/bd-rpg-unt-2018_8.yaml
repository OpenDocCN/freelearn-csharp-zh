- en: Multiplayer Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The desire of every indie game developer is to make a multiplayer game. The
    reality is, creating multiplayer games is difficult. There are a lot of scenarios
    that you need to take into consideration as a game designer/developer. Besides
    the technical complexities that are involved in the nature of creating online
    multiplayer games, there are also game-play elements that you will need to consider.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this chapter is to give you a good overview of the out-of-box
    networking functionality using the new Unity networking paradigm. This is a complex
    topic, and as such we cannot cover everything in this chapter. A whole new book
    will be required to really dive into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, I have prepared this chapter to include one simple project,
    which will be used to illustrate the fundamentals of networking. I will then show
    you how to network-enable our own game objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Heads-up display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completing a HUD design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here we go!
  prefs: []
  type: TYPE_NORMAL
- en: Challenges of a multiplayer game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A general rule of thumb is, if you don't need to enable your game to be multiplayer,
    don't! It just adds a whole lot of complexity and extra requirements and specifications
    that you will need to start worrying about. But if you must, then you must!
  prefs: []
  type: TYPE_NORMAL
- en: 'You probably know by now that creating even the simplest multiplayer game has
    its own challenges you will need to address as the game designer. There are different
    types of online multiplayer game design, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Real-time multiplayer games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn-based multiplayer games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous multiplayer games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local multiplayer games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most challenging out of all the different types of multiplayer games is
    real-time multiplayer gaming. This is because all players have to be synchronized
    in a proper and effective way with the latest game state at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: That is, if we have Player A perform a specific action, Player B will see the
    action at the same time on his or her screen. Now, consider we have another player
    join, say Player C; Players A and B will need to synchronize with Player C, and
    in turn Player C will need to synchronize its own environment with Player A's
    and Player B's state.
  prefs: []
  type: TYPE_NORMAL
- en: Not only does the actual position/rotation of the players have to be synchronized,
    but also all of the player data. Now, imagine what will happen when you multiply
    this by 100, 1,000, or 1,000,000 connected players.
  prefs: []
  type: TYPE_NORMAL
- en: For a real-world multiplayer game, what we will cover here is not enough, and
    what Unity provides out of the box is not enough either. Chances are you will
    need to write your own server-side code to handle the player data.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can see the challenge involved in designing and developing multiplayer
    games, we can start by building our first multiplayer game.
  prefs: []
  type: TYPE_NORMAL
- en: Initial multiplayer game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to learn about multiplayer games is by looking at a simple example.
    The following project is based on the Unity networking tutorial but has been extended
    to have some other features implemented that will be helpful in the implementation
    of networking in our RPG.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental networking components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the first edition of the book, a lot of technical and architectural changes
    have occurred within the Unity engine. Networking is one of the areas that has
    improved drastically since the publication of the first edition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look and see how we can quickly get started. The first thing
    you will need to do is download the *Network Lobby* asset from the Asset Store,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00169.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is a great starting point, as we have a generic network lobby to start
    off with, so we don't have to waste time creating everything from scratch!
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to get familiar with some networking components that will be used for
    the creation of our network-enabled games. These components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Network Manager: `NetworkManager` is a high-level class that allows you to control
    the state of a networked game. It provides an interface in the editor to control
    the configuration of the network, the prefabs used for spawning, and the scenes
    to use for different network game states.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network Lobby Manager: `NetworkLobbyManager` is a specialized type of `NetworkManager`
    that provides a multiplayer lobby before entering the main play scene of the game.
    Ideal for matchmaking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network Manager HUD: This provides a default user interface for controlling
    the network state of the game. It also shows information about the current state
    of `NetworkManager` in the editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network Identity: The `NetworkIdentity` component is at the heart of the new
    networking system. This component controls an object''s network identity, and
    it makes the networking system aware of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network Transform: The `NetworkTransform` component synchronizes the movement
    of game objects across the network. This component takes authority into account,
    so `LocalPlayer` objects synchronize their position from the client to the server,
    then out to other clients. Other objects (with server authority) synchronize their
    position from the server to clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My tank networking project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is assumed that you have downloaded and imported the Network Lobby asset.
    We will be using two scenes to illustrate the concept. The first scene will be
    the lobby scene, and the second scene will be where the game will take place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create a scene, and name it `NetworkingGameLobby`. This is where
    the game will start. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00170.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: My tank network lobby
  prefs: []
  type: TYPE_NORMAL
- en: Add the `LobbyManager` prefab to the scene. Select the `LobbyManager` GameObject
    in the scene, and note the `LobbyManager` component in the Inspector window. There
    are several things to notice here. First, you will need to assign the Lobby Scene
    and the Play Scene properties. We need to assign our `NetworkingGameLobby` scene
    to the Lobby Scene property, and the `NetworkingGamePlay` scene to the Play Scene
    property. Next, you will need to assign the `Game Player` Prefab property with
    the `Player` prefab. Don't worry, we will create the `Player` prefab next. Finally,
    we need to configure the Spawn Info section, and register the prefabs (GameObjects)
    that will be spawned during game time; in our case, these will be the Bullet and
    the Enemy Tanks.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a player character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now add a simple player character. You can really use any primitive
    GameObject to represent your PC; I will create my player to take the shape of
    a simple tank. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00171.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot will illustrate the hierarchy of the `Tank` GameObject:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00172.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I will not cover how to create the GameObject, as you should be able to do that
    very easily by now. What I will cover, is how to enable the new network-enabled Tank
    GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: We will attach two network components to the `Tank` GameObject. The first one
    will be `NetworkIdentity`, which can be added by selecting the `Tank` GameObject,
    and from within the Inspector window, select Add Component | Network | Network
    Identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are done adding the component, make sure to check the Local Player
    Authority property checkbox, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00173.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Local Player Authority allows the object to be controlled by the client that
    owns it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add the `NetworkTransform` component to the Tank GameObject.
    Again, selecting the `Tank` GameObject, from the Inspector window, click Add Component
    | Network | NetworkTransform to add the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00174.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will keep the default values for the `NetworkTransform` component. With the
    exception of the rotation properties, since we are only rotating on the *Y*-axis,
    we don't have to send all XYZ information, so change that to Y (Top-Down 2D) and
    increase the interpolate Rotation field to 15, and change the Compress Ratio to
    High. You can read more about the different properties on your own using the online
    documentation. The main attribute you might want to adjust is the Network Send
    Rate.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to create a script that will allow us to control the movement
    of the Tank. Go ahead and create a new C# script and name it `MyPlayerController.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a listing of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code is straightforward, but there are some important concepts that we need
    to discuss. First and foremost, you will notice that we are inheriting from `NetworkBehaviour`
    instead of `MonoBehaviour`.
  prefs: []
  type: TYPE_NORMAL
- en: '`NetworkBehaviour` is used to work with objects with the `NetworkIdentiy` component.
    This allows you to perform network-related functions such as `Commands`, `ClientRPCs`,
    `SyncEvents`, and `SyncVars`.'
  prefs: []
  type: TYPE_NORMAL
- en: Variable synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Synchronizing variables is one of the important aspects of a multiplayer game.
    If you recall, one of the challenges of multiplayer games is the ability to make
    sure all of the key data for the game is synchronized across the server and the
    clients. This is accomplished by the `SyncVar` attribute. You will see how this
    is applied in the next script, which we will create for the health of the unity.
  prefs: []
  type: TYPE_NORMAL
- en: Network callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Network callbacks are functions that are invoked on the `NetworkBehaviour`
    script for various network events. They are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnStartServer()` is called when an object is spawned on the server, or when
    the server is started for objects in the scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnStartClient()` is called when the object is spawned on the client, or when
    the client connects to a server for objects in the scene'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnSerialize()` is called to gather state to send from the server to the clients'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDeSerialize()` is called to apply state to objects on clients'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnNetworkDestroy()` is called on clients when the server tells the object
    to be destroyed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnStartLocalPlayer()` is called on clients for player objects for the local
    client only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnRebuildObservers()` is called on the server when the set of observers for
    an object is rebuilt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnSetLocalVisibility()` is called on a host when the visibility of an object
    changes for the local client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnCheckObserver()` is called on the server to check the visibility state for
    a new client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `PlayerController.cs` script, you will notice that we are using `OnStartClient()`
    to highlight the local player by changing its material color to blue.
  prefs: []
  type: TYPE_NORMAL
- en: Sending commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commands are how clients request a function to be performed on the server. In
    a server authoritative system, clients can only do things through commands. Commands
    are run on the player object on the server that corresponds to the client that
    sent the command. This routing happens automatically, so it is impossible for
    a client to send a command for a different player.
  prefs: []
  type: TYPE_NORMAL
- en: A command must begin with the prefix "Cmd" and have the `[Command]` custom attribute
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: In our `PlayerController.cs` script, when the player fires, it sends a Command
    to the server using the `CmdFire()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Client RPC calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client RPC calls are a way for server objects to cause things to happen on client
    objects. This is the reverse direction to how commands send messages, but the
    concepts are the same. Client RPC calls, however, are not only invoked on player
    objects; they can also be invoked on any `NetworkIdentity` object. They must begin
    with the prefix "Rpc" and have the `[ClientRPC]` custom attribute.
  prefs: []
  type: TYPE_NORMAL
- en: You will see an example of this on the `Health.cs` script, which we will be
    creating next.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need a way to keep track of our player character's health. This
    will be done using a new script called `Health.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A listing of the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, in this script, we are also inheriting from `NetworkBehaviour`.
    The two main items I want to bring to your attention are the `SyncVar`, the `ClientRpc`,
    and the `Start()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: We want to synchronize the player's health across the network. To do this, we
    use the `SyncVarNetworkBehaviour`. `SyncVar` can be any basic type, not classes,
    lists, or other collections.
  prefs: []
  type: TYPE_NORMAL
- en: When the value of *SyncVar* is changed on the server, it will be sent to all
    of the ready clients in the game. When objects are spawned, they are created on
    the client with the latest state of all *SyncVars* from the server.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnStartClient()` function makes sure that each object with the `Health.cs`
    script attached to it will have the most up-to-date value to display on the health
    bar UI.
  prefs: []
  type: TYPE_NORMAL
- en: I want to take a moment and make sure I give you a crucial pointer here. Assume
    we are running a networked game session, and we have the `Host`, `Player A`, and
    `Player B` connected and going about their business. During the gameplay, `Player
    A` and `Player B` have their health value changed. Now, we have a third player
    connect to the game, `Player C`. If `Start()` is not implemented, the client for
    `Player C` will have the correct data synchronized for all of the GameObjects
    with the `Health.cs` script; however, the data will not reflect correctly on the
    UI because we need to have a trigger for that to happen. This can be handled in
    the `Start()` function, as shown in the code.
  prefs: []
  type: TYPE_NORMAL
- en: The next function is the `RpcRespawn()` function. In the `TakeDamage()` function,
    we check the health of the current GameObject. If the health drops below zero,
    we check to see if the `destroyOnDeath` Boolean variable is set. If it is not
    set, we go ahead and reset the `currentHealth` value to `maxHealth` value, and
    we use the `RpcRespawn()` method to re-spawn the player at the origin. Remember
    this function is executed on all clients!
  prefs: []
  type: TYPE_NORMAL
- en: Within the function, we check to see if the caller is the local player by checking
    the `isLocalPlayer`variable. Yes, creating a multiplayer game does get confusing!
    This will become more apparent as you start experimenting with it more.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the cannonball for the tank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a prefab that will represent our cannonballs! Very simply, create
    a sphere and make it the same size as the nozzle of your tank gun.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to attached the following components to the Canon Ball GameObject:
    `NetworkIdentity`, `NetworkTransform`, `Rigidbody`, and `Bullet.cs` scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you set the `Use Gravity` property to `False` on the `Rigidbody`
    component. Also, make sure that both Server Only and Local Player Authority properties
    are *False* on the `NetworkIdentity` component. On the `NetworkTransform` component,
    change `Network Send Rate` to `0`. Once we generate the object on the server,
    the physics will take care of the motion on each client.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script called `Bullet.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The listing for the script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All we are doing here is detecting a collision. If there is a collision, we
    get the `Health` component. If the `Health` component is not null, we call the
    `TakeDamage()` function and pass it a value.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall from the `Health.cs` script, the `TakeDamage()` function reduces
    `currentHealth` of the player, which in return is a `SyncVar` that gets updated
    on all active clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'One item we did not discuss is the idea of a `hook`. A `SyncVar` can have a
    `hook`. Think of a hook as an event handler. The hook attribute can be used to
    specify a function to be called when the `SyncVar` changes value on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnChangeHealth()` function is responsible for updating the UI canvas for
    displaying our health value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and also make a prefab of the cannonball and delete the instance from
    the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have assigned the proper prefab associations that are required
    on each script. For instance, the `Tank` GameObject's `PlayerController.cs` script
    needs a reference to the cannonball prefab, and also the canon spawn location.
    The `Health.cs` script needs a reference to the HealthBar foreground image and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the tank prefab and configuring the network lobby manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created our `Tank` GameObject and attached all of the necessary
    components and scripts to it, we need to make a prefab of it. This is because
    we will let `NetworkLobbyManger` spawn our player character, and in order for
    it to be able to do so, it needs to refer to a prefab that is a representation
    of your player character.
  prefs: []
  type: TYPE_NORMAL
- en: The `NetworkLobbyManager` has a `Spawn Info` section that you can assign the
    `Player` Prefab, determine if the `NetworkLobbyManager` can Auto Create Player
    and the `Player Spawn` Method.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a section for `Registered Spawnable` Prefabs. We need to register
    all of the GameObjects that will be spawned by the `NetworkServer`. For instance,
    the Canon Ball prefab will need to be registered here so that we can spawn it
    across the network on different clients.
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Network Lobby Manager` GameObject in the scene, and in the Inspector window
    assign the appropriate prefabs as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of how the `NetworkLobbyManager` should look at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00175.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Lobby manager
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you are ready to test out what we have built so far. Go ahead
    and create a stand-alone version of your game using the Build Settings window.
    Once you have your build ready, launch two instances of the application. We will
    use one instance to host the game, and the other to connect as a client, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00176.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot illustrates how your game instance will look when
    you run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00177.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshots illustrate how your screen will look during runtime.
    The game is created on an Android tablet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00178.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second player selects LIST SERVERS and gets available matches, and clicks
    JOIN to enter the room, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00179.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once everyone is ready, the game starts. Notice that each player has a unique
    tank color assign based on their color selection in the lobby.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, note that each client has highlighted the player
    character it controls, that is, the tank it controls. It will be difficult to
    capture the fire command, but you can go ahead and use the Space Bar to fire the
    canon, and it will be triggered accordingly on all active clients.
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice that the health of each tank will be reflected accurately
    if they do get a hit. Now we are ready to create an enemy to illustrate the non-player
    character in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the enemy tank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to add some of the non-player characters to our multiplayer demo.
    Adding the Enemy Tank will be simple as we will use our Tank prefab as a base.
    Go ahead and drop the Tank prefab into the scene, and change the name to `TankEnemy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `MyPlayerCharacter.cs` script from the GameObject. We will create
    a separate script as the controller for the enemy tank. I have also gone ahead
    and applied different material to the enemy tank so that we can visually distinguish
    which tanks will be controlled by players and which ones will be non-player. Take
    a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00180.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Enemy tank setup
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot illustrates how your `Tank` and `TankEnemy` prefabs
    should look. The main difference between the two is the controller script. Tank
    has the `MylayerController.cs` script, and `TankEnemy` has the `EnemyController.cs`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'A listing of the `EnemyController.cs` script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The script continuously searches for all players that are active in the scene
    and makes a list of them. Then it finds the closest one to itself. Once it determines
    which player is closest, it rotates to face the player.
  prefs: []
  type: TYPE_NORMAL
- en: After that, it calculates the distance between itself and the selected player;
    if the distance is shorter than the acceptable threshold, then it starts firing
    at the player. Each time the enemy tank fires, it actually calls a `[Command]`
    named `CmdFire()`.
  prefs: []
  type: TYPE_NORMAL
- en: This function is run on the server; it instantiates a cannonball prefab and
    spawns it on the network.
  prefs: []
  type: TYPE_NORMAL
- en: The `EnemyController.cs` script also has a `SyncVar` for the `playertoAttack`
    variable, with a `hook` attached as an `OnChangePlayerToAttack()` function. This,
    in turn, makes sure that all clients get updated with the latest data on each
    Enemy `Tank` GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: The `Health.cs` script works the same as it does on the `Tank` GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more item we need to cover: the spawning of the `Enemy Tanks`
    by the server. We can do this easily by creating another empty GameObject and
    naming it `Enemy Spawner`. We need to attach a `NetworkIdentity` component and
    make sure we set the `Server Only` property to `True`. This will make sure that
    only the server can instantiate the enemy objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the `EnemySpawner.cs` scripts. The listing is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code technically takes the prefab provided as the enemy tank and randomly
    spawns each enemy tank within a range over the network.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure all of your prefabs have been assigned in the Inspector window for
    both the `Enemy Spawner` GameObject and the `TankEnemy` GameObject. Create a prefab
    of your `TankEnemy` if you have not done so already, and delete it from the scene.
    Do not delete the `Enemy Spawner`.
  prefs: []
  type: TYPE_NORMAL
- en: We need to register the `TankEnemy` prefab with the `NetworkLobbyManager`. Go
    ahead and select the `Network Manager` GameObject, and from the Inspectorwindow,
    add a new Prefab to the `Registered Spawnable` Prefabs option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `Network Manager` should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00181.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Lobby Network Manager Setup
  prefs: []
  type: TYPE_NORMAL
- en: Building and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are ready to do our final test. Go ahead and build the stand-alone version
    of the project, and launch a new instance of the game. Player 1 will create the
    room, and the rest of the players will join the game, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00182.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Joining a game demo
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice that right after initialization, all of the enemy tanks
    will rotate toward the player character tank and if within range, they will start
    firing at it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates the runtime of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00183.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that while I was trying to capture the screen, the enemy tanks were merciless
    and fired at Player 4 continuously. You can see that my health bar has reduced
    drastically. You can also see that one of the enemy tanks has also received some
    damage.
  prefs: []
  type: TYPE_NORMAL
- en: I assure you that I had nothing to do with the damage taken by the enemy tank;
    it was actually caused by friendly fire. Yes, at the moment, the enemy tanks are
    not smart enough to hold fire if another team member is in the line of fire!
  prefs: []
  type: TYPE_NORMAL
- en: I will let you handle the implementation of that on your own. Shouldn't be too
    complex.
  prefs: []
  type: TYPE_NORMAL
- en: Use Raycasting to make sure there is no object between the enemy tank and the
    player prior to firing.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have just created your first multiplayer game! As mentioned
    previously, creating, maintaining, and hosting a multiplayer game is no small
    task, and covering every single aspect on how to do it is simply impossible in
    a few pages.
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is to give you the foundation and the fundamentals that you can
    take and expand upon. I would encourage you to take some time to study what we
    have just covered and do some more reading on the material, even though not much
    exists. The truth is that you will need to do a lot of experimentation and trial
    and error on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the basics, let's go ahead and apply what we have learned to
    our RPG assets.
  prefs: []
  type: TYPE_NORMAL
- en: Network-enabling RPG characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to make life easier, I have decided to create a new scene that will
    be used to test and implement our network-enabled characters. This example will
    show you how to network-enable the player character, and also how to synchronize
    the player character data such as inventory items across the network, as well
    as provide you with the ability to network-enable the non-player character and
    make it synchronize its data across the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scene for our RPG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the tank demo in the previous section, we will use two new scenes
    to illustrate the RPG networking concept here. We will create two scenes, one
    called `NetworkingMenu` and the other `DeathMatchMultiplayer`.
  prefs: []
  type: TYPE_NORMAL
- en: The `NetworkingMenu` scene is our lobby scene, so it will be exactly the same
    as the Tank Multiplayer lobby scene, with the exception that the player character
    will be replaced by the Barbarian prefab, and the `Registered Spawnable` Prefabs
    will be different. We shall see this later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `DeathMatchMultiplayer` scene, I have the following level design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00184.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Level design spawn enemy
  prefs: []
  type: TYPE_NORMAL
- en: 'Your lobby scene should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00185.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to make sure our GameObjects are network-enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Networked player character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go ahead and drag the player prefab you have created into the scene. We will
    use it as a base to create a new prefab, which will be used for the networked
    version of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and remove the existing `BarbarianCharacterController.cs` and `BarbarianCharacterCustomization.cs`
    components from the instance. We will create new scripts that are network-enabled
    and use them. Rename the `PC` GameObject instance to `PC-C6-Network`. Now make
    a prefab of the instance. You should now have a new prefab named `PC-C6-Network`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and attach the following components to the prefab: `NetworkIdentiy`,
    `NetworkTransform`, and `NetworkAnimator`, by using the `Inspector` Window and
    selecting Add Components *|* Network *|* <component name>.'
  prefs: []
  type: TYPE_NORMAL
- en: On the `NetworkIdentity` component, set `Local Player Authority` to `True`.
    On the `NetworkTransform` component, change Transform Sync Mode to Sync Rigidbody
    3D. On the `NetworkAnimator` component, you will need to drag the `Animator` components
    attached to the GameObject into the `Animator` slot.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to select the `Animator` component and drag it right down into
    the `Animator` slot on the `NetworkAnimator` components.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to create a new character controller so that it is network compatible.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script and call it `BarbarianCharacterNetworkController.cs`.
    Attach the script to the `PC-C6-Network` prefab. The new character controller
    is a stripped-down version of the original character controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The listing for it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing you should notice is that we are inheriting from `NetworkBehaviour`
    instead of `MonoBehaviour`. This is necessary if we want to enable certain network
    behaviors on the GameObject. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00186.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Level setup for RPG network
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at some of the variables that need to be synchronized across
    the network for each player character that is connected. These variables are `enemyToAttack`
    and `Health`. There are two more variables, `Shield` and `Helmet`, which we will
    discuss later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Update()` function, we need a way to check and make sure that it is
    the local player before giving the controller the chance to execute the player.
    This is done by having the following code check to see if the current client is
    the local player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will make sure that the code runs only for the current client (player).
    The rest of the code in the `Update()` function checks to see if the enemy is
    in sight, and makes sure the player character is facing the enemy to attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the player is in attack mode and the enemy is in our view, we set `enemyInSight`
    to `True` and `enemyToAttack` to the enemy GameObject, which is stored in the
    `hitAttack` variable of type `RacastHit`. The important element here is the `CmdEnemyToAttack()`
    function. The client needs to send a command to the server telling the server
    who the target of attack is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make sure that the data is registered correctly on the server and
    that it is synchronized to other clients. We also have another function, called
    `CmdEnemyTakeDamage()`, which is used to reduce the health of the enemy character
    on the server. The server then calls the `RpcEnemyTakeDamage()` function to synchronize the
    health value of the enemy across all clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This idea is a bit confusing at first, but it will be clearer as you start to
    study it more carefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have the following function to send commands to the server when the
    player dies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding functions make sure that the player character is dead and destroyed
    on all connected clients at the moment of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, the following hook functions are used by the `SyncVar` on the
    Health and `enemyToAttack` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This idea is also a bit confusing at first, but it will be clearer as you start
    to study it more carefully.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not done so already, apply and save all of your changes to your
    `PC-CC-Network` prefab.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, your character is ready to be integrated with `NetworkManager`*;* you
    can drag and drop the prefab into the `Player` Prefab slot, and build a stand-alone
    version to test out your character movement and synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Networked non-player character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the player character network-enabled prefab, we will use the non-player
    character prefab as our base to get started. Go ahead and create an instance of
    your NPC in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and remove the existing `NPC_Movement.cs` component from the prefab.
    Rename the Prefab to `B1-Network` and attach the following components to it: `NetworkIdentity`,
    `NetworkTransform`, and `NetworkAnimator`, by selecting `Add Component` *|* Network
    *|* <component name> from the Inspector window.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `NetworkIdentity` component, set `Local Player Authority` to `True`*;* in
    the `NetworkTransform` component, set `Transform Sync Mode` to `Sync Transform`;
    and for the `NetworkAnimator` component, set the `Animator` slot to the `Animator`
    controller attached to the prefab, by dragging it and dropping into the slot,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00187.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now need to create a new script for our NPC movement that is network-enabled.
    Go ahead and create a new C# script, and name it `NPC_Movement_Network.cs`. A
    listing of the scripts is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There are a few variables that have been indicated as `SyncVars`*;* these are: `die`, `distance`, `direction`, `angle`, `playerInSight`, `fieldOfViewAngle`, `calculatedAngle`, `playerToAttack`,
    and `Health`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Some of the `SyncVars` have a `hook`*;* these are `Health`, `playerToAttack`,
    `playerInSight`, and `die`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Update()` function, we check to make sure we are the server by the
    following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are the server, we use the `CmdUpdateNetwork()` and `RpcUpdateNetwork()`
    functions to perform our duties. These are just for the movement and action for
    the NPC. The key here is the `SyncVars` and `hook` functions that are used to
    synchronize the NPC data to all clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That is all we need for the NPC. Go ahead and add the script to the prefab and
    apply the changes. Save it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your new NPC prefab should have the following components attached:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing player customization and items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order for this to work, we need to perform configure and create several more
    new inventory item prefabs. I will use two inventory items to demonstrate this
    particular point.
  prefs: []
  type: TYPE_NORMAL
- en: I will use one of the `Helmet` prefabs from my inventory items. Duplicate it,
    and remove the `InventoryItemAgent.cs` component. We will create a new script
    that is network-enabled, as we did for our PC and NPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attach the following components to the instance: `NetworkIdentity` and `NetworkTransform`,
    using Add Component | Network | <component name> from the Inspector window*:*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00188.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new script named `InventoryItemAgent_Network.cs`. The listing is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: All this script does is assign the inventory item to the player character using
    the `PlayerArmourChanged()` function in the `CharacterController_Network.cs` script.
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerArmourChanged()` function uses another script we need to create that
    is network enabled, and that is the `CharacterCustomization_Network.cs` script.
    I will not list the script here as it is very long. You can look at the script
    in the code supplied with the book.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning NPCs and other items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need a way to spawn our NPC as well as the inventory items we will be using
    for the next demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: In the Hierarchy window, right-click and select Create Empty*;* this will create
    an `Empty` GameObject. Rename it `SpawnEnemy`, and add a `NetworkIdentity` component
    to it by selecting Add Component | Network | NetworkIdentity from the Inspector
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new script called `EnemySpawn_Network.cs`. The listing is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The script is very simple, as you can see. We are just referencing the GameObjects
    that represent the prefabs for the NPC and inventory items prefab.
  prefs: []
  type: TYPE_NORMAL
- en: Attach the new script to the `SpawnEnemy` prefab in the Hierarchy Window.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our network-enabled PC and NPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have all of the assets needed to test out our network-enabled
    RPG characters. There is one final step that we need to perform if you have not
    done so already.
  prefs: []
  type: TYPE_NORMAL
- en: Select the `NetworkManager` GameObject in the Hierarchy window, and from the
    Inspector window, you will need to make sure certain things have been assigned
    in the *Spawn* Info section.
  prefs: []
  type: TYPE_NORMAL
- en: '*Player Prefab* should be assigned to your player character prefab. Mine is
    named `PC-CC-Network-1`. Make sure Auto Create Player is set to `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: You will also register your NPC prefabs and other network-enabled non-character
    prefabs in the Registered Spawnable Prefabs. I have the barbarian prefab named
    `B1-Network-1` assigned, `barbarian_helmet_01_LOD0_Network`, and `shield_01_LOD0_Networ`*k*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00189.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Alright, at last, we can do a build. Let''s go ahead and make a stand-alone
    build of our game. Make sure that the current scene is in the build configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00190.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Go ahead and launch two instances of the build. Make one of them the host, and
    the other the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00191.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, we have started a client as a server and the player
    character has picked up one of the inventory items, a shield. When we connect
    the second client, it should correctly take into consideration the current state
    of all PCs and NPCs active in the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00192.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Keeping both of the instances running, use the Unity IDE to connect the third
    client. You can use the client to perform debugging on the client end, and also
    to see what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00193.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see all of the player characters and how
    they have been accurately synchronized with one another. Select B1-Network-1 GameObject
    from the Hierarchy Window, and use one of the client instances to take the player
    character and attack the NPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will pause the editor and inspect the variables and how they have been properly
    synchronized, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00194.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have witnessed, network programming is simple, but at the same time,
    it can be difficult. The difficulty lies in managing and understanding the synchronization
    of the data between all players in an efficient and meaningful way.
  prefs: []
  type: TYPE_NORMAL
- en: It can actually get a bit more involved if you are truly considering creating
    a game with a large number of clients. Unity networking will not be able to handle
    that; you will need to create your own backend server managers and messaging systems.
  prefs: []
  type: TYPE_NORMAL
- en: What we have covered in this chapter will give you a good understanding to take
    it to the next level. Keep on coding until we meet again!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at network programming using the Unity networking
    components. The main objective of the chapter was to introduce you to the fundamentals
    of networking in Unity by implementing two samples.
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by discussing some of the challenges you will face as
    a game designer and developer for a multiplayer game. One of the main questions
    raised is whether you really need to invest the time and energy to create a multiplayer
    mode for your game. Assuming you really do want or need to create a multiplayer
    game, we started by looking at the different types of multiplayer games popular
    today.
  prefs: []
  type: TYPE_NORMAL
- en: We then went on with our first example of a simplified multiplayer game. The
    multiplayer game we developed are real-time, that is, all clients are synchronized
    with one another based on the activity on each active player's state; namely,
    the position, rotation, movement, and other important data needs to be synchronized
    with all clients connected to the game session.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the fundamentals of Unity's networking components, such as the
    Network Manager, Network Manager HUD, Network Identity, and Network Transform.
    These are the base components that are used to illustrate multiplayer programming
    in Unity. Once we understood what these components are used for, we started with
    a simple sample.
  prefs: []
  type: TYPE_NORMAL
- en: We created a simple tank game that demonstrated how to put together all of the
    essential components for a multiplayer game. We created the necessary player character
    prefab with the appropriate network-enabled scripts and components. We also created
    the non-player character prefab with its own network-enabled scripts. The game
    demonstrates how to spawn, and how to synchronize between the player characters
    and non-player characters.
  prefs: []
  type: TYPE_NORMAL
- en: During the construction of the tank game, we covered how to synchronize variables
    and use network callbacks that are crucial for the development of a multiplayer
    game. We also covered what *Commands* and *ClientRPC* calls are and how to use
    them properly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we applied what we learned to the RPG characters we developed in previous
    chapters. We used the existing prefabs as a base, and extended them to include
    the networking components and create new network-enabled scripts to handle the
    character movement, character customization, and NPC movement scripts.
  prefs: []
  type: TYPE_NORMAL
- en: One of the crucial elements that we covered is the synchronization of each player
    character's inventory items visually with the rest of the players. We closed the
    chapter by testing and discussing how to debug your code on the client and the
    server while developing your multiplayer game.
  prefs: []
  type: TYPE_NORMAL
