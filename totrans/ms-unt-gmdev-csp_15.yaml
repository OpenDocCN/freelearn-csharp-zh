- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Tips and Tricks in Unity
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity 中的技巧与窍门
- en: Welcome to the concluding chapter of our journey through game development using
    C#! In this chapter, we’ll delve into advanced techniques and workflows that are
    designed to boost productivity and enhance your game development skills. We’ll
    start by exploring essential Unity Editor shortcuts, followed by time-saving code
    editor shortcuts for C# scripting. Next, we’ll dive into optimizing your prefab
    workflow and mastering the use of prefabs effectively. Moving on to advanced techniques,
    we’ll uncover the power of Scriptable Objects for data-driven development and
    delve into creating custom editors to enhance your workflow and user experience.
    Lastly, we’ll tackle troubleshooting and common challenges, mastering debugging
    tools and addressing platform-specific challenges such as mobile optimization
    and cross-platform development. Get ready to level up your game development skills
    as we navigate these productivity-boosting strategies and advanced techniques!Top
    of Form
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们使用 C# 进行游戏开发之旅的最后一章！在本章中，我们将深入探讨旨在提高生产力和提升您游戏开发技能的高级技术和工作流程。我们将从探索必要的
    Unity 编辑器快捷键开始，接着是节省时间的代码编辑器快捷键，专门针对 C# 脚本编写。接下来，我们将深入研究优化您的预制件工作流程和有效地掌握预制件的使用。在高级技术方面，我们将揭示
    Scriptable Objects 在数据驱动开发中的力量，并深入探讨创建自定义编辑器以增强工作流程和用户体验。最后，我们将解决故障排除和常见挑战，掌握调试工具并解决特定平台挑战，如移动优化和跨平台开发。准备好提升您的游戏开发技能，随着我们导航这些提高生产力的策略和高级技术！
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Productivity-boosting shortcuts with C#
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 的提高生产力快捷键
- en: Advanced techniques and workflows with C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 的高级技术和工作流程
- en: Troubleshooting and common challenges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除和常见挑战
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code files required for this chapter can be found at: [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2010](B22017_10.xhtml#_idTextAnchor157).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的所有代码文件都可以在以下位置找到：[https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2010](B22017_10.xhtml#_idTextAnchor157)。
- en: Productivity-boosting shortcuts with C#
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 的提高生产力快捷键
- en: In this section, we’ll delve into a variety of essential shortcuts and tricks
    that can significantly enhance your Unity development workflow. We’ll start by
    exploring Unity Editor shortcuts, which are vital for quickly and efficiently
    navigating Unity Editor. Next, we’ll focus on code editor shortcuts, where you’ll
    learn time-saving keyboard shortcuts specifically tailored for C# scripting in
    your preferred code editor. Following that, we’ll discuss prefab workflow optimization,
    offering tips on effectively using prefabs and shortcuts for efficient prefab
    management. Each of these topics will help streamline your development process
    and make working with Unity more efficient and productive.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨各种基本快捷键和技巧，这些技巧可以显著提高您的 Unity 开发工作流程。我们将从探索必要的 Unity 编辑器快捷键开始，这些快捷键对于快速有效地导航
    Unity 编辑器至关重要。接下来，我们将关注代码编辑器快捷键，您将学习针对您首选代码编辑器中 C# 脚本编写的节省时间的键盘快捷键。随后，我们将讨论预制件工作流程优化，提供有效使用预制件和高效预制件管理的快捷键。每个主题都将帮助简化您的开发过程，使使用
    Unity 更高效和更有生产力。
- en: Shortcuts are incredibly productive tools that help us save valuable time, which
    is crucial in our workflow.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 快捷键是极具生产力的工具，帮助我们节省宝贵的时间，这在我们的工作流程中至关重要。
- en: Unity Editor shortcuts
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity 编辑器快捷键
- en: In this subsection, we will unlock the power of Unity Editor shortcuts for efficient
    navigation and management, saving us valuable time and enhancing productivity
    in Unity development.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本子节中，我们将解锁 Unity 编辑器快捷键的强大功能，以实现高效的导航和管理，节省我们宝贵的时间，并提高 Unity 开发的生产力。
- en: Hierarchy navigation shortcuts
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层次结构导航快捷键
- en: 'First, let’s start exploring Unity’s hierarchy navigation shortcuts for organized
    and efficient editing of GameObjects in complex scenes. Let’s dive into these
    helpful shortcuts:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们开始探索 Unity 的层次结构导航快捷键，以实现复杂场景中 GameObject 的有序和高效编辑。让我们深入了解这些有用的快捷键：
- en: '*Ctrl*/*Cmd* + *Left Arrow*: Collapses the selected GameObject’s hierarchy
    in the **Hierarchy** view, as shown in the following figure:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*/*Cmd* + *左箭头*：在 **层次结构** 视图中折叠选定的 GameObject 的层次结构，如图下所示：'
- en: '![Figure 10.1 – Collapsing the selected GameObjects](img/B22017_10_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 折叠选定的 GameObject](img/B22017_10_01.jpg)'
- en: Figure 10.1 – Collapsing the selected GameObjects
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 折叠选定的 GameObject
- en: '*Ctrl*/*Cmd* + *Right Arrow*: Expands the selected GameObject’s hierarchy in
    the **Hierarchy** view, as shown in the following figure:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*/*Cmd* + *右箭头*: 在**层次结构**视图中展开选定的GameObject的层次结构，如图下所示：'
- en: '![Figure 10.2 – Expanding the selected GameObjects](img/B22017_10_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 展开选定的GameObject](img/B22017_10_02.jpg)'
- en: Figure 10.2 – Expanding the selected GameObjects
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 展开选定的GameObject
- en: Next, we’ll explore another category of shortcuts, this time focusing on GameObjects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨另一类快捷键，这次聚焦于GameObject。
- en: GameObject creation and management shortcuts
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GameObject创建和管理快捷键
- en: 'Here, we will explore Unity’s GameObject creation and management shortcuts
    for efficient creation, component addition, parenting, and hierarchy maintenance
    in scenes. Let’s dive into these productivity-enhancing shortcuts:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将探讨Unity的GameObject创建和管理快捷键，用于在场景中高效创建、添加组件、设置父对象和维持层次结构。让我们深入了解这些提高生产力的快捷键：
- en: '*Ctrl*/*Cmd* + *Shift* + *N*: Creates an empty GameObject:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*/*Cmd* + *Shift* + *N*: 创建一个空GameObject：'
- en: '![Figure 10.3 – Creating an empty GameObject](img/B22017_10_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 创建一个空GameObject](img/B22017_10_03.jpg)'
- en: Figure 10.3 – Creating an empty GameObject
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 创建一个空GameObject
- en: '*Ctrl*/*Cmd* + *Shift* + *A*: Adds a component to the selected GameObject:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*/*Cmd* + *Shift* + *A*: 向选定的GameObject添加组件：'
- en: '![Figure 10.4 – Adding a component to the selected GameObject](img/B22017_10_04.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 向选定的GameObject添加组件](img/B22017_10_04.jpg)'
- en: Figure 10.4 – Adding a component to the selected GameObject
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 向选定的GameObject添加组件
- en: '*Ctrl*/*Cmd* + *Shift* + *V*: Pastes the GameObject as a child of another GameObject:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*/*Cmd* + *Shift* + *V*: 将GameObject作为另一个GameObject的子对象粘贴：'
- en: '![Figure 10.5 – Pasting the GameObject as a child of another GameObject](img/B22017_10_05.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 将GameObject作为另一个GameObject的子对象粘贴](img/B22017_10_05.jpg)'
- en: Figure 10.5 – Pasting the GameObject as a child of another GameObject
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 将GameObject作为另一个GameObject的子对象粘贴
- en: '*Ctrl*/*Cmd* + *Shift* + *G*: Creates an empty parent for the selected GameObject:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*/*Cmd* + *Shift* + *G*: 为选定的GameObject创建一个空父对象：'
- en: '![Figure 10.6 – Creating an empty parent for a GameObject](img/B22017_10_06.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 为GameObject创建一个空父对象](img/B22017_10_06.jpg)'
- en: Figure 10.6 – Creating an empty parent for a GameObject
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 为GameObject创建一个空父对象
- en: The preceding shortcuts are just simple examples of shortcuts that can enhance
    your productivity. You can learn more shortcuts by navigating to **Shortcuts**
    (**Edit** | **Shortcuts**).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述快捷键只是提高生产力的简单示例。您可以通过导航到**快捷键**（**编辑** | **快捷键**）来学习更多快捷键。
- en: 'After navigating to **Shortcuts**, you’ll see the panel shown in *Figure 10**.7*.
    Notice the options to create profiles, categorize shortcuts in the left list,
    and modify existing shortcuts. You can also assign shortcuts for empty slots:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到**快捷键**后，您将看到如图*图10**.7*所示的面板。注意左侧列表中的创建配置文件、分类快捷键和修改现有快捷键的选项。您还可以为空槽分配快捷键：
- en: '![Figure 10.7 – The Shortcuts panel](img/B22017_10_07.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 快捷键面板](img/B22017_10_07.jpg)'
- en: Figure 10.7 – The Shortcuts panel
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 快捷键面板
- en: 'If you need to create a specific profile for your work, simply click on the
    **Create new profile..** option. This will bring up the following panel, where
    you can assign the name of the new profile:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要为工作创建特定的配置文件，只需单击**创建新配置文件..**选项。这将弹出一个面板，您可以在其中为新配置文件分配名称：
- en: '![Figure 10.8 – The Create profile panel](img/B22017_10_08.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 创建配置文件面板](img/B22017_10_08.jpg)'
- en: Figure 10.8 – The Create profile panel
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 创建配置文件面板
- en: After creating a new profile, you can modify the default shortcuts within it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新配置文件后，您可以修改其中的默认快捷键。
- en: Utilizing these Unity Editor shortcuts leads to increased productivity by reducing
    development time, allowing for more efficient use of time on essential tasks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些Unity编辑器快捷键可以减少开发时间，提高工作效率，从而更有效地利用时间在关键任务上。
- en: Now, let’s explore the time-saving Visual Studio shortcuts that can enhance
    your productivity.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索节省时间的Visual Studio快捷键，这些快捷键可以提高您的生产力。
- en: Visual Studio shortcuts
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio快捷键
- en: In this subsection, we will explore the efficiency-boosting Visual Studio shortcuts,
    which are categorized into navigation, refactoring, and code generation, to streamline
    your coding experience and enhance productivity.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将探讨提升效率的Visual Studio快捷键，这些快捷键分为导航、重构和代码生成类别，以简化您的编码体验并提高生产力。
- en: Navigation shortcuts
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航快捷键
- en: 'We’ll start by discovering a range of powerful navigation shortcuts in Visual
    Studio that are designed to streamline your coding experience and boost productivity.
    Let’s delve into these time-saving shortcuts:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从发现一系列强大的 Visual Studio 导航快捷键开始，这些快捷键旨在简化您的编码体验并提高生产力。让我们深入这些节省时间的快捷键：
- en: '*Ctrl* + *T*: Opens a search window so that you can quickly navigate to any
    file, type, or member:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl* + *T*: 打开一个搜索窗口，以便您可以快速导航到任何文件、类型或成员：'
- en: '![Figure 10.9 – The Search panel](img/B22017_10_09.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 搜索面板](img/B22017_10_09.jpg)'
- en: Figure 10.9 – The Search panel
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 搜索面板
- en: '*Ctrl* + *Shift* + *V*: Allows you to view the clipboard history so that you
    can paste previously copied items:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl* + *Shift* + *V*: 允许您查看剪贴板历史记录，以便您可以粘贴之前复制的项目：'
- en: '![Figure 10.10 – Editor’s clipboard](img/B22017_10_10.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 编辑器剪贴板](img/B22017_10_10.jpg)'
- en: Figure 10.10 – Editor’s clipboard
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 编辑器剪贴板
- en: Next, let’s explore another category of shortcuts, this time focusing on refactoring.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索另一类快捷键，这次聚焦于重构。
- en: Refactoring shortcuts
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构快捷键
- en: Let’s discover how Visual Studio’s refactoring shortcuts can help you improve
    code readability, maintainability, and overall code quality with ease. Let’s dive
    into these efficient refactoring tools!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解 Visual Studio 的重构快捷键如何帮助您轻松提高代码可读性、可维护性和整体代码质量。让我们深入这些高效的重构工具！
- en: '*Ctrl* + *R*, *R*: Renames a symbol across your code base:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl* + *R*, *R*: 在整个代码库中重命名符号：'
- en: '![Figure 10.11 – Renaming a symbol](img/B22017_10_11.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 重命名符号](img/B22017_10_11.jpg)'
- en: Figure 10.11 – Renaming a symbol
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 重命名符号
- en: '*Ctrl* + *R*, *M*: Extracts method to refactor code into a separate method:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl* + *R*, *M*: 将方法提取为重构代码到单独的方法：'
- en: '![Figure 10.12 – Extracting a method](img/B22017_10_12.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 提取方法](img/B22017_10_12.jpg)'
- en: Figure 10.12 – Extracting a method
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 提取方法
- en: Next, let’s explore another category of shortcuts, this time focusing on code
    generation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索另一类快捷键，这次聚焦于代码生成。
- en: Code generation shortcuts
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码生成快捷键
- en: 'Here, we will explore Visual Studio’s code generation shortcuts, powerful tools
    that are designed to streamline coding tasks, automate repetitive actions, and
    enhance code consistency and readability. Let’s dive into these time-saving shortcuts:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将探索 Visual Studio 的代码生成快捷键，这些强大的工具旨在简化编码任务，自动化重复性操作，并增强代码的一致性和可读性。让我们深入这些节省时间的快捷键：
- en: '*Ctrl* + *K*, *S*: Surrounds selected code with a code snippet (such as **try-catch**
    or **if-else**):'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl* + *K*, *S*: 将选定的代码包裹在一个代码片段（例如 **try-catch** 或 **if-else**）中：'
- en: '![Figure 10.13 – Surrounding selected code](img/B22017_10_13.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – 包围选定的代码](img/B22017_10_13.jpg)'
- en: Figure 10.13 – Surrounding selected code
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 包围选定的代码
- en: '*Ctrl* + *Space*: Shows IntelliSense to help autocomplete code or display suggestions
    for code completion:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl* + *Space*: 显示 IntelliSense 以帮助自动完成代码或显示代码完成的建议：'
- en: '![Figure 10.14 – Autocompleting code](img/B22017_10_14.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 自动完成代码](img/B22017_10_14.jpg)'
- en: Figure 10.14 – Autocompleting code
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 自动完成代码
- en: You can access and modify Visual Studio shortcuts by navigating to **Tools**
    | **Options** | **Environment** | **Keyboard**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过导航到 **工具** | **选项** | **环境** | **键盘** 来访问和修改 Visual Studio 的快捷键。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: These shortcuts are specifically designed for Visual Studio. To learn more about
    shortcuts for your editor, you can navigate to its **Shortcuts** panel.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些快捷键专门为 Visual Studio 设计。要了解更多关于您编辑器的快捷键，您可以导航到其 **快捷键** 面板。
- en: In conclusion, mastering Visual Studio’s powerful shortcuts for navigation,
    refactoring, and code generation is key to optimizing your coding workflow and
    achieving greater efficiency in your development projects. By exploring and utilizing
    these time-saving tools, you can enhance code readability, streamline coding tasks,
    and ultimately boost productivity in your programming endeavors.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，掌握 Visual Studio 的强大快捷键，用于导航、重构和代码生成，对于优化您的编码工作流程和提升开发项目中的效率至关重要。通过探索和利用这些节省时间的工具，您可以提高代码可读性，简化编码任务，并最终在编程工作中提高生产力。
- en: Optimizing your prefab workflow is essential for efficient Unity development,
    allowing you to streamline asset management, enhance modularity, and increase
    productivity throughout your project.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 优化预制工作流程对于高效的 Unity 开发至关重要，它允许您简化资产管理、增强模块化，并在整个项目中提高生产力。
- en: Prefab workflow optimization
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预制工作流程优化
- en: 'Prefab workflow optimization encompasses various techniques and strategies
    to effectively manage prefabs, improve reusability, and maintain consistency across
    your Unity project. The following are some techniques you can implement to improve
    your workflow:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 预制件工作流程优化包括各种技术和策略，以有效地管理预制件，提高可重用性，并在您的Unity项目中保持一致性。以下是一些您可以实施的技术，以改进您的流程：
- en: '**Prefab variants**: Use prefab variants to create variations of a base prefab
    with overridden properties or components. This allows you to maintain consistency
    while customizing specific instances of prefabs.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预制件变体**：使用预制件变体来创建具有覆盖属性或组件的基预制件的变体。这允许您在自定义特定预制件实例的同时保持一致性。'
- en: To create a prefab variant, first, select the base prefab you want to derive
    from. Then, right-click on it in the **Project** window and choose **Create**
    | **Prefab Variant**. This will create a new variant of the base prefab. You can
    customize the properties, components, and hierarchy of the variant while maintaining
    a connection to the base prefab. This allows you to make changes that are specific
    to the variant without them affecting other instances of the base prefab.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建预制件变体，首先选择您想要从中派生的基预制件。然后，在**项目**窗口中右键单击它，并选择**创建** | **预制件变体**。这将创建基预制件的新变体。您可以在保持与基预制件连接的同时自定义变体的属性、组件和层次结构。这允许您对变体进行特定更改，而不会影响基预制件的其他实例。
- en: '**Nested prefabs**: Utilize Unity’s nested prefab feature to create modular
    and reusable components with nested hierarchies. This allows for better organization
    and easier updating of complex prefab structures.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套预制件**：利用Unity的嵌套预制件功能创建具有嵌套层次结构的模块化和可重用组件。这有助于更好地组织并简化复杂预制件结构的更新。'
- en: To create a nested prefab, simply drag one prefab onto another in the Unity
    hierarchy. This will make the dragged prefab a child of the other prefab, creating
    a nested relationship. Nested prefabs allow you to encapsulate reusable components
    or objects within a parent prefab, making it easier to manage and update complex
    prefab structures. Changes that are made to nested prefabs are automatically reflected
    in all instances of the parent prefab.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建嵌套预制件，只需在Unity层次结构中将一个预制件拖放到另一个预制件上。这将使拖动的预制件成为另一个预制件的子项，创建嵌套关系。嵌套预制件允许您在父预制件内封装可重用组件或对象，使其更容易管理和更新复杂的预制件结构。对嵌套预制件所做的更改将自动反映在父预制件的所有实例中。
- en: '`ScriptableObject` asset that holds configuration data, parameters, or references
    to other assets. Then, you can apply these `ScriptableObject` assets to prefabs
    by assigning them as properties or parameters in scripts attached to the prefab
    instances. This allows for data-driven prefab customization and flexibility.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScriptableObject`资产，用于存储配置数据、参数或其他资产的引用。然后，您可以通过将它们作为属性或参数分配到附加到预制件实例的脚本中，将这些`ScriptableObject`资产应用于预制件。这允许数据驱动的预制件定制和灵活性。'
- en: '**Prefab PrefabUtility events**: Utilize **PrefabUtility** events such as **Prefab**
    **InstanceUpdatedCallback** or `PrefabUtility` events such as `PrefabInstanceUpdatedCallback`
    or `PrefabInstanceRemovedCallback` to perform custom actions or validations when
    prefabs are modified or removed in the editor. By subscribing to these events
    in your editor scripts, you can trigger custom logic or workflows based on prefab
    modifications, allowing for automated validation checks or workflow optimizations.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预制件PrefabUtility事件**：利用**PrefabUtility**事件，例如**Prefab** **InstanceUpdatedCallback**或`PrefabUtility`事件，例如`PrefabInstanceUpdatedCallback`或`PrefabInstanceRemovedCallback`，在编辑器中修改或删除预制件时执行自定义操作或验证。通过在您的编辑器脚本中订阅这些事件，您可以根据预制件的修改触发自定义逻辑或工作流程，从而实现自动验证检查或工作流程优化。'
- en: Let’s explore a practical example demonstrating the implementation of one of
    these techniques.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一个实际示例，展示这些技术中的一种实现。
- en: Updating component properties across prefab instances
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在预制件实例间更新组件属性
- en: Let’s consider a scenario where you have a large number of prefabs in your Unity
    project, and you need to update a specific component or property across all instances
    of a particular prefab in the scene. Manually updating each instance can be time-consuming
    and error-prone. However, with the use of C# scripting and Unity’s `PrefabUtility`
    API, you can automate this process efficiently.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，您在Unity项目中拥有大量预制件，并且需要更新场景中特定预制件的所有实例的特定组件或属性。手动更新每个实例可能既耗时又容易出错。然而，通过使用C#脚本和Unity的`PrefabUtility`
    API，您可以有效地自动化此过程。
- en: '*Problem*: You have a game with hundreds of enemy prefabs scattered throughout
    your scenes. Due to a gameplay change, you need to update the movement speed property
    of the `EnemyMovement` component in all enemy prefabs.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*问题*：您有一个游戏中散布在场景中的数百个敌人预制体。由于游戏玩法的变化，您需要更新所有敌人预制体中`EnemyMovement`组件的移动速度属性。'
- en: '*Solution*: You can create a C# script to iterate through all instances of
    the enemy prefab in the scenes and update the movement speed property of the `EnemyMovement`
    component programmatically, like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案*：您可以创建一个C#脚本，遍历场景中所有敌人预制体的实例，并按程序方式更新`EnemyMovement`组件的移动速度属性，如下所示：'
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s take a closer look at the `UpdateEnemyPrefabs` method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看`UpdateEnemyPrefabs`方法。
- en: 'This method is marked as static and is decorated with the `[MenuItem]` attribute,
    making it a custom menu item that can be accessed from Unity Editor’s **Tools**
    menu:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法被标记为静态，并带有`[MenuItem]`属性，使其成为可以从Unity编辑器的**工具**菜单访问的自定义菜单项：
- en: '**static void UpdateEnemyPrefabs()**: This **static** method iterates through
    all enemy prefabs located in the **Prefabs/Enemies** folder within the Unity project’s
    **Resources** directory'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**static void UpdateEnemyPrefabs()**：这个**静态**方法遍历Unity项目**Resources**目录中**Prefabs/Enemies**文件夹内的所有敌人预制体'
- en: '**GameObject[] enemyPrefabs = Resources.LoadAll<GameObject>("Prefabs/Enemies");**:
    This line loads all GameObject prefabs from the **Prefabs/Enemies** folder using
    the **Resources.LoadAll()** method'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GameObject[] enemyPrefabs = Resources.LoadAll<GameObject>("Prefabs/Enemies");**：这一行使用**Resources.LoadAll()**方法从**Prefabs/Enemies**文件夹加载所有GameObject预制体'
- en: '**foreach (GameObject prefab in enemyPrefabs) { ... }**: This **foreach** loop
    iterates through each enemy prefab that’s loaded from the **Resources** folder'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**foreach (GameObject prefab in enemyPrefabs) { ... }**：这个**foreach**循环遍历从**Resources**文件夹加载的每个敌人预制体'
- en: 'Follow these steps to utilize this component effectively and achieve the desired
    solution:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤有效地使用此组件并实现所需的解决方案：
- en: Attach the **EnemyPrefabUpdater** script to any GameObject in your scene.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**EnemyPrefabUpdater**脚本附加到场景中的任何GameObject上。
- en: Set the **newMovementSpeed** variable to the desired value for the movement
    speed property.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**newMovementSpeed**变量设置为移动速度属性的期望值。
- en: In the Editor, go to `EnemyMovement` component, and save the changes back to
    the prefabs.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，转到`EnemyMovement`组件，并将更改保存回预制体。
- en: Overall, this script provides a convenient way to update the properties of multiple
    enemy prefabs in Unity Editor with a single menu command, enhancing workflow efficiency
    and productivity.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，此脚本提供了一个方便的方法，通过单个菜单命令在Unity编辑器中更新多个敌人预制体的属性，从而提高工作流程效率和生产力。
- en: By implementing these prefab workflow optimization techniques, you can simplify
    asset management, accelerate development iterations, and ensure a more organized
    and scalable project structure in Unity.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施这些预制体工作流程优化技术，您可以简化资产管理，加速开发迭代，并确保Unity项目中更组织化和可扩展的项目结构。
- en: Let’s dive deeper into the world of Unity game development as we explore advanced
    techniques and workflows that specifically involve using C#.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解Unity游戏开发的世界，探索涉及使用C#的高级技术和工作流程。
- en: Advanced techniques and workflows with C#
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#的高级技术和工作流程
- en: In this section, we’ll delve into the details of advanced C# techniques and
    workflows within Unity, offering insights into how these strategies can enhance
    your game development process. We’ll cover several key topics, including ScriptableObjects
    and custom editors.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入了解Unity中高级C#技术和工作流程的细节，提供有关这些策略如何增强您的游戏开发过程的见解。我们将涵盖几个关键主题，包括ScriptableObjects和自定义编辑器。
- en: ScriptableObjects
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ScriptableObjects
- en: 'ScriptableObjects are dynamic assets in Unity that allow you to store and manage
    data separately from GameObject instances. They’re perfect for implementing data-driven
    systems and facilitating communication between different parts of your game. Let’s
    look at the different ways you can leverage ScriptableObjects:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ScriptableObjects是Unity中的动态资源，允许您将数据与GameObject实例分开存储和管理。它们非常适合实现数据驱动系统并促进游戏不同部分之间的通信。让我们看看您可以利用ScriptableObjects的不同方式：
- en: '**Data-driven development**:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据驱动开发**：'
- en: Use ScriptableObjects to store data such as game settings, character stats,
    item attributes, and more. This allows for easy modification and iteration without
    the need to modify code. You learned more about data-driven development in [*Chapter
    6*](B22017_06.xhtml#_idTextAnchor098), *Effective Game Data Handling and Management*
    *with C#*.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用ScriptableObjects存储数据，例如游戏设置、角色统计数据、物品属性等。这允许在不修改代码的情况下轻松修改和迭代。你可以在[*第6章*](B22017_06.xhtml#_idTextAnchor098)，*使用C#进行有效的游戏数据处理和管理*中了解更多关于数据驱动开发的内容。
- en: '**Event systems**:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件系统**：'
- en: Event-driven architectures are a powerful way to facilitate communication between
    different game elements in a decoupled manner. By using ScriptableObjects as events,
    we will create a flexible and robust system for handling interactions and triggering
    actions within our game.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事件驱动架构是一种强大的方式，可以以解耦的方式在不同游戏元素之间促进通信。通过使用ScriptableObjects作为事件，我们将创建一个灵活且健壮的系统来处理交互和触发游戏中的动作。
- en: 'The following are the benefits of event systems with ScriptableObjects:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于ScriptableObjects的事件系统的优势：
- en: '**Decoupled communication**: Event systems based on ScriptableObjects enable
    decoupled communication between different components in your game. This means
    that components can interact with each other without needing direct references,
    leading to cleaner and more modular code.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦通信**：基于ScriptableObjects的事件系统使得游戏中的不同组件之间可以实现解耦通信。这意味着组件可以相互交互，而无需直接引用，从而使得代码更加清晰和模块化。'
- en: '**Flexibility and extensibility**: ScriptableObjects provide a flexible and
    extensible way to define custom events and data structures. This allows you to
    create event types tailored to specific interactions or game mechanics, empowering
    you to design complex systems with ease.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性和可扩展性**：ScriptableObjects提供了一种灵活且可扩展的方式来定义自定义事件和数据结构。这允许你创建针对特定交互或游戏机制的事件类型，使你能够轻松设计复杂的系统。'
- en: '**Centralized event management**: By centralizing event management in ScriptableObjects,
    you can maintain a clear and organized structure for handling game events. This
    makes it easier to debug, modify, and extend your event system as your project
    evolves.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式事件管理**：通过在ScriptableObjects中集中管理事件，你可以为处理游戏事件保持一个清晰和有序的结构。这使得在项目发展过程中更容易调试、修改和扩展你的事件系统。'
- en: '**Loose coupling**: Using ScriptableObjects for event communication promotes
    loose coupling between game elements. This means that changes to one part of your
    code base are less likely to have unintended consequences on other parts, leading
    to more robust and maintainable code.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：使用ScriptableObjects进行事件通信可以促进游戏元素之间的松耦合。这意味着对代码库某一部分的更改不太可能对其他部分产生意外的后果，从而使得代码更加健壮和易于维护。'
- en: Let’s learn by considering a real scenario in a game and how we can use ScriptableObjects
    for event-driven architecture.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑游戏中的一个真实场景以及我们如何使用ScriptableObjects进行事件驱动架构来学习。
- en: 'Imagine a tower defense game where towers need to react to enemy spawns, player
    upgrades, and environmental effects. We’ll implement an event system using ScriptableObjects
    to handle these interactions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个塔防游戏，其中塔需要响应敌人生成、玩家升级和环境效果。我们将使用ScriptableObjects实现一个事件系统来处理这些交互：
- en: 'First, let’s define custom events using ScriptableObjects for enemy spawns,
    player upgrades, and environmental effects:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用ScriptableObjects为敌人生成、玩家升级和环境效果定义自定义事件：
- en: '[PRE1]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we’ll subscribe to these events within the **Tower** class and implement
    the logic to react when these events are raised:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在**Tower**类中订阅这些事件，并实现当这些事件被触发时的逻辑：
- en: '[PRE2]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we’ll raise events from related components. The **EnemySpawner**, **PlayerManager**,
    and **EnvironmentManager** classes are responsible for invoking the respective
    events:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从相关组件中触发事件。**EnemySpawner**、**PlayerManager**和**EnvironmentManager**类负责调用相应的事件：
- en: '[PRE3]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, we’ve created three custom events using ScriptableObjects:
    `EnemySpawnEvent`, `PlayerUpgradeEvent`, and `EnvironmentChangeEvent`. Each event
    encapsulates a specific game event and provides a mechanism to raise the event
    with relevant data.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用ScriptableObjects创建了三个自定义事件：`EnemySpawnEvent`、`PlayerUpgradeEvent`和`EnvironmentChangeEvent`。每个事件封装了一个特定的游戏事件，并提供了一种机制来使用相关数据触发事件。
- en: The `Tower` class subscribes to these events and implements event handlers to
    react to enemy spawns, player upgrades, and environmental changes. Other components,
    such as `EnemySpawner`, `PlayerManager`, and `EnvironmentManager`, raise these
    events when relevant actions occur in the game.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tower`类订阅了这些事件，并实现了事件处理程序以响应敌人生成、玩家升级和环境变化。其他组件，如`EnemySpawner`、`PlayerManager`和`EnvironmentManager`，在游戏中的相关动作发生时引发这些事件。'
- en: This implementation demonstrates the power of using ScriptableObjects for decoupled
    communication between game elements, enabling flexible and modular event-driven
    architectures in Unity.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现展示了使用ScriptableObjects进行游戏元素解耦通信的强大功能，使Unity中的灵活和模块化事件驱动架构成为可能。
- en: Unlocking the full potential of Unity’s editor goes beyond the default **Inspector**
    view. With custom editors, we can tailor interfaces to their exact specifications,
    enhancing productivity and user experience.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁Unity编辑器的全部潜力超出了默认的**检查器**视图。通过自定义编辑器，我们可以根据其精确规格定制界面，提高生产力和用户体验。
- en: Custom editors
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义编辑器
- en: 'Custom editors are essential for extending Unity’s editor functionality beyond
    the default **Inspector** view. They allow you to create specialized interfaces
    tailored to your specific needs, providing more efficient workflows and enhancing
    user experience. The following are advanced techniques in custom editor development:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义编辑器对于扩展Unity编辑器功能，超出默认的**检查器**视图至关重要。它们允许您创建针对特定需求的专用界面，提供更高效的流程和增强用户体验。以下是一些自定义编辑器开发的高级技术：
- en: Customizing property drawing
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制属性绘制
- en: Using scene gizmos
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用场景辅助线
- en: We will go over each of these advanced techniques in the following subsections.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的小节中逐一介绍这些高级技术。
- en: Customizing property drawing
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定制属性绘制
- en: We can customize how properties are displayed in the `[Header]`, `[Space]`,
    `[Range]`, `[TextArea]`, and others. You can also create custom property drawers
    to completely control the UI for specific data types or classes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自定义在`[Header]`、`[Space]`、`[Range]`、`[TextArea]`和其他中的属性显示方式。您还可以创建自定义属性抽屉，以完全控制特定数据类型或类的UI。
- en: 'In custom inspectors and editors, the ability to tailor how properties are
    displayed is crucial. Unity provides a variety of attributes, allowing us to create
    visually appealing and organized UIs within the **Inspector** window. I will mention
    some of these attributes and their usage here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义检查器和编辑器中，调整属性显示方式的能力至关重要。Unity提供了一系列属性，允许我们在**检查器**窗口内创建视觉上吸引人且组织有序的UI。以下我将提及一些这些属性及其用法：
- en: '**[ContextMenu("Menu Item Name")]**: This attribute is used to create custom
    context menu items that appear when right-clicking on a component or asset in
    Unity Editor. *Figures 10.15* and *10.16* demonstrate the use of this attribute
    in the editor:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[ContextMenu("菜单项名称")]**: 此属性用于在Unity编辑器中右键单击组件或资产时创建自定义上下文菜单项。*图10.15*和*图10.16*展示了在编辑器中使用此属性的方法：'
- en: '![Figure 10.15 – The ContextMenu attribute](img/B22017_10_15.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – ContextMenu属性](img/B22017_10_15.jpg)'
- en: Figure 10.15 – The ContextMenu attribute
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – ContextMenu属性
- en: '![Figure 10.16 – ContextMenu usage](img/B22017_10_16.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – ContextMenu使用](img/B22017_10_16.jpg)'
- en: Figure 10.16 – ContextMenu usage
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – ContextMenu使用
- en: '**[AddComponentMenu("MenuName/SubmenuName/ComponentName")]**: This attribute
    adds the component to a specific menu hierarchy in the **Add Component** menu.
    *Figures 10.1**7* and *10.18* demonstrate the use of this attribute in the editor:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[AddComponentMenu("菜单名/子菜单名/组件名")]**: 此属性将组件添加到**添加组件**菜单中的特定菜单层次结构。*图10.17*和*图10.18*展示了在编辑器中使用此属性的方法：'
- en: '![Figure 10.17 – The AddMenuComponent attribute](img/B22017_10_17.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17 – AddMenuComponent属性](img/B22017_10_17.jpg)'
- en: Figure 10.17 – The AddMenuComponent attribute
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 – AddMenuComponent属性
- en: '![Figure 10.18 – AddMenuComponent usage](img/B22017_10_18.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图10.18 – AddMenuComponent使用](img/B22017_10_18.jpg)'
- en: Figure 10.18 – AddMenuComponent usage
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 – AddMenuComponent使用
- en: '**[ColorUsage(bool showAlpha, bool hdr)]**: This attribute provides color picker
    options for the **Color** and **Gradient** fields in the **Inspector** view, allowing
    you to specify whether to display the alpha channel and use **high dynamic range**
    (**HDR**) colors. *Figures 10.19* and *10.20* demonstrate the use of this attribute
    in the editor:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[ColorUsage(bool showAlpha, bool hdr)]**: 此属性为**检查器**视图中的**颜色**和**渐变**字段提供颜色选择器选项，允许您指定是否显示alpha通道和使用**高动态范围**（**HDR**）颜色。*图10.19*和*图10.20*展示了在编辑器中使用此属性的方法：'
- en: '![Figure 10.19 – The ColorUsage attribute](img/B22017_10_19.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图10.19 – ColorUsage属性](img/B22017_10_19.jpg)'
- en: Figure 10.19 – The ColorUsage attribute
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19 – ColorUsage属性
- en: '![Figure 10.20 – ColorUsage usage](img/B22017_10_20.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图10.20 – ColorUsage使用](img/B22017_10_20.jpg)'
- en: Figure 10.20 – ColorUsage usage
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20 – ColorUsage使用
- en: 'While I won’t cover every attribute exhaustively, I’ll mention others for your
    awareness and encourage you to explore and utilize them as needed in your code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不会详尽地介绍每个属性，但我将提及其他一些属性以供您了解，并鼓励您根据需要探索和使用它们在代码中：
- en: '**[RequireComponent(typeof(ComponentType))]**: Automatically adds the specified
    component to the GameObject when the script is attached, ensuring that the required
    component is always present.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[RequireComponent(typeof(ComponentType))]**: 当脚本附加时自动将指定的组件添加到GameObject中，确保所需组件始终存在。'
- en: '**[Range(min, max)]**: Restricts a **float** or **int** property to a specified
    range of values, displayed as a slider in the **Inspector** view for easy value
    selection.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Range(min, max)]**: 限制**float**或**int**属性的范围，在**检查器**视图中显示为滑块，以便轻松选择值。'
- en: '**[HideInInspector]**: Completely hides the property from the **Inspector**
    view, ensuring that it is not visible or editable by the user.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[HideInInspector]**: 完全隐藏属性从**检查器**视图中，确保用户不可见或编辑。'
- en: '**[TextArea(minLines, maxLines)]**: Renders a multi-line text field in the
    **Inspector** view for string properties, with adjustable minimum and maximum
    lines for better text editing.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[TextArea(minLines, maxLines)]**: 在**检查器**视图中渲染多行文本字段，用于字符串属性，具有可调整的最小和最大行数，以便更好地进行文本编辑。'
- en: '**[Tooltip("Tooltip Text")]**: Adds a tooltip to the property in the **Inspector**
    view, providing helpful information when hovering over the property with the mouse
    cursor.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Tooltip("Tooltip Text")]**: 在**检查器**视图中的属性上添加工具提示，当鼠标光标悬停在属性上时提供有用的信息。'
- en: '**[ReadOnly]**: Renders the property as read-only in the **Inspector** view,
    preventing users from modifying its value but still displaying it for reference.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[ReadOnly]**: 在**检查器**视图中将属性渲染为只读，防止用户修改其值，但仍然显示它以供参考。'
- en: '**[Space(height)]**: Inserts vertical space of the specified height (in pixels)
    between properties in the **Inspector** view, aiding in visual separation and
    readability.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Space(height)]**: 在**检查器**视图中的属性之间插入指定高度（以像素为单位）的垂直空间，有助于视觉分离和可读性。'
- en: '**[Header("Section Name")]**: Creates a labeled header for grouping related
    properties in the **Inspector** view, enhancing organization and readability.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Header("Section Name")]**: 在**检查器**视图中创建带有标签的标题，用于分组相关的属性，增强组织和可读性。'
- en: '**[SerializeField]**: Forces Unity to serialize a private field, making it
    visible and editable in the **Inspector** view despite its access level.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[SerializeField]**: 强制Unity序列化私有字段，使其在**检查器**视图中可见并可编辑，尽管其访问级别。'
- en: '**[ExecuteInEditMode]**: Executes the script’s code in **Edit** mode, allowing
    you to perform actions or updates in the editor without entering **Play** mode.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[ExecuteInEditMode]**: 在**编辑**模式下执行脚本的代码，允许您在编辑器中执行操作或更新，而无需进入**播放**模式。'
- en: '**[Multiline(int lines)]**: Specifies that a string property should be displayed
    as a multi-line text area in the **Inspector** view, with the specified number
    of lines for text input.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Multiline(int lines)]**: 指定字符串属性应在**检查器**视图中显示为多行文本区域，具有指定的行数用于文本输入。'
- en: '**[System.Flags]**: Converts an enum into a bitmask field in the **Inspector**
    view, allowing you to select multiple enum values simultaneously using checkboxes.
    This is handy for defining multiple options at once.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[System.Flags]**: 将枚举转换为**检查器**视图中的位掩码字段，允许您使用复选框同时选择多个枚举值。这对于一次性定义多个选项非常有用。'
- en: '**[Delayed]**: Delays updating the property value until the user has finished
    editing in the **Inspector** view. This is useful for performance optimization.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[Delayed]**: 延迟更新属性值，直到用户完成在**检查器**视图中的编辑。这对于性能优化很有用。'
- en: '**[DisallowMultipleComponent]**: Restricts the GameObject to have only one
    instance of the component, preventing duplicates.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[DisallowMultipleComponent]**: 限制GameObject只能有一个组件实例，防止重复。'
- en: '**[SelectionBase]**: Highlights the GameObject in the **Hierarchy** view when
    selecting a child object, making it easier to identify in complex scenes.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[SelectionBase]**: 在选择子对象时突出显示**层次结构**视图中的GameObject，使得在复杂场景中更容易识别。'
- en: '**[ExecuteAlways]**: Forces the script to execute its methods even in **Edit**
    mode, allowing for immediate feedback during development.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[ExecuteAlways]**: 强制脚本在**编辑**模式下执行其方法，允许在开发过程中获得即时反馈。'
- en: '**[SerializeReference]**: Serializes a reference-type property, supporting
    polymorphism and inheritance in serialized objects.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[SerializeReference]**: 序列化引用类型属性，支持序列化对象中的多态性和继承。'
- en: '**[FormerlySerializedAs("OldName")]**: Renames a serialized field without losing
    its serialized data.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[FormerlySerializedAs("OldName")]**: 重命名序列化字段，而不会丢失其序列化数据。'
- en: '**[HelpURL("URL")]**: Links to online documentation or resources related to
    the property or component.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[HelpURL("URL")]**: 链接到与属性或组件相关的在线文档或资源。'
- en: '**[CanEditMultipleObjects]**: Allows you to edit multiple objects with the
    same component simultaneously in the **Inspector** view.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[CanEditMultipleObjects]**: 允许你在**检查器**视图中同时编辑具有相同组件的多个对象。'
- en: '**[RuntimeInitializeOnLoadMethod]**: Marks a method to be executed when the
    game starts or the editor is loaded.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[RuntimeInitializeOnLoadMethod]**: 标记一个在游戏开始或编辑器加载时执行的方法。'
- en: '**[ExecuteInEditMode, HelpURL("URL")]**: Combines **ExecuteInEditMode** with
    a help URL for easy access to documentation.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[ExecuteInEditMode, HelpURL("URL")]**: 将**ExecuteInEditMode**与帮助URL结合，以便轻松访问文档。'
- en: By mastering attribute customization, we can design intuitive and efficient
    inspector interfaces that enhance the editing experience and streamline workflow
    in Unity.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握属性自定义，我们可以设计直观且高效的检查器界面，从而增强编辑体验并简化Unity中的工作流程。
- en: Scene gizmos
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场景gizmos
- en: 'Scene gizmos in Unity are powerful tools for visually representing game elements,
    debugging information, and other critical data directly within the **Scene** view.
    By adding custom scene gizmos, we can enhance our workflow, improve visualization,
    and streamline the debugging process. Here are some important details to consider:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的场景gizmos是强大的工具，可以直接在**场景**视图中直观地表示游戏元素、调试信息和其他关键数据。通过添加自定义场景gizmos，我们可以增强我们的工作流程，改进可视化，并简化调试过程。以下是一些重要的考虑因素：
- en: '**Visual representation**: Gizmos allow us to visually represent game elements,
    such as vectors, rays, spheres, cubes, lines, and more, directly in the **Scene**
    view. This visual representation helps you understand the positioning, orientation,
    and behavior of objects during runtime and in the editor.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可视化表示**：Gizmos允许我们在**场景**视图中直观地表示游戏元素，如向量、光线、球体、立方体、线条等。这种可视化表示有助于您在运行时和在编辑器中理解对象的定位、朝向和行为。'
- en: '**Debugging aid**: Gizmos are powerful debugging tools that help us identify
    issues, visualize data, and debug complex systems more effectively. For example,
    we can use gizmos to display paths, boundaries, collision zones, trigger areas,
    and other critical information that aids in debugging and testing.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试辅助工具**：Gizmos是强大的调试工具，帮助我们识别问题、可视化数据，并更有效地调试复杂系统。例如，我们可以使用gizmos来显示路径、边界、碰撞区域、触发区域和其他有助于调试和测试的临界信息。'
- en: '**Enhanced workflow**: By adding custom gizmos, we can enhance our workflow
    by improving visualization, simplifying debugging tasks, and providing valuable
    insights into the game’s mechanics and interactions. This streamlined workflow
    can save time and effort during the development and testing phases.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的工作流程**：通过添加自定义的gizmos，我们可以通过改进可视化、简化调试任务以及为游戏机制和交互提供有价值的见解来增强我们的工作流程。这种简化的工作流程可以在开发和测试阶段节省时间和精力。'
- en: '**Interactive feedback**: Gizmos can provide interactive feedback during gameplay
    and editor mode, allowing us to dynamically adjust parameters, visualize changes,
    and fine-tune game elements directly in the **Scene** view. This interactive feedback
    loop fosters rapid iteration and prototyping, leading to better design decisions
    and optimized gameplay experiences.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互式反馈**：Gizmos可以在游戏和编辑器模式期间提供交互式反馈，允许我们动态调整参数、可视化更改，并在**场景**视图中直接微调游戏元素。这种交互式反馈循环促进了快速迭代和原型设计，从而带来更好的设计决策和优化的游戏体验。'
- en: Let’s showcase one of the applications of gizmos in Unity.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示Unity中gizmos的一个应用实例。
- en: 'In the following code block, the `DisplayForwardDirection` class showcases
    a method to visually represent the forward direction of a GameObject through a
    drawn ray:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，`DisplayForwardDirection`类展示了通过绘制光线来直观表示GameObject前向方向的方法：
- en: '[PRE4]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, attach the `DisplayForwardDirection` script to your desired GameObject.
    Afterward, you can customize the color or size of the ray. Refer to *Figure 20**.21*
    for an illustration of the attached component:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`DisplayForwardDirection`脚本附加到您想要的GameObject上。之后，您可以自定义光线的颜色或大小。请参考*图20*。21*来查看附加组件的说明：
- en: '![Figure 10.21 – The DisplayForwardDirection script](img/B22017_10_21.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图10.21 – DisplayForwardDirection脚本](img/B22017_10_21.jpg)'
- en: Figure 10.21 – The DisplayForwardDirection script
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.21 – DisplayForwardDirection 脚本
- en: '*Figure 20**.22* shows the ray extending in the forward direction from the
    displayed cylinder:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 20.22* 显示了从显示的圆柱体延伸出的向前方向的射线：'
- en: '![Figure 10.22 – The ray extending forward](img/B22017_10_22.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.22 – 延伸向前的射线](img/B22017_10_22.jpg)'
- en: Figure 10.22 – The ray extending forward
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22 – 延伸向前的射线
- en: In summary, leveraging custom scene gizmos in Unity significantly enhances the
    development workflow, improves debugging capabilities, optimizes game performance,
    and fosters better communication and collaboration among team members. Integrating
    scene gizmos effectively can lead to more efficient development cycles and higher-quality
    games.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，利用 Unity 中的自定义场景图示显著提高了开发工作流程，改善了调试能力，优化了游戏性能，并促进了团队成员之间更好的沟通和协作。有效地集成场景图示可以导致更高效的开发周期和更高质量的游戏。
- en: By integrating these advanced techniques and workflows into your Unity projects,
    you’ll not only expand your skills but also unlock new possibilities for creating
    engaging and immersive gaming experiences.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些高级技术和工作流程集成到您的 Unity 项目中，您不仅可以扩展您的技能，还可以解锁创建引人入胜和沉浸式游戏体验的新可能性。
- en: Navigating the complexities of game development often involves encountering
    troubleshooting and common challenges that require adept problem-solving skills.
    We’ll consider this in the following section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中导航复杂性通常涉及遇到故障排除和常见挑战，需要熟练的问题解决技能。我们将在下一节中考虑这一点。
- en: Troubleshooting and common challenges
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除和常见挑战
- en: In this section, we’ll delve into essential debugging techniques and strategies
    to help you identify and resolve errors effectively. Additionally, we’ll explore
    platform-specific challenges, focusing on mobile optimization, cross-platform
    development, and the intricacies of targeting diverse gaming platforms.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究基本的调试技术和策略，以帮助您有效地识别和解决错误。此外，我们还将探讨特定平台挑战，重点关注移动优化、跨平台开发和针对不同游戏平台的复杂性。
- en: Let’s start with debugging, which is an essential skill in game development,
    allowing developers to identify and fix errors in their code effectively.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从调试开始，这是游戏开发中的一个基本技能，它允许开发者有效地识别和修复代码中的错误。
- en: Debugging techniques
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试技术
- en: In this subsection, we’ll delve into mastering debugging tools and techniques
    in Unity, equipping you with the skills to troubleshoot and resolve code issues
    efficiently.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将深入了解 Unity 中的调试工具和技术，让您掌握高效故障排除和解决代码问题的技能。
- en: Let’s begin by exploring the different types of debugging messages. Utilizing
    debugging messages effectively is a valuable skill that can greatly benefit us
    in troubleshooting and improving our code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来探索不同的调试信息类型。有效地使用调试信息是一项宝贵的技能，它可以在故障排除和改进我们的代码方面给我们带来很大的好处。
- en: 'The following code block contains the four main types of debugging messages
    that you can use and customize in Unity:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块包含了在 Unity 中可以使用和自定义的四种主要类型的调试信息：
- en: '[PRE5]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can format the debug messages so that they include additional information
    within the text. This is shown in the following code block:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将调试信息格式化，以便在文本中包含额外的信息。以下代码块显示了这一点：
- en: '[PRE6]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also style the debug messages with colors, as shown in the following
    code block:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用颜色来格式化调试信息，如下面的代码块所示：
- en: '[PRE7]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we will discover how to utilize the Code Editor Debugger in Unity to navigate
    breakpoints, empowering you to efficiently debug and resolve bugs in your projects.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解如何在 Unity 中使用代码编辑器调试器来导航断点，这将使您能够有效地调试和解决项目中的错误。
- en: Code Editor Debugger
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码编辑器调试器
- en: 'Let’s walk through the steps of using the Code Editor Debugger so that you
    can apply the following techniques to your code wherever debugging is needed:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步地了解如何使用代码编辑器调试器，这样您就可以将以下技术应用到需要调试的代码中：
- en: 'Place breakpoints on the left-hand side of your code panel, as demonstrated
    in *Figure 10**.23*:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码面板的左侧放置断点，如图 *图 10.23* 所示：
- en: '![Figure 10.23 – Adding a breakpoint](img/B22017_10_23.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.23 – 添加断点](img/B22017_10_23.jpg)'
- en: Figure 10.23 – Adding a breakpoint
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.23 – 添加断点
- en: 'Afterward, click on **Attach to Unity**, as shown in *Figure 10**.24*. The
    build will begin, waiting to sync with Unity:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**附加到 Unity**，如图 *图 10.24* 所示。构建过程将开始，等待与 Unity 同步：
- en: '![Figure 10.24 – The Attach to Unity button](img/B22017_10_24.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.24 – 附加到 Unity 按钮](img/B22017_10_24.jpg)'
- en: Figure 10.24 – The Attach to Unity button
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.24 – 连接到Unity按钮
- en: 'If it’s your first time using the debugger, you’ll see the message shown in
    *Figure 10**.25*. You can click on **Enable debugging for this session** for this
    project only, or **Enable debugging for all projects** to enable it across all
    projects:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次使用调试器，你会看到 *图10.25* 中显示的消息。你可以点击 **仅为此项目启用调试**，或者点击 **为所有项目启用调试** 以在所有项目中启用它：
- en: '![Figure 10.25 – Attaching the C# debugger](img/B22017_10_25.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图10.25 – 连接到C#调试器](img/B22017_10_25.jpg)'
- en: Figure 10.25 – Attaching the C# debugger
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.25 – 连接到C#调试器
- en: 'Play the game in the editor and wait for the code to reach the breakpoint.
    The game will pause, and the editor will open at the breakpoint’s location. Hover
    your mouse over the line to view variable information and conditions, as shown
    in *Figure 10**.26*:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中播放游戏，等待代码到达断点。游戏将暂停，编辑器将在断点位置打开。将鼠标悬停在行上以查看变量信息和条件，如图 *图10.26* 所示：
- en: '![Figure 10.26 – Data displayed on hovering](img/B22017_10_26.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图10.26 – 鼠标悬停时显示的数据](img/B22017_10_26.jpg)'
- en: Figure 10.26 – Data displayed on hovering
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26 – 鼠标悬停时显示的数据
- en: 'After reviewing the data, you can resume your session by pressing the **Continue**
    button, as shown in *Figure 10**.27*. If no breakpoints have been set, the game
    will proceed as usual; however, any breakpoints that are present will be executed
    again when they’re encountered:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查数据后，你可以通过按下 **继续** 按钮来恢复你的会话，如图 *图10.27* 所示。如果没有设置断点，游戏将按正常方式继续；然而，当遇到断点时，任何现有的断点都将再次执行：
- en: '![Figure 10.27 – The Continue button](img/B22017_10_27.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图10.27 – 继续按钮](img/B22017_10_27.jpg)'
- en: Figure 10.27 – The Continue button
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.27 – 继续按钮
- en: You can follow these steps to start debugging by using breakpoints in your games.
    This method is highly useful for displaying comprehensive information about custom
    classes and conditions, as well as showing all data in the breakpoint line. Additionally,
    you can use **Step Into** or **Step Over** at certain points to gain a full understanding
    of what a particular chunk of code does.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下步骤使用游戏中的断点开始调试。这种方法对于显示有关自定义类和条件的综合信息以及显示断点行上的所有数据非常有用。此外，你可以在某些点使用 **Step
    Into** 或 **Step Over** 来全面了解特定代码块的功能。
- en: Exception handling and error logging
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常处理和错误日志记录
- en: Exception handling involves managing unexpected errors or exceptions that occur
    during runtime, preventing crashes, and ensuring the stability of your application.
    Unity provides various mechanisms to handle exceptions gracefully, such as `try-catch`
    blocks, custom error logging, and handling specific exception types.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理涉及管理在运行时发生的意外错误或异常，防止崩溃，并确保应用程序的稳定性。Unity提供了各种机制来优雅地处理异常，例如 `try-catch`
    块、自定义错误日志记录和处理特定异常类型。
- en: 'The following are the benefits of exception handling and error logging:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对异常处理和错误日志记录的好处：
- en: '**Preventing crashes**: By implementing robust exception handling, you can
    catch and manage errors before they cause your application to crash, providing
    a smoother and more reliable user experience'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止崩溃**：通过实现强大的异常处理，你可以在错误导致应用程序崩溃之前捕获和管理错误，从而提供更平滑、更可靠的用户体验'
- en: '**Graceful error handling**: Proper exception handling allows you to respond
    to errors gracefully, providing meaningful error messages to users and logging
    detailed information for debugging purposes'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优雅的错误处理**：适当的异常处理允许你优雅地响应错误，向用户提供有意义的错误消息，并为调试目的记录详细的信息'
- en: '**Debugging and troubleshooting**: Error logging plays a crucial role in debugging
    and troubleshooting issues in your code base as it provides a record of errors,
    along with relevant contextual information'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试和故障排除**：错误日志记录在调试和解决代码库中的问题时起着至关重要的作用，因为它提供了错误记录以及相关的上下文信息'
- en: 'Let’s demonstrate this with three examples:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过三个示例来演示这一点：
- en: '*Example 1 – basic* *exception handling*'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*示例1 – 基本异常处理*'
- en: 'In the following code block, I’ve implemented a basic `try-catch` block to
    handle errors in a numbers array. I can then debug the error to understand its
    nature and resolution:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我实现了一个基本的 `try-catch` 块来处理数字数组中的错误。然后我可以调试错误，了解其本质和解决方案：
- en: '[PRE8]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Example 2 – custom* *error logging*'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*示例2 – 自定义* *错误日志*'
- en: 'In the following code block, I’ve implemented a custom try-catch logging method:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我实现了一个自定义的 try-catch 日志记录方法：
- en: '[PRE9]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inside the catch block, there’s a call to a custom method called `LogErrorToFile`.
    This method is responsible for logging the error message to a file or an external
    logging system. In this example, it uses Unity’s `Debug.LogErrorFormat` method
    to log an error message in the console with a specified format.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在catch块中，调用了名为`LogErrorToFile`的自定义方法。此方法负责将错误消息记录到文件或外部日志系统中。在这个例子中，它使用Unity的`Debug.LogErrorFormat`方法以指定格式在控制台中记录错误消息。
- en: '*Example 3 – handling* *specific exceptions*'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*示例 3 – 处理* *特定异常*'
- en: 'In the following code block, I’ve implemented a specific exception:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我实现了一个特定的异常：
- en: '[PRE10]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By implementing robust exception handling and error logging practices such as
    these, you can enhance the stability and reliability of your Unity applications,
    ensuring smoother gameplay experiences for users and simplifying the debugging
    process for developers.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施强大的异常处理和错误记录实践，如这些，您可以增强Unity应用程序的稳定性和可靠性，确保用户获得更平滑的游戏体验，并简化开发者的调试过程。
- en: Platform-specific challenges are a crucial aspect of game development that requires
    expertise and strategic considerations to optimize performance across different
    devices and platforms.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 平台特定的挑战是游戏开发中的一个关键方面，需要专业知识以及战略性的考虑，以优化不同设备和平台上的性能。
- en: Platform-specific challenges
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台特定的挑战
- en: As experienced Unity developers, we understand the intricate challenges posed
    by platform-specific optimizations, especially in mobile environments and cross-platform
    development scenarios.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 作为经验丰富的Unity开发者，我们了解平台特定优化带来的复杂挑战，尤其是在移动环境和跨平台开发场景中。
- en: 'The following are some tips and tricks regarding mobile optimization:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于移动优化的技巧和窍门：
- en: Utilize **level of detail** (**LOD**) techniques to manage complex scenes and
    improve performance on mobile devices
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用**细节级别**（**LOD**）技术来管理复杂场景并提高移动设备上的性能
- en: Implement dynamic batching and static batching to reduce draw calls and optimize
    rendering for mobile platforms
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现动态批处理和静态批处理以减少绘制调用次数并优化移动平台上的渲染
- en: Optimize shader complexity and use mobile-friendly shaders to ensure smooth
    performance across various mobile hardware
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化着色器复杂度并使用适合移动设备的着色器，以确保在各种移动硬件上实现流畅的性能
- en: Implement performance optimizations such as object pooling and texture compression
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现性能优化，如对象池和纹理压缩
- en: Utilize Unity’s Profiler and performance tools for in-depth analysis and optimization
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Unity的Profiler和性能工具进行深入分析和优化
- en: Utilize GPU instancing and dynamic batching for efficient rendering on mobile
    devices
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用GPU实例化和动态批处理，在移动设备上实现高效的渲染
- en: Implement asynchronous loading and asset streaming to manage resource-intensive
    scenes seamlessly
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现异步加载和资产流式传输，以无缝管理资源密集型场景
- en: Leverage Unity’s Addressable Asset System for optimized asset management and
    dynamic content loading
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Unity的Addressable Asset系统进行优化的资产管理以及动态内容加载
- en: Optimize UI elements for mobile devices by using canvas scaling modes such as
    **Constant Pixel Size** or **Scale with Screen Size** to ensure UI elements are
    displayed correctly across different screen resolutions
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用如**固定像素大小**或**根据屏幕大小缩放**等画布缩放模式来优化移动设备上的UI元素，以确保在不同屏幕分辨率上正确显示UI元素
- en: Implement occlusion culling to optimize rendering by only rendering objects
    that are within the camera’s view, improving performance in complex scenes
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过仅渲染相机视图内的对象来实现遮挡剔除，以优化渲染并提高复杂场景中的性能
- en: Minimize the use of dynamic lights and use baked lighting whenever possible
    to reduce GPU overhead and improve performance on mobile platforms
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化动态光源的使用，并在可能的情况下使用烘焙光照，以减少GPU开销并提高移动平台上的性能
- en: Implement efficient audio management by using audio pooling, streaming audio
    clips, and reducing the number of simultaneous audio sources to conserve resources
    on mobile devices
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用音频池、流式音频片段和减少同时音频源的数量，实现高效的音频管理，以在移动设备上节省资源
- en: Use texture atlases and sprite packing to reduce the number of draw calls and
    optimize memory usage by combining multiple textures into a single texture atlas
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理图集和精灵打包将多个纹理合并到一个纹理图集中，以减少绘制调用次数并优化内存使用
- en: Perform regular profiling and performance testing on target mobile devices to
    identify bottlenecks, optimize critical areas, and ensure smooth and efficient
    gameplay on various devices
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目标移动设备上定期进行性能分析和测试，以识别瓶颈、优化关键区域，并确保在各种设备上实现流畅高效的游戏体验
- en: 'The following are some cross-platform development strategies you should consider:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你应该考虑的跨平台开发策略：
- en: Employ platform-specific compilation directives to customize behavior across
    different platforms
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定平台的编译指令来定制不同平台的行为
- en: Design modular architectures and feature flags to accommodate platform variations
    without compromising code base integrity
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模块化架构和功能标志，以适应平台变化而不损害代码库的完整性
- en: Utilize Unity Cloud Build and automated testing frameworks for streamlined deployment
    and compatibility testing
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Unity Cloud Build 和自动化测试框架以实现简化的部署和兼容性测试
- en: Use platform-specific compilation directives (**#if UNITY_IOS**, **#if UNITY_ANDROID**,
    and so on) to customize code behavior for different platforms
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定平台的编译指令（如 **#if UNITY_IOS**、**#if UNITY_ANDROID** 等）来定制不同平台上的代码行为
- en: Implement responsive UI design principles to create adaptive user interfaces
    that work seamlessly on different screen resolutions and aspect ratios
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施响应式 UI 设计原则，以创建在不同屏幕分辨率和宽高比上无缝工作的自适应用户界面
- en: Implement advanced approaches for developing games that run seamlessly on multiple
    platforms, such as PCs, consoles, and mobile devices, with a focus on code architecture
    and platform-specific optimizations
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施开发在多个平台上无缝运行的游戏的高级方法，例如 PC、游戏机和移动设备，重点关注代码架构和特定平台的优化
- en: Utilize Unity’s Addressable Asset System to manage and load assets efficiently
    across different platforms, allowing for dynamic content updates without the need
    to recompile the entire project
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Unity 的可寻址资产系统在不同平台上高效地管理和加载资产，允许动态更新内容，无需重新编译整个项目
- en: Use remote configuration services to dynamically adjust game settings, features,
    and content based on platform-specific requirements or user preferences
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程配置服务根据特定平台的要求或用户偏好动态调整游戏设置、功能和内容
- en: Leverage cloud-based analytics and monitoring tools to gather real-time performance
    data and user feedback across different platforms, enabling data-driven optimizations
    and updates
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用基于云的分析和监控工具收集不同平台上的实时性能数据和用户反馈，实现数据驱动的优化和更新
- en: Implement localization and internationalization features to support multiple
    languages and cultural preferences across various platforms, enhancing global
    accessibility and user engagement
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施本地化和国际化功能，以支持各种平台上的多种语言和文化偏好，增强全球可访问性和用户参与度
- en: Implement platform-specific input mapping and control customization options,
    allowing players to adjust control schemes based on their preferred devices and
    platforms
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施特定平台的输入映射和控制定制选项，允许玩家根据他们偏好的设备和平台调整控制方案
- en: Utilize Unity’s Build Report Tool and performance analysis features to monitor
    build sizes, memory usage, frame rates, and other performance metrics across different
    platforms, enabling data-driven optimizations
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Unity 的构建报告工具和性能分析功能来监控不同平台上的构建大小、内存使用、帧率和其他性能指标，从而实现数据驱动的优化
- en: Implement platform-specific testing and QA processes, including beta testing
    programs, device compatibility testing, and platform-specific bug tracking, to
    identify and address platform-specific issues and ensure high-quality releases
    on all platforms
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施特定平台的测试和 QA 流程，包括测试计划、设备兼容性测试和特定平台的错误跟踪，以识别和解决特定平台的问题，并确保所有平台上的高质量发布
- en: By mastering these platform-specific challenges and implementing advanced optimization
    techniques, we can deliver high-quality games that perform optimally across a
    wide range of devices and platforms, showcasing our expertise as Unity developers.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握这些特定平台的挑战并实施高级优化技术，我们可以提供高质量的游戏，这些游戏在各种设备和平台上表现最佳，展示了我们作为 Unity 开发者的专业知识。
- en: In summary, mastering these troubleshooting techniques and grasping platform-specific
    considerations will equip you with the skills needed to overcome common challenges
    and provide players with seamless and optimized gameplay experiences on different
    platforms.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，掌握这些故障排除技术并掌握特定平台的考虑因素，将使你具备克服常见挑战的技能，并在不同平台上为玩家提供无缝和优化的游戏体验。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this concluding chapter, we explored advanced game development techniques
    and productivity-enhancing strategies using C#. We started by covering essential
    Unity Editor shortcuts and time-saving keyboard shortcuts in code editors. We
    also delved into prefab workflow optimization, ScriptableObjects for data-driven
    development, and creating custom editors to improve user experience. Additionally,
    we mastered debugging tools, tackled platform-specific challenges such as mobile
    optimization, and provided insights for effective cross-platform development.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾部分，我们探讨了使用 C# 的高级游戏开发技术和提高生产力的策略。我们首先介绍了 Unity 编辑器的基本快捷键和代码编辑器中的节省时间的快捷键。我们还深入探讨了预制件工作流程的优化、用于数据驱动开发的
    ScriptableObjects 以及创建自定义编辑器以提升用户体验。此外，我们还掌握了调试工具，应对了特定平台挑战，如移动优化，并为有效的跨平台开发提供了见解。
- en: As we conclude this book, I want to express my heartfelt gratitude to you, the
    reader, for embarking on this learning journey with us. Remember, the essence
    of this book lies not in memorizing specific techniques but in understanding the
    underlying concepts and principles. May this knowledge empower you to unleash
    your creativity and innovate in your game development endeavors. Keep pushing
    the boundaries, exploring new possibilities, and creating captivating experiences
    for players around the world. Thank you for being a part of this journey, and
    I wish you continued success and fulfilment in your game development endeavors.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本书的结束，我想向读者表达我衷心的感谢，感谢您与我们一同踏上这段学习之旅。请记住，本书的精髓不在于记忆特定的技术，而在于理解其背后的概念和原则。愿这些知识能够赋予您释放创造力并在游戏开发事业中创新的能量。继续拓展边界，探索新的可能性，为世界各地的玩家创造引人入胜的体验。感谢您成为这段旅程的一部分，并祝愿您在游戏开发事业中继续取得成功和满足。
