- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: 'Starting Your AI Journey: Building Intelligent Enemies for Your Game'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始你的AI之旅：为你的游戏构建智能敌人
- en: What is a game if not a great challenge to the player, who needs to use their
    character’s abilities to tackle different scenarios? Each game imposes different
    kinds of obstacles for the player, but in our game, the primary challenge comes
    from the enemies. Imagine an enemy that can sense your presence and strategically
    plan its attack – this is what we aim to achieve through these AI techniques.
    Creating challenging and believable enemies can be complex; they must behave like
    real characters, smart enough to present challenges yet not so formidable as to
    be invincible. We are going to use basic but sufficient AI techniques to make
    an AI capable of sensing its surroundings and, based on that information, making
    decisions on what to do, using **Finite State Machines** (**FSMs**), along with
    other techniques. Those decisions will be executed using **intelligent pathfinding**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果说游戏不是对玩家的一项巨大挑战，那么玩家需要使用角色的能力来应对不同的场景，那游戏又是什么呢？每种游戏都会给玩家带来不同类型的障碍，但在我们的游戏中，主要的挑战来自敌人。想象一下，一个能够感知你的存在并战略性地计划攻击的敌人——这正是我们通过这些AI技术所追求的目标。创建具有挑战性和可信度的敌人可能很复杂；它们必须表现得像真实的人物，足够聪明以提供挑战，但又不足以不可战胜。我们将使用基本但足够的AI技术来使AI能够感知其周围环境，并根据这些信息做出决策，决定做什么，使用**有限状态机**（**FSMs**）以及其他技术。这些决策将通过**智能路径查找**来执行。
- en: 'In this chapter, we will examine the following AI concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下AI概念：
- en: Gathering information with sensors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传感器收集信息
- en: Making decisions with FSMs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FSM进行决策
- en: Executing FSM actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行FSM动作
- en: These components are crucial in creating enemies that are not only reactive
    but also exhibit a semblance of intelligence and strategy. By the end of the chapter,
    you will have a fully functional enemy capable of detecting the player and attacking
    them, so let’s start by seeing first how to make the sensor systems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件对于创建不仅具有反应性，而且展现出类似智能和策略的敌人至关重要。到本章结束时，你将拥有一个功能齐全的敌人，能够检测玩家并对其进行攻击，所以让我们首先看看如何制作传感器系统。
- en: Gathering information with sensors
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用传感器收集信息
- en: 'AI in games works in a three-step process: gathering information, analyzing
    it, and executing actions based on such analysis. This is important as it reflects
    a simple version of how the human mind works, making the resulting AI more realistic.
    As you can see, we cannot do anything without information, so let’s start with
    that part.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的AI工作在三个步骤中：收集信息、分析信息，并根据这种分析执行动作。这一点很重要，因为它反映了人类思维的一个简单版本，使得生成的AI更加逼真。正如你所见，没有信息我们无法做任何事情，所以让我们从这部分开始。
- en: There are several sources of information our AI can use, such as data about
    itself (life and bullets) or maybe some game state (winning condition or remaining
    enemies), which can easily be found with the code we’ve seen so far. One important
    source of information, however, is sensors such as sight and hearing. In our case,
    sight will be enough, so let’s learn how to code that.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的人工智能可以使用多种信息来源，例如关于自身的数据（生命和子弹）或可能是某些游戏状态（胜利条件或剩余敌人），这些都可以通过我们迄今为止看到的代码轻松找到。然而，一个重要的信息来源是传感器，如视觉和听觉。在我们的案例中，视觉就足够了，所以让我们学习如何编写这部分代码。
- en: 'In this section, we will examine the following sensor concepts:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下传感器概念：
- en: Creating three-filter sensors with C#
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C#创建三种过滤传感器
- en: Creating three-filter sensors with Visual Scripting
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视觉脚本创建三种过滤传感器
- en: Debugging with gizmos
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用gizmos进行调试
- en: Let’s start by seeing how to create a sensor with the three-filter approach.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何使用三种过滤方法创建一个传感器。
- en: Creating three-filter sensors with C#
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用C#创建三种过滤传感器
- en: The common way to code senses is through a three-filter approach to discard
    enemies out of sight. Each filter will discard objects that fall outside our sensors.
    The first filter is a distance filter, which will discard enemies too far away
    to be seen, then the second filter is the angle check, which will check enemies
    inside our viewing cone, and finally, the third filter is a raycast check, which
    will discard enemies that are being occluded by obstacles such as walls.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编码感官的常见方法是使用一种三种过滤方法来排除视线之外的敌人。每个过滤器都会排除超出我们传感器范围的物体。第一个过滤器是距离过滤器，它会排除太远而看不见的敌人，然后第二个过滤器是角度检查，它会检查我们视野锥体内的敌人，最后，第三个过滤器是射线投射检查，它会排除被墙壁等障碍物遮挡的敌人。
- en: 'Before starting, a word of advice: we will be using vector mathematics here,
    and covering those topics in-depth is outside the scope of this book. If you don’t
    understand something, feel free to just search online for the code in the screenshots.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，有一句话要提醒：我们将在这里使用向量数学，而深入探讨这些主题超出了本书的范围。如果您不理解某些内容，请随时在网上搜索截图中的代码。
- en: 'Let’s code sensors in the following way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下面的方式编写传感器代码：
- en: 'Create an empty `GameObject` called `AI` as a child of the **Enemy** Prefab.
    You need to first open the Prefab to modify its children (double-click the Prefab).
    Remember to set the transform of this `GameObject` to **Position** (**0,** **1.75,
    0**), **Rotation (0, 0, 0)**, and **Scale (1, 1, 1**) so it will be aligned with
    the enemy’s eyes. This is done this way for the future sight sensors we will do.
    Consider your **Enemy** Prefab might have a different height for the eyes. While
    we can certainly just put all AI scripts directly in the **Enemy** Prefab root
    `GameObject`, we did this just for separation and organization:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `AI` 的空 `GameObject`，作为 **Enemy** 预制件的子对象。您需要首先打开预制件以修改其子对象（双击预制件）。请记住将此
    `GameObject` 的变换设置为 **位置**（**0，** **1.75，0**），**旋转（0，0，0**）和 **缩放（1，1，1**），以便它与敌人的眼睛对齐。这样做是为了未来我们将做的视觉传感器。请注意，您的
    **Enemy** 预制件的眼睛可能具有不同的高度。虽然我们可以直接将所有 AI 脚本直接放在 **Enemy** 预制件根 `GameObject` 中，但我们这样做只是为了分离和组织：
- en: '![](img/B21361_09_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_01.png)'
- en: 'Figure 9.1: AI scripts container'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：AI 脚本容器
- en: Create a script called `Sight` and add it to the `AI` child GameObject.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Sight` 的脚本，并将其添加到 `AI` 子 GameObject。
- en: Create two fields of the `float` type called `distance` and `angle`, and another
    two of the `LayerMask` type called `obstaclesLayers` and `objectsLayers`. The
    `distance` field will be used as the vision distance, `angle` will determine the
    amplitude of the view cone, `obstacleLayers` will be used by our obstacle check
    to determine which objects are considered obstacles, and `objectsLayers` will
    be used to determine what types of objects we want the `Sight` component to detect.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个名为 `distance` 和 `angle` 的 `float` 类型的字段，以及另外两个名为 `obstaclesLayers` 和 `objectsLayers`
    的 `LayerMask` 类型的字段。`distance` 字段将用作视野距离，`angle` 将确定视锥体的幅度，`obstaclesLayers` 将用于我们的障碍物检查以确定哪些对象被认为是障碍物，而
    `objectsLayers` 将用于确定我们想要 `Sight` 组件检测的对象类型。
- en: We just want the sight to see enemies; we are not interested in objects such
    as walls or power-ups. **LayerMask** is a property type that allows us to select
    one or more layers to use inside code, so we will be filtering objects by layer.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只想让视野看到敌人；我们对墙壁或增益物品等对象不感兴趣。**LayerMask** 是一种属性类型，允许我们在代码中选择一个或多个层来使用，因此我们将通过层过滤对象。
- en: '![](img/B21361_09_02_PE.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_02_PE.png)'
- en: 'Figure 9.2: Fields to parametrize our Sight check'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：用于参数化我们的视野检查的字段
- en: In `Update`, call `Physics.OverlapSphere`, as in *Figure 9.3*.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Update` 中调用 `Physics.OverlapSphere`，如 *图 9.3* 所示。
- en: This function creates an imaginary sphere in the place specified by the first
    parameter (in our case, our position) and with a radius specified in the second
    parameter (the distance property) to detect objects with the layers specified
    in the third parameter (`ObjectsLayers`). It will return an array with all the
    colliders found inside the sphere; these functions use physics to carry out the
    check, so the objects must have at least one collider.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在由第一个参数指定的位置（在我们的情况下，是我们的位置）创建一个假想的球体，并具有第二个参数指定的半径（距离属性）以检测具有第三个参数指定的层（`ObjectsLayers`）的对象。它将返回一个包含在球体内找到的所有碰撞器的数组；这些函数使用物理进行检查，因此对象必须至少有一个碰撞器。
- en: This is the method we will be using to find all enemies inside our view distance,
    and we will be further filtering them in the next steps. Note that we are passing
    our position to the first parameter, which is not actually the position of the
    enemy but the position of the `AI` child object, given our script is located there.
    This highlights the importance of the position of the `AI` object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将使用的方法来找到我们视野距离内的所有敌人，我们将在下一步中进一步过滤它们。请注意，我们正在将我们的位置传递给第一个参数，这实际上不是敌人的位置，而是
    `AI` 子对象的位置，因为我们的脚本位于那里。这突出了 `AI` 对象位置的重要性。
- en: Another way of accomplishing the first check is to just check the distance from
    the objects we want to see to the player, or if looking for other kinds of objects,
    to a `Manager` component containing a list of them. However, the method we chose
    is more versatile and can be used for any kind of object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第一个检查的另一种方法是检查我们想要看到的物体与玩家之间的距离，或者如果寻找其他类型的物体，到一个包含它们的`Manager`组件。然而，我们选择的方法更灵活，可以用于任何类型的物体。
- en: Also, you might want to check the `Physics.OverlapSphereNonAlloc` version of
    this function, which does the same but is more performant by not allocating an
    array to return the results.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能还想检查这个函数的`Physics.OverlapSphereNonAlloc`版本，它执行相同的操作，但通过不分配返回结果的数组而更高效。
- en: Iterate over the array of objects returned by the function using a `for` loop:![](img/B21361_09_03_PE.png)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环遍历函数返回的对象数组：![图片](img/B21361_09_03_PE.png)
- en: 'Figure 9.3: Getting all GameObjects at a certain distance'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.3：获取一定距离内的所有GameObject
- en: 'To detect whether the object falls inside the vision cone, we need to calculate
    the angle between our viewing direction and the direction from ourselves toward
    the object itself. If the angle between those two directions is less than our
    cone angle, we consider that the object falls inside our vision. We will do that
    in the following steps:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了检测物体是否落在视野锥内，我们需要计算我们的观察方向与从我们自身指向物体本身的方位之间的角度。如果这两个方向之间的角度小于我们的锥形角度，我们认为物体落在我们的视野内。我们将在以下步骤中这样做：
- en: 'Start calculating the direction toward the object, which can be done by normalizing
    the difference between the object’s position and ours, as in *Figure 9.4*. You
    might notice we used `bounds.center` instead of `transform.position`; this way,
    we check the direction to the center of the object instead of its pivot. Remember
    that the player’s pivot is in the ground and the ray check might collide against
    it before the player:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始计算指向物体的方向，这可以通过将物体位置与我们的位置之间的差异进行归一化来实现，如*图9.4*所示。你可能注意到我们使用了`bounds.center`而不是`transform.position`；这样，我们检查的是指向物体中心的方位，而不是其旋转点。记住，玩家的旋转点在地面，射线检查可能会在玩家之前与之碰撞：
- en: '![](img/B21361_09_04.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_04.png)'
- en: 'Figure 9.4: Calculating direction from our position toward the collider'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：从我们的位置计算指向碰撞体的方向
- en: We can use the `Vector3.Angle` function to calculate the angle between two directions.
    In our case, we can calculate the angle between the direction toward the enemy
    and our forward vector to see the angle:![](img/B21361_09_05.png)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`Vector3.Angle`函数来计算两个方向之间的角度。在我们的情况下，我们可以计算指向敌人的方向与我们的前进向量之间的角度来查看角度：![图片](img/B21361_09_05.png)
- en: 'Figure 9.5: Calculating the angle between two directions'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.5：计算两个方向之间的角度
- en: If you want, you can instead use `Vector3.Dot`, which will execute a dot product
    – a mathematics function to calculate the length of a vector projected to another
    (search online for more info). `Vector3.Angle` actually uses that one but converts
    the result of the dot product into an angle, which needs to use trigonometry,
    and that can be time-consuming to calculate. Our `Vector3.Angle` approach is simpler
    and faster to code, and, given that we don’t require many sensors because we won’t
    have many enemies, optimizing the sensor using dot products is not necessary now,
    but do consider that for games with a larger scale.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以使用`Vector3.Dot`，这将执行点积——一种数学函数，用于计算一个向量在另一个向量上的投影长度（在网上搜索更多信息）。`Vector3.Angle`实际上使用这个函数，但将点积的结果转换为角度，这需要使用三角函数，并且可能计算起来很耗时。我们的`Vector3.Angle`方法更简单，编码更快，而且鉴于我们不需要很多传感器，因为我们不会有太多敌人，使用点积优化传感器现在不是必要的，但请考虑这一点，对于更大规模的游戏。
- en: Now check whether the calculated angle is less than the one specified in the
    `angle` field. Note that if we set an angle of `90`, it will actually be `180`,
    because if the `Vector3.Angle` function returns, as an example, `30`, it could
    be `30` to the left or to the right. If our angle says `90`, it could be both
    `90` to the left and to the right, so it will detect objects in a 180-degree arc.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在检查计算出的角度是否小于在`angle`字段中指定的角度。注意，如果我们设置角度为`90`，实际上会是`180`，因为如果`Vector3.Angle`函数返回，例如，`30`，它可能是向左或向右的`30`。如果我们的角度是`90`，它可能是向左和向右的`90`，因此它将检测到180度弧内的物体。
- en: Use the `Physics.Linecast` function to create an imaginary line between the
    first and the second parameter (our position and the collider position) to detect
    objects with the layers specified in the third parameter (the obstacle layers)
    and return a Boolean indicating whether that ray hit something or not.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Physics.Linecast` 函数在第一个和第二个参数（我们的位置和碰撞体位置）之间创建一个假想线，以检测第三参数（障碍层）中指定的层上的对象，并返回一个布尔值，指示该射线是否击中了某个对象。
- en: 'The idea is to use the line to detect whether there are any obstacles between
    ourselves and the detected collider, and if there is no obstacle, this means that
    we have a direct line of sight toward the object. Observe how we use the `!` or
    `not` operator in *Figure 9.6* to check that `Physics.Linecast` didn’t detect
    any objects. Again, note that this function depends on the obstacle objects having
    colliders, which, in our case, we have (walls, floor, and so on):'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 策略是使用线来检测我们和检测到的碰撞体之间是否存在任何障碍物，如果没有障碍物，这意味着我们有一个直接视线通向该对象。观察我们在 *图 9.6* 中如何使用
    `!` 或 `not` 操作符来检查 `Physics.Linecast` 没有检测到任何对象。再次注意，这个函数依赖于具有碰撞器的障碍物对象，在我们的例子中，我们有（墙壁、地板等）：
- en: '![](img/B21361_09_06_PE.png)'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B21361_09_06_PE.png)'
- en: 'Figure 9.6: Using Linecast to check obstacles between the sensor and the target
    object'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.6：使用 Linecast 检查传感器和目标对象之间的障碍物
- en: If the object passes the three checks, that means that this is the object we
    are currently seeing, so we can save it inside a field of the `Collider` type
    called `detectedObject`, to save that information for later use by the rest of
    the `AI` scripts.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对象通过了这三个检查，这意味着这是我们目前看到的对象，因此我们可以将其保存在 `Collider` 类型的字段 `detectedObject` 中，以便稍后由其他
    `AI` 脚本使用该信息。
- en: 'Consider using `break` to stop the `for` loop that is iterating the colliders
    to prevent wasting resources by checking the other objects, and to set `detectedObject`
    to `null` before `for` to clear the result from the previous frame. If, in this
    frame, we don’t detect anything, it will keep the `null` value so we notice that
    there is nothing in the sensor:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑使用 `break` 来停止迭代碰撞体的 `for` 循环，以防止通过检查其他对象而浪费资源，并在 `for` 之前将 `detectedObject`
    设置为 `null` 以清除前一帧的结果。如果在当前帧中没有检测到任何内容，它将保持 `null` 值，这样我们就会注意到传感器中没有东西：
- en: '![](img/B21361_09_07_PE.png)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B21361_09_07_PE.png)'
- en: 'Figure 9.7: Full sensor script'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.7：完整的传感器脚本
- en: In our case, we are using the sensor just to look for the player (the only object
    the sensor is in charge of looking for), but if you want to make the sensor more
    advanced, you can just keep a list of detected objects, placing inside it every
    object that passes the three tests instead of just the first one. In our case,
    it’s not necessary as we have only one player in the game.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只是使用传感器来寻找玩家（传感器负责寻找的唯一对象），但如果你想让传感器更高级，你只需保留一个检测到的对象列表，在其中放置通过三个测试的每个对象，而不仅仅是第一个。在我们的例子中，这并不必要，因为我们游戏中只有一个玩家。
- en: 'In the editor, configure the sensor at your will. In this case, we will set
    `Objects Layer` to `Player` so our sensor will focus its search on objects with
    that layer, and `Obstacles Layer` to `Default`, the layer we used for walls and
    floors. Remember the `Sight` script is in the `AI` GameObject, which is a child
    of the `Enemy` Prefab:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，根据您的意愿配置传感器。在这种情况下，我们将 `Objects Layer` 设置为 `Player`，这样我们的传感器就会专注于搜索具有该层的对象，并将
    `Obstacles Layer` 设置为 `Default`，这是我们用于墙壁和地板的层。记住，`Sight` 脚本位于 `AI` GameObject
    中，它是 `Enemy` 预制件的子对象：
- en: '![](img/B21361_09_08_PE.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_08_PE.png)'
- en: 'Figure 9.8: Sensor settings'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：传感器设置
- en: To test this, just place an enemy with a movement speed of **0** in front of
    the player, select its `AI` child object, and then play the game to see how the
    property is set in the Inspector. Also, try putting an obstacle between the two
    and check that the property says **None** (`null`). If you don’t get the expected
    result, double-check your script, its configuration, and whether the player has
    the **Player** layer, and the obstacles have the **Default** layer. Also, you
    might need to raise the `AI` object a little bit to prevent the ray from starting
    below the ground and hitting it. Feel free to make further tests to really understand
    your code.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试这一点，只需在玩家前方放置一个移动速度为 **0** 的敌人，选择其 `AI` 子对象，然后玩游戏以查看属性在检查器中的设置情况。此外，尝试在两者之间放置一个障碍物，并检查属性是否显示
    **None** (`null`)。如果您没有得到预期的结果，请仔细检查您的脚本、其配置以及玩家是否具有 **Player** 层，障碍物是否具有 **Default**
    层。您可能还需要将 `AI` 对象稍微抬高一点，以防止射线从地面以下开始并击中它。请随意进行进一步测试，以真正理解您的代码。
- en: Now that we understand how the sensors work in C#, let’s see the Visual Scripting
    version.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了C#中传感器的工作原理，让我们看看可视化脚本版本。
- en: Creating Three-Filters sensors with Visual Scripting
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可视化脚本创建三过滤传感器
- en: 'Regarding the Visual Scripting version, let’s check it part by part, starting
    with the **Overlap Sphere**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可视化脚本版本，让我们逐部分检查，从**重叠球体**开始：
- en: '![](img/B21361_09_09_PE.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_09_PE.png)'
- en: 'Figure 9.9: Overlap Sphere in Visual Scripting'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：可视化脚本中的重叠球体
- en: So far, we just called **Overlap Sphere** after setting the `sensedObject` variable
    to `null`. The previous image contains not only the variables we need so far but
    also the ones that we will use later, so remember to create all of them. Something
    to consider is how the `sensedObject` variable in the **Variables** component
    in the Inspector might instead have a **Null** type in your case, which means
    no type in Visual Scripting. This isn’t possible in C# – all variables must have
    a type – and while we could set the `sensedObject` variable to the proper type
    (**Collider**), we will keep the variable type to be set later via a script. Even
    if we set the type now, Visual Scripting tends to forget the type if no value
    is set, and we cannot set it until we detect something.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是在将`sensedObject`变量设置为`null`后调用了**重叠球体**。上一张图片不仅包含了我们目前需要的变量，还包括了我们以后会使用的变量，所以请记住创建所有这些变量。需要考虑的一点是，在检查器中的**变量**组件中的`sensedObject`变量可能在你的情况下具有**Null**类型，这意味着在可视化脚本中没有类型。这在C#中是不可能的——所有变量都必须有类型——虽然我们可以将`sensedObject`变量设置为正确的类型（**Collider**），但我们将会通过脚本将其变量类型留待以后设置。即使我们现在设置类型，如果没有设置值，可视化脚本往往会忘记类型，并且我们无法设置它，直到我们检测到某个东西。
- en: Don’t worry about that for the moment; when we set the variable through our
    script, it will acquire the proper type. Actually, all variables in Visual Scripting
    can switch types at runtime according to what we set them to, given how the **Variables**
    component works. I don’t recommend changing a variable’s type in runtime, as it
    will give a different meaning to it. Try to stick with the intended variable type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必担心这个问题；当我们通过我们的脚本设置变量时，它将获得正确的类型。实际上，在可视化脚本中，所有变量都可以在运行时根据我们设置的值切换类型，这取决于**变量**组件的工作方式。我不建议在运行时更改变量的类型，因为这会给它赋予不同的含义。尽量坚持预期的变量类型。
- en: We just said that all variables in C# must have a type, but that’s not entirely
    true. There are ways to create dynamically typed variables, but it’s not a good
    practice that I’d recommend using unless no other option is present.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才说过，C#中的所有变量都必须有类型，但这并不完全正确。有方法可以创建动态类型的变量，但这不是一种我推荐使用的良好实践，除非没有其他选择。
- en: Another thing to observe is how we set the `sensedObject` variable to `null`
    at the beginning using the **Null** node, which effectively represents the `null`
    value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点要注意的是，我们是如何在开始时使用**Null**节点将`sensedObject`变量设置为`null`，这实际上代表了`null`值。
- en: 'Now, let’s explore the **Foreach** part:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索一下**Foreach**部分：
- en: '![](img/B21361_09_10_PE.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_10_PE.png)'
- en: 'Figure 9.10: Iterating collections in Visual Scripting'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：在可视化脚本中迭代集合
- en: We can see that one of the output pins of **Overlap Sphere** has a list icon,
    which essentially represents the `collider` array returned by **Overlap Sphere**.
    We connect that pin to the **For Each Loop** node, which, as you might imagine,
    iterates over the elements of the provided collection (array, list, dictionary,
    etc.). The **Body** pin represents the nodes to execute in each iteration of the
    loop, and the **Item** output pin represents the item currently being iterated
    – in our case, one of the colliders detected in **Overlap Sphere**. Finally, we
    save that item in a **Flow** `potentialDetection` variable (**Flow** variables
    being the equivalent to local variables in C# functions).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，**重叠球体**的一个输出引脚有一个列表图标，这本质上代表了由**重叠球体**返回的`collider`数组。我们将该引脚连接到**For
    Each Loop**节点，正如你可能想象的那样，它遍历提供的集合（数组、列表、字典等）的元素。**Body**引脚代表循环中要执行的节点，**Item**输出引脚代表当前正在迭代的项——在我们的情况下，是**重叠球体**检测到的其中一个碰撞体。最后，我们将该项保存在一个**Flow**
    `potentialDetection`变量中（**Flow**变量在C#函数中相当于局部变量）。
- en: To maintain clarity in our Visual Scripting graph and avoid clutter, we assign
    the currently iterated collider to a **Flow** variable named `potentialDetection`.
    This approach eliminates the need for extensive connections across the graph,
    simplifying the visual layout and subsequent referencing of this collider.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的视觉脚本图清晰，避免杂乱，我们将当前迭代的碰撞体分配给一个名为`potentialDetection`的**Flow**变量。这种方法消除了在整个图中进行大量连接的需要，简化了视觉布局和随后对该碰撞体的引用。
- en: 'Now let’s explore the **Angle** check:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们探索**角度**检查：
- en: '![](img/B21361_09_11_PE.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_11_PE.png)'
- en: 'Figure 9.11: Angle check in Visual Scripting'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：视觉脚本中的角度检查
- en: Here, you can see a direct translation of what we did in C# to detect the angle,
    so it should be pretty self-explanatory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到我们将C#中检测角度所做操作的直接翻译，因此应该很容易理解。
- en: 'Now, let’s explore the **Linecast** part:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索**Linecast**部分：
- en: '![](img/B21361_09_12_PE.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_12_PE.png)'
- en: 'Figure 9.12: Linecast check in Visual Scripting'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：视觉脚本中的Linecast检查
- en: Again, this is essentially the same as we did before in C#. The only thing to
    highlight here is the fact we used the **Flow** variable `potentialDetection`
    to again get the position of the current item being iterated, instead of connecting
    the **Get Position** node all the way to the For Each Item output pin.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这基本上与我们之前所做的是一样的。这里要强调的唯一一点是我们使用了**Flow**变量`potentialDetection`来再次获取当前迭代的项的位置，而不是将**Get
    Position**节点连接到For Each Item输出引脚。
- en: 'Now, let’s explore the final part:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索最后一部分：
- en: '![](img/B21361_09_13_PE.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_13_PE.png)'
- en: 'Figure 9.13: Setting the sensedObject'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：设置sensedObject
- en: Again, this is pretty much self-explanatory; if the **Linecast** returns **False**,
    we set the `potentialDetection` variable (the currently iterated item) as the
    `sensedObject` variable (the one that will be accessed by other scripts later
    to query which is the object our AI can see right now). Something to consider
    here is the usage of the **Break Loop** node, which is equivalent to the C# `break`
    keyword; essentially, we are stopping the **Foreach** loop we are currently in.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这部分内容基本上是自我解释的；如果**Linecast**返回**False**，我们将`potentialDetection`变量（当前迭代的项）设置为`sensedObject`变量（稍后其他脚本将访问的变量，以查询现在我们的AI可以看到哪个对象）。这里需要考虑的是**Break
    Loop**节点的使用，它等同于C#中的`break`关键字；本质上，我们正在停止我们当前所在的**Foreach**循环。
- en: Now, even if we have our sensor working, sometimes, checking whether it’s working
    or configured properly requires some visual aids that we can create using gizmos.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使我们的传感器正在工作，有时，检查它是否工作或配置正确需要一些我们可以使用gizmos创建的视觉辅助工具。
- en: Debugging with gizmos
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用gizmos进行调试
- en: As we create our AI, we will start to detect certain errors in edge cases, usually
    related to misconfigurations. You may think that the player falls within the sight
    range of the enemy, but maybe you cannot see that the line of sight is occluded
    by an object, especially as the enemies move constantly. A good way to debug those
    scenarios is through Editor-only visual aids known as gizmos, which allow you
    to visualize invisible data such as the sight distance or the `Linecasts` executed
    to detect obstacles.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的AI时，我们将开始检测边缘情况中的某些错误，通常与配置错误有关。你可能认为玩家在敌人的视线范围内，但也许你看不到视线被一个物体遮挡，尤其是在敌人不断移动的情况下。调试这些场景的一个好方法是使用仅编辑器可用的视觉辅助工具，即gizmos，它允许你可视化诸如视线距离或用于检测障碍物的`Linecasts`等不可见数据。
- en: 'Let’s start seeing how to create gizmos drawing a sphere representing the sight
    distance by doing the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤开始了解如何创建绘制表示视线距离的球体gizmos：
- en: In the `Sight` script, create an event function called `OnDrawGizmos`. This
    event is only executed in the Editor (not in builds) and is the place to draw
    any gizmos in Unity.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Sight`脚本中，创建一个名为`OnDrawGizmos`的事件函数。这个事件仅在编辑器中执行（不在构建中），是绘制任何Unity中gizmos的地方。
- en: 'Use the `Gizmos.DrawWireSphere` function, passing our position as the first
    parameter and the distance as the second parameter to draw a sphere in our position
    with the radius of our distance. You can check how the size of the gizmo changes
    as you change the `distance` field:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Gizmos.DrawWireSphere`函数，将我们的位置作为第一个参数，将距离作为第二个参数，在我们的位置上绘制一个半径为我们的距离的球体。你可以检查当改变`distance`字段时gizmo的大小如何变化：
- en: '![](img/B21361_09_14_PE.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_14_PE.png)'
- en: 'Figure 9.14: Sphere gizmo'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：球体gizmo
- en: Optionally, you can change the color of the gizmo, setting `Gizmos.color` before
    calling the drawing functions:![](img/B21361_09_15_PE.png)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，你可以在调用绘图函数之前设置 `Gizmos.color` 来更改gizmo的颜色：![图片](img/B21361_09_15_PE.png)
- en: 'Figure 9.15: Gizmos drawing code'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.15：Gizmos绘制代码
- en: Now you are drawing gizmos constantly, and if you have lots of enemies, they
    can pollute the **Scene** view with too many gizmos. In that case, try the `OnDrawGizmosSelected`
    event function instead, which draws gizmos only if the object is selected.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你正在不断绘制gizmos，如果你有很多敌人，它们可以用太多的gizmos污染**场景**视图。在这种情况下，尝试使用 `OnDrawGizmosSelected`
    事件函数，它只在对象被选中时绘制gizmos。
- en: 'We can draw the lines representing the cone using `Gizmos.DrawRay`, which receives
    the origin of the line to draw and the direction of the line, which can be multiplied
    by a certain value to specify the length of the line, as in the following screenshot:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `Gizmos.DrawRay` 来绘制代表锥体的线条，它接收要绘制的线条的起点和方向，方向可以通过乘以一个特定的值来指定线条的长度，如下面的截图所示：
- en: '![](img/B21361_09_16_PE.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_16_PE.png)'
- en: 'Figure 9.16: Drawing rotated lines'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：绘制旋转线条
- en: In the screenshot, we used `Quaternion.Euler` to generate a quaternion based
    on the angles we want to rotate. A quaternion is a mathematical construct to represent
    rotations; please search for this term for more info on it. If we multiply this
    quaternion by a direction, we will get the rotated direction. We are taking our
    forward vector and rotating it according to the `angle` field to generate our
    cone vision lines.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在截图，我们使用了 `Quaternion.Euler` 来根据我们想要旋转的角度生成一个四元数。四元数是一种数学结构，用于表示旋转；请搜索此术语以获取更多关于它的信息。如果我们用一个方向乘以这个四元数，我们将得到旋转后的方向。我们正在根据
    `angle` 字段旋转我们的前进向量以生成我们的锥形视觉线条。
- en: 'Also, we multiply this direction by the sight distance to draw the line as
    far as our sight can see; you will see how the line matches the end of the sphere
    this way:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将这个方向乘以视线距离来绘制线条，直到我们的视线所能看到的地方；你会看到线条如何与球体的末端匹配：
- en: '![](img/B21361_09_17_PE.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_17_PE.png)'
- en: 'Figure 9.17: Vision angle lines'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17：视觉角度线条
- en: 'We can also draw the linecasts, which check the obstacles, but as they depend
    on the current situation of the game, such as the objects that pass the first
    two checks and their positions, we can use `Debug.DrawLine` instead, which can
    be executed in the `Update` method. This version of `DrawLine` is designed to
    be used in runtime only. The gizmos we saw also execute in the Editor. Let’s try
    them in the following way:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以绘制线条投射，它们检查障碍物，但它们依赖于游戏的当前情况，例如通过前两个检查的对象及其位置，我们可以使用 `Debug.DrawLine` 代替，它可以在
    `Update` 方法中执行。这种 `DrawLine` 版本是为运行时设计的。我们看到的gizmos也在编辑器中执行。让我们以下面的方式尝试它们：
- en: 'First, let’s debug the scenario where `Linecast` didn’t detect any obstacles,
    so we need to draw a line between our sensor and the object. We can call `Debug.DrawLine`
    in the `if` statement that calls `Linecast`, as in the following screenshot:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们调试 `Linecast` 没有检测到任何障碍物的情况，因此我们需要在传感器和物体之间绘制一条线。我们可以在调用 `Linecast` 的
    `if` 语句中调用 `Debug.DrawLine`，如下面的截图所示：
- en: '![](img/B21361_09_18_PE.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_18_PE.png)'
- en: 'Figure 9.18: Drawing a line in Update'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18：在Update中绘制线条
- en: 'In the next screenshot, you can see `DrawLine` in action:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一张截图，你可以看到 `DrawLine` 的实际应用：
- en: '![](img/B21361_09_19_PE.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_19_PE.png)'
- en: 'Figure 9.19: Line toward the detected object'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19：指向检测到的物体的线条
- en: We also want to draw a line in red when the sight is occluded by an object.
    In this case, we need to know where the linecast hit, so we can use an overload
    of the function, which provides an `out` parameter that gives us more information
    about what the line collided with, such as the position of the hit and the normal
    and the collided object, as in the following screenshot:![](img/B21361_09_20_PE.png)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望在视线被物体遮挡时用红色绘制线条。在这种情况下，我们需要知道线条投射击中的位置，因此我们可以使用函数的重载，它提供了一个 `out` 参数，它提供了更多关于碰撞的信息，例如击中的位置、法线和碰撞的物体，如下面的截图所示：![图片](img/B21361_09_20_PE.png)
- en: 'Figure 9.20: Getting information about Linecast'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.20：获取Linecast的信息
- en: 'Parameters using the out keyword allow the method to return data also via parameters.
    For more info on this, check the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out).'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`out`关键字声明的参数允许方法通过参数返回数据。有关此信息的更多信息，请查看以下链接：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out)。
- en: Note that `Linecast` doesn’t always collide with the nearest obstacle but with
    the first object it detects in the line, which can vary in order. If you need
    to detect the nearest obstacle, look for the `Physics.Raycast` version of the
    function.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`Linecast`并不总是与最近的障碍物碰撞，而是与它在直线上检测到的第一个对象碰撞，这可能会变化。如果你需要检测最近的障碍物，请查找函数的`Physics.Raycast`版本。
- en: 'We can use that information to draw the line from our position to the hit point
    in the `else` part of the `if` sentence when the line collides with something:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用这些信息在`if`语句的`else`部分绘制从我们的位置到击中点的线条，当线条与某个物体碰撞时：
- en: '![](img/B21361_09_21_PE.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_21_PE.png)'
- en: 'Figure 9.21: Drawing a line if we have an obstacle'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21：如果我们有障碍物，则绘制线条
- en: 'In the next screenshot, you can see the results. Ensure the **Gizmos** option
    is on in the **Scene** view toolbars (the rightmost sphere-shaped icon):'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一张屏幕截图中，你可以看到结果。确保在**场景**视图工具栏中开启**Gizmos**选项（最右侧的球形图标）：
- en: '![](img/B21361_09_22_PE.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_22_PE.png)'
- en: 'Figure 9.22: Line when an obstacle occludes vision'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22：当障碍物遮挡视线时的线条
- en: 'Regarding the Visual Scripting version, the first part will look like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，第一部分将看起来像这样：
- en: '![](img/B21361_09_23_PE.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_23_PE.png)'
- en: 'Figure 9.23: Drawing gizmos with Visual Scripting'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23：使用视觉脚本绘制辅助工具
- en: 'Then, the angle lines will look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，角度线将看起来像这样：
- en: '![](img/B21361_09_24_PE.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_24_PE.png)'
- en: 'Figure 9.24: Drawing angle lines of sight in Visual Scripting'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24：在视觉脚本中绘制视线角度线
- en: 'Note that, here, we are showing just one; the other is essentially the same
    but multiplying the angle by -1\. Finally, the red lines toward the detected object
    and obstacles will look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里我们只展示了一个；另一个基本上是相同的，但将角度乘以-1。最后，指向检测到的对象和障碍物的红色线条将看起来像这样：
- en: '![](img/B21361_09_25_PE.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_25_PE.png)'
- en: 'Figure 9.25: Drawing lines toward obstacles or detected objects in Visual Scripting'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25：在视觉脚本中绘制指向障碍物或检测到的对象的线条
- en: Note that to accomplish this last one, we needed to change the previous **Linecast**
    node for the version that returns **Raycast Hit** info at the end.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了完成这个最后一步，我们需要将之前的**Linecast**节点更改为返回**Raycast Hit**信息的版本。
- en: In this section, we created the sensor system that will give sight to our AI
    and plenty of info about what to do next. Now that we have completed our sensors,
    let’s use the information provided by them to make decisions with FSMs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了将赋予我们的AI视力和大量关于下一步做什么的信息的传感器系统。现在我们已经完成了传感器，让我们使用它们提供的信息使用FSM做出决策。
- en: Making decisions with FSMs
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FSM做出决策
- en: 'We explored the concept of FSMs in the past when we used them in the `Animator`
    component. To recap, we recommend reviewing *Chapter 17*, *Animated Realities:
    Creating Animations with Animator, Cinemachine, and Timeline*. We learned that
    an FSM is a collection of states, each one representing an action that an object
    can be executing at a time and a set of transitions that dictates how the states
    are switched. This concept is not only used in animation but in a myriad of programming
    scenarios, and one of the common ones is AI. For AI, each state will represent
    a different possible AI behavior to be active at a time, and transitions will
    represent the conditions that need to be met for other AI behaviors to be active.
    For example, in a shooter game, the enemies can have states like **Idle**, **Patrolling**,
    **Attacking**, **Fleeing**, **Taking Cover**, and so on.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，当我们使用`Animator`组件时，我们探索了有限状态机（FSM）的概念。为了回顾，我们建议复习*第17章*，*动画现实：使用Animator、Cinemachine和Timeline创建动画*。我们了解到，FSM是一组状态，每个状态代表一个对象在某一时刻可以执行的动作以及一组转换，这些转换决定了状态如何切换。这个概念不仅用于动画，而且在许多编程场景中都有应用，其中之一就是人工智能。对于人工智能，每个状态将代表在某一时刻可能激活的不同人工智能行为，转换将代表需要满足的条件，以便其他人工智能行为能够激活。例如，在射击游戏中，敌人可以具有诸如**空闲**、**巡逻**、**攻击**、**逃跑**、**躲避**等状态。
- en: 'To further reinforce the FSM concept, we recommend reviewing this link: [https://gameprogrammingpatterns.com/state.html](https://gameprogrammingpatterns.com/state.html).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步强化FSM概念，我们建议回顾以下链接：[https://gameprogrammingpatterns.com/state.html](https://gameprogrammingpatterns.com/state.html)。
- en: 'In this section, we will examine the following AI FSM concepts:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查以下AI FSM概念：
- en: Creating the FSM in C#
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#中创建FSM
- en: Creating transitions
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建转换
- en: Creating the FSM in Visual Scripting
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视觉脚本中创建FSM
- en: Let’s start implementing this FSM theory by creating an FSM in C#.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个C#中的FSM来开始实现这个FSM理论。
- en: Creating the FSM in C#
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在C#中创建FSM
- en: To create our own FSM, we need to recap some basic concepts. Remember that an
    FSM can have a state for each possible action it can execute and that only one
    can be executed at a time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们自己的FSM，我们需要回顾一些基本概念。记住，FSM可以为它可能执行的每个动作都有一个状态，并且一次只能执行一个。
- en: 'In terms of AI, for example, we can be patrolling, attacking, fleeing, and
    so on. Also, remember that there are transitions between states that determine
    conditions to be met to change from one state to another, and in terms of AI,
    this can be the user being near the enemy to start attacking or life being low
    to start fleeing. In the next figure, you can find a simple reminder example of
    the two possible states of a door:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在AI方面，例如，我们可以巡逻、攻击、逃跑等等。同时，记住状态之间有转换，这些转换决定了从一个状态转换到另一个状态所需满足的条件，在AI方面，这可能是用户靠近敌人开始攻击或生命值低开始逃跑。在下一张图中，你可以找到一个简单的门两种可能状态的提醒示例：
- en: '![State diagram - Wikipedia](img/B21361_09_26_PE.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![状态图 - 维基百科](img/B21361_09_26_PE.png)'
- en: 'Figure 9.26: FSM skeleton'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26：FSM骨架
- en: 'There are several ways to implement FSMs for AI; you can even use the `Animator`
    component if you want to or download an FSM system from the Asset Store. In our
    case, we are going to take the simplest approach possible – a single script with
    a set of `if` sentences, which can be basic but is still a good start to understanding
    the concept. Let’s implement it by doing the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实现AI的FSM有几种方法；如果你想的话，甚至可以使用`Animator`组件或从资源商店下载FSM系统。在我们的案例中，我们将采取最简单的方法——一个包含一系列`if`语句的脚本，这可能是基本的，但仍然是理解概念的好开始。让我们通过以下步骤来实现它：
- en: Create a script called `EnemyFSM` in the `AI` child object of the enemy.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在敌人的`AI`子对象中创建一个名为`EnemyFSM`的脚本。
- en: Create an enum called `EnemyState` with the `GoToBase`, `AttackBase`, `ChasePlayer`,
    and `AttackPlayer` values. We are going to have those states in our AI.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`EnemyState`的枚举，包含`GoToBase`、`AttackBase`、`ChasePlayer`和`AttackPlayer`值。我们将在我们的AI中拥有这些状态。
- en: Create a field of the `EnemyState` type called `currentState`, which will hold
    the current state of our enemy:![](img/B21361_09_27_OE.png)
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`currentState`的`EnemyState`类型字段，它将保存我们敌人的当前状态：![图9.26：FSM骨架](img/B21361_09_27_OE.png)
- en: 'Figure 9.27: EnemyFSM state definition'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.27：EnemyFSM状态定义
- en: 'For more information about how enums work, we recommend checking the following
    link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum).'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于枚举如何工作，我们建议查看以下链接：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum)。
- en: Create three functions named after the states we defined.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个以我们定义的状态命名的函数。
- en: Call those functions in `Update` depending on the current state:![](img/B21361_09_28_PE.png)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据当前状态在`Update`中调用这些函数：![图9.28：状态测试](img/B21361_09_28_PE.png)
- en: 'Figure 9.28: An if-based FSM'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.28：基于if的FSM
- en: Yes, you can totally use a switch here, but I just prefer the regular `if` syntax
    for this example.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是的，你完全可以在这里使用switch，但我只是更喜欢这个示例中的常规`if`语法。
- en: 'Test in the Editor how changing the `currentState` field will change which
    state is active, seeing the messages being printed in the **Console** window:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中测试如何通过更改`currentState`字段来改变活动状态，查看在**控制台**窗口中打印的消息：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_09_29_PE.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述自动生成，置信度中等](img/B21361_09_29_PE.png)'
- en: 'Figure 9.29: State testing'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29：状态测试
- en: As you can see, it is a pretty simple but totally functional approach. In the
    future, you could face having to code enemies with many more states, and this
    approach will start to scale badly. In such a case, you could use any FSM plugin
    from the Asset Store you prefer to have more powerful and scalable tools, or even
    consider advanced techniques like behavior trees, but that’s outside the scope
    of this book. Now let’s continue with this FSM, by creating its transitions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个相当简单但完全实用的方法。在未来，您可能需要编写具有更多状态的游戏敌人，这种方法将开始变得不适用。在这种情况下，您可以使用Asset
    Store中您喜欢的任何FSM插件来获得更强大和可扩展的工具，或者甚至考虑更高级的技术，如行为树，但这超出了本书的范围。现在让我们继续使用FSM，通过创建其转换。
- en: Creating transitions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建转换
- en: 'If you remember the transitions created in the Animator Controller, those were
    basically a collection of conditions that checked whether the state the transition
    belongs to is active. In our FSM approach, this translates simply as `if` sentences
    that detect conditions inside the states. Let’s create the transitions between
    our proposed states as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得在Animator Controller中创建的转换，那些基本上是一系列检查转换所属状态是否激活的条件。在我们的FSM方法中，这简单地转化为检测状态内部条件的`if`语句。让我们按照以下方式创建我们提议状态之间的转换：
- en: Add a field of the `Sight` type called `sightSensor` in our FSM script, and
    drag the `AI` GameObject to that field to connect it to the `Sight` component
    there. As the FSM component is in the same object as `Sight`, we can also use
    `GetComponent` instead, but in advanced AIs, you might have different sensors
    that detect different objects, so I prefer to prepare my script for that scenario.
    You should pick the approach you like the most.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的FSM脚本中添加一个名为`sightSensor`的`Sight`类型字段，并将`AI`GameObject拖拽到该字段以连接到那里的`Sight`组件。由于FSM组件与`Sight`组件位于同一对象中，我们也可以使用`GetComponent`，但在高级AI中，您可能有不同的传感器来检测不同的对象，所以我更喜欢为那种情况准备我的脚本。您应该选择您最喜欢的做法。
- en: 'In the `GoToBase` function, check whether the detected object of the `Sight`
    component is not `null`, meaning that something is inside our line of vision.
    If our AI is going toward the base but detects an object in the way, we must switch
    to the `Chase` state to pursue the player, so we change the state, as in the following
    screenshot:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GoToBase`函数中，检查`Sight`组件检测到的对象是否不为`null`，这意味着在我们的视线中有物体。如果我们的AI正在向基地移动但检测到障碍物，我们必须切换到`Chase`状态以追逐玩家，因此我们改变状态，如下截图所示：
- en: '![](img/B21361_09_30_PE.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_30_PE.png)'
- en: 'Figure 9.30: Creating transitions'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30：创建转换
- en: 'Also, we must change to `AttackBase` if we are near enough to the object that
    must be damaged to decrease the base life. We can create a field of the `Transform`
    type called `baseTransform` and drag the player’s base life object we created
    previously there so we can check the distance. Remember to add a `float` field
    called `baseAttackDistance` to make that distance configurable:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果我们离必须损坏的对象足够近，为了减少基础生命值，我们必须切换到`AttackBase`。我们可以创建一个类型为`Transform`的字段，命名为`baseTransform`，并将之前创建的玩家基础生命值对象拖拽到那里，以便我们可以检查距离。记得添加一个名为`baseAttackDistance`的`float`字段，以便可以配置该距离：
- en: '![A screen shot of a computer code  Description automatically generated with
    low confidence](img/B21361_09_31_PE.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![计算机代码屏幕截图，自动生成描述，置信度低](img/B21361_09_31_PE.png)'
- en: 'Figure 9.31: GoToBase transitions'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31：GoToBase转换
- en: 'In the case of `ChasePlayer`, we need to check whether the player is out of
    sight to switch back to the `GoToBase` state or whether we are near enough to
    the player to start attacking it. We will need another `distance` field called
    `PlayerAttackDistance`, which determines the distance to attack the player, and
    we might want different attack distances for those two targets. Consider an early
    return in the transition to prevent getting `null` reference exceptions if we
    try to access the position of the sensor-detected object when there are not any:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ChasePlayer`的情况下，我们需要检查玩家是否在视线之外，以便切换回`GoToBase`状态，或者我们是否足够接近玩家以开始攻击它。我们需要另一个名为`PlayerAttackDistance`的`distance`字段，它决定了攻击玩家的距离，我们可能希望为这两个目标设置不同的攻击距离。考虑在转换中提前返回，以防止在没有任何传感器检测到的对象时尝试访问传感器检测到的对象的位置时出现`null`引用异常：
- en: '![A picture containing text, screenshot, font  Description automatically generated](img/B21361_09_32_PE.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体描述的图片，自动生成描述](img/B21361_09_32_PE.png)'
- en: 'Figure 9.32: ChasePlayer transitions'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32：追逐玩家转换
- en: For `AttackPlayer`, we need to check whether the player is out of sight to get
    back to `GoToBase` or whether it is far enough to go back to chasing it. You will
    notice how we multiplied `playerAttackDistance` to make the stop-attacking distance
    a little bit greater than the start-attacking distance; this will prevent switching
    back and forth rapidly between attacking and chasing when the player is near that
    distance.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`AttackPlayer`，我们需要检查玩家是否在视线之外，以便返回`GoToBase`，或者它是否足够远，可以返回追逐它。您会注意到我们是如何将`playerAttackDistance`乘以，使停止攻击的距离略大于开始攻击的距离；这将防止当玩家接近那个距离时在攻击和追逐之间快速切换。
- en: 'You can make it configurable instead of hardcoding `1.1`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将它设置为可配置的，而不是硬编码`1.1`：
- en: '![A screen shot of a computer code  Description automatically generated with
    low confidence](img/B21361_09_33_PE.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![计算机代码屏幕截图，自动生成描述，置信度低](img/B21361_09_33_PE.png)'
- en: 'Figure 9.33: AttackPlayer transitions'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.33：攻击玩家状态转换
- en: In our case, `AttackBase` won’t have any transition. Once the enemy is near
    enough to the base to attack it, it will stay like that, even if the player starts
    shooting at it. Its only objective once there is to destroy the base.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的例子中，`AttackBase` 不会有任何转换。一旦敌人足够接近基地以攻击它，它就会保持这种状态，即使玩家开始射击它。一旦到达那里，它的唯一目标就是摧毁基地。
- en: 'Remember you can use `Gizmos` to draw the distances:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住您可以使用`Gizmos`来绘制距离：
- en: '![A picture containing text, screenshot, font, line  Description automatically
    generated](img/B21361_09_34_PE.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、行的图片，自动生成描述](img/B21361_09_34_PE.png)'
- en: 'Figure 9.34: FSM Gizmos'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.34：有限状态机（FSM）组件
- en: 'Test the script by selecting the `AI` object prior to clicking **Play** and
    then moving the player around, checking how the states change in the **Inspector**
    pane. You can also keep the original `print` messages in each state to see them
    changing in the **Console** window. Remember to set the attack distances and the
    references to the objects. In the screenshot, you can see the settings we use:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在点击**播放**之前选择`AI`对象，然后移动玩家，检查**检查器**面板中状态的变化来测试脚本。您还可以保留每个状态中的原始`print`消息，以在**控制台**窗口中查看它们的变化。请记住设置攻击距离和对象引用。在屏幕截图中，您可以查看我们使用的设置：
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_09_35_PE.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，自动生成描述](img/B21361_09_35_PE.png)'
- en: 'Figure 9.35: Enemy FSM settings'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.35：敌人有限状态机（FSM）设置
- en: A little problem that we will have now is that the spawned enemies won’t have
    the needed references to make the distance calculations to the player’s base transform.
    You will notice that if you try to apply the changes on the enemy of the scene
    to the Prefab (**Overrides | Apply All**), the **Base Transform** variable will
    say **None**. Remember that Prefabs cannot contain references to objects in the
    scene, which complicates our work here. One alternative would be to create `BaseManager`,
    a singleton that holds the reference to the damage position, so our `EnemyFSM`
    can access it. Another one could be to make use of functions such as `GameObject.Find`
    to find our object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将遇到的一个小问题是生成的敌人将没有需要的引用来计算到玩家基地变换的距离。您会注意到，如果您尝试将场景中的敌人更改应用到预制件（**覆盖 | 应用全部**），则**基地变换**变量将显示为**None**。请记住，预制件不能包含对场景中对象的引用，这使我们的工作变得复杂。一个替代方案是创建`BaseManager`，一个单例，它持有对损伤位置的引用，这样我们的`EnemyFSM`就可以访问它。另一个方案是利用`GameObject.Find`等函数来查找我们的对象。
- en: In this case, we will use the latter. Even though it can be less performant
    than the `Manager` version, I want to show you how to use it to expand your Unity
    toolset. In this case, just set the `baseTransform` field in `Awake` to the return
    of `GameObject`.`Find`, using `BaseDamagePoint` as the first parameter, which
    will look for an object with the same name, as in the following screenshot.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用后者。尽管它可能不如`Manager`版本性能好，但我想要向您展示如何使用它来扩展您的Unity工具集。在这种情况下，只需将`baseTransform`字段在`Awake`中设置为`GameObject`.`Find`的返回值，使用`BaseDamagePoint`作为第一个参数，这将查找具有相同名称的对象，如下面的屏幕截图所示。
- en: 'You will see that now our wave-spawned enemies will change states:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到现在我们生成的敌人波次将改变状态：
- en: '![A picture containing text, font, line, screenshot  Description automatically
    generated](img/B21361_09_36_PE.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、行、截图的图片，自动生成描述](img/B21361_09_36_PE.png)'
- en: 'Figure 9.36: Searching for an object in the scene by name'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.36：通过名称在场景中搜索对象
- en: When I started learning about AI for games, I thought I was going to create
    Skynet using complex algorithms like deep learning. As you can see, we are far
    away from that, and the reason is that AI for games doesn’t need to be intelligent;
    it needs to be fun. Making it so requires careful design to generate the exact
    desired experience, which could be difficult to achieve with cutting-edge AI technology.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始学习关于游戏人工智能时，我以为我会使用像深度学习这样的复杂算法来创建天网。正如你所见，我们离那个目标还很远，原因在于游戏人工智能不需要智能，它需要的是趣味性。要实现这一点，需要精心设计来生成确切期望的体验，而这可能使用尖端的人工智能技术很难实现。
- en: 'Having said that, there are other AI techniques, like behavior trees, which
    you can learn about it in this Halo developers’ article: [https://www.gamedeveloper.com/programming/gdc-2005-proceeding-handling-complexity-in-the-i-halo-2-i-ai](https://www.gamedeveloper.com/programming/gdc-2005-proceeding-handling-complexity-in-the-i-halo-2-i-ai)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，还有其他人工智能技术，比如行为树，你可以在本篇光环开发者文章中了解更多：[https://www.gamedeveloper.com/programming/gdc-2005-proceeding-handling-complexity-in-the-i-halo-2-i-ai](https://www.gamedeveloper.com/programming/gdc-2005-proceeding-handling-complexity-in-the-i-halo-2-i-ai)
- en: 'Other alternative is called GOAP, and I recommend reading this paper from the
    F.E.A.R. developers: [https://www.gamedevs.org/uploads/three-states-plan-ai-of-fear.pdf](https://www.gamedevs.org/uploads/three-states-plan-ai-of-fear.pdf)
    Finally, there’s the Game AI Pro book series, which collects several game AI-related
    papers, and you can learn more about it here: [http://www.gameaipro.com/](http://www.gameaipro.com/)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个名为GOAP的替代方案，我建议阅读来自F.E.A.R.开发者的这篇论文：[https://www.gamedevs.org/uploads/three-states-plan-ai-of-fear.pdf](https://www.gamedevs.org/uploads/three-states-plan-ai-of-fear.pdf)
    最后，还有游戏人工智能专业书籍系列，它收集了多篇与游戏人工智能相关的论文，你可以在这里了解更多：[http://www.gameaipro.com/](http://www.gameaipro.com/)
- en: In this section, we made our FSM properly switch states according to the data
    provided by sensors and other sources, laying the foundation to start scripting
    the actual behavior of each state. Now that our FSM states are coded and execute
    transitions properly, let’s see how to do the same in Visual Scripting. Feel free
    to skip the following section if you are only interested in the C# version.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使我们的有限状态机（FSM）能够根据传感器和其他来源提供的数据正确切换状态，为开始编写每个状态的实际行为奠定基础。现在我们的FSM状态已经编码并且能够正确执行转换，让我们看看如何在视觉脚本中做到同样的事情。如果你只对C#版本感兴趣，可以自由跳过以下部分。
- en: Creating the FSM in Visual Scripting
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在视觉脚本中创建FSM
- en: 'So far, most scripts in Visual Scripting were almost a mirror of the C# version
    with some differences in some nodes. Regarding state machines, we could do the
    same; instead, we are going to use the **State Machine** system of Visual Scripting.
    The concept is the same – you have states and can switch them – but how the states
    are organized and when the transitions trigger is managed visually, in a similar
    way as the **Animator** system does. So, let’s see how we can use the system by
    creating our first **State Machine Graph** and some states. Follow these steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大多数视觉脚本中的脚本几乎是对C#版本的镜像，只是在一些节点上有所不同。至于状态机，我们本可以做到一样；相反，我们将使用视觉脚本的**状态机**系统。概念是相同的——你有状态并且可以切换它们——但是状态的组织方式和何时触发转换是由视觉管理的，这与**动画器**系统类似。所以，让我们看看如何通过创建我们的第一个**状态机图**和一些状态来使用这个系统。按照以下步骤操作：
- en: Add the **State Machine** component to our enemy. Remember it is called **State
    Machine** and not **Script Machine**, the latter being the component for regular
    Visual Scripts.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**状态机**组件添加到我们的敌人身上。请记住，它被称为**状态机**，而不是**脚本机**，后者是常规视觉脚本的组件。
- en: Click the **New** button in the component and select a place to save the fixed
    asset in a similar way to what we have done so far for regular Visual Scripts.
    In my case, I called it `EnemyFSM`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件中点击**新建**按钮，并选择一个位置来保存固定资产，方式与我们迄今为止为常规视觉脚本所做的一样。在我的例子中，我将其命名为`EnemyFSM`。
- en: '![A screenshot of a state machine  Description automatically generated with
    medium confidence](img/B21361_09_37_PE.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![状态机的截图，描述由中等置信度自动生成](img/B21361_09_37_PE.png)'
- en: 'Figure 9.37: Creating a Visual Scripting State Machine'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.37：创建视觉脚本状态机
- en: Double-click **State Machine Graph** to edit it as usual.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**状态机图**以像往常一样编辑它。
- en: 'Right-click in any empty area of the **Graph** editor and select **Create Script
    State** in order to create a new state:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图**编辑器的任何空白区域右键单击，然后选择**创建脚本状态**以创建一个新状态：
- en: '![A picture containing text, screenshot, font, rectangle  Description automatically
    generated](img/B21361_09_38_PE.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、字体、矩形的图片，描述由自动生成](img/B21361_09_38_PE.png)'
- en: 'Figure 9.38: Creating our first Visual Scripting State Machine state'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.38：创建我们的第一个可视化脚本状态机状态
- en: 'Repeat *step 4* until you end up having four states:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤 4*，直到您拥有四个状态：
- en: '![](img/B21361_09_39_PE.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_39_PE.png)'
- en: 'Figure 9.39: Visual Scripting states'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.39：可视化脚本状态
- en: 'Select any of them and, in the **Info** panel on the left, fill the **Title**
    field (the first one) with the name of any of the states we created before (`GoToBase`,
    `AttackBase`, `ChasePlayer`, and `AttackPlayer`). If you don’t see the **Info**
    panel, click the button with the **i** in the middle to display it:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何一个状态，然后在左侧的**信息**面板中，将**标题**字段（第一个字段）填写为我们之前创建的任何状态的名称（`GoToBase`、`AttackBase`、`ChasePlayer`和`AttackPlayer`）。如果您看不到**信息**面板，请点击中间带有**i**的按钮以显示它：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_09_40_PE.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，描述由中等置信度自动生成](img/B21361_09_40_PE.png)'
- en: 'Figure 9.40: Renaming a Visual Scripting state'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.40：重命名可视化脚本状态
- en: 'Repeat that for the rest of the state nodes until you have each node named
    after each state created in the *Creating the FSM in C#* section of this chapter:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对其余的状态节点重复此操作，直到每个节点都按照本章*在 C# 中创建有限状态机*部分创建的状态命名：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_09_41_PE.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，描述由低置信度自动生成](img/B21361_09_41_PE.png)'
- en: 'Figure 9.41: All the needed states'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.41：所有所需的状态
- en: You can see one of the states has a green bar at the top, which represents which
    node is supposed to be the first one. I renamed that initial state `GoToBase`
    as that’s the one I prefer to be first. If you don’t have that one as the starting
    one, right-click the node that currently has the green bar in your state machine,
    select **Toggle Start** to remove the green bar from it, and then repeat for the
    node that you want to be the first one (`GoToBase` in our scenario), adding the
    green bar to that one.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到其中一个状态顶部有一个绿色条，这代表哪个节点应该是第一个。我将那个初始状态重命名为`GoToBase`，因为这是我首选的第一个状态。如果您没有将其作为起始状态，请右键单击当前具有绿色条的状态机中的节点，选择**切换起始**以从它中移除绿色条，然后对您想要作为第一个的节点（在我们的场景中是`GoToBase`）重复此操作，将绿色条添加到该节点上。
- en: Something to consider is that you can have more than one start state in Visual
    Scripting, meaning you can have multiple states running at the same time and transitioning.
    If possible, I recommend avoiding having more than one state active at a time
    to make things simple.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要考虑的是，在可视化脚本中可以有一个以上的起始状态，这意味着您可以同时运行多个状态并进行转换。如果可能，我建议一次不要激活多个状态，以使事情变得简单。
- en: 'Double-click `GoToBase` to enter the edit mode for these states. Connect a
    **String** node to the **Print** **Message** input pin in the **OnUpdate** event
    node to print a message saying **GoToBase**:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`GoToBase`以进入这些状态的编辑模式。将一个**字符串**节点连接到**OnUpdate**事件节点中的**打印** **消息**输入引脚，以打印一条表示**GoToBase**的消息：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_09_42_PE.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，描述由低置信度自动生成](img/B21361_09_42_PE.png)'
- en: 'Figure 9.42: Our first state machine logic'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.42：我们的第一个状态机逻辑
- en: 'In the top bar, click the **EnemyFSM** label at the left of **GoToBase** in
    order to return to the whole **State Machine** view. If you don’t see it, click
    any text label to the right of the third button (the one that looks like **<x>**):'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部栏中，点击**GoToBase**左侧的**EnemyFSM**标签以返回到整个**状态机**视图。如果您看不到它，请点击第三个按钮（看起来像**<x>**）右侧的任何文本标签：
- en: '![](img/B21361_09_43_PE.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_43_PE.png)'
- en: 'Figure 9.43: Returning to the State Machine editor mode'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.43：返回到状态机编辑模式
- en: Feel free to delete the other event nodes if you are not planning to use them.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不打算使用它们，可以随意删除其他事件节点。
- en: Repeat *steps 9* to *11* for each state until all of them print their names.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个状态重复执行*步骤 9*到*11*，直到所有状态都打印出它们的名称。
- en: 'With this, we have created the nodes representing the possible states of our
    AI. In the next section, we will be adding logic for them to something meaningful,
    but before that, we need to create the transitions between the states and the
    conditions that need to be met to trigger them by doing the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经创建了表示我们AI可能状态的节点。在下一节中，我们将为它们添加逻辑，使其变得有意义，但在那之前，我们需要创建状态之间的转换以及触发它们的条件，具体操作如下：
- en: Create variables in the **Variables** component of the enemy called `baseTransform`,
    `baseAttackDistance`, and `playerAttackDistance`, as we are going to need them
    to do the transitions.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在敌人的**变量**组件中创建变量`baseTransform`、`baseAttackDistance`和`playerAttackDistance`，因为我们需要它们来进行转换。
- en: 'Don’t set any type to `baseTransform` as we will fill it later via code, but
    regarding `baseAttackDistance`, make it using the **Float** type and put a value
    of `2`, and finally, for `playerAttackDistance`, also use **Float** and a value
    of `3`. Feel free to change those values if you prefer:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要将任何类型设置为`baseTransform`，因为我们将在稍后通过代码填充它，但关于`baseAttackDistance`，使用**Float**类型并设置值为`2`，最后，对于`playerAttackDistance`，也使用**Float**并设置值为`3`。如果您愿意，可以更改这些值：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_09_44_PE.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图  描述由低置信度自动生成](img/B21361_09_44_PE.png)'
- en: 'Figure 9.44: Variables needed for our transitions'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.44：我们转换所需的变量
- en: 'Right-click the `GoToBase` node, select the **Make Transition** option, and
    then click the `ChasePlayer` node. This will create a transition between the two
    states:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`GoToBase`节点，选择**创建转换**选项，然后单击`ChasePlayer`节点。这将在这两个状态之间创建一个转换：
- en: '![](img/B21361_09_45_PE.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_45_PE.png)'
- en: 'Figure 9.45: A transition between two states'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.45：两个状态之间的转换
- en: 'Repeat *step 3* for each transition we created in the C# version. The **State
    Machine** graph will need to look like the following screenshot:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于在C#版本中创建的每个转换，重复*步骤3*。**状态机**图需要看起来像以下截图：
- en: '![](img/B21361_09_46_PE.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_46_PE.png)'
- en: 'Figure 9.46: All the needed transitions'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.46：所有需要的转换
- en: Double-click the yellow shape in the middle of the transition between **GoToBase**
    and **ChasePlayer** to enter the **Transition** mode. Here, you will be able to
    specify the condition that will trigger that transition (instead of using an `If`
    node during the state logic). Remember, you have two yellow shapes, one for each
    transition direction, so check you are double-clicking the correct one based on
    the white arrows connecting them.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**GoToBase**和**ChasePlayer**之间转换中间的黄色形状以进入**转换**模式。在这里，您将能够指定将触发该转换的条件（而不是在状态逻辑中使用`If`节点）。请记住，您有两个黄色形状，每个方向一个，所以请确保您双击的是基于连接它们的白色箭头的正确形状。
- en: 'Modify the graph to check whether the `sensedObject` variable is not `null`.
    It should look like this:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改图以检查`sensedObject`变量是否不是`null`。它应该看起来像这样：
- en: '![](img/B21361_09_47_PE.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_47_PE.png)'
- en: 'Figure 9.47: Adding a transition condition'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.47：添加转换条件
- en: 'The transition between **GoToBase** and **AttackBase** should look like this:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GoToBase**和**AttackBase**之间的转换应该如下所示：'
- en: '![](img/B21361_09_48_PE.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_48_PE.png)'
- en: 'Figure 9.48: The GoToBase to AttackBase transition condition'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.48：GoToBase到AttackBase的转换条件
- en: 'Now, **ChasePlayer** to **GoToBase** should be as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，**ChasePlayer**到**GoToBase**应该如下所示：
- en: '![](img/B21361_09_49_PE.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_49_PE.png)'
- en: 'Figure 9.49: The ChasePlayer to GoToBase transition condition'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.49：ChasePlayer到GoToBase的转换条件
- en: 'For the **ChasePlayer** to **AttackPlayer** transition, do as in *Figure 9.50*.
    This is essentially the same as **GoToBase** and **AttackBase** (a distance check)
    but with different targets:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**ChasePlayer**到**AttackPlayer**的转换，按照*图9.50*中的操作进行。这本质上与**GoToBase**和**AttackBase**（距离检查）相同，但目标不同：
- en: '![](img/B21361_09_50_PE.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_50_PE.png)'
- en: 'Figure 9.50: The ChasePlayer to AttackPlayer transition condition'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.50：ChasePlayer到AttackPlayer的转换条件
- en: 'For the **AttackPlayer** to **ChasePlayer** transition, do as in *Figure 9.51*.
    This is another distance check but is now checking whether the distance is greater
    and multiplying the distance by `1.1` (to prevent transition jittering, as we
    explained in the C# version):'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**AttackPlayer**到**ChasePlayer**的转换，按照*图9.51*中的操作进行。这是另一个距离检查，但现在检查距离是否更大，并将距离乘以`1.1`（以防止转换抖动，如我们在C#版本中解释的）：
- en: '![](img/B21361_09_51_PE.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_51_PE.png)'
- en: 'Figure 9.51: The AttackPlayer to ChasePlayer transition condition'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.51：AttackPlayer到ChasePlayer的转换条件
- en: 'Finally, for **AttackPlayer** to **GoToBase**, this is the expected graph:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于 **AttackPlayer** 到 **GoToBase**，这是预期的图：
- en: '![](img/B21361_09_52_PE.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_52_PE.png)'
- en: 'Figure 9.52: The AttackPlayer to GoToBase transition condition'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.52：从 **AttackPlayer** 到 **GoToBase** 的转换条件
- en: A little detail we need to tackle before moving on is the fact that we still
    don’t have any value set in the `baseTransform` variable. The idea is to fill
    it via code as we did in the C# version. But something to consider here is that
    we cannot add an **Awake** event node to the whole state machine, but just to
    the states.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要解决的一个小细节是我们还没有在 `baseTransform` 变量中设置任何值。想法是通过代码填充它，就像我们在 C# 版本中所做的那样。但这里需要考虑的是，我们无法将
    **Awake** 事件节点添加到整个状态机中，而只能添加到状态中。
- en: In this scenario, we could use the **OnEnterState** event, which is an exclusive
    event node for state machines. It will execute as soon as the state becomes active,
    which is useful for state initializations. We could add the logic to initialize
    the `baseTransform` variable in the **OnEnterState** event node of the **GoToBase**
    state, given it is the first state we execute.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们可以使用 **OnEnterState** 事件，这是状态机的专用事件节点。它将在状态变为活动状态时立即执行，这对于状态初始化很有用。我们可以将初始化
    `baseTransform` 变量的逻辑添加到 **GoToBase** 状态的 **OnEnterState** 事件节点中，前提是它是我们首先执行的状态。
- en: 'This way, the **GoToBase** logic will look as in *Figure 9.53*. Remember to
    double-click the state node to edit it:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，**GoToBase** 逻辑将看起来像 *图 9.53*。请记住双击状态节点来编辑它：
- en: '![](img/B21361_09_53_PE.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_53_PE.png)'
- en: 'Figure 9.53: The GoToBase initialization logic'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.53：**GoToBase** 的初始化逻辑
- en: Notice how, here, we set the result of the **Find** node into the variable only
    on the **Null** pin of **Null Check**. What **Null Check** does is check if our
    `baseTransform` variable is set, going through the **Not Null** pin if it is,
    and **Null** if it isn’t. This way, we avoid executing `GameObject.Find` every
    time we enter the **GoToBase** state, but only the first time. Also note that,
    in this case, we will be executing the **Set Variable** node not only when the
    object initializes but also each time **GoToBase** becomes the current state.
    If, in any case, that results in unexpected behavior, other options could be to
    create a new initial state that initializes everything and then transitions to
    the rest of the states, or maybe do a classic Visual Scripting graph that initializes
    those variables in the **On Start** event node.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里，我们将 **Find** 节点的结果仅设置到 **Null Check** 的 **Null** 插针上的变量中。**Null Check**
    的作用是检查我们的 `baseTransform` 变量是否已设置，如果是，则通过 **Not Null** 插针，如果不是，则通过 **Null** 插针。这样，我们就可以避免每次进入
    **GoToBase** 状态时都执行 `GameObject.Find`，而只需第一次执行。此外，请注意，在这种情况下，我们将不仅当对象初始化时执行 **Set
    Variable** 节点，而且每次 **GoToBase** 成为当前状态时也会执行。如果这导致意外的行为，其他选项可能是创建一个新的初始状态，初始化所有内容，然后过渡到其他状态，或者也许可以创建一个经典的视觉脚本图，在
    **On Start** 事件节点中初始化这些变量。
- en: With all this, we learned how to create a decision-making system for our AI
    through FSMs. It will make decisions based on the info gathered via sensors and
    other systems. Now that our FSM states are coded and transition properly, let’s
    make them do something.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有这些，我们学习了如何通过 FSM 创建 AI 的决策系统。它将根据通过传感器和其他系统收集的信息做出决策。现在我们的 FSM 状态已经编码并且过渡得当，让我们让它们做一些事情。
- en: Executing FSM actions
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 FSM 动作
- en: Now we need to complete the last step – make the FSM do something interesting.
    Here, we can do a lot of things such as shoot the base or the player and move
    the enemy toward its target (the base or the player). We will be handling movement
    with the Unity Pathfinding system called `NavMesh`, a tool that allows our AI
    to calculate and traverse paths between two points while avoiding obstacles, which
    needs some preparation to work properly.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要完成最后一步——让 FSM 做一些有趣的事情。在这里，我们可以做很多事情，比如射击基地或玩家，并将敌人移动到其目标（基地或玩家）。我们将使用
    Unity 的寻路系统 `NavMesh` 来处理移动，这是一个允许我们的 AI 在两点之间计算和遍历路径，同时避开障碍物的工具，它需要一些准备才能正常工作。
- en: 'In this section, we will examine the following FSM action concepts:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查以下 FSM 动作概念：
- en: Calculating our scene’s NavMesh
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算场景的 NavMesh
- en: Using Pathfinding
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用寻路算法
- en: Adding final details
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加最终细节
- en: Let’s start by preparing our scene for movement with Pathfinding.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为使用寻路算法的场景做准备。
- en: Calculating our scene’s NavMesh
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算场景的 NavMesh
- en: 'Pathfinding algorithms rely on simplified versions of the scene. Analyzing
    the full geometry of a complex scene is almost impossible to do in real time.
    There are several ways to represent Pathfinding information extracted from a scene,
    such as graphs and **NavMesh** geometries. Unity uses the latter – a simplified
    mesh similar to a 3D model that spans all areas that Unity determines are walkable.
    In the next screenshot, you can find an example of `NavMesh` generated in a scene
    – that is, the light blue geometry:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 寻路算法依赖于场景的简化版本。分析复杂场景的完整几何形状在实时中几乎是不可能的。有几种方式可以表示从场景中提取的寻路信息，例如图和**NavMesh**几何形状。Unity使用后者——一个类似于3D模型的简化网格，它跨越Unity确定的所有可通行区域。在下一张截图，你可以找到一个场景中生成的`NavMesh`示例——即，浅蓝色几何形状：
- en: '![](img/B21361_09_54_PE.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_54_PE.png)'
- en: 'Figure 9.54: NavMesh of walkable areas in the scene'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.54：场景中可通行区域的NavMesh
- en: Generating `NavMesh` can take from seconds to minutes depending on the size
    of the scene. That’s why Unity’s Pathfinding system calculates the `NavMesh` once
    in the Editor, so when we distribute our game, the user will use the pre-generated
    `NavMesh`. In previous Unity versions, like lightmapping, `NavMesh` used to be
    baked into a file for later use. That meant that GameObjects that contributed
    to the `NavMesh` surface used to be static, and that they couldn’t suffer any
    modifications of the scene during runtime. The main advantage of the new AI navigation
    system in Unity is that `NavMesh` objects can now change during runtime. If you
    destroy or move a floor tile, the AI will still adapt its behavior to walk, stay,
    or fall over that area. This means if a floor tile is destroyed during gameplay,
    the `NavMesh` dynamically updates to reflect this change, showing the AI where
    it can no longer walk. We will install and use the AI Navigation package to add
    this behavior to our game.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 生成`NavMesh`可能需要几秒到几分钟，这取决于场景的大小。这就是为什么Unity的寻路系统在编辑器中只计算一次`NavMesh`，这样当我们发布我们的游戏时，用户将使用预先生成的`NavMesh`。在之前的Unity版本中，就像光照贴图一样，`NavMesh`通常会被烘焙到一个文件中以便以后使用。这意味着对`NavMesh`表面有贡献的GameObject曾经是静态的，并且在运行时不能对场景进行任何修改。Unity中新的AI导航系统的主要优势是`NavMesh`对象现在可以在运行时改变。如果你摧毁或移动一个地板砖，AI仍然会调整其行为以在该区域行走、停留或跌倒。这意味着如果在游戏过程中摧毁地板砖，`NavMesh`会动态更新以反映这一变化，显示AI不能再行走的区域。我们将安装并使用AI导航包来将这种行为添加到我们的游戏中。
- en: 'To generate `NavMesh` for our scene, do the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的场景生成`NavMesh`，请执行以下操作：
- en: Open Package Manager (**Window** | **Package Manager**).
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开包管理器（**窗口** | **包管理器**）。
- en: Set the **Packages** dropdown to **Unity Registry** mode.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**包**下拉菜单设置为**Unity注册表**模式。
- en: 'Search the list for a package called AI Navigation. This package will allow
    us to have access to new components that will help us define which surfaces are
    walkable and which agents can walk on top of them. At the time of writing the
    book, the current version of this package is 1.1.4:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中搜索一个名为AI导航的包。这个包将使我们能够访问新的组件，这些组件将帮助我们定义哪些表面是可走的，哪些代理可以走在上面。在撰写本书时，这个包的当前版本是1.1.4：
- en: '![](img/B21361_09_55.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_55.png)'
- en: 'Figure 9.55: Installing the AI Navigation package'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.55：安装AI导航包
- en: Add a `NavMeshSurface` component to the walkable surface.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NavMeshSurface`组件添加到可通行表面。
- en: 'From the recently added component, click on the **Bake** button at the bottom
    of the window, and check the generated `NavMesh`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从最近添加的组件中，点击窗口底部的**烘焙**按钮，并检查生成的`NavMesh`：
- en: '![](img/B21361_09_56.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_56.png)'
- en: 'Figure 9.56: Generating a NavMesh'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.56：生成NavMesh
- en: And that’s pretty much everything you need to do. Of course, there are lots
    of settings you can fiddle around with in this component, such as **Max Slope**,
    which indicates the maximum angle of slopes the AI will be able to climb, or **Step
    Height**, which will determine whether the AI can climb stairs, connecting the
    floors between the steps in `NavMesh`, but as we have a plain and simple scene,
    the default settings will suffice.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 大概这就是你需要做的所有事情。当然，在这个组件中有很多设置你可以调整，例如**最大坡度**，它表示AI能够爬升的最大角度，或者**步高**，这将决定AI是否能够爬楼梯，连接`NavMesh`中楼梯之间的楼层，但鉴于我们有一个简单直接的场景，默认设置就足够了。
- en: If you want to play around with them, you can go to the menu bar and select
    **Window** | **AI** | **Navigation**. From there, you will be able to adjust all
    these parameters and re-bake the `NavMeshSurface` to adjust the walkable areas
    depending on the size of the AI agents.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想玩弄它们，你可以转到菜单栏并选择**窗口** | **AI** | **导航**。从那里，你将能够调整所有这些参数并重新烘焙`NavMeshSurface`以根据AI代理的大小调整可通行区域。
- en: With our scene’s `NavMesh` set up, we’ve laid the groundwork for sophisticated
    AI movement. Let’s see this in action as we program our AI to navigate the game
    world.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们场景的`NavMesh`设置完成后，我们已经为复杂的AI移动打下了基础。让我们通过编程我们的AI在游戏世界中导航来观察这一过程。
- en: Using Pathfinding
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用路径查找
- en: For making an AI object that moves with `NavMesh`, Unity provides the `NavMeshAgent`
    component, which will make our AI stick to `NavMesh`, preventing the object from
    going outside it. It will not only calculate the path to a specified destination
    automatically but will also move the object through the path with the use of **Steering**
    behavior algorithms that mimic the way a human would move through the path, slowing
    down on corners and turning with interpolations instead of instantaneously. This
    component also ensures AI characters avoid each other. It prevents crowding by
    steering each character away from others, maintaining a natural flow in the game.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作一个使用`NavMesh`移动的AI对象，Unity提供了`NavMeshAgent`组件，这将使我们的AI粘附在`NavMesh`上，防止对象超出其范围。它不仅会自动计算到指定目的地的路径，还会使用**引导**行为算法通过路径移动对象，模仿人类通过路径移动的方式，在拐角处减速，并通过插值而不是瞬间转向。此组件还确保AI角色彼此避免。它通过将每个角色引导远离其他角色来防止拥挤，保持游戏中的自然流动。
- en: 'Let’s use this powerful component by doing the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下方式使用这个强大的组件：
- en: 'Select the **Enemy** Prefab and add the `NavMeshAgent` component to it. Add
    it to the root object, the one called `Enemy`, not the AI child – we want the
    whole object to move. You will see a cylinder around the object representing the
    area the object will occupy in `NavMesh`. Note that this isn’t a collider, so
    it won’t be used for physical collisions:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**敌人**预制体，并向其添加`NavMeshAgent`组件。将其添加到根对象中，即名为`Enemy`的对象，而不是AI子对象——我们希望整个对象都能移动。你将看到围绕对象的一个圆柱体，表示对象在`NavMesh`中将占用的区域。注意，这并不是一个碰撞器，因此它不会被用于物理碰撞：
- en: '![](img/B21361_09_57_PE.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_57_PE.png)'
- en: 'Figure 9.57: The NavMeshAgent component'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.57：NavMeshAgent组件
- en: Remove the `ForwardMovement` component; from now on, we will drive the movement
    of our enemy with `NavMeshAgent`.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`ForwardMovement`组件；从现在起，我们将用`NavMeshAgent`驱动敌人的移动。
- en: In the `Awake` event function of the `EnemyFSM` script, use the `GetComponentInParent`
    function to cache the reference of `NavMeshAgent` into a new `private` variable.
    This will work similarly to `GetComponent` – it will look for a component in our
    GameObject, but if the component is not there, this version will try to look for
    that component in all parents. Remember to add the `using UnityEngine.AI` line
    to use the `NavMeshAgent` class in this script:![](img/B21361_09_58_PE.png)
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyFSM`脚本的`Awake`事件函数中，使用`GetComponentInParent`函数将`NavMeshAgent`的引用缓存到一个新的`private`变量中。这会与`GetComponent`类似工作——它将在我们的GameObject中查找组件，但如果组件不存在，这个版本将尝试在所有父组件中查找该组件。记得添加`using
    UnityEngine.NavMesh`行以在脚本中使用`NavMeshAgent`类！![图片](img/B21361_09_58_PE.png)
- en: 'Figure 9.58: Caching a parent component reference'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.58：缓存父组件引用
- en: As you can imagine, there is also the `GetComponentInChildren` method, which
    searches components in `GameObject` first and then in all its children if necessary.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所想，还有一个`GetComponentInChildren`方法，它首先在`GameObject`中搜索组件，如果需要，再在其所有子组件中搜索。
- en: 'In the `GoToBase` state function, call the `SetDestination` function of the
    `NavMeshAgent` reference, passing the position of the base object as the target:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GoToBase`状态函数中，调用`NavMeshAgent`引用的`SetDestination`函数，传入基地对象的坐标作为目标：
- en: '![](img/B21361_09_59_PE.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_09_59_PE.png)'
- en: 'Figure 9.59: Setting a destination for our AI'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.59：为我们的AI设置目的地
- en: Save the script and test this with a few enemies in the scene or with the enemies
    spawned by the waves. You will see the problem where the enemies will never stop
    going toward the target position, entering inside the object, if necessary, even
    if the current state of their FSMs changes when they are near enough. That’s because
    we never tell `NavMeshAgent` to stop, which we can do by setting the `isStopped`
    field of the agent to `true`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并在场景中的几个敌人或由波次生成的敌人上测试这个脚本。你会看到问题，敌人永远不会停止向目标位置移动，如果需要，甚至进入对象内部，即使他们的有限状态机（FSM）的当前状态在它们足够接近时发生变化。这是因为我们从未告诉`NavMeshAgent`停止，我们可以通过将智能体的`isStopped`字段设置为`true`来实现这一点。
- en: 'You might want to tweak the base attack distance to make the enemy stop a little
    bit closer or further away:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能想要调整基础攻击距离，使敌人停止得更近或更远一些：
- en: '![](img/B21361_09_60_PE.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_60_PE.png)'
- en: 'Figure 9.60: Stopping agent movement'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.60：停止智能体移动
- en: 'We can do the same for `ChasePlayer` and `AttackPlayer`. In `ChasePlayer`,
    we can set the destination of the agent to the player’s position, and in `AttackPlayer`,
    we can stop the movement. In this scenario, `AttackPlayer` can go back again to
    `GoToBase` or `ChasePlayer`, so you need to set the `isStopped` agent field to
    `false` in those states or before doing the transition. We will pick the former,
    as that version will cover other states that also stop the agent without extra
    code. We will start with the `GoToBase` state:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以为`ChasePlayer`和`AttackPlayer`做同样的事情。在`ChasePlayer`中，我们可以将智能体的目的地设置为玩家的位置，在`AttackPlayer`中，我们可以停止移动。在这种情况下，`AttackPlayer`可以再次回到`GoToBase`或`ChasePlayer`，所以你需要在这些状态中将智能体的`isStopped`字段设置为`false`或在进行转换之前。我们将选择前者，因为这个版本将涵盖其他也需要停止智能体的状态，而无需额外的代码。我们将从`GoToBase`状态开始：
- en: '![](img/B21361_09_61_PE.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_61_PE.png)'
- en: 'Figure 9.61: Reactivating the agent'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.61：重新激活智能体
- en: 'Then, continue with `ChasePlayer`:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，继续使用`ChasePlayer`：
- en: '![](img/B21361_09_62_PE.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_62_PE.png)'
- en: 'Figure 9.62: Reactivating the agent and chasing the player'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.62：重新激活智能体并追逐玩家
- en: 'And finally, continue with `AttackPlayer`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，继续使用`AttackPlayer`：
- en: '![](img/B21361_09_63_PE.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_09_63_PE.png)'
- en: 'Figure 9.63: Stopping the movement'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.63：停止移动
- en: You can tweak the **Acceleration**, **Speed**, and **Angular Speed** properties
    of `NavMeshAgent` to control how fast the enemy will move. Balance these settings
    to make sure the AI moves in a way that makes sense in your game. Also, remember
    to apply the changes to the Prefab for the spawned enemies to be affected.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以调整`NavMeshAgent`的**加速度**、**速度**和**角速度**属性来控制敌人移动的速度。平衡这些设置以确保AI在游戏中的移动方式合理。此外，请记住将更改应用到生成的敌人的Prefab中，以便受到影响。
- en: 'Regarding the Visual Scripting versions, `GoToBase`will look like the following
    screenshot:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，`GoToBase`将看起来如下截图所示：
- en: '*![A picture containing text, diagram, font, screenshot  Description automatically
    generated](img/B21361_09_64_PE.png)*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*![包含文本、图表、字体、屏幕截图的图片，描述自动生成](img/B21361_09_64_PE.png)*'
- en: 'Figure 9.64: Making our agent move'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.64：使我们的智能体移动
- en: We deleted the **OnUpdate** event node printing a message as we don’t need it
    anymore. Also, we called the **Set Destination** node after setting the variable
    if `if` was `null`, and also when the variable wasn’t `null` (**Not Null** pin
    of **Null** **Check**). Note that all of this happens in the **On Enter State**
    event, so we just need to do it once. We do it for every frame in the C# version
    for simplicity but that’s actually not necessary, so we will take advantage of
    the **On Enter State** event. We can emulate that behavior in the C# version if
    we want, executing these actions at the moment we change the state (inside the
    `if` statements that check the transition conditions), instead of using the **Update**
    function. Finally, notice how we needed to use the **Get Parent** node in order
    to access the `NavMeshAgent` component in the enemy’s root object? This is needed
    because we are currently in the `AI` child object instead.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们删除了打印消息的**OnUpdate**事件节点，因为我们不再需要它。此外，我们在设置变量后调用了**设置目的地**节点，如果`if`为`null`，以及当变量不为`null`（**Null**检查的**Not
    Null**引脚）时。请注意，所有这些都在**On Enter State**事件中发生，所以我们只需要做一次。我们在C#版本中为每一帧做这件事是为了简单起见，但实际上并不必要，所以我们将利用**On
    Enter State**事件。如果我们想，我们可以在C#版本中模拟这种行为，在改变状态时（在检查转换条件的`if`语句内部）执行这些动作，而不是使用**Update**函数。最后，注意我们为什么需要使用**获取父节点**来访问敌人根对象中的`NavMeshAgent`组件？这是因为我们目前处于`AI`子对象中。
- en: 'Now, the `AttackBase` state will look like this:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`AttackBase`状态将看起来如下：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_09_65_PE.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，描述由中等置信度自动生成](img/B21361_09_65_PE.png)'
- en: 'Figure 9.65: Making our agent stop'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.65：使我们的智能体停止
- en: 'The `ChasePlayer` state will look like this:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ChasePlayer`状态将看起来像这样：'
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_09_66_PE.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图，描述由低置信度自动生成](img/B21361_09_66_PE.png)'
- en: 'Figure 9.66: The ChasePlayer logic'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.66：ChasePlayer逻辑
- en: 'And finally, `AttackPlayer` will look like this:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`AttackPlayer`将看起来像这样：
- en: '![](img/B21361_09_67_PE.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![img/B21361_09_67_PE.png](img/B21361_09_67_PE.png)'
- en: 'Figure 9.67: The AttackPlayer logic'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.67：AttackPlayer逻辑
- en: 'While Unity has its own pathfinding system, it is not the only one, and it
    might not suit more advanced games. I recommend learning the basics of pathfinding,
    like learning about the BFS, Dijkstra, and A* algorithms. If you want to deep
    dive, you can learn more advanced techniques, like the tactical pathfinding explained
    in this Killzone developers’ paper: [http://cse.unl.edu/~choueiry/Documents/straatman_remco_killzone_ai.pdf](http://cse.unl.edu/~choueiry/Documents/straatman_remco_killzone_ai.pdf),
    or this presentation of Left 4 Dead AI systems: [https://steamcdn-a.akamaihd.net/apps/valve/2009/ai_systems_of_l4d_mike_booth.pdf](https://steamcdn-a.akamaihd.net/apps/valve/2009/ai_systems_of_l4d_mike_booth.pdf).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Unity有其自己的路径查找系统，但它并非唯一，可能也不适合更高级的游戏。我建议学习路径查找的基础知识，比如了解BFS、Dijkstra和A*算法。如果你想要深入研究，你可以学习更高级的技术，比如这篇Killzone开发者论文中解释的战术路径查找：[http://cse.unl.edu/~choueiry/Documents/straatman_remco_killzone_ai.pdf](http://cse.unl.edu/~choueiry/Documents/straatman_remco_killzone_ai.pdf)，或者这篇关于Left
    4 Dead AI系统的演示：[https://steamcdn-a.akamaihd.net/apps/valve/2009/ai_systems_of_l4d_mike_booth.pdf](https://steamcdn-a.akamaihd.net/apps/valve/2009/ai_systems_of_l4d_mike_booth.pdf)。
- en: With our AI now capable of navigating the game world, we’re close to having
    a fully functional enemy. Next, we’ll add the finishing touches, including shooting
    mechanics and animations, to complete our AI’s behavior.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在随着我们的AI能够导航游戏世界，我们离拥有一个完全功能的敌人不远了。接下来，我们将添加一些细节，包括射击机制和动画，以完成AI的行为。
- en: Adding the final details
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加最终细节
- en: 'We have two things missing here: the enemy is not shooting any bullets, and
    it doesn’t have animations. Let’s start with fixing the shooting by doing the
    following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们缺少两件事：敌人没有射击任何子弹，并且它没有动画。让我们从修复射击开始做以下操作：
- en: Add a `bulletPrefab` field of the `GameObject` type to our `EnemyFSM` script
    and a `float` field called `fireRate`.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`EnemyFSM`脚本中添加一个`GameObject`类型的`bulletPrefab`字段和一个名为`fireRate`的`float`字段。
- en: 'Create a function called `Shoot` and call it inside `AttackBase` and `AttackPlayer`:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Shoot`的函数，并在`AttackBase`和`AttackPlayer`中调用它：
- en: '![](img/B21361_09_68_PE.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![img/B21361_09_68_PE.png](img/B21361_09_68_PE.png)'
- en: 'Figure 9.68: Shooting function calls'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.68：射击函数调用
- en: In the `Shoot` function, put a similar code as that used in the `PlayerShooting`
    script to shoot bullets at a specific fire rate, as in *Figure 9.68*. Remember
    to set the `Enemy` layer in your `Enemy` Prefab, if you didn’t before, to prevent
    the bullet from damaging the enemy itself. You might also want to raise the `AI`
    GameObject position a little bit to shoot bullets from a position other than the
    ground or, better, add a `shootPoint` transform field and create an empty object
    in the enemy to use as a spawn position. If you do that, consider making the empty
    object not be rotated so the enemy rotation affects the direction of the bullet
    properly:![](img/B21361_09_69.png)
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Shoot`函数中，放入与`PlayerShooting`脚本中使用的类似代码，以特定射速射击子弹，如*图9.68*所示。记得如果你的`Enemy`
    Prefab中还没有设置，设置`Enemy`层，以防止子弹伤害到敌人本身。你可能还希望稍微提高`AI` GameObject的位置，以便从地面以外的位置射击子弹，或者更好的是，添加一个`shootPoint`变换字段，并在敌人中创建一个空对象作为生成位置。如果你这样做，请考虑使空对象不旋转，以便敌人的旋转能够正确地影响子弹的方向：![img/B21361_09_69.png](img/B21361_09_69.png)
- en: 'Figure 9.69: Shoot function code'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.69：射击函数代码
- en: Here, you find some duplicated shooting behavior between `PlayerShooting` and
    `EnemyFSM`. You can fix that by creating a `Weapon` behavior with a function called
    `Shoot` that instantiates bullets and takes into account the fire rate, and call
    it inside both components to re-utilize it.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你可以在`PlayerShooting`和`EnemyFSM`之间找到一些重复的射击行为。你可以通过创建一个名为`Shoot`的函数的`Weapon`行为来修复这个问题，该函数实例化子弹并考虑射速，并在两个组件内部调用它以重新利用它。
- en: 'When the agent is stopped, not only does the movement stop but also the rotation.
    If the player moves while the enemy is being attacked, we still need the enemy
    to face the player to shoot bullets in its direction. We can create a `LookTo`
    function that receives the target position to look at and then call it in `AttackPlayer`
    and `AttackBase`, passing the target to shoot at:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代理停止时，不仅移动停止，旋转也会停止。如果玩家在敌人被攻击时移动，我们仍然需要敌人面对玩家以射击子弹。我们可以创建一个`LookTo`函数，该函数接收要观察的目标位置，然后在`AttackPlayer`和`AttackBase`中调用它，传递要射击的目标：
- en: '![A screenshot of a computer code  Description automatically generated with
    medium confidence](img/B21361_09_70_PE.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![计算机代码的屏幕截图  描述由中等置信度自动生成](img/B21361_09_70_PE.png)'
- en: 'Figure 9.70: LookTo function calls'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.70：LookTo函数调用
- en: 'Complete the `LookTo` function by calculating the direction of our parent to
    the target position. We access our parent with `transform.parent` because, remember,
    we are the child `AI` object – the object that will move is our parent. Then,
    we set the `Y` component of the direction to `0` to prevent the direction from
    pointing upward or downward – we don’t want our enemy to rotate vertically. Finally,
    we set the forward vector of our parent to that direction so it will face the
    target position immediately. You can replace that with interpolation through quaternions
    to have a smoother rotation if you want to, but let’s keep things as simple as
    possible for now:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过计算我们的父对象到目标位置的方向来完成`LookTo`函数。我们通过`transform.parent`访问我们的父对象，因为，记得，我们是子`AI`对象——将要移动的对象是我们的父对象。然后，我们将方向`Y`分量设置为`0`以防止方向向上或向下指向——我们不希望我们的敌人垂直旋转。最后，我们将父对象的正向向量设置为该方向，这样它就会立即面对目标位置。如果你想要更平滑的旋转，可以用四元数插值来替换，但现在让我们尽可能保持简单：
- en: '![A screen shot of a computer code  Description automatically generated with
    low confidence](img/B21361_09_71_PE.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![计算机代码的屏幕截图  描述由低置信度自动生成](img/B21361_09_71_PE.png)'
- en: 'Figure 9.71: Looking toward a target'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.71：朝向目标看去
- en: 'Regarding the Visual Scripting version, **AttackBase** actions look like this:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于视觉脚本版本，**AttackBase**动作看起来是这样的：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B21361_09_72_PE.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序的屏幕截图  描述由低置信度自动生成](img/B21361_09_72_PE.png)'
- en: 'Figure 9.72: AttackBase state'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.72：AttackBase状态
- en: In this state, we have some things to highlight. First, we are using the **Look
    At** node in the **On Enter State** event node after the **Set Stopped** node.
    As you might imagine, this does the same as we did with math in C#. We specify
    a target to look at (our base transform) and then we specify that the **World
    Up** parameter is a vector pointing upward `0`,`1`,`0`. This will make our object
    look at the base but maintain its up vector pointing to the sky, meaning our object
    will not look at the floor if the target is lower than it.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个状态下，我们有一些要强调的内容。首先，我们在**Set Stopped**节点之后，在**On Enter State**事件节点中使用了**Look
    At**节点。正如你可能想象的那样，这与我们在C#中使用的数学方法相同。我们指定一个要观察的目标（我们的基地变换）并指定**World Up**参数是一个向上指向的向量`0`,`1`,`0`。这将使我们的对象朝向基地，但保持其向上向量指向天空，这意味着如果目标低于它，我们的对象不会朝向地面。
- en: We can use this exact function in C# if we want to (`transform.LookAt`); the
    idea was just to show you all the options. Also, note that we execute `LookAt`
    only when the state becomes active; as the base doesn’t move, we don’t need to
    constantly update our orientation.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想的话，可以在C#中使用这个确切的功能（`transform.LookAt`）；只是想展示所有选项。另外，注意我们只在状态变为活动时执行`LookAt`；因为基地不动，我们不需要不断更新我们的方向。
- en: The second thing to highlight is that we used coroutines to shoot, the same
    idea we used in the **Enemy Spawner** to constantly spawn enemies. Essentially,
    we make an infinite loop between **Wait For Seconds** and **Instantiate**. We
    took this approach here because it was convenient as it takes fewer nodes in Visual
    Scripting.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个要强调的是，我们使用了协程来射击，这与我们在**Enemy Spawner**中不断生成敌人的相同思路。本质上，我们在**Wait For Seconds**和**Instantiate**之间创建了一个无限循环。我们采取这种方法是因为它很方便，因为它在视觉脚本中需要的节点更少。
- en: 'Remember to select the **On Enter State** node and check the **Coroutine**
    checkbox as we did before. Also, we need a new `Float` type variable called `fireRate`
    in the **Enemy** `AI` child object:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 记得选择**On Enter State**节点并检查我们之前所做的**Coroutine**复选框。此外，我们还需要在**Enemy**的`AI`子对象中添加一个新的`Float`类型变量，名为`fireRate`：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_09_73_PE.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述自动生成，置信度中等](img/B21361_09_73_PE.png)'
- en: 'Figure 9.73: Coroutines'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.73：协程
- en: 'Then, **AttackPlayer** will look like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，**AttackPlayer** 将看起来像这样：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_09_74_PE.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图  描述自动生成，置信度中等](img/B21361_09_74_PE.png)'
- en: 'Figure 9.74: AttackPlayer state'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.74：AttackPlayer状态
- en: Essentially it is the same as **AttackBase**, but that looks toward the `sensedObject`
    instead of toward the player’s base, and we also made the **Look At** node part
    of the infinite loop, to correct the enemy’s heading before shooting to target
    the player.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上与**AttackBase**相同，但它面向的是`sensedObject`而不是玩家的基地，我们还把**Look At**节点作为无限循环的一部分，以便在射击前纠正敌人的航向，以瞄准玩家。
- en: With that, we have finished all AI behaviors. Of course, these scripts/graphs
    are big enough to deserve some rework and splitting in the future, but with this,
    we have prototyped our AI, and we can test it until we are happy with it, and
    then we can improve this code.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经完成了所有的AI行为。当然，这些脚本/图表足够大，未来值得重写和拆分，但有了这个，我们已经原型化了我们的AI，我们可以测试它，直到我们满意为止，然后我们可以改进这段代码。
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I’m pretty sure AI is not what you imagined; you are not creating Skynet here,
    but we have accomplished a simple but interesting AI to challenge our players,
    which we can iterate and tweak to tailor to our game’s expected behavior. We saw
    how to gather our surrounding information through sensors to make decisions on
    what action to execute using FSMs and different Unity systems such as Pathfinding
    to make the AI execute those actions. We used those systems to diagram a state
    machine capable of detecting the player, running to them, and attacking them,
    and if the player is not there, just going to the base to accomplish its task
    to destroy it.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我很确定AI不是你想象的那样；你在这里不是在创造天网，但我们已经完成了一个简单但有趣的AI来挑战我们的玩家，我们可以迭代和调整以适应我们游戏预期的行为。我们看到了如何通过传感器收集周围信息，使用有限状态机（FSMs）和不同的Unity系统，如寻路系统，来决定执行哪些动作，从而使AI执行这些动作。我们使用这些系统来绘制一个能够检测玩家、向他们跑去并攻击他们的状态机，如果玩家不在那里，就前往基地完成任务，摧毁它。
- en: 'As we move on to the next chapter, we’ll shift our focus to another vital aspect
    of game development: enhancing the graphics and audio. Get ready to dive into
    creating materials and shaders that will bring your game world to life.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入下一章，我们将把重点转移到游戏开发的另一个重要方面：增强图形和音频。准备好深入创建将使你的游戏世界栩栩如生的材质和着色器。
- en: Learn more on Discord
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity游戏开发专家和作者本人一起阅读这本书。提问，为其他读者提供解决方案，通过Ask Me Anything（AMA）会议与作者聊天，等等。扫描二维码或访问链接加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1498477041053909218.png)'
