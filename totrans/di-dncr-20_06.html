<html><head></head><body>
        

                            
                    <h1 class="header-title">Object Lifetime</h1>
                
            
            
                
<p class="mce-root">Object Lifetime is the time duration between an object's creation and destruction. In Functional Programming Languages, data stored in constant variables have a scope defined which is immutable in nature. This means that their lifetimes have a functional scope (no destruction) as long as the app is not stopped. On the other hand, the objects in Object Oriented Programming are mutable and have different types of scope which leads to different lifestyles.</p>
<p class="mce-root">Memory plays a vital role in application life cycle. All objects and variables use memory space. Therefore, it is important to learn the concepts which deal with an object's flow during application execution. Unless we know how to free up space by using proper codes or patterns, it would result in <strong>Memory Leaks</strong>.</p>
<p>If a computer program exposes bugs and erroneously manages the memory allocations, then resources become unavailable. This condition is called Memory Leaks.</p>
<p>To avoid Memory Leaks, we should take proper care while designing our classes, so that the resources are available when needed. That would only happen if and only if resources attached to objects are released by the program as soon as objects go out of scope. Thus, the app runs seamlessly as unused space is regularly cleared. However, this process is not automatic in all scenarios. The reason, we are going to explore this topic, is to understand how exactly the DI technique manages the lifetime of objects differently in different scenarios, which in return helps us take appropriate decisions while designing our classes.</p>
<p>An object is born when it's related class is instantiated. The newly born object stays around for a limited period of time as long as the application keeps a reference of that and continues to use that. If your application is closed or the reference of the object goes out of scope in the code, then .NET Framework will flag that object to be removed from memory.</p>
<p>In this particular chapter, we will learn how objects are managed by .NET Core. Also, we will look into techniques to determine when an object is disposable and how to work with it.</p>
<p>Topics we will cover in this chapter are:</p>
<ul>
<li>Managed and unmanaged resources.</li>
<li>Object's creation and destruction</li>
<li><kbd>IDisposal</kbd> interface</li>
<li>Object lifetime management in .NET Core</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Manage the object life cycle</h1>
                
            
            
                
<p>There are two basic places in the memory--stack and heap.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Stack versus heap</h1>
                
            
            
                
<p class="mce-root">Let's learn a little bit about these memory space types.<strong><br/></strong></p>
<table>
<tbody>
<tr>
<td><strong>Stack</strong></td>
<td><strong>Heap</strong></td>
</tr>
<tr>
<td>
<p class="mce-root">Static memory: Fixed memory space allocated for the app.</p>
</td>
<td>Dynamic memory: No fixed space.</td>
</tr>
<tr>
<td>When a method is called, a chunk of stack is reserved to store the method's information like a method name, local variables, return type, and so on.</td>
<td>Can store anything. The developer has the flexibility to manage this space.</td>
</tr>
<tr>
<td>Memory allocation has a pattern in <strong>LIFO</strong> (<strong>Last In First Out</strong>) order. So, when the <kbd>Main</kbd> function calls method <kbd>A()</kbd> and then <kbd>A()</kbd> calls <kbd>B()</kbd>, <kbd>B()</kbd> will be stored at the top and executes first. Refer to the following diagram:</td>
<td>
<p class="mce-root">No such pattern to store data.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The following diagram shows how the data gets stored in stack and heap for one program:</p>
<div><img height="233" width="389" src="img/dff1fbbb-ae31-446a-87ba-1c011ddfec81.png"/></div>
<p><kbd>Main()</kbd> calls <kbd>A()</kbd> which then calls <kbd>B()</kbd> method. According to stack properties, it first moves the last one out, which is <kbd>B()</kbd>. So, <kbd>B()</kbd> executes first. Then <kbd>B()</kbd> is removed from the stack and then <kbd>A()</kbd> is processed and removed from memory. After that, the <kbd>Main()</kbd> method executes and removed. The reference type variable named as <kbd>foo</kbd> inside <kbd>Main()</kbd> is stored in stack, but the actual object is allocated memory in heap.</p>
<p>Consider the following example:</p>
<pre>    static void Main(string[] args)
    {
      string name = "Dependency Injection";
      SomeClass sc = new SomeClass()
    }</pre>
<p>The variable <kbd>name</kbd> is a value type, which is directly stored on the stack. But, when we write <kbd>SomeClass sc = new SomeClass()</kbd>, it actually tells the framework to store the object in heap. In addition to this, it also allocates a memory space for a variable <kbd>sc</kbd> in the stack, which holds the reference to this object.</p>
<p>Now, when the <kbd>Main</kbd> method execution is completed, the variables <kbd>name</kbd> and <kbd>sc</kbd> will be released and memory space becomes free. Here is the catch though. The variable <kbd>sc</kbd> (reference type) is released from the stack, but the actual object is still on the heap. It's just the reference, which is removed. As the reference is removed from the stack, so there is no way to actually know if there is an object existing on the heap., related to it. We have ended up with a management problem now.</p>
<p>To get rid of this (in C++), we could have done something like this <kbd>delete sc;</kbd>. However, in C#, which is a managed language, there is a service known as <strong>Garbage Collector</strong> (<strong>GC</strong>), which automatically cleans up the unused memory by analyzing all those flagged <em>out of scoped</em> objects.</p>
<div><strong>Managed Language</strong> is a high-level language that depends on services provided by a runtime environment to execute, such as Garbage Collection service, Security Service, Exception Handling, and more. It uses Common Language Runtime (CLR) to execute in .Net languages or <strong>Java Virtual Machine</strong> (<strong>JVM</strong>) in Java.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Managed and unmanaged resources</h1>
                
            
            
                
<p class="mce-root">Pure .NET code is called <strong>managed resources</strong> as that can be directly managed by the runtime environment. On the other hand, unmanaged resources are those that are not in direct control of the runtime such as, file handles, COM objects, database connections, and so on. For example, if you open a connection to a database server this will use resources on the server (for maintaining the connection) and possibly other non .NET resources.</p>
<p class="mce-root">The managed resources are targeted directly by CLR, therefore, Garbage Collector cleans them up, which is an automatic process. As a developer, you don't usually need to explicitly call GC. However, there is a catch, when we consider the unmanaged resources like database connections. We have to deal with them ourselves as the CLR can't. We have to release them manually using the <kbd>Finalize</kbd> method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generations</h1>
                
            
            
                
<p class="mce-root">The heap is categorized into three generations so it can handle long-lived and short-lived objects. Garbage collection basically reclaims short-lived objects that typically occupy only a small part of the heap.</p>
<p class="mce-root">There are the following three generations of objects on the heap:</p>
<ul>
<li class="mce-root"><strong>Generation 0</strong>: When an object is initialized, it's generation gets started. It first falls into Generation 0. This generation's objects are usually short-lived. These objects are more prone to GC for destruction. GC collects these short-lived objects so that they can be released to free up memory space. If the objects survive from being collected by GC, that means they are going to stay for a longer time, thereby being promoted to the next generation.</li>
<li class="mce-root"><strong>Generation 1</strong>: This generation objects live for a longer duration than Generation 0 objects. GC does collect the objects from this generation, but not so regularly as it does for Generation 0 because their existence is extended by the application for more operations. Survivors of this generation go to Generation 2.</li>
<li class="mce-root"><strong>Generation 2</strong>: These are the longest existing objects in the application. Prolonged objects which successfully pass through the previous two generations are automatically considered for Generation 2. GC rarely comes into the picture when it comes to releasing these objects.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Object creation</h1>
                
            
            
                
<p>Constructors are responsible for giving birth to the object of a particular class. If we create any class without a constructor, the compiler will automatically create a one default constructor for that class. At least one constructor is present in every class.</p>
<p>The constructors can be overloaded too which provide a convenient way to build the object with different attributes, meaning, it can instantiate the object by taking certain parameters (like a normal method) and assign them to its properties inside its body (also called as a parameterized constructor). A constructor should have the same name as the class name.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Copy constructor</h1>
                
            
            
                
<p>There is another type of constructor called the <strong>Copy constructor</strong>. As the name suggests, it can copy one object to the new object (of the same class) which is going to be instantiated. In other words, it is a parameterized constructor that contains a parameter of same class type. The main purpose of a copy constructor is to initialize a new instance to the values of an existing instance. We will see how this can be done with an example in a while.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Object destruction</h1>
                
            
            
                
<p>We have different ways to destroy an object. Let's explore them one by one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Finalize</h1>
                
            
            
                
<p>Finalizers are used to destroy the objects. We can design Finalizers using destructor methods using the tilde (<kbd>~</kbd>) sign with the class name. We will see it in action soon:</p>
<pre>    ~Order()<br/>    {<br/>      // Destructor or Finalizer<br/>    }</pre>
<p>Garbage Collector has full control on the finalization process as it internally calls this method when objects go out of scope. We can, however, write codes inside the destructor to customize our requirements, but we can't just say to someone to call the destructor. Even if you are very sure that the object is not required anymore and decide to release it, you can't explicitly execute destructor in order to free up space. You have to wait until GC collects the object for destruction.</p>
<p>The finalization process has two collection cycles. In the first cycle, short-lived objects are flagged for finalization. In the next cycle, it calls the finalizers to release them completely from memory space.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The IDisposable interface</h1>
                
            
            
                
<p class="mce-root">Unmanaged resources, as we discussed, are not in direct control of the framework. We can easily reclaim these resources inside Finalizers, as we discussed. That means, they will be released when the objects are destroyed by the garbage collector. However, the GC destroys the objects only when the CLR demands more free memory. So, resources may still exist even long even after the object goes out of scope.</p>
<p class="mce-root">Thus, there is a need to free up resources as soon as we are done with them. Your classes can provide a mechanism to actively manage system resources if they implement the <kbd>IDisposable</kbd> interface. This interface exposes one method, <kbd>Dispose()</kbd>, which clients should call when they finish using an object. You can use the <kbd>Dispose</kbd> method to immediately release resources to perform tasks such as closing files and database connections etc. Unlike the <kbd>Finalize</kbd> destructor, the <kbd>Dispose</kbd> method is not called automatically. Objects must explicitly call <kbd>Dispose</kbd> when they want to release the resources.</p>
<p class="mce-root">This method is the single method in an <kbd>IDisposable</kbd> interface and can be used to release unmanaged resources manually.</p>
<pre class="mce-root">    public interface IDisposable<br/>    {<br/>      void Dispose();<br/>    }</pre>
<p>Now it's just a matter of calling the <kbd>Dispose()</kbd>. But wait. You can only call this method from an object of a class which have implemented this interface and defined the <kbd>Dispose()</kbd> method.</p>
<p>For example, the <kbd>SqlConnection</kbd> class has implemented this interface and provided us with the <kbd>Dispose()</kbd> method, which can be used as follows. As soon as you are finished using the connection object, call <kbd>Dispose</kbd>:</p>
<pre>    var connection = new SqlConnection("ConnectionString");<br/>    // Do Database related stuff here.<br/><br/>    // After we are done, let's call Dispose.<br/>    connection.Dispose();</pre>
<p>There is another beautiful way to deal with the disposal of objects in .NET. Instead of calling <kbd>Dispose</kbd> directly, we can use the <kbd>using</kbd> block. The same statement can be decorated with the <kbd>using</kbd> block coded as follows:</p>
<pre class="mce-root">     using (var connection = new SqlConnection("ConnectionString"))
    {
      // Use the connection object and do database operation.
    }</pre>
<p>When we do this, it converts the code to <kbd>try...finally</kbd> intermediate code. It disposes the connection object inside the <kbd>finally</kbd> block, which we created. Unless you do this, the connection object stays in memory. In due course, when we get a huge number of connections, memory starts to leak.</p>
<p>If you are using the finalizer (destructor) method, then make sure to call <kbd>Dispose()</kbd> inside it for the resources you want to deallocate. Thus, you will be doubly sure that your resources will be cleaned by GC even if someone forgets to release them in their code while using your class.</p>
<p>Out of curiosity, you must be asking yourself, what would happen if some exception occurs before <kbd>Dispose()</kbd> is called? Will that object be disposed of? The solution to this is to wrap that with a <kbd>try...finally</kbd> block, so that no matter what happens to the program, finally will be called and you can dispose of objects inside that. To make it simple, the framework has a beautiful thing called the <kbd>using</kbd> block which can be used as follows:</p>
<div><kbd>Dispose()</kbd> versus <kbd>Close()</kbd>: Are you confused which one to call for an <kbd>SqlConnection</kbd> object? They are two different methods which solve different problems. <kbd>Close()</kbd> just closes the connection. You can reopen the connection using the same object. However, <kbd>Dispose()</kbd> closes the connection (calls <kbd>Close()</kbd> under the hood) and then deallocates the object from memory. You can't use the object anymore.</div>
<p>You can find out more about Garbage Collector at <a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/">https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Consider an example</h1>
                
            
            
                
<p>A simple <kbd>Order</kbd> class can have a default, parameterized, copy constructor along with a destructor (to destroy the object):</p>
<pre>    class Order
    {
        public string ProductName { get; set; }
        public int Quantity { get; set; }

        public Order()
        {
           // Default Constructor
        }

        public Order(string productName, int quantity)
        {
           // Constructor with two arguments
           ProductName = productName;
           Quantity = quantity;
        }

        public Order(Order someOrder)
        {
           // Copy constructor
           ProductName = someOrder.ProductName;
           Quantity = someOrder.Quantity;
        }

        ~Order()
        {
           // Destructor or Finalizer
        }
    }</pre>
<p>You can see how the constructors are formed using and without the parameters. Notice the copy constructor, which takes an object of the same class as an argument and inside the body, assigns it's properties to the object in making.</p>
<p>The finalizer implicitly calls <kbd>Finalize</kbd> on the base class of the object. Therefore, when GC calls the Finalizer, that might call a method something like shown in the following:</p>
<pre>    protected override void Finalize()
    {  
      try  
      {  
        // Cleanup statements...  
      }  
      finally  
      {  
         base.Finalize();  
      }  
    }</pre>
<p>Let's verify this behavior with a code snippet inside a console app using .NET Core 2.0:</p>
<pre>    class BaseClass
    {
      ~BaseClass()
      {
        System.Diagnostics.Trace.WriteLine("BaseClass's destructor is called.");
      }
    }
    class DeriveClass1 : BaseClass
    {
      ~DeriveClass1()
      {
        System.Diagnostics.Trace.WriteLine("DeriveClass1's destructor<br/>            is called.");
      }
    }

   class DeriveClass2 : DeriveClass1
   {
      public DeriveClass2()
      {
        System.Diagnostics.Trace.WriteLine("DeriveClass2's constructor is called.");
      }

      ~DeriveClass2()
      {        <br/>         System.Diagnostics.Trace.WriteLine("DeriveClass2's destructor <br/>          is called.");
      }
   }

   class Program
  {
    static void Main(string[] args)
    {
       DeriveClass2 t = new DeriveClass2();<br/><br/>       // Unlike .NET Framework, .NET Core 2.0, as of now, <br/>       // does not call GC on application termination <br/>       // to finalise the objects.<br/>       // So, we are trying to manually call GC<br/>       // to see the output.<br/>       System.GC.Collect();
    }
  }</pre>
<p>The <kbd>DeriveClass2</kbd> object is created first which logs the constructor messages. Then the <kbd>DeriveClass2</kbd> destructor is executed. Thus, it is destroyed first when the <kbd>Main</kbd> function execution completes. Additionally, the parent classes have destructors. As the child class (<kbd>DeriveClass2</kbd>) object is already destroyed, it runs the parent class destructors too. The following screenshot is taken from the output window of visual studio. Make sure you run the app in Release mode:</p>
<div><img height="74" width="315" src="img/ffc917d6-732d-47c0-b688-4056666c2f2e.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the IDisposable Interface</h1>
                
            
            
                
<p>It's important to learn how to implement <kbd>IDisposable</kbd> interface as you might work with a user-defined class in your project which will deal with unmanaged resources. The system defines classes using unmanaged resources implement <kbd>IDisposable</kbd> and expose Dispose so that we can easily call that method to dispose of the object like we saw in the code snippet for <kbd>SqlConnection</kbd> class.</p>
<p>There is a pattern called <strong>Dispose Pattern</strong>, which the developers must follow while implementing <kbd>IDisposable</kbd>. Let's explore that. I will go through it step by step.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Step1 -  Basic structure of class</h1>
                
            
            
                
<p>We will have an <kbd>ExampleIDisposable</kbd> class which implements the <kbd>IDisposable</kbd> interface. I am not going to demonstrate usage of unmanaged resources, as our intention is to learn the pattern. I just have a console line inside the constructor telling that we are acquiring unmanaged resources.</p>
<pre>    class ExampleIDisposable : IDisposable
    {
        public Dictionary&lt;int, string&gt; Chapters{ get; set; }
        public ExampleIDisposable(Dictionary&lt;int, string&gt; chapters)
        {
           // Managed resources
           Console.WriteLine("Managed Resources acquired");
           Chapters = chapters;

           // Some Unmanaged resources
           Console.WriteLine("Unmanaged Resources acquired");
        }

        public void Dispose()
        {
           Console.WriteLine("Someone called Dispose");

           // Dispose managed resources
           if (Chapters != null)
           {
              Chapters = null;
           }

          // Dispose unmanaged resources
        }
     }</pre>
<p>You can see that the class contains one managed property which is initialized inside the constructor. We will print a line for it. Likewise, we might have some property using unmanaged resources declared in the class and given life by the constructor. Since we implemented <kbd>IDisposable</kbd>, we are bound to define the only method <kbd>Dispose()</kbd>. For now, we just have a console line inside this.</p>
<p>Let's try it out:</p>
<pre>    static void Main(string[] args)
   {
      ExampleIDisposable disposable = new ExampleIDisposable(new Dictionary&lt;int,<br/>        string&gt; {{ 5, "Object Composition" },
                { 6, "Object Lifetime" }
        });
                        
      disposable.Dispose();
      Console.ReadLine();
    }</pre>
<p>This produces the following output:</p>
<div><img height="102" width="285" src="img/af3d32ed-b02a-4594-b70c-2984ed113c4d.png"/></div>
<p>We need to understand two important points before moving forward.</p>
<p><strong>What happens when Finalizer is called by GC? </strong>When an object goes out of scope, that will be added to the Finalizer queue for Garbage Collector to take action on them to release it from memory. And we don't know when that will happen. If you kill the managed resources inside <kbd>Dispose()</kbd>, then we need to restrict the objects going into the finalizer queue thereby informing GC not to take action on them as they don't exist anymore. Also, that is an overhead for GC.</p>
<p><strong>What if the developer forgets to call Dispose? </strong>Suppose, the developer who is using our class does not dispose of it. Still, we need to handle this situation. We can easily do that by calling <kbd>Dispose()</kbd> inside Finalizer, but wait! We need to ask the <kbd>Dispose()</kbd> method to kill unmanaged resources only, not managed ones because GC is there to automatically deal with them.</p>
<p>This is where another method comes into the picture.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Step2 - Defining a Dispose Overload method</h1>
                
            
            
                
<p>The <kbd>Dispose()</kbd> method we defined inside the class is going to help us while calling it directly through the object of the class. However, we need another overload of <kbd>Dispose()</kbd> inside the class which would answer the questions we previously discussed. Let's introduce that to our class.</p>
<pre>    class ExampleIDisposable : IDisposable
    {
      public Dictionary&lt;int, string&gt; Chapters { get; set; }
      public ExampleIDisposable(Dictionary&lt;int, string&gt; chapters)
      {
        // Managed resources
        System.Diagnostics.Trace.WriteLine("Managed Resources acquired");
        Chapters = chapters;

        // Some Unmanaged resources
         System.Diagnostics.Trace.WriteLine("Unmanaged Resources acquired");
      }
      public void Dispose()
       {
         System.Diagnostics.Trace.WriteLine("Someone called Dispose");
         Dispose(true);
         GC.SuppressFinalize(this);
       }
       public void Dispose(bool disposeManagedResources)
        {
          if (disposeManagedResources)
          {
            if (Chapters != null)
            {
              Chapters = null;
            }

            System.Diagnostics.Trace.WriteLine("Managed Resources disposed");
          }
          System.Diagnostics.Trace.WriteLine("Unmanaged Resources disposed");
        }

        ~ExampleIDisposable()
        {
          System.Diagnostics.Trace.WriteLine("Finalizer called: Managed<br/>              resources will be cleaned");
          Dispose(false);
        }
      }</pre>
<p>Modifications done to the <kbd>Dispose</kbd> methods are explained as follows:</p>
<ul>
<li><kbd>public void Dispose()</kbd>: Now, we are asking the <kbd>Dispose(bool)</kbd> method to release all type of resources. <kbd>public void Dispose(). GC.SuppressFinalize(this)</kbd>; suppresses the GC finalizer call, as we have already disposed of everything inside the <kbd>Dispose(bool)</kbd></li>
<li><kbd>public void Dispose(bool)</kbd>: This method is the important part of this pattern. With the <kbd>bool</kbd> param, it decides whether there is a need to kill the managed resources or not</li>
</ul>
<p>I have replaced the console lines with trace lines so that the <kbd>main</kbd> method ends and we can see the lines on the output screen. If you just remove <kbd>Console.ReadLine();</kbd> from the <kbd>Main</kbd> method and run the app again, the output produced will be as follows:</p>
<div><img height="173" width="421" src="img/fd4c2965-f338-4a83-96b1-6dca53511e7c.png"/></div>
<p class="mce-root">Removal of the <kbd>Dispose()</kbd> calls from the <kbd>Main</kbd> method that is <kbd>disposable.Dispose();</kbd>, will result in something as follows. Note to call <kbd>GC.Collect();</kbd> at the end of <kbd>Main</kbd> method as we did in Step 1:</p>
<div><img height="145" width="567" src="img/3ab0882c-c4b8-412a-a457-cc9b83b35a01.png"/></div>
<p>That means whenever developer forgets to dispose, the finalizer is called where we have called <kbd>Dispose(false);</kbd>, which eventually released unmanaged resources. Of course, finalizer will remove the managed resources automatically. You can see that the lines Someone called Dispose and Managed Resources disposed are missing in the last case.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Step3 -Modifying the Dispose(bool) for Derived classes</h1>
                
            
            
                
<p>As we have <kbd>Dispose(bool)</kbd> overload, it will be available directly on the object to call. There is no need to expose <kbd>Dispose(bool)</kbd> to the object for the direct call as we are internally calling it from <kbd>Dispose()</kbd> and Finalizer.</p>
<p>The user should not pass boolean and decide what to dispose of and how. The only thing they will do is to call <kbd>Dispose()</kbd> which will release all type of resources. For that reason, we will restrict the call to <kbd>Dispose(bool)</kbd> by changing the access specifier from <kbd>public</kbd> to <kbd>protected</kbd>.</p>
<p>The <kbd>Dispose(bool)</kbd> is a logical block for the class which is implementing <kbd>IDisposable</kbd>. Any class which is going to derive a base class implementing <kbd>IDisposable</kbd> might have their own custom logic for disposal. So, instead of adding another dispose method, they can just override the base class <kbd>Dispose(bool)</kbd>. To make that happen, we need to prepend a <kbd>virtual</kbd> keyword before the method name.</p>
<p>The preceding paragraphs call for a modification of our very well known method <kbd>Dispose(bool)</kbd>:</p>
<pre>    protected virtual void Dispose(bool disposeManagedResources)
    {
      if (disposeManagedResources)
      {
        if (Chapters != null)
        {
           Chapters = null;
        }
        System.Diagnostics.Trace.WriteLine("Managed Resources disposed");
      }
      System.Diagnostics.Trace.WriteLine("Unmanaged Resources disposed");
    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Step 4 - Handling duplicate Dispose calls</h1>
                
            
            
                
<p>We should manage the scenario where the user might call Dispose more than once. If we don't tackle this situation, the subsequent calls will just be unnecessary executions for the runtime because the runtime will try to release an object which has been already disposed of.</p>
<p>We can easily put a flag inside the class which will indicate whether the object was disposed or not.</p>
<pre>    bool disposed = false;
    protected virtual void Dispose(bool disposeManagedResources)
    {
      if (disposed)
      {
        System.Diagnostics.Trace.WriteLine("Dispose(bool) already called");
         return;
      }
      if (disposeManagedResources)
        {
          if (Chapters != null)
          {
             Chapters = null;
          }
          System.Diagnostics.Trace.WriteLine("Managed Resources disposed");
       }
       System.Diagnostics.Trace.WriteLine("Unmanaged Resources disposed");
       disposed = true;
     }</pre>
<p>Notice the <kbd>disposed</kbd> variable, which is used inside <kbd>Dispose(bool)</kbd>. We are checking if that is true inside the method. If true, then we return/exit from the method, otherwise execute the disposal codes. At last, we set it as true. So, for the first time <kbd>Dispose(bool)</kbd> is going to execute fully, after that, it will just return once called. This way, we are preventing disposing of the same object many times which is an overhead.</p>
<p>Let's modify the code to call <kbd>Dispose()</kbd> multiple times:</p>
<pre>    disposable.Dispose();
    disposable.Dispose();
    disposable.Dispose();</pre>
<p>This would give us the following output:</p>
<div><img height="172" width="281" src="img/ac96fa07-23c1-4416-9e2f-fb32c5d50b49.png"/></div>
<p>You can see, for the first call, everything works as expected. The the next two subsequent Dispose() calls for the same object results in a simple return from the method. That is why we see two sets of Someone called Dispose and Dispose(bool) already called messages.</p>
<p>Alright, I would like to show you the final code after all these steps:</p>
<pre>    class ExampleIDisposable : IDisposable
    {
        public Dictionary&lt;int, string&gt; Chapters { get; set; }
        bool disposed = false;

        public ExampleIDisposable(Dictionary&lt;int, string&gt; chapters)
        {
            // Managed resources
            System.Diagnostics.Trace.WriteLine("Managed Resources acquired");
            Chapters = chapters;

            // Some Unmanaged resources
            System.Diagnostics.Trace.WriteLine("Unmanaged Resources acquired");
        }

        public void Dispose()
        {
           System.Diagnostics.Trace.WriteLine("Someone called Dispose");

           Dispose(true);
           GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposeManagedResources)
        {
           if (disposed)
           {
               System.Diagnostics.Trace.WriteLine("Dispose(bool) already called");
               return;
           }

           if (disposeManagedResources)
           {
              if (Chapters != null)
              {
                 Chapters = null;
              }
              System.Diagnostics.Trace.WriteLine("Managed Resources<br/>                  disposed");
           }

           System.Diagnostics.Trace.WriteLine("Unmanaged Resources disposed");
           disposed = true;
        }

        ~ExampleIDisposable()
        {
          System.Diagnostics.Trace.WriteLine("Finalizer called: Managed <br/>                resources will be cleaned");
          Dispose(false);
        }
      }</pre>
<p>Don't forget that you can use the <kbd>using</kbd> statement with any class which implements <kbd>IDisposable</kbd>. For instance, let's write that for <kbd>ExampleIDisposable</kbd>:</p>
<pre>    using (ExampleIDisposable disposable = 
        new ExampleIDisposable(new Dictionary&lt;int, string&gt; {
        { 5, "Object Composition" },
        { 6, "Object Lifetime" }
        }))
    {
      // Do something with the "disposable" object.
    }</pre>
<p>If you run this, it would produce the same result as shown in the first screenshot under <em>Step 2: Defining a Dispose Overload method </em>section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Object lifetime management in .NET Core</h1>
                
            
            
                
<p>In previous chapters, we have already explored how Dependency Injection is built into .NET Core. Now that we learned how objects are managed by .NET Framework, let's shed some light on their lifestyle in .NET Core.</p>
<p>With just one line, I can say, in Startup, .NET Core takes one class, tags a lifetime to it as specified in code, then instantiates and stores it in the container or service collection. Consider the following screenshot: </p>
<div><img height="222" width="262" src="img/663079d7-0bb5-478d-a787-557867ec8ef7.png"/></div>
<p>We will be covering how the following is addressed in .NET Core:</p>
<ul>
<li>Object Creation.</li>
<li>Object's Lifestyles.</li>
<li>Object's Disposal after everything is done.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Object creation</h1>
                
            
            
                
<p class="mce-root">Typically in ASP.NET Core 2.0, an injected type is called a <strong>service</strong>. For example, the injected interface is called as <kbd>IServiceCollection</kbd> and we can add services, as we need, by using the <kbd>AddSingleton</kbd> method here. We will learn more about it soon:</p>
<pre>    public void ConfigureServices(IServiceCollection services)
    {
      services.AddMvc();
      services.AddSingleton&lt;IExampleService, ExampleService&gt;();
    }</pre>
<p class="mce-root">The built-in DI framework in ASP.NET Core performs two important steps when we perform the preceding code:</p>
<ul>
<li class="mce-root"><strong>Instantiation:</strong> The object of the provided service (example: <kbd>ExampleService</kbd>) is instantiated so that it can be made available to controllers when they are called. The object gets injected through constructor injection or property injection. <kbd>IExampleService</kbd> will be an argument to the controller. The implementer of this interface <kbd>ExampleService</kbd> can be instantiated and injected. We will see the constructor in a while.</li>
<li><strong>Lifetime Management:</strong> Then it decides the lifetime (creation and disposal) of the object injected to the controller. There are different types of lifestyles served by the framework, which we will learn next.</li>
</ul>
<p>Let's explore the three-lifetime modes served by <em>ASP.NET Core</em> by default. The following is a quick reference table for these lifestyles:</p>
<table>
<tbody>
<tr>
<td><strong>Lifestyle</strong></td>
<td><strong>Description</strong></td>
<td><strong>Disposal</strong></td>
</tr>
<tr>
<td>
<p class="mce-root">Transient (temporary or short-lived)</p>
</td>
<td>A new instance will be created each time the service is requested.</td>
<td>Never</td>
</tr>
<tr>
<td>
<p class="mce-root">Scoped (extent or ranged)</p>
</td>
<td>An instance will be created for a defined scope. When out of scope is reached, another instance will be created, if requested. A simple scope can be stated as one <kbd>Web Request</kbd>. Any resource, requesting the instance in a particular <kbd>Web Request</kbd> will be served the same from the container.</td>
<td>Disposed when the scope ends</td>
</tr>
<tr>
<td>
<p class="mce-root">Singleton (single or individual)</p>
</td>
<td>One instance created by the container which will be used/shared throughout the app for every request.</td>
<td>Disposed when the container is disposed</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">We will look at each concept in detail now. Don't worry, if you are confused after reading this. After a well-designed example, you will definitely get the concept.</p>
<p>First of all, let's design our ASP.NET MVC Core app to use all these kinds of lifetimes. This example is similar to that given in the official documentation, which can be found at <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection</a>.</p>
<p>The main goal here is to understand how the instances stay during the incoming requests. We will investigate the instances from two places: one from a controller and another from a class. Both these guys will use the same interfaces as dependencies injected to their constructors. Let's go through things step by step.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Designing the interfaces</h1>
                
            
            
                
<p>First code an interface <kbd>IExampleService</kbd> with a <kbd>Guid</kbd> type property <kbd>ExampleId</kbd>. Then write four interfaces implementing this interface. We have named them according to a different type of lifetimes so that we can easily recognize them afterward:</p>
<pre>    public interface IExampleService
    {
      Guid ExampleId { get; }
    }

    public interface IExampleTransient : IExampleService
    {
    }
    public interface IExampleScoped : IExampleService
    {
    }
    public interface IExampleSingleton : IExampleService
    {
    }
    public interface IExampleSingletonInstance : IExampleService
    {
    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Concrete class</h1>
                
            
            
                
<p>Abstract which means something which can be conceptualized whereas concrete means something which exists in reality and not abstract. Suppose we consider three Shapes like a circle, a rectangle, and a square. The shape seems like a concept, doesn't it? On the other hand a circle, a rectangle, and a square actually have the behavior of shape to represent a concrete idea. An Abstract class is incomplete in nature and when a class takes (or inherits) its behavior, it becomes complete which is denoted as <strong>Concrete</strong>.</p>
<p>Thus, Abstract (or incomplete) concept is meant to be completed by other classes inheriting it, forming <em>Concrete Classes</em>. An Abstract class is incomplete and just a concept, so instantiating it becomes meaningless. Shape, for instance, is not meant to be instantiated, rather it's meant to be inherited by actual shape classes. The following diagram shows the relationship:</p>
<div><img height="163" width="233" src="img/36b8337a-1d81-4ff2-9ace-c1d5a66d9050.png"/></div>
<p>A single <kbd>Example</kbd> class implements all these interfaces and defines the <kbd>ExampleId</kbd> guid. Two constructors are there: one which takes the <kbd>Guid</kbd> as a param and the other one is the default which initializes a new guid. All those interfaces will be resolved as this class in <em>Startup</em>. We are approaching that code soon:</p>
<pre>    using LifetimesExample.Interfaces;<br/>    using System;

    namespace LifetimesExample.Models
   {
      public class Example : IExampleScoped, IExampleSingleton, <br/>         IExampleTransient, IExampleSingletonInstance
      {
        public Guid ExampleId { get; set; }
        public Example()
        {
          ExampleId = Guid.NewGuid();
        }
        public Example(Guid exampleId)
        {
          ExampleId = exampleId;
        }
      }
    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Service class</h1>
                
            
            
                
<p>As we said to have a simple class using these interfaces, here is that class called as <kbd>ExampleService</kbd>. We have a constructor here, which is waiting for the interfaces to be injected and assigned to local interface type variables.</p>
<pre>    using LifetimesExample.Interfaces;<br/>    namespace LifetimesExample.Services
    {
    public class ExampleService
    {
        public IExampleTransient TransientExample { get; }
        public IExampleScoped ScopedExample { get; }
        public IExampleSingleton SingletonExample { get; }
        public IExampleSingletonInstance SingletonInstanceExample { get; }

        public ExampleService(IExampleTransient transientExample,
            IExampleScoped scopedExample,
            IExampleSingleton singletonExample,
            IExampleSingletonInstance instanceExample)
        {
            TransientExample = transientExample;
            ScopedExample = scopedExample;
            SingletonExample = singletonExample;
            SingletonInstanceExample = instanceExample;
        }
      }
    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The controller</h1>
                
            
            
                
<p>The controller is almost the same as the service class with an additional reference of <kbd>ExampleService</kbd>. It has a constructor to initialize them. The properties of <kbd>ExampleService</kbd> will be printed on a view, that's why we are referring to that class:</p>
<pre>    using Microsoft.AspNetCore.Mvc;<br/>    using LifetimesExample.Services;<br/>    using LifetimesExample.Interfaces;

    namespace LifetimesExample.Controllers
    {
      public class ExampleController : Controller
      {
        private readonly ExampleService _exampleService;
        private readonly IExampleTransient _transientExample;
        private readonly IExampleScoped _scopedExample;
        private readonly IExampleSingleton _singletonExample;
        private readonly IExampleSingletonInstance _singletonInstanceExample;

        public ExampleController(ExampleService ExampleService,
            IExampleTransient transientExample,
            IExampleScoped scopedExample,
            IExampleSingleton singletonExample,
            IExampleSingletonInstance singletonInstanceExample)
        {
            _exampleService = ExampleService;
            _transientExample = transientExample;
            _scopedExample = scopedExample;
            _singletonExample = singletonExample;
            _singletonInstanceExample = singletonInstanceExample;
        }

        public IActionResult Index()
        {
            // viewbag contains controller-requested services
            ViewBag.Transient = _transientExample;
            ViewBag.Scoped = _scopedExample;
            ViewBag.Singleton = _singletonExample;
            ViewBag.SingletonInstance = _singletonInstanceExample;

            // Example service has its own requested services
            ViewBag.Service = _exampleService;

            return View();
        }
      }
    }</pre>
<p>Inside <kbd>Index()</kbd> action, we are returning all these values in <kbd>ViewBag</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">View</h1>
                
            
            
                
<p>Last, but not least, we will simply design a view which can show all these values so that we can start our observation. This would be <kbd>Index.cshtml</kbd> inside <kbd>Views/Example</kbd>.</p>
<pre class="mce-root">    @using LifetimesExample.Interfaces<br/>    @using LifetimesExample.Services<br/><br/>    @{<br/>      ViewData["Title"] = "Index";<br/>     }<br/><br/>    @{<br/>      IExampleTransient transient = (IExampleTransient)ViewData["Transient"];<br/>      IExampleTransient scoped = (IExampleTransient)ViewData["Scoped"];<br/>      IExampleTransient singleton = (IExampleTransient)ViewData["Singleton"];<br/>      IExampleTransient singletonInstance = (IExampleTransient)ViewData["SingletonInstance"];<br/>      ExampleService service = (ExampleService)ViewBag.Service;<br/>    }<br/><br/>    &lt;h2&gt;Lifetimes&lt;/h2&gt;<br/><br/>    &lt;h3&gt;ExampleController Dependencies&lt;/h3&gt;<br/>    &lt;table&gt;<br/>     &lt;tr&gt;<br/>        &lt;th&gt;Lifestyle&lt;/th&gt;<br/>        &lt;th&gt;Guid Value&lt;/th&gt;<br/>     &lt;/tr&gt;<br/>    &lt;tr&gt;<br/>        &lt;td&gt;Transient&lt;/td&gt;<br/>        &lt;td&gt;@transient.ExampleId&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>    &lt;tr&gt;<br/>        &lt;td&gt;Scoped&lt;/td&gt;<br/>        &lt;td&gt;@scoped.ExampleId&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>    &lt;tr&gt;<br/>        &lt;td&gt;Singleton&lt;/td&gt;<br/>        &lt;td&gt;@singleton.ExampleId&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>    &lt;tr&gt;<br/>        &lt;td&gt;Instance&lt;/td&gt;<br/>        &lt;td&gt;@singletonInstance.ExampleId&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>   &lt;/table&gt;<br/><br/>   &lt;h3&gt;ExampleService Dependencies&lt;/h3&gt;<br/>   &lt;table&gt;<br/>    &lt;tr&gt;<br/>        &lt;th&gt;Lifestyle&lt;/th&gt;<br/>        &lt;th&gt;Guid Value&lt;/th&gt;<br/>    &lt;/tr&gt;<br/>    &lt;tr&gt;<br/>        &lt;td&gt;Transient&lt;/td&gt;<br/>        &lt;td&gt;@service.TransientExample.ExampleId&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>    &lt;tr&gt;<br/>        &lt;td&gt;Scoped&lt;/td&gt;<br/>        &lt;td&gt;@service.ScopedExample.ExampleId&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>    &lt;tr&gt;<br/>        &lt;td&gt;Singleton&lt;/td&gt;<br/>        &lt;td&gt;@service.SingletonExample.ExampleId&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>    &lt;tr&gt;<br/>        &lt;td&gt;Instance&lt;/td&gt;<br/>        &lt;td&gt;@service.SingletonInstanceExample.ExampleId&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>  &lt;/table&gt;</pre>
<p>Finally, we completed the codes. Are you sure? We forgot the main entry point. The one which decides what class will be resolved against which interface.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Startup ConfigureServices</h1>
                
            
            
                
<p>Now each type of lifestyle is added to the container resolved using <kbd>Example</kbd> class. The class <kbd>ExampleService</kbd> is resolved for itself. That means, whenever we need <kbd>ExampleService</kbd> anywhere in the app, to be injected, it will automatically assign an object of that class with all its properties:</p>
<pre>    public void ConfigureServices(IServiceCollection services)
    {
        // Add framework services.
        services.AddMvc();

        services.AddTransient&lt;IExampleTransient, Example&gt;();
        services.AddScoped&lt;IExampleScoped, Example&gt;();
        services.AddSingleton&lt;IExampleSingleton, Example&gt;();<br/>        services.AddSingleton&lt;IExampleSingletonInstance, Example&gt;();
        services.AddSingleton(new Example(Guid.Empty));
        services.AddTransient&lt;ExampleService, ExampleService&gt;();
    }</pre>
<p><kbd>Add***</kbd> methods (with different lifestyles) make sure that the objects are created according to the desired behavior expected from them. Once these objects are initialized, they can be injected where ever required.</p>
<p>If we run the app now, for the first request, we will get the following output:</p>
<div><img height="470" width="352" src="img/9a77645f-5f93-4b86-9e98-17f9d68cf2aa.png"/></div>
<p>I opened the page in another tab (or you can just refresh the tab). I saw the following output:</p>
<div><img height="439" width="356" src="img/eed82ac7-6517-4824-90c6-44afd3b3ed53.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Object lifetimes</h1>
                
            
            
                
<p>Let's examine all the lifetimes one by one according to the values we see in these screenshots. The values help us recognize the objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Singleton</h1>
                
            
            
                
<p>Looking at the screenshots and diagrams, the first thing which is clearly seen is the <kbd>Singleton</kbd> one. No matter how many requests you do after running the app, the object will be the same. It does not depend upon the Controller or the <kbd>Service</kbd> class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scoped</h1>
                
            
            
                
<p>For a particular request, the object is same throughout the scope. Notice how the object's guid value is different in the second request. However, the values are same for Controller and <kbd>Service</kbd> class in both the requests. Here the scope is the web request. When one more request is served, the object is recreated.</p>
<p>Creating a scope in code is possible though. There is an interface called <kbd>IServiceScopeFactory</kbd> which exposes the method <kbd>CreateScope</kbd>. <kbd>CreateScope</kbd> is of the type <kbd>IServiceScope</kbd>, which implements <kbd>IDisposable</kbd>. Here the <kbd>using</kbd> block comes to our rescue for disposal of the scoped instance:</p>
<pre>    var serviceProvider = services.BuildServiceProvider();
    var serviceScopeFactory = serviceProvider.GetRequiredService&lt;<br/>          IServiceScopeFactory&gt;();

    IExampleScoped scopedOne;
    IExampleScoped scopedTwo;

    using (var scope = serviceScopeFactory.CreateScope())
    {
      scopedOne = scope.ServiceProvider.GetService&lt;IExampleScoped&gt;();
    }
    using (var scope = serviceScopeFactory.CreateScope())
    {
     scopedTwo = scope.ServiceProvider.GetService&lt;IExampleScoped&gt;();
    }</pre>
<p>We created two scoped instances in the preceding code using <kbd>CreateScope</kbd>. Both are independent of each other and are not shared within a request like a normal scoped instance. That is because we manually assigned the scope instead of the default Web Request scope.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transient</h1>
                
            
            
                
<p>Simple! A new object is always created whenever requested from the container. In the screenshot, you can see the guid values are different in the Controller and the <kbd>Service</kbd> class even for a single request.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Instance</h1>
                
            
            
                
<p>The last one is a special case of Singleton, where the user creates the object and provides that to the <kbd>AddSingleton</kbd> method. So, we are explicitly creating the object of the <kbd>Example</kbd> class ( <kbd>services.AddSingleton(new Example(Guid.Empty))</kbd>) and asking DI framework to register it as a Singleton. In this case, we are sending <kbd>Guid.Empty</kbd>. Thus, an empty guid is assigned which stays unchanged for all requests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Object disposal</h1>
                
            
            
                
<p>When we register a service directly with the <kbd>Add***</kbd> method, the container is responsible for creating the object and managing the lifetime. Essentially, it calls <kbd>Dispose</kbd> for the objects, which implement <kbd>IDisposable</kbd> according to the lifetime.</p>
<p>Consider the following example where <kbd>ServiceDisposable</kbd> implements <kbd>IDisposable</kbd> and we told services to manage its lifetime as <kbd>Scoped</kbd>. Therefore, it will create the instance, then make it available across all resources in the app for a single request. At last, it disposes of it when the request ends:</p>
<pre>    public class ServiceDisposable : IDisposable {}
    public void ConfigureServices(IServiceCollection services)
    {
      services.AddScoped(ServiceDisposable);
    }</pre>
<p>However, when we create the object explicitly and provide that to the DI, we need to handle it's disposal our self. In the following case, we have to manually call <kbd>Dispose()</kbd> somewhere to dispose the instance:</p>
<pre>    public class ServiceDisposable : IDisposable {}
    public void ConfigureServices(IServiceCollection services)
    {
      services.AddScoped(new ServiceDisposable());
    }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">When to choose what?</h1>
                
            
            
                
<p>It's important how we deal with different objects in our application so that they consume limited memory space and resources, yet optimize the performance.</p>
<ul>
<li>Objects which require more space and utilize large server resources should not be recreated, rather they should be reused. Database objects, for instance, should be reused for all the requests which follow a <kbd>Singleton</kbd> pattern.</li>
<li>Operations which runs in a batch or a loop can be reused in a particular request but should be recreated for another. That indicates a Scoped lifetime.</li>
<li>The <kbd>Model</kbd> and <kbd>View Model</kbd> classes should be instantiated every time we try to form them. We can't reuse a Model class object while doing a CRUD operation, else we might end up with the wrong values going into the database. Of course, that is <kbd>Transient</kbd> as it lives for a short period of time.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Relationship and dependencies among lifetimes</h1>
                
            
            
                
<p>In this section, we will dig more to find out the relation between the lifetimes. The reason is pretty clear. While instantiating our classes with a different type of lifestyle, we might face situations where we need dependency of one class in another class. But the catch here is that they may not be following a similar lifestyle. So, what happens to the instance which is following a scoped lifestyle referred inside a <kbd>Singleton</kbd> class. Does that behave as Scoped?</p>
<p>Let's get our hands dirty and do some code modifications to inject dependencies into one another.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Singleton depending on Scoped and Transient</h1>
                
            
            
                
<p>First, we need to add two new properties to the existing <kbd>IExampleSingleton</kbd> interface:</p>
<pre>    public interface IExampleSingleton : IExampleService
    {
        Guid ScopedExampleId { get; }
        Guid TransientExampleId { get; }
   }</pre>
<p>Next, we want to design a new class explicitly for all lifestyles. As we have planned, let's inject Transient and Scoped dependencies into this <kbd>Singleton</kbd> class through the constructor. The properties defined for dependent lifestyles are assigned values accordingly from the arguments.</p>
<pre>    using System;
    namespace LifetimesExample
    {
      public class ExampleSingleton : IExampleSingleton
      {
        public Guid ExampleId { get; set; }
        public Guid ScopedExampleId { get; set; }
        public Guid TransientExampleId { get; set; }

        public ExampleSingleton(IExampleTransient transient, IExampleScoped scoped)
        {
            ExampleId = Guid.NewGuid();
            ScopedExampleId = scoped.ExampleId;
            TransientExampleId = transient.ExampleId;
        }
      }
      public class ExampleScoped : IExampleScoped
      {
        public Guid ExampleId { get; set; }

        public ExampleScoped()
        {
            ExampleId = Guid.NewGuid();
        }
      }
      public class ExampleTransient : IExampleTransient
      {
        public Guid ExampleId { get; set; }

        public ExampleTransient()
        {
            ExampleId = Guid.NewGuid();
        }
       }
     }</pre>
<p>I have defined all classes in a single place just for the readability purposes of this book. You should ideally add them in different files every time.</p>
<p>The controller is the next place where we need to have an action which will return the view where we will show the values.</p>
<pre>    using Microsoft.AspNetCore.Mvc;
    namespace LifetimesExample.Controllers
    {
      public class ExampleController : Controller
      {
        private readonly ExampleService _exampleService;
        private readonly IExampleTransient _transientExample;
        private readonly IExampleScoped _scopedExample;
        private readonly IExampleSingleton _singletonExample;

        public ExampleController(ExampleService ExampleService,
            IExampleTransient transientExample,
            IExampleScoped scopedExample,
            IExampleSingleton singletonExample)
        {
            _exampleService = ExampleService;
            _transientExample = transientExample;
            _scopedExample = scopedExample;
            _singletonExample = singletonExample;
        }

        public IActionResult SingletonDependencies()
        {
            ViewBag.Singleton = _singletonExample;

            ViewBag.Service = _exampleService;

            return View("Singleton");
        }
      }
    }</pre>
<p>It's similar to what we have done with the <kbd>Index</kbd> action. The difference is that we have removed the <kbd>SingletonInstance</kbd> reference and returned a view called as <kbd>Singleton</kbd>.</p>
<p>The view would look something like the following:</p>
<pre>  @{<br/>    ViewData["Title"] = "Index";<br/>  }<br/><br/>  @{<br/>    IExampleSingleton singleton = (IExampleSingleton)ViewData["Singleton"];<br/>    ExampleService service = (ExampleService)ViewBag.Service;<br/>  }<br/>  &lt;h2&gt;Singleton Lifetime Dependencies&lt;/h2&gt;<br/><br/>  &lt;h3&gt;ExampleController&lt;/h3&gt;<br/><br/>  &lt;h5&gt;&lt;u&gt;Singleton ExampleId: @singleton.ExampleId&lt;/u&gt;&lt;/h5&gt;<br/><br/>  &lt;table&gt;<br/>    &lt;tr&gt;<br/>        &lt;th&gt;Dependencies&lt;/th&gt;<br/>        &lt;th&gt;Guid Value&lt;/th&gt;<br/>    &lt;/tr&gt;<br/><br/>    &lt;tr&gt;<br/>        &lt;td&gt;Scoped Dependency&lt;/td&gt;<br/>        &lt;td&gt;@singleton.ScopedExampleId&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>    &lt;tr&gt;<br/>        &lt;td&gt;Transient Dependency&lt;/td&gt;<br/>        &lt;td&gt;@singleton.TransientExampleId&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>  &lt;/table&gt;<br/><br/>  &lt;h3&gt;ExampleService&lt;/h3&gt;<br/><br/>  &lt;h5&gt;&lt;u&gt;Singleton ExampleId: @service.SingletonExample.ExampleId&lt;/u&gt;&lt;/h5&gt;<br/><br/>  &lt;table&gt;<br/>    &lt;tr&gt;<br/>        &lt;th&gt;Dependencies&lt;/th&gt;<br/>        &lt;th&gt;Guid Value&lt;/th&gt;<br/>    &lt;/tr&gt;<br/><br/>    &lt;tr&gt;<br/>        &lt;td&gt;Scoped Dependency&lt;/td&gt;<br/>        &lt;td&gt;@service.SingletonExample.ScopedExampleId&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>    &lt;tr&gt;<br/>        &lt;td&gt;Transient Dependency&lt;/td&gt;<br/>        &lt;td&gt;@service.SingletonExample.TransientExampleId&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>  &lt;/table&gt;</pre>
<p>So, I am trying to print the <kbd>ExampleId</kbd> of <kbd>Singleton</kbd> object and properties related to the dependent objects (<kbd>Transient</kbd> and <kbd>Scoped</kbd>). I have omitted the styles from this code which is just to make the table look cool.</p>
<p>It's time to tell the <kbd>Startup</kbd> <kbd>ConfigureService</kbd> to register the classes with the appropriate lifestyle:</p>
<pre>public void ConfigureServices(IServiceCollection services)
{
        // Add framework services.
        services.AddMvc();

        services.AddSingleton&lt;IExampleSingleton, ExampleSingleton&gt;();
        services.AddScoped&lt;IExampleScoped, ExampleScoped&gt;();
        services.AddTransient&lt;IExampleTransient, ExampleTransient&gt;();

        services.AddTransient&lt;ExampleService, ExampleService&gt;();
}</pre>
<p class="mce-root">Voila! We are done. Let's check the output. I have pasted the screenshots of two requests done to the controller side by side so that we can easily mark the findings:</p>
<div><img src="img/f98f9b19-cec3-4dbe-b7ec-7aa5d7e9b4a7.png"/></div>
<p><strong>Observation</strong>: The <kbd>Singleton</kbd> object is shared across two requests as the underlined <kbd>ExampleId</kbd> value is same.</p>
<p>Hold on! There is something weird. Dependent objects' values are also the same across request. Notice the values in red blocks. Even though those classes are registered as <kbd>Scoped</kbd> and <kbd>Transient</kbd>, they are behaving like a <kbd>Singleton</kbd>. That means the normal lifestyle of these objects is tampered.</p>
<p><strong>Inference</strong>: It's not recommended to refer <kbd>Scoped</kbd> and <kbd>Transient</kbd> lifestyle classes inside a <kbd>Singleton</kbd> class as they will lose their usual behavior and become Singletons.</p>
<p>Obviously, a <kbd>Singleton</kbd> class can depend on another a <kbd>Singleton</kbd> class. Likewise, other lifestyles follow the same rule. So, a <kbd>Scoped</kbd> class can refer another <kbd>Scoped</kbd> class and a <kbd>Transient</kbd> can refer another <kbd>Transient</kbd>. They all will behave as expected when executed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scoped depending on Singleton and Transient</h1>
                
            
            
                
<p>Similarly, we can test for dependencies inside a <kbd>Scoped</kbd> class. We will start by adding two properties to the interface <kbd>IExampleScoped</kbd>:</p>
<pre>public interface IExampleScoped : IExampleService
{
        Guid SingletonExampleId { get; }
        Guid TransientExampleId { get; }
}</pre>
<p><kbd>ExampleScoped</kbd> should now implement these two properties. Also, the interfaces related to <kbd>Transient</kbd> and <kbd>Singleton</kbd> need to be injected into the <kbd>constructor</kbd>:</p>
<pre>    public class ExampleScoped : IExampleScoped
    {
        public Guid ExampleId { get; set; }
        public Guid SingletonExampleId { get; set; }
        public Guid TransientExampleId { get; set; }

        public ExampleScoped(IExampleTransient transient, IExampleSingleton singleton)
        {
          ExampleId = Guid.NewGuid();
          SingletonExampleId = singleton.ExampleId;
          TransientExampleId = transient.ExampleId;
        }
    }</pre>
<p>A new action is added which will return the view named as <kbd>Scoped</kbd>:</p>
<pre>    public IActionResult ScopedDependencies()
    {
        ViewBag.Scoped = _scopedExample;

        ViewBag.Service = _exampleService;

        return View("Scoped");
    }</pre>
<p>Looks like we are done. Let's run the app:</p>
<div><img src="img/ded12cfc-42d1-41fa-a62f-a1699b3d40d5.png"/></div>
<p>Oops! We see an exception screen which says a Circular Dependency was detected.</p>
<div><strong>Circular Dependency</strong>, as the name suggests, is a class which depends on another, which in turn, depends on the first class. We designed everything to test the dependencies of other lifestyles in Scoped lifestyle, but we forgot one thing before doing that. Previously, we added a dependency of <kbd>Scoped</kbd> class inside a <kbd>Singleton</kbd> class and now, if you see the preceding <kbd>ExampleScoped</kbd> constructor, we now inject <kbd>IExampleSingleton</kbd>, which is resolved as the <kbd>Singleton</kbd> class <kbd>ExampleSingleton</kbd>. That's how it became circular.</div>
<p>Therefore, we need to remove the dependencies from the <kbd>Singleton</kbd> class to test. We can also test by doing another interface and class for <kbd>Singleton</kbd>. So, when you fix the code, we will get the following output. I am not going to write the codes of the <kbd>View</kbd> here. It's pretty much the same as we done in <kbd>Singleton</kbd>. We just need to print <kbd>ExampleId</kbd>, <kbd>SingletonExampleId</kbd> and <kbd>TransientExampleId</kbd>:</p>
<div><img src="img/157c30df-1f4d-4d51-817f-978969316d74.png"/></div>
<p><strong>Observation:</strong> In the red boxes, we have transient object values. That is because they are not <kbd>Transient</kbd> anymore and behave like <kbd>Scoped</kbd>, as the values are the same in a request, which is not what <kbd>Transient</kbd> looks like. It should be different every time it is requested. But in the case of <kbd>Singleton</kbd> dependency, it is the same across requests, which not only satisfies the <kbd>Singleto</kbd>n paradigm but also behaves like scoped in a particular request.</p>
<p><strong>Inference:</strong> That's why it is recommended to use <kbd>Scoped</kbd> and <kbd>Singleton</kbd> dependencies inside a <kbd>Scoped</kbd> class, but not Transient.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transient depending on Singleton and Scoped</h1>
                
            
            
                
<p>The following the same pattern for <kbd>Transient</kbd>, we will design the interface and class as required. The interface will look like the following:</p>
<pre>public interface IExampleTransient : IExampleService
{
        Guid SingletonExampleId { get; }
        Guid ScopedExampleId { get; }
}</pre>
<p>Next is the <kbd>Transient</kbd> class depending on <kbd>Singleton</kbd> and <kbd>Scoped</kbd>.</p>
<pre>public class ExampleTransient : IExampleTransient
{
        public Guid ExampleId { get; set; }
        public Guid SingletonExampleId { get; set; }
        public Guid ScopedExampleId { get; set; }

        public ExampleTransient(IExampleSingleton singleton, IExampleScoped scoped)
        {
                ExampleId = Guid.NewGuid();
                SingletonExampleId = singleton.ExampleId;
                ScopedExampleId = scoped.ExampleId;
        }
}</pre>
<p>Last, but not the least, a new action to render the view <kbd>Transient</kbd>:</p>
<pre>    public IActionResult TransientDependencies()
   {
        ViewBag.Transient = _transientExample;

        ViewBag.Service = _exampleService;

        return View("Transient");
   }</pre>
<p>Running this after designing the view will end up with something like the following:</p>
<div><img src="img/964da5d3-1efd-41bf-a166-cb3cd8aa5334.png"/></div>
<p>You can see how the <kbd>Transient</kbd> <kbd>ExampleId</kbd> differs in inside and outside the request.</p>
<p><strong>Observation:</strong> You must be wondering why I don't have red boxes in this picture. That is because everything looks perfect. <kbd>Singleton</kbd> is the same everywhere and <kbd>Scoped</kbd> is the same in a particular request, however, changes in the next request.</p>
<p><strong>Inference:</strong> That means, both these dependencies carry their usual characteristics when injected inside a <em>Transient</em> class. Also, another <em>Transient</em> dependency will definitely work if injected to a <em>Transient</em> class.</p>
<p>Saying all this, I would say these are the recommended patterns to follow while injecting one lifestyle into another. We should be careful while designing the classes and their lifestyle. Either we will end up in a Circular Dependency or lose the appropriate behavior of the lifestyle injected as we saw in the preceding examples. We can still mix it up as long as we are aware of the consequences.</p>
<p>With just a simple table, I can represent the whole point:</p>
<div><img height="233" width="273" src="img/99131700-c1b9-4a79-a682-50d2c5038a10.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned about how objects are created and destroyed by .NET Framework. Creation and destruction mechanism were discussed. <em>Garbage Collector</em> plays an important role in the automatic disposal through Finalizers, which we analyzed through examples.</p>
<p>Most importantly, we saw a step-by-step walkthrough to manually dispose of objects as soon as we are done by implementing the <kbd>IDisposal</kbd> interface.</p>
<p>After that, we explored the different lifetimes maintained by objects in .NET Core. We saw examples using the controller and service classes. We learned how the objects are created and disposed of. Most importantly, we experimented with the adaptability of different lifestyles with each other.</p>
<p>Interception, another pillar of DI, will be covered in <a href="d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml" target="_blank">Chapter 7</a>, <em>Interception</em>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>