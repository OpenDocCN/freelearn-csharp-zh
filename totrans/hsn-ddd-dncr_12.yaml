- en: Bounded Context
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有限上下文
- en: So far, we have spent quite a lot of time working on our `Marketplace` system,
    as it will be a single application with one API and, possibly, one web UI that
    will talk to that API to serve its users. However, now it is time to take a step
    back and look at the big picture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经花费了大量时间在我们的“市场”系统上，因为它将是一个单一的应用程序，有一个API，可能还有一个与该API通信以服务其用户的Web UI。然而，现在是我们退一步，看看大局的时候了。
- en: I've been writing software since the age of 15; so, as of writing this book,
    my experience in the industry is close to 30 years. Some systems that I've built
    have been replaced by something new and some are still very active, being developed
    further by other developers. Today, as I go along in the industry as a software
    architect and a consultant, I am involved in many hands-on activities, such as
    prototyping, modeling, and writing production code. Over the years, not only have
    I progressed as a developer so I write better-quality code, but I have also understood
    more about the foundational principles of building complex systems. This knowledge
    and experience allow me to be more successful with the companies I work for to
    create systems that will evolve and not need major rewrites in a couple of years.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我从15岁开始编写软件；因此，在撰写这本书的时候，我在行业中的经验接近30年。我构建的一些系统已经被新的东西所取代，而一些系统仍然非常活跃，由其他开发者进一步开发。今天，作为一名软件架构师和顾问，我在行业中继续前行，参与了许多实际活动，例如原型设计、建模和编写生产代码。多年来，我不仅作为开发者不断进步，编写出更好的代码，而且对构建复杂系统的基本原理有了更深入的理解。这些知识和经验使我能够为我的公司创造更成功的系统，这些系统将在几年内不断进化，而无需进行大规模的重写。
- en: One of the things that I believe made me a better developer and architect is
    the realization that systems can rarely be modeled as something singular and unbreakable,
    as a single unit. We already discussed the contextual nature of language in [Chapter
    2](6fa9e02b-66fa-4e1d-a69c-f26726dc9ad0.xhtml), *Language and Context*, and that
    hopefully led you to understand the importance of context.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为使我成为一个更好的开发者和架构师的事情之一是意识到系统很少可以被建模为单一且不可分割的东西，作为一个单一单元。我们在[第二章](6fa9e02b-66fa-4e1d-a69c-f26726dc9ad0.xhtml)中讨论了语言的上下文性质，“语言与上下文”，并希望这能让你理解上下文的重要性。
- en: During my career, I have seen many complex systems that were implemented as
    a single code base, with a single data model supporting it. In this chapter, we
    are going to look closer at this approach and, hopefully, I will convince you
    that it does not always work and there is a better way. We will spend some time
    discussing how the language context can be used to discover parts of the whole
    system that could be developed more efficiently with a good degree of isolation
    and autonomy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，我看到了许多被实现为单一代码库的复杂系统，它们有一个单一的数据模型来支持。在本章中，我们将更深入地探讨这种方法，并希望说服你它并不总是有效，而且有更好的方法。我们将花一些时间讨论如何使用语言上下文来发现整个系统中可以更高效地开发的部分，这些部分具有良好程度的隔离和自主性。
- en: 'In this chapter, you will learn:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: How linguistic boundaries can help identify system boundaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言边界如何帮助识别系统边界
- en: The definition of Bounded Context
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限上下文的定义
- en: The benefits of splitting systems into parts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将系统拆分为部分的好处
- en: Which factors need to be considered when context boundaries aren't clear
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当上下文边界不明确时，需要考虑哪些因素
- en: The single model trap
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一模型陷阱
- en: Let's take a look at how software usually starts its life, when developers first
    get their hands on keyboards and start writing code, hoping to build something
    useful. We will follow the usual progress that software companies (or IT departments)
    make while addressing the needs of their users, over the years they spent, working
    to make the software more useful, adding features and fixing issues. What I describe
    next is the usual evolutionary growth of software solutions that can be found
    everywhere. It is possible that some parts of the picture that I am going to paint
    will be recognizable to you and will resonate with your experience.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看软件通常是如何开始的，当开发者第一次接触键盘并开始编写代码时，希望构建一些有用的东西。我们将跟随软件公司（或IT部门）在多年中为满足用户需求而采取的通常进展，他们努力使软件更有用，增加功能并修复问题。接下来我所描述的是软件解决方案通常的进化增长，这种增长可以在任何地方找到。可能我即将描绘的画面中的一些部分你会觉得熟悉，并且与你的经验产生共鸣。
- en: Starting small
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从小做起
- en: We rarely find ourselves working for a company that has colossal plans to conquer
    the world with majestic software that solves a huge problem for humanity. Well,
    some businesses try but inevitably fail, and that's probably one of the well-learned
    lessons that people rarely forget. More often than not, businesses are trying
    to solve real problems that people are dealing with frequently. At least, that's
    what people that run the company believe. So, as a developer, you probably would
    work on a system with a reasonable scale, unless you work for a software giant
    such as Microsoft or SAP. But make no mistake, they started small as well, although
    most people forget that.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少遇到那些有宏伟计划用壮丽的软件征服世界，为人类解决巨大问题的公司。好吧，有些企业尝试过但不可避免地失败了，这可能是人们很少忘记的宝贵教训之一。更常见的是，企业试图解决人们经常遇到的真实问题。至少，这是公司运营者所相信的。所以，作为一个开发者，你可能会在一个规模合理的系统上工作，除非你为像微软或SAP这样的软件巨头工作。但不要弄错，他们也是从小开始的，尽管大多数人忘记了这一点。
- en: When a couple of developers start working on a system, everything works quite
    well because the team is small and the goal is hopefully quite clear. If the problem
    they are aiming to solve is real and the solution is viable, the company would
    probably start making some money rather quickly, after spending a year or two
    to build the first version of the software. By that time, the system would still
    be reasonably small and the number of people building it won't exceed a handful
    of engineers. Companies such as Uber, AirBnB, and GitHub all started that way.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当几个开发者开始对一个系统进行工作时，一切运作得相当顺利，因为团队规模小，目标希望很明确。如果他们试图解决的问题真实存在，解决方案可行，公司可能会在花费一两年时间构建软件的第一个版本后很快开始赚钱。到那时，系统仍然相对较小，构建它的人数不会超过几个工程师。像Uber、AirBnB和GitHub这样的公司都是这样开始的。
- en: In the beginning, everything is fine. Then, at some point, the system becomes
    quite large and the productivity starts to decrease due to the size of the system.
    One single data model is being changed for many different reasons, conflicting
    interests of multiple product owners of project managers that all have their own
    teams working on different parts of the system start to struggle with a growing
    number of conflicts. The coordination effort grows since different teams touch
    places in the systems that they didn't expect to, but they must in order to do
    their work. But often such changes interfere with other teams' work. Releases
    are being heavily coordinated and the effort of making a release sometimes exceeds
    the effort of creating features. The company never releases on Friday, because
    the risk is too high and people are almost certain that there are bugs that weren't
    caught during the testing phase, although the QA team is doing their best. Fixing
    bugs becomes a challenging and daunting task; by fixing one bug developers create
    two more.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始，一切都很顺利。然后，在某个时刻，系统变得相当大，由于系统规模的原因，生产力开始下降。一个单一的数据模型因为许多不同的原因被修改，多个产品所有者或项目经理之间的利益冲突开始出现，他们各自有自己的团队在不同的系统部分工作，开始因为日益增长的冲突而挣扎。协调工作增加，因为不同的团队在系统中触及了他们未曾预料到的地方，但他们必须这样做才能完成工作。但通常这样的变更会干扰其他团队的工作。发布需要高度协调，有时发布的工作量甚至超过了创建功能的工作量。公司从不周五发布，因为风险太高，人们几乎可以肯定在测试阶段没有发现所有错误，尽管质量保证团队已经尽力了。修复错误变成了一项具有挑战性和艰巨的任务；修复一个错误开发者会创造两个新的错误。
- en: Does this sound familiar to you? If not—you are very lucky, probably the company
    you work for is already doing DDD or something similar. For me, after spending
    decades in the industry, this is a very common situation. To be honest, I've never
    worked in a company that hasn't had those issues. So, how did such a small and
    concise system eventually become an unmanageable monster that developers don't
    dare touch?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来熟悉吗？如果不熟悉——你非常幸运，可能你工作的公司已经在做领域驱动设计（DDD）或类似的事情。对我来说，在行业里度过了几十年，这种情况非常普遍。说实话，我从没在一家没有这些问题的公司工作过。那么，这样一个既小又简洁的系统是如何最终变成一个无法管理的怪物，让开发者不敢触碰的呢？
- en: Complexity, again
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂性，再次
- en: If you have some years of experience in the software development industry and
    have worked at one or more companies, you've probably worked on some production
    systems. Systems that are in production usually bring value to their users in
    one way or another. Such a system could be a product that people around the world
    use to solve their daily tasks, such as buying goods online or tracking their
    pets on a live map. Other systems are used internally to support company employees
    in what they do and by doing so, contributing indirectly to the value chain. That
    could be, for example, supply management, finance, billing, scheduling, or yield-management
    systems. Many companies develop their internal systems, which embrace the highest
    level of the domain knowledge that has been inherited by a long, successful history
    of a company's way of doing things over the years.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在软件开发行业工作了几年，并在一家或多家公司工作过，你很可能参与过一些生产系统的工作。通常，处于生产状态的系统以某种方式为用户提供价值。这样的系统可能是一个全球范围内的人们用来解决日常任务的产品，比如在线购物或通过实时地图追踪他们的宠物。其他系统则用于内部，以支持公司员工的工作，并通过这种方式间接地贡献到价值链中。这可能包括供应链管理、财务、账单、调度或收益管理系统。许多公司开发他们的内部系统，这些系统包含了公司多年来通过其成功的历史传承下来的最高级别的领域知识。
- en: Usually, people need software to solve complex problems. Complex problems can
    rarely be solved by simple solutions; we spent a good deal of time discussing
    this matter in [Chapter 1](948b7834-c47c-4321-a91c-2ba58068c52e.xhtml), *Why Domain-Driven
    Design?* and [Chapter 2](6fa9e02b-66fa-4e1d-a69c-f26726dc9ad0.xhtml), *Language
    and Context*. One inevitable aspect of dealing with a complex system is that such
    systems grow over time. Engineers grasp more and more of the business insight
    and capture the ever-changing needs of their users in code. Unavoidably, such
    evolutionary progress leads to the ever-increasing complexity of the software,
    reflecting the complexity of business problems that the software is trying to
    address.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，人们需要软件来解决复杂问题。复杂问题很少能通过简单的解决方案来解决；我们在[第1章](948b7834-c47c-4321-a91c-2ba58068c52e.xhtml)，“为什么是领域驱动设计？”和[第2章](6fa9e02b-66fa-4e1d-a69c-f26726dc9ad0.xhtml)，“语言和上下文”中花了大量时间讨论这个问题。处理复杂系统的一个不可避免的特点是，这些系统会随着时间的推移而增长。工程师们越来越掌握业务洞察力，并在代码中捕捉用户不断变化的需求。这种进化进步不可避免地导致软件的复杂性不断增加，反映了软件试图解决的商业问题的复杂性。
- en: So, even if the original plan is to build a rather simple solution to fix one
    or two things that we think people struggle with in their daily work, hoping that
    they will thank us for it by buying our product, we find ourselves on a slippery
    slope from the start. Our users would never be fully satisfied. No one wants to
    pay continuously for something that doesn't evolve. So, unless you are building
    a simple, catchy game app for a smartphone, hoping for millions of users to pay
    you once, you are probably building software that evolves over time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使最初的计划是构建一个相对简单的解决方案来解决我们认为人们在日常工作中遇到的一两个问题，希望他们通过购买我们的产品来感谢我们，我们发现自己从一开始就站在了一个滑梯上。我们的用户永远不会完全满意。没有人愿意为不发展的事物持续付费。所以，除非你正在为智能手机开发一个简单、吸引人的游戏应用，希望有数百万人一次性付费，否则你很可能正在构建一个随着时间的推移而演变的软件。
- en: More often than not, we cannot create a model for our software that will be
    valid for many years. Our understanding of the domain changes, our ignorance decreases,
    and we learn more about our users and their wishes. Something that was clear three
    months ago is not as clear today, and the model that was perfectly fine last year
    is now an obstacle. But, do we keep spending the time to find a better model and
    refactor our code to reflect these new insights? Well, not always.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的时候，我们无法为我们的软件创建一个能够持续多年的模型。我们对领域的理解在变化，我们的无知在减少，我们对用户及其愿望的了解也在增加。三个月前还清楚的事情，现在可能就不那么清晰了，去年还非常合适的模型现在可能已经成为了一个障碍。但是，我们是否一直在花费时间寻找更好的模型，并重构我们的代码以反映这些新的见解呢？嗯，不一定。
- en: When the system is new and the market pressure is high, developers are being
    pushed to deliver new features instead. So, the software just grows, in the number
    of features, number of lines of code, number of database tables, and the relations
    between them. We have no time to take a break, take a deep breath, and look at
    the model to see whether it can be improved. I won't even mention the time to
    refactor the code for features that have already been delivered—what's done is
    done; the project manager would rarely understand the need to rewrite code that
    already works.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: But that is not the worst part of it. As I mentioned before, nearly all systems
    start with a small code base. A small persistence model, or what we hear more
    often, the *data model*, comes along. We might not even have a class diagram,
    but most certainly someone spent time creating a relational model for the system,
    because relational databases are seen as the *default* choice to persist almost
    anything in this world, especially if you are working in a .NET space that is
    dominated by enterprises and companies that prefer using everything from Microsoft.
    So, SQL Server it is, most of the time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: New features lead to changes in the data model, new tables are added, new fields
    are added to the existing tables and before you realize, when you want to get
    anything from your database, you have to write a query with five inner joins because
    your DBA says that the database must be normalized and data duplication is evil.
    But some tables have so much data that you cannot just add a new field with a
    `NOT NULL` constraint, so you must add a couple of left outer joins as well. Of
    course, there are a couple of hundred stored procedures here and there, since
    it is faster that way and some people who worked here before you were better at
    writing SQL than C#. But stored procedures cannot be tested in isolation, and
    everything is tested on a copy of the production database. To add an insult to
    injury, there are no unit tests for the SQL code because the QA engineer will
    do regression tests manually anyway. Some stored procedures are so old that people
    prefer adding code at the end and don't dare touch the existing code for fear
    of breaking things because, well, there are no tests for stored procedures. Tables
    are well-known to be unavailable for the *find usages* feature of Visual Studio,
    so nobody really knows whether that particular table is being used for any query,
    although it occupies one gigabyte of the disk space that we tried to save by applying
    the third-level normalization to the database in the first place.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Maybe the picture I had drawn here is too dark, but I've seen it some many times
    during my decades of working in the industry that it is very hard for me to make
    it any softer. Does all or some of it sound familiar to you as well?  So, where
    exactly did it go wrong? Surely, we can blame SQL databases for everything and
    try to change them to something fancier, but would we ever be sure that by doing
    such a thing we solve any of the aforementioned issues? At the end of the day,
    databases are just tools and like any other tool, it is used or misused.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我画出的这幅图太暗了，但在我几十年的行业工作中，我见过它很多次，很难让它变得柔和。这一切是否让你感到熟悉？那么，究竟哪里出了问题？当然，我们可以把所有的问题都归咎于SQL数据库，并试图将它们改变得更加花哨，但我们真的能确定通过这样做就能解决上述问题中的任何一个吗？毕竟，数据库只是工具，就像任何其他工具一样，它被使用或误用。
- en: Big ball of mud
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大泥球
- en: What I described in the previous section is a pattern (or, more precisely, anti-pattern)
    known as *Big Ball of Mud*. The term was suggested by Brian Marick and then popularized
    by Brian Foote and Joseph Yoder in their paper called, unsurprisingly, *Big Ball
    of Mud*, published in 1997 ([http://www.laputan.org/mud/](http://www.laputan.org/mud/)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我在上一个部分描述的是一种被称为*大泥球*（或更精确地说，反模式）的图案。这个术语是由布莱恩·马里克提出的，后来由布莱恩·福特和约瑟夫·约德在他们的论文中普及，该论文出人意料地名为*大泥球*，发表于1997年([http://www.laputan.org/mud/](http://www.laputan.org/mud/))。
- en: Developers don't intentionally create software that later can be characterized
    by this awful term. We constantly work under pressure of the management, who want
    to get value from the software that we build and they see the value as new features.
    So, we don't really find time to improve the structure of our software. At least,
    this is the most common excuse that we give when someone asks us why the code
    is so convoluted and hard to maintain.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者并不是有意创建后来可以用这个可怕的术语来描述的软件。我们在管理层的压力下不断工作，他们希望从我们所构建的软件中获得价值，他们看到的价值是新的功能。因此，我们实际上没有时间来改进我们软件的结构。至少，这是当我们被问及为什么代码如此复杂且难以维护时，我们给出的最常见的借口。
- en: But, is it true? Is that the sole reason that exists for us to forget about
    the architecture and design? Certainly, the given reason is a valid one, but not
    the only one. What we tend to forget is that we don't really build systems. Such
    systems already exist and our software becomes part of some system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这是真的吗？这是我们忘记架构和设计的唯一原因吗？当然，给出的原因是有效的，但不是唯一的。我们往往忘记的是，我们并没有真正构建系统。这样的系统已经存在，我们的软件只是某个系统的一部分。
- en: Think about any kind of business. If you work for a bank, the bank is the system.
    It probably existed before without the software that is currently being used by
    the bank employees. Banks are interconnected and heavily regulated. They have
    customers with certain expectations about the reliability of the service provided
    by banks and the safety of their funds. This is just one of the countless examples
    that we can find around us.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 想想任何一种商业。如果你在银行工作，银行就是系统。它可能在没有目前银行员工使用的软件的情况下就已经存在了。银行之间相互连接，并且受到严格的监管。他们有客户，客户对银行提供的服务可靠性以及资金安全有一定的期望。这仅仅是我们周围可以找到的无数例子中的一个。
- en: Repeatedly, we make the same mistake of developing software that we see as a
    system on its own, ignoring the fact that it is just a part of something bigger,
    which is, in itself, a system. As I wrote before, software usually solves complex
    problems and therefore exists as a part of a larger landscape of some complex
    system. So, what is the system?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们反复犯同样的错误，那就是将软件视为一个独立的系统来开发，而忽略了它只是更大系统的一部分，而这个更大的系统本身也是一个系统。正如我之前所写的，软件通常解决复杂问题，因此存在于某个复杂系统的大景观中。那么，什么是系统？
- en: In the book *Thinking in Systems* by Donella H. Meadows, has defined system
    as an element set, which is interconnected. Such elements are organized in a coherent
    manner.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在唐娜·H·米多斯所著的《系统思考》一书中，将系统定义为元素集，这些元素是相互连接的。这些元素以协调的方式组织。
- en: There are surprisingly many things we can learn from such a short definition;
    for now, let's concentrate on the fact that no system consists of just one part
    and the parts of the system are always interconnected, exchanging information
    between them, and that is something we often forget about. System parts are not
    classes, modules, database tables, or stored procedures. These are atoms of a
    certain system part. What we usually do is try to put too many parts in one box
    and call it a software system. Let's check one trivial example to illustrate the
    inevitable path that leads us to the big ball of mud.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从如此简短的定义中，我们可以学到许多令人惊讶的东西；目前，让我们集中关注这样一个事实：没有系统只由一个部分组成，系统的各个部分总是相互连接，相互之间交换信息，而这正是我们常常忘记的东西。系统部分不是类、模块、数据库表或存储过程。这些都是某个系统部分的原子。我们通常试图把太多的部分放在一个盒子里，称之为软件系统。让我们检查一个简单的例子，以说明我们不可避免地走向一团糟的大泥球的道路。
- en: 'Think about an e-commerce system that deals with customer orders. Obviously,
    we need somewhere to keep information about all the products we sell. Definitely,
    we must be able to place orders and follow the order cycle, from the moment an
    order is placed until it is delivered. We start small and create a simple model,
    such as this one:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 想想一个处理客户订单的电子商务系统。显然，我们需要一个地方来保存我们销售的所有产品的信息。当然，我们必须能够下订单并跟踪订单周期，从下单的那一刻直到交付。我们从小处着手，创建一个简单的模型，比如这个：
- en: '![](img/9cd7ad90-e3a6-4a8a-91d1-557b6b7cbd50.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cd7ad90-e3a6-4a8a-91d1-557b6b7cbd50.png)'
- en: Simple e-commerce model
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的电子商务模型
- en: 'Of course, after a little while, we realize that the price on each order line
    cannot refer to the product price and must be fixed at the moment the line is
    created, so we implement that as well. Later, we get a requirement to keep the
    supplier information as well. Then, we must add a product image URL. When we start
    doing things for real, we must keep the stock-level information. Not long after
    that, we get a requirement to add the product-packaging information and the dimensions
    along with the weight, to be able to calculate shipping costs. Before we know
    it, our model looks quite a bit different:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，过了一会儿，我们意识到每条订单行上的价格不能参考产品价格，而必须在创建行时固定，所以我们也将这一点实现。后来，我们得到了一个要求保留供应商信息的要求。然后，我们必须添加产品图片URL。当我们开始真正做事时，我们必须保留库存水平信息。不久之后，我们得到了一个要求添加产品包装信息以及尺寸和重量，以便能够计算运费。在我们意识到这一点之前，我们的模型看起来已经相当不同了：
- en: '![](img/616e2b0b-c1a5-40ba-b411-bab7a3631f2e.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/616e2b0b-c1a5-40ba-b411-bab7a3631f2e.png)'
- en: The model becomes larger with time
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，模型变得越来越大
- en: You might notice that the full model is certainly different since you can find
    references such as `PaymentMethodId`, `PaymentTermsId`, and `PaymentId`, which
    must point to some tables as well. But I think this is enough to show the essence
    of it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到完整的模型肯定不同，因为你可以找到像`PaymentMethodId`、`PaymentTermsId`和`PaymentId`这样的引用，这些必须指向某些表。但我认为这已经足够展示其本质了。
- en: My point here is that we can clearly see that a small original model uncontrollably
    grew, following the requirements coming from different directions, trying to satisfy
    all needs at once. You might notice one field of the `Product` table, called `UpdatedAt`.
    I haven't invented it but found it on a sample model, posted as the answer to
    some question on Stack Overflow. Now, let's imagine what the significance of the
    date we put in this field was. Was the name of the product updated on that date?
    Or the price? Or, perhaps, the stock level? All those changes have completely
    different reasons; however, we only have one field to keep the date and time of
    the change.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里要说明的是，我们可以清楚地看到，一个小的原始模型在来自不同方向的需求驱动下不受控制地增长，试图一次性满足所有需求。你可能注意到`Product`表中的一个字段，称为`UpdatedAt`。这不是我发明的，而是在一个样本模型中发现的，作为Stack
    Overflow上某个问题的答案。现在，让我们想象一下我们放入这个字段中的日期的意义。是在那个日期更新了产品的名称吗？或者价格？或者，也许，库存水平？所有这些变化都有完全不同的原因；然而，我们只有一个字段来保存更改的日期和时间。
- en: 'What is the danger of having a model such as this? At the end of the day, there
    are countless products that have such models in their backend and some of them
    are even quite successful. Not so much, I would say. Such companies and products
    usually thrive despite having such a model, not because of it. Let''s see what
    happens when features are requested by different stakeholders:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型的危险是什么？最终，有无数的产品在其后端有这种模型，其中一些甚至相当成功。但我不这么认为。这样的公司和产品通常是在这种模型下繁荣，而不是因为这种模型。让我们看看当不同利益相关者请求功能时会发生什么：
- en: '![](img/e3a82bde-4532-4ccf-99b5-8b5f61e090af.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e3a82bde-4532-4ccf-99b5-8b5f61e090af.png)'
- en: Coupling is not only for code. It applies to the whole organization.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是代码需要耦合。它适用于整个组织。
- en: The sales team is now interested in selling the product in packages. They tell
    us that it is quite simple—we just need to create *a special type of product*
    and a simple child-parent relationship. They don't really think about the supply
    chain but we currently have all this information in one place. If different components
    of this fictitious packaged product come from different suppliers, who will actually
    be *the* supplier for it? The stock level is even trickier, it seems like we must
    calculate on-demand?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 销售团队现在对以套餐形式销售产品感兴趣。他们告诉我们，这相当简单——我们只需要创建一种**特殊类型的产品**和简单的父子关系。他们并没有真正考虑供应链，但我们目前所有这些信息都集中在一个地方。如果这个虚构的包装产品的不同组件来自不同的供应商，那么实际上**谁是**它的供应商呢？库存水平似乎更加复杂，我们似乎必须按需计算？
- en: The sales team also wants to have a tighter relationship with customers and
    give them a call when they stop buying from us. Maybe they have found another
    supplier and we can offer them a discount? To do that, we *simply* need to keep
    track of the running total of all sales for each customer and compare the numbers
    with our history. But, we don't have any history, so where do we get such data
    in the first place?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 销售团队还希望与客户保持更紧密的关系，并在他们停止从我们这里购买时给他们打电话。也许他们找到了另一个供应商，我们可以给他们提供折扣？为了做到这一点，我们**只需**跟踪每个客户的销售总额，并将这些数字与我们的历史数据进行比较。但是，我们没有历史数据，那么我们最初从哪里得到这样的数据呢？
- en: The finance team wants to see the total outstanding amount of customers who
    pay after they get the product, so-called **credit line customers**. If they are
    late with their payment, the finance department should decide different strategies
    for the debt collection, based on the amount. They see it as *just add another
    field* to the `Customer` table.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 财务团队希望看到支付产品后客户的总未结金额，即所谓的**信贷额度客户**。如果他们付款延迟，财务部门应根据金额决定不同的催收策略。他们认为这只是在`客户`表中**添加另一个字段**。
- en: We also have to address the request of the marketing team. They want to improve
    sales by showing more photos of a product. Right now, we have only one and they
    want at least three; but ideally, they need an unlimited number of pictures for
    any product. So, we either need to *just add two more fields* to the `Product`
    table or add a new table for photos with the many-to-many relationship; but in
    the latter case, we'll have to deal with data migrations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须处理营销团队的要求。他们希望通过展示更多产品的图片来提高销量。目前我们只有一张图片，他们至少想要三张；但理想情况下，他们需要任何产品无限数量的图片。因此，我们或者需要在`产品`表中**仅添加两个更多字段**，或者添加一个包含多对多关系的照片新表；但在后一种情况下，我们必须处理数据迁移。
- en: All those requests are potentially conflicting. We can clearly see that the
    same parts of the model will be touched when developers will be working on those
    new features. Let's add more damage to the picture and remember that we have three
    development teams. One team is only doing changes at the backend, two other teams
    are doing the frontend work—one for the web and the other for the legacy WinForm
    client.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些请求都有潜在的冲突。我们可以清楚地看到，当开发人员开始工作在这些新功能上时，模型的相同部分将被触及。让我们给这幅图增加更多损害，并记住我们有三个开发团队。一个团队只做后端更改，另外两个团队做前端工作——一个用于网页，另一个用于传统的WinForm客户端。
- en: The issue now is that we have three conflicting forces that push their requests
    through to developers, and in addition, we have three conflicting development
    teams working on the same parts of the model. It is hard to imagine that any of
    the frontend teams will be able to finish their work before the backend team will
    do the necessary changes to the database model and for all necessary layers if
    they have any.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们有三种相互冲突的力量推动他们的请求传递给开发者，而且还有三个相互冲突的开发团队在同一个模型的同一部分工作。很难想象，如果前端团队在后台团队对数据库模型进行必要的更改以及所有必要的层之前完成他们的工作，他们能否完成。
- en: Overall, we can see that the singular model for anything less trivial than a
    `Hello World` application would most probably lead to a big ball of mud. It might
    happen in a couple of months, but with a small team of good developers, a company
    might be happy with such a model for quite a while. But as soon as the business
    and the system grow, the mud monster will come and potentially do a lot of harm.
    At the very least, productivity will suffer. At most, the customers will get so
    annoyed by the lack of progress and the overall application performance that they will
    leave.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来看，我们可以看到，对于任何比“Hello World”应用更不平凡的事物，单一的模型很可能会导致一团糟。这种情况可能在几个月后发生，但如果有一个小团队的好开发者，公司可能会对这样的模型感到满意一段时间。但是，一旦业务和系统增长，泥潭怪物就会到来，可能会造成很多损害。至少，生产力会受到影响。最严重的情况是，客户会因为缺乏进展和整体应用性能而感到非常烦恼，以至于他们可能会离开。
- en: Structuring systems
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统结构
- en: 'I know I''ve been painting a somewhat horrifying picture so far now—when software
    undeniably slips toward becoming an unmanageable clew of spaghetti code. You might
    be wondering: what''s the point if we end up in the land of horror anyway? When
    we find ourselves there, we can start fresh, and learn from the past to build
    a new, shiny, bright system, with the newest technology and everything will be
    fine again. We will get back to the big rewrite topic later on, but for now, let''s
    think about why the new system would be better than the old one.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道到目前为止，我描绘了一幅相当令人恐惧的画面——当软件无疑地滑向成为一个无法管理的意大利面代码团。你可能会想：如果我们最终陷入恐怖之地，那还有什么意义呢？当我们发现自己身处其中时，我们可以从头开始，从过去的学习中构建一个新的、闪亮的、明亮的系统，使用最新的技术，一切都会再次变得顺利。我们稍后会回到大重写的话题，但现在，让我们思考一下为什么新系统会比旧系统更好。
- en: No matter whether we are planning to create a new software system or to refactor
    the old one, there is at least one thing we can do to ensure that we keep our
    software in good shape for quite a long time. We might not be able to use the
    most beloved programming language, the new, shiny silver-bullet framework, or
    a fancy new database, because our organization has certain constraints that are
    hard or impossible to fight against. These constraints rarely impose significant
    limitations on how we design our models. In the design of domain, models are where
    we can find the key to building better software.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是在计划创建一个新的软件系统还是重构旧的系统，至少我们可以做一件事来确保我们的软件在相当长的一段时间内保持良好的状态。我们可能无法使用最喜爱的编程语言、新的闪亮的银弹框架或一个花哨的新数据库，因为我们的组织有一些难以或无法对抗的限制。这些限制很少对我们设计模型的方式施加重大的限制。在领域设计方面，模型是我们找到构建更好软件的关键。
- en: In [Chapter 3](07ee37fb-0189-467c-865d-18e72868b137.xhtml), *EventStorming*,
    we discussed domain models. We should remember that models don't represent the
    real world. Instead, models provide a simplified version of the real world that
    is relevant for building a particular piece of software. Throughout this book,
    we've learned to avoid giving more information and behavior to our models than
    was absolutely necessary in order to solve the specific problems that we are aiming
    to solve with our software.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](07ee37fb-0189-467c-865d-18e72868b137.xhtml)，“事件风暴法”，我们讨论了领域模型。我们应该记住，模型并不代表现实世界。相反，模型提供了一个简化的现实世界版本，这对于构建特定的软件是相关的。在这本书的整个过程中，我们学会了避免给我们的模型提供比解决我们用软件试图解决的具体问题绝对必要的更多信息和行为。
- en: But now we see that as the number of concerns for the software grows, the amount
    of required information in the model grows as well. At the same time, we clearly
    see that this information is put together into a single model deliberately by
    developers, who tend to enrich the domain object with unrelated properties. It
    usually happens because the domain object name seems to be the same across different
    domains, but developers don't realize this.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们看到，随着软件关注点的增加，模型中所需的信息量也在增加。同时，我们清楚地看到，这些信息是由开发者故意组合成一个单一模型的，他们倾向于用无关的属性丰富领域对象。这通常是因为领域对象名称在不同领域之间似乎相同，但开发者没有意识到这一点。
- en: Now, we are going to look at how we can structure our software better, providing
    clear separation for concepts with similar names but different meanings. DDD offers
    the concept of *Bounded Context* to define such separation and we are going to
    look at how to find and define boundaries for such contexts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨如何更好地构建我们的软件结构，为具有相似名称但含义不同的概念提供清晰的分离。DDD 提供了 *边界上下文* 的概念来定义这种分离，我们将探讨如何寻找和定义这些上下文的边界。
- en: Make no mistake, when I write about structuring the system, going away from
    a single model and introducing boundaries, this doesn't imply having multiple
    executables, using microservices, migration to Docker, and so on. Bringing sanity
    to domain models is the most important topic and we will touch upon the implementation
    details in the next chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要误解，当我写关于系统结构化、远离单一模型并引入边界时，这并不意味着拥有多个可执行文件、使用微服务、迁移到 Docker 等等。使领域模型变得合理化是最重要的主题，我们将在下一章中触及实现细节。
- en: Linguistic boundaries
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言边界
- en: Remember that we talked about the *speed of change* when we were going through
    the aggregate design topic? So, you might wonder if we are going in circles right
    now. Indeed, we can clearly see that things such as the thumbnail URL or the photo
    URL of the product have nothing to do with the product price or stock level. The
    stock level might change every second if the product is popular and we have enough
    customers. The price might be dynamic as well, but we could expect it to be more
    stable. Photos, however, will probably never change, along with the weight and
    the packaging size. Keeping all this information in one aggregate is not something
    we'd embrace and we learned about this already.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在讨论聚合设计主题时提到的 *变化速度* 吗？所以，你可能想知道我们现在是否在原地打转。确实，我们可以清楚地看到，像产品的缩略图 URL 或照片
    URL 这样的东西与产品价格或库存水平没有任何关系。如果产品受欢迎并且我们有足够的客户，库存水平可能会每秒变化。价格也可能动态变化，但我们预计它会更加稳定。然而，照片、重量和包装尺寸可能永远不会改变。将所有这些信息放在一个聚合中并不是我们愿意接受的事情，而且我们已经学到了这一点。
- en: Where, then, do we keep it? Do we create several aggregates, all called `Product`?
    Although that might sound weird, the answer could be *yes* if we can identify
    the boundaries where each of those aggregates will live. We must also talk to
    our domain experts and gain more insight, at least about the language. Some new
    discoveries could await us there, such as the inventory level is indeed being
    referred to as `Inventory` and not `Product`. But for some other areas, such as
    sales, marketing, and procurement, they may use the same term and mean different
    things. As we learned in [Chapter 2](6fa9e02b-66fa-4e1d-a69c-f26726dc9ad0.xhtml), *Language
    and Context*, we can see the context is changing there.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们把它放在哪里呢？我们是否创建几个名为 `Product` 的聚合？虽然这听起来可能有些奇怪，但如果我们能识别出每个聚合将存在的边界，答案可能是
    *是的*。我们还必须与我们的领域专家交谈，并获取更多见解，至少关于语言方面。那里可能会有一些新的发现，例如库存水平确实被称为 `Inventory`，而不是
    `Product`。但对于其他领域，如销售、营销和采购，他们可能使用相同的术语，但含义不同。正如我们在 [第 2 章](6fa9e02b-66fa-4e1d-a69c-f26726dc9ad0.xhtml)
    中学习的，*语言与上下文*，我们可以看到上下文在那里正在变化。
- en: When I see very common words such as `Customer`, `Person`, `Contact`, or `Order`
    scattered upon a large code base, an alarm bell goes off in my head. Here be dragons
    or, to be more specific, the big ball of mud. Developers of this system weren't
    cautious enough to dive deeper into the domain specifics to find what these terms
    mean in different parts of the business. If we look at the `Product` example in
    the previous diagram, we could see unrelated concepts placed in one object for
    no particular reason.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我看到像`Customer`、`Person`、`Contact`或`Order`这样非常常见的词语在一个庞大的代码库中散布时，我的脑海中就会响起警钟。这里可能有龙或，更具体地说，一个大泥球。这个系统的开发者没有足够谨慎地深入研究领域特定性，以找到这些术语在业务的不同部分中的含义。如果我们看看之前图中`Product`的例子，我们就可以看到没有特定原因地将不相关的概念放在一个对象中。
- en: I can't stress enough how dangerous this approach is for the software and beyond.
    Think about a meeting you might have with two domain experts. One would be telling
    you about adding more pictures to the product to enrich the catalog. Another one
    is only interested in the delivery process and needs to have the product weight
    and packaging details to calculate the shipping costs. You might notice the difference
    in their language, and from such a conversation you might learn that the single
    model that you already have or plan to implement won't suit the business.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法强调这种做法对软件及其以外的危险程度。想想您可能参加的与两位领域专家的会议。一位会告诉您添加更多图片以丰富目录。另一位只对配送过程感兴趣，需要产品的重量和包装细节来计算运费。您可能会注意到他们语言上的差异，并且从这样的对话中，您可能会了解到您已经拥有或计划实施的单一模型不会满足业务需求。
- en: 'So, defining bounded contexts about the meaning of words, looking for particularities,
    and being eager to truly understand the context where these words are being used
    is the first and the most powerful method to find context boundaries:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义关于词语意义的边界上下文，寻找特殊性，并渴望真正理解这些词语被使用的上下文，这是找到上下文边界的第一种也是最有力的方法：
- en: '![](img/ac75fdbe-476c-4f73-ae09-e1d64424241a.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac75fdbe-476c-4f73-ae09-e1d64424241a.png)'
- en: Words change meaning in a context
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 词语在上下文中改变含义
- en: As you can see, one single term that is used in a different context with a different
    meaning can be modeled inside its own context with a concise meaning. Instead
    of a single object with unrelated properties, we now have several. Those new objects
    are much smaller and contain only the information that is relevant to the specific
    context. Making a change to an object in one context should have no effect on
    all other objects with the same name in other contexts, and it can be made freely
    by the developer that works with the context where these changes are being made,
    eliminating, or at least minimizing, the risk of introducing issues elsewhere.
    Naturally, this brings us to the next purpose and benefit of bounded contexts: the
    autonomy of development teams.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一个在特定上下文中具有不同含义的单个术语可以在其自身的上下文中以简洁的意义进行建模。我们不再只有一个具有无关属性的单一对象，而是有多个。这些新对象要小得多，只包含与特定上下文相关的信息。在一个上下文中对对象所做的更改不应影响其他上下文中具有相同名称的所有其他对象，并且可以由在该上下文中进行更改的开发者自由地进行，从而消除或至少最小化在其他地方引入问题的风险。自然地，这引出了边界上下文的下一个目的和好处：开发团队的自主性。
- en: Another aspect of context boundaries is the extended *Tell, Don't Ask* principle.
    The original principle was formulated by Alec Sharp in his book *Smalltalk by
    Example*, published in 1997.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文边界的另一个方面是扩展的*告诉，不要询问*原则。原始原则是由Alec Sharp在他的1997年出版的书籍《Smalltalk by Example》中提出的。
- en: As you might have noticed from your own experience, there is a lot of code out
    there in production software that uses procedural style, even if it is written
    in an object-oriented language. Unfortunately, .NET-based projects suffer from
    this a lot, especially those that are written using WinForms and ASP.NET ([https://dotnet.microsoft.com/apps/aspnet](https://dotnet.microsoft.com/apps/aspnet))
    WebForms. I've seen many applications where the business logic is concentrated
    inside the code—behind UI elements, scattered across numerous `OnClick` event
    handlers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能从自己的经验中注意到的，在生产的软件中有很多使用过程式风格的代码，即使它是用面向对象的语言编写的。不幸的是，基于.NET的项目深受其害，特别是那些使用WinForms和ASP.NET
    ([https://dotnet.microsoft.com/apps/aspnet](https://dotnet.microsoft.com/apps/aspnet))
    WebForms编写的项目。我见过许多应用程序，其业务逻辑集中在代码中——在UI元素后面，分散在许多`OnClick`事件处理器中。
- en: Better-designed software uses separate classes to implement business logic.
    The pattern that embraces the isolation of the business logic from the UI logic
    and the persistence is known as **multilayer architecture** or **n-tier architecture**.
    Wikipedia defines this term as a *client-server* type of architecture, but that
    is not exactly correct. You can have multiple layers without separating client
    and server code if the application is a desktop rich-client application or a web
    application with server-side rendering, where all actions cause a roundtrip to
    the server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 设计更好的软件使用独立的类来实现业务逻辑。将业务逻辑从UI逻辑和持久性中隔离出来的模式被称为**多层架构**或**n层架构**。维基百科将这个术语定义为一种**客户端-服务器**类型的架构，但这并不完全准确。如果应用程序是一个桌面富客户端应用程序或具有服务器端渲染功能的Web应用程序，其中所有操作都会导致与服务器的一次往返，那么即使没有分离客户端和服务器代码，也可以有多个层次。
- en: 'When we are looking for context boundaries, one of the indicators that can
    help in finding them is the availability of information that is needed to make
    decisions. When users (which could potentially include other systems) send commands
    to the domain model, the model itself must be able to handle this command without
    going to other parts of the system to fetch information. That might be confusing
    at the beginning because, at first glance, we might see that some commands require
    a lot of information that we considered to be located outside of the context where
    the command is executed. Let''s take a look at the e-commerce example again:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在寻找上下文边界时，一个可以帮助我们找到它们的指标是所需做出决策所需信息的可用性。当用户（这可能包括其他系统）向领域模型发送命令时，模型本身必须能够处理这个命令，而无需去系统的其他部分获取信息。这可能在开始时有些令人困惑，因为我们可能会看到一些命令需要大量的信息，而这些信息我们认为是位于执行命令的上下文之外。让我们再次看看电子商务的例子：
- en: '![](img/9e6a4f14-4746-4b78-8de2-56e386cf6d33.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e6a4f14-4746-4b78-8de2-56e386cf6d33.png)'
- en: Several queries are needed to make a decision
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 做出决定需要几个查询
- en: When we tell the domain model of the `Sales` context to place an order, it seems
    to require a lot of information from other contexts to make decisions for the
    command's execution. This can create quite a lot of confusion, and if we follow
    our gut without thought, we would hardly resist the urge to put all the information
    from the whole system in one place. And, the big ball of mud strikes again.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们告诉`Sales`上下文的领域模型放置一个订单时，它似乎需要从其他上下文中获取大量信息来做出决策。这可能会造成相当多的困惑，如果我们没有经过思考就跟随直觉，我们几乎无法抵制把整个系统的所有信息放在一个地方的冲动。而且，大泥球问题再次出现。
- en: In reality, we only need a fraction of the information from other contexts to
    make that decision. Besides, if we consider commands that affect that information,
    we could quite clearly see that none of them will be touching the sales context.
    For example, the inventory level is updated solely inside the `Inventory` context.
    The available credit limit for a customer is balanced between the agreed initial
    credit limit and the number of unpaid invoices. Contact details of the customer
    are updated in a completely independent fashion from anything else.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，我们只需要从其他环境中获取信息的一小部分来做出那个决定。此外，如果我们考虑影响该信息的命令，我们可以清楚地看到，其中没有任何一个会触及销售环境。例如，库存水平仅在`Inventory`环境中更新。客户的可用信用额度在协议的初始信用额和未付款发票数量之间保持平衡。客户的联系信息以一种完全独立的方式更新，与其他任何事物无关。
- en: But, you might have noticed that there is still some level of information exchange.
    How does the inventory level change? How does the unpaid amount for the customer
    get updated? Surely, there are some actions that trigger those updates. We feel
    that somehow these triggers are linked to the order processing and that might
    even increase our certainty to put everything together, again.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你可能已经注意到，仍然存在一定程度的信息交换。库存水平是如何变化的？客户的未付款金额是如何更新的？当然，有一些动作会触发这些更新。我们感觉这些触发器与订单处理有关，这甚至可能会增加我们把这些东西放在一起的确信度。
- en: But wait a minute. The inventory level doesn't necessarily decrease when the
    order is placed. We might need to clarify that with domain experts, but most certainly,
    the inventory only gets updated when the order is shipped and that's probably
    not handled by `Sales` but by the `Shipment` context instead. The same happens
    with the total outstanding amount—it probably only gets updated when we send an
    invoice for the order. That, in turn, might only happen when the order is shipped
    or even delivered. So, you can see that these links between contexts are not really
    that direct and straightforward. There is more logic involved that we might not
    even consider at first glance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，订单下单时库存水平并不一定会减少。我们可能需要与领域专家澄清这一点，但可以肯定的是，库存只有在订单发货时才会更新，而这可能不是由“销售”部门处理，而是由“发货”上下文处理。同样，总未结金额也只有在发送订单发票时才会更新。这反过来可能只发生在订单发货或交付时。所以，你可以看到这些上下文之间的联系并不是那么直接和简单。其中涉及更多的逻辑，我们可能一开始甚至都没有考虑到。
- en: 'The topic of cross-context communication will be briefly touched upon in the
    next chapter, but even now I can tell you that it happens by the same *Tell, Don''t
    Ask* principle. Contexts emit domain events after executing each command, as we
    learned in [Chapter 3](07ee37fb-0189-467c-865d-18e72868b137.xhtml), *EventStorming,*
    and even implemented in the earlier chapters. We never used those events to share
    the information, but that''s exactly how the necessary—and only the necessary—data
    gets across context boundaries. So, we might need to have some context-specific
    objects that we haven''t originally considered. Let''s look at the revised diagram
    of the `Place an order` command and the details needed to execute it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将简要讨论跨上下文通信的话题，但现在我可以告诉你，它遵循相同的“只告诉，不询问”原则。上下文在执行每个命令后都会发出领域事件，正如我们在[第三章](07ee37fb-0189-467c-865d-18e72868b137.xhtml)“事件风暴”中学到的，甚至在早期章节中已经实现。我们从未使用这些事件来共享信息，但这正是必要且仅必要的数据跨越上下文边界的方式。因此，我们可能需要一些原本未考虑到的上下文特定对象。让我们看看“下单”命令的修订图和执行它所需的详细信息：
- en: '![](img/045a56d0-a7ba-4210-bc39-3a5e4e800619.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/045a56d0-a7ba-4210-bc39-3a5e4e800619.png)'
- en: Tell-only flow
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 只告诉的流程
- en: Here, you can see that there are no *ask* arrows anymore. All we do is *tell*
    others either to do something, or that something has been done.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到已经没有“询问”箭头了。我们所做的只是“告诉”其他人去做某事，或者某事已经完成。
- en: 'There are two points that I would like to draw your attention to:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有两点我想引起你的注意：
- en: You might wonder why the CRM context is not sharing any information with the
    `Sales` context. Don't we need customer details to place an order? Not exactly.
    We might need this information to know the customer's name and contact details
    to know where the order needs to be delivered. But none of those details is required
    to decide whether we can place the order. Of course, we might get more complicated
    requirements, when orders for certain delivery addresses cannot be placed, but
    that is something that needs to be clarified with domain experts and, clearly,
    some more domain knowledge is required to get such constraints into the system.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么CRM上下文没有与“销售”上下文共享任何信息。我们难道不需要客户详情来下单吗？并不完全是这样。我们可能需要这些信息来知道客户的名字和联系详情，以便知道订单需要送到哪里。但没有任何这些详情是决定我们是否可以下单所必需的。当然，我们可能会遇到更复杂的要求，当某些送货地址的订单无法下单时，但这需要与领域专家澄清，并且显然需要更多的领域知识才能将这些约束纳入系统中。
- en: I often hear complaints that keeping the information about the same physical
    entity in different contexts leads to data duplication. In the model shown in
    the previous diagram, that is not the case. The information we share is not exactly
    the same as the data we keep inside each context. For example, the number of product
    items available for sale doesn't necessarily replicate the current stock item.
    Some more complicated rules might be involved and the sales domain is kept happily
    ignorant to those rules, which are completely internal to the `Inventory` context.
    But then, some data will definitely be duplicated and that is a small price to
    pay to keep our models clean. There is no harm in keeping the same data in multiple
    places, the disk space is not a big issue these days.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我经常听到抱怨，说在不同上下文中保持同一物理实体的信息会导致数据重复。在前面图表中展示的模型中，情况并非如此。我们共享的信息并不完全等同于每个上下文中我们保留的数据。例如，可供销售的产品数量并不一定复制当前的库存项目。可能涉及一些更复杂的规则，而销售领域对这些规则保持愉快的不知情，这些规则完全属于“库存”上下文内部。但是，一些数据肯定会被重复，这是为了保持我们的模型整洁而付出的微小代价。在多个地方保留相同的数据并没有什么害处，现在的磁盘空间并不是一个大问题。
- en: But we definitely must ensure that keeping the information in sync is reliable,
    which is something we will be looking in the next chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们绝对必须确保保持信息同步是可靠的，这一点我们将在下一章中探讨。
- en: Team autonomy
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队自主性
- en: If you ever used Kanban or at least learned about it, you probably remember
    that the holy grail of this methodology is to reduce **work in progress** (**WIP**).
    There is a lot you can learn from Kanban practitioners, but if you don't limit
    the WIP, you aren't doing Kanban. That, by the way, is why teams often fail when
    trying the methodology.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过看板或者至少了解过它，你可能记得这个方法的圣杯是减少**工作在进度中**（**WIP**）。你可以从看板实践者那里学到很多东西，但如果你不限制WIP，你其实并没有在做看板。顺便说一句，这也是为什么团队在尝试这种方法时经常失败的原因。
- en: 'Originally, the idea of doing the work in small batches to eliminate queues
    and stocking up materials along the value creation stream comes from the manufacturing
    industry. You''ve probably heard of the *Toyota Way*, where Kanban originates
    from, or the **Theory of Constraints** (**ToC**) formulated by Eliyahu M. Goldratt.
    Although the philosophy of those methods comes from a rather different industry,
    where some of the aspects are drastically different from the software industry,
    I''d like to emphasize the following two principles that we can directly apply
    to our work in order to be more efficient in delivering business value: limiting
    work in progress and improving throughput.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，将工作分成小批量以消除队列和沿价值创造流储存材料的想法来自制造业。你可能听说过源自看板的**丰田之道**，或者由Eliyahu M. Goldratt提出的**约束理论**（**ToC**）。尽管这些方法的哲学来自一个相当不同的行业，其中一些方面与软件行业截然不同，但我想要强调以下两个原则，我们可以直接将这些原则应用到我们的工作中，以便更有效地交付业务价值：限制工作在进度中和提高吞吐量。
- en: Limiting work in progress
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制工作在进度中
- en: When a team or an individual developer is working on a list of things at the
    same time, completing any single item from the list would always take more time
    than if they were working solely on one thing. That happens, above all, due to
    the context switching, which I mentioned in [Chapter 2](6fa9e02b-66fa-4e1d-a69c-f26726dc9ad0.xhtml),
    *Language and Context*. When we change our focus from one task to another, there
    will always be some time lost to bring our mind to the state when we can work
    on the new task efficiently. The more things we have unfinished, the more things
    that need to be remembered and then recovered—from memory and notes—when we go
    back to an unfinished task.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个团队或个人开发者同时处理一个待办事项列表时，完成列表中的任何一项通常会比他们只专注于一件事情花费更多的时间。这种情况尤其是因为上下文切换，正如我在[第二章](6fa9e02b-66fa-4e1d-a69c-f26726dc9ad0.xhtml)“语言与上下文”中提到的。当我们从一项任务切换到另一项任务时，总会有一段时间损失，这是为了将我们的思维状态调整到可以高效地处理新任务。我们未完成的事情越多，需要记住的事情就越多，当我们回到未完成的任务时，就需要从记忆和笔记中恢复这些事情。
- en: When teams that are working on a system that has a single model and single monolithic
    code base, those teams will have to coordinate with each other. Coordination might
    be required to prevent changes in share classes that are being changed for unrelated
    reasons. They might also need to ensure that before one team makes their changes,
    the other team does some prerequisite work. Data migration, regression testing,
    coordinated releases, and so on—we are quite familiar with those type of dependencies
    between teams.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当团队在一个具有单一模型和单一单体代码库的系统中工作时，这些团队将需要相互协调。协调可能需要防止因无关原因而更改共享类别的变化。他们还可能需要确保在一个团队进行更改之前，另一个团队做一些前置工作。数据迁移、回归测试、协调发布等等——我们对团队之间这种类型的依赖关系非常熟悉。
- en: But management rarely cares about such dependencies. If during the stand-up
    meeting, one team reports that they are waiting for another team to complete their
    work, their manager will ask them to do something else while they are waiting.
    When that happens, they get one more WIP item that cannot be completed right now,
    so they pull another item from the backlog and start working on it. That item
    might get some dependency as well and so the number of unfinished work snowballs.
    Teams start to blame each other for not delivering anything at all since they
    were all waiting for someone else.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但是管理层很少关心这种依赖关系。如果在站立会议期间，一个团队报告说他们正在等待另一个团队完成他们的工作，他们的经理会要求他们在等待期间做其他事情。当这种情况发生时，他们会得到一个无法立即完成的WIP项目，因此他们会从待办事项中拉出一个项目并开始工作。那个项目可能也会有一些依赖关系，因此未完成的工作数量会像雪球一样滚雪球般增加。团队开始互相指责，因为他们都在等待别人，以至于什么都没有交付。
- en: What suffers most in these situations is the throughput.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，受影响最大的是吞吐量。
- en: Improving throughput
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高吞吐量
- en: If there is a step in the delivery pipeline that is slow, the whole pipeline
    cannot produce more than this single step does. When teams work on a single codebase
    and a single model, they can have two major issues. First, there's the always-growing
    work in progress, as described in the previous paragraph. A constant need for
    coordination and continuous waiting leads to a lot of unfinished business. Some
    items from the *in progress* list will eventually be worked on again after the
    wait is over, but then comes the context switching. Sometimes, teams spend days
    or weeks picking up the work they put on hold a couple of months before. The time
    that is spent on the cross-team coordination—waiting for the others to complete
    the prerequisite job and to get back to the new context—is wasted. During that
    time, no value is produced but the money is spent as if the teams were doing something
    useful.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果交付管道中的某个步骤很慢，整个管道的生产能力不会超过这个单个步骤。当团队在一个单一代码库和单一模型上工作时，他们可能会遇到两个主要问题。首先，正如前一段所述，总是不断增长的工作在进度中。持续的协调和连续的等待导致大量未完成的工作。一些来自*进行中*列表的项目在等待结束后最终会再次被处理，但随后是上下文切换。有时，团队可能会花费几天或几周的时间来恢复几个月前搁置的工作。在跨团队协调——等待其他人完成前置工作并回到新上下文——这段时间内，时间被浪费了。在这段时间里，没有产生任何价值，但钱就像团队在做一些有用的事情一样被花掉了。
- en: One more thing that could affect the throughput is a bottleneck. If all changes
    need to be done by two teams, no matter how fast or brilliant one team is, if
    the other team is slow or suffers from being understaffed of not skilled enough,
    the work will not be finished before the slowest of the two teams completes their
    part. Such a situation usually happens in organizations that split their teams
    not based on domain expertise or function, but on technological skill. A typical
    example would be the frontend team, the backend team, and the database team. You
    don't need to have all three, having just two of those will do enough damage to
    slow down the value chain tremendously. Before the database schema is changed,
    no work can be completed at the backend. Before the backend job took shape, at
    least in a form of the API contract (if the company is skilled enough to embrace
    contract-based development), the frontend team can do very little without having
    a risk of rewriting half of their code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可能影响吞吐量的另一个因素是瓶颈。如果所有变更都需要由两个团队完成，无论一个团队的速度有多快或有多聪明，如果另一个团队速度慢或人员不足或技能不够，那么工作将不会在两个团队中最慢的那个团队完成其部分之前完成。这种情况通常发生在组织不是基于领域专业知识或功能，而是基于技术技能来划分团队的情况下。一个典型的例子是前端团队、后端团队和数据库团队。你不需要所有三个团队，只要有两个就足以对价值链造成巨大的损害。在数据库模式更改之前，后端无法完成任何工作。在后台工作成形之前，至少在API合约的形式（如果公司足够有技能来拥抱基于合约的开发）中，前端团队几乎无法做什么，而不会面临重写一半代码的风险。
- en: When teams are structured in this way, we can observe the worst example of Conway's
    law in real life.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当团队以这种方式组织时，我们可以在现实生活中观察到康威定律最糟糕的例子。
- en: Conway's law
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 康威定律
- en: Fifty years ago, in 1968, Melvin E. Conway published his paper called *How Do
    Committees Invent*? ([http://www.melconway.com/research/committees.html](http://www.melconway.com/research/committees.html)).
    Perhaps the most cited part of that paper is the formulation of what we now call
    **Conway's law**, which states that if an organization designs a system, it will
    produce a design with a copy of that organization's communication structure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 五十年前，在1968年，Melvin E. Conway发表了名为《委员会如何发明？》的论文([http://www.melconway.com/research/committees.html](http://www.melconway.com/research/committees.html))。也许这篇论文最被引用的部分就是我们现在称之为**康威定律**的表述，它指出如果一个组织设计一个系统，它将产生一个与该组织通信结构副本的设计。
- en: I don't really want to overload you with details now but remember that this
    definition became so relevant that the 2017 edition of the DDD Europe conference
    had Conway's law as the main topic.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在不想让你负担太多细节，但请记住，这个定义变得如此相关，以至于2017年DDD欧洲会议的主题就是康威定律。
- en: In the context of this chapter, my personal observations that how organizations
    structure their teams directly impacts the structure of their software, very much
    confirm the hypothesis of Mel Conway. I gave an example of technically-oriented
    teams because I experienced it during my career more than once. In one organization,
    I saw that the team that worked on a web part of the system user interface came
    so much in conflict with the team that was working on the rich-client for the
    same system, that they decided to create a separate domain model, backed by a
    separate database model, for them to use. That was done solely to avoid having
    blocking dependencies between those teams since they couldn't find a good way
    to coordinate. A lot of blood was spilled between those teams blaming each other,
    but in my view the situation was inevitable and there was no one to blame except
    the management that decided to structure teams like that.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的背景下，我个人的观察是，组织如何构建团队直接影响了他们软件的结构，这非常证实了Mel Conway的假设。我给出了一个技术导向团队的例子，因为我在我职业生涯中不止一次经历过。在一个组织中，我看到负责系统用户界面Web部分的团队与负责同一系统的丰富客户端的团队发生了如此多的冲突，以至于他们决定为各自创建一个独立的领域模型，并支持一个独立的数据库模型，以便使用。这是为了完全避免这些团队之间有阻塞依赖，因为他们找不到一个好的协调方式。这些团队之间因为互相指责而流了很多血，但在我看来，这种情况是不可避免的，没有人应该为此负责，除了决定以这种方式构建团队的管理层。
- en: Coordination between teams rarely works and most often leads to delays, tons
    of time spent on meetings and context switching. It also creates tensions between
    teams and create risks to slide into the blame-game. We can talk about *improving
    communication* for years and it won't improve the coordination even slightly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 团队间的协调很少有效，通常会导致延误，花费大量时间在会议和上下文切换上。它还会在团队之间产生紧张关系，并增加陷入责任游戏的危险。我们可以谈论*提高沟通*多年，但这甚至不会稍微改善协调。
- en: Loose coupling, high alignment
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松耦合，高内聚
- en: I probably drowned you in the sea of problems that our industry suffers from
    on a large scale today. Let me bring some light to the picture and give you some
    clues as to how we can improve the situation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能已经让你淹没在我们行业今天大规模遭受的问题的海洋中。让我为这幅图带来一些光明，并给你一些线索，关于我们如何可以改善这种情况。
- en: 'As developers, we hear that we need to strive toward loose coupling and high
    cohesion in our code. Overall, the principle of one unit is responsible for one
    thing applies not only for classes in our code but also, for example, for services
    in the **service-oriented architecture** (**SOA**). It also applies to the responsibilities
    of teams. Structuring teams around their technical proficiency are suboptimal.
    Let''s look at how such teams might work when we have two distinct feature requests:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们经常听到我们需要努力追求代码中的松耦合和高内聚。总的来说，一个单元负责一件事的原则不仅适用于我们代码中的类，例如，也适用于**面向服务的架构**（**SOA**）中的服务。它同样适用于团队的责任。围绕团队的技术专长来构建团队是不太理想的。让我们看看当有两个不同的功能请求时，这样的团队可能会如何运作：
- en: '![](img/0c9416cb-57f5-4c33-9ce2-6158645f76e9.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c9416cb-57f5-4c33-9ce2-6158645f76e9.png)'
- en: Flow when coordination is required
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 需要协调的流程
- en: The flow shown in this diagram is greatly simplified, but you get the idea.
    All those white spots in between chunks of work that the teams are doing to complete
    those two stories are mostly wasted. That time could be spent on waiting, context
    switching, and small-scale coordination when developers from different teams need
    to agree on the sequence of work and issues discovered in the deliverables of
    other teams. In the end, there is not a single delivery done during the time frame,
    teams keep switching between tasks but the release is being constantly postponed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图中展示的流程被大大简化了，但你能理解这个概念。那些团队在完成这两个故事时所做的、分布在各个工作块之间的所有空白区域几乎都是浪费的。这些时间本可以用来等待、上下文切换以及当不同团队的开发者需要就其他团队交付成果中的工作顺序和发现的问题达成一致时进行的小规模协调。最终，在规定的时间内没有完成任何交付，团队不断在任务之间切换，但发布却一直被不断推迟。
- en: 'If, however, teams are organized around business functions, or domains, the
    picture would be completely different:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果团队是围绕业务功能或领域组织起来的，情况将完全不同：
- en: '![](img/6ba01d02-141b-425d-bc92-f33bd8c56ec1.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ba01d02-141b-425d-bc92-f33bd8c56ec1.png)'
- en: Flow without coordination
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 无需协调的流程
- en: Don't be mistaken by the linear flow of work, since it is placed on a singular
    timeline. All these steps can be done in iterations, but iterations itself won't
    save you if teams require coordination.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被工作的线性流程所误导，因为它被放置在单一的时间线上。所有这些步骤都可以在迭代中进行，但如果团队需要协调，迭代本身并不能救你。
- en: Even if the amount of work is more or less the same, although it would probably
    be less due to a better focus and deeper domain knowledge, the coordination effort
    is gone along with context switching. Both teams are able to release independently
    and be ready to pick up new tasks.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使工作量或多或少相同，尽管由于更好的专注度和更深入的领域知识，这可能会更少，但协调努力和上下文切换已经消失了。两个团队都能够独立发布并准备好接受新任务。
- en: Highly-aligned and loosely-coupled teams are one of the fundamental principles
    of the highly-praised Netflix culture, for example. One of the prerequisites to
    make such a structure even feasible is to have clear boundaries where each team
    operates. It doesn't mean, however, that teams must be assigned to work with a
    single bounded context. You might identify six contexts and have only three teams.
    In such a case, you need to look at the team size first. If each team has 10 members,
    maybe you want to have more teams that are smaller. Teams of five are fine in
    keeping the information-sharing tight and the feedback loop short.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 高度一致性和松散耦合的团队是备受赞誉的Netflix文化的基本原则之一，例如。使这种结构甚至可行的一个先决条件是每个团队都有明确的操作边界。然而，这并不意味着团队必须被分配到单一边界上下文中工作。你可能会识别出六个上下文，但只有三个团队。在这种情况下，首先需要考虑团队规模。如果每个团队有10名成员，可能希望有更多规模较小的团队。五人团队在保持信息共享紧密和反馈循环短方面是可行的。
- en: But, there is no limitation to how many contexts one team can own. I can easily
    imagine a rather complex system that is being developed by a startup company that
    only has 10 engineers. They might identify that due to the complexity of the problem
    they are trying to solve, the system would need to be modeled with 10 bounded
    contexts. If they divide all developers into two teams of five, each team can
    handle multiple contexts. The most important aspect here is the ownership of the
    context, so teams should not share contexts. Transferring of the ownership is
    definitely possible, but it should be rare and complete so that after the transfer
    is complete, only one team owns the context.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一个团队可以拥有的上下文数量没有限制。我可以很容易地想象一个由只有10名工程师的初创公司开发的相当复杂的系统。他们可能会发现，由于他们试图解决的问题的复杂性，系统需要用10个边界上下文来建模。如果他们把所有开发人员分成两个五人团队，每个团队可以处理多个上下文。这里最重要的方面是上下文的拥有权，因此团队不应共享上下文。所有权的转让是可能的，但应该是罕见的，并且应该是完整的，以便在转让完成后，只有一个团队拥有该上下文。
- en: The match between bounded contexts and teams can also give an indication of
    how many engineers the company might need. If the core business domain is properly
    identified, most probably all developers will work on the core domain With time
    it might happen that one team is solely engaged with the core business problem
    and another team is doing the work with all the supportive subdomains, such as
    account management, payment processing, and billing. When the complexity of the
    software grows, those supportive subdomains might be transferred to new teams.
    If a new core domain has been identified, some other team needs to take charge.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 边界上下文与团队之间的匹配也可以提供公司可能需要的工程师数量的指示。如果核心业务领域被正确识别，大多数开发人员很可能会在核心领域工作。随着时间的推移，可能会出现一个团队专注于核心业务问题，而另一个团队则处理所有支持性子域的工作，例如账户管理、支付处理和账单。当软件的复杂性增加时，这些支持性子域可能会转移到新的团队。如果已经确定了新的核心领域，其他团队需要负责。
- en: Geography
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理位置
- en: The last point that I would like to make in relation to Conway's law is the
    physical location of teams. It might come as a surprise, but this aspect is very
    important. Nowadays, more and more companies hire remote workers that work from
    home and also keep open offices on different parts of the planet. Keep in mind
    that such a distribution of the workforce, despite getting wider access to talent,
    also brings the burden of communication that is completely different for co-located
    teams and distributed teams.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于康威定律的最后一个要点是团队的物理位置。这可能令人惊讶，但这一方面非常重要。如今，越来越多的公司雇佣远程工作者，他们在家工作，并在地球的不同部分保持开放式办公室。请记住，尽管这种劳动力分布可以更广泛地获取人才，但也带来了与本地团队和分布式团队完全不同的沟通负担。
- en: If one bounded context is given to a team that contains members in different
    countries, or even worse, in different time zones, there will be a high level
    of risk involved. If engineers in such a team are experienced remote workers,
    it might be not a problem at all. But if people in that team are used to working
    in the office and suddenly they are asked to work together with someone that wakes
    up when they plan to go home, it might not work at all. So, it is a good idea
    to keep the geography consolidated if your company doesn't have much experience
    working with a remote workforce.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个边界上下文被分配给一个包含不同国家成员的团队，或者更糟糕的是，在完全不同的时区，将涉及很高的风险。如果这个团队的工程师是经验丰富的远程工作者，可能根本不是问题。但如果这个团队的人习惯在办公室工作，突然被要求与一个在他们计划回家时醒来的人一起工作，可能根本行不通。因此，如果你的公司没有太多与远程员工一起工作的经验，保持地理集中化是一个好主意。
- en: That shouldn't be seen as an obstacle to hire people in other countries and
    let them work remotely. But you might want to have several people that can sit
    in one place or at least live in one town, so they can communicate efficiently,
    meet regularly or even share one office, and call them a team. Such a team can
    easily take ownership of one or more of the bounded contexts of your software.
    The reduced burden of coordination and the high level of autonomy—those benefits
    of clearly defined bounded contexts will most certainly allow making even remote
    teams be much more successful and productive.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这不应该被视为雇佣其他国家人员并让他们远程工作的障碍。但你可能希望有几个人能坐在同一个地方，或者至少住在同一个城镇，这样他们可以高效沟通，定期会面，甚至共享一个办公室，并将他们称为一个团队。这样的团队可以轻松地承担你软件的一个或多个边界上下文的所有权。协调负担的减轻和高度自主性——这些明确定义的边界上下文的益处无疑将使远程团队更加成功和高效。
- en: In fact, I believe that most of the failures that we hear about, when companies
    open remote offices and after some time declare the experience as a failure, are
    related to the fact that these companies weren't able to articulate the work they
    were giving to remote teams as bounded contexts. If teams are working on a shared
    code base, they must coordinate. They may make conflicting changes and all the
    burden and frustration that co-located teams are struggling with is multiplied
    by 10 when the teams are geographically distributed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我相信我们听到的许多失败，当公司在开设远程办公室一段时间后宣布这次经历是失败时，这与这些公司无法将分配给远程团队的工作明确为边界上下文有关。如果团队在一个共享的代码库上工作，他们必须协调。他们可能会做出相互冲突的更改，而当团队地理上分散时，所有这些负担和挫败感都会增加10倍。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we finally started to use the term Bounded Context. It is often
    overlooked by people who started learning DDD. In Eric Evans's book, *Bounded
    Context*, it is explained in the strategic design part, which starts quite late
    in the book. A lot of useful patterns are introduced in that book before getting
    to the concept of Bounded Context and naturally, people start using what they
    know and sometimes find that to be enough.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们终于开始使用“边界上下文”这个术语。对于刚开始学习领域驱动设计（DDD）的人来说，这往往被忽视。在埃里克·埃文斯（Eric Evans）的《边界上下文》一书中，它被解释在战略设计部分，这部分在书中出现得相当晚。在介绍边界上下文概念之前，这本书介绍了许多有用的模式。自然地，人们开始使用他们所知道的东西，有时发现这已经足够了。
- en: But make no mistake, the power of DDD is not in aggregates and repositories.
    If you have a single model for a large, complex software system, having aggregates
    and repositories won't help you. When a large number of developers work with a
    single model, they suffer from an extensive need for coordination, conflicting
    changes, regression bugs, cognitive overload, and constant context switching.
    The fact that contexts aren't articulated properly in such a system doesn't remove
    them from existence. These contexts still exist as long as the business has people
    that are specialized in executing different business functions. Contexts lurk
    in a massive number of lines of code, numerous classes, and database tables that
    contain information about everything that happens. So, context switching is there,
    whether you like it or not.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要误解，DDD（领域驱动设计）的力量并不在于聚合（aggregates）和仓储（repositories）。如果你有一个针对大型、复杂软件系统的单一模型，拥有聚合和仓储并不能帮助你。当大量开发者使用单一模型时，他们会面临广泛的协调需求、冲突的变更、回归错误、认知过载和持续的上下文切换问题。在这样一个系统中，上下文没有得到适当的阐述，但这并不意味着它们不存在。只要业务中有人专门执行不同的业务功能，这些上下文就会存在。上下文隐藏在大量的代码行、众多类和包含关于发生的一切信息的数据库表中。因此，上下文切换是存在的，无论你是否喜欢。
- en: As I first heard from Vaughn Vernon, DDD is a Ubiquitous Language developed
    within a Bounded Context. I like this definition a lot. It brings two of the most
    important principles of DDD into the spotlight. There is nothing more important
    than getting the language right, then finding linguistic boundaries for terms
    that are expressed by the same words but have a different meaning. And that would
    be the first obvious step toward finding the context boundaries.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我第一次从Vaughn Vernon那里听说，DDD（领域驱动设计）是在边界上下文中开发的一种通用语言。我非常喜欢这个定义。它将DDD的两个最重要的原则带到了聚光灯下。没有什么比正确使用语言更重要，然后为具有相同但含义不同的词汇找到语言边界。这将是我们找到上下文边界的第一个明显步骤。
- en: Conway's law is something you must not ignore. If teams aren't structured by
    business capability and function, and instead are specialized by technical responsibility,
    even perfect Bounded Contexts won't help you. Only proper cross-functional teams
    that are organized around functional aspects of the system, that take ownership
    of one or more bounded contexts, will be able to work effectively and successfully.
    That is due to the fact that well-defined context boundaries bring the greatest
    level of autonomy to teams, as soon as no more than one team owns one bounded
    context. That doesn't imply that your organization must have as many teams as
    the number of identified bounded contexts. One team can probably handle more than
    one context, but not the other way around. High alignment and loose coupling are
    not only applicable for classes and services; these principles are fundamental
    for building successful teams that deliver.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 康威定律（Conway's law）是你不能忽视的东西。如果团队不是按照业务能力和功能来组织，而是按照技术责任来专业化，即使完美的边界上下文也无法帮助你。只有围绕系统功能方面组织、负责一个或多个边界上下文、能够有效且成功工作的跨职能团队才能做到这一点。这是因为定义良好的上下文边界为团队带来了最高的自主权，只要不超过一个团队拥有一个边界上下文。这并不意味着你的组织必须有与已识别的边界上下文数量一样多的团队。一个团队可能可以处理多个上下文，但反之则不然。高一致性和松散耦合不仅适用于类和服务；这些原则对于构建能够交付成功的团队是基本的。
- en: Don't forget about the location of your colleagues. Distributed teams could
    work if they consist of people that have experience working remotely. But a remote
    team can take responsibility for one or more bounded contexts since they will
    not require a lot of coordination with other teams.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记你同事的位置。分布式团队如果由有远程工作经验的人组成，是可以工作的。但远程团队可以负责一个或多个边界上下文，因为它们不需要与其他团队进行大量的协调。
