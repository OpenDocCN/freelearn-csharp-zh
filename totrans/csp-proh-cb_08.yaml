- en: Chapter 8. Code Contracts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。代码合约
- en: 'This chapter will introduce you to code contracts. This is a very powerful
    technology and one that will enable you to secure your code from unnecessary errors.
    This is especially true when you are writing a class that is shared between several
    developers. Code contracts allow you to inspect and handle data passed to your
    method under contract. If the contract fails its validation, you can take decisive
    action within your method to handle this eventuality. This chapter will cover
    the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍代码合约。这是一项非常强大的技术，它将使您能够确保您的代码免受不必要的错误。这尤其适用于您正在编写一个由多个开发者共享的类。代码合约允许您检查和处理在合约下传递给您的方法的参数。如果合约验证失败，您可以在您的方
    法中采取果断行动来处理这种情况。本章将涵盖以下步骤：
- en: Downloading, installing, and integrating code contracts into Visual Studio
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载、安装和将代码合约集成到 Visual Studio 中
- en: Creating code contract preconditions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码合约前置条件
- en: Creating code contract postconditions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码合约后置条件
- en: Creating code contract invariant
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码合约不变量
- en: Creating code contract `Assert` and `Assume` methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码合约 `Assert` 和 `Assume` 方法
- en: Creating code contract `ForAll` method
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码合约 `ForAll` 方法
- en: Creating code contract `ValueAtReturn` method
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码合约 `ValueAtReturn` 方法
- en: Creating code contract `Result` method
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码合约 `Result` 方法
- en: Using code contracts on abstract classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在抽象类中使用代码合约
- en: Using contract abbreviator methods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用合约缩写方法
- en: Creating tests using IntelliTest
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IntelliTest 创建测试
- en: Using code contracts in extension methods
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在扩展方法中使用代码合约
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: You might be wondering what code contracts are exactly. To explain it in layman's
    terms, a code contract is a definition that you add to your methods. It tells
    the compilers that the method under contract will always adhere to specific conditions.
    An example of this is that the method will never return a null value to the calling
    code or that the method will always expect a parameter greater than a specific
    value. If any of these conditions are not met, your code can emit an exception,
    and the developer integrating with your class will be prompted to refine their
    calling code. On the flip side, when a developer calls your class, they can be
    sure that the method under contract will always behave in a specific way and never
    deviate from it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道代码合约究竟是什么。为了用通俗易懂的语言解释，代码合约是您添加到您的方法中的定义。它告诉编译器，合约下的方法将始终遵守特定的条件。例如，该方法永远不会向调用代码返回空值，或者该方法将始终期望一个大于特定值的参数。如果任何这些条件未满足，您的代码可以抛出异常，并且与您的类集成的开发者将被提示改进他们的调用代码。另一方面，当开发者调用您的类时，他们可以确信合约下的方法将始终以特定的方式行为，并且永远不会偏离。
- en: Code contracts really stand out when working within a team of developers, but
    implementing this technology in a single-developer solution will only improve
    your code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发团队中工作时，代码合约确实非常突出，但在单开发者解决方案中实现这项技术只会提高你的代码质量。
- en: Downloading, installing, and integrating code contracts into Visual Studio
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载、安装和将代码合约集成到 Visual Studio 中
- en: Before you can use code contracts in your applications, you need to download
    and install them. The easiest way of doing this is via extensions and updates.
    After the installation is complete, you will need to define a few settings for
    the code contracts to start functioning against the code they are implemented
    in. Let's have a look at the following recipe.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以在应用程序中使用代码合约之前，你需要下载并安装它们。最简单的方法是通过扩展和更新来完成。安装完成后，你需要为代码合约定义一些设置，以便它们开始针对其实现的代码进行功能。让我们看看以下步骤。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, we will create a new class and add it to our Visual Studio project. We
    will then get the Code Contracts installer and install it for our project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新类并将其添加到我们的 Visual Studio 项目中。然后，我们将获取代码合约安装程序并为我们的项目安装它。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Create a new class by right-clicking on your solution and selecting **Add**
    and then **New Project** from the context menu:![How to do it…](img/B05391_08_01.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击你的解决方案并从上下文菜单中选择**添加**然后**新建项目**来创建一个新类：![如何操作…](img/B05391_08_01.jpg)
- en: From the **Add New Project** dialog screen, select **Class Library** from the
    installed templates and call your class `Chapter8`:![How to do it…](img/B05391_08_02.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**添加新项目**对话框屏幕中，选择已安装的模板中的**类库**，并将您的类命名为 `Chapter8`：![如何操作…](img/B05391_08_02.jpg)
- en: Your new class library will be added to your solution with a default name of
    `Class1.cs`, which we renamed to `Recipes.cs` in order to distinguish the code
    properly. You can, however, rename your class to whatever you like.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的新类库将以默认名称 `Class1.cs` 添加到你的解决方案中，我们将其重命名为 `Recipes.cs` 以便正确区分代码。然而，你可以将你的类重命名为你喜欢的任何名称。
- en: To rename your class, simply click on the class name in **Solution Explorer**
    and select **Rename** from the context menu:![How to do it…](img/B05391_08_03.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重命名你的类，只需在 **解决方案资源管理器** 中单击类名，并从上下文菜单中选择 **重命名**：![如何操作…](img/B05391_08_03.jpg)
- en: Visual Studio will ask you to confirm a rename of all references to the code
    element **Class1** in the project. Just click on **Yes**:![How to do it…](img/B05391_08_04.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 将要求你确认项目中对代码元素 **Class1** 的所有引用的重命名。只需点击 **是**：![如何操作…](img/B05391_08_04.jpg)
- en: Next, click on the **Tools** menu and select **Extensions and Updates…**:![How
    to do it…](img/B05391_08_05.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击 **工具** 菜单并选择 **扩展和更新…**：![如何操作…](img/B05391_08_05.jpg)
- en: You will see the **Extensions and Updates** window appear. Be sure to click
    on the **Visual Studio Gallery** on the left-hand side and type `Code Contracts`
    as the search term. If you have not got the Code Contracts installer, you will
    see a download button appear on the **Code Contracts for .NET** result. Click
    on it to download and install code contracts:![How to do it…](img/B05391_08_06.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到 **扩展和更新** 窗口出现。务必点击左侧的 **Visual Studio 代码库** 并以 `Code Contracts` 作为搜索词。如果你还没有
    Code Contracts 安装程序，你将在 **Code Contracts for .NET** 结果中看到一个下载按钮。点击它以下载和安装代码合约：![如何操作…](img/B05391_08_06.jpg)
- en: After code contracts have been installed, you might need to restart Visual Studio.
    After doing this, right-click on the `Chapter8` project and select **Properties**
    from the context menu:![How to do it…](img/B05391_08_07.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码合约安装完成后，你可能需要重新启动 Visual Studio。完成此操作后，右键单击 `Chapter8` 项目，并从上下文菜单中选择 **属性**：![如何操作…](img/B05391_08_07.jpg)
- en: You will notice that a new **Code Contracts** tab has been added to the properties
    page for your `Chapter8` project. Click on this tab and make sure that **Perform
    Runtime Contract Checking** is checked. Then, save your changes and close the
    properties page:![How to do it…](img/B05391_08_08.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到，为你的 `Chapter8` 项目属性页添加了一个新的 **代码合约** 选项卡。点击此选项卡，并确保 **执行运行时合约检查** 被勾选。然后，保存你的更改并关闭属性页：![如何操作…](img/B05391_08_08.jpg)
- en: Finally, add a reference to your `Chapter8` project in the console application
    created earlier. Do this by expanding your console application project and right-clicking
    on the **References** item. Select **Add Reference** from the context menu:![How
    to do it…](img/B05391_08_09.jpg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将你的 `Chapter8` 项目引用添加到之前创建的控制台应用程序中。通过展开控制台应用程序项目，右键单击 **引用** 项，并从上下文菜单中选择
    **添加引用**：![如何操作…](img/B05391_08_09.jpg)
- en: Make sure that you have selected `Chapter8` in the project references section
    and click on **OK**:![How to do it…](img/B05391_08_10.jpg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你在项目引用部分已选择 `Chapter8`，然后点击 **确定**：![如何操作…](img/B05391_08_10.jpg)
- en: How it works…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: You have now installed and configured the minimum requirements to enable code
    contracts in your `Chapter8` class. You can now go ahead and build your solution
    to make sure that everything builds successfully.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经安装并配置了最小要求，以在 `Chapter8` 类中启用代码合约。你可以继续构建你的解决方案，以确保一切构建成功。
- en: Creating code contract preconditions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建代码合约预设条件
- en: Preconditions allow you to control exactly what the parameters need to look
    like before they are used in your method. This means that you can assume a lot
    of things about the data being sent to your method by the calling code. You can,
    for example, specify that a parameter should never be null or that a value must
    always be within a specific value range. Dates can be checked, and objects can
    be verified and vetted.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 预设条件允许你在方法中使用参数之前精确控制参数的形状。这意味着你可以假设调用代码发送到你的方法的数据有很多东西。例如，你可以指定一个参数永远不能为空，或者一个值必须始终在特定的值范围内。可以检查日期，并对对象进行验证和审查。
- en: You have complete control over the data coming in to your method. It gives you
    the peace of mind to use that data once it has passed your contract without having
    to do additional checks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你对你的方法传入的数据有完全的控制权。这让你在使用数据时感到安心，一旦它通过了你的合约，就不需要做额外的检查。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Be sure that you have installed code contracts and that you have configured
    the settings correctly in the project properties, as described in the previous
    recipe.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经安装了代码合约，并且已经按照前一个菜谱中描述的项目属性中正确配置了设置。
- en: How to do it…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In your `Recipes` class, create a new method called `ValueGreaterThanZero()`
    and have it take an integer as a parameter:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `Recipes` 类中，创建一个名为 `ValueGreaterThanZero()` 的新方法，并让它接受一个整数作为参数：
- en: '[PRE0]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the `ValueGreaterThanZero()` method, type the start of the `Contract` declaration,
    and you will notice that the code is underlined with a red squiggly line. Hold
    down *Crtl* + *.* (period) to bring up the suggestions for potential fixes. Click
    on the suggestion to add the `using` statement for the code contracts to your
    class:![How to do it…](img/B05391_08_11.jpg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ValueGreaterThanZero()` 方法中，输入 `Contract` 声明的开头，你会注意到代码被一条红色的波浪线下划线。按下 *Crtl*
    + *.*（点）来显示潜在修复的建议。点击建议以将代码合约的 `using` 语句添加到你的类中：![如何操作…](img/B05391_08_11.jpg)
- en: 'When you have done that, continue entering the precondition. Define that the
    parameter value must be greater than zero:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，继续输入先决条件。定义参数值必须大于零：
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you go back to the console application, add the following `using` statements:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你返回到控制台应用程序，添加以下 `using` 语句：
- en: '[PRE2]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since we have created a static class and brought it into scope with the `using`
    statement, you can just call the method name in the `Recipes` class directly.
    To see how code contracts work, pass a zero parameter to the method:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经创建了一个静态类，并通过 `using` 语句将其引入作用域，你可以在 `Recipes` 类中直接调用方法名。为了了解代码合约的工作原理，将零参数传递给方法：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, run your console application and see the exception generated:![How
    to do it…](img/B05391_08_12.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行你的控制台应用程序，查看生成的异常：![如何操作…](img/B05391_08_12.jpg)
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The code contract has inspected the precondition and determined that the parameter
    value passed to the method under contract failed the precondition check. An exception
    is thrown and output to the console window.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码合约检查了先决条件，并确定传递给合约中方法的参数值未通过先决条件检查。抛出异常并输出到控制台窗口。
- en: Creating code contract postconditions
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建代码合约后置条件
- en: Just as code contract preconditions control what information is passed to the
    method under contract, code contract postconditions control what information the
    method under contract returns to the calling code. You can, therefore, specify
    that the method will never return a null value or an empty dataset, for example.
    The actual condition does not matter; this is something that will change on a
    case-by-case basis. The important thing to remember here is that this code contract
    allows you to have more control over the data returned by your code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如代码合约先决条件控制传递给合约中方法的哪些信息一样，代码合约后置条件控制合约中方法返回给调用代码的信息。因此，你可以指定方法永远不会返回空值或空数据集，例如。实际条件并不重要；这是根据具体情况而变化的。这里要记住的重要事情是，这个代码合约允许你对自己的代码返回的数据有更多的控制。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Assume that the method under contract needs to ensure that the value returned
    will always be greater than zero. Using a code contract postcondition, we can
    easily enforce this rule.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设合约中的方法需要确保返回的值始终大于零。使用代码合约后置条件，我们可以轻松地强制执行此规则。
- en: How to do it…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Before you start, make sure that you have added the following `using` statement
    to the top of your `Recipes` class:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始之前，确保你已经将以下 `using` 语句添加到 `Recipes` 类的顶部：
- en: '[PRE4]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the `Recipes` class, add a method called `NeverReturnZero()` and pass an
    integer parameter to this method:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Recipes` 类中添加一个名为 `NeverReturnZero()` 的方法，并将一个整数参数传递给此方法：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside the method, add your postcondition contract. As one could expect, the
    method in the contract class is called `Ensures`. This is quite descriptive of
    its function. The code contract ensures that a specific method result is never
    returned. You can see this in the signature of the `Contract.Ensures` method.
    The postcondition, therefore, ensures that the result of this method will never
    be zero:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法内部，添加你的后置条件合约。正如预期的那样，合约类中的方法被称为 `Ensures`。这非常描述了它的功能。代码合约确保特定的方法结果永远不会返回。你可以在
    `Contract.Ensures` 方法的签名中看到这一点。因此，后置条件确保此方法的结果永远不会为零：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Go back to the console application, and add the following `using` statements:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到控制台应用程序，并添加以下 `using` 语句：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since you have created a static class and brought it into scope with the `using`
    statement, you can just call the method name in the `Recipes` class directly.
    Pass the `NeverReturnZero()` method a value of `1`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你已经创建了一个静态类，并且使用`using`语句将其引入作用域，你只需直接在`Recipes`类中调用方法名。将`NeverReturnZero()`方法传递一个值为`1`的参数：
- en: '[PRE8]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, run your console application and review the output in the console window:![How
    to do it…](img/B05391_08_13.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行你的控制台应用程序，并在控制台窗口中查看输出：![如何操作…](img/B05391_08_13.jpg)
- en: How it works…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When the value of `1` was passed to the method under contract, it resulted in
    a return value of zero being returned. We forced this by subtracting `1` from
    the parameter passed to the method. As the method ensures non-zero values, an
    exception was thrown with the message we defined.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`1`的值传递给合同中的方法时，它导致返回值为零。我们通过从传递给方法的参数中减去`1`来强制这样做。由于该方法确保非零值，因此抛出了我们定义的消息异常。
- en: Creating code contract invariant
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建代码合同不变量
- en: Something that is defined as invariant tells us that it will never change. It
    will always be the same, no matter what. This brings up a vast array of use cases
    if we consider this in the context of code contracts. The invariant code contract
    is basically used to validate the internal state of a class. So, what do we mean
    by the "internal state?" Well, the properties of the class give that class a specific
    state. Let's assume that we wanted to guarantee that the properties of the class
    we are using only accept specific values, thereby assuring the internal state
    of that class. This is where the code contract invariant comes into play.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 被定义为不变量的东西告诉我们它永远不会改变。它始终是相同的，无论发生什么。如果我们从代码合同的角度考虑这一点，这会带来大量的用例。不变量代码合同基本上用于验证类的内部状态。那么，“内部状态”是什么意思呢？嗯，类的属性给这个类一个特定的状态。让我们假设我们想要保证我们使用的类的属性只接受特定的值，从而确保该类的内部状态。这就是代码合同不变量发挥作用的地方。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can understand the use of the invariant better with the use of the following
    example. Assume that the class needs to store dates. We can't ever store a date
    in the past though. Any date used in the class must be a current or future date.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下示例更好地理解不变量的使用。假设该类需要存储日期。尽管如此，我们永远不能存储过去的日期。在类中使用的任何日期都必须是当前或未来的日期。
- en: How to do it…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，请确保你已经将代码合同`using`语句添加到你的`Recipes.cs`类文件顶部：
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we will add a new class called `InvariantClassState` to the `Recipes.cs`
    class file. This is so that we can create an instance class and not a static class:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`Recipes.cs`类文件中添加一个新的类，名为`InvariantClassState`。这样做是为了我们可以创建一个实例类而不是一个静态类：
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following `private` properties to your `InvariantClassState` class
    that will accept integer values for the year, month, and day:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`private`属性添加到你的`InvariantClassState`类中，这些属性将接受年、月和日的整数值：
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will now add a constructor to our `InvariantClassState` class. The constructor
    will accept parameters to set the properties created earlier:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将向我们的`InvariantClassState`类添加一个构造函数。构造函数将接受参数来设置之前创建的属性：
- en: '[PRE12]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you create `public` properties, it is always a good practice to create them
    with `private` setters such as `public int Value { get; private set; }`.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你创建`public`属性，始终是一个好习惯用`private`设置器来创建它们，例如`public int Value { get; private
    set; }`。
- en: The next method we need to add is the contract invariant method. You can call
    this method any name you like, and in this example, it is called `Invariants()`.
    You will read many developers stating that a commonly accepted practice is to
    call this method `ObjectInvariant()`. The naming of this method, however, has
    no impact on the invariant code contract. You will notice that we decorate this
    method with `[ContractInvariantMethod]`, and it is this that defines this method
    (whatever the name) as the invariant code contract. Another important thing to
    remember is that the invariant code contract method must be a `void` method and
    be specified as a `private` method.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加的下一个方法是合同不变量方法。你可以给这个方法起任何你喜欢的名字，在这个例子中，它被命名为`Invariants()`。你会看到许多开发者表示，一个普遍接受的做法是将这个方法命名为`ObjectInvariant()`。然而，这个方法的命名对不变量代码合同没有任何影响。你会注意到我们用`[ContractInvariantMethod]`装饰了这个方法，这就是定义这个方法（无论名字如何）作为不变量代码合同的原因。还有另一件重要的事情需要记住，不变量代码合同方法必须是一个`void`方法，并且被指定为`private`方法。
- en: 'Inside our code contract invariant method, we now specify which properties
    are invariant. In other words, those properties that can never be any other value
    than what we specify inside this code contract invariant method. For starters,
    we will specify that the year value cannot be in the past. We will also ensure
    that the month value is a valid value between `1` and `12`. Finally, we will specify
    that the day value cannot be a value outside the days contained in the month supplied
    or a value less than `1`:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码合同不变性方法内部，我们现在指定哪些属性是不变的。换句话说，那些在这个代码合同不变性方法内部永远不会是其他值的属性。首先，我们将指定年值不能在过去。我们还将确保月值是一个在
    `1` 到 `12` 之间的有效值。最后，我们将指定日值不能是月份包含的天数之外的值或小于 `1` 的值：
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can further extend the `Contract.Invariant` methods by supplying an exception
    message. Your `Invariants()` method will then look like this:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过提供一个异常消息来进一步扩展 `Contract.Invariant` 方法。然后你的 `Invariants()` 方法将看起来像这样：
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, add another method that returns the date formatted as month/day/year:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加另一个方法，该方法返回按月/日/年格式化的日期：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you are finished, your `InvariantClassState` class will look like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成时，你的 `InvariantClassState` 类将看起来像这样：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Head back to the console application and add the following `using` statement
    to your console application `Program.cs` file:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到控制台应用程序，并将以下 `using` 语句添加到你的控制台应用程序 `Program.cs` 文件中：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will now add a new instance of our `InvariantStateClass` class and pass
    the values to the constructor. First, pass the current year less than `1` to the
    constructor. This will result in the last year being passed to the constructor:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加一个新的 `InvariantStateClass` 类实例，并将值传递给构造函数。首先，将小于 `1` 的当前年传递给构造函数。这将导致将上一年传递给构造函数：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running your console application will result in the code contract invariant
    throwing an exception because the year passed to the constructor is in the past:![How
    to do it…](img/B05391_08_14.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的控制台应用程序将导致代码合同不变性抛出异常，因为传递给构造函数的年份是过去的：![如何做…](img/B05391_08_14.jpg)
- en: 'Let''s modify our code by passing a valid year value to the constructor, but
    keep the rest of the parameter values the same:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过将有效的年值传递给构造函数来修改我们的代码，但保持其余的参数值不变：
- en: '[PRE19]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Running the console application will again result in an exception message stating
    that the month value cannot be greater then `12`:![How to do it…](img/B05391_08_15.jpg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序将再次导致一个异常消息，指出月值不能大于 `12`：![如何做…](img/B05391_08_15.jpg)
- en: 'Once again, modify the parameters passed to the method and supply a valid year
    and month value, but pass an invalid day value:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次修改传递给方法的参数，并提供一个有效的年和月值，但传递一个无效的日值：
- en: '[PRE20]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Running the console application again will result in the code contract invariant
    throwing an exception because the day is clearly wrong. No month contains 32 days:![How
    to do it…](img/B05391_08_16.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行控制台应用程序将导致代码合同不变性抛出异常，因为日显然是错误的。没有一个月包含 32 天：![如何做…](img/B05391_08_16.jpg)
- en: 'Modify the parameters passed to the constructor again, and this time, add valid
    values for year, month, and day:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次修改传递给构造函数的参数，这次，为年、月和日添加有效的值：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because November 25, 2016 is a valid date (because the current year is 2016),
    the formatted date is returned to the console application window:![How to do it…](img/B05391_08_17.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为 2016 年 11 月 25 日是一个有效的日期（因为当前年份是 2016 年），所以格式化的日期被返回到控制台应用程序窗口：![如何做…](img/B05391_08_17.jpg)
- en: 'Let''s mix things up a little by passing 29 February, 2017 to the constructor:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们稍微改变一下，将 2017 年 2 月 29 日传递给构造函数：
- en: '[PRE22]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Again, the code contract invariant method throws an exception because 2017 is
    not a leap year:![How to do it…](img/B05391_08_18.jpg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，代码合同不变性方法抛出异常，因为 2017 年不是闰年：![如何做…](img/B05391_08_18.jpg)
- en: How it works…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The code contract invariant method is a simple yet effective way to ensure that
    the state of your class is not modified. You can then assume that the properties
    you use inside your class are always correct and will never contain unexpected
    values. We like to think of the code contract invariant as a type of immutable
    (which it isn't). Strings are immutable, which means that the original value is
    never modified when the value changes. A new space in memory is always created
    when you change the value of a string. Similarly, this reminds me of the properties
    defined as invariant. These property values can never change to values other than
    those defined by our code contract invariant method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代码合同不变量方法是一种简单而有效的方法，以确保你的类状态没有被修改。然后你可以假设你在类内部使用的属性始终是正确的，并且永远不会包含意外的值。我们喜欢将代码合同不变量视为一种不可变类型（尽管它不是）。字符串是不可变的，这意味着当值改变时，原始值永远不会被修改。当你改变字符串的值时，内存中总是会创建一个新的空间。同样，这让我想起了定义为不变量的属性。这些属性值永远不会改变到由我们的代码合同不变量方法定义之外的其他值。
- en: Creating code contract Assert and Assume methods
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建代码合同Assert和Assume方法
- en: The code contract `Assert` and `Assume` methods might seem confusing at first,
    but both provide a specific function. Where the previous code contract conditions
    had to appear at the beginning of the methods they were defined in, the `Assert`
    method can be placed somewhere inside a method. This means that it will have an
    effect on the code at that specific time in the compilation. If you, for example,
    perform a calculation somewhere in your method under contract and you need to
    check the value calculated, you can use `Assert` to perform a check in place to
    ascertain whether the calculated value passes the contract.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 代码合同的`Assert`和`Assume`方法可能一开始看起来有些令人困惑，但它们都提供了特定的功能。之前的代码合同条件必须出现在它们定义的方法的开始部分，而`Assert`方法可以放置在方法内部的任何位置。这意味着它将在编译的特定时间对代码产生影响。例如，如果你在合同下的方法中某处执行计算并需要检查计算出的值，你可以使用`Assert`在原地执行检查以确认计算值是否通过合同。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't confuse `Debug.Assert` with `Contract.Assert`. They aren't the same thing.
    `Debug.Assert` will only have an effect if your code is run in the **Debug** mode.
    `Contract.Assert` will run in the **Debug** and **Release** modes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆`Debug.Assert`与`Contract.Assert`。它们不是同一回事。`Debug.Assert`只有在你的代码以**调试**模式运行时才会产生影响。`Contract.Assert`将在**调试**和**发布**模式下运行。
- en: With `Contract.Assume`, however, we are telling the code contract that it needs
    to assume that the condition it needs to check is true. This is only applicable
    when the static checker is switched on, and this will become clearer in this recipe.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`Contract.Assume`，我们正在告诉代码合同，它需要假设它需要检查的条件是真实的。这仅适用于静态检查器已开启时，这一点将在本食谱中变得更加清晰。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the same method under contract to illustrate the use of `Assert`
    and `Assume` methods with the static checker switched on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的合同方法来展示在静态检查器开启时使用`Assert`和`Assume`方法。
- en: How to do it…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，请确保你已经将代码合同`using`语句添加到你的`Recipes.cs`类文件顶部：
- en: '[PRE23]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add a method called `ValueIsValid()` to the class, which accepts two integer
    parameters:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加一个名为`ValueIsValid()`的方法，它接受两个整数参数：
- en: '[PRE24]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To this method, add a calculation (it appears first in the method before the
    contract) that subtracts `1` from the `valueForCalc` parameter. The `Contract.Assert`
    method is placed after the calculation to check the value of the calculated value.
    We want to ensure that the value is not zero:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此方法中，添加一个计算步骤（它出现在方法中合同之前），从`valueForCalc`参数中减去`1`。将`Contract.Assert`方法放置在计算之后，以检查计算值的值。我们希望确保该值不为零：
- en: '[PRE25]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the static class into scope:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，将相关的`using`语句添加到`Program.cs`类中，以便将静态类引入作用域：
- en: '[PRE26]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Call the `ValueIsValid()` method by passing two integer values to it. As you
    can see, the first parameter will result in a zero value being calculated inside
    the method under contract:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递两个整数值调用`ValueIsValid()`方法。正如你所见，第一个参数将在合同下的方法内部计算出零值：
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run your console application and inspect the output window. We can see that
    the `Assert` contract correctly threw an exception because the calculated value
    was zero:![How to do it…](img/B05391_08_19.jpg)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的控制台应用程序并检查输出窗口。我们可以看到`Assert`合约正确地抛出了异常，因为计算出的值是零：![如何操作…](img/B05391_08_19.jpg)
- en: However, what if we want our code to be checked when we build our application?
    This is where the static checker comes into play. Right-click on the `Chapter8`
    project and select **Properties**:![How to do it…](img/B05391_08_20.jpg)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果我们想在构建应用程序时检查我们的代码呢？这就是静态检查器发挥作用的地方。右键单击`Chapter8`项目并选择**属性**：![如何操作…](img/B05391_08_20.jpg)
- en: Click on the **Code Contracts** tab and select the checkbox next to **Perform
    Static Contract Checking**. Also, uncheck the **Check in background** box and
    select **Fail build on warnings**. Moreover, set **Warning Level** to **hi**:![How
    to do it…](img/B05391_08_21.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**代码合约**选项卡，并选中**执行静态合约检查**旁边的复选框。同时，取消选中**在后台检查**复选框，并选择**警告时失败构建**。此外，将**警告级别**设置为**高**：![如何操作…](img/B05391_08_21.jpg)
- en: Note
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We assume that the developers of Code Contracts meant to make the warning level
    between low and high. "Hi" is probably a typo in the code.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们假设Code Contracts的开发者本意是在低和高之间设置警告级别。“Hi”可能是代码中的误拼。
- en: Save your code contract settings and run your console application. You will
    notice that your build fails:![How to do it…](img/B05391_08_22.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的代码合约设置并运行您的控制台应用程序。您会注意到您的构建失败：![如何操作…](img/B05391_08_22.jpg)
- en: If we have a look at the `ValueIsValid()` method, we can see that the static
    checker has identified that the method under contract needs an additional contract
    defined. The static checker has identified that we need to add `Contract.Requires`
    to our method to check whether the `valueForCalc` parameter is greater than zero:![How
    to do it…](img/B05391_08_23.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看`ValueIsValid()`方法，我们可以看到静态检查器已经识别出在合约下的方法需要定义一个额外的合约。静态检查器已经识别出我们需要在我们的方法中添加`Contract.Requires`来检查`valueForCalc`参数是否大于零：![如何操作…](img/B05391_08_23.jpg)
- en: 'If we had to correct this, we would add `Contract.Requires` to the method as
    follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们必须纠正这一点，我们将在方法中添加`Contract.Requires`，如下所示：
- en: '[PRE28]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For now, let''s ignore the recommendation of the static checker and, instead,
    add `Contract.Assume` to our method. Here, we are telling the static checker to
    assume that the value will never be zero after the calculation is done on the
    `valueForCalc` parameter:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们忽略静态检查器的建议，而是将`Contract.Assume`添加到我们的方法中。在这里，我们正在告诉静态检查器假设在`valueForCalc`参数的计算完成后，该值永远不会为零：
- en: '[PRE29]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If we run our console application again, we will get a clean build, because
    the static checker assumes that you know best and that the value will never equal
    zero after the calculation. If, however, the calculated value turns out to be
    zero, `Assume` still checks the value at runtime and will throw an exception if
    the value equals zero:![How to do it…](img/B05391_08_24.jpg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们再次运行我们的控制台应用程序，我们将得到一个干净的构建，因为静态检查器假设您最了解情况，并且计算后的值永远不会等于零。然而，如果计算出的值实际上是零，`Assume`仍然会在运行时检查该值，如果值等于零，则会抛出异常：![如何操作…](img/B05391_08_24.jpg)
- en: How it works…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: You might be wondering what the use of `Assume` in code contracts is. As it
    turns out, this is quite useful when working with code that you have no control
    over. If you implement code that you can't edit or that does not contain code
    contracts, you can tell the static checker to ignore specific portions of the
    code that produce errors based on the check it does.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道代码合约中`Assume`的使用目的。实际上，当您处理无法控制的代码时，这非常有用。如果您实现了无法编辑或不含代码合约的代码，您可以告诉静态检查器忽略基于检查产生的错误的具体代码部分。
- en: Creating code contract ForAll method
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建代码合约ForAll方法
- en: If this code contract sounds like it is validating some or the other collection,
    then you would be correct. The code contract `ForAll` will perform validation
    of `IEnumerable` collections. This is very handy, because as a developer, you
    do not need to do any kind of iteration over the collection and writing validation
    logic. This contract does it for you.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个代码合约听起来像是在验证某些或其他的集合，那么您就是正确的。代码合约`ForAll`将对`IEnumerable`集合执行验证。这对于开发者来说非常方便，因为您不需要对集合进行任何类型的迭代，也不需要编写验证逻辑。这个合约为您完成了这一切。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a simple list of integers and populate the list with values.
    Our code contract will validate that the list does not contain any zero values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的整数列表，并用值填充该列表。我们的代码契约将验证列表中不包含任何零值。
- en: How to do it…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，确保你已经将代码契约的`using`语句添加到你的`Recipes.cs`类文件顶部：
- en: '[PRE30]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add a method called `ValidateList()` to your class and pass a `List<int>` collection
    to it:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的类中添加一个名为`ValidateList()`的方法，并将一个`List<int>`集合传递给它：
- en: '[PRE31]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Inside the `ValidateList()` method, add the `Contract.ForAll` contract. Interestingly,
    you will notice that we are using `Contract.Assert` here to check whether this
    list passes our contract conditions. The `Contract.ForAll` will use a lambda expression
    to check that none of the values contained in our list of integers equals zero:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ValidateList()`方法内部，添加`Contract.ForAll`契约。有趣的是，你会注意到我们在这里使用`Contract.Assert`来检查这个列表是否通过我们的契约条件。`Contract.ForAll`将使用lambda表达式来检查我们整数列表中的任何值都不等于零：
- en: '[PRE32]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the static class into scope:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，将相关的`using`语句添加到`Program.cs`类中，以便将静态类引入作用域：
- en: '[PRE33]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can then add a simple list of integers containing at least one zero value
    and pass it to the `ValidateList()` method:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以添加一个包含至少一个零值的简单整数列表，并将其传递给`ValidateList()`方法：
- en: '[PRE34]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Run the console application and inspect the results in the output:![How to do
    it…](img/B05391_08_25.jpg)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并在输出中检查结果：![如何做…](img/B05391_08_25.jpg)
- en: How it works…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We can see that the `ForAll` contract has worked exactly as we had expected.
    This is an extremely useful code contract to use, especially since you need not
    add copious amounts of boilerplate code to check the collection for various invalid
    values.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`ForAll`契约正好按我们预期的那样工作。这是一个极其有用的代码契约，特别是当你不需要添加大量的样板代码来检查集合中的各种无效值时。
- en: Creating code contract ValueAtReturn method
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建代码契约ValueAtReturn方法
- en: The best example we can think of when using the code contract `ValueAtReturn`
    is `out` parameters. Personally, I do not use `out` parameters often, but there
    are times when you need to use them. Code contracts make provision for this, and
    you can check the value at the time it is returned.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用代码契约`ValueAtReturn`时，我们能想到的最好例子是`out`参数。我个人并不经常使用`out`参数，但有时你需要使用它们。代码契约为此提供了支持，你可以在返回时检查值。
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a simple method that subtracts a value from a parameter. The
    `out` parameter will be validated by the code contract, and the result will be
    output to the console window.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的方法，从参数中减去一个值。`out`参数将由代码契约验证，并将结果输出到控制台窗口。
- en: How to do it…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，确保你已经将代码契约的`using`语句添加到你的`Recipes.cs`类文件顶部：
- en: '[PRE35]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `Recipes` class, create a new method called `ValidOutValue()` and pass
    an `out` parameter called `secureValue` to it:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Recipes`类中，创建一个新的方法`ValidOutValue()`，并传递一个名为`secureValue`的`out`参数：
- en: '[PRE36]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, add `Contract.ValueAtReturn` to the method. Interestingly, you will
    note that this needs to be contained in `Contract.Ensures`. This actually makes
    sense, because the code contract ensures that the value that we will return will
    adhere to a specific condition:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`Contract.ValueAtReturn`添加到方法中。有趣的是，你会发现这需要包含在`Contract.Ensures`中。这实际上是有道理的，因为代码契约确保我们将返回的值将符合特定的条件：
- en: '[PRE37]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the static class into scope:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，将相关的`using`语句添加到`Program.cs`类中，以便将静态类引入作用域：
- en: '[PRE38]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, add some code to call the `ValidOutValue()` method and pass an `out`
    parameter to it:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加一些代码来调用`ValidOutValue()`方法，并将一个`out`参数传递给它：
- en: '[PRE39]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run the console application and inspect the results in the output window:![How
    to do it…](img/B05391_08_26.jpg)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并在输出窗口中检查结果：![如何做…](img/B05391_08_26.jpg)
- en: How it works…
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We can see that the `out` parameter has been successfully validated. As soon
    as the condition was not met, the code contract threw an exception that we were
    able to catch.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`out`参数已经成功验证。一旦条件不满足，代码契约抛出了我们能够捕获的异常。
- en: Creating code contract Result method
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建代码契约Result方法
- en: Sometimes, we simply want a way to validate the result of a method. We want
    to be able to check what is returned and validate it against some or the other
    condition. It is here that the code contract `Result` can be used. It will inspect
    the value returned by the method under contract against the contract specified,
    and then it will succeed or fail.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们只是想有一种方式来验证方法的结果。我们希望能够检查返回的内容，并对其进行验证。正是在这里，代码契约`Result`可以派上用场。它将检查契约下方法返回的值与指定的契约，然后成功或失败。
- en: How to do it…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，请确保你已经将代码契约`using`语句添加到你的`Recipes.cs`类文件顶部：
- en: '[PRE40]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `Recipes` class, add a new method called `ValidateResult()` that takes
    two integer values as parameters:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Recipes`类中，添加一个名为`ValidateResult()`的新方法，该方法接受两个整数作为参数：
- en: '[PRE41]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To this method, add the code contract `Result` that checks the resultant value
    of the method. It has to be mentioned that the code contract `Result` can never
    be used in a `void` method. This is obvious, because the very purpose of this
    code contract is to examine and validate the result of a method. You will also
    notice that the code contract `Result` method is used in conjunction with the
    `Contract.Ensures` method. The format of `Contract.Result` is made up of the return
    type `<int>()` and the condition `>= 0` that the return value needs to adhere
    to:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向此方法添加检查方法结果的代码契约`Result`。必须指出的是，代码契约`Result`永远不能在`void`方法中使用。这是显而易见的，因为这种代码契约的目的是检查和验证方法的结果。你还会注意到，代码契约`Result`方法与`Contract.Ensures`方法一起使用。`Contract.Result`的格式由返回类型`<int>()`和需要遵守的条件`>=
    0`组成：
- en: '[PRE42]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the static class into scope:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，将相关的`using`语句添加到`Program.cs`类中，以便将静态类引入作用域：
- en: '[PRE43]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the call to the static method under contract and pass to it parameters
    that will cause the code contract to throw an exception. In this case, we are
    passing `10` and `23`, which will result in a negative result being returned from
    the `ValidateResult()` method:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在契约下的静态方法中添加调用，并传递将导致代码契约抛出异常的参数。在这种情况下，我们传递了`10`和`23`，这将导致`ValidateResult()`方法返回一个负数：
- en: '[PRE44]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Finally, run the console application and inspect the result returned to the
    console output window:![How to do it…](img/B05391_08_27.jpg)
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行控制台应用程序，检查返回到控制台输出窗口的结果：![如何操作…](img/B05391_08_27.jpg)
- en: How it works…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: You will see that the code contract has inspected the resultant value of the
    `ValidateResult()` method and found that it contravenes the contract. An exception
    is then thrown and displayed in the console window.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到代码契约检查了`ValidateResult()`方法的返回值，并发现它违反了契约。随后，将抛出异常并在控制台窗口中显示。
- en: Using code contracts on abstract classes
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在抽象类上使用代码契约
- en: If you use abstract classes in your code, you will know that being able to control
    how they are used with code contracts will result in more robust code. But how
    exactly can we use code contracts with abstract classes? Especially since abstract
    classes are supposed to contain no implementation? Well, it is definitely possible,
    and here is how we do it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在代码中使用抽象类，你会知道能够通过代码契约来控制它们的使用，这将导致代码更加健壮。但究竟我们如何使用代码契约与抽象类结合呢？特别是既然抽象类不应该包含任何实现？好吧，这绝对可能，下面就是如何做到这一点的方法。
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you have not worked with abstract classes before, we advise you to first
    read [Chapter 2](ch02.html "Chapter 2. Classes and Generics"), *Classes and Generics*,
    to familiarise yourself with how abstract classes are used and created.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过抽象类，我们建议你首先阅读[第2章](ch02.html "第2章。类和泛型")，*类和泛型*，以熟悉如何使用和创建抽象类。
- en: How to do it…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，请确保你已经将代码契约`using`语句添加到你的`Recipes.cs`类文件顶部：
- en: '[PRE45]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create an abstract class called `Shape` that defines two methods called `Length()`
    and `Width()` which each take an integer value as a parameter. Remember that abstract
    classes contain no implementation:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Shape`的抽象类，它定义了两个方法，分别称为`Length()`和`Width()`，每个方法都接受一个整数作为参数。记住，抽象类不包含任何实现：
- en: '[PRE46]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create another abstract class called `ShapeContract` that inherits the `Shape`
    abstract class. It is here that our code contracts will reside:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为 `ShapeContract` 的抽象类，它继承自 `Shape` 抽象类。我们的代码合同将驻留在这里：
- en: '[PRE47]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Override the `Length()` and `Width()` methods of the `Shape` abstract class
    and ensure that they require a non-zero parameter:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `Shape` 抽象类的 `Length()` 和 `Width()` 方法，并确保它们需要一个非零参数：
- en: '[PRE48]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We now need to associate the `ShapeContract` contract class to the `Shape`
    abstract class. We will do this via the use of attributes. Add the following attribute
    to the top of your `Shape` abstract class:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要将 `ShapeContract` 合同类与 `Shape` 抽象类关联起来。我们将通过使用属性来完成此操作。在你的 `Shape` 抽象类顶部添加以下属性：
- en: '[PRE49]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After doing this, your `Shape` abstract class will look like this:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，你的 `Shape` 抽象类将看起来像这样：
- en: '[PRE50]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We also need to associate the `Shape` abstract class to the `ShapeContract`
    abstract class as a means of telling the compiler which class the contracts need
    to act upon. We will do this by adding the following attribute to the top of the
    `ShapeContract` class:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将 `Shape` 抽象类与 `ShapeContract` 抽象类关联起来，作为告诉编译器合同需要作用于哪个类的手段。我们将通过在 `ShapeContract`
    类顶部添加以下属性来完成此操作：
- en: '[PRE51]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When you have done this, your `ShapeContract` class will look like this:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成这些操作后，你的 `ShapeContract` 类将看起来像这样：
- en: '[PRE52]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We are now ready to implement the `Shape` abstract class. Create a new class
    called `Rectangle` and inherit the `Shape` abstract class:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备好实现 `Shape` 抽象类。创建一个名为 `Rectangle` 的新类，并继承 `Shape` 抽象类：
- en: '[PRE53]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You will notice that Visual Studio underlines the `Rectangle` class with a red
    squiggly line. This is because no implementation of the `Shape` class exists yet.
    Hover your mouse cursor over the red squiggly line and look at the lightbulb pop-up
    suggestion provided by Visual Studio:![How to do it…](img/B05391_08_28.jpg)
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到 Visual Studio 用红色波浪线下划线标记了 `Rectangle` 类。这是因为还没有实现 `Shape` 类。将鼠标光标悬停在红色波浪线上，查看
    Visual Studio 提供的灯泡弹出建议：![如何操作…](img/B05391_08_28.jpg)
- en: By holding down *Ctrl* + *.* (period), you will see the suggested fixes that
    you can implement to correct the error that Visual Studio is warning you about.
    In this instance, there is only a single fix that Visual Studio suggests we implement,
    which is to implement the abstract class:![How to do it…](img/B05391_08_29.jpg)
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按住 *Ctrl* + *.*（句号），你会看到可以实施的建议修复，以纠正 Visual Studio 警告你的错误。在这种情况下，Visual Studio
    建议我们实施的单个修复是实现抽象类：![如何操作…](img/B05391_08_29.jpg)
- en: After you have clicked on the **Implement Abstract Class** suggestion in the
    lightbulb suggestion, Visual Studio will insert the implementation of the `Shape`
    abstract class. You will notice that the methods inserted for you still don't
    contain any implementation and will throw `NotImplementedException` if you don't
    add any implementation to the `Length()` and `Width()` methods:![How to do it…](img/B05391_08_30.jpg)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击灯泡建议中的**实现抽象类**建议后，Visual Studio 将插入 `Shape` 抽象类的实现。你会注意到为你插入的方法仍然没有任何实现，如果你没有为
    `Length()` 和 `Width()` 方法添加任何实现，它们将抛出 `NotImplementedException`：![如何操作…](img/B05391_08_30.jpg)
- en: 'To add implementation to our `Rectangle` class, create two properties for the
    `Length()` and `Width()` methods and set these properties equal to the value of
    the supplied parameter value:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为我们的 `Rectangle` 类添加实现，为 `Length()` 和 `Width()` 方法创建两个属性，并将这些属性设置为提供的参数值的值：
- en: '[PRE54]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the `Chapter8` class into scope:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，向 `Program.cs` 类添加相关的 `using` 语句，以便将 `Chapter8` 类引入作用域：
- en: '[PRE55]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a new instance of the `Rectangle` class and pass some values to the
    `Length()` and `Width()` methods of the `Rectangle` class:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Rectangle` 类的新实例，并将一些值传递给 `Rectangle` 类的 `Length()` 和 `Width()` 方法：
- en: '[PRE56]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Finally, run the console application and inspect the output window:![How to
    do it…](img/B05391_08_31.jpg)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行控制台应用程序并检查输出窗口：![如何操作…](img/B05391_08_31.jpg)
- en: How it works…
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As we have added a zero value to the `Length()` method, the code contract on
    the abstract class has correctly thrown an exception. Being able to implement
    code contracts on abstract classes allows developers to create better code, especially
    when working in teams where you need to convey implementation limitations based
    on certain business rules.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 `Length()` 方法中添加了一个零值，抽象类上的代码合同已正确地抛出了异常。能够在抽象类上实现代码合同允许开发者创建更好的代码，尤其是在团队工作中，你需要根据某些业务规则传达实现限制时。
- en: Using contract abbreviator methods
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用契约缩写方法
- en: Abbreviator methods are a great addition to the features of code contracts.
    They allow us to create a single abbreviator method that contains often used or
    grouped code contracts. This means that we can simplify our code and make it more
    readable.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写方法是代码契约功能的一个很好的补充。它们允许我们创建一个包含常用或分组代码契约的单个缩写方法。这意味着我们可以简化我们的代码并使其更易于阅读。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create two methods with the same code contract requirements. We will
    then simplify the methods under contract by implementing an abbreviator method
    to contain the code contracts.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个具有相同代码契约要求的方法。然后，通过实现一个缩写方法来包含代码契约，我们将简化契约下的方法。
- en: How to do it…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，请确保您已将代码契约 `using` 语句添加到您的 `Recipes.cs` 类文件顶部：
- en: '[PRE57]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Consider the following methods before you add them. We have two methods here,
    and each method requires that the parameter passed to it is not equal to zero
    and that the result is also not zero. The implementation within each method is
    different, but the code contracts applied are identical. To avoid a situation
    where code contracts are unnecessarily repeated, we can use abbreviator methods:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加以下方法之前请考虑。这里有两个方法，每个方法都需要传入的参数不等于零，并且结果也不为零。每个方法内部实现不同，但应用的代码契约是相同的。为了避免代码契约不必要地重复，我们可以使用缩写方法：
- en: '[PRE58]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Add a new method called `StandardMethodContract()` to your `Recipes` class.
    This method''s name can be anything you like, but the signature needs to match
    the methods it abbreviates. Inside this method, add the required code contracts
    defined earlier in `MethodOne()` and `MethodTwo()`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `Recipes` 类中添加一个名为 `StandardMethodContract()` 的新方法。此方法的名字可以是任何您喜欢的，但签名需要与缩写的方法匹配。在此方法内部，添加之前在
    `MethodOne()` 和 `MethodTwo()` 中定义的所需代码契约：
- en: '[PRE59]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add the following attribute to the top of the `StandardMethodContract()` method
    to identify it as an abbreviator method:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到 `StandardMethodContract()` 方法的顶部，以将其标识为缩写方法：
- en: '[PRE60]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once you have done this, your abbreviator method should look like this:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，您的缩写方法应如下所示：
- en: '[PRE61]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can now go ahead and simplify `MethodOne()` and `MethodTwo()` by simply
    referencing the abbreviator method in place of the code contracts:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以通过在代码契约的位置引用缩写方法来简化 `MethodOne()` 和 `MethodTwo()`：
- en: '[PRE62]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the static class into scope:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，将相关的 `using` 语句添加到 `Program.cs` 类中，以便将静态类引入作用域：
- en: '[PRE63]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'First, call the two methods using the following parameters:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下参数调用两个方法：
- en: '[PRE64]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you run your console application, you will notice that the code contract
    throws an exception in the abbreviator contract, telling us that the supplied
    parameter can't be zero:![How to do it…](img/B05391_08_32.jpg)
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行您的控制台应用程序，您将注意到代码契约在缩写契约中抛出异常，告诉我们提供的参数不能为零：![如何操作…](img/B05391_08_32.jpg)
- en: 'Then, modify your calling code and pass a valid value for `MethodOne()`, but
    leave the call to `MethodTwo()` as is. Run your console application again:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，修改您的调用代码，为 `MethodOne()` 传递一个有效值，但保持对 `MethodTwo()` 的调用不变。再次运行您的控制台应用程序：
- en: '[PRE65]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This time, you will see that the code contract in the abbreviator method throws
    an exception on the return value that can't be zero:![How to do it…](img/B05391_08_33.jpg)
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，您将看到缩写方法中的代码契约在返回值不能为零的情况下抛出异常：![如何操作…](img/B05391_08_33.jpg)
- en: How it works…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Abbreviator methods allow us to create more readable code and to group often
    used code contracts in a common method decorated with the `[ContractAbbreviator]`
    attribute. Abbreviator methods are a powerful feature of code contracts that developers
    can utilize to produce better code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写方法允许我们创建更易于阅读的代码，并将常用代码契约分组在带有 `[ContractAbbreviator]` 特性的公共方法中。缩写方法是代码契约的一个强大功能，开发人员可以利用它来生成更好的代码。
- en: Creating tests using IntelliTest
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IntelliTest 创建测试
- en: IntelliTest allows developers to create and run tests against their code contracts.
    This allows developers to create the most robust code possible by creating additional
    code contracts to pass the test failures reported by IntelliTest. One thing to
    note, however, is that IntelliTest is included in the Visual Studio Enterprise
    only.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliTest 允许开发者创建和运行针对其代码合同的测试。这允许开发者通过创建额外的代码合同来通过 IntelliTest 报告的测试失败，从而创建最健壮的代码。但需要注意的是，IntelliTest
    仅包含在 Visual Studio Enterprise 中。
- en: Getting ready
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to use Visual Studio Enterprise 2015 to be able to create and
    run IntelliTests.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用 Visual Studio Enterprise 2015 来创建和运行 IntelliTests。
- en: How to do it…
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，请确保您已将代码合同 `using` 语句添加到 `Recipes.cs` 类文件顶部：
- en: '[PRE66]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Add a new class called `CodeContractTests` to your `Recipes.cs` file:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `Recipes.cs` 文件中添加一个名为 `CodeContractTests` 的新类：
- en: '[PRE67]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, add a method called `Calculate()` to the `CodeContractTests` class and
    pass two integer values as parameters to the `Calculate()` method. Inside the
    `Calculate()` method, add a code contract to ensure that the result from this
    method is never equal to zero:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `CodeContractTests` 类中添加一个名为 `Calculate()` 的方法，并将两个整数值作为参数传递给 `Calculate()`
    方法。在 `Calculate()` 方法内部，添加一个代码合同以确保该方法的结果永远不会等于零：
- en: '[PRE68]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Select the `Calculate()` method and right-click on it. From the context menu,
    click on the **Create IntelliTest** menu item:![How to do it…](img/B05391_08_34.jpg)
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Calculate()` 方法并右键单击它。从上下文菜单中，点击 **创建 IntelliTest** 菜单项：![如何操作…](img/B05391_08_34.jpg)
- en: Visual Studio will then show the **Create IntelliTest** window. Here, you can
    define several settings for your IntelliTest. One thing to note is that you can
    use a different test framework than **MSTest**. For our purposes, however, we
    will use **MSTest** and keep the rest of the settings set to their defaults:![How
    to do it…](img/B05391_08_35.jpg)
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 将显示 **创建 IntelliTest** 窗口。在这里，您可以定义您的 IntelliTest 的几个设置。需要注意的是，您可以使用与
    **MSTest** 不同的测试框架。然而，出于我们的目的，我们将使用 **MSTest** 并将其他设置保留为默认值：![如何操作…](img/B05391_08_35.jpg)
- en: When you click on the **OK** button, Visual Studio will continue to create a
    new test project for you:![How to do it…](img/B05391_08_36.jpg)
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您点击 **确定** 按钮时，Visual Studio 将继续为您创建一个新的测试项目：![如何操作…](img/B05391_08_36.jpg)
- en: When the project creation is complete, you will see the new test project created
    in the **Solution Explorer**. In this case, because we kept the default settings
    in the **Create IntelliTest** window, our new test project will be called `Chapter8.Tests`:![How
    to do it…](img/B05391_08_37.jpg)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当项目创建完成后，您将在 **解决方案资源管理器** 中看到创建的新测试项目。在本例中，因为我们保留了 **创建 IntelliTest** 窗口中的默认设置，所以我们的新测试项目将被称为
    `Chapter8.Tests`：![如何操作…](img/B05391_08_37.jpg)
- en: 'Go ahead and expand the `Chapter8.Tests` project and then click on the `CodeContractTestsTest.cs`
    file created for you. You will see the following code created for you by Visual
    Studio:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续展开 `Chapter8.Tests` 项目，然后点击为您创建的 `CodeContractTestsTest.cs` 文件。您将看到 Visual
    Studio 为您创建的以下代码：
- en: '[PRE69]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Back in the `CodeContractTests` class, right-click on the `Calculate()` method
    and select **Run IntelliTest** from the context menu:![How to do it…](img/B05391_08_38.jpg)
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CodeContractTests` 类中，右键单击 `Calculate()` 方法并从上下文菜单中选择 **运行 IntelliTest**：![如何操作…](img/B05391_08_38.jpg)
- en: IntelliTest will jump into action and open the **IntelliTest Exploration Results**
    window:![How to do it…](img/B05391_08_39.jpg)
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IntelliTest 将立即开始工作并打开 **IntelliTest 探索结果** 窗口：![如何操作…](img/B05391_08_39.jpg)
- en: From the test results we ran for the `Calculate()` method, we can see that we
    have three failed tests and one successful test. The test failures reported are
    `DivideByZeroException`, `ContractException`, and `OverflowException`. Clicking
    on individual test failures allows you to view the test details as well as the
    **Stack trace**:![How to do it…](img/B05391_08_40.jpg)
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们对 `Calculate()` 方法运行的测试结果中，我们可以看到有三个失败的测试和一个成功的测试。报告的测试失败是 `DivideByZeroException`、`ContractException`
    和 `OverflowException`。点击单个测试失败可以查看测试详情以及 **堆栈跟踪**：![如何操作…](img/B05391_08_40.jpg)
- en: 'Let''s modify the `Calculate()` method by adding the following additional code
    contracts:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过添加以下额外的代码合同来修改 `Calculate()` 方法：
- en: '[PRE70]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: From the additional code contracts, we can see that by requiring the `valueTwo`
    parameter to be greater than zero, we have resolved the `DivideByZeroException`.
    We can also see that the code contract that requires `valueOne` is always greater
    than `valueTwo`. Thus, we have resolved the `ContractException`. Finally, by requiring
    that both parameters be greater than zero, we have automatically resolved the
    `OverflowException`:![How to do it…](img/B05391_08_41.jpg)
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从附加的代码约定中，我们可以看到，通过要求`valueTwo`参数大于零，我们已经解决了`DivideByZeroException`。我们还可以看到，要求`valueOne`总是大于`valueTwo`的代码约定已经解决了`ContractException`。最后，通过要求两个参数都大于零，我们自动解决了`OverflowException`：![如何做……](img/B05391_08_41.jpg)
- en: Right-click on the `Calculate()` method and run the IntelliTest again. This
    time, you will see that all the tests have passed, and our method under contract
    is now ready for use in production code:![How to do it…](img/B05391_08_42.jpg)
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`Calculate()`方法并再次运行IntelliTest。这次，你会看到所有测试都通过了，我们受合同约束的方法现在可以用于生产代码：![如何做……](img/B05391_08_42.jpg)
- en: How it works…
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: IntelliTest allows developers to quickly and efficiently create tests for your
    code contracts with a few clicks of your mouse.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliTest允许开发者通过几点击鼠标快速高效地为你的代码约定创建测试。
- en: Using code contracts in extension methods
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在扩展方法中使用代码约定
- en: The previous recipes illustrated how a developer might create various code contracts
    to secure your code from unexpected input and output, but let's look at how a
    developer could leverage code contracts. The idea of extension methods come to
    mind, where we create code that can be used throughout your project to perform
    actions that are often used.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的菜谱展示了开发者如何创建各种代码约定来保护你的代码免受意外输入和输出的影响，但让我们看看开发者如何利用代码约定。扩展方法的想法浮现在脑海中，其中我们创建可以在整个项目中使用以执行常用操作的代码。
- en: Let's use the code contract `ForAll` method. This has an impact on a collection,
    so naturally, its use in extension methods leads us to a possible implementation.
    In this recipe, we will create an extension method that uses a code contract to
    validate the list we have just created.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用代码约定`ForAll`方法。这会影响一个集合，因此自然地，它在扩展方法中的使用引导我们到一个可能的实现。在这个菜谱中，我们将创建一个使用代码约定来验证我们刚刚创建的列表的扩展方法。
- en: Getting ready
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a static class for our extension method and then use the `ForAll`
    code contract to validate the `List` collection.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个用于扩展方法的静态类，然后使用`ForAll`代码约定来验证`List`集合。
- en: How to do it…
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'Before you go on, ensure that you have added the code contracts `using` statement
    to the top of your `Recipes.cs` class file:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你继续之前，确保你已经将代码约定`using`语句添加到你的`Recipes.cs`类文件顶部：
- en: '[PRE71]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create a new static class called `ExtensionMethods` and add it to your `Recipes.cs`
    class file:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ExtensionMethods`的新静态类并将其添加到`Recipes.cs`类文件中：
- en: '[PRE72]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, add an extension method called `ContainsInvalidValue()` that takes the
    given list of anonymous type `T` and an invalid value to check as type `T` as
    parameters:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为`ContainsInvalidValue()`的扩展方法，它接受一个匿名类型`T`的给定列表和一个要检查的类型为`T`的无效值作为参数：
- en: '[PRE73]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Inside our extension method, add code contract `ForAll` wrapped in a `try`
    `catch` statement that checks the existence of the given parameter in the list:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的扩展方法内部，添加一个包裹在`try` `catch`语句中的代码约定`ForAll`，该语句检查给定参数是否在列表中存在：
- en: '[PRE74]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Once you have added all the code to your extension method, it should look like
    this:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你将所有代码添加到你的扩展方法中，它应该看起来像这样：
- en: '[PRE75]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the console application, add the relevant `using` statement to the `Program.cs`
    class to bring the `Chapter8` class into scope:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，将相关的`using`语句添加到`Program.cs`类中，以便将`Chapter8`类引入作用域：
- en: '[PRE76]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As we did earlier, create a simple list, but this time, call the extension
    method that is exposed via the static extension methods class on the list. We
    will now be able to directly validate our list via the use of extension methods
    and code contracts:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们之前所做的那样，创建一个简单的列表，但这次，调用通过静态扩展方法类在列表上公开的扩展方法。现在，我们将能够通过使用扩展方法和代码约定直接验证我们的列表：
- en: '[PRE77]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Running the application will result in the following output:![How to do it…](img/B05391_08_43.jpg)
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序将产生以下输出：![如何做……](img/B05391_08_43.jpg)
- en: 'As we are using an anonymous type here, we can easily call this extension method
    on lists containing different types. Here is an example of an implementation on
    a list of strings:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在这里使用匿名类型，我们可以轻松地在包含不同类型的列表上调用这个扩展方法。以下是一个在字符串列表上的实现示例：
- en: '[PRE78]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Running the application again will result in the following output:![How to do
    it…](img/B05391_08_44.jpg)
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行应用程序将产生以下输出：![如何操作…](img/B05391_08_44.jpg)
- en: How it works…
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We can see that using code contracts along with other powerful features of C#
    allows us to utilize very powerful code checking and validation techniques. The
    extension methods can be used throughout your project to perform frequent validation
    or other code logic specific to your project.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，使用代码约定以及C#的其他强大功能，我们可以利用非常强大的代码检查和验证技术。扩展方法可以在整个项目中使用，以执行频繁的验证或针对您项目的特定代码逻辑。
