- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing Applications with Middleware in ASP.NET Core 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core 9 offers a robust and flexible framework designed to handle high-demand
    web applications. A key component of this framework is middleware, which allows
    developers to interact directly with the request and response pipeline. Understanding
    and leveraging middleware can significantly enhance your application’s capabilities.
    This chapter will dive deep into middleware, exploring its structure, implementation,
    and practical applications, such as global error handling, request limiting, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the middleware pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with factory-based middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding capabilities to applications using middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an extension method for middleware registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will explore essential best practices for developing applications
    with ASP.NET Core 9, covering the correct use of asynchronous mechanisms, HTTP
    requests, and application instrumentation through logs.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To support the learning of this chapter, the following tools must be present
    in your development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker** : The Docker engine must be installed on your operating system and
    have an SQL Server container running. You can find more details about Docker and
    SQL Server containers in [*Chapter 5*](B21788_05.xhtml#_idTextAnchor078) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postman** : This tool will be used to execute requests to APIs of the developed
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redis Insight** : This tool is used to connect to a Redis Server database
    ( [https://redis.io/insight/](https://redis.io/insight/) ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code examples used in this chapter can be found in the book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter08](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the middleware pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the previous chapters, we used several features of ASP.NET Core 9, including
    middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware is a pipeline model used during the execution flow of an ASP.NET
    Core 9 web application to handle requests and responses, and the applications
    developed in this book already use some standard middleware from the .NET platform,
    such as **Authentication** , **Authorization** , **Cross-Origin Resource Sharing**
    ( **CORS** ), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ASP.NET Core request pipeline consists of a sequence of request delegates,
    called one after the other. *Figure 8* *.1* demonstrates the concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – ASP.NET Core 9 middleware pipeline](img/B21788_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – ASP.NET Core 9 middleware pipeline
  prefs: []
  type: TYPE_NORMAL
- en: Request delegates are configured using the **Run** , **Map** , and **Use** extension
    methods typically configured in the **Program.cs** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each extension method has a template for registering a request delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Run** : The **app.Run** method is used to define an inline middleware that
    handles the request and completes the response, as in the following example code
    that implements an inline middleware:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Map** : The **app.Map** method is used to create a branch in the middleware
    pipeline. In the following code, requests to **/SomeRoute** are handled by this
    middleware branch. The middleware in the branch writes a message to the response:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Use** : The **app.Use** method is used to add middleware to the pipeline.
    The following code uses a middleware to log the request method and path before
    calling the next middleware in the pipeline. After the next middleware completes,
    it logs the response status code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The use of middleware brings constant benefits to applications; we will understand
    in greater detail the use of different approaches, such as the creation of middleware
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn about how the middleware execution flow works.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding middleware flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the application receives a request, it goes through each middleware component
    in the order they are registered, and the following cases can be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process the request and pass it to the next piece of middleware** : It’s
    like a relay race where each runner passes the baton to the next. Each piece of
    middleware does its part and then calls the next one in line to continue processing
    the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process the request and break the chain, preventing other middleware from
    running** : Imagine a security checkpoint at an airport. If security finds a problem,
    they may stop you for additional checks, preventing you from proceeding. Likewise,
    the middleware may decide to handle the request completely and stop further processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process the response as it moves up the chain** : This is like sending a
    package through multiple stages of inspection. Once the package reaches the final
    stage, it is inspected again at each stage on the way back, ensuring that everything
    is in order before being delivered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The layered approach allows for powerful and flexible handling of HTTP requests
    and responses. Middleware can be used for a variety of tasks, such as logging,
    authentication, error handling, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the order in which you register middleware is crucial, as it defines
    the flow of the request and response pipeline. We can see a representation of
    the middleware execution flow in *Figure 8* *.2* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Middleware execution flow](img/B21788_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Middleware execution flow
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the flow works in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request arrival** : When a request arrives at the server, it enters the pipeline
    and reaches the first middleware component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middleware execution** : Each middleware can do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modify the request** : Middleware can change aspects of the request, such
    as adding headers or changing the request path'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Move to next middleware** : After processing, the middleware can call the
    next middleware in the pipeline using **await next** , which we’ll discuss in
    the *Implementing custom* *middleware* section'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Short-circuiting the pipeline** : The middleware may decide not to call the
    next middleware, effectively ending request processing early'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Response handling** : When the request reaches the end of the pipeline, the
    response goes back through the middleware components in reverse order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modifying the response** : The middleware can change the response, such as
    adding headers, changing the status code, or logging information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware order
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 has, by default, some middleware available to handle requests
    and responses. However, the order in which this middleware is inserted completely
    changes the application’s execution flow and, in some cases, can cause malfunctions.
    For example, it is important to add middleware authentication before middleware
    authorization; otherwise, how can you validate authorization without being authenticated?
  prefs: []
  type: TYPE_NORMAL
- en: In any case, in addition to standard middleware, there is an order of execution
    for customized middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about middleware order, see the following link: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#middleware-order](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#middleware-order)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: By working on the middleware execution flow, we have the ability to add several
    powerful possibilities to our applications, and we will learn some more benefits
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of middleware and best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Middleware plays a key role in ASP.NET Core 9 applications, offering a number
    of benefits that contribute to the robustness, maintainability, and extensibility
    of your application. Understanding these benefits allows you to use this resource
    effectively, so let’s look at this in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity** : Modularity means that middleware is an independent unit of
    functionality that can be easily added, removed, or replaced without affecting
    the rest of the application. This modularity allows developers to create reusable
    middleware components that can be shared between different projects or in different
    parts of the same project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition** : Middleware can be composed in multiple orders to achieve
    different behaviors. This compositional nature allows you to tailor the request
    and response pipeline to the specific needs of your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s say you have three middleware components: one for logging, one for authentication,
    and one for handling errors. You can compose these middleware components in the
    desired order:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see in the preceding code, the **app.UseMiddleware** method adds
    middleware to handle errors, authentication, and logging in the application. The
    **app.Run** method just creates a standard request response, returning a **Hello**
    **World** message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is important to consider the following factors:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to rearrange the order of these middleware components, the way requests
    are processed and errors are handled will be different.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SoC (Separation of concerns)** : Middleware allows for a clear separation
    of different concerns, enabling the definition of a clear execution context in
    a pipeline and facilitating a clearer, extensible, and maintainable code base.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensibility** : You can develop a custom middleware to extend the application’s
    functionality – for example, by adding validation capabilities to requests or
    modifying responses globally within the application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose you need custom middleware to validate an API key in request headers.
    You can create this middleware as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code aims to create a customized middleware that checks the existence
    of an API key that must be provided in the header of a request, where the header
    key is **X-API-KEY** and the expected value is, exactly, **XYZ123** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When performing validation, if the header and value are not part of the request,
    then the user receives an **unauthorized** return message with HTTP status code
    **401** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In fact, middleware is a powerful feature that allows you to have greater control
    over the flow of requests and responses in an application developed in ASP.NET
    Core 9.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry about the details related to the preceding code examples. We will
    learn about the structure of a middleware class in the *Implementing custom* *middleware*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the great benefits of applications using middleware, it is important
    to be aware of good practices; otherwise, what could be a benefit could become
    a major problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Order matters** : The order in which middleware components are added is crucial
    as it affects how requests and responses are processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep it simple** : Middleware should do one thing and do it well. Complex
    logic should be avoided in middleware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling** : Make sure your middleware components handle exceptions
    and errors in the same way as other classes in your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance** : Be aware of the impact of middleware on performance, especially
    in high-load scenarios. As it operates in request and response processes, avoid
    large amounts of processing during these stages to avoid causing problems for
    users and the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reuse existing middleware** : Use built-in middleware whenever possible to
    reduce the need for custom implementations. As we have already learned, there
    is some middleware available in ASP.NET Core 9.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the principles, benefits, and best practices of middleware,
    let’s implement our first custom middleware and learn the details of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom middleware allows you to encapsulate functionality and reuse it in different
    parts of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating custom middleware in ASP.NET Core 9 involves several steps, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Middleware class definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of the **Invoke** or **InvokeAsync** method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware registration in the request pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s analyze the following code, which represents a customized middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This custom middleware code aims to just write a string to the console at the
    beginning and in the response of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is important to understand the structure of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RequestDelegate** : This is a delegate that represents the next middleware
    in the pipeline. This delegate is stored in a field called **_next** for use in
    the context of the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructor** : The class constructor receives an instance of the **RequestDelegate**
    class as a parameter, representing the next middleware in the execution flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invoke** or **InvokeAsync** method: Contains the logic for processing HTTP
    requests. The difference between the methods is that one is executed asynchronously
    and the other is not. The **InvokeAsync** method receives an **HttpContext** object
    as a parameter. The **HttpContext** object allows you to access request and response
    information. It is a good practice to use the **InvokeAsync** method to improve
    performance and scalability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**await _next(context)** : Execution of the **_next** delegate, which receives
    the **HttpContext** object as a parameter. In this example, we are just writing
    a string containing request information before propagating the execution of the
    next middleware, and then another string is written with response information
    after executing the middleware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection (DI) in middleware
  prefs: []
  type: TYPE_NORMAL
- en: Custom middleware classes must use the **Explicit Dependencies Principle** (
    **EDP** ), as we have already learned in previous chapters, where the dependencies
    of a class are defined in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: As middleware is built during application initialization, it is not possible
    to inject services added to a scoped lifetime as is done with each request in
    a **Controller** class, for example.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you want to use any services available in DI control in a middleware
    class, add these services to the signature of the **InvokeAsync** method, which
    can accept additional parameters resolved by DI.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code example, although simple, demonstrates the basic structure
    of a middleware, which requires a **RequestDelegated** field, a constructor that
    depends on an instance of **RequestDelegated** , and the implementation of the
    **Invoke** or **InvokeAsync** method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the customized middleware to be used in the application, it is necessary
    to register it in the ASP.NET Core 9 execution pipeline through the **Program.cs**
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code has been shortened to make it easier to read and learn. For
    the middleware to be registered, the **UseMiddleware** extension method is used,
    which is a generic method, where we define the previously executed custom middleware
    as the type.
  prefs: []
  type: TYPE_NORMAL
- en: During the application startup flow, all custom or non-customized middleware
    is created, forming part of the application lifecycle, and not by request, as
    is generally done in scoped services. This behavior prevents other dependencies
    from being added to the constructor of a custom middleware class but allows the
    addition of dependencies with parameters through the **Invoke** and **InvokeAsync**
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining HTTP context objects in middleware
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative to using DI in the **InvokeAsync** method, it is possible
    to use the **context.RequestService** property ( [https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.requestservices?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.requestservices?view=aspnetcore-9.0)
    ), as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**public async Task** **InvokeAsync(HttpContext context)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**var logger =** **context.RequestServices**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.** **GetRequiredService<Ilogger**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<** **BeforeAfterRequestMiddleware >>();**'
  prefs: []
  type: TYPE_NORMAL
- en: '**logger.LogInformation($"Request:{context.Request.Method}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{** **context.Request.Path}");**'
  prefs: []
  type: TYPE_NORMAL
- en: '**await _next(context);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**logger.LogInformation($"Response:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{** **context.Response.StatusCode}");**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: However, this somewhat decreases dependency visibility in code.
  prefs: []
  type: TYPE_NORMAL
- en: However, ASP.NET Core 9 offers an approach to enabling the use of custom middleware
    on a per-request basis using factory-based middleware, which we will discuss in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with factory-based middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to create custom middleware is by using the factory-based approach,
    which offers better performance and flexibility using DI.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is particularly useful when the middleware requires scoped services.
  prefs: []
  type: TYPE_NORMAL
- en: Factory-based middleware uses the **IMiddleware** interface, which allows the
    middleware to be activated by the **DI** **container** ( **DIC** ).
  prefs: []
  type: TYPE_NORMAL
- en: The **IMiddleware** interface has only one **InvokeAsync** method that must
    be implemented in the class. The structure of a customized middleware that uses
    the factory-based approach is very similar to the traditional approach learned
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The big difference with the factory-based approach is the definition of a dependency
    in the class constructor instead of declaring it as a parameter in the **InvokeAsync**
    method. In the preceding code example, the constructor has a dependency on an
    **ILogger** interface.
  prefs: []
  type: TYPE_NORMAL
- en: The **InvokeAsync** method must only have two parameters, **HttpContext** and
    **RequestDelegate** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at custom middleware registration, using the factory-based
    approach, by analyzing the **Program.cs** class code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Middleware registration is done using the **app.UseMiddleware** method, as we
    have already learned. However, note that the **RequestLimitingMiddleware** class
    is added to the scoped lifetime through the **builder.Services.AddScoped<RequestLimitingMiddleware>()**
    code with the lifecycle managed per request.
  prefs: []
  type: TYPE_NORMAL
- en: Service lifetimes
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 offers different types of service lifetimes; you can learn more
    at [https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#service-lifetimes](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#service-lifetimes)
    .
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the factory-based approach allows us to use DIC resources and
    manage the middleware lifecycle by request.
  prefs: []
  type: TYPE_NORMAL
- en: Whether to use a factory-based or the traditional approach depends, of course,
    on the application requirements. However, both are powerful solutions that add
    precious features to our applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will create and use some common middleware used in many
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Adding capabilities to applications using middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have knowledge about the features and possibilities of middleware,
    we will work on some capabilities that will bring greater quality to our web applications.
  prefs: []
  type: TYPE_NORMAL
- en: There is no strict standard directory structure or namespace for creating middleware
    classes. However, it is good practice to organize classes into well-defined namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will default to creating a folder called **Middlewares**
    in the root of your application project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will focus on the following middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: Global error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding request logging – logging request information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting – defining request limits in your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project containing the classes mentioned in the preceding list is available
    in the book repository, the link to which can be found in the *Technical* *requirements*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new application. Open the terminal, and in a folder of your
    choice, create a project with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Then, in the root of the directory, create a folder called **Middlewares** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will start creating the first middleware: global error handling.'
  prefs: []
  type: TYPE_NORMAL
- en: Global error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the execution flow of an application, errors or exceptions may arise
    that, if not handled correctly, may cause inconvenience to users.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we must handle errors in our code to prevent exceptions from causing
    applications to malfunction.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, a good practice is to use a global error-handling middleware
    that makes it possible to manage the application’s exception flow in a centralized
    manner, even allowing it to extend its functionality by adding logs in different
    monitoring tools, which is essential for error corrections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called **ErrorHandlingMiddleware.cs** in the **Middlewares**
    folder you created earlier and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding code the common structure of a middleware. The great
    functionality of this global error-handling middleware is the use of the **try**
    / **catch** block, in the body of the **InvokeAsync** method.
  prefs: []
  type: TYPE_NORMAL
- en: The **await _next(context)** command is executed in a **try** block so that
    if there is an exception in the application, it will be handled globally. Exception
    handling is done through the **HandleExceptionAsync** method, called in the **catch**
    block.
  prefs: []
  type: TYPE_NORMAL
- en: The **HandleExceptionAsync** method modifies the request response by changing
    the **StatusCode** property to Internal Server Error, **HTTP status code 500**
    , in addition to returning an object in the request body. This object is represented
    by the **ErrorDetails** class, which has the **StatusCode** and Message properties.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in addition to guaranteeing the handling of any exception in the
    application, there is a customized, but common, return that can be used appropriately
    for handling in a UI, allowing a better experience for the developers and also
    for the users of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Problems Details in ASP.NET Core 9
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 provides built-in support for Problem Details, a standardized
    format for error responses based on RFC 7807 (https://datatracker.ietf.org/doc/html/rfc7807).
    By incorporating Trace ID into the response, developers can enhance debugging
    and error tracking.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Problem Details response with a Trace ID looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"** **type": "https://example.com/probs/server-error",**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"title": "An unexpected** **error occurred.",**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"** **status": 500,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"detail": "The system encountered** **an issue.",**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"** **instance": "/example-path",**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"** **traceId": "00-abcdef1234567890abcdef1234567890-1234567890abcdef-01"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **ProblemDetails** class can be used in conjunction with the Middleware
    following the following implementation example, changing the **HandleExceptionAsync**
    method of the **ErrorHandlingMiddleware** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**private static Task HandleExceptionAsync(HttpContext context,** **Exception
    exception)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**var traceId = Activity.Current?.Id ??** **context.TraceIdentifier;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**var problemDetails =** **new ProblemDetails**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type = "** **server-error",**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Title = "An unexpected** **error occurred.",**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Status =** **StatusCodes.Status500InternalServerError,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Detail = “Internal Server Error from the** **custom middleware.”,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instance =** **context.Request.Path**'
  prefs: []
  type: TYPE_NORMAL
- en: '**};**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// Include the Trace ID in the** **Problem Details.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**problemDetails.Extensions["traceId"] =** **traceId;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**context.Response.ContentType = "** **application/problem+json";**'
  prefs: []
  type: TYPE_NORMAL
- en: '**context.Response.StatusCode =** **StatusCodes.Status500InternalServerError;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**return context.Response.WriteAsJsonAsync(problemDetails);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code is a customization of the Global Error Handler implemented
    through Middleware. In addition to using the **ProblemDetails** class, code is
    added to obtain the trace id value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**var traceId = Activity.Current?.Id ??** **context.TraceIdentifier;**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the trace ID is added to the extensions of the object ProblemdDetails>:'
  prefs: []
  type: TYPE_NORMAL
- en: '**problemDetails.Extensions["traceId"] =** **traceId;**'
  prefs: []
  type: TYPE_NORMAL
- en: The trace ID is excellent information that should be part of the application
    Log, facilitating the correlation between error responses to resolve issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core 9 also has alternatives for error handling that you can learn
    more about at the following URL: [https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors?view=aspnetcore-9.0)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Using global error handling brings an excellent benefit to applications, and,
    in addition, some log writing strategies could be used in cloud monitoring tools,
    in the terminal, or even in files, facilitating problem resolution.
  prefs: []
  type: TYPE_NORMAL
- en: The log functionality can be used for other purposes, not just to handle errors.
    Let’s analyze another middleware approach for logging requests.
  prefs: []
  type: TYPE_NORMAL
- en: Adding request logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every web application has a constant flow of communication and processing of
    requests that generate different types of information, as well as exceptions that
    must be handled, and we took care of this scenario when creating global error-handling
    middleware in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to handling errors and exceptions, we must log this information
    to be able to carry out effective troubleshooting. However, in many cases, it
    is necessary to log information processed during the request and response flow
    of an application. This approach offers several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Centralized logging** : Centralize logging logic, ensuring all requests are
    logged consistently in a single location in the pipeline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request tracking** : The ability to trace all requests is useful for monitoring
    application performance, debugging issues, and understanding user behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and auditing** : By logging requests, you can maintain an audit
    trail of access to your application, which is essential for security compliance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error diagnosis** : When problems arise, logs can help you diagnose and troubleshoot
    problems by providing a detailed history of the request activity that led to an
    error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance monitoring** : Logging the time it takes to process requests
    can help identify performance bottlenecks and optimize application performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility** : The middleware can be configured to log only certain types
    of requests or responses, providing flexibility in how logging is implemented'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at an example of middleware responsible for logging request data
    into the application. To do this, create a class called **PerformanceLoggingMiddleware.cs**
    in the **Middlewares** folder and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code aims to record the execution time of a request. This is an
    interesting approach to measuring the limits of your application and allowing
    you to improve the performance of your implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When analyzing the code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DI** : The **InvokeAsync** method accepts an **ILogger<PerformanceLoggingMiddleware>**
    parameter, which is provided by DI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log request metrics** : The **InvokeAsync** method uses the **ILogger** instance
    to log the HTTP method, request path, and time taken to process the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collecting the request execution time** : Before executing the request, use
    the **GetTimestamp()** static method of the **Stopwatch** object to get the initial
    timestamp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After executing the request through the **_await _next(context)** request delegation,
    the **Stop** method of the **Stopwatch** object is used to end the timer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A log is then created containing information about the request, such as the
    method, path, and execution time in milliseconds, obtained from the **Stopwatch**
    class throughout the **GetElapsedTime(timestamp).TotalMilliseconds** method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Stopwatch class
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Stopwatch** class in .NET is a high-resolution timer provided by the
    **System.Diagnostics** namespace. It is used to measure elapsed time with great
    precision, making it ideal for performance measurement and benchmarking tasks.
    Get more information about the features available in **Stopwatch** through the
    documentation: [https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.stopwatch?view=net-9.0](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.stopwatch?view=net-9.0)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see when implementing customized logs such as **PerformanceLoggingMiddleware**
    , creating customized middleware enhances the functionalities of our applications,
    helping both the experience of users who consume quality applications and supporting
    teams in maintenance processes, diagnostics, and also application evolution.
  prefs: []
  type: TYPE_NORMAL
- en: However, ASP.NET Core 9 provides some middleware capable of dealing with several
    other important aspects of an application’s execution flow, such as rate limiting,
    which we will understand in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rate-limiting middleware in ASP.NET Core 9 is a powerful feature that is
    essential for protecting applications from abuse and improving overall performance
    and reliability. This middleware controls the number of requests a client can
    make to a server within a specified period of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the rate-limiting middleware in ASP.NET Core 9 is done by adding the
    configuration in the **Program.cs** file. The following is a step-by-step guide:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the required NuGet packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the middleware in the HTTP request pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add rate-limiting middleware to the pipeline. Rate-limiting middleware is included
    in **Microsoft.AspNetCore.RateLimiting** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s see an example of implementation in a Razor Pages-type application using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s analyze the important aspects of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**builder.Services.AddRateLimiter** : Required to define the rate limit policies
    that will be used in this application. Each policy uses a unique client identifier,
    adding the **X-Forwarded-For** HTTP header, to enforce limits per client IP address.
    In the previous code, we configured three policies – namely, the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fixed window** : Limits requests to 5 per minute. Once the limit is reached,
    no further requests will be allowed until the window is reset.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sliding window** : Similar to the fixed window policy, but divides the window
    into segments, allowing for a more distributed request margin per minute.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Token bucket** : Allows you to make up to 10 tokens (requests) available,
    with 5 new tokens replenished every 10 seconds. If tokens run out, incoming requests
    will be queued.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**app.UseRateLimiter()** : This line adds the rate-limiting middleware to the
    request pipeline, enabling the configured rate-limiting policies to take effect.
    Unlike the traditional way of adding middleware where the **UseMiddleware<>**
    method is used, rate limiting has an exclusive extension method. We will learn
    how to create extension methods to add middleware in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rate limiting is an important feature that should be considered when developing
    ASP.NET Core 9 applications, bringing some benefits such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overload protection** : Prevents the server from being overloaded by too
    many requests, ensuring stable performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fair use** : Ensures that no client can monopolize server resources, promoting
    equitable access for all users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security:** Mitigates certain types of attacks, such as **Distributed Denial-of-Service**
    ( **DDoS** ) attacks, by limiting the rate at which clients can make requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved user experience** : By preventing server overload, rate limiting
    helps maintain consistent response times and service availability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning more about rate-limiting middleware
  prefs: []
  type: TYPE_NORMAL
- en: 'Rate limiting has several other features that can add to your strategy for
    using this middleware. See the documentation for more details: [https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit?view=aspnetcore-9.0)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to rate-limiting middleware, ASP.NET Core 9 offers different other
    middleware that are widely used in different types of applications, such as authentication
    and authorization middleware, discussed in [*Chapter 6*](B21788_06.xhtml#_idTextAnchor093)
    . Depending on your application requirements, you can combine the capabilities
    of middleware to create powerful, high-quality solutions that run in modern environments.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 built-in middleware
  prefs: []
  type: TYPE_NORMAL
- en: 'Consult the documentation to analyze the different middleware available on
    the ASP.NET Core 9 platform at the following URL: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#built-in–middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-9.0#built-in-middleware)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created customized middleware and learned how to use the rate-limiting
    middleware available in ASP.NET Core 9, it is time to learn a good practice for
    registering middleware using extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an extension method for middleware registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the exception of middleware built into ASP.NET Core 9, which have their
    respective extension methods for registration in the HTTP pipeline, each custom
    middleware must be registered using extension methods, such as **UseMiddleware<>**
    , already used in several code examples from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, the addition of different middleware to the **Program.cs** file can
    create complexity in reading and maintaining these resources in the application.
  prefs: []
  type: TYPE_NORMAL
- en: A good practice is to create extension methods in order to centralize the registration
    of middleware and have the benefit of abstracting the complexity of configuring
    these mechanisms, in addition to centralizing responsibilities appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an extension method to centralize the configurations of the previously
    created middleware. To do this, in the **Middlewares** folder, create a new class
    called **CommonMiddlewareExtension.cs** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code contains all the rate-limiting middleware settings, in addition
    to the use of global error-handling and request performance measurement middleware.
  prefs: []
  type: TYPE_NORMAL
- en: This extension method class exposes two **AddCustomRateLimiting** methods, responsible
    for adding the rate-limiting policies, and the **UseCommonApplicationMiddleware**
    method, responsible for adding the previously created custom middleware and the
    rate-limiting middleware to the HTTP pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the class, we will change the **Program.cs** file, which will
    have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the highlighted code, the **Program.cs** class uses the previously
    created extension methods, making it more readable and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The extension method approach is a good practice for grouping a set of configurations
    in your application flow in order to correctly separate responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Use these features in your web application deployment flow with ASP.NET Core
    9 and combine different middleware to create more powerful applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters of the book, we will cover other different techniques to
    further add possibilities to your ASP.NET Core 9 applications, such as secure
    configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use the power of middleware to customize
    the execution flow of ASP.NET Core 9 applications, understanding how the middleware
    pipeline works. In addition, we learned how to implement custom middleware, work
    with factory-based middleware, and add capabilities to applications by working
    with global error handling approaches, information logging, and request limit
    settings. In the next chapter, we will explore how to manage application configurations
    securely.
  prefs: []
  type: TYPE_NORMAL
