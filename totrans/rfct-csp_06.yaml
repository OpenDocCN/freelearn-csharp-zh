- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first part of this book, we covered the process of refactoring and some
    of the more common refactoring techniques. Now, it’s time for us to take a step
    back and remind ourselves of what refactoring is: *refactoring is the process
    of changing the form or shape of the code without changing how* *it behaves*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, we can make our code as clean and easy to maintain as we can,
    but if those changes introduce bugs, that’s not refactoring since refactoring
    is about changing the form of code *without changing its behavior*. To improve
    our code without introducing bugs, we need a safety net: **unit testing**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll explore unit tests and cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding testing and unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing code with xUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring other testing frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopting a testing mindset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter06/Ch6BeginningCode` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding testing and unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever I was managing or mentoring another developer and they wanted to make
    a change to a system I’d ask them a question: *“How can you be sure your change
    won’t* *break things?”*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple question can be deceptively hard to answer, but every answer I’ve
    ever heard boils down to a single concept: testing.'
  prefs: []
  type: TYPE_NORMAL
- en: I define **testing** as *the process of verifying software functionality and
    detecting unwanted changes to* *program behavior*.
  prefs: []
  type: TYPE_NORMAL
- en: This testing could be done by a human, such as a developer or a quality assurance
    analyst, or it could be done via software, depending on the type of test involved.
  prefs: []
  type: TYPE_NORMAL
- en: Types of tests and the testing pyramid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing is a broad field that encompasses many different types of activities,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manual testing**, which involves a person performing some activity manually
    and verifying the outcome.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exploratory testing**, a subset of manual testing that focuses on exploring
    how the system reacts to things to find new types of bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit tests**, in which small parts of the software system are tested in isolation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component tests**, where larger components of the system are tested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration tests**, which involve two components, such as an API and a database,
    that are tested together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end tests**, in which entire paths through the system are tested.
    This usually involves multiple sets of components interacting in sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these activities are automated tests where computer code interacts with
    the system to verify its behavior. We’ll talk more about what factors make up
    good tests at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Automated tests do have some drawbacks. First, automated tests take time to
    create. Typically, a human must write code or use some tool to script out the
    test. Secondly, these tests often require ongoing maintenance as the software
    system changes to stay relevant. Finally, these tests can offer a false sense
    of security. For example, let’s say a developer wrote a test to navigate to the
    “book a flight” web page and verify that open seats display as available. This
    test may pass even if the web page has obvious errors and misalignments on it,
    simply because the test was only coded to check a small part of the web page.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, human testers are intelligent. They have free agency and
    initiative and can make objective judgments about software that machines cannot.
    They can find issues that nobody ever thought of writing a test for, and they
    can provide valuable feedback about the functionality of your products. However,
    people are usually a lot slower than automated tests and it may take some time
    for a quality assurance analyst to test a feature once it is ready for testing.
  prefs: []
  type: TYPE_NORMAL
- en: There are strengths and weaknesses when it comes to both automated and manual
    tests. One is not better than the other; instead, they combine to make for an
    effective solution to quality issues in software projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'A popular concept in software quality is the idea of a **testing pyramid**.
    A testing pyramid shows the various types of tests an organization might perform.
    Additionally, as shown in *Figure 6**.1*, the width of each segment of the pyramid
    indicates the quantity of that type of test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – An example of a testing pyramid](img/B21324_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – An example of a testing pyramid
  prefs: []
  type: TYPE_NORMAL
- en: In a testing pyramid, such as this one, the items at the base should be the
    most numerous and the items at the top of the pyramid should be the rarest. Almost
    every diagram of a testing pyramid is different in the exact types of tests listed
    in the pyramid, but all of them agree that the most common form of testing should
    be the unit test and the least common should be manual testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many organizations get this wrong early in their software development maturity.
    When that happens, they have a lot of manual tests, few unit tests, and typically
    no end-to-end, integration, or component tests. As a result, the pyramid would
    look a little like *Figure 6**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Testing pyramid with many manual tests, few unit tests, and
    no other tests](img/B21324_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Testing pyramid with many manual tests, few unit tests, and no
    other tests
  prefs: []
  type: TYPE_NORMAL
- en: This pyramid *should* look ridiculous because having very little test automation
    is almost always a recipe for slow processes, delayed releases, and software bugs
    reaching production environments!
  prefs: []
  type: TYPE_NORMAL
- en: The larger your system becomes, the less feasible manual testing will be and
    the longer it will take to discover bugs manually.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this is **automated testing**, particularly automated unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit tests are small methods of code that test other methods in your system
    to verify those methods perform correctly given a specific scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '*More succinctly, unit tests are code that tests* *other code*.'
  prefs: []
  type: TYPE_NORMAL
- en: Already familiar with tests?
  prefs: []
  type: TYPE_NORMAL
- en: You may already be familiar with unit tests if you work with unit tests regularly.
    If that’s true, you may want to skim the rest of this chapter and resume with
    the next one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the idea of unit testing, let’s look at a simple method that
    generates a flight status message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'While this method is very simple, let’s think about the steps we’d need to
    take to verify it works correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate the `Flight` class and store that object in a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a pair of string variables representing `id` and `status`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `BuildMessage` method on our flight object from *Step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the result of *Step 3* in a new string variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the string we just stored matched what we expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is essentially what a unit test would do. It would instantiate your class,
    *arrange* the variables it needs, *act* on the method the unit test is trying
    to verify, and finally *assert* that the result of the method matched what we
    expected. We call this pattern the **arrange/act/assert** pattern and we’ll discuss
    it more later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help illustrate this concept, here’s a sample test for the `BuildMessage`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry about the specific syntax here as we’ll get into this shortly. For
    now, understand that the `GeneratedMessageShouldBeCorrect` method is an example
    of a unit test that tests a small unit of code to verify a specific piece of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, this method verifies that the `Flight` class’s `BuildMessage`
    method calculates and returns an accurate status message given the `id` and `status`
    parameters it receives.
  prefs: []
  type: TYPE_NORMAL
- en: 'This test can be run quickly alongside all the other tests in the solution
    and will either pass if the `BuildMessage` method is acting as expected or will
    fail if the result of `BuildMessage` ever changes, as shown in *Figure 6**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – A failing unit test](img/B21324_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – A failing unit test
  prefs: []
  type: TYPE_NORMAL
- en: Test failures such as this are helpful because they highlight bugs that developers
    might otherwise release into production without the failing test flagging the
    potential issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we’ll explore unit tests more by introducing the most
    popular unit testing framework: **xUnit**.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing code with xUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: xUnit.net, commonly referred to as xUnit, is currently the most popular unit
    testing library in .NET, followed by `Attributes` that you can use to identify
    your test code, as we’ll see shortly. Using these attributes lets a test runner,
    such as Visual Studio’s **Test Explorer**, recognize your methods as unit tests
    and run them.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter’s code starts with most of the classes from the chapters up to
    this point, organized into various namespaces inside of the `Chapter6` `Chapter6BeginningCode`
    **solution**.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions and projects
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, a project represents a distinct assembly of .NET code that accomplishes
    some purpose. Different projects have different types, from desktop applications
    to web servers to class libraries and test projects. Solutions, on the other hand,
    group all of these projects together into a collection of interrelated projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the remainder of this chapter, we’ll write tests for a number of the classes
    from the previous chapters. Since xUnit is currently the most popular testing
    library, let’s start by adding a new xUnit test project to the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an xUnit Test Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add a new project to a solution, right-click on the solution’s name at the
    top of **Solution Explorer**, just below the search bar, and then choose **Add**,
    followed by **New Project…**
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, search for `xUnit` and select the **xUnit Test Project** result with
    the C# label attached to it, as shown in *Figure 6**.4*. Note that there are also
    versions of this test project that use other languages, such as VB or F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Selecting the xUnit Test Project option](img/B21324_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Selecting the xUnit Test Project option
  prefs: []
  type: TYPE_NORMAL
- en: Click `Chapter6XUnitTests`, and click **Next** again.
  prefs: []
  type: TYPE_NORMAL
- en: After this, you'll need to select the version of .NET to use. Since the code
    in this book uses **.NET 8**, you can select that option and click **Create**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should open a new file in your editor that contains some basic test code:'
  prefs: []
  type: TYPE_NORMAL
- en: UnitTest1.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, a new project was added to your solution that now appears in
    **Solution Explorer**, as shown in *Figure 6**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The test project in Solution Explorer](img/B21324_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The test project in Solution Explorer
  prefs: []
  type: TYPE_NORMAL
- en: There are still a few more steps that we’ll need to do to test our code in the
    other project. But before we do that, it may surprise you that the code xUnit
    created is already a runnable unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the `Test1` unit test, which will turn into a green check mark once
    the test runs, as shown in *Figure 6**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Test Explorer with tests expanded to the point where Test1 is
    visible](img/B21324_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Test Explorer with tests expanded to the point where Test1 is visible
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs: []
  type: TYPE_NORMAL
- en: If you do not see **Test Explorer** after running your tests, click on the **View**
    menu and then select **Test Explorer**. You may also need to build your solution
    before running tests becomes an option.
  prefs: []
  type: TYPE_NORMAL
- en: Note that our current test isn’t much of a test and we still haven’t covered
    the code or how it works. We’ll get there shortly, but first, let’s take the final
    step in setting up our tests and connect our test project to our `Chapter6` project.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the xUnit Test Project to your main project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In .NET, projects can depend on code in other projects. This allows you to have
    a class defined in one project and another project uses that class. This is something
    we’ll need to be able to do to test code from our unit test project. So, we’ll
    need to set up a project dependency from the test project to the `Chapter6` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the **Dependencies** node inside of the test project in **Solution
    Explorer** and choose **Add Project Reference…**, as shown in *Figure 6**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Adding a project reference to our test project](img/B21324_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Adding a project reference to our test project
  prefs: []
  type: TYPE_NORMAL
- en: After this, click the checkmark next to `Chapter6` and click `Chapter6` project
    so that the test project can now reference classes defined in the other project.
  prefs: []
  type: TYPE_NORMAL
- en: With all this in place, we’re ready to write our first real test.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first tests will test the `BaggageCalculator` class we built in [*Chapter
    2*](B21324_02.xhtml#_idTextAnchor026).
  prefs: []
  type: TYPE_NORMAL
- en: '`BaggageCalculator` has a `CalculatePrice` method with the following method
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We also know the following rules for this method:'
  prefs: []
  type: TYPE_NORMAL
- en: All carry-on baggage costs $30 per bag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first checked bag a passenger checks in costs $40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each subsequent checked bag costs $50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the travel occurs during the holidays, a 10% surcharge is applied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won’t be able to test all this logic in a single test, and we shouldn’t try.
    Unit tests should be small and related to one specific piece of logic. If a test
    fails, that failure should tell you a lot about what is wrong in your system.
    If unit tests try to do too much, they become harder to understand and a failure
    tells you less about what is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by taking our `UnitTest1` class and renaming it using the rename
    refactoring we covered in [*Chapter 2*](B21324_02.xhtml#_idTextAnchor026). Tests
    are generally named after the class they test. Since our class tests `BaggageCalculator`,
    let’s rename it `BaggageCalculatorTests`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll rename the `Test1` method to reflect what we’re trying to verify.
    The name of this test will show up in a test failure. So, my general rule of thumb
    is that if I get a notification that a test failed, its name alone should tell
    me what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we’re trying to verify that carry-on baggage is priced correctly.
    So, let’s rename `Test1` to something like `CarryOnBaggageIsPricedCorrectly`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code now reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we move on to writing our test code, let’s highlight a few key things:'
  prefs: []
  type: TYPE_NORMAL
- en: First, our method has a `Fact` attribute applied to it. This lets xUnit tell
    the test runner about our test and effectively registers the test for potential
    execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, `CarryOnBaggageIsPricedCorrectly` returns `void` and accepts no parameters.
    Test methods using the `Fact` attribute cannot accept parameters and must either
    return `void` or `Task` for asynchronous tests. We’ll discuss `Theory` and `InlineData`
    later in this chapter as they allow you to pass in parameters to unit tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, both the class and the method are `public`. Both must be `public` for
    the unit test to appear in the test runner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve covered some of the basic mechanics of unit tests, let’s follow
    the *arrange*/*act*/*assert* pattern to build our test.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing tests with Arrange/Act/Assert
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **arrange/act/assert pattern** is a structural pattern that’s used when
    writing tests. When following *arrange*/*act*/*assert*, you perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange** the things that you need for your tests by declaring variables.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Act** on the specific thing you’re trying to test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Assert** that the result of your action produced the desired outcome.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start by arranging the code. Since we’re testing the `CalculatePrice`
    method on the `BaggageCalculator` class, we’ll need to instantiate an instance
    of the baggage calculator.
  prefs: []
  type: TYPE_NORMAL
- en: We also know we’ll need to pass in the number of checked and carry-on bags,
    as well as the number of passengers and whether the travel is during a holiday
    season. These values should be whatever we think will make the most relevant or
    representative test, so they’re up to our discretion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filling out our *arrange* section with variable declarations results in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re setting up everything we need to carry out the *act* phase. Also,
    note that I included an `// Arrange` comment to group related code together. This
    is something I and many other developers I know do in our test code to help organize
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our variables in place, we can act upon the code we’re testing:
    the `CalculatePrice` method. To do this, we must call the method and store the
    `decimal` value it returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the *arrange* section, the *act* section is very brief, usually only
    a single line long. This is because the *act* section focuses on the thing you’re
    trying to test. We call the method we’re testing on the calculator object that
    was instantiated earlier and pass it the parameters it needs to do its job.
  prefs: []
  type: TYPE_NORMAL
- en: The system under test
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the `calculator` variable stores the instance of the class we’re
    testing. This is commonly referred to as the `sut` variable name for the object
    they’re about to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the cool thing: from our test’s perspective, we don’t care how it does
    its job. All we care about is that we give the method a set of inputs and we expect
    a specific output.'
  prefs: []
  type: TYPE_NORMAL
- en: We verify this behavior in our *assert* section by asserting that one or more
    things are true. If these things turn out *not* to be true, our test will fail.
    If all of them turn out to be true, the test will pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assertions typically use the `Assert` class to verify that values match their
    expected value. In our case, the scenario has 2 carry-on bags and no other bags.
    At $30 per carry-on bag, this should work out to $60, so our test code becomes
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter of the `Equal` method is the expected value. That’s the
    value *you* expect your result to be. You should *not* be calculating this value
    in code; otherwise, you risk repeating the same potentially bad logic in the code
    you’re testing to begin with!
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is the actual value, which is almost always the result
    of calling your method in the *act* section.
  prefs: []
  type: TYPE_NORMAL
- en: Often, developers new to testing expect the first parameter to be the actual
    value and the second value to be the expected value. However, this is incorrect
    and will lead to confusing test failures with swapped values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the result was 50 and we verified it correctly with `Assert.Equal(60m,
    result);` as we did earlier, you’d see a failure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is helpful and tells the developer what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you confused the two parameters and wrote `Assert.Equal(result, 60m);` you’d
    get this much more confusing message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This mistake has caused a lot of confusion and hair loss for me in the past.
    Do yourself a favor and remember that the first parameter is always the value
    you expect the result to be.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B21324_09.xhtml#_idTextAnchor189), *Advanced Unit Testing*,
    we’ll introduce a cleaner way of writing assertions with the **Shouldly** and
    **FluentAssertions** libraries. For now, remember that the expected value goes
    first and the actual value goes second.
  prefs: []
  type: TYPE_NORMAL
- en: Other Assert methods
  prefs: []
  type: TYPE_NORMAL
- en: The `Assert` class has more methods than just `Assert.Equal`. You can also use
    `Assert.True` and `Assert.False` to verify whether a boolean condition is true
    or false. `Assert.Null` and `Assert.NotNull` can help verify if something is or
    isn’t null. `Assert.Contains` and `Assert.DoesNotContain` will verify the presence
    or absence of an element in a collection. These are just a few of the methods
    available through the `Assert` class. For each of these messages, you can also
    provide a custom failure message to use when an assertion causes your test to
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve added our first unit test, let’s talk specifically about what
    makes a test pass and what makes a test fail.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding tests and exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every unit test that runs will pass – unless it encounters something that makes
    it fail.
  prefs: []
  type: TYPE_NORMAL
- en: That failure could be an `Assert` statement not matching the expected value,
    or it could be your program or test throwing an exception without catching it.
  prefs: []
  type: TYPE_NORMAL
- en: When you investigate how `Assert` methods are implemented, you’ll see that they
    all throw exceptions when their conditions aren’t met. When these exceptions are
    thrown, the test runner catches them and fails the test, displaying the failure
    message and stack trace appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: This is why an empty test will pass even without any `Assert` statements, and
    this is why you generally never write a `try`/`catch` block in your unit tests
    unless you are explicitly trying to verify some form of exception-handling logic.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this understanding of what makes a test fail, let’s write a second
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional test methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like classes can have multiple methods inside of them, test classes can
    have multiple test methods inside of them. This is because unit tests are just
    code in every sense of the word. Unit tests live in classes that are ordinary
    in every regard, except they live in a special project type and individual unit
    test methods have `[Fact]` just before the method is declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s illustrate this by adding a test for the next scenario: *The first checked
    bag costs $40*. Here’s what that test would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of similarities between this test and the prior one, but the
    key differences are that the number of carry-on and checked bags has changed to
    match the new scenario we’re testing, and the expected total is now $40 instead
    of $60.
  prefs: []
  type: TYPE_NORMAL
- en: Each test you write should be different. However, if you start to notice a lot
    of commonalities between tests, it’s probably time to refactor your unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests are code, and like other types of code, they can degrade in quality
    over time when not given proper respect and proactive refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, when you see code smells such as duplicated code that appears in most
    of your tests, it’s a sign that your tests need to be refactored.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore several ways of refactoring your test code.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing tests with Theory and InlineData
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we think about the similarities between our two tests, they only vary based
    on the values being passed into the method we’re testing and the value we expect
    the result to be.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about our test method, this is a clear case where it’d be wonderful
    to have parameters that could go into one test method that could represent multiple
    unit tests, each testing something slightly different, but with similar code.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall from earlier, unit tests that use `Fact` cannot have any parameters
    to them. However, xUnit gives us another attribute called `Theory` that allows
    us to pass data into the unit test as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple different ways of providing data to these parameters, but
    the most common way is to use an `InlineData` attribute to provide the test parameter
    data next to the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using `Theory` and `InlineData` to test four different
    scenarios around baggage pricing using the same test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is only a single method, each `InlineData` line represents a unique
    unit test and, as shown in *Figure 6**.8*, it will show up as an individual test
    in the test runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The four theory-based tests in Test Explorer grouped under a
    single test](img/B21324_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – The four theory-based tests in Test Explorer grouped under a single
    test
  prefs: []
  type: TYPE_NORMAL
- en: Although using `Theory` instead of `Fact` can initially be harder to read, the
    maintainability advantage is huge. First, parameterized tests have less code duplication.
    Secondly, if you need to update your tests later, you only need to update a single
    method instead of the many separate methods if you wrote the same tests using
    `Fact`.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing test code with constructors and fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Theory` isn’t the only way to improve your test code. If you find that your
    tests do a lot of work that is potentially sharable, you can introduce private
    methods to help organize your test code.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say you wanted to test the `FlightScheduler` class from [*Chapter
    5*](B21324_05.xhtml#_idTextAnchor101) and you wanted to start with testing that
    adding a flight to the schedule via `ScheduleFlight` results in that flight showing
    up when `GetAllFlights` is called.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you’ve created a `FlightSchedulerTests` class and are working on
    a `ScheduleFlightShouldAddFlight` unit test.
  prefs: []
  type: TYPE_NORMAL
- en: As you begin to write the test, you notice the `ScheduleFlight` method requires
    an `IFlightInfo` instance, which, in turn, needs several `AirportEvent` objects.
    These `AirportEvent` objects require their own `Airport` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'These dependencies result in you writing a lot of *arrange* code to set up
    for your test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This large volume of code isn’t necessarily *bad*, but it does distract from
    the rest of the test method, which performs the scheduling and verifies that the
    flight was added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While a lengthy *arrange* section isn’t the end of the world, other tests may
    likely want to create their own `PassengerFlightInfo`, `Airport`, or `AirportEvent`,
    which would lead to very similar code showing up between tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help improve the readability of our arrange method, we can introduce fields
    for the two airports and set them up in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When xUnit runs your test code, it will instantiate the `FlightSchedulerTests`
    class once for every unit test in that class. This means that any logic in the
    constructor or field initializers will run whenever any test in that class is
    run.
  prefs: []
  type: TYPE_NORMAL
- en: 'This lets us simplify the *arrange* section of our test considerably:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This process can be repeated as needed. For example, if you wanted to reuse
    the same `PassengerFlightInfo` between tests, you could add a `_flight` field
    and initialize it in the constructor as well.
  prefs: []
  type: TYPE_NORMAL
- en: The refactoring process isn’t about minimizing the size of the *arrange* section;
    it’s about keeping code duplication low while keeping the important aspects of
    your test visible to other developers reading your code.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing test code with methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another technique you can use to keep your code focused is to extract reusable
    methods from your test code to help accomplish common *arrange* tasks.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you wanted to test that removing a flight correctly removes
    the flight from the scheduler, you’d need a test that looks a lot like the test
    we just covered.
  prefs: []
  type: TYPE_NORMAL
- en: When you think about it, both tests don’t care much about the specifics of the
    flight being added – they care that when a flight is scheduled, it appears in
    the list of flights and that when a flight is removed, it should no longer be
    included.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we can extract a method to create our `Flight` object.
    This method could take in a flight identifier and return the created flight, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our prior test can now call this method to create its flight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See how much more focused this method is? You can quickly read it and get the
    intent of the test without having to focus on all the mechanics needed to create
    the flight.
  prefs: []
  type: TYPE_NORMAL
- en: Testing void methods
  prefs: []
  type: TYPE_NORMAL
- en: One question I often encounter is “How do you test `void` methods since they
    don’t return anything?” Most of the time, when you write tests, you test the return
    value of a method, but with `void` methods, you test the side effects of that
    method. This `ScheduleFlight` test is an example of how a `void` method can be
    tested. In our case, the side effect of scheduling a flight *should* be that the
    flight is present later when we’re getting all the flights from the scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the flight removal test, which uses the same method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This method is focused on the task of scheduling a flight and then removing
    it, and then verifying that the flight is no longer on the list of flights. If
    adding and removing a flight doesn’t remove it from the list of flights, that
    would be a bug and the test would fail.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing methods between test classes
  prefs: []
  type: TYPE_NORMAL
- en: If you find that many of your test classes would benefit from the same “helper”
    methods, such as `CreateFlight`, you may want to consider moving these helpers
    to a static class in your test project. This pattern is sometimes referred to
    as the **ObjectMother** or Builder pattern and is described further in the *Further*
    *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you could introduce a base testing class, move your shared methods
    to that class, and then have your tests inherit from that class. Test classes
    and test projects are just like normal code and many of the refactoring tricks
    we used in part 1 of this book will help improve your tests as well.
  prefs: []
  type: TYPE_NORMAL
- en: Before we close out this chapter with a discussion on adopting a testing mindset,
    let’s briefly look at a pair of other popular C# testing frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other testing frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond xUnit, the next most popular testing frameworks are **NUnit** and **MSTest**.
  prefs: []
  type: TYPE_NORMAL
- en: These two frameworks operate in very similar ways to xUnit but with slight differences
    in the syntax you use to declare a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve had the opportunity to program professionally and recreationally in all
    three major testing frameworks and I can tell you that these differences are largely
    cosmetic. That said, you will find that certain frameworks have specific features
    that might not be present in the others.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with NUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of the three testing frameworks, NUnit’s syntax is my favorite because it uses
    the `Test` name for both unit tests that require no parameters (equivalent to
    an xUnit `Fact`) and those that do (equivalent to an xUnit `Theory`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a parameterized test that verifies the `Load` method on `PassengerFlightInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In `NUnit`, Test and `TestCase` replace Theory and `InlineData`. If this test
    were not parameterized, `TestCase` would become `Test`.
  prefs: []
  type: TYPE_NORMAL
- en: The assert section of this test is a little different. The first thing to note
    is that NUnit’s assertion method is `Assert.AreEqual` instead of `Assert.Equal`.
    While this is a minor difference, I find that the code reads a bit better.
  prefs: []
  type: TYPE_NORMAL
- en: Below the `Assert.AreEqual` line is the `Assert.That` line. This is NUnit’s
    newer constraint model of unit tests; it reads a bit more fluently and reduces
    your chances of confusing parameters like the expected and actual values on an
    assertion. Both ways of writing NUnit tests are valid and work fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final note: in NUnit, all tests in a test class share the same class instance.
    This means that values stored in fields or properties on your tests will be shared
    by all tests in that test class. This is different from xUnit which creates a
    new test class instance for each test that runs.'
  prefs: []
  type: TYPE_NORMAL
- en: With NUnit explored, let's look at MSTest.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with MSTest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MSTest’s official name was **Visual Studio Unit Testing Framework**, but the
    framework has come to be known as **MSTest** throughout the community and even
    throughout Microsoft’s internal documentation.
  prefs: []
  type: TYPE_NORMAL
- en: MSTest V2
  prefs: []
  type: TYPE_NORMAL
- en: While MSTest had a poor reputation for nearly a decade due to a lack of feature
    parity between it and NUnit and xUnit, Microsoft revised MSTest in 2016, calling
    it **MSTest V2** and bringing many improvements to the framework to the point
    where it is now on par with its competitors.
  prefs: []
  type: TYPE_NORMAL
- en: Like NUnit, MSTest uses a single `TestMethod` attribute to mark both parameterized
    and unparameterized unit tests. However, unlike both NUnit and xUnit, MSTest also
    requires a `TestClass` attribute on the class itself to make the individual tests
    discoverable. This is something to watch out for when writing tests in MSTest
    as it’s another thing you can miss to make your tests not show up in the test
    runner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a sample parameterized test in MSTest that verifies the `FullName`
    property of the `Passenger` class from our `BoardingProcessor` class from [*Chapter
    3*](B21324_03.xhtml#_idTextAnchor045):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, this parameterized test evaluates the name of each of this book’s technical
    reviewers from `DataRow`, just like `InlineData` does in xUnit or `TestCase` does
    in NUnit.
  prefs: []
  type: TYPE_NORMAL
- en: While the MSTest syntax is different, there are many similarities between it
    and the other test frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The major differences between MSTest and NUnit are the inclusion of the `TestClass`
    attribute and the names `TestMethod` and `DataRow` instead of `Test` and `TestCase`,
    respectively. Even the naming of the `Assert.AreEqual` methods are identical between
    the two frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, these three testing frameworks are all very similar and serve a
    powerful role in your goal of high-quality software. I’ve found that I can work
    effectively in any of the three frameworks. While I tend to prefer NUnit’s syntax,
    I use xUnit in new projects because xUnit has largely become the community standard.
  prefs: []
  type: TYPE_NORMAL
- en: My recommendation is to pick the library whose syntax you like the most and
    use that for your projects and focus your efforts on writing good tests and adopting
    a testing mindset.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting a testing mindset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s take a step back and talk about why a book on refactoring features an
    entire series of chapters around testing. The reason is that code that needs to
    be refactored is often a bit more volatile and tends to break more easily when
    changed. Since the art of refactoring is about changing the form of the software
    without changing its behavior, introducing bugs when refactoring is undesirable
    and unacceptable.
  prefs: []
  type: TYPE_NORMAL
- en: This is where tests come in. Tests give you the confidence you and your team
    need to be able to improve your code. Your legacy code may or may not have tests
    around it already, so the responsibility and necessity of ensuring good tests
    are present falls to you before you perform any testing work.
  prefs: []
  type: TYPE_NORMAL
- en: This requires you to adopt a testing mindset. This phrase refers to thinking
    about tests at the *beginning* of the development process as a vital component
    of software development and refactoring, not as an afterthought.
  prefs: []
  type: TYPE_NORMAL
- en: While we’ll explore this concept at length in the next chapter as we discuss
    **test-driven development**, let’s touch on a few considerations that will help
    you be successful with tests in your organization and adopt a testing mindset.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating testing into your workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing should be a standard part of your everyday life as a software engineer.
  prefs: []
  type: TYPE_NORMAL
- en: This means that you should think about testing whenever you make any change
    to a system, whether the change is a new feature, fixing a bug, or paying down
    technical debt through refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: This requires a shift of mentality from seeing tests as tedious or something
    you ought to do to thinking of tests as things that have intrinsic value to the
    codebase and even to the larger organization. This is because tests provide value
    through their role as a sort of “living documentation” of your codebase, their
    ability to provide a safety net against certain types of bugs in the future, and
    their ability to give you and the business confidence in the code you’re writing.
  prefs: []
  type: TYPE_NORMAL
- en: You will, of course, bump into pieces of software that are significantly harder
    to test. These might be pieces of code working with the user interface or they
    might be pieces of code with very strong dependencies to other systems.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll touch more on dependencies later in this section and again in *Chapters
    8* and *9*, but testing the user interface is typically done with specialized
    tools and libraries and varies based on whether you are testing a web, desktop,
    or mobile application. As a result, user interface testing is outside the scope
    of this book. However, isolating dependencies is usually a strong part of that
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we talk about isolating dependencies, this means that when we test a piece
    of code, testing it shouldn’t alter anything else.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we’re trying to verify that scheduling a flight adds the flight
    to the list of flights in the system, we don’t want the system to send an email
    with a flight confirmation every time we run our unit test!
  prefs: []
  type: TYPE_NORMAL
- en: 'Such an example might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, `FlightScheduler` has an `EmailClient` class and calls `SendMessage` on
    the client every time a flight is scheduled. This is a strong dependency from
    `FlightScheduler` to the `EmailClient` class and will result in an undesirable
    side effect of sending emails when this code is tested.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects such as sending emails or interacting with the filesystem or a
    database are often undesirable in unit tests, as we’ll discuss shortly.
  prefs: []
  type: TYPE_NORMAL
- en: While it’s good for systems to be able to do these things, we want to test our
    units of code in isolation without them having side effects we don’t like. We
    can work around this via a process called **dependency injection**, where a class
    is no longer responsible for creating the dependencies it needs but gets them
    from others.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more testable version of `FlightScheduler` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, the dependency on the `EmailClient` class is injected into this class
    in its constructor and a new `IEmailClient` interface is used so that we can use
    a different implementation of this interface for testing. This test-specific version
    wouldn’t have the negative side effect of sending emails, making it more acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection and its related terms, **inversion of control** and **dependency
    inversion**, are complex topics that take some time to grasp. So, we’ll revisit
    them in [*Chapter 8*](B21324_08.xhtml#_idTextAnchor173), *Avoiding Code Anti-Patterns
    with SOLID*. Additionally, experienced testers may be crying out that a mocking
    framework such as Moq or NSubstitute can help with some of these concerns. We’ll
    cover these libraries in [*Chapter 7*](B21324_07.xhtml#_idTextAnchor161).
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s move on to talking about other factors that constitute good and
    bad tests.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating good and bad tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Good unit tests should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast to run**: If tests take minutes to run, developers won’t run them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliable and repeatable**: Tests shouldn’t randomly fail or pass or fail
    based on the day of the week, time of day, or which other tests were run earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independent from one another**: One test should never impact another test
    passing or failing and tests shouldn’t need to be run in a certain order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolated**: They should be kept independent of dependencies such as databases,
    files on disk, cloud resources, or external APIs. Not only do these things slow
    down your tests but if we’re testing these interactions, that’s an *integration
    test*, not a unit test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readable**: Tests serve as examples of how to interact with your classes.
    Additionally, when a test fails, its failure should be easy to understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portable**: Tests shouldn’t require significant machine setup and should
    be runnable on any developer’s machine or another machine as part of a **continuous
    integration/continuous delivery** (**CI/CD**) pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast, bad tests take time to run, are “flaky” and randomly fail, cannot
    be run in parallel or out of order, are difficult to understand regarding what
    they’re testing or why, and require a lot of manual configuration to run reliably.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you want to favor many small unit tests that are fast to run, easy
    to understand, and reliable over more ambitious tests that test too many things
    at once, leading to slow tests that lead to unclear and unreliable test failures.
  prefs: []
  type: TYPE_NORMAL
- en: Thoughts on code coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I can’t talk about unit testing without introducing **code coverage**. Code
    coverage is the lines of code that run as part of any unit test. If a test causes
    the line of code to run, it is considered covered; otherwise, it is considered
    not covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several tools calculate code coverage, including Visual Studio Enterprise and
    JetBrains ReSharper, which we talked about briefly in [*Chapter 2*](B21324_02.xhtml#_idTextAnchor026).
    If you have Visual Studio Enterprise, you can calculate code coverage by selecting
    the **Test** menu and then **Analyze Code Coverage for All Tests**. This will
    show the lines of code that are covered and not covered by unit tests, as shown
    in *Figure 6**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Overview of Code Coverage Results in Visual Studio Enterprise](img/B21324_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Overview of Code Coverage Results in Visual Studio Enterprise
  prefs: []
  type: TYPE_NORMAL
- en: 'These coverage results will highlight any lines that are not covered by unit
    tests, such as the code of the `Unload` method in `PassengerFlightInfo`, as shown
    in *Figure 6**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Covered lines are highlighted in blue, while lines without
    tests are highlighted in red (line 14)](img/B21324_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Covered lines are highlighted in blue, while lines without tests
    are highlighted in red (line 14)
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage is one of those topics that can be divisive. On the one hand,
    code coverage gives you a metric that shows how much of your code is executed
    by any test. This gives you a meaningful way of measuring the extent of your unit
    testing safety net.
  prefs: []
  type: TYPE_NORMAL
- en: However, code coverage can be deceptive. Just running a line of code does not
    mean that the effects of that line are verified by a unit test. This can lead
    to a false sense of security around your unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when organizations prioritize work that increases the code coverage
    percentage or requires a certain minimum percentage of code coverage for new work,
    this can lead to tests that focus on the less risky aspects of your software system.
    For example, do you need to write a unit test to verify code that throws an `ArgumentNullException`
    error when a null value is passed to a method, or is your time better spent elsewhere?
  prefs: []
  type: TYPE_NORMAL
- en: Often, the most critical areas of your application may already appear to be
    covered by your code coverage metrics, but no tests verify that these lines work
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: My personal feeling is that code coverage is one of many useful metrics to monitor
    but should not be used to significantly drive the behavior of your development
    teams.
  prefs: []
  type: TYPE_NORMAL
- en: See the *Further reading* section for more information on code coverage and
    how to get started calculating it.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore other metrics in [*Chapter 12*](B21324_12.xhtml#_idTextAnchor259),
    *Code Analysis in Visual Studio*, but for now, let’s conclude this chapter with
    some closing thoughts on unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is a powerful way to verify that refactoring code does not introduce
    bugs, document your classes, and prevent bugs from occurring in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are code that tests other code. In .NET, project unit tests are usually
    performed with xUnit, NUnit, or MSTest. Each testing framework provides assertions
    that verify that code behaves correctly or fails a test if the actual value doesn’t
    match the expected value.
  prefs: []
  type: TYPE_NORMAL
- en: When we write unit tests, we typically structure our tests in the *arrange*/*act*/*assert*
    pattern, which sets up the thing being tested in the *arrange* step, does a single
    action in the *act* step, and verifies the correctness of the action’s result
    in the *assert* step.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore testing more with test-driven development.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Which unit testing framework syntax do you like the most?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the most complex parts of your application? Are they tested?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you test a method that calculates the credit score of an applicant?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you test a `void` method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What things can you do to help test code stay clean and readable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information about the materials discussed in this chapter
    by checking out the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Types of* *Tests*: [https://learn.microsoft.com/en-us/dotnet/core/testing/](https://learn.microsoft.com/en-us/dotnet/core/testing/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Visual Studio Test* *Explorer*: [https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer](https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*xUnit*: [https://xunit.net/](https://xunit.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*NUnit*: [https://nunit.org/](https://nunit.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MSTest*: [https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The ObjectMother* *Pattern*: [https://www.martinfowler.com/bliki/ObjectMother.html](https://www.martinfowler.com/bliki/ObjectMother.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code* *Coverage*: [https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested](https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
