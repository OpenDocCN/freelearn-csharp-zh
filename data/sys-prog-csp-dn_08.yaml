- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: The One with the Network Navigation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络导航者
- en: '*Building High-Performance* *Networking Applications*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*构建高性能* *网络应用程序*'
- en: Software seldom lives in isolation. The same can be said, to a greater extent
    for system programs. Since these programs do not directly interact with the user,
    they rely on other software to give them input, read their output, and be told
    what to do. That “other software” often lives on the same machine, but just as
    often, that software runs elsewhere.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件很少孤立存在。对于系统程序来说，这一点更是如此。由于这些程序不直接与用户交互，它们依赖于其他软件来提供输入，读取它们的输出，并被告知要做什么。那个“其他软件”通常位于同一台机器上，但同样经常，那个软件运行在其他地方。
- en: 'We have so far discussed how to transfer data to and from our applications
    and briefly looked at networking. This chapter focuses on that specific topic:
    networking. Be prepared to go deeply into the world of interconnected software!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何将数据传输到我们的应用程序以及从我们的应用程序中传输数据，并简要地了解了网络。本章将专注于这个特定主题：网络。准备好深入到互联软件的世界吧！
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: The fundamentals and the OSI layers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础知识和 OSI 层
- en: Exploring the System.Net namespace (including the most used protocols)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 System.Net 命名空间（包括最常用的协议）
- en: Working with System.Net.Sockets to have more control
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 System.Net.Sockets 以获得更多控制
- en: Asynchronous, non-blocking networking
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步、非阻塞网络
- en: How to improve networking performance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何提高网络性能
- en: Networking errors and time-out, and how to deal with those
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络错误和超时，以及如何处理这些问题
- en: We are about to break out of the box and connect to the outside world. Let’s
    go!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将跳出盒子，连接到外部世界。让我们出发吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the code samples for this chapter can be found at [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter08](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter08).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在[https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter08](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter08)找到。
- en: The fundamentals
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: We have already talked about the OSI model. But just as a quick refresher, the
    OSI model defines the layers that make up the system, allowing us to communicate
    with other systems. The layers span from the lowest layer, which describes the
    voltages a network adapter should be able to handle, up to the highest level,
    which describes the application that uses networking.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 OSI 模型。但为了快速回顾，OSI 模型定义了构成系统的层，使我们能够与其他系统通信。这些层从最低层开始，描述网络适配器应该能够处理的电压，到最高层，描述使用网络的程序。
- en: A walk down the OSI layers
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSI 层的漫步
- en: I want to walk you through all the layers again, detailing what happens in each.
    To do this, I want to discuss a user using FTP to send data. **FTP**, which stands
    for **File Transfer Protocol**, is an older, hardly used technique to send data
    to remote machines or to get data from those remote machines.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我想再次带你们走过所有层，详细说明每一层发生的事情。为此，我想讨论一个用户使用 FTP 发送数据的情况。**FTP**，即**文件传输协议**，是一种较老的技术，几乎不再使用，用于向远程机器发送数据或从远程机器获取数据。
- en: FTP used to be the best way to achieve that, but the lack of security features
    made people move to other means. We will discuss some of those later, but we can
    still use FTP for our walk-down of the OSI model. It makes things a bit easier
    to understand.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: FTP 曾经是实现这一点的最佳方式，但由于缺乏安全功能，人们转向了其他方式。我们稍后会讨论其中的一些，但我们仍然可以使用 FTP 来了解 OSI 模型。这使得事情更容易理解。
- en: An FTP client can be as simple as a console application. Actually, almost all
    FTP clients are just that. There are GUI-based clients, but they act as wrappers
    around the FTP commands.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 FTP 客户端可以简单到只是一个控制台应用程序。实际上，几乎所有的 FTP 客户端都是这样。也有基于 GUI 的客户端，但它们只是 FTP 命令的包装器。
- en: To transfer a file, a user fires up the FTP client, specifies the server to
    connect to, and optionally passes in the credentials. Then, the user uses commands
    such as `GET` and `PUT` to transfer the file. Another command is `LS`, which is
    used to get the contents of a remote directory. We also have `MKDIR` to create
    a remote directory and other such commands.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要传输文件，用户启动 FTP 客户端，指定要连接的服务器，并可选地传递凭据。然后，用户使用 `GET` 和 `PUT` 等命令来传输文件。另一个命令是
    `LS`，用于获取远程目录的内容。我们还有 `MKDIR` 命令来创建远程目录和其他类似命令。
- en: 'So, let us assume that the user is sitting at their machine and wants to log
    in to the remote computer. To do that, the user types `ftp username:password@127.0.0.1`
    at the command prompt. This does a few things:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们假设用户正坐在他们的机器上，并想要登录到远程计算机。为此，用户在命令提示符中输入 `ftp username:password@127.0.0.1`。这会做几件事情：
- en: It starts up the command-line version of FTP
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它启动了 FTP 的命令行版本
- en: Then it tells it to connect to a computer found at address 127.0.0.1 (which
    is, as you probably remember, localhost)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它告诉它连接到地址为 127.0.0.1 的计算机（如您可能记得，这是本地主机）
- en: It supplies a username and a password that the server needs.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它提供服务器需要的用户名和密码。
- en: After a few seconds, the client lists all files in the requested location. But
    what happens in the computer when the user presses the *Enter* key?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，客户端列出请求位置中的所有文件。但是当用户按下 *Enter* 键时，计算机里会发生什么？
- en: After starting the application, the FTP client takes over.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动应用程序后，FTP 客户端接管。
- en: 'The commands and data flow through the OSI levels. Let me show you what happens:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 命令和数据通过 OSI 层流动。让我向您展示会发生什么：
- en: '**Layer 7**: The application runs on OSI level 7, the application level. The
    FTP protocol in the application then sets up the connection. FTP creates two connections:
    one for control commands and one for data transfer.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 7 层**：应用程序在 OSI 第 7 层，即应用层运行。应用程序中的 FTP 协议随后建立连接。FTP 创建两个连接：一个用于控制命令，一个用于数据传输。'
- en: '`open` command is translated from whatever string format it was into an 8-bit
    ASCII format. If encryption is needed, that is also taken care of here. After
    all, layer 6 is all about how to present the data.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open` 命令将字符串格式转换为 8 位 ASCII 格式。如果需要加密，这里也会处理。毕竟，第 6 层是关于如何呈现数据的问题。'
- en: '**Layer 5**: The session layer then takes over. This layer is where the actual
    connection to the remote machine is made. This layer keeps an eye on the connection
    to make sure it is reliable and stable. It also closes the connection when it
    is no longer needed.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 5 层**：会话层随后接管。这一层是实际连接到远程机器的地方。这一层会监控连接，确保其可靠性和稳定性。当不再需要时，它也会关闭连接。'
- en: '**Layer 4**: After that, the transport layer makes sure the data containing
    the command is broken into smaller packets and sends them out in the correct order.
    FTP uses TCP, meaning layer 4 is responsible for rearranging data packets that
    are out of order when data is received. Error checking is also something that
    happens here.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 4 层**：之后，传输层确保包含命令的数据被分成更小的数据包，并按正确顺序发送出去。FTP 使用 TCP，这意味着第 4 层负责在接收数据时重新排列顺序错误的数据包。错误检查也在这里发生。'
- en: '**Layer 3**: The network layer is where the **Internet Protocol** (**IP**)
    lives. This protocol in layer 3 is responsible for finding the best route to the
    remote machine. It also handles packet forwarding and rerouting.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 3 层**：网络层是 **互联网协议**（**IP**）所在的地方。第 3 层的此协议负责找到到达远程机器的最佳路由。它还处理数据包转发和重新路由。'
- en: '**Layer 2**: Then, we get to the data link layer. This layer adds data to the
    packets, such as the MAC address of the next machine the data needs to get to.
    It is responsible for node-to-node communication. If you use Wi-Fi, this layer
    prepares the data to be sent over the radio waves.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 2 层**：然后，我们到达数据链路层。这一层向数据包添加数据，例如数据需要到达的下一台机器的 MAC 地址。它负责节点到节点的通信。如果你使用
    Wi-Fi，这一层会准备数据以便通过无线电波发送。'
- en: '**Layer 1**: Finally, we reach the physical layer. This last layer is where
    the data is actually transmitted. This layer translates the data into radio signals
    if you use Wi-Fi. It deals with all the hardware issues, such as the frequencies
    used and the strength of the signal.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 1 层**：最后，我们到达物理层。这一层实际上是数据传输的地方。如果你使用 Wi-Fi，这一层会将数据转换为无线电信号。它处理所有硬件问题，例如使用的频率和信号的强度。'
- en: Luckily, most of this is done at the OS or BIOS level. We do not have to worry
    about frequencies when setting up a network connection. We usually deal with **layers
    7** and **6**, and sometimes **5**. We write the application (**layer 7**). We
    define the presentation (**layer 6**) if we have our own protocol. And we might
    sometimes have to worry about the actual connections, so we deal with **layer**
    **5** occasionally.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大部分工作都是在操作系统或 BIOS 层面上完成的。我们设置网络连接时不必担心频率。我们通常处理 **第 7 层** 和 **第 6 层**，有时还会处理
    **第 5 层**。我们编写应用程序（**第 7 层**）。如果我们有自己的协议，我们会定义表示（**第 6 层**）。有时我们可能还需要担心实际连接，所以我们偶尔会处理
    **第 5 层**。
- en: Tip
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The BCL and the CLR have many classes, tools, and helpers, allowing us to focus
    on the fun without worrying about the details. But sometimes, as system programmers,
    we must worry about those details. These details can be the difference between
    a great, fast, and stable system and a mediocre one. But do not worry: we cover
    it all here in this chapter!'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: BCL和CLR有许多类、工具和辅助工具，使我们能够专注于乐趣，而不必担心细节。但有时，作为系统程序员，我们必须担心这些细节。这些细节可能是伟大、快速和稳定的系统与平庸系统之间的区别。但不用担心：我们在这里的章节中涵盖了所有内容！
- en: Before we can do that, let us look at commonly used ways to transmit data over
    a network.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够做到这一点之前，让我们看看在网络上传输数据的常用方式。
- en: Exploring the System.Net namespace
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索System.Net命名空间
- en: Chances are, if you need a way to transmit data, someone else has already figured
    out the best way to do this.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 很有可能，如果你需要一种传输数据的方法，其他人已经想出了做这件事的最佳方式。
- en: For instance, you could write all the code to transfer a file to and from a
    machine or use FTP and rely on existing software.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以编写所有代码来在机器之间传输文件，或者使用FTP并依赖现有软件。
- en: In fact, there are many ways to transfer data. Many of those ways are so standardized
    that they are part of the BCL. You can use them without dealing with third-party
    NuGet packages. Let us discuss some of the offerings in the System.Net namespace
    and see what we can do with them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有很多种传输数据的方式。其中许多方式已经标准化到成为BCL的一部分。你可以使用它们而无需处理第三方NuGet包。让我们讨论System.Net命名空间中的一些提供项，看看我们能用它们做什么。
- en: Understanding HTTP/HTTPS
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解HTTP/HTTPS
- en: HTTP was the protocol that enabled millions of users to finally use the internet.
    Before HTTP, the only way to exchange data was through technically complicated
    protocols, most of which had to be controlled through the command line. When Sir
    Tim Berners-Lee published his ideas about the World Wide Web and the accompanying
    **Hypertext Transfer Protocol** (**HTTP**), people with little or no technical
    background could also use the net. Web browsers made it easy to go around and
    find information. Of course, when I say easy, I mean easier than before. In the
    early 1990s, we had no Google or Bing, so finding interesting sites was a struggle
    compared to today.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是使数百万用户最终能够使用互联网的协议。在HTTP之前，交换数据的唯一方式是通过技术复杂的协议，其中大多数都需要通过命令行控制。当蒂姆·伯纳斯-李爵士发布了他关于万维网和伴随的**超文本传输协议**（**HTTP**）的想法时，那些技术背景很少或没有的人也可以使用网络。网络浏览器使四处走动和查找信息变得容易。当然，当我说容易时，我的意思是比以前更容易。在20世纪90年代初，我们没有Google或Bing，所以与今天相比，找到有趣的网站是一种挑战。
- en: '*HTTP democratized the internet*. Before that, it was the realm of scientists
    and the military, with a few nerds sprinkled in for good measure. Yes, I was one
    of those nerds: I first used the internet through SMTP, Gopher, FTP, and Usenet
    in 1987\. HTTP and the WWW made it all so much easier.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTTP使互联网民主化*。在此之前，它是科学家和军事人员的领域，还有一些为了平衡而加入的极客。是的，我就是那些极客之一：我第一次在1987年通过SMTP、Gopher、FTP和Usenet使用互联网。HTTP和万维网使这一切变得容易得多。'
- en: 'Programming for it was not that easy. However, with the current frameworks,
    getting data from an arbitrary site anywhere on the globe only takes a couple
    of lines of code. Let me show you:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为其编程并不那么容易。然而，随着当前的框架，从全球任何地方的任意网站获取数据只需要几行代码。让我给你看看：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the first line, we create an instance of the `HttpClient` class. This class
    is a helpful little helper: it takes away much of the complexity of the older
    `HttpWebRequest`. Although `HttpWebRequest` does offer some advantages over `HttpClient`
    (for instance, more control over the headers, the option to set time-outs, and
    the ability to use synchronous data transfers if needed), `HttpClient` is by far
    the better choice.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了一个`HttpClient`类的实例。这个类是一个有用的辅助工具：它减少了旧版`HttpWebRequest`的许多复杂性。尽管`HttpWebRequest`在`HttpClient`之上提供了一些优势（例如，对头部的更多控制、设置超时的选项，以及在需要时使用同步数据传输的能力），但`HttpClient`无疑是更好的选择。
- en: Testing with dummy servers
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟服务器进行测试
- en: If you want to play around with HTTP and HTTPS, you need a reliable and easy-to-use
    website to connect to. The [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    URL is a great site to use in those cases. It gives you several endpoints to connect
    to, read from, and send data to. It is simple to use, and it is free. Please have
    a look at that site to see what it offers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要玩转HTTP和HTTPS，你需要一个可靠且易于使用的网站来连接。[https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    URL是这种情况下的一个很好的网站。它提供了几个端点来连接、读取和发送数据。它使用简单，而且是免费的。请查看该网站，看看它提供了什么。
- en: After declaring the URL, we call the `GetAsync` method with that URL. This asynchronous
    operation returns an instance of the `HttpResponseMessage` class. That class contains
    all we need to read the data from the remote server.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明URL之后，我们使用该URL调用`GetAsync`方法。这个异步操作返回`HttpResponseMessage`类的实例。这个类包含了我们读取远程服务器数据所需的所有内容。
- en: The next call is just a shorthand for some straightforward error checking. Calling
    `EnsureSuccessStatusCode` does very little besides looking at the return code
    from the server, and it throws an error if it is not in the 200 range. As you
    probably know, HTTP requests return a numeric status code that tells you what
    the result of the call is. Everything between 200 and 299 means your call worked.
    Codes such as 404 mean the site is unreachable, and so on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个调用只是一个简单的错误检查的快捷方式。调用`EnsureSuccessStatusCode`除了查看服务器的返回代码之外几乎不做任何事情，如果它不在200范围内，它会抛出一个错误。正如你可能知道的，HTTP请求返回一个数字状态码，告诉你调用结果是什么。200到299之间的所有代码都表示你的调用成功了。例如，404代码表示网站不可达，等等。
- en: This single method makes your code much more readable than `if` statements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种单一的方法可以使你的代码比`if`语句更易于阅读。
- en: If all is okay, we continue by reading the actual data. The response has several
    properties, one of which is `Content`. Other properties are the status code, the
    headers, and so on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们继续读取实际数据。响应有几个属性，其中一个是`Content`。其他属性包括状态码、头信息等。
- en: '`Content`, of type `HttpContent`, is a wrapper around `Stream` that allows
    us to read data from the server. In our case, we call `ReadAsStringAsync`, which
    takes all data the server can give us and returns that to us as a string. Of course,
    this all happens asynchronously.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content`，类型为`HttpContent`，是`Stream`的包装器，它允许我们从服务器读取数据。在我们的例子中，我们调用`ReadAsStringAsync`，它接受服务器可以给出的所有数据，并将其作为字符串返回给我们。当然，所有这些都是在异步中发生的。'
- en: Finally, we display that string on the console.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在控制台上显示那个字符串。
- en: This is the simplest example of using HTTP I can think of. All classes shown
    here have many more use cases, methods, and helpers that can benefit you. I suggest
    you look at the documentation of `HttpClient`, `HttpResponseMessage`, `HttpContent`,
    and the rest to see what else you can do with them. In the meantime, let’s look
    at some other protocols.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我能想到的HTTP使用最简单的例子。这里展示的所有类都有许多更多的用例、方法和辅助工具，这些都可以为你带来好处。我建议你查看`HttpClient`、`HttpResponseMessage`、`HttpContent`和其他类的文档，看看你还能用它们做什么。同时，让我们看看其他协议。
- en: FTP
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP
- en: We saw FTP before. I used it to illustrate the flow of actions through the OSI
    model. But we never thoroughly explored what we can do with it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前见过FTP。我使用它来说明通过OSI模型的动作流程。但我们从未彻底探索过我们可以用它做什么。
- en: FTP is an older technology. It is not in use that much anymore, but it is still
    beneficial. It is a quick, easy-to-understand technology to transfer files between
    machines and control remote file systems, regardless of the underlying operating
    system. It is fast and reliable. Most operating systems support FTP both as a
    client and as a server.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: FTP是一种较老的技术。它现在不再被广泛使用，但它仍然有益。它是一种快速、易于理解的技术，可以在机器之间传输文件和控制远程文件系统，无论底层操作系统是什么。它是快速且可靠的。大多数操作系统都支持FTP作为客户端和服务器。
- en: In Windows, you can enable the FTP server by going to the **Program and Features**
    section of the settings in the control panel, and there, under **Internet Information
    Services**, you can see the option to install the FTP server. Alternatively, you
    can click *Win* + *R* and then enter the optional features. See *Figure 8**.1*
    to see what it looks like.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，你可以通过访问控制面板设置中的**程序和功能**部分来启用FTP服务器，在那里，在**互联网信息服务**下，你可以看到安装FTP服务器的选项。或者，你可以按*Win*
    + *R*，然后输入可选功能。参见*图8.1*了解其外观。
- en: '![Figure 8.1: Installing FTP Server on Windows](img/B20924_09_01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：在Windows上安装FTP服务器](img/B20924_09_01.jpg)'
- en: 'Figure 8.1: Installing FTP Server on Windows'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：在Windows上安装FTP服务器
- en: However, make sure you know what you are doing. One of the reasons we do not
    use FTP that much anymore is that it is not secure by default. To transfer files,
    it would be better to use something such as SFTP, which is a secure version.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请确保你知道你在做什么。我们不再那么频繁地使用FTP的一个原因是因为它默认不安全。为了传输文件，最好使用像SFTP这样的东西，它是一个安全的版本。
- en: But good old FTP is still your friend if you want to communicate in a secure
    environment (such as in a Kubernetes cluster) and transfer files quickly and easily.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想在安全的环境中（例如在Kubernetes集群中）快速轻松地传输文件，那么古老的FTP仍然是你的朋友。
- en: 'So, how do you read the contents of a remote directory? Simple: use this piece
    of code!'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何读取远程目录的内容呢？很简单：使用这段代码！
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, the code here is pretty straightforward. We create an instance
    of `WebRequest` and cast it to a subclass: `FtpWebRequest`. We specify what we
    want to do by setting the method to `ListDirectoryDetails`. We add some credentials
    if needed and get a stream containing the data we need. Of course, we handle exceptions
    as well.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里的代码相当直接。我们创建了一个`WebRequest`的实例并将其转换为子类：`FtpWebRequest`。我们通过设置方法为`ListDirectoryDetails`来指定我们想要做什么。如果需要，我们添加一些凭据，并获取包含所需数据的流。当然，我们也会处理异常。
- en: Great! But wait… this is actually not so great.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！但是等等…这实际上并不那么好。
- en: 'If you do this in your editor, you will see warnings: `WebRequest` (and thus
    `FtpWebRequest`) has been marked obsolete. They have been superseded by the much
    better `HttpClient`. Unfortunately, that one cannot be used with FTP sites: it
    is only meant for HTTP traffic.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这款编辑器中这样做，你会看到警告：“`WebRequest`（以及因此`FtpWebRequest`）已被标记为过时。它们已被更好的`HttpClient`所取代。不幸的是，它不能用于FTP站点：它仅适用于HTTP流量。
- en: I believe Microsoft made a mistake here. But it is their framework, so they
    can do what they want. The good news is that plenty of NuGet packages can do what
    we want them to do. One is *FluentFtp*, which you can find at the [https://github.com/robinrodricks/FluentFTP](https://github.com/robinrodricks/FluentFTP)
    URL. Here, I would like to mention that I am not affiliated with this or any other
    NuGet package I mention in this book; these are just the packages I use. Of course,
    many different options are available, so just pick whatever works for you.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为微软在这里犯了一个错误。但这是他们的框架，所以他们可以随心所欲。好消息是，有很多NuGet包可以做到我们想要的事情。一个是*FluentFtp*，你可以在[https://github.com/robinrodricks/FluentFTP](https://github.com/robinrodricks/FluentFTP)这个URL找到。在这里，我想提到的是，我与此书提到的任何NuGet包都没有关联；这些只是我使用的包。当然，有很多不同的选项可供选择，所以请选择对你有用的任何一种。
- en: Email protocols
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子邮件协议
- en: 'HTTP is the most used protocol on the public-facing internet, both in the number
    of servers handling it and in the percentage of data dealt with. But second to
    that is SMTP. **SMTP**, which stands for **Simple Mail Transfer Protocol**, is
    used for email. SMTP is just one of the protocols related to emails. Let’s look
    into each one of those:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是公共互联网上使用最广泛的协议，无论是处理它的服务器数量还是处理的数据百分比。但排在第二位的是SMTP。**SMTP**，即**简单邮件传输协议**，用于电子邮件。SMTP只是与电子邮件相关的协议之一。让我们来看看这些协议中的每一个：
- en: '**SMTP**: The Simple Mail Transfer Protocol is used to send mail over the Internet.
    It is connection-oriented, meaning its primary task is to ensure a connection
    between the client sending the mail and the server processing it. It is reliable
    (meaning it can be recovered if data is lost in transit).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SMTP**：简单邮件传输协议用于在互联网上发送邮件。它是面向连接的，这意味着它的主要任务是确保发送邮件的客户机和处理邮件的服务器之间的连接。它是可靠的（这意味着如果传输过程中数据丢失，它可以恢复）。'
- en: '**POP3**: POP3 is the third iteration of the **Post Operation Protocol**. This
    protocol deals with the other side: SMTP ensures the mail gets delivered to the
    server, and POP3 allows the users to read their mail from the server. POP3 allows
    for offline access to email, but it can only access one mailbox at a time. If
    you want to read multiple mailboxes (or accounts, if you will), you need to set
    up more than one POP3 connection.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POP3**：POP3是**Post Operation Protocol**的第三版。这个协议处理另一边：SMTP确保邮件被发送到服务器，而POP3允许用户从服务器读取邮件。POP3允许离线访问电子邮件，但一次只能访问一个邮箱。如果你想读取多个邮箱（或者说是账户），你需要设置多个POP3连接。'
- en: '**IMAP**: IMAP stands for **Internet Message Access Protocol**. This protocol
    is also meant to read mail from the server. But this protocol can read multiple
    mailboxes in one go. IMAP can access, search, manipulate, and delete your emails
    without downloading them. It can send these commands to the server in an RPC way
    (we discussed RPC extensively in [*Chapter 7*](B20924_08.xhtml#_idTextAnchor159)).'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IMAP**：IMAP代表**互联网消息访问协议**。这个协议也是为了从服务器读取邮件。但这个协议可以一次性读取多个邮箱。IMAP可以在不下载邮件的情况下访问、搜索、操作和删除您的电子邮件。它可以通过RPC方式（我们在[*第7章*](B20924_08.xhtml#_idTextAnchor159)中广泛讨论了RPC）将这些命令发送到服务器。'
- en: '**MIME**: Despite not having a P at the end of the acronym, **MIME** is also
    a protocol. It is the acronym for **Multipurpose Internet Mail Extension** protocol.
    As the name suggests, it is an extension, allowing us to have attachments, multimedia,
    and non-ASCII characters in our mail messages.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MIME**：尽管缩写中没有P，**MIME**也是一个协议。它是**多用途互联网邮件扩展**协议的缩写。正如其名所示，它是一个扩展，允许我们在邮件消息中包含附件、多媒体和非ASCII字符。'
- en: All these protocols enable us to have a functional, complete mail experience.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些协议都使我们能够拥有一个功能齐全、完整的邮件体验。
- en: Sending an email
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: 'That being said, most software sends mail messages; it hardly ever reads them.
    So, let’s look at a simple sample of how to send an email in code. The sample
    code I provide consists of three parts. Let’s look at them:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，大多数软件发送邮件消息；它们几乎从不读取它们。所以，让我们看看一个简单的代码示例，说明如何发送电子邮件。我提供的示例代码由三部分组成。让我们来看看它们：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Obviously, we need a message. Otherwise, why would we connect to an SMTP server?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要一个消息。否则，我们为什么要连接到SMTP服务器？
- en: The message is of type `MailMessage`. It needs a sender, and it can have multiple
    recipients. Those recipients can be in the `To`, `CC`, or `BCC` fields. `To`,
    `CC`, and `BCC` are all lists, so you can add multiple recipients. Of course,
    you need to supply at least the `To` recipients.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的类型是`MailMessage`。它需要一个发送者，并且可以有多个收件人。这些收件人可以在`收件人`、`抄送`或`密送`字段中。`收件人`、`抄送`和`密送`都是列表，因此您可以添加多个收件人。当然，您至少需要提供`收件人`。
- en: We can supply a `Subject` field. I would really encourage you to do that, of
    course. Then we have a `Body`, which contains the message we want to send.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供一个`主题`字段。当然，我非常鼓励您这样做。然后我们有一个`正文`字段，它包含我们想要发送的消息。
- en: Once we have the message, we can create an instance of the `SmtpClient` class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了消息，我们就可以创建`SmtpClient`类的实例。
- en: You need to have access to a real SMTP server, of course. Most internet service
    providers have them, so please look up how to connect to them in their documentation.
    You usually need a username and password to authenticate yourself. In the old
    days, there were anonymous servers, but in these days of spam, those are very
    hard to find.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您需要能够访问一个真实的SMTP服务器。大多数互联网服务提供商都有，所以请查阅他们的文档了解如何连接到它们。您通常需要一个用户名和密码来验证自己。在以前的日子里，有匿名服务器，但如今在垃圾邮件泛滥的时代，这些服务器非常难以找到。
- en: 'We have to specify the server’s address and port (port `25` is the old port;
    port `587` is the new, secure one, and the preferred port to use), and you can
    specify whether you want to use SSL. That code looks like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须指定服务器的地址和端口（端口`25`是旧端口；端口`587`是新端口，也是推荐使用的安全端口），并且您可以指定是否要使用SSL。这段代码看起来是这样的：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And finally, we can send the message!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以发送消息！
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you have set up the client, you can send multiple messages using that same
    client instance. You do not have to worry about setting up connections. You can
    just call `Send`, and it all works.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您设置了客户端，您可以使用相同的客户端实例发送多个消息。您不必担心设置连接。您只需调用`Send`，一切都会正常工作。
- en: Sending HTML messages
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送HTML消息
- en: 'The previous example works fine, but the message is kind of bland. These days,
    messages are much more colorful and pleasant to look at. The way to do that is
    to send an HTML message. You can do that by just putting HTML in the `Body` field
    and setting the `IsBodyHtml` property of `MailMessage` to true. But that is not
    the best way to do that for the following two reasons:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子工作得很好，但消息有点平淡。如今，消息要丰富多彩得多，看起来也更令人愉快。要做到这一点，就是发送一个HTML消息。您可以通过在`正文`字段中放入HTML并设置`MailMessage`的`IsBodyHtml`属性为true来实现。但这样做并不是最佳方式，以下有两个原因：
- en: Not all clients support HTML. The readers must decipher the HTML to find the
    body text if their client does not support HTML.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有客户端都支持HTML。如果他们的客户端不支持HTML，读者必须解析HTML以找到正文文本。
- en: Messages only containing HTML are usually marked as spam.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只包含HTML的消息通常会被标记为垃圾邮件。
- en: 'The best way to do this is to combine your beautifully crafted HTML body and
    a more down-to-earth plain text body. You can do that by using the `AlternateView`
    class. The code to create the mail message looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的最好方法是将你精心制作的HTML正文和更接地气的纯文本正文结合起来。你可以通过使用`AlternateView`类来实现这一点。创建邮件消息的代码如下：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We create an instance of the regular `MailMessage` class. Most of the fields
    are the same. But we do not specify a body. Instead, we create two instances of
    the `AlternateView` class by calling the `CreateAlternateViewFromString` static
    method. That method takes the content we want to send (either HTML or plain text)
    and the encoding we use (we set it to `NULL`, so it uses the default setting for
    your machine). We do have to specify the content type. The first contains `"text/html"`
    and the second contains `"text/plain"`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个常规的`MailMessage`类实例。大多数字段都是相同的。但我们没有指定正文。相反，我们通过调用`CreateAlternateViewFromString`静态方法创建了两个`AlternateView`类实例。该方法接受我们想要发送的内容（HTML或纯文本）以及我们使用的编码（我们将其设置为`NULL`，因此使用机器的默认设置）。我们确实需要指定内容类型。第一个包含`"text/html"`，第二个包含`"text/plain"`。
- en: We then add both parts to the `MailMessage` instance, and we can send it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将这两部分添加到`MailMessage`实例中，并发送它。
- en: The rest of the code stays the same.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其他部分保持不变。
- en: That covers some of the higher-level classes. It is now time to go deeper into
    the rabbit hole.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了部分高级类。现在是时候深入探究这个兔子洞了。
- en: Working with the System.Net.Sockets namespace
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在使用`System.Net.Sockets`命名空间时
- en: The default protocols are fantastic. They take away a lot of manual work. We
    do not have to program the HTTP protocol ourselves; we can focus on the content
    instead. The same goes for SMTP, POP3, and all the other protocols out there.
    You can find a class or a NuGet package if the protocol you want to use is popular
    enough.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认协议非常出色。它们减少了大量的手动工作。我们不必自己编写HTTP协议；我们可以专注于内容。同样适用于SMTP、POP3以及所有其他协议。如果你想要使用的协议足够流行，你可以找到一个类或NuGet包。
- en: But of course, sometimes you cannot find that package. Sometimes, you want to
    write your own protocol. In that case, you have to do all the hard work yourself.
    But, I have to be honest, I immensely enjoy doing that. There is something nice
    about writing my protocol, deploying it in my apps, and seeing them work together.
    And even if you do not enjoy this, there are cases where you have no choice.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但当然，有时你找不到那个包。有时，你想编写自己的协议。在这种情况下，你必须自己完成所有艰苦的工作。但是，我必须诚实地说，我非常享受这个过程。编写自己的协议，将其部署在我的应用程序中，并看到它们协同工作，这很有趣。即使你不享受这个过程，也有时候你别无选择。
- en: The good news is that the good people who wrote the BCL have already done much
    of the underlying work.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，编写BCL的善良的人们已经做了很多底层工作。
- en: In [*Chapter 6*](B20924_07.xhtml#_idTextAnchor140), we encountered the `Socket`
    class when we discussed how systems can communicate. Sockets were mentioned as
    one of the options. We wrote a simple chat application that uses TCP/IP to communicate.
    TCP/IP is one of the ways sockets can connect.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B20924_07.xhtml#_idTextAnchor140)中，当我们讨论系统如何通信时，我们遇到了`Socket`类。套接字被提及为一种选项。我们编写了一个简单的聊天应用程序，该程序使用TCP/IP进行通信。TCP/IP是套接字可以连接的方式之一。
- en: In the chat sample I mentioned, we created instances of the `TcpListener` and
    `TcpClient` classes. These classes are wrappers around the more generic `Socket`
    class. They are specifically used for TCP/IP connections and handle much of the
    plumping needed to get this to work.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我提到的聊天示例中，我们创建了`TcpListener`和`TcpClient`类的实例。这些类是更通用的`Socket`类的包装器。它们专门用于TCP/IP连接，并处理了使这一切工作所需的大部分管道工作。
- en: You can use sockets yourself, of course. That means you must do much of the
    work yourself, giving you more control over what happens.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以使用套接字。这意味着你必须自己完成大部分工作，这让你对发生的事情有更多的控制。
- en: 'You can use sockets with TCP and UDP connections. We looked at the differences
    in [*Chapter 6*](B20924_07.xhtml#_idTextAnchor140), so we won’t compare them again
    here. However, you should use the `Socket` class if you want to use UDP: obviously,
    `TCPClient` will not work. By the way, there is also a `UdpClient` class, with
    which you can achieve the same result. However, I want you to be aware of the
    inner workings. That is why I am going with `Sockets` here.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用套接字进行TCP和UDP连接。我们在[*第6章*](B20924_07.xhtml#_idTextAnchor140)中探讨了它们之间的差异，所以在这里我们不会再次比较。然而，如果你想使用UDP，你应该使用`Socket`类：显然，`TCPClient`将不起作用。顺便说一下，还有一个`UdpClient`类，你可以用它达到相同的结果。但是，我想让你了解其内部工作原理。这就是为什么我选择使用`Sockets`的原因。
- en: Steps to take when using sockets
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用套接字时的步骤
- en: 'When working with sockets, you need to take a number of steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当与套接字一起工作时，你需要采取一些步骤：
- en: Choose the right socket. You can use stream sockets. Stream sockets are based
    on the TCP protocol. It is a reliable, connection-oriented protocol. But you can
    also choose datagram sockets. These are based on the UDP protocol. They are connectionless,
    fire-and-forget ways of communicating. It is quick, but you have no guarantee
    the data will reach the intended recipient.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择正确的套接字。你可以使用流套接字。流套接字基于TCP协议。它是一个可靠、面向连接的协议。但你也可以选择数据报套接字。这些基于UDP协议。它们是无连接的、一次性通信方式。它很快，但你无法保证数据会到达预期的接收者。
- en: Then, you create the socket. You specify the kind of address you want to use
    (IPV4 or IPV6), the type of socket (stream or datagram), and the protocol (TCP
    or UDP).
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你创建套接字。你指定你想要使用的地址类型（IPv4或IPv6）、套接字类型（流或数据报）和协议（TCP或UDP）。
- en: It’s time to connect. You either listen to incoming connections or connect to
    a server somewhere. When you connect to a remote server, you must specify the
    IP address and the port. If you are listening, you need the port at least, and
    if you have more network connections, you might want to specify the IP address
    you are listening to.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候连接了。你可以监听传入的连接或连接到某个服务器。当你连接到远程服务器时，你必须指定IP地址和端口。如果你在监听，你至少需要端口，如果你有更多的网络连接，你可能还想指定你正在监听的IP地址。
- en: Sending and receiving data. After all, that’s what we are here for, right?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送和接收数据。毕竟，我们在这里就是为了这个，对吧？
- en: 'When you are done, you must be sure to close the connection. You do not want
    to hold on to a connection for too long: you might get in the way of other applications.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成时，你必须确保关闭连接。你不希望长时间保持连接：你可能会妨碍其他应用程序。
- en: And that is all there is to it. If I put it like this, it seems straightforward,
    doesn’t it? Well, the devil is in the details!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。如果我这样说，看起来很简单，不是吗？嗯，魔鬼在细节中！
- en: IPv4 and IPv6
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv4和IPv6
- en: 'We need to talk a bit about the IP address. The **IP** address, which stands
    for **Internet Protocol** address, is a unique number identifying a network device.
    It is unique within boundaries, but we will discuss that later. There are two
    kinds of addresses we can use: IPv4 and IPv6\. As you might have guessed, these
    acronyms are Internet Protocol version 4 and version 6, respectively.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要稍微谈谈IP地址。IP地址，即**互联网协议**地址，是一个唯一标识网络设备的数字。它在边界内是唯一的，但稍后我们将讨论这一点。我们可以使用两种类型的地址：IPv4和IPv6。正如你可能已经猜到的，这些缩写分别是互联网协议版本4和版本6。
- en: The first publicly used version was IPv4\. IPv5 never saw the light of day,
    leaving us with two versions. It has always been the idea to replace IPv4 with
    IPv6 completely, but it seems IPv4 will stay around for a bit longer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个公开使用的版本是IPv4。IPv5从未见过天日，留下了两个版本。我们一直的想法是完全用IPv6替换IPv4，但看起来IPv4还会存在一段时间。
- en: 'An IPv4 address consists of 4 bytes, thus making it 32 bits long. This size
    means that there are about 4.3 billion unique addresses in theory. In practice,
    there are fewer since many ranges are reserved. We have already encountered one
    of them: the address is `127.0.0.1`. This is the address of the device itself.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个IPv4地址由4个字节组成，因此它有32位长。这个大小意味着理论上大约有43亿个唯一的地址。实际上，由于许多范围被保留，所以更少。我们已经遇到了其中之一：地址是`127.0.0.1`。这是设备的地址本身。
- en: 'Although different systems can reserve different port ranges, there is a common
    understanding of what ranges we should avoid using or what ranges we can use.
    These ranges are explained like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不同的系统可以保留不同的端口范围，但我们对于应该避免使用哪些范围或可以使用哪些范围有一个共同的理解。这些范围是这样解释的：
- en: '**Port 0 – 1023**: Well-known ports. These ports are used everywhere and you
    should not use them yourself.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口 0 – 1023**：知名端口。这些端口到处都在使用，你不应该自己使用它们。'
- en: '`1433`, which is used by SQL Server. However, these are not as strictly assigned
    as the range `0` – `1023`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1433`，由SQL Server使用。然而，这些并不是像`0` – `1023`范围那样严格分配的。'
- en: '**Port 49152 – 65535**: This range is known as the dynamic or private range.
    They are usually used for ephemeral or short-lived communications. They are, most
    of the time, dynamically allocated by the operating system.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口 49152 – 65535**：这个范围被称为动态或私有范围。它们通常用于临时或短暂的通信。它们通常由操作系统动态分配。'
- en: Just make sure the port you pick is not yet in use on your intended system!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 只确保你选择的端口在你打算使用的系统上尚未被占用！
- en: 'An IPv6 address comprises 8 sets of 2-byte structures, making it 128 bits in
    length. You can fit substantially more addresses in that address space: there
    are about 340 undecillion unique addresses.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6地址由8组2字节的结构组成，长度为128位。你可以在那个地址空间中放入大量地址：大约有340个十一万亿个唯一的地址。
- en: Big numbers
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大数字
- en: 'Working with computers means you sometimes run into big numbers. This is such
    a case: an undecillion is 10 to the power of 36\. That means the number is 340,
    followed by 36 zeros. That’s a lot of addresses.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与计算机打交道意味着你有时会遇到大数字。这是一个例子：一个十一万亿等于10的36次方。这意味着这个数字是340后面跟着36个零。这有很多地址。
- en: 'The IPv6 address is displayed as a sequence of 8 sets of 16-bit hexadecimal
    values. For instance, a valid address could look like this: `2001:0db8:85a3:0000:0000:8a2e:0370:7334`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6地址显示为8组16位十六进制值的序列。例如，一个有效的地址可能看起来像这样：`2001:0db8:85a3:0000:0000:8a2e:0370:7334`。
- en: 'This is also an interesting address: `0000:0000:0000:0000:0000:0000:0000:0001`.
    This is the IPv6 version of 127.0.0.1\. In other words, this is localhost. However,
    it is pretty long: there are 7 sets of `0000`. With IPv6 we can omit a range of
    `0000` values with two colons. So we can shorten the address for localhost to
    ::1.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个有趣的地址：`0000:0000:0000:0000:0000:0000:0000:0001`。这是127.0.0.1的IPv6版本。换句话说，这就是localhost。然而，它相当长：有7组`0000`。在IPv6中，我们可以通过两个冒号省略一系列的`0000`值。因此，我们可以将localhost的地址缩短为::1。
- en: Both in IPv4 and IPv6, we have reserved ranges. For instance, everything in
    the range `192.168.0.0` up to `192.168.255.255` is used for internal networks.
    You cannot, however, assign these addresses to devices facing the public network.
    The same goes for the addresses `10.0.0.0 to 10.255.255.255` and `172.16.0.0`
    `to 172.31.255.255`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv4和IPv6中，我们都预留了地址范围。例如，`192.168.0.0`到`192.168.255.255`范围内的所有地址都用于内部网络。然而，你不能将这些地址分配给面向公共网络的设备。对于地址`10.0.0.0`到`10.255.255.255`和`172.16.0.0`到`172.31.255.255`也是如此。
- en: Looking up time with sockets
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用套接字查找时间
- en: It is time to look at how to do all this for real.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看如何真正地做这些了。
- en: 'There are servers out there that work as time servers. These servers have one
    purpose: wait for your connection and then respond with the current date and time.
    The way they do this is pretty interesting: they calculate the time it takes to
    send a response and adjust the time accordingly, thus making sure the answer is
    as accurate as possible.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有些服务器充当时间服务器。这些服务器只有一个目的：等待你的连接，然后响应当前的日期和时间。他们这样做的方式非常有趣：他们计算发送响应所需的时间，并相应地调整时间，从而确保答案尽可能准确。
- en: 'Let’s look at some code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码：
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The method starts with a default value for the name of the server. We use [pool.ntp.org](http://pool.ntp.org)
    as our server, but there are many more out there that would do the trick. They
    all use the NTP protocol (**NTP** means **Network Time Protocol**, in case you
    were wondering). NTP is one of the oldest protocols. Systems used this protocol
    to synchronize the clocks of computers over a network as far back as the early
    80s!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法从服务器的默认名称值开始。我们使用[pool.ntp.org](http://pool.ntp.org)作为我们的服务器，但还有许多其他服务器也能完成这项任务。它们都使用NTP协议（**NTP**意味着**网络时间协议**，以防你有所疑问）。NTP是最古老的协议之一。早在80年代初，系统就使用这个协议来通过网络同步计算机的时钟！
- en: 'The address we use, `pool.ntp.org`, is not a single computer but a pool of
    thousands of NTP servers, ensuring everybody can get their time. However, we can
    treat it as a single server. Oh, one word of warning: that URL is meant to be
    used by NTP clients. They use port `123`, as you can see in the code. If you use
    your browser to go to that address, you automatically use HTTP and thus port `80`
    (there is no HTTPS server at that address). This means you get to see whatever
    the maintainers of that pool want to put there. Do not use your browser to go
    to that URL; use port `123` as it is intended!'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的地址`pool.ntp.org`不是一个单独的计算机，而是一个包含数千个NTP服务器的池，确保每个人都能获取到时间。然而，我们可以将其视为一个单独的服务器。哦，有一点需要注意：该URL旨在由NTP客户端使用。它们使用端口`123`，正如你在代码中所见。如果你使用浏览器访问该地址，你将自动使用HTTP，因此端口`80`（在那个地址上没有HTTPS服务器）。这意味着你将看到该池维护者想要放置的内容。不要使用浏览器访问该URL；使用它应有的端口`123`！
- en: 'A request to the NTP server needs a buffer of 48 bytes to hold the answer.
    We need to add some data in that buffer when we connect to the server, telling
    it what we want. In our case, we give it the value 0x23\. This byte consists of
    3 groups of bits, each group telling the server something about what we want.
    Look at the following table to see what these bits mean:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 向NTP服务器请求需要一个48字节的缓冲区来存储答案。当我们连接到服务器时，我们需要在缓冲区中添加一些数据，告诉它我们想要什么。在我们的情况下，我们给它值0x23。这个字节由3组位组成，每组位告诉服务器我们想要什么。查看以下表格以了解这些位的含义：
- en: '| **Bits** | **Name** | **Description** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **名称** | **描述** |'
- en: '| 6– 7 | Leap Indicator | Indicates whether we want to take the leap seconds
    a month might have into account. 0 means no adjustment, 1 means the last minute
    of the month has 61 seconds, 2 means the last minute of the month has 59 seconds,
    and 3 means the clock is unsynchronized. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 6-7 | 闰秒指示器 | 表示我们是否想要考虑一个月可能有的闰秒。0表示没有调整，1表示该月的最后分钟有61秒，2表示该月的最后分钟有59秒，3表示时钟未同步。|'
- en: '| 4-6 | Version | The version of the protocol we want to use. The latest version
    is 4. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 4-6 | 版本 | 我们想要使用的协议版本。最新版本是4。|'
- en: '| 0-3 | Mode | 0: Reserved1: Symmetric active2: Symmetric passive3: Client4:
    Server5: Broadcast6: NTP control message7: Reserved |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 0-3 | 模式 | 0：保留1：对称主动2：对称被动3：客户端4：服务器5：广播6：NTP控制消息7：保留 |'
- en: 'Table 8.1: Settings for NTP servers'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1：NTP服务器的设置
- en: We do not want to use leap adjustment. We are interested in using protocol version
    4\. And we are a client here. That means we have to do some bit-arithmetic. Working
    down from the most significant bits to the least significant bits, we get 00 for
    bits 6 and 7, 100 for bits 4, 5, and 6, and finally, 011 for bits 0 through 4\.
    If we combine this, we get 0010 0011, or 23 in decimal.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想使用闰秒调整。我们感兴趣的是使用协议版本4。我们在这里是客户端。这意味着我们必须做一些位运算。从最高有效位到最低有效位工作，我们得到位6和7为00，位4、5和6为100，最后位0到4为011。如果我们组合这些，我们得到0010
    0011，或十进制的23。
- en: We place that value in the first byte in the 48-byte long buffer we shall give
    to the server.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个值放在48字节长缓冲区的第一个字节中，我们将把这个缓冲区给服务器。
- en: We have the name of the NTP server (`pool.ntp.org`), but we need the actual
    IP address of that machine. After all, sockets need an address and not a string
    of text. The `var addresses = Dns.GetHostEntry(ntpServer);`, I get 4 IP addresses
    back.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有NTP服务器的名称（`pool.ntp.org`），但我们需要该机器的实际IP地址。毕竟，套接字需要一个地址而不是一串文本。`var addresses
    = Dns.GetHostEntry(ntpServer);`，我得到了4个IP地址。
- en: We take the first address we got back and construct an instance of an `IPEndPoint`
    class with that address and port `123`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取回的第一个地址，并使用该地址和端口`123`创建一个`IPEndPoint`类的实例。
- en: Then, we can create an instance of the `Socket` class. We give it the `AddressFamily`
    `InterNetwork`, meaning we want to use IPv4 addresses. We also specify that we’ll
    use a datagram, and thus, we use UDP.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个`Socket`类的实例。我们给它`AddressFamily` `InterNetwork`，这意味着我们想要使用IPv4地址。我们还指定我们将使用数据报，因此我们使用UDP。
- en: Mixing streams, datagrams, TCP, and UDP
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 混合流、数据报、TCP和UDP
- en: You must specify what socket type and protocol type you want to use. However,
    if you use `SocketType.Stream`, you must also use `ProtocolType.TCP`. And if you
    want to use `SocketType.DGram`, you must also use `ProtocolType.UDP`. If you try
    to mix these (you want datagram over TCP, for instance), you get an exception
    during runtime. So, be careful what you choose.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须指定您想要使用的套接字类型和协议类型。然而，如果您使用`SocketType.Stream`，您还必须使用`ProtocolType.TCP`。如果您想使用`SocketType.DGram`，您也必须使用`ProtocolType.UDP`。如果您尝试混合这些（例如，您想要TCP上的数据报），则在运行时会出现异常。所以，请小心选择。
- en: We call `connect` on the socket, giving it the endpoint we created. After that,
    we send the server our 48-byte buffer containing information about `leap`, `version`,
    and `mode`. Next, we try to get an answer by calling `Receive`, using that same
    buffer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在套接字上调用`connect`，给它我们创建的端点。之后，我们向服务器发送一个包含关于`leap`、`version`和`mode`信息的48字节缓冲区。接下来，我们通过调用`Receive`来尝试获取答案，使用相同的缓冲区。
- en: Of course, when we get the answer, we close the connection.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们得到答案时，我们关闭连接。
- en: Once the answer is received and safely stored in our buffer, we can do some
    calculations to transform the data into something we can use in a `DateTime` structure.
    That specific piece of code we call contains conversions between different formats,
    swapping bits, and more. They have nothing to do with getting data from a server,
    so I leave it out. The sample on GitHub has that code, so please check that out
    if you want to see what that looks like.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到答案并安全地存储在我们的缓冲区中，我们就可以进行一些计算，将数据转换为我们可以在`DateTime`结构中使用的格式。我们称之为特定代码片段，它包含不同格式之间的转换、位交换等。它们与从服务器获取数据无关，所以我将其省略。GitHub上的示例有这段代码，如果你想看看它是什么样子，请查看。
- en: The code that deals with the socket was not that complicated. But there is a
    problem with this code. It is what we call **blocking code**. It blocks the entire
    thread for the duration of the call to the NTP server. Let’s fix that.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 处理套接字的代码并不复杂。但这个代码存在一个问题。这就是我们所说的**阻塞代码**。它在调用NTP服务器期间会阻塞整个线程。让我们来修复它。
- en: Async, non-blocking networking
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步、非阻塞网络
- en: It should be evident by now that you must ensure that all non-instantaneous
    operations in your code are a potential performance issue. Slow operations can
    block a process from continuing. File I/O is one of the areas where this is appropriate.
    Networking is even slower than that. So, everything that we can do asynchronously
    should be implemented that way.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经很明显，你必须确保你代码中的所有非即时操作都可能是性能问题。慢速操作可能会阻止进程继续。文件I/O是这种操作适用的一个领域。网络甚至比这还要慢。所以，我们可以异步执行的所有操作都应该以这种方式实现。
- en: 'The good news is that most classes dealing with networking have asynchronous
    versions of their methods. The bad news is that for `Socket`, it is not as straightforward
    as you might have hoped. But do not worry: we will tackle this soon!'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，大多数处理网络的类都有它们方法的异步版本。坏消息是，对于`Socket`来说，这并不像你希望的那样简单直接。但不用担心：我们很快就会解决这个问题！
- en: Making asynchronous calls
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行异步调用
- en: 'In the previous sample, we used the static `Dns` class to get information about
    the address of the NTP server. We called `GetHostEntry()`, which is a synchronous
    blocking call. We can fix that quite easily: `Dns` has asynchronous versions of
    those methods. We can rewrite the call to look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们使用了静态的`Dns`类来获取NTP服务器的地址信息。我们调用了`GetHostEntry()`，这是一个同步阻塞调用。我们可以很容易地修复这个问题：`Dns`有这些方法的异步版本。我们可以重写调用，使其看起来像这样：
- en: '[PRE7]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Of course, the signature of the method needs to change as well. Instead of
    having this method declaration: `public DateTime GetNetworkTime(string ntpServer
    = "``pool.ntp.org")`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，方法签名也需要改变。而不是有这个方法声明：`public DateTime GetNetworkTime(string ntpServer = "``pool.ntp.org")`。
- en: 'We change it into this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其改为如下：
- en: '`public async Task<DateTime> GetNetworkTimeAsync(string ntpServer = "``pool.ntp.org")`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`public async Task<DateTime> GetNetworkTimeAsync(string ntpServer = "``pool.ntp.org")`'
- en: We made it `async`, changed the return type to `Task<DateTime>` instead of `DateTime`,
    and renamed the method to have the `Async` postfix.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其改为`async`，将返回类型改为`Task<DateTime>`而不是`DateTime`，并将方法重命名为带有`Async`后缀。
- en: 'That was simple enough. We can do the same for the code working with `Socket`.
    This is the full method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。我们可以对与`Socket`一起工作的代码做同样的处理。这是完整的方法：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This version takes advantage of the async/await pattern, so the calls to the
    server do not block the threads.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本利用了async/await模式，因此对服务器的调用不会阻塞线程。
- en: Tip
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Networking code should always use asynchronous methods instead of synchronous
    ones. Networking is slow compared to the raw speed of the CPU and the local machine,
    so why waste time waiting on that slow trickle of data from the network adapter?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 网络代码应始终使用异步方法而不是同步方法。与CPU和本地机器的原始速度相比，网络较慢，那么为什么还要浪费时间等待网络适配器缓慢的数据流呢？
- en: However, there are ways to improve the performance of your system when you use
    networking. Let’s look at those next.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用网络时，有方法可以改进你系统的性能。让我们接下来看看那些方法。
- en: Networking performance
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络性能
- en: 'Since networking is comparatively slow, we have to be smart about ways to improve
    the throughput of the data. We can control local networks, ensuring we have optic
    fiber and super-fast routers everywhere, but that does not solve the issues. Even
    the fastest physical network is way slower than data handled in the CPU. Of course,
    having fast hardware helps. But it only helps on our own network: we cannot control
    the hardware on other networks. We must be wise in our code to get the most out
    of our networking. Once again, it all comes down to us, the developers!'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络相对较慢，我们必须在提高数据吞吐量的方法上变得聪明。我们可以控制本地网络，确保我们到处都有光纤和超级快速的路由器，但这并不能解决问题。即使是最快的物理网络也比
    CPU 处理的数据要慢得多。当然，拥有快速的硬件有帮助。但这只帮助我们的网络：我们无法控制其他网络上的硬件。我们必须在代码中变得聪明，以充分利用我们的网络。再一次，这都取决于我们，开发者！
- en: Connection pooling
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接池
- en: 'A connection represents an open line between a client and a server. Let’s look
    at the following line of code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 连接代表客户端和服务器之间的开放线路。让我们看看以下代码行：
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This single line of code is simple enough: this creates a connection to a server
    called `my.server.com` on port `123` and returns the open connection. Fine. We’ve
    seen that before. But let me show you what happens when you run that line of code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码很简单：它创建了一个连接到名为 `my.server.com` 的服务器，端口为 `123`，并返回打开的连接。很好。我们之前见过。但是让我给你看看运行这行代码会发生什么：
- en: '`my.server.com` string into the correct IPv4 or IPv6 addresses we can use.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `my.server.com` 字符串转换为我们可以使用的正确 IPv4 或 IPv6 地址。
- en: '`Socket` class is instantiated, allocating the memory for it and ensuring it
    is available.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化 `Socket` 类，为其分配内存并确保其可用。
- en: '`SYN` is sent to the server. Basically, the client is asking, “Hey, can we
    talk?”'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向服务器发送 `SYN`。基本上，客户端在问：“嘿，我们可以交谈吗？”
- en: '`SYN` message comes in, it responds with `SYN-ACK`, acknowledging that it is
    ready to talk.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当接收到 `SYN` 消息时，它会响应 `SYN-ACK`，表示它已准备好进行通信。
- en: '`SYN-ACK`, that apparently the network works fine, and that they can talk.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYN-ACK`，这表明网络工作正常，并且它们可以进行通信。'
- en: When all this has happened, the communication line is open and ready for use.
    We can start sending and receiving data.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当这一切都发生后，通信线路就打开了，并准备好使用。我们可以开始发送和接收数据。
- en: As you can see, a lot of work is involved in that simple line of code. You can
    imagine that the handshaking between the client and the server takes a lot of
    time. Network connections are expensive!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，那简单的一行代码涉及到很多工作。你可以想象客户端和服务器之间的握手过程需要花费很多时间。网络连接是昂贵的！
- en: There is no getting around this. These steps need to be taken. But there is
    no reason to do them more than you need to. If you have a connection to a server,
    you might reuse it as well. We call that connection pooling. We create a pool
    of connections, and whenever something in our system needs to talk to the server,
    we return the already-created connection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点无法回避。这些步骤必须执行。但是，没有必要做得比你需要的更多。如果你已经连接到服务器，你也可以重用它。我们称之为连接池。我们创建一个连接池，每当我们的系统需要与服务器通信时，我们返回已经创建的连接。
- en: Unfortunately, the BCL does not have a class for this. But it is not too hard
    to write one yourself. You could do it like this.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，BCL 没有为此提供类。但是自己写一个并不太难。你可以这样做。
- en: 'We create a class called `TcpClientConnectionPool`. The signature looks like
    this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `TcpClientConnectionPool` 的类。其签名如下：
- en: '[PRE10]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have three methods in that class:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中有三个方法：
- en: '[PRE11]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Before we look at what those methods do, we need to create two private fields
    in the class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看这些方法之前，我们需要在类中创建两个私有字段：
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When you create a pool to hold objects, you need a place to store them. We
    use `ConcurrentBag<T>` here. `ConcurrentBag` is a thread-safe collection that
    has the following characteristics:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个用于存储对象的池时，你需要一个地方来存储它们。我们在这里使用 `ConcurrentBag<T>`。`ConcurrentBag` 是一个线程安全的集合，具有以下特性：
- en: '**Thread safe**: You can add, access, and remove objects without worrying about
    locks or other threads running amock. This class handles the details for you.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程安全**：你可以添加、访问和删除对象，而无需担心锁或其他线程的干扰。这个类为你处理这些细节。'
- en: '**Unordered**: There is no specific order. In our case, this is just fine.
    However, if you want to use something like FIFO, you should use a class with an
    order built in.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无序**：没有特定的顺序。在我们的情况下，这完全没问题。然而，如果你想使用类似 FIFO 的东西，你应该使用内置顺序的类。'
- en: '**Duplicates are allowed**: You can add the same object to the collection if
    you want.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许重复**：如果你想，可以将相同的对象添加到集合中。'
- en: '**Performance**: This class is optimized for scenarios where the same thread
    adds or removes items but performs pretty well in mixed scenarios.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：这个类针对同一线程添加或删除项目的情况进行了优化，但在混合场景中表现也相当不错。'
- en: 'The `GetConnection()` method pulls an object from the pool if one is available.
    If one is not, it creates one for you. Here it is:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetConnection()`方法如果池中有可用对象，则从中拉取一个对象。如果没有，它会为您创建一个。下面是这个方法：'
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, I throw an exception when the pool has reached the maximum
    allowed objects. You want to limit the number of `TcpClient` instances in your
    code: they take up quite a lot of memory and underlying handles, so having an
    unlimited amount of them lying around might not be the best idea.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，当池达到最大允许对象数时，我会抛出一个异常。您希望在代码中限制`TcpClient`实例的数量：它们占用相当多的内存和底层句柄，因此让它们无限期地存在可能不是最好的主意。
- en: 'If there is room in the pool but no items are available, we create a new one
    and return it to the caller. The idea is that after using, the caller returns
    the object, and we store it in the collection, ready for another user to pick
    it up. We use lazy initialization here: we only create `TcpClient` when needed.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果池中有空间但没有可用项，我们创建一个新的并返回给调用者。这个想法是，在使用后，调用者将对象返回，我们将其存储在集合中，以便其他用户可以取用。在这里我们使用懒加载初始化：只有在需要时才创建`TcpClient`。
- en: If you want, you can create all 10 instances in the constructor of this class.
    That makes the initialization of the class slower, and it uses more memory, but
    it is much faster during the object’s lifetime.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以在这个类的构造函数中创建所有10个实例。这使得类的初始化变慢，并且占用更多内存，但在对象的整个生命周期中运行得更快。
- en: 'When the connection user calls this method, it gets an active and open connection.
    When the user no longer needs `TcpClient`, it needs to be returned so it can be
    stored in the pool and ready for the following user. That method looks like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接用户调用此方法时，它会获得一个活跃和开放的连接。当用户不再需要`TcpClient`时，它需要返回以便存储在池中，并准备好供下一个用户使用。这个方法看起来是这样的：
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can do some checking when we get `TcpClient` back. For instance, I usually
    check to see whether it is still connected here. It is a bit like a library: when
    you return your items, they expect them to be pristine. We do the same here. If
    there is something wrong, we can fix it or not even add it back to the pool. I’ll
    leave that up to you.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获取`TcpClient`时，我们可以进行一些检查。例如，我通常检查它是否仍然连接。这有点像图书馆：当你归还物品时，他们期望它们是完好的。我们在这里也这样做。如果有问题，我们可以修复它，或者甚至不将其放回池中。我将这个决定留给您。
- en: 'Finally, when the connection pool is disposed of, we do some cleaning up:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当连接池被释放时，我们进行一些清理工作：
- en: '[PRE15]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We go through all the remaining instances of `TcpClient` in our collection,
    close them if needed, dispose of the underlying stream, and dispose of the instances
    themselves. This makes sure we leave no connection open. My mother taught me this
    at a very young age: always clean up after yourself!'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历集合中剩余的`TcpClient`实例，如果需要则关闭它们，释放底层流，并释放实例本身。这确保我们没有留下任何打开的连接。我的母亲在我很小的时候就教了我这一点：总是要清理自己的东西！
- en: 'To finalize this part, this is how you would use this class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这部分，这是您将如何使用这个类的示例：
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I first create an instance of `connectionPool`. Obviously, you would not do
    that in each method call that needs a connection, but for this simple example,
    it is all right.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先创建了一个`connectionPool`的实例。显然，您不会在每个需要连接的方法调用中都这样做，但在这个简单的示例中，这样做是可以的。
- en: Then I try to get a connection by calling `GetConnection()`;
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我尝试通过调用`GetConnection()`来获取连接；
- en: Then I get some bytes by taking the `Hello, World` string, postfixing that with
    `u8` to ensure it is UTF-8 and then converting it to a byte array.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我通过获取`Hello, World`字符串，在后面加上`u8`以确保它是UTF-8，然后将其转换为字节数组。
- en: I can use my pooled connection to send that string to the server. Finally, I
    can put the connection back in the pool.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用我的池化连接将这个字符串发送到服务器。最后，我可以将连接放回池中。
- en: This sample is limited in functionality and lacks a lot of the code you would
    need before taking it into production. But I am sure it will help you get on your
    way.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的功能有限，并且在将其投入生产之前缺少很多必要的代码。但我确信它将帮助您走上正轨。
- en: What we are doing is caching our connections. But caching can help in a lot
    of other ways as well.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在缓存我们的连接。但缓存还可以以许多其他方式提供帮助。
- en: Caching
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: 'Caching stores data nearby so you can reuse it instead of going to the server
    each time. That sounds simple enough: it can be a huge performance booster. Getting
    an object from a memory location on your machine instead of going to a remote
    server each time sounds like a no-brainer, right? But there are some potential
    pitfalls you need to take into account. Here are the most important ones:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存将数据存储在附近，以便你可以重用它，而不是每次都去服务器。这听起来很简单：它可以是一个巨大的性能提升器。从您机器上的内存位置获取对象，而不是每次都去远程服务器，这似乎是一个显而易见的选择，对吧？但有一些潜在的陷阱你需要考虑。以下是最重要的几点：
- en: '**Stale data**: Data might change. For instance, our NTP sample changes every
    millisecond. That being said, you might retrieve it from the server once and then
    add the local time that’s elapsed since you got it. It will eventually run out
    of sync (NTP servers are much more precise than your local machine), but I am
    sure it will not be that big of an issue soon. But data will get stale. You have
    to take that into account if you store data locally. How often will data change?
    How important is it that I have the latest version?'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过时数据**：数据可能会改变。例如，我们的NTP示例每毫秒都会改变。话虽如此，您可能从服务器检索一次，然后添加自您获取它以来经过的本地时间。它最终会失去同步（NTP服务器比您的本地机器更精确），但我确信这不会很快成为一个大问题。但数据会过时。如果您在本地存储数据，您必须考虑这一点。数据会多久改变一次？我拥有最新版本的重要性有多大？'
- en: '**Memory overhead**: Storing items locally on your machine takes up local memory.
    Storing large amounts of (large) objects takes up a lot of data, which might slow
    down your total application. It might even lead to out-of-memory exceptions. You
    must decide what you use frequently and what can be left on the server.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：在您的机器上本地存储项目会占用本地内存。存储大量（大）对象会占用大量数据，这可能会减慢您的整个应用程序。甚至可能导致内存不足异常。你必须决定你经常使用什么，什么可以留在服务器上。'
- en: '**Complexity in cache invalidation**: If data gets stale, you have to renew
    it. That requires code to monitor the data and refresh it when needed. That code
    can get quite complicated. You might have a separate thread that monitors your
    local cache, or you might decide when something pulls that data from the cache.
    Either way, you have to write a lot of monitoring code. That might overly complicate
    your software.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存失效的复杂性**：如果数据过时，你必须更新它。这需要代码来监控数据，并在需要时刷新它。这些代码可能会相当复杂。你可能有一个单独的线程来监控你的本地缓存，或者你可能决定在从缓存中拉取数据时进行。无论如何，你必须编写大量的监控代码。这可能会过度复杂化你的软件。'
- en: '**Security concerns**: Data on your machine is not always safe. If you store
    sensitive data on the local machine, it might be susceptible to snooping, especially
    if you store that cached data on a storage medium. Be sure to handle sensitive
    data safely.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全顾虑**：您机器上的数据并不总是安全的。如果您在本地机器上存储敏感数据，它可能会容易受到窃听，尤其是如果您将缓存数据存储在存储介质上。请确保安全地处理敏感数据。'
- en: '**Costs of cache misses**: When your application relies on getting data from
    the cache and only has it read from the remote server when you have a cache miss
    (thus, the item is not in the cache yet), you might have introduced a performance
    bottleneck. The logic of going through the cache, only to go out to the server
    if the data is not available, takes time. If the data you need is not needed that
    often, this is probably not the best case for caching.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存未命中成本**：当您的应用程序依赖于从缓存中获取数据，并且只有当您遇到缓存未命中（因此，项目尚未在缓存中）时才从远程服务器读取数据时，您可能引入了一个性能瓶颈。通过缓存进行逻辑操作，如果数据不可用，则转到服务器，这个过程需要时间。如果所需的数据不经常需要，这可能不是缓存的最佳案例。'
- en: '**Inconsistent data**: Suppose your app uses data from the cache, but another
    system or part of your system uses data from the server. In that case, there might
    be discrepancies between the data. This is not only stale data, but it means that
    two systems use different data – data they expect to be the same. If that might
    be an issue, caching might be a bad idea.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据不一致**：假设您的应用程序使用缓存中的数据，但另一个系统或您的系统的一部分使用服务器中的数据。在这种情况下，数据之间可能会有差异。这不仅是不新鲜的数据，这意味着两个系统使用不同的数据——他们期望相同的数据。如果这可能是一个问题，缓存可能不是一个好主意。'
- en: Caching can speed up your application, but be aware of the risks involved. Before
    implementing this, you should consider the potential risks and benefits.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存可以提高你的应用程序速度，但要注意其中涉及的风险。在实施之前，你应该考虑潜在的风险和收益。
- en: Compression and serialization
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩和序列化
- en: 'If transferring data over the wire is slow, transmitting or requesting less
    data can help. So, compression and how you serialize data can help. In earlier
    chapters, we looked into compression and serialization, so I will not go into
    detail here. But please remember: if there is one place where it helps a lot when
    you use compression, this is the place. You can speed up network communications
    if you reduce the payload by compressing it first. And of course, choosing the
    correct serialization technique also helps.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过电线传输数据较慢，传输或请求更少的数据可能会有所帮助。所以，压缩以及你如何序列化数据可能会有所帮助。在早期章节中，我们探讨了压缩和序列化，所以在这里我不会详细说明。但请记住：如果你使用压缩，这里是一个非常有帮助的地方。通过首先压缩来减少负载，你可以加快网络通信速度。当然，选择正确的序列化技术也有帮助。
- en: Since we already looked at how to do compression, I will not show you it again
    here. You already know how to use the `GZipStream` class in the `System.IO.Compression`
    namespace (yes, that was a hint).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经讨论了如何进行压缩，所以我不会在这里再次展示。你已经知道如何在 `System.IO.Compression` 命名空间中使用 `GZipStream`
    类（是的，这是一个提示）。
- en: Keep-alive connections
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持连接
- en: 'Creating a `TcpClient` is not that expensive per se. Opening a connection to
    a server is expensive, however. It can help to keep connections open as long as
    you can. The `HTTPClient` class is very good at that: it is built so that you
    can leave the connection open for a long time without getting in your way. If
    you use sockets, you can do something similar. However, keeping a connection open
    when you do not need it anymore is not a good idea. If you do not need it, please
    close the connection. Otherwise, by all means, keep it open. Of course, if you
    keep a connection open, you also affect the other party. A client that clings
    to a connection also limits the server. You have to think about this a lot and
    make the right decisions.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `TcpClient` 本身并不昂贵。然而，打开到服务器的连接却是昂贵的。尽量长时间保持连接打开是有帮助的。`HTTPClient` 类在这方面非常出色：它被设计成你可以长时间保持连接打开而不会妨碍你。如果你使用套接字，你也可以做类似的事情。然而，当你不再需要连接时保持连接打开并不是一个好主意。如果你不需要它，请关闭连接。否则，无论如何，保持它打开。当然，如果你保持连接打开，你也会影响到对方。一个紧紧抓住连接的客户也会限制服务器。你必须深思熟虑并做出正确的决定。
- en: Networking errors and time-outs
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络错误和超时
- en: 'When dealing with networks, there is one rule you have to keep in mind. That
    rule is: *assume that the other party is not answering* *your call*.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理网络时，有一条规则你必须牢记在心。那就是：*假设对方不会回应你的电话*。
- en: Servers go down. Connections can drop. Networks are unreachable. There are a
    whole lot of issues that will (not might!) happen.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器会宕机。连接可能会断开。网络不可达。会有很多问题（不是可能会发生的问题！）会发生。
- en: You must use defensive coding to ensure it doesn’t impact your code too much.
    Of course, if you rely on an external machine to get the data you need, and that
    machine is not available, you have a problem. But maybe you can get around it.
    Perhaps you can cache older data. Or, you can retry if something goes wrong.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用防御性编程来确保它不会过多地影响你的代码。当然，如果你依赖于外部机器来获取所需的数据，而这个机器不可用，你就有问题。但也许你可以绕过它。也许你可以缓存旧数据。或者，如果出现问题，你可以重试。
- en: Let me help you with some strategies you can use to deal with hiccups in the
    network.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我帮你提供一些你可以用来处理网络中断的策略。
- en: Using the HTTPClient wisely
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智慧地使用 HTTPClient
- en: The `HTTPClient` class has some neat tricks to help you with making the use
    of it more stable. For instance, connection pooling comes free and out of the
    box in this handy class. And they built that connection pooling in a pretty clever
    way.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPClient` 类有一些巧妙的技巧可以帮助你更稳定地使用它。例如，连接池在这个方便的类中是免费且开箱即用的。而且他们以一种相当巧妙的方式构建了这个连接池。'
- en: The general advice is to create one instance of `HTTPClient` and use that throughout
    your system. The class is smart enough to pool connections to a server. If you
    use the same `HTTPClient` to get data from another server, the class creates a
    new pool, so those connections also get pooled.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一般建议是创建一个 `HTTPClient` 实例并在整个系统中使用它。这个类足够智能，可以池化到服务器的连接。如果你使用同一个 `HTTPClient`
    从另一个服务器获取数据，这个类会创建一个新的池，因此这些连接也会被池化。
- en: 'Of course, be careful what you do: do not generate connections to hundreds
    of servers if you do not need them. They still take up memory in your system.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要小心你的行为：如果你不需要，不要生成到数百个服务器的连接。它们仍然会占用你的系统内存。
- en: Another way to make `HTTPClient` more resilient is to use a default configuration
    for your connections. I always ensure I set `DefaultRequestHeaders` so I know
    that I can handle the data coming in.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使`HTTPClient`更具弹性的另一种方法是使用默认配置来设置你的连接。我总是确保我设置了`DefaultRequestHeaders`，这样我知道我可以处理传入的数据。
- en: And I always make sure I have a `TimeOut` on my instance. That way, I know that
    the `HTTPClient` will not have to wait too long for data from the server.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是确保我的实例上有`TimeOut`。这样，我知道`HTTPClient`不会等待太久来从服务器获取数据。
- en: 'I suggest you use something such as a `Factory` to create your instances. I
    use one that looks like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你使用类似`Factory`的东西来创建你的实例。我使用的一个看起来像这样：
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This static class creates an instance of `HTTPClient` for me if needed. It tells
    the handler that it needs to use `Cookies` and that I do not want a proxy on my
    connection. I also set `DefaultRequestHeaders` and asked it to accept `application/json`
    data. I also added a nice user agent so the server knows who it is talking to.
    Finally, I set the `timeout` to 5 seconds.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个静态类在我需要时为我创建一个`HTTPClient`实例。它告诉处理程序它需要使用`Cookies`，并且我不希望在连接上使用代理。我还设置了`DefaultRequestHeaders`，并要求它接受`application/json`数据。我还添加了一个友好的用户代理，以便服务器知道它在和谁交谈。最后，我将`timeout`设置为5秒。
- en: 'If I need an `HTTPClient` instance, I can get it like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我需要一个`HTTPClient`实例，我可以这样获取它：
- en: '[PRE18]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first time I needed that client, it built it. But the second time and after
    that, it will pull it from the connection pool, making it a lot quicker and more
    resilient to mistakes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次我需要那个客户端时，它会构建它。但第二次以及之后，它将从连接池中提取它，这使得它更快，并且对错误更具弹性。
- en: I also ensure I do not use the `GetStringAsync()` method or `GetStreamAsync()`
    directly from `HTTPClient`. I first get the `Response` (of the type `HttpResponseMessage`)
    to check whether the result is valid. As we have seen, this is what the `IsSuccessStatusCode`
    property tells us.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我还确保我不直接从`HTTPClient`使用`GetStringAsync()`方法或`GetStreamAsync()`。我首先获取`Response`（类型为`HttpResponseMessage`），以检查结果是否有效。正如我们所看到的，这就是`IsSuccessStatusCode`属性告诉我们的。
- en: This way, your communications with an HTTP server will become faster and much
    more stable.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你与HTTP服务器的通信将会更快，并且更加稳定。
- en: Implementing retries with Polly
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Polly实现重试
- en: But of course, things will still go wrong. The server might be busy, or the
    network might be congested. The best way to get around that is to try again, and
    then again, until either it works or you give up.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，事情仍然可能会出错。服务器可能很忙，或者网络可能很拥挤。解决这个问题的最好方法是尝试再次尝试，然后再次尝试，直到它工作或者你放弃。
- en: You could write that logic yourself, but you would be better off using a standard
    library. The most used library that implements this is called **Polly**.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己编写那个逻辑，但使用标准库会更好。实现这个功能的常用库被称为**Polly**。
- en: 'So, let’s install that NuGet package in our application first. You can do so
    in the CLI by using this command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先在我们的应用程序中安装那个NuGet包。你可以在CLI中使用以下命令来这样做：
- en: '[PRE19]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once you have done that, we can change our `HttpClientFactory` class a bit.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以稍微修改一下我们的`HttpClientFactory`类。
- en: 'First, add a new `private static` field to that class:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，向那个类添加一个新的`private static`字段：
- en: '[PRE20]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is our `RetryPolicy`, which we will apply to the requests.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`RetryPolicy`，我们将将其应用于请求。
- en: 'At the end of the `CreateInstance` method in the `HttpClientFactory` class,
    add a call to a new method: `SetupRetryPolicy`. The method looks like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HttpClientFactory`类的`CreateInstance`方法末尾，添加对新方法的调用：`SetupRetryPolicy`。该方法看起来像这样：
- en: '[PRE21]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the static `Policy` class, we call the `Handle()` method. We give it the
    `HttpRequestException` type parameter. This way, the framework knows the trigger
    to start retrying. We also tell it to retry if `HttpResponseMessage.IsSuccesStatusCode`
    is set to false.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态`Policy`类中，我们调用`Handle()`方法。我们给它`HttpRequestException`类型参数。这样，框架就知道触发重试的条件。我们还告诉它，如果`HttpResponseMessage.IsSuccesStatusCode`设置为false，则进行重试。
- en: If one of those conditions arises, we tell the policy to `WaitAndRetryAsync`.
    We ask it to give it three retries after the first failure. The following parameter
    tells the `Policy` to wait for 2, 4, or 8 seconds (2 to the power of the retry
    number). So, it waits twice as long each time to give the server time to get its
    stuff in order.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现这些条件之一，我们告诉策略使用`WaitAndRetryAsync`。我们要求它在第一次失败后进行三次重试。以下参数告诉`Policy`等待2秒、4秒或8秒（2的幂次方重试次数）。因此，每次等待的时间是前一次的两倍，以便给服务器时间来整理其数据。
- en: We also give it a delegate that the framework will execute as soon as it starts
    to retry. In this case, we print out some messages to the console, telling it
    what failed, how long it will wait before it tries again, and how many times it
    has tried already.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还给它一个委托，框架将在开始重试时执行该委托。在这种情况下，我们打印一些消息到控制台，告诉它发生了什么失败，它将在尝试再次之前等待多长时间，以及它已经尝试了多少次。
- en: 'With that in place, we can rewrite how we ask the `HTTPClient` for data. In
    the previous example, I showed you how to get the `Instance` from the factory
    and then use that instance directly. I want to move that code to `HttpClientFactory`
    as well. But the call to the server must be wrapped up in our new `Policy`. The
    method looks like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以重新编写我们请求 `HTTPClient` 数据的方式。在之前的例子中，我向你展示了如何从工厂中获取 `Instance` 并直接使用该实例。我想将这段代码移动到
    `HttpClientFactory` 中。但调用服务器的请求必须被我们的新 `Policy` 包装。方法看起来是这样的：
- en: '[PRE22]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Instead of the user of our class calling `GetAsync(url)`, we do it for them
    using this wrapper method. But we wrap up that call in `_retryPolicy.ExecuteAsync()`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是让我们的类用户调用 `GetAsync(url)`，我们使用这个包装方法为他们做这件事。但我们把这个调用包装在 `_retryPolicy.ExecuteAsync()`
    中。
- en: 'Change the original code that uses this factory to look like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用此工厂的原代码更改为如下所示：
- en: '[PRE23]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Instead of calling `client.GetAsync()`, I now call `HttpClientFactory.GetAsync()`.
    The rest hasn’t changed. Well, that’s not entirely true. I also altered the URL
    a bit. I am not asking for `posts2` instead of `posts` in that URL. And that doesn’t
    exist. That should trigger our retry mechanism.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在不再调用 `client.GetAsync()`，而是调用 `HttpClientFactory.GetAsync()`。其余的都没有改变。嗯，这并不完全正确。我还稍微修改了URL。在那个URL中，我没有要求
    `posts2` 而不是 `posts`。而且那并不存在。这应该会触发我们的重试机制。
- en: Run it and see what happens. There you go – retries done the right way!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它并看看会发生什么。就这样——正确地完成了重试！
- en: The circuit breaker pattern
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断路器模式
- en: A similar pattern is the circuit breaker pattern. This pattern detects when
    connections are in a fault state and prevents the system from making calls to
    the server for a predefined period. If the connection raises errors, the circuit
    breaker opens and stops all communications to that server for a while. After that
    cooldown period, it opens a bit to allow another quick peek at the server. If
    it seems to work, it allows full traffic. Otherwise, it will give up and let you
    know things have gone wrong.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 类似模式的是断路器模式。这种模式检测连接是否处于故障状态，并防止系统在预定义的时间内对服务器进行调用。如果连接引发错误，断路器打开，并暂时停止与该服务器的所有通信。在那段冷却期之后，它会稍微打开一点，以便快速查看服务器。如果看起来工作正常，它将允许全流量。否则，它会放弃，并告诉你事情已经出错。
- en: The circuit breaker is also part of the Polly NuGet package.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器也是Polly NuGet包的一部分。
- en: Validating network availability
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证网络可用性
- en: Trying to connect to a server that doesn’t exist will result in errors. But
    what happens if your own network has an issue? In that case, it would look like
    all servers worldwide are down.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试连接一个不存在的服务器会导致错误。但如果你自己的网络有问题会怎样？在这种情况下，它看起来就像全球的所有服务器都宕机了。
- en: That last scenario doesn’t seem so likely, so verifying that our network is
    healthy would be nice before we blame the entire internet.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 那种最后一种情况似乎不太可能，所以在责怪整个互联网之前，验证我们的网络是健康的会很好。
- en: 'It turns out that it is not too hard to do so. All you need is one line of
    code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，这样做并不太难。你只需要一行代码：
- en: '[PRE24]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That’s all there is to it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部了。
- en: 'You can also interrogate each network adaptor in your machine like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以这样查询你机器上的每个网络适配器：
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can iterate through all network adapters and see what their status is. That
    can help us to select the suitable adapter and thus the right IP address if we
    want to be resilient against errors and failures.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历所有网络适配器并查看它们的状态。这可以帮助我们选择合适的适配器，从而在想要对错误和故障具有弹性时选择正确的IP地址。
- en: Monitoring and logging
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控和日志记录
- en: 'This one goes without saying: *the best way to solve issues is to log and monitor
    what is happening*. If you have extensive logging, you are much more likely to
    find problems if they occur. But let’s not worry about that too much for now.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点不言而喻：*解决问题的最佳方式是记录和监控正在发生的事情*。如果你有详细的日志记录，一旦出现问题，你更有可能找到问题。但现在我们不必过于担心这一点。
- en: If you follow these tips and tricks, you will still face network issues. They
    are inevitable. But at least network failures will not bring your system down.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循这些技巧和窍门，你仍然会遇到网络问题。这是不可避免的。但至少网络故障不会让你的系统崩溃。
- en: Next steps
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: In this chapter, we took a deep dive into networking. We broke out of the confines
    of the local machine and looked at all the good stuff that the BCL gives us when
    it comes to connecting to the outside world.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了网络。我们摆脱了本地机器的限制，并研究了BCL在连接到外部世界时为我们提供的所有好东西。
- en: We looked at default protocols such as HTTP, FTP, and SMTP. We also looked at
    sockets in case the predefined protocols are not good enough, such as when you
    want to look up the current time from a time server. We dove into asynchronous
    networking and talked a lot about performance and making our networking error-proof
    and more robust.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了默认协议，如HTTP、FTP和SMTP。我们还探讨了套接字，以防预定义的协议不够好，例如当你想从时间服务器查询当前时间时。我们深入研究了异步网络，并大量讨论了性能以及使我们的网络错误检测和更健壮的方法。
- en: 'Let’s be honest: almost no computer these days runs on its own. Most machines
    and thus the software running on them, are somehow connected to the outside world.
    Especially the things we as system programmers are interested in are not used
    by users, but instead by other software. Some of that software lives on other
    machines. This means it is imperative you know about networking. And now you do!'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 诚实地讲：如今几乎没有任何计算机是独立运行的。大多数机器以及运行在其上的软件，都以某种方式连接到外部世界。特别是我们作为系统程序员感兴趣的东西，并不是由用户使用，而是由其他软件使用。其中一些软件存在于其他机器上。这意味着你必须了解网络。现在你已经做到了！
- en: We did not talk about security and logging. Logging is something we touch on
    in [*Chapter 10*](B20924_11.xhtml#_idTextAnchor222). Security is the topic of
    [*Chapter 12*](B20924_13.xhtml#_idTextAnchor260). Yes, these topics are so important
    they deserve their own chapter.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有讨论安全和日志记录。日志记录是我们简要提及的[*第10章*](B20924_11.xhtml#_idTextAnchor222)的内容。安全是[*第12章*](B20924_13.xhtml#_idTextAnchor260)的主题。是的，这些话题如此重要，它们值得拥有自己的章节。
- en: But before we go there, let’s take a little trip to other platforms. Since systems
    programming works closely with devices, I thought it would be fun to dive into
    another device and see if we could talk to some fancy hardware. So, let’s go there
    next!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入之前，让我们先去其他平台看看。由于系统编程与设备紧密相关，我觉得深入另一个设备并看看我们是否能与一些高级硬件进行通信会很有趣。所以，让我们继续前进吧！
