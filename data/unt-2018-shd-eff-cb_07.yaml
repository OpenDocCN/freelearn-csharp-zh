- en: Fragment Shaders and Grab Passes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段着色器和抓取通道
- en: So far, we have relied on Surface Shaders. They have been designed to simplify
    the way shader coding works, providing meaningful tools for artists. If we want
    to push our knowledge of shaders further, we need to venture into the territory
    of Vertex and Fragment Shaders.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直依赖于表面着色器。它们被设计用来简化着色器编码的方式，为艺术家提供有意义的工具。如果我们想进一步推进我们对着色器的了解，我们需要进入顶点和片段着色器的领域。
- en: 'In this chapter, you will learn the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下配方：
- en: Understanding Vertex and Fragment Shaders
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解顶点和片段着色器
- en: Using grab passes to draw behind objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抓取通道在物体后面绘制
- en: Implementing a Glass Shader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现玻璃着色器
- en: Implementing a Water Shader for 2D games
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现二维游戏的着色器
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Compared to Surface Shaders, Vertex and Fragment Shaders come with little to
    no information about the physical properties that determine how light reflects
    on surfaces. What they lack in expressivity, they compensate for with power: Vertex
    and Fragment Shaders are not limited by physical constraints and are perfect for
    non-photorealistic effects. This chapter will focus on a technique called the
    **grab pass**, which allows these shaders to simulate deformations.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与表面着色器相比，顶点和片段着色器在确定光线如何反射到表面上的物理属性方面提供的信息很少或没有。它们在表现力方面的不足，通过强大的功能来补偿：顶点和片段着色器不受物理约束的限制，非常适合非真实感效果。本章将重点介绍一种称为**抓取通道**的技术，它允许这些着色器模拟变形。
- en: Understanding Vertex and Fragment Shaders
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解顶点和片段着色器
- en: 'The best way to understand how Vertex and Fragment Shaders work is by creating
    one yourself. This recipe will show you how to write one of these shaders, which
    will simply apply a texture to a model and multiply it by a given color, as shown
    in the following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 理解顶点和片段着色器工作原理的最好方式是创建一个自己。这个配方将向你展示如何编写这些着色器之一，它将简单地应用一个纹理到模型上，并将其乘以给定的颜色，如以下截图所示：
- en: '![](img/00154.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00154.jpeg)'
- en: Notice how it works similarly to how the Multiply filter in Photoshop works.
    That's because we will be doing the same calculation done there!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它的工作方式与Photoshop中的乘法滤镜相似。这是因为我们将执行那里所做的相同计算！
- en: The shader presented here is very simple, and it will be used as a starting
    base for all the other Vertex and Fragment Shaders.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的着色器非常简单，它将被用作所有其他顶点和片段着色器的起始基础。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need a new shader. Follow these steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要一个新的着色器。按照以下步骤操作：
- en: Create a new shader (`Multiply`).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的着色器（`Multiply`）。
- en: Create a new material (`MultiplyMat`) and assign the shader to it.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的材质（`MultiplyMat`）并将着色器分配给它。
- en: Bring the soldier prefab from the `Chapter 06 `| `Prefabs` folder into the scene,
    and attach the new material to the prefab's head. The head can be found in the
    `Soldier` child of the `Soldier` object.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将士兵预制体从`Chapter 06`|`Prefabs`文件夹拖入场景，并将新材质附加到预制体的头部。头部位于`Soldier`对象的`Soldier`子对象中。
- en: 'From there, in the Inspector tab, scroll down to the Skinned Mesh Renderer
    component and, under Materials, set Element 0 to the new materials. Lastly, in
    the `Albedo (RGB)` property, drag and drop the `Unity_soldier_Head_DIF_01` texture.
    The following screenshot should help demonstrate what we are looking for:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，在检查器选项卡中，向下滚动到Skinned Mesh Renderer组件，在材质下，将元素0设置为新材料。最后，在`Albedo (RGB)`属性中，拖放`Unity_soldier_Head_DIF_01`纹理。以下截图应该有助于展示我们正在寻找的内容：
- en: '![](img/00155.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00155.jpeg)'
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'In all the previous chapters, we have always been able to refit Surface Shaders.
    This is not the case any more, as Surface and Fragment Shaders are structurally
    different. We will need to implement the following changes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的章节中，我们总能重新配置表面着色器。现在不再是这样了，因为表面和片段着色器在结构上是不同的。我们需要实施以下更改：
- en: 'Delete all the properties of the shader, replacing them with the following:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除着色器的所有属性，用以下内容替换：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Delete all the code in the `SubShader` block and replace it with this:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`SubShader`块中的所有代码，并用以下内容替换：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save your shader script and return to the Unity editor. Once finished, modify
    the Color property of the `MultiplyMat` material and see that we get the result
    we are looking for:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的着色器脚本并返回到Unity编辑器。完成后，修改`MultiplyMat`材质的Color属性，并查看我们是否得到了预期的结果：
- en: '![](img/00156.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00156.jpeg)'
- en: This will also be the base for all future Vertex and Fragment Shaders.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将成为所有未来顶点和片段着色器的基础。
- en: How it works…
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'As the name suggests, Vertex and Fragment Shaders work in two steps. The model
    is first passed through a vertex function; the result is then inputted to a Fragment
    function. Both these functions are assigned using `#pragma` directives:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，顶点和片段着色器分为两个步骤工作。首先将模型传递给顶点函数；然后将结果输入到片段函数。这两个函数都使用`#pragma`指令进行分配：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, they are simply called `vert` and `frag`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它们简单地被称为`vert`和`frag`。
- en: Conceptually speaking, fragments are closely related to pixels; the term fragment
    is often used to refer to the collection of data necessary to draw a pixel. This
    is also why Vertex and Fragment Shaders are often called **Pixel Shaders**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，片段与像素密切相关；术语片段常用来指代绘制像素所需的数据集合。这也是为什么顶点和片段着色器常被称为**像素着色器**。
- en: 'The vertex function takes the input data in a structure that is defined as
    `vertInput` in the shader:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点函数接收在着色器中定义为`vertInput`的结构体中的输入数据：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Its name is totally arbitrary, but its content is not. Each field of the `struct`
    must be decorated with a **binding semantic**. This is a feature of Cg that allows
    us to mark variables so that they will be initialized with certain data, such
    as normal vectors and the vertex position. The binding semantic, `POSITION`, indicates
    that when `vertInput` is inputted to the vertex function, `pos` will contain the
    position of the current vertex. This is similar to the vertex field of the `appdata_full`
    structure in a Surface Shader. The main difference is that `pos` is represented
    in model coordinates (relative to the 3D object), which we need to convert to
    view coordinates manually (relative to the position on the screen).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它的名字完全是任意的，但它的内容却不是。`struct`中的每个字段都必须用**绑定语义**进行装饰。这是Cg的一个特性，允许我们标记变量，以便它们可以初始化为某些数据，例如法线向量和顶点位置。绑定语义`POSITION`表示当`vertInput`输入到顶点函数时，`pos`将包含当前顶点的位置。这与Surface
    Shader中`appdata_full`结构的顶点字段类似。主要区别在于`pos`是以模型坐标（相对于3D对象）表示的，我们需要手动将其转换为视图坐标（相对于屏幕上的位置）。
- en: The vertex function in a Surface Shader is used to alter the geometry of the
    model only. In a Vertex and Fragment Shader, instead, the vertex function is necessary
    to project the coordinates of the model to the screen.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在表面着色器中，顶点函数用于仅改变模型的几何形状。而在顶点和片段着色器中，顶点函数是必要的，用于将模型的坐标投影到屏幕上。
- en: 'The mathematics behind this conversion is beyond the scope of this chapter.
    However, this transformation can be achieved by using the `UnityObjectToClipPos`
    function, which will take a point from object space to the camera''s clip space
    in homogeneous coordinates. This is done by multiplying by the **model-view-projection
    matrix**, and it is essential to find the position of a vertex on the screen:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换背后的数学超出了本章的范围。然而，可以通过使用`UnityObjectToClipPos`函数来实现这种转换，该函数将点从对象空间转换为相机的裁剪空间（齐次坐标）。这是通过乘以**模型视图投影矩阵**来完成的，这对于找到屏幕上顶点的位置是至关重要的：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For more information on this and other helper functions that ShaderLab has built-in,
    check out [https://docs.unity3d.com/Manual/SL-BuiltinFunctions.html](https://docs.unity3d.com/Manual/SL-BuiltinFunctions.html).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此以及其他ShaderLab内置的辅助函数的更多信息，请查看[https://docs.unity3d.com/Manual/SL-BuiltinFunctions.html](https://docs.unity3d.com/Manual/SL-BuiltinFunctions.html)。
- en: 'The other piece of information initialized is `textcoord`, which uses the `TEXCOORD0`
    binding semantics to get the UV data of the first texture. No further processing
    is required, and this value can be passed directly to the fragment function (`frag`):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个初始化的信息是`textcoord`，它使用`TEXCOORD0`绑定语义来获取第一个纹理的UV数据。不需要进一步处理，这个值可以直接传递给片段函数（`frag`）：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While Unity will initialize `vertInput` for us, we are responsible for the
    initialization of `vertOutput`. Despite this, its fields still need to be decorated
    with binding semantics:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Unity会为我们初始化`vertInput`，但我们负责初始化`vertOutput`。尽管如此，其字段仍然需要用绑定语义进行装饰：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once the vertex function has initialized `vertOutput`, the structure is passed
    to the fragment function (`frag`). This samples the main texture of the model
    and multiplies it by the color provided.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦顶点函数初始化了`vertOutput`，该结构体就传递给片段函数（`frag`）。这将从模型的主要纹理中采样并乘以提供的颜色。
- en: As you can see, the Vertex and Fragment Shader have no knowledge of the physical
    properties of the material. This means that the material does not have the same
    effect by light sources, and it does not have data regarding how light reflects
    to create bumped surfaces compared to a Surface Shader; it works closer to the
    architecture of the graphics GPU.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，顶点和片段着色器没有关于材料物理属性的知识。这意味着材料在光源下不会产生相同的效果，并且它没有关于如何与表面着色器相比，通过反射光线创建凹凸表面的数据；它更接近图形GPU的架构。
- en: There's more…
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: One of the most confusing aspects of Vertex and Fragment Shaders is binding
    semantics. There are many others that you can use, and their meanings depend on
    context.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点和片段着色器中最令人困惑的方面之一是绑定语义。还有许多其他可以使用的语义，它们的含义取决于上下文。
- en: Input semantics
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入语义
- en: 'The binding semantics in the following table can be used in `vertInput`, which
    is the structure that Unity provides to the vertex function. The fields decorated
    with this semantics will be initialized automatically:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下表中的绑定语义可以在`vertInput`中使用，这是Unity提供给顶点函数的结构。带有此语义的字段将自动初始化：
- en: '| **Binding semantics** | **Description** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **绑定语义** | **描述** |'
- en: '| `POSITION`, `SV_POSITION` | The position of a vertex in world coordinates
    (object space) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `POSITION`, `SV_POSITION` | 顶点在世界坐标系（对象空间）中的位置 |'
- en: '| `NORMAL` | The normal of a vertex, relative to the world (not to the camera)
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `NORMAL` | 顶点的法线，相对于世界（而不是相机） |'
- en: '| `COLOR`, `COLOR0`, `DIFFUSE`, `SV_TARGET` | The color information stored
    in the vertex |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `COLOR`, `COLOR0`, `DIFFUSE`, `SV_TARGET` | 存储在顶点中的颜色信息 |'
- en: '| `COLOR1`, `SPECULAR` | The secondary color information stored in the vertex
    (usually the specular) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `COLOR1`, `SPECULAR` | 存储在顶点中的次颜色信息（通常是高光） |'
- en: '| `TEXCOORD0`, `TEXCOORD1`, …, `TEXCOORDi` | The i-th UV data stored in the
    vertex |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `TEXCOORD0`, `TEXCOORD1`, …, `TEXCOORDi` | 存储在顶点中的第i个UV数据 |'
- en: Output semantics
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出语义
- en: 'When binding, semantics are used in `vertOutput`; they do not automatically
    guarantee that fields will be initialized. Quite the opposite; it''s our responsibility
    to do so. The compiler will do its best to ensure that the fields are initialized
    with the right data:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定时，语义在`vertOutput`中使用；它们并不自动保证字段将被初始化。恰恰相反；这是我们的责任。编译器将尽力确保字段用正确的数据初始化：
- en: '| **Binding semantics** | **Description** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **绑定语义** | **描述** |'
- en: '| `POSITION`, `SV_POSITION`, `HPOS` | The position of a vertex in camera coordinates
    (clip space, from zero to one for each dimension) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `POSITION`, `SV_POSITION`, `HPOS` | 顶点在相机坐标系（裁剪空间，每个维度从零到一）中的位置 |'
- en: '| `COLOR`, `COLOR0`, `COL0`, `COL`, `SV_TARGET` | The front primary color |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `COLOR`, `COLOR0`, `COL0`, `COL`, `SV_TARGET` | 前主颜色 |'
- en: '| `COLOR1`, `COL1` | The front secondary color |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `COLOR1`, `COL1` | 前次颜色 |'
- en: '| `TEXCOORD0`, `TEXCOORD1`, …, `TEXCOORDi`, `TEXi` | The i-th UV data stored
    in the vertex |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `TEXCOORD0`, `TEXCOORD1`, …, `TEXCOORDi`, `TEXi` | 存储在顶点中的第i个UV数据 |'
- en: '| `WPOS` | The position, in pixels, in the window (origin in the lower left
    corner) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `WPOS` | 在窗口中的位置，以像素为单位（原点在左下角） |'
- en: If, for any reason, you need a field that will contain a different type of data,
    you can decorate it with one of the many `TEXCOORD` data available. The compiler
    will not allow fields to be left undecorated.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于任何原因，你需要一个包含不同类型数据的字段，你可以用可用的许多`TEXCOORD`数据之一来装饰它。编译器将不允许字段未装饰。
- en: See also
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can refer to the NVIDIA Reference Manual to check the other binding semantics
    that are available in Cg:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考NVIDIA参考手册来检查Cg中可用的其他绑定语义：
- en: '[http://developer.download.nvidia.com/cg/Cg_3.1/Cg-3.1_April2012_ReferenceManual.pdf](http://developer.download.nvidia.com/cg/Cg_3.1/Cg-3.1_April2012_ReferenceManual.pdf)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developer.download.nvidia.com/cg/Cg_3.1/Cg-3.1_April2012_ReferenceManual.pdf](http://developer.download.nvidia.com/cg/Cg_3.1/Cg-3.1_April2012_ReferenceManual.pdf)'
- en: Using the grab pass to draw behind objects
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用抓取通道在物体后面绘制
- en: In the *Adding transparency to PBR* recipe of [Chapter 5](part0131.html#3STPM0-e8c76c858d514bc3b1668fda96f8fa08), *Physically-Based
    Rendering*, we have seen how a material can be made transparent. Even if a transparent
    material can draw over a scene, it cannot change what has been drawn underneath
    it. This means that those Transparent Shaders cannot create distortions such as
    the ones typically seen in glass or water. In order to simulate them, we need
    to introduce another technique called a grab pass. This allows us to access what
    has been drawn on-screen so far, so that a shader can use it (or alter it) with
    no restrictions. To learn how to use grab passes, we will create a material that
    grabs what's rendered behind it and draws it again on the screen. It's a shader
    that, paradoxically, uses several operations to show no changes at all.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0131.html#3STPM0-e8c76c858d514bc3b1668fda96f8fa08)的“为PBR添加透明度”配方中，我们看到了如何使材质变得透明。即使透明材质可以在场景中绘制，它也不能改变其下已经绘制的内容。这意味着那些透明着色器不能创建像玻璃或水中通常看到的扭曲。为了模拟这些效果，我们需要引入另一种称为抓取遍历的技术。这允许我们访问到目前为止屏幕上已经绘制的内容，以便着色器可以无限制地使用它（或修改它）。为了学习如何使用抓取遍历，我们将创建一个材质，它抓取它后面的渲染内容并在屏幕上再次绘制。这是一个着色器，它矛盾地使用几个操作来显示没有任何变化。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe requires the following operations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要以下操作：
- en: Create a shader (`GrabShader`) that we will initialize later.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个着色器（`GrabShader`），我们稍后会初始化它。
- en: Create a material (`GrabMat`) to host the shader.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个材质（`GrabMat`）来托管着色器。
- en: 'Attach the material to a flat piece of geometry, such as a quad. Place it in
    front of some other object so that you cannot see through it. The quad will appear
    transparent as soon as the shader is complete:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质附加到一个平面几何体上，例如一个四边形。将其放置在某个其他物体前面，以便无法透过它。一旦着色器完成，四边形将看起来是透明的：
- en: '![](img/00157.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00157.jpeg)'
- en: How to do it…
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To use a grab pass, you need to follow these steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用抓取遍历，你需要遵循以下步骤：
- en: Remove the `Properties` section, and the `Input` section; this shader will not
    use any of them.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`Properties`部分和`Input`部分；这个着色器将不会使用它们。
- en: 'In the `SubShader` section, remove everything, and add the following to ensure
    the object is treated as being `Transparent`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SubShader`部分中，删除所有内容，并添加以下内容以确保对象被视为`Transparent`：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, below that, add a grab pass:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在下面添加一个抓取遍历：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After the `GrabPass`, we will need to add this extra pass:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GrabPass`之后，我们需要添加这个额外的遍历：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Save your script and return to the Unity editor. Upon getting back, you should
    notice your material now works the way you intend it to:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并返回Unity编辑器。返回后，你应该注意到你的材质现在按你期望的方式工作：
- en: '![](img/00158.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00158.jpeg)'
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This recipe not only introduces grab passes, but also Vertex and Fragment Shaders;
    for this reason, we have to analyze the shader in detail.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方不仅介绍了抓取遍历，还介绍了顶点和片段着色器；因此，我们必须详细分析着色器。
- en: So far, all the code has always been placed directly in the `SubShader` section.
    This is because our previous shaders required only a single pass. This time, two
    passes are required. The first one is the `GrabPass{}`, which is defined simply
    by `GrabPass{}`. The rest of the code is placed in the second pass, which is contained
    in a `Pass` block.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的代码都始终直接放置在`SubShader`部分中。这是因为我们之前的着色器只需要一个遍历。这次需要两个遍历。第一个是`GrabPass{}`，它简单地定义为`GrabPass{}`。其余的代码放置在第二个遍历中，它包含在一个`Pass`块中。
- en: 'The second pass is not structurally different from the shader shown in the
    first recipe of this chapter; we use the vertex function, `vert`, to get the position
    of the vertex, and then we give it a color in the Fragment function frag. The
    difference is that vert calculates another important detail: the UV data for the
    `GrabPass{}`. The `GrabPass{}` automatically creates a texture that can be referred
    to as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次遍历与本章第一个配方中显示的着色器在结构上没有区别；我们使用顶点函数`vert`来获取顶点的位置，然后在片段函数`frag`中给它一个颜色。区别在于`vert`计算了另一个重要的细节：`GrabPass{}`的UV数据。`GrabPass{}`会自动创建一个可以如下引用的纹理：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order to sample this texture, we need its UV data. The `ComputeGrabScreenPos`
    function returns data that we can use later to sample the grab texture correctly.
    This is done in the Fragment Shader using the following line:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了采样这个纹理，我们需要它的UV数据。`ComputeGrabScreenPos`函数返回我们可以用于以后正确采样抓取纹理的数据。这是在片段着色器中使用以下行完成的：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the standard way in which a texture is grabbed and applied to the screen
    in its correct position. If everything has been done correctly, this shader will
    simply clone what has been rendered behind the geometry. We will see in the following
    recipes how this technique can be used to create materials such as water and glass.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是纹理以正确位置抓取并应用于屏幕的标准方式。如果一切操作都正确，这个着色器将简单地克隆几何体后面渲染的内容。我们将在接下来的配方中看到这种技术如何用于创建水、玻璃等材料。
- en: There's more…
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Every time you use a material with `GrabPass{}`, Unity will have to render
    the screen to a texture. This operation is very expensive and limits the number
    of `GrabPass` instances that you can use in a game. Cg offers a slightly different
    variation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你使用带有`GrabPass{}`的材料时，Unity都不得不将屏幕渲染到纹理中。这个操作非常昂贵，限制了你在游戏中可以使用的`GrabPass`实例的数量。Cg提供了一种略有不同的变体：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This line not only allows you to give a name to the texture, but also shares
    the texture with all the materials that have a `GrabPass` called `TextureName`.
    This means that if you have ten materials, Unity will only do a single `GrabPass`
    and share the texture with all of them. The main problem of this technique is
    that it doesn't allow for effects that can be stacked. If you are creating a glass
    with this technique, you won't be able to have two glasses one after the other.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行不仅允许你给纹理命名，而且还与所有具有名为`TextureName`的`GrabPass`的材料共享纹理。这意味着如果你有十个材料，Unity将只执行一个`GrabPass`并将纹理与它们共享。这种技术的主要问题是它不允许堆叠效果。如果你使用这种技术创建玻璃，你将无法连续放置两个玻璃。
- en: Implementing a Glass Shader
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现玻璃着色器
- en: 'Glass is a very complicated material; it should not be a surprise that other
    chapters have already created shaders to simulate it in the *Adding transparency
    to PBR* recipe of [Chapter 5](part0131.html#3STPM0-e8c76c858d514bc3b1668fda96f8fa08), *Physically-Based
    Rendering*. We already know how to make our glasses semi-transparent to show the
    objects behind it perfectly and that works for a number of applications. However,
    most glasses are not perfect. For instance, if you look through a stain glass
    window you may notice distortions or deformations when you look through them.
    This recipe will teach you how to achieve that effect. The idea behind this effect
    is to use a Vertex and Fragment Shader with a `GrabPass`, and then sample the
    grab texture with a little change to its UV data to create a distortion. You can
    see the effect in the following screenshot, using the glass-stained textures from
    the Unity Standard Assets:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 玻璃是一种非常复杂的材料；在[第5章](part0131.html#3STPM0-e8c76c858d514bc3b1668fda96f8fa08)的“*在PBR中添加透明度*”配方中，其他章节已经创建了着色器来模拟它，这并不令人惊讶。我们已经知道如何使我们的玻璃半透明，以完美地显示其后的物体，并且这适用于许多应用。然而，大多数玻璃并不完美。例如，如果你透过彩色玻璃窗看，你可能会注意到当你透过它们看时会有扭曲或变形。这个配方将教会你如何实现这种效果。这个效果背后的想法是使用带有`GrabPass`的顶点和片段着色器，然后通过对其UV数据进行一点改变来采样抓取纹理，以创建扭曲。你可以在下面的屏幕截图中看到这个效果，使用了Unity标准资产中的玻璃染色纹理：
- en: '![](img/00159.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00159.jpeg)'
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The setup for this recipe is similar to the one presented previously in [Chapter
    6](part0158.html#4MLOS0-e8c76c858d514bc3b1668fda96f8fa08), *Vertex Functions*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方与之前在[第6章](part0158.html#4MLOS0-e8c76c858d514bc3b1668fda96f8fa08)中介绍的设置类似，*顶点函数*：
- en: Create a new Vertex and Fragment Shader. You can start by copying the one used
    in the previous recipe, *Using the grab pass to draw behind objects*, as a base
    by selecting it and hitting *Ctrl*+*D* to duplicate it. Once duplicated, change
    its name to `WindowShader`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的顶点和片段着色器。你可以通过选择它并按*Ctrl*+*D*来复制之前配方中使用的着色器，作为基础。一旦复制，将其名称更改为`WindowShader`。
- en: Create a material that will use the shader (`WindowMat`).
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将使用着色器的材料（`WindowMat`）。
- en: Assign the material to a quad or another flat geometry that will simulate your
    glass.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材料分配给一个四边形或其他平面几何体，以模拟你的玻璃。
- en: 'Place some objects behind it so that you can see the distortion effect:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置一些物体在其后面，以便你可以看到扭曲效果：
- en: '![](img/00160.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00160.jpeg)'
- en: How to do it…
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s start by editing the Vertex and Fragment Shaders:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从编辑顶点和片段着色器开始：
- en: 'Create a `Properties` block with these items in it:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下项目的`Properties`块：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add their variables in the second pass:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二次传递中添加它们的变量：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the texture information to the input and output structures:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将纹理信息添加到输入和输出结构中：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Transfer the UV data from the input to the output structure:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UV数据从输入传输到输出结构：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use the following Fragment function:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下片段函数：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This material is transparent, so it changes its tags in the `SubShader` block:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此材质是透明的，因此它在 `SubShader` 块中更改其标记：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What''s left now is to set the texture for the glass, and for a normal map
    to displace the grab texture:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在剩下的是设置玻璃的纹理，以及用于偏移抓取纹理的法线图：
- en: '![](img/00161.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00161.jpeg)'
- en: How it works…
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The core that this shader uses is a grab pass to take what has already been
    rendered on the screen. The part where the distortion takes place is in the Fragment
    function. Here, a normal map is unpacked and used to offset the UV data of the
    grab texture:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此着色器使用的核心是抓取通道，以获取屏幕上已经渲染的内容。扭曲发生的地方在片段函数中。在这里，一个法线图被解包并用于偏移抓取纹理的UV数据：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `_Magnitude` slider is used to determine how strong the effect is:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`_Magnitude` 滑块用于确定效果有多强：'
- en: '![](img/00162.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00162.jpeg)'
- en: There's more…
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This effect is very generic; it grabs the screen and creates a distortion based
    on a normal map. There is no reason why it shouldn't be used to simulate more
    interesting things. Many games use distortions around explosions or other sci-fi
    devices. This material can be applied to a sphere and, with a different normal
    map, it would simulate the heat wave of an explosion perfectly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此效果非常通用；它抓取屏幕并根据法线图创建扭曲。没有理由它不能用来模拟更有趣的东西。许多游戏使用爆炸或其他科幻设备周围的扭曲。此材质可以应用于球体，并且使用不同的法线图，它可以完美地模拟爆炸的热浪。
- en: Implementing a Water Shader for 2D games
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为2D游戏实现水着色器
- en: 'The Glass Shader introduced in the previous recipe is static; its distortion
    never changes. It takes just a few changes to convert it to an animated material,
    making it perfect for 2D games that feature water. This uses a similar technique
    to the one shown in [Chapter 6](part0158.html#4MLOS0-e8c76c858d514bc3b1668fda96f8fa08), *Vertex
    Functions*, in the recipe entitled *Animating Vertices in a Surface Shader*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中引入的玻璃着色器是静态的；其扭曲从不改变。只需进行一些更改即可将其转换为动画材质，使其非常适合具有水的2D游戏。这使用与 [第6章](part0158.html#4MLOS0-e8c76c858d514bc3b1668fda96f8fa08)
    中 *Vertex Functions* 配方中显示的类似技术：
- en: '![](img/00163.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00163.jpeg)'
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is based on the Vertex and Fragment Shaders described in the *Using
    the grab pass to draw behind objects* recipe, as it will rely heavily on `GrabPass`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于 *使用抓取通道绘制在物体后面* 配方中描述的顶点和片段着色器，因为它将严重依赖于 `GrabPass`。
- en: Create a new Vertex and Fragment Shader. You can start by copying the one used
    in the previous recipe, *Using the grab pass to draw behind objects*, as a base
    by selecting it and hitting *Ctrl*+*D* to duplicate it. Once duplicated, change
    its name to `WaterShader`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的顶点着色器和片段着色器。你可以通过选择它并按 *Ctrl*+*D* 复制来以“使用抓取通道绘制在物体后面”中使用的着色器作为基础，然后将其名称更改为
    `WaterShader`。
- en: Create a material that will use the shader (`WaterMat`).
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将使用着色器的材质（`WaterMat`）。
- en: 'Assign the material to a flat geometry that will represent your 2D water. In
    order for this effect to work, you should have something rendered behind it so
    that you can see the water-like displacement:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质分配给一个平面几何体，该几何体将代表你的2D水。为了使此效果生效，你应该在它后面渲染一些内容，以便你可以看到类似水的位移：
- en: '![](img/00164.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00164.jpeg)'
- en: 'This recipe requires a noise texture, which is used to get pseudo-random values.
    It is important that you choose a seamless noise texture, such as the ones generated
    by tileable 2D Perlin noise, as shown in the following screenshot. This ensures
    that when the material is applied to a large object, you will not see any discontinuity.
    In order for this effect to work, the texture has to be imported in Repeat mode.
    If you want a smooth and continuous look for your water, you should also set it
    to Bilinear from Inspector. These settings ensure that the texture is sampled
    correctly from the shader:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个配方需要一个噪声纹理，它用于获取伪随机值。选择无缝噪声纹理非常重要，例如由可平铺的2D Perlin噪声生成的纹理，如下面的截图所示。这确保了当材质应用于大型物体时，你不会看到任何不连续性。为了使此效果生效，纹理必须以重复模式导入。如果你想为你的水创建平滑且连续的外观，你还应该将其设置为从检查器中的双线性。这些设置确保从着色器正确采样纹理：
- en: '![](img/00165.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00165.jpeg)'
- en: You can find an example noise texture in `Chapter 6` | `Textures` folder of
    the book's example code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书的示例代码的 `第6章` | `纹理` 文件夹中找到一个示例噪声纹理。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create this animated effect, you can start by refitting the shader. Follow
    these steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个动画效果，你可以从重新调整着色器开始。按照以下步骤操作：
- en: 'Add the following properties:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下属性：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add their respective variables to the second pass of the shader:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们各自的变量添加到着色器的第二次传递中：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define the following input and output structures for the vertex function:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为顶点函数定义以下输入和输出结构：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This shader needs to know the exact position of the space of every fragment.
    To do this, update the vertex function to the following:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个着色器需要知道每个片段空间的确切位置。为此，更新顶点函数如下：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Use the following Fragment function:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下片段函数：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Save your script and return to the Unity editor. Afterward, select your Water
    Material (`WatMat`)and apply the noise texture. Afterward, tweak the properties
    in the Water Material and notice how it modifies the things behind it.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并返回Unity编辑器。之后，选择你的水材质（`WatMat`）并应用噪声纹理。之后，调整水材质中的属性，注意它如何修改其后的内容。
- en: '![](img/00166.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00166.jpeg)'
- en: How it works…
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This shader is very similar to the one introduced in the *Implementing a Glass
    Shader* recipe. The major difference is that this is an animated material; the
    displacement is not generated from a normal map, but takes into account the current
    time in order to create a constant animation. The code that displaces the UV data
    of the grab texture seems quite complicated; let''s try to understand how it has
    been generated. The idea behind it is that a sinusoid function is used to make
    the water oscillate. This effect needs to evolve over time; to achieve this effect,
    the distortion generated by the shader depends on the current time that is retrieved
    with the built-in variable, `_Time`. The `_Period` variable determines the period
    of the sinusoid, which means how fast the waves appear:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器与在*实现玻璃着色器*配方中介绍的那个非常相似。主要区别在于这是一个动画材质；位移不是从法线图中生成的，而是考虑当前时间以创建持续的动画。位移UV数据的代码似乎相当复杂；让我们尝试理解它是如何生成的。其背后的想法是使用正弦函数使水振荡。这个效果需要随时间演变；为了实现这个效果，着色器生成的扭曲取决于通过内置变量`_Time`检索的当前时间。`_Period`变量决定了正弦波的周期，这意味着波浪出现的速度：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The problem with this code is that you have the same displacement on the *X*
    and *Y* axes; as a result, the entire grab texture will rotate in a circular motion,
    which looks nothing like water. We obviously need to add some randomness to this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于你在X轴和Y轴上有相同的位移；因此，整个抓取纹理将以圆形运动旋转，看起来根本不像水。显然，我们需要添加一些随机性。
- en: 'The most common way to add random behaviors to shaders is by including a noise
    texture. The problem now is to find a way to sample the texture at seemingly random
    positions. The best way to avoid seeing an obvious sinusoid pattern is to use
    the sine waves as an offset in the UV data of the `_NoiseTex` texture:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 向着色器添加随机行为的最常见方法是包含一个噪声纹理。现在的问题是找到一种在看似随机位置采样纹理的方法。为了避免看到明显的正弦波模式，最好的方法是在`_NoiseTex`纹理的UV数据中使用正弦波作为偏移量：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `_Scale` variable determines the size of the waves. This solution is closer
    to the final version but has a severe issue—if the water quad moves, the UV data
    follows it and you can see the water waves following the material rather than
    being anchored to the background. To solve this, we need to use the world position
    of the current fragment as the initial position for the UV data:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`_Scale`变量决定了波浪的大小。这个解决方案更接近最终版本，但有一个严重的问题——如果水四边形移动，UV数据会跟随它，你会看到水波跟随材质而不是锚定在背景上。为了解决这个问题，我们需要使用当前片段的世界位置作为UV数据的初始位置：'
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result is a pleasant, seamless distortion, which doesn't move in any clear
    direction.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一种愉快、无缝的扭曲，不会向任何明显的方向移动。
- en: 'We can also improve the readability of the code by breaking apart the distortion
    into smaller steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将扭曲分解成更小的步骤来提高代码的可读性：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That is what you should see in the final result.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最终结果中你应该看到的内容。
- en: As happens with all these special effects, there is no perfect solution. This
    recipe shows you a technique to create water-like distortion, but you are encouraged
    to play with it until you find an effect that fits the aesthetics of your game.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有这些特殊效果一样，没有完美的解决方案。这个配方向你展示了一种创建类似水波扭曲的技术，但鼓励你尝试，直到找到适合你游戏美学的效果。
