<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Assessments</h1>
                </header>
            
            <article>
                


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 1</h1>
                </header>
            
            <article>
                
<ol>
<li>A software architect needs to be aware of any technology that can help them solve problems faster and ensure they have better quality.</li>
<li>Azure provides, and keeps evolving, lots of components that a software architect can implement in solutions.</li>
<li>The process model can help you understand the team you have, the kind of solution you will provide, and the budget that's available.</li>
<li>A software architect pays attention to any user or system requirement that can have an effect on performance, security, usability, and so on.</li>
<li>All of them, but the non-functional requirements need to be given more attention.</li>
<li>Design Thinking is a tool that helps software architects define exactly what users need. </li>
<li>User Stories are good when we want to define functional requirements.</li>
<li>Caching, asynchronous programming, and correct object allocation.</li>
<li>To check that the implementation is correct, a software architect compares it with models and prototypes that have already been designed and validated.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 2</h1>
                </header>
            
            <article>
                
<ol>
<li>Vertically and horizontally.</li>
<li>Yes, you can deploy automatically to an already defined web app or create a new one directly using Visual Studio.</li>
<li>To take advantage of available hardware resources by minimizing the time they remain idle.</li>
<li>Code behavior is deterministic, so it is easy to debug. No deadlocks are possible and the execution flow mimics the flow of sequential code, which means it's easier to design and understand.</li>
<li>Because the right order minimizes the number of gestures that are needed to fill in a form.</li>
</ol>
<ol start="6">
<li>Because it allows for the manipulation of path files in a way that is independent of the operating system.</li>
<li>It can be used with several .NET Core <span>versions, as well as with several versions of the classic .NET framework.</span></li>
<li>Console, .NET Core, and .NET standard class library; ASP.NET Core, Test, and Microservices.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 3</h1>
                </header>
            
            <article>
                
<ol>
<li>No, it is available for several platforms.</li>
<li>Yes, every step involved in the development/deployment process can be automated, including deployment to production.</li>
<li>Automatic, manual, and load test plans.</li>
<li>Yes, they can <span>–</span> through Azure DevOps feeds.</li>
<li>To manage requirements and to organize the whole development process.</li>
<li>Epic work items represent high-level system subparts that are made up of several features.</li>
<li>A children-father relationship.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 4</h1>
                </header>
            
            <article>
                
<ol>
<li>IaaS is a good option when you are migrating from an on-premise solution or if you have an infrastructure team.</li>
<li>PaaS is the best option for fast and safe software delivery in systems where the team is focused on software development.</li>
<li>If the solution you intend to deliver is provided by a well-known player, such as a SaaS, you should consider using it.</li>
<li>Serverless is definitely an option when you are building a new system where you don't have people who specialize in infrastructure and you don't want to worry about scalability. </li>
<li>Azure SQL Server Database can be up in minutes and you will have all the power of a Microsoft SQL Server afterward.</li>
<li>Azure provides a set of services called Azure Cognitive Services. These services provide solutions for vision, speech, language, search, and knowledge.</li>
</ol>
<ol start="7">
<li>In a hybrid scenario, you have the flexibility to decide on the best solution for each part of your system while respecting the solution's path and driving it into the future.</li>
<li>To allow update/write parallelism.</li>
<li>The third argument that's passed to the <kbd>Create</kbd> method, which creates proxy instances, allows us to specify permitted targets for communication. In general, the third argument of the <kbd>ServiceReplicaListener</kbd> constructor specifies whether the listener will be created on secondary replicas or not.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 5</h1>
                </header>
            
            <article>
                
<ol>
<li>The modularity of code and deployment modularity.</li>
<li>No, other important advantages include handling the development team and the whole CI/CD cycle well, and the possibility of mixing heterogeneous technologies easily and effectively.</li>
<li>A library that helps us implement resilient communication.</li>
<li>It is in the <kbd>HostBuilder</kbd> method that you can declare dependency injection and hosted services.</li>
<li>Once you've installed Docker on your development machine, you can develop, debug, and deploy Dockerized .NET Core applications. You can also add Docker images to Service Fabric applications that are being handled with Visual Studio.</li>
<li>The one based on Kubernetes <kbd>.yaml</kbd> files.</li>
<li>The one that's exposed to traffic from outside the cluster and is accessible through the cluster's URI.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 6</h1>
                </header>
            
            <article>
                
<ol>
<li>With the help of database-dependent providers.</li>
<li>Either by calling them <kbd>Id</kbd> or by decorating them with the <kbd>Key</kbd> attribute.</li>
<li>With the <kbd>MaxLength</kbd> and <kbd>MinLength</kbd> attributes.</li>
<li>With something similar to: <kbd>builder.Entity&lt;Package&gt;().HasIndex(m =&gt; m.Name);</kbd>.</li>
</ol>
<ol start="5">
<li>With something similar to <kbd>builder.Entity&lt;Destination&gt;()</kbd>:<br/>
<kbd>.HasMany(m =&gt; m.Packages)</kbd><br/>
<kbd>.WithOne(m =&gt; m.MyDestination)</kbd><br/>
<kbd>.HasForeignKey(m =&gt; m.DestinationId)</kbd><br/>
<kbd>.OnDelete(DeleteBehavior.Cascade);</kbd></li>
<li>Add-Migration and Update-Database.</li>
<li>No, but you can forcefully include them with the <kbd>Include</kbd> LINQ clause.</li>
<li>Yes, it is, thanks to the <kbd>Select</kbd> LINQ clause.</li>
<li>By calling <kbd>context.Database.Migrate()</kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 7</h1>
                </header>
            
            <article>
                
<ol>
<li>No, it is an in-memory dictionary that can be used as a cache or for other in-memory storage needs.</li>
<li>Yes, they are. Most of this chapter's sections are dedicated to explaining why. </li>
<li>Write operations.</li>
<li>The main weaknesses of NoSQL databases are their consistency and transactions, while their main advantage is performance, especially when it comes to handling distributed writes.</li>
<li><span>Eventual, Consistency Prefix, Session, Bounded Staleness, Strong.</span></li>
<li>No, they are not efficient in a distributed environment. GUID-based strings perform better, since their uniqueness is automatic and doesn't require synchronization operations.</li>
<li><kbd>OwnsMany</kbd> and <kbd>OwnsOne</kbd>.</li>
<li>Yes, they can. Once you use <kbd>SelectMany</kbd>, indices can be used to search for nested objects.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 8</h1>
                </header>
            
            <article>
                
<ol>
<li>Azure Functions is an Azure PaaS component that allows you to implement FaaS solutions.</li>
<li>You can program Azure Functions in different languages, such as C#, F#, and Node. You can also create functions using Azure Portal and Visual Studio VS Code.</li>
</ol>
<ol start="3">
<li>There are two plan options in Azure Functions. The first plan is the Consumption Plan, where you are charged according to the amount you use. The second plan is the App Service Plan, where you share your App Service resources with the function's needs.</li>
<li>The process of deploying Functions in Visual Studio is the same as in web app deployment.</li>
<li>There are lots of ways we can trigger Azure Functions, such as using Blob Storage, Cosmos DB, Event Grid, Event Hubs, HTTP, Microsoft Graph Events, Queue storage, Service Bus, Timer, and Webhooks.</li>
<li>Azure Functions v1 needs the .NET Framework Engine, whereas v2 needs .NET Core.</li>
<li>The execution of every Azure Function can be monitored by Application Insights. Here, you can check the time it took to process, resource usage, errors, and exceptions that happened in each function call.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 9</h1>
                </header>
            
            <article>
                
<ol>
<li>Design patterns are good solutions to common problems in software development.</li>
<li>While design patterns give you code implementation for typical problems we face in development, design principles help you select the best options when it comes to implementing the software architecture.</li>
<li>The Builder Pattern will help you generate sophisticated objects without the need to define them in the class you are going to use them in. </li>
<li><span>The Factory Pattern is really useful in situations where you have multiple kinds of object from the same abstraction and you don't know which of them needs to be created by the time you start coding. </span></li>
<li><span>The Singleton Pattern is useful when you need a class that has only one instance during the software's execution. </span></li>
<li><span>The Proxy Pattern is used when you need to provide an object that controls access to another object. </span></li>
<li><span>The Command Pattern is used when you need to execute a <em>command</em> that will affect the behavior of an object.</span></li>
<li><span>The Publisher/Subscriber Pattern is useful when you need to provide information about an object to a group of other objects. </span></li>
<li>The DI Pattern is useful if you want <span>to implement the Dependency Inversion principle.</span></li>
</ol>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 10</h1>
                </header>
            
            <article>
                
<ol>
<li>Changes in the language used by experts and changes in the meaning of words.</li>
<li>Domain mapping.</li>
<li>No; the whole communication passes through the entity, that is, the aggregate root.</li>
<li>Because aggregates represent part-subpart hierarchies.</li>
<li>Just one, since repositories are aggregate-centric.</li>
<li>The application layer manipulates repository interfaces. Repository implementations are registered in the dependency injection engine.</li>
<li>To coordinate in single transactions operations on several aggregates.</li>
<li>The specifications for updates and queries are usually quite different, especially in simple CRUD systems. The reason for its strongest form is mainly the optimization of query response times.</li>
<li>Dependency injection.</li>
<li>No; a serious impact analysis must be performed so that we can adopt it.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 11</h1>
                </header>
            
            <article>
                
<ol>
<li>No, since you will have lots of duplicate code in this approach, which will cause difficulties when it comes to maintenance.</li>
<li>The best approach for code reuse is creating libraries.</li>
<li>Yes. You can find components that have already been created in the libraries you've created before and then increase these libraries by creating new components that can be reused in the future.</li>
<li>The .NET Standard is a specification that allows compatibility between different frameworks of .NET, <span>from .NET Framework to Unity. .NET Core is one .NET implementation and is open source.</span></li>
<li>By creating a .NET Standard library, you will be able to use it in different .NET implementations, such as .NET Core, the .NET Framework, and Xamarin.</li>
<li>You can enable code reuse using object-oriented principles (inheritance, encapsulation, abstraction, and polymorphism).</li>
<li><span>Generics is a sophisticated implementation that simplifies how objects with the same characteristics are treated by defining a placeholder that will be replaced with the specific type at compile time. </span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 12</h1>
                </header>
            
            <article>
                
<ol>
<li>No, since this would violate the principle that a service reaction to a request must depend on the request itself and not on other messages/requests that had previously been exchanged with the client.</li>
<li>No, since this would violate the interoperability constraint.</li>
<li>Yes, it can. The primary action of a POST must be creation, but a delete can be performed as a side-effect.</li>
<li>Three, that is, Base64 encoding of the header and body plus the signature.</li>
<li>From the request body.</li>
<li>With the <kbd>ApiController</kbd> attribute.</li>
<li>The <kbd>ProducesResponseType</kbd> attribute.</li>
<li>With the <kbd>Route</kbd> and <kbd>Http&lt;verb&gt;</kbd> attributes.</li>
<li>Something like <kbd>services.AddHttpClient&lt;MyProxy&gt;()</kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 13</h1>
                </header>
            
            <article>
                
<ol>
<li>Developer error pages and developer database error pages, production error pages, hosts, HTTPS redirection, routing, authentication and authorization, and endpoint invokers.</li>
<li>No.</li>
<li>False. Several tag helpers can be invoked on the same tag.</li>
<li><kbd>ModelState.IsValid</kbd>.</li>
<li><kbd>@RenderBody()</kbd>.</li>
<li>We can use <kbd>@RenderSection("Scripts", required: false)</kbd>.</li>
<li>We can use <kbd>return View("viewname", ViewModel)</kbd>.</li>
<li>Three.</li>
<li>No; there is also the <kbd>ViewState</kbd> dictionary.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 14</h1>
                </header>
            
            <article>
                
<ol>
<li>Maintainability gives you the opportunity to deliver the software you designed quickly. It also allows you to fix bugs easily.</li>
<li>Cyclomatic complexity is a metric that detects the number of nodes a method has. The higher the number, the worse the effect.</li>
<li>A version control system will guarantee the integrity of your source code, giving you the opportunity to analyze the history of each modification that you've made.</li>
<li>Try-catch is a way to control exceptions that have been invoked by the code you are writing. Try-finally is a way to guarantee that, even with an exception inside the try-block, the finally block will carry out its process. You can use try-catch-finally when you want to solve both situations in the same piece of code.</li>
<li>A garbage collector is a .NET Core/.NET Framework system that monitors your application and detects objects that you aren't using anymore. It disposes of these objects to release memory.</li>
<li>The <kbd>IDisposable</kbd> interface is important in classes that instantiate objects that need to be disposed of by the programmer since the garbage collector cannot dispose of them. </li>
<li>.NET Core encapsulates some design patterns in some of its libraries in a way that can guarantee safer code, such as with dependency injection and Builder.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 15</h1>
                </header>
            
            <article>
                
<ol>
<li>Because most of the tests must be repeated after any software changes occur.</li>
<li>Because the probability of exactly the same error occurring in a unit test and in its associated application code is very low.</li>
<li><span> </span><kbd>[Theory]</kbd><span> </span>is used when the test method defines several tests, while<span> </span><kbd>[Fact]</kbd><span> </span>is used when the test method defines just one test.</li>
<li><kbd>Assert</kbd>.</li>
<li><kbd>Setup</kbd>, <kbd>Returns</kbd>, and <kbd>ReturnsAsync</kbd>.</li>
<li>Yes; with <kbd>ReturnAsync</kbd>.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 16</h1>
                </header>
            
            <article>
                
<ol>
<li>Well-written code is code that any person skilled in that programming language can handle, modify, and evolve.</li>
<li>Roslyn is the .NET Compiler that's used for code analysis inside Visual Studio.</li>
<li>Code analysis is a practice that considers the way the code is written to detect bad practices before compilation. </li>
<li>Code analysis can find problems that happen even with apparently good software, such as memory leaks and bad programming practices. </li>
<li>Roslyn can be programmed for code analysis.</li>
<li>Visual Studio Extensions are tools that have been programmed to run inside Visual Studio. These tools can help you out in some cases where Visual Studio IDE doesn't have the appropriate feature for you to use.</li>
<li>Microsoft Code Analysis, SonarLint, and Code Cracker.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 17</h1>
                </header>
            
            <article>
                
<ol>
<li>To maximize the value that the software provides for the target organization.</li>
<li>No; it requires the acquisition of all competencies that are required to maximize the value added by the software.</li>
<li>Because when a new user subscribes, its tenant must be created automatically, and because new software updates must be distributed to all the customer's infrastructures.</li>
<li>Yes; Terraform is an example.</li>
<li>Azure pipelines.</li>
<li>Your business depends on the SaaS supplier, so its reliability is fundamental.</li>
<li>No; scalability is just as important as fault tolerance and automatic fault recovery.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 18</h1>
                </header>
            
            <article>
                
<ol>
<li>DevOps is the approach of delivering value to the end user continuously. To do this with success, continuous integration, continuous delivery, and continuous feedback <span>must be undertaken.</span></li>
<li>Continuous integration allows you to check the quality of the software you are delivering every single time you commit a change. You can do this by turning on this feature in Azure DevOps.</li>
<li>Continuous delivery allows you to deploy a solution once you are sure that all the quality checks have passed the tests you designed. Azure DevOps helps you with that by providing you with relevant tools.</li>
<li>Continuous Feedback is the adoption of tools in the DevOps life cycle that enable fast feedback when it comes to performance, usability, and other aspects of the application you are developing. </li>
<li>The build pipeline will let you run tasks for building and testing your application, while the release pipeline will give you the opportunity to define how the application will be deployed in each scenario.</li>
<li>Application Insights is a helpful tool for monitoring the health of the system you've deployed, which makes it a fantastic continuous feedback tool.</li>
<li><span>Test &amp; Feedback is a tool </span>that allows stakeholders to analyze the software you are developing and enables a connection with Azure DevOps to open tasks and even bugs.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 19</h1>
                </header>
            
            <article>
                
<ol>
<li><span>It is an approach that makes sure that every single commit to the code repository is built and tested.</span></li>
<li><span>Yes, you can have DevOps separately and then enable Continuous Delivery later. Your team and process need to be ready and attentive for this to happen.</span></li>
<li><span>All of these risks may cause damage to your production environment. You can have, for example, a feature that isn't ready but has been deployed, you can cause a stop at a bad time for your customers, or you can even suffer a bad collateral effect due to an incorrect fix.</span></li>
<li><span>A multi-stage environment protects production from bad releases.</span></li>
<li><span>Automated tests</span> anticipate<span> bugs and bad behaviors in preview scenarios.</span></li>
</ol>
<ol start="6">
<li>Pull requests allow code reviews before commits are made in the master branch.</li>
<li>No; pull requests can help you in any development approach where you have GIT as your source control.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Chapter 20</h1>
                </header>
            
            <article>
                
<ol>
<li>No; it depends on the complexity of the user interface and how often it changes.</li>
<li>The ASP.NET Core pipeline isn't executed, but inputs are passed directly to controllers.</li>
<li>Use of the <kbd>Microsoft.AspNetCore.Mvc.Testing</kbd> NuGet package.</li>
<li>Use of the <kbd>AngleSharp</kbd> NuGet package.</li>
</ol>


            </article>

            
        </section>
    </body></html>