- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Best Practices in Coding C# 12
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 12 编码的最佳实践
- en: When you are the software architect on a project, it is your responsibility
    to define and/or maintain a coding standard that will direct the team to program
    according to the expectations of the company. This chapter covers some of the
    **best practices** in coding that will help developers like you program safe,
    simple, and maintainable software. It also includes tips and tricks for coding
    in **C#**. Although coding can be considered an art, writing understandable code
    is closer to a philosophy. In this chapter, we also discuss practices that you,
    as a software architect, need to propagate to your developers, with techniques
    and tools for code analysis, so that you have well-written code for your projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你是项目中的软件架构师时，你的责任是定义和/或维护一个编码标准，这将指导团队根据公司的期望进行编程。本章涵盖了编码的一些 **最佳实践**，这将帮助像你这样的开发者编写安全、简单和可维护的软件。它还包括在
    **C#** 中编码的技巧和窍门。虽然编码可以被认为是一种艺术，但编写可理解的代码更接近于一种哲学。在本章中，我们还讨论了你作为软件架构师需要传播给开发者的实践，包括代码分析的技术和工具，以便你为项目拥有编写良好的代码。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How the complexity of your code can affect performance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码复杂性如何影响性能
- en: The importance of using a version control system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用版本控制系统的必要性
- en: Writing safe code in C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 中编写安全的代码
- en: .NET 8 tips and tricks for coding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 8 编码的技巧和窍门
- en: Identifying well-written code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别编写良好的代码
- en: '**C# 12** was launched together with **.NET 8**. However, the practices presented
    here can be used in many versions of .NET, since they refer to the basics of programming
    C#. By the end of the chapter, you will be able to define which tools you are
    going to incorporate into your software development life cycle to facilitate code
    analysis.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**C# 12** 与 **.NET 8** 一起发布。然而，这里介绍的做法可以应用于许多版本的 .NET，因为它们涉及 C# 编程的基础。到本章结束时，你将能够定义你打算将哪些工具纳入你的软件开发生命周期以促进代码分析。'
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires, at least, the Visual Studio 2022 free *Community Edition*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章至少需要 Visual Studio 2022 的免费 *Community Edition*。
- en: The simpler your code, the better a programmer you are
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的代码越简单，你作为程序员的水平就越高
- en: For many people, a good programmer is one who writes complex code. However,
    the evolution of maturity in software development means there is a different way
    of thinking about it. Complexity does not mean a good job; it means poor code
    quality. Some incredible scientists and researchers have confirmed this theory
    and emphasized that professional code needs to be focused on time, high quality,
    and budget.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，一个好的程序员是编写复杂代码的人。然而，软件开发成熟度的演变意味着对此有不同的思考方式。复杂性并不意味着工作做得好；它意味着代码质量差。一些令人难以置信的科学家和研究人员已经证实了这一理论，并强调专业代码需要关注时间、高质量和预算。
- en: Even when you have a complex scenario on your hands, if you reduce ambiguities
    and clarify the process of what you are coding, especially by using good names
    for methods and variables, which contribute to making your code “self-documented”
    and respect SOLID principles (**S**ingle Responsibility, **O**pen/Close, **L**iskov
    Substitution, **I**nterface Segregation, and **D**ependency Inversion), you will
    turn complexity into simple code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你手头有一个复杂的场景，如果你减少了歧义并澄清了你所编写的代码的过程，特别是通过使用好的方法名和变量名，这有助于使你的代码“自文档化”并尊重 SOLID
    原则（**S**ingle Responsibility，**O**pen/Close，**L**iskov Substitution，**I**nterface
    Segregation，和 **D**ependency Inversion），你将把复杂性转化为简单的代码。
- en: So, if you want to write good code, you need to keep the focus on how to do
    it, considering you are not the only one who will read it later. This is a good
    tip that changes the way you write code. This is how we will discuss each point
    of this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想编写好的代码，你需要关注如何编写它，考虑到你不会是唯一一个以后会阅读它的人。这是一个改变你编写代码方式的良好建议。这就是我们将如何讨论本章的每个要点。
- en: 'If your understanding of the importance of writing good code is aligned with
    the idea of simplicity and clarity while writing it, you should look at the Visual
    Studio tool known as **Code Metrics**:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对编写良好代码重要性的理解与编写时的简洁性和清晰性理念一致，你应该看看名为 **Code Metrics** 的 Visual Studio 工具：
- en: '![Tela de celular com publicação numa rede social  Descrição gerada automaticamente](img/B19820_04_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![手机屏幕上显示社交媒体发布，自动生成的描述](img/B19820_04_01.png)'
- en: 'Figure 4.1: Calculating code metrics in Visual Studio'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：在 Visual Studio 中计算代码度量
- en: 'The **Code Metrics** tool will deliver metrics that will give you insights
    regarding the quality of the software you are delivering. The metrics that the
    tool provides can be found at this link: [https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码度量**工具将提供度量指标，这些指标将为你提供关于你交付的软件质量的洞察。该工具提供的度量指标可以在以下链接中找到：[https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values)。'
- en: Once you have run the code metrics analysis, you will need to interpret each
    metric presented. The following subsections focus on describing how a **maintainability
    index**, **cyclomatic complexity**, **depth of inheritance**, **class coupling**,
    and the **number of lines of code** are useful in some real-life scenarios.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行了代码度量分析，你将需要解释每个展示的度量指标。以下小节将重点描述**可维护性指数**、**圈复杂度**、**继承深度**、**类耦合度**和**代码行数**在现实生活中的某些场景中是如何有用的。
- en: Maintainability index
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可维护性指数
- en: The maintainability index represents a number from 0 to 100, which indicates
    how easy it is to maintain code – the easier the code, the higher the index. Easy
    maintenance is one of the key points to keeping software in good health. It is
    obvious that any software will require changes in the future since change is inevitable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性指数表示一个从0到100的数字，它表示维护代码的难易程度——代码越容易维护，指数越高。易于维护是保持软件健康的关键点之一。显然，任何软件在未来都需要更改，因为变化是不可避免的。
- en: For this reason, consider refactoring your code to elevate the maintainability
    index if it currently has a low score. Writing classes and methods dedicated to
    a single responsibility, avoiding duplicate code, and limiting the number of lines
    of code of each method are examples of how you can improve the maintainability
    index.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你当前的代码可维护性指数较低，考虑重构代码以提高可维护性指数。编写专门负责单一职责的类和方法、避免重复代码以及限制每个方法的代码行数都是提高可维护性指数的例子。
- en: Cyclomatic complexity
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 圈复杂度
- en: 'The creator of the cyclomatic complexity metric is Thomas J. McCabe. He defines
    the complexity of a software function according to the number of **code paths**
    available (**graph nodes)**. The more paths you have, the more complex your function
    is. McCabe considers that each function must have a complexity score of less than
    10\. That means that if the code has more complex methods, you must refactor it,
    transforming parts of the code into separate methods. There are some real scenarios
    where this behavior is easily detected:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 圈复杂度度量的创造者是托马斯·J·麦卡贝。他根据可用的**代码路径数**（**图节点**）来定义软件函数的复杂度。路径越多，函数越复杂。麦卡贝认为每个函数的复杂度得分必须小于10。这意味着如果代码有更复杂的方法，你必须重构它，将代码的部分转换为单独的方法。有一些实际场景中这种行为的检测很容易：
- en: Loops inside loops
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环嵌套
- en: Lots of consecutive `if-else` statements
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量的连续`if-else`语句
- en: '`switch` with code processing for each case inside the same method'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一方法内部对每个情况执行代码处理的`switch`语句
- en: 'For instance, look at the first version of this method for processing different
    responses to a credit card transaction. As you can see, the cyclomatic complexity
    is bigger than the number considered by McCabe as a basis. The reason why this
    happens is because of the number of `if-else` statements inside each case of the
    main switch:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看这个方法的第一版，用于处理信用卡交易的不同响应。正如你所看到的，圈复杂度大于麦卡贝作为基础的数字。这种情况发生的原因是主开关的每个情况中都有大量的`if-else`语句：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you calculate the code metrics of this code, you will find a bad result when
    it comes to cyclomatic complexity, as you can see in the following screenshot.
    A cyclomatic complexity number above 10 indicates that the code is difficult to
    read, and a developer will probably have trouble maintaining it in a future code
    change.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计算这段代码的代码度量，你将发现圈复杂度方面会有一个不良的结果，如以下截图所示。圈复杂度数值超过10表明代码难以阅读，开发者可能在未来代码更改中难以维护它。
- en: '![Interface gráfica do usuário, Aplicativo  Descrição gerada automaticamente](img/B19820_04_02.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面，应用程序，自动生成的描述](img/B19820_04_02.png)'
- en: 'Figure 4.2: High level of cyclomatic complexity'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：高圈复杂度
- en: 'It is important to reinforce that the purpose of the code from this example
    is not the focus here. The point here is to show you the number of improvements
    that can be made to write better code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，本例中代码的目的并不是重点。这里的关键是要展示可以如何改进代码以编写更好的代码：
- en: The options from `switch-case` could be written using `Enum`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch-case` 中的选项可以用 `Enum` 来编写。'
- en: 'Each `case` processing can be done:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 `case` 处理可以完成：
- en: In a specific method.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个特定的方法中。
- en: In a specific class, inheriting the action from the superclass, using the polymorphism
    concept.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个特定的类中，从超类继承操作，使用多态概念。
- en: In a specific class, implementing an interface to define a contract.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个特定的类中，实现一个接口来定义一个合同。
- en: '`switch-case` can be substituted with `Dictionary<Enum, Method>` or by using
    the `switch` expression.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch-case` 可以用 `Dictionary<Enum, Method>` 替换，或者使用 `switch` 表达式。'
- en: 'By refactoring this code with the preceding techniques, the result is a piece
    of code that is much easier to understand, as you can see in the following code
    snippet of its main method:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用前面提到的技术重构此代码，结果是代码更容易理解，如以下主方法代码片段所示：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the `switch` expression available since C# 8.0, the code can be even simpler!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 C# 8.0 以来，可以使用 `switch` 表达式使代码更加简洁！
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The full code can be found in the GitHub repository of this chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)/tree/main/ch04
    and demonstrates how lower-complexity code can be achieved. The following screenshot
    shows these results according to Code Metrics:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在本章的 GitHub 仓库中找到，网址为 [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)/tree/main/ch04，展示了如何实现低复杂度代码。以下截图显示了根据代码指标的结果：
- en: '![Graphical user interface, application  Description automatically generated](img/B19820_04_03.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B19820_04_03.png)'
- en: 'Figure 4.3: Cyclomatic complexity reduction after refactoring'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：重构后的循环复杂度降低
- en: As you can see in the preceding screenshot, there is a considerable reduction
    in complexity after refactoring. In *Chapter 5*, *Implementing Code Reusability
    in C# 12*, we will discuss the importance of refactoring for code reuse. The reason
    we are doing this here is the same – we want to eliminate duplication. It is important
    to remember that when you are refactoring code, you are writing it in a better
    way while respecting the input and output data that this code will process.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，重构后复杂性有相当大的降低。在 *第 5 章*，*在 C# 12 中实现代码重用*，我们将讨论重构对于代码重用的重要性。我们在这里这样做的原因是相同的——我们想要消除重复。重要的是要记住，当你重构代码时，你正在以更好的方式编写代码，同时尊重此代码将处理输入和输出数据。
- en: The key point here is that with the applied techniques, our understanding of
    the code increased and the complexity index decreased, thus proving the importance
    of cyclomatic complexity.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键点是，通过应用的技术，我们对代码的理解增加了，复杂度指数降低了，从而证明了循环复杂度的重要性。
- en: Depth of inheritance
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承深度
- en: 'This metric represents the number of classes inherited by the one that is being
    analyzed. The more classes you have inherited, the worse the metric will be. This
    is like class coupling and indicates how difficult it is to change the code of
    this class without impacting other ones, which neglects the Open/Close principle
    stated by SOLID. For instance, the following screenshot shows four inherited classes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指标表示正在分析的那个类继承的类数量。继承的类越多，这个指标就越差。这就像类耦合，表明在不影响其他类的情况下更改这个类的代码有多困难，这忽略了 SOLID
    原则中提出的开放/关闭原则。例如，以下截图显示了四个继承的类：
- en: '![Diagrama  Descrição gerada automaticamente](img/B19820_04_04.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Diagrama Descrição gerada automaticamente](img/B19820_04_04.png)'
- en: 'Figure 4.4: Depth of inheritance sample'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：继承深度示例
- en: 'You can see in the following screenshot that the deepest class has the worst
    metric, considering there are three other classes that can change its behavior:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下截图看到，最深的类在考虑有三个其他类可以改变其行为的情况下，具有最差的指标：
- en: '![Graphical user interface, application  Description automatically generated](img/B19820_04_05.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B19820_04_05.png)'
- en: 'Figure 4.5: Depth of inheritance metric'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：继承深度指标
- en: Inheritance is one of the basic object-oriented analysis principles. However,
    it can sometimes be bad for your code in that it can cause dependencies. So, if
    it makes sense to do so, consider using composition or aggregation instead of
    inheritance, as we will explain in the following section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是基本面向对象分析原则之一。然而，有时它可能会对你的代码造成不利影响，因为它可能会引起依赖。所以，如果这样做有意义，考虑使用组合或聚合而不是继承，正如我们将在下一节中解释的那样。
- en: Class coupling
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类耦合
- en: 'When you connect too many classes in a single class, obviously you will get
    tight coupling, and changing a participant causes unintended consequences in others.
    For sure, this can cause bad maintenance of your code, resulting in bugs that
    will make you spend more time trying to deliver a great solution. For instance,
    refer to *Figure 4.6*. It shows a design where aggregation has been performed
    a lot. There is no sense to the code itself:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在单个类中连接太多的类时，显然你会得到紧密耦合，改变一个参与者会导致其他参与者产生意外的后果。当然，这可能会造成你代码的糟糕维护，导致需要花费更多时间来尝试交付一个优秀的解决方案。例如，参考*图4.6*。它显示了一个进行了大量聚合的设计。代码本身没有意义：
- en: '![Diagrama  Descrição gerada automaticamente](img/B19820_04_06.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的描述图](img/B19820_04_06.png)'
- en: 'Figure 4.6: Class coupling example'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：类耦合示例
- en: 'Once you have calculated the code metrics for the preceding design, you will
    see that the number of class coupling instances for the `ProcessData()` method,
    which calls `ExecuteTypeA()`, `ExecuteTypeB()`, and `ExecuteTypeC()`, equals three:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你计算了前一个设计的代码度量，你会发现调用`ExecuteTypeA()`、`ExecuteTypeB()`和`ExecuteTypeC()`的`ProcessData()`方法的类耦合实例数等于三个：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B19820_04_07.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的中等置信度描述](img/B19820_04_07.png)'
- en: 'Figure 4.7: Class coupling metric'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：类耦合度量
- en: Microsoft suggests that the maximum number of class coupling instances should
    be nine, as presented at [https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-class-coupling?view=vs-2022](https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-class-coupling?view=vs-2022).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 微软建议类耦合实例的最大数量应该是九个，如[https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-class-coupling?view=vs-2022](https://learn.microsoft.com/en-us/visualstudio/code-quality/code-metrics-class-coupling?view=vs-2022)所示。
- en: With composition/aggregation being a better practice than inheritance, and since
    you will decouple code written from your class, the use of interfaces will solve
    class coupling problems. For instance, the same code with the following design
    will give you a better result. Although the interface is not strictly required
    for this example, its usage enables us to evolve the solution for other **execution
    types** without impacting the classes already written, since you are not using
    inheritance to solve the problem.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于组合/聚合比继承是一种更好的实践，并且你将解耦从你的类编写的代码，使用接口将解决类耦合问题。例如，以下设计中的相同代码将给出更好的结果。尽管在这个例子中接口不是严格必需的，但其使用使我们能够为其他**执行类型**的解决方案进行演化，而不会影响已经编写的类，因为你没有使用继承来解决问题。
- en: '![](img/B19820_04_08.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_04_08.png)'
- en: 'Figure 4.8: Reducing class coupling'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：减少类耦合
- en: 'Note that using the interface in the design will allow you to increase the
    number of execution types without increasing the class coupling of the solution:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在设计中使用接口将允许你在不增加解决方案的类耦合的情况下增加执行类型：
- en: '![](img/B19820_04_09.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_04_09.png)'
- en: 'Figure 4.9: Class coupling results after applying aggregations'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：应用聚合后的类耦合结果
- en: As a software architect, you must design your solution to have more cohesion
    than coupling. The literature indicates that good software has low coupling and
    high cohesion. In software development, high cohesion indicates that each class
    has its methods and data, with good relationships between them. Conversely, low
    coupling indicates that classes are not closely and directly connected. This is
    a basic principle that can guide you to a better architectural model.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件架构师，你必须设计你的解决方案，使其具有比耦合更高的内聚性。文献指出，好的软件具有低耦合和高内聚。在软件开发中，高内聚表示每个类都有其方法和数据，并且它们之间有良好的关系。相反，低耦合表示类之间没有紧密和直接的连接。这是一个基本原理，可以指导你到一个更好的架构模型。
- en: Number of lines of code
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码行数
- en: This metric is useful in terms of making you understand the size of the code
    you are dealing with. There is no way to connect the number of lines of code and
    complexity, since the number of lines is not indicative of that. Conversely, the
    number of lines of code does show the software size and software design. For instance,
    if you have too many lines of code in a single class (more than 1,000 lines of
    code – 1 KLOC), this indicates that it is a bad design. Besides, if a class has
    too many methods, it obviously violates the Single Responsibility principle from
    SOLID.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指标有助于你理解你正在处理的代码的大小。由于行数并不能直接反映复杂性，因此无法将代码行数与复杂性联系起来。相反，代码行数确实可以显示软件的大小和软件设计。例如，如果一个类中有太多的代码行（超过
    1,000 行代码 – 1 KLOC），这表明它是一个糟糕的设计。此外，如果一个类有太多的方法，这显然违反了 SOLID 设计原则中的单一职责原则。
- en: In Visual Studio 2022, this metric was divided into **lines of source code**
    and **lines of executable code**. The first indicates the exact number of source
    lines, including blank lines. Conversely, the second one estimates the number
    of executable code lines.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2022 中，这个指标被分为**源代码行数**和**可执行代码行数**。前者表示确切的总源代码行数，包括空白行。相反，后者估计的是可执行代码的行数。
- en: As a software architect, you have the objective of delivering to your programmers
    a list of best practices that will enable each of them to improve their techniques
    for developing good software. Make sure they know the exact impacts of not achieving
    good metric results in their code. The metrics presented above are certainly a
    great way to start to achieve this objective. But let us see how using a version
    control system can be the difference between amateur and professional software
    development.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件架构师，你的目标是向程序员提供一系列最佳实践，使他们能够提高开发优质软件的技术。确保他们了解在代码中未能实现良好指标结果的直接影响。上述指标无疑是实现这一目标的良好开端。但让我们看看使用版本控制系统如何能区分业余和专业的软件开发。
- en: Using a version control system
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用版本控制系统
- en: You may find this topic a bit obvious, but many people and companies still do
    not regard a version control system as an essential tool for software development.
    A common reason why version control systems are not considered a priority, particularly
    in some situations, is the belief that they are unnecessary for solo coding projects
    or for study purposes. You may think that a version control system is only needed
    by teams inside companies. The purpose of addressing this is to force you to understand
    our point. There is no architectural model or best practice that can save software
    development if you do not use a **version control system**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得这个话题有点明显，但许多人和企业仍然不认为版本控制系统是软件开发的一个基本工具。版本控制系统不被视为优先事项的常见原因，尤其是在某些情况下，是认为它们对于单独编码项目或学习目的来说是不必要的。你可能认为版本控制系统仅适用于公司内部的团队。提出这个问题的目的是让你理解我们的观点。如果你不使用**版本控制系统**，就没有任何架构模型或最佳实践能够拯救软件开发。
- en: In the last few years, we have been enjoying the advantages of online version
    control systems, such as Azure DevOps, GitHub, and Bitbucket. The fact is, you
    must have a version control system in your software development life cycle, and
    there is no reason not to have one anymore, since most providers offer free versions
    for small groups. Even if you develop by yourself, these tools are useful for
    tracking your changes, managing your software versions, and guaranteeing the consistency
    and integrity of your code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年里，我们一直在享受在线版本控制系统带来的优势，例如 Azure DevOps、GitHub 和 Bitbucket。事实上，在你的软件开发生命周期中必须有一个版本控制系统，而且没有理由不再使用它，因为大多数提供商为小型团队提供免费版本。即使你独自开发，这些工具也有助于跟踪你的更改、管理你的软件版本，并保证代码的一致性和完整性。
- en: Dealing with version control systems in teams
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 团队中处理版本控制系统
- en: The reason for using a version control system tool when you are alone is obvious.
    You want to keep your code safe. However, this kind of system was developed to
    solve team problems while writing code. For this reason, some features, such as
    branching and merging, were introduced to keep code integrity even in scenarios
    where the number of developers is quite large.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你独自一人使用版本控制系统工具的原因很明显。你希望确保你的代码安全。然而，这种系统是为了解决编写代码时的团队问题而开发的。因此，引入了一些功能，如分支和合并，以保持代码完整性，即使在开发者数量相当大的情况下也是如此。
- en: As a software architect, you will have to decide which branch strategy you will
    conduct in your team. Microsoft and GitHub suggest different ways to deliver that,
    and both are useful in some scenarios.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件架构师，你将不得不决定在你的团队中实施哪种分支策略。微软和GitHub建议了不同的方法来实现这一点，并且两者在某些场景中都很有用。
- en: 'Information about how the Microsoft teams deal with DevOps can be found here:
    [https://learn.microsoft.com/en-us/devops/develop/how-microsoft-develops-devops](https://learn.microsoft.com/en-us/devops/develop/how-microsoft-develops-devops).
    The branching strategy presented in this article describes an approach where a
    branch is created for each release. They call it **the release flow**. The big
    difference here is that the master branch is not continuously deployed to production.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 关于微软团队如何处理DevOps的信息可以在这里找到：[https://learn.microsoft.com/en-us/devops/develop/how-microsoft-develops-devops](https://learn.microsoft.com/en-us/devops/develop/how-microsoft-develops-devops)。本文中提出的分支策略描述了一种为每个发布创建分支的方法。他们将这称为
    **发布流程**。这里的主要区别是主分支不会持续部署到生产环境。
- en: Conversely, GitHub describes its process at [https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/).
    This process is called **GitHub flow** and can be defined as a lightweight, branch-based
    workflow, where each development is created in a specific branch that will be
    reviewed by collaborators as soon as a pull request is created for feedback. As
    soon as the pull request is approved, the new code is merged to a master branch,
    so you can delete the development branch created before.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，GitHub在其[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)中描述了其流程。这个过程被称为
    **GitHub flow**，可以被定义为一个轻量级的、基于分支的工作流程，其中每个开发都在一个特定的分支中进行，一旦创建了拉取请求以供反馈，协作者就会对其进行审查。一旦拉取请求被批准，新代码就会被合并到主分支，这样你就可以删除之前创建的开发分支。
- en: It is your choice; decide on the one that best fits your needs, but we do want
    you to understand that you need to have a strategy for controlling your code.
    In *Chapter 8*, *Understanding DevOps Principles and CI/CD*, we will discuss this
    in more detail. But now, let us see how to write safe code using C# so that you
    can develop a list of best practices to be shared with your developers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你的选择；选择最适合你需求的一个，但我们确实希望你明白你需要有一个控制你代码的策略。在 *第8章*，*理解DevOps原则和CI/CD* 中，我们将更详细地讨论这一点。但现在，让我们看看如何使用C#编写安全代码，以便你可以制定一份最佳实践清单与你的开发者分享。
- en: Writing safe code in C#
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中编写安全代码
- en: C# can be considered a safe programming language by design. Unless you force
    it, there is no need for pointers, and memory release is, in most cases, managed
    by the garbage collector. Even so, some care should be taken so that you can get
    better and safer results from your code. Let us have a look at some common practices
    to ensure safe code in C#.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计上讲，C# 可以被认为是一种安全的编程语言。除非你强制使用，否则不需要指针，并且大多数情况下，内存释放由垃圾回收器管理。即便如此，也应该注意一些事项，以便你能从代码中获得更好的、更安全的成果。让我们看看一些常见的做法，以确保在C#中编写安全代码。
- en: try-catch
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try-catch
- en: Exceptions in coding are so frequent that you should have a way to manage them
    whenever they happen. `try-catch` statements are built to manage exceptions, and
    they are important for keeping your code safe. Be careful when they happen, since
    they can cause performance issues, as we discussed in *Chapter 2,* *Non-Functional
    Requirements*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的异常如此频繁，你应该有一种方法来管理它们，无论何时发生。`try-catch` 语句被构建来管理异常，这对于保持代码安全非常重要。当它们发生时，要小心，因为它们可能会引起性能问题，正如我们在
    *第2章*，*非功能性需求* 中讨论的那样。
- en: 'There are a lot of cases where an application crashes, and the reason for that
    is the lack of using `try-catch`. The following code shows an example of the lack
    of usage of the `try-catch` statement. It is worth mentioning that this is just
    an example of understanding the concept of an exception thrown without correct
    treatment. Consider using `int.TryParse(textToConvert, out int result)` to handle
    cases where a parse is unsuccessful:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多情况下应用程序崩溃，而其原因是没有使用 `try-catch`。以下代码展示了缺少 `try-catch` 语句使用的一个例子。值得注意的是，这只是一个理解未正确处理的异常抛出概念的一个例子。考虑使用
    `int.TryParse(textToConvert, out int result)` 来处理解析失败的情况：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Conversely, bad `try-catch` usage can cause damage to your code too, especially
    because you will not see the correct behavior of that code and may misunderstand
    the results provided.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，错误的 `try-catch` 使用也可能对你的代码造成损害，尤其是因为你将看不到该代码的正确行为，并可能误解提供的结果。
- en: 'The following code shows an example of an empty `try-catch` statement:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了空`try-catch`语句的例子：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`try-catch` statements must be connected to logging solutions so that you can
    have a response from the system that will indicate the correct behavior and, at
    the same time, not cause application crashes. The following code shows an ideal
    `try-catch` statement with logging management. It is worth mentioning that specific
    exceptions should be caught whenever possible, since catching a general exception
    will hide unexpected exceptions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`try-catch`语句必须与日志解决方案连接，以便你可以从系统中获得响应，指示正确的行为，同时不会导致应用程序崩溃。以下代码展示了带有日志管理的理想`try-catch`语句。值得注意的是，在可能的情况下，应该捕获特定的异常，因为捕获通用异常会隐藏意外的异常：'
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is very important to note that exceptions are, computationally speaking,
    expensive. No matter whether you are throwing them to indicate an error or catching
    them to manage errors, it takes a lot of computational processing. So, it is common,
    and preferable, to rely on a higher-level exception handler instead of trying
    to handle everything everywhere, as the code might become hard to reason about,
    particularly if there is not a good action to take when an exception happens.
    That means you may not handle the exceptions in every method, especially if you
    do not know what to do with them at that part of the code and you will throw it
    again to a higher-level handle. You should prioritize handling exceptions where
    meaningful actions can be taken.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意，从计算的角度来看，异常是昂贵的。无论你是抛出它们来指示错误还是捕获它们来管理错误，都需要大量的计算处理。因此，依赖高级异常处理器而不是试图在各个地方处理所有事情是常见且更可取的，因为代码可能难以推理，尤其是在不知道在代码的这一部分如何处理异常的情况下，你可能会再次将其抛给更高层次的处理器。你应该优先处理可以在其中采取有意义操作的异常。
- en: However, it is also worth mentioning that exception errors delivered to the
    end user can cause the feeling that bad software was delivered. As a software
    architect, you should conduct code inspections to define the best behavior for
    code. Instability in a system, like unexpected crashes and high-memory usage,
    is often connected to the lack of `try-catch` statements in code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也值得提到的是，传递给最终用户的异常错误可能会造成软件质量差的印象。作为一名软件架构师，你应该进行代码审查，以定义代码的最佳行为。系统中的不稳定性，如意外的崩溃和高内存使用，通常与代码中缺少`try-catch`语句有关。
- en: try-finally and using
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try-finally 和 using
- en: '*Memory leaks* can be considered one of the worst software behaviors. They
    cause instability, bad usage of computer resources, and undesired application
    crashes. C# tries to solve this with **Garbage Collector**, which automatically
    releases objects from memory as soon as it realizes an object can be freed. The
    trigger for Garbage Collector is well explained at [https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存泄漏*可以被认为是软件行为中最糟糕的一种。它们会导致不稳定、计算机资源使用不当和应用程序崩溃。C#通过**垃圾回收器**来尝试解决这个问题，垃圾回收器会在意识到对象可以被释放时自动从内存中释放对象。垃圾回收器的触发机制在[https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals)中有详细解释。'
- en: 'Objects that interact with I/O are the ones that generally are not managed
    by Garbage Collector: the filesystem, sockets, and so on. The following code is
    an example of the incorrect usage of a `FileStream` object because it thinks Garbage
    Collector will release the memory used, but it will not:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与I/O交互的对象通常不是由垃圾回收器管理的：文件系统、套接字等。以下代码是`FileStream`对象使用不当的例子，因为它认为垃圾回收器会释放使用的内存，但实际上不会：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Besides, it takes a while for Garbage Collector to interact with objects that
    need to be released, and sometimes, you may want to do it yourself. For both cases,
    the use of `try-finally` or `using` statements is the best practice:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，垃圾回收器与需要释放的对象交互需要一段时间，有时你可能想自己来做这件事。在这两种情况下，使用`try-finally`或`using`语句是最佳实践：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code shows exactly how to deal with objects that are not managed
    by Garbage Collector. Both `try-finally` and `using` are implemented. As a software
    architect, you do need to pay attention to this kind of code. The lack of `try-finally`
    or `using` statements can cause huge damage to software behavior when it is running.
    It is worth mentioning that using code analysis tools, such as **Sonar Lint**
    and **Code Analysis**, will automatically alert you to these sorts of problems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了如何处理垃圾回收器未管理的对象。`try-finally` 和 `using` 都已实现。作为一名软件架构师，你需要注意这类代码。缺少 `try-finally`
    或 `using` 语句可能会在运行时对软件行为造成巨大损害。值得一提的是，使用代码分析工具，如 **Sonar Lint** 和 **代码分析**，将自动提醒你这些问题。
- en: The IDisposable interface
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDisposable 接口
- en: 'In the same way that you will have trouble if you do not manage objects created
    inside a method with `try-finally`/`using` statements, objects created in a class
    that does not properly implement the `IDisposable` interface may cause memory
    leaks in your application. For this reason, when you have a class that deals with
    and creates objects, you should implement the `Disposable` pattern to guarantee
    the release of all resources created by the class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就像如果你不使用 `try-finally`/`using` 语句来管理方法内部创建的对象，你将遇到麻烦一样，在未正确实现 `IDisposable`
    接口的情况下创建的对象可能会导致你的应用程序出现内存泄漏。因此，当你有一个处理和创建对象的类时，你应该实现 `Disposable` 模式来保证释放由该类创建的所有资源：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B19820_04_10.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件  描述自动生成](img/B19820_04_10.png)'
- en: 'Figure 4.10: IDisposable interface implementation'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：IDisposable 接口实现
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once you have inserted the code, you need to follow the to-do instructions so
    that you have the correct pattern implemented.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你插入了代码，你需要遵循待办指令，以确保正确实现了模式。
- en: As a software architect, you will be responsible not only for the architecture
    defined in a system but also for how this system performs in operation. Memory
    leaks and bad performance, in general, are caused by errors related to the `try-catch`
    strategy, a lack of `try-finally/using`, and wrong or no implementation of `IDisposable`.
    So be sure that your team knows how to deal with these techniques.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名软件架构师，你不仅需要对系统中定义的架构负责，还要对系统的运行性能负责。内存泄漏和性能不佳通常是由与 `try-catch` 策略相关的错误、缺乏
    `try-finally/using` 以及 `IDisposable` 的错误或未实现引起的。所以请确保你的团队知道如何处理这些技术。
- en: Since we have covered some important information about how to write safe code
    in C#, it would be nice to get some tips and tricks for coding in this programming
    language. Let us do so in the next topic of this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经介绍了一些关于如何在 C# 中编写安全代码的重要信息，那么获取一些关于这种编程语言的编程技巧和窍门将是非常有用的。让我们在本章的下一个主题中这样做。
- en: .NET 8 tips and tricks for coding
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 8 编程技巧与窍门
- en: .NET 8 implements some good features that help us to write better code. One
    of the most useful things for having cleaner code is **dependency injection**
    (**DI**), which will be discussed in *Chapter 6*, *Design Patterns and .NET 8
    Implementation*. There are some good reasons for considering this. The first one
    is that you will only need to worry about disposing of the injected objects if
    you are the creator of them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8 实现了一些有助于我们编写更好代码的良好功能。其中最有用的一个就是**依赖注入**（**DI**），它将在第 6 章，**设计模式和 .NET
    8 实现**中讨论。考虑这一点有几个很好的理由。第一个是，如果你是注入对象的创建者，你只需担心注入对象的释放。
- en: 'Besides, DI enables you to inject `ILogger`, a useful tool for debugging exceptions
    that will need to be managed by `try-catch` statements in your code. Furthermore,
    programming in C# with .NET 8 must follow the common good practices of any programming
    language. The following list shows some of these:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，DI 使你能够注入 `ILogger`，这是一个用于调试需要由 `try-catch` 语句管理的异常的有用工具。此外，使用 .NET 8 在 C#
    中编程必须遵循任何编程语言的通用良好实践。以下列表显示了其中的一些：
- en: '**Classes, methods, and variables should have understandable names**: The name
    should explain everything that the reader needs to know. There should be no need
    for an explanatory comment unless these declarations are public.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类、方法和变量应该有可理解的名字**：名字应该解释读者需要知道的一切。除非这些声明是公开的，否则不应需要解释性注释。'
- en: '**Methods should not have high complexity levels**: Cyclomatic complexity should
    be checked so that methods do not have too many lines of code.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法不应具有高复杂度级别**：应检查循环复杂度，以确保方法中代码行数不要过多。'
- en: '**Members must have the correct visibility**: As an object-oriented programming
    language, C# enables encapsulation with different visibility keywords. C# 9 has
    presented *init-only setters*, so you can create `init` property/index accessors
    instead of `set`, defining these members as read-only following the construction
    of the object.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成员必须具有正确的可见性**：作为面向对象编程语言，C#通过不同的可见性关键字支持封装。C# 9引入了*只读设置器*，因此您可以使用`init`属性/索引访问器而不是`set`，在对象构造后定义这些成员为只读。'
- en: '**Duplicate code should be avoided**: There is no reason for having duplicate
    code in a high-level programming language such as C#.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应避免重复代码**：在像C#这样的高级编程语言中，没有必要存在重复代码。'
- en: '**Objects should be checked before usage**: Since null objects can exist, code
    must have null type checking. It is worth mentioning that since C# 8, we have
    nullable reference types to avoid errors related to nullable objects. You can
    refer to [https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references](https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references)
    for more information about nullable reference types.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在使用对象之前应检查对象**：由于可能存在null对象，代码必须进行null类型检查。值得一提的是，自从C# 8以来，我们有了可空引用类型来避免与可空对象相关的错误。您可以参考[https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references](https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references)了解更多关于可空引用类型的信息。'
- en: '**Constants and enumerators should be used**: A good way of avoiding magic
    numbers and text inside code is to transform this information into constants and
    enumerators, which generally are more understandable.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应使用常量和枚举器**：避免在代码中使用魔法数字和文本的好方法是将此信息转换为常量和枚举器，这些通常更容易理解。'
- en: '**Unsafe code should be avoided**: Unsafe code enables you to deal with pointers
    in C#. Unless there is no other way to implement the solution, unsafe code should
    be avoided.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应避免使用不安全代码**：不安全代码使您能够在C#中处理指针。除非没有其他方法来实现解决方案，否则应避免使用不安全代码。'
- en: '**try-catch statements cannot be empty**: There is rarely a reason to use a
    `try-catch` statement without treatment in the `catch` area. Moreover, the caught
    exceptions should be as specific as possible, and not just an “exception,” to
    avoid swallowing unexpected exceptions.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**try-catch语句不能为空**：在没有处理`catch`区域的`try-catch`语句中很少有使用理由。此外，捕获的异常应尽可能具体，而不仅仅是“异常”，以避免吞咽意外的异常。'
- en: '**Dispose of the objects that you have created, if they are disposable**: Even
    for objects where Garbage Collector will take care of the disposed-of object,
    consider disposing of objects that you were responsible for creating yourself.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果创建了可释放的对象，则应释放它们**：即使垃圾回收器会处理已释放的对象，也应考虑释放自己负责创建的对象。'
- en: '**At least public methods should be commented**: Considering that public methods
    are the ones used outside your library, they must be explained for their correct
    external usage.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**至少公共方法应该有注释**：考虑到公共方法是用于您库外部的，它们必须解释其正确的外部使用。'
- en: '**switch-case statements must have a default treatment**: Since `switch-case`
    statements may receive an entrance variable unknown in some cases, the default
    treatment will guarantee that code will not break in such a situation.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**switch-case语句必须具有默认处理**：由于`switch-case`语句可能接收到某些情况下未知的人口变量，默认处理将保证在这种情况下代码不会中断。'
- en: As a software architect, you may consider a good practice of providing a code
    pattern for your developers that will be used to keep the style of code consistent
    as a team. You can also use this code pattern as a checklist for coding inspections,
    which will enrich software code quality.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，您可能考虑为您的开发人员提供一个代码模式，该模式将用于保持团队代码风格的一致性。您还可以将此代码模式用作编码检查的清单，这将丰富软件代码质量。
- en: Identifying well-written code
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别编写良好的代码
- en: It is not easy to identify whether code is well written. The best practices
    described so far can certainly guide you as a software architect to define a standard
    for your team. However, even with a standard, mistakes will happen, and you will
    probably find them only after code is in production. The decision to refactor
    code in production just because it does not follow all the standards you define
    is not an easy one to take, especially if the code in question works properly.
    Some people conclude that well-written code is simply code that works well in
    production. However, this can surely cause damage to the software’s life since
    developers might be influenced by that non-standard code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 识别代码是否编写得很好并不容易。到目前为止所描述的最佳实践当然可以指导你作为一个软件架构师为你的团队定义一个标准。然而，即使有了标准，错误仍然会发生，你可能会在生产代码中才发现它们。仅仅因为代码没有遵循你定义的所有标准就决定在生产中重构代码，这是一个不容易做出的决定，尤其是如果相关的代码运行正常的话。有些人认为，编写得好的代码就是那些在生产中运行良好的代码。然而，这肯定会对软件的生命周期造成损害，因为开发者可能会受到那些非标准代码的影响。
- en: For this reason, as a software architect, you need to find ways to enforce adherence
    to the coding standard you’ve defined. Luckily, nowadays, we have many options
    for tools that can help us with this task. They are called static code analysis
    tools, and using them provides a great opportunity to improve both the software
    developed and the team’s programming knowledge.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个软件架构师，你需要找到方法来强制执行你定义的编码标准的遵守。幸运的是，如今，我们有许多工具可以帮助我们完成这项任务。它们被称为静态代码分析工具，使用它们提供了改进开发和团队编程知识的大好机会。
- en: The reason your developers will evolve with code analysis is that you start
    to disseminate knowledge between them during code inspections. The tools that
    we have now have the same purpose. Even better, with Roslyn, they do this task
    while you write the code. Roslyn is the compiler platform for .NET, and it enables
    you to develop some tools for analyzing code. These analyzers can check style,
    quality, design, and other issues.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者会随着代码分析而发展，原因是在代码审查过程中，你开始在他们之间传播知识。我们现在拥有的工具具有相同的目的。更好的是，使用Roslyn，它们在编写代码的同时完成这项任务。Roslyn是.NET的编译器平台，它使你能够开发一些用于分析代码的工具。这些分析器可以检查风格、质量、设计和其他问题。
- en: 'For instance, look at the following code. It does not make any sense, but you
    can still see that there are some mistakes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看下面的代码。它没有任何意义，但你仍然可以看到其中有一些错误：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The idea of this code is to show you the power of some tools to improve the
    code you deliver. Let us study each of them in the next section, including how
    to set them up.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的目的是向您展示一些工具的强大功能，这些工具可以帮助您改进交付的代码。让我们在下一节中逐一研究它们，包括如何设置它们。
- en: Understanding and applying tools that can evaluate C# code
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解和应用可以评估C#代码的工具
- en: The evolution of code analysis in Visual Studio is continuous. This means that
    Visual Studio 2022 certainly has more tools for this purpose than Visual Studio
    2019, and so on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio中代码分析的发展是持续的。这意味着Visual Studio 2022肯定比Visual Studio 2019有更多用于此目的的工具，依此类推。
- en: 'One of the issues that you (as a software architect) need to deal with is the
    *coding style of the team*. This certainly results in a better understanding of
    the code. For instance, if you go to the **Visual Studio Menu**, then **Tools
    -> Options**, and then, in the left-hand menu, **Text Editor -> C#**, you will
    find ways to deal with different code style patterns, and a bad coding style is
    even indicated as an error in the **Code Style** options, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你（作为一个软件架构师）需要处理的一个问题是团队的*编码风格*。这当然有助于更好地理解代码。例如，如果你去**Visual Studio菜单**，然后**工具
    -> 选项**，接着在左侧菜单中**文本编辑 -> C#**，你会找到处理不同代码风格模式的方法，而且不良的编码风格甚至在**代码风格**选项中被标记为错误，如下所示：
- en: '![](img/B19820_04_11.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_04_11.png)'
- en: 'Figure 4.11: Code Style options'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：代码风格选项
- en: The preceding screenshot chnage that **Avoid unused parameters** was considered
    an error.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图中的更改**避免未使用参数**被认为是一个错误。
- en: 'After this change, the result of the compilation of the code presented at the
    beginning of the chapter is different, as you can see in the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次更改之后，本章开头展示的代码的编译结果不同，如下面的截图所示：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19820_04_12.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  描述自动生成](img/B19820_04_12.png)'
- en: 'Figure 4.12: Code Style result'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：代码风格结果
- en: You can export your coding style configuration and attach it to your project
    so that it will follow the rules you have defined.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将您的编码风格配置导出并附加到您的项目上，这样它就会遵循您定义的规则。
- en: 'Another good tool that Visual Studio 2022 provides is **Analyze and Code Cleanup**.
    With this tool, you can set up some code standards that can clean up your code.
    For instance, in the following screenshot, it was set to remove unnecessary code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022提供的另一个好工具是**分析和代码清理**。使用此工具，您可以设置一些代码标准来清理您的代码。例如，在下面的屏幕截图中，它被设置为删除不必要的代码：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19820_04_13.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序描述自动生成](img/B19820_04_13.png)'
- en: 'Figure 4.13: Configure Code Cleanup'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：配置代码清理
- en: 'The way to run Code Cleanup is by selecting it with the help of a right-click
    in the **Solution Explorer** area, over the project where you want to run it.
    After that, this process will run in all the code files you have:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码清理的方式是通过在**解决方案资源管理器**区域中，在您想要运行它的项目上右键单击来选择它。之后，此过程将在您所有的代码文件中运行：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19820_04_14.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序描述自动生成](img/B19820_04_14.png)'
- en: 'Figure 4.14: Run Code Cleanup'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：运行代码清理
- en: 'After solving the errors indicated by the **Code Style** and **Code Cleanup**
    tools, the sample code we are working on has some minimal simplifications, as
    follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决**代码风格**和**代码清理**工具指示的错误之后，我们正在处理的示例代码进行了一些最小化简化，如下所示：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is worth mentioning that the preceding code has many improvements that still
    need to be addressed. Visual Studio enables you to add additional tools for the
    IDE by installing extensions to it. These tools can help you to improve your code
    quality, since some of them were built to perform code analysis. This section
    will list some free options so that you can decide on the one that best fits your
    needs. There are certainly other options and even paid ones. The idea here is
    not to indicate a specific tool but to give you an idea of their abilities.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，前面的代码还有许多需要解决的改进。Visual Studio通过安装扩展到IDE中，使您能够为IDE添加额外的工具。这些工具可以帮助您提高代码质量，因为其中一些工具是为了执行代码分析而构建的。本节将列出一些免费选项，以便您可以选择最适合您需求的选项。当然，还有其他选项，甚至付费选项。这里的想法不是指出一个特定的工具，而是给您一个它们能力的概念。
- en: 'To install these extensions, you will need to find the **Extensions** menu
    in Visual Studio 2022\. Here is a screenshot of the **Manage Extensions** option:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这些扩展，您需要在Visual Studio 2022中找到**扩展**菜单。以下是**管理扩展**选项的屏幕截图：
- en: '![](img/B19820_04_15.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_04_15.png)'
- en: 'Figure 4.15: Extensions in Visual Studio 2022'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：Visual Studio 2022中的扩展
- en: There are many other great extensions that can improve the productivity and
    quality of your code and solutions. Search for them in this manager.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他优秀的扩展可以提升您代码和解决方案的生产力和质量。您可以在本管理器中搜索它们。
- en: After you have selected the extension that will be installed, you will need
    to restart Visual Studio. Most of the extensions are easy to identify after installation,
    since they modify the behavior of the IDE. However, they need to be set in each
    developer environment. To resolve it, Visual Studio has introduced the option
    to include analyzers as NuGet packages, so all developers who work with the project
    will have their code analyzed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在您选择了将要安装的扩展之后，您需要重新启动Visual Studio。大多数扩展在安装后都很容易识别，因为它们会修改IDE的行为。然而，它们需要在每个开发环境中进行设置。为了解决这个问题，Visual
    Studio引入了将分析器作为NuGet包包含的选项，这样所有与项目合作的开发者都将对他们的代码进行分析。
- en: Applying extension tools to analyze code
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将扩展工具应用于分析代码
- en: Although the sample code delivered after the Code Style and Code Cleanup tools
    is better than the code we presented at the beginning of the chapter, it is clearly
    far removed from the best practices discussed so far.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管经过代码风格和代码清理工具处理后的示例代码比章节开头我们展示的代码要好，但它显然与迄今为止讨论的最佳实践相去甚远。
- en: 'For this reason, Microsoft has divided analyzers into three groups:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Microsoft将分析器分为三个组：
- en: Code style, as mentioned before
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述的代码风格
- en: Code quality analyzers that are already included in .NET 5+ projects
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已包含在.NET 5+项目中的代码质量分析器
- en: Third-party analyzers that can be installed as a NuGet package or Visual Studio
    extension
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以作为NuGet包或Visual Studio扩展安装的第三方分析器
- en: You can find an overview of source code analysis at [https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview](https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview](https://docs.microsoft.com/en-us/visualstudio/code-quality/roslyn-analyzers-overview)
    找到源代码分析概述。
- en: Let us study how these third-party analyzers can be useful, using as a reference
    the **SonarAnalyzer** package.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们研究一下这些第三方分析器如何有用，以 **SonarAnalyzer** 包作为参考。
- en: Applying SonarAnalyzer
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用 SonarAnalyzer
- en: SonarAnalyzer is an open-source initiative from the Sonar Source community to
    detect bugs and quality issues while you code. There is support for C#, VB.NET,
    C, C++, and JavaScript. They also offer an extension called **SonarLint**. The
    great thing about this extension is that it comes with explanations for resolving
    detected issues, and that is why we think developers learn how to code well while
    using these tools.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: SonarAnalyzer 是 Sonar Source 社区发起的一个开源项目，旨在在编码时检测错误和质量问题。它支持 C#、VB.NET、C、C++
    和 JavaScript。他们还提供了一个名为 **SonarLint** 的扩展。这个扩展的伟大之处在于它提供了解决检测到的问题的解释，这就是为什么我们认为开发者在使用这些工具时可以学会如何编写良好的代码。
- en: This extension can point out mistakes and, even better, there is an explanation
    for each warning. This is useful not only for detecting problems but also for
    training developers in good coding practices.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展可以指出错误，而且更好的是，每个警告都有解释。这对于发现问题以及培训开发者良好的编码实践都很有用。
- en: 'In Visual Studio 2022, the SonarLint extension is available. Besides that,
    you can also use the NuGet package, as we can see in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2022 中，SonarLint 扩展可用。除此之外，您还可以使用 NuGet 包，如下面的截图所示：
- en: '![Tela de computador com texto preto sobre fundo branco  Descrição gerada automaticamente](img/B19820_04_16.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Tela de computador com texto preto sobre fundo branco Descrição gerada automaticamente](img/B19820_04_16.png)'
- en: 'Figure 4.16: SonarAnalyzer.CSharp NuGet package'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16：SonarAnalyzer.CSharp NuGet 包
- en: The result produced is the same as the one we got using the SonarLint extension,
    but the good thing about this option is that any developer who needs to code for
    this project will get their code analyzed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的结果与使用 SonarLint 扩展得到的结果相同，但这个选项的好处是，任何需要为这个项目编码的开发者都会得到他们的代码分析。
- en: '![Texto  Descrição gerada automaticamente](img/B19820_04_17.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Texto Descrição gerada automaticamente](img/B19820_04_17.png)'
- en: 'Figure 4.17: SonarAnalyzer.CSharp analysis result'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17：SonarAnalyzer.CSharp 分析结果
- en: As a software architect, you will always have to pay attention and take action
    to get projects unified with the same code standard, so the NuGet option may be
    useful for achieving this goal.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，您将始终需要关注并采取行动，以确保项目使用相同的代码标准统一，因此 NuGet 选项可能有助于实现这一目标。
- en: Checking the final code after analysis
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析后的最终代码检查
- en: 'Following the analysis of the two options presented, we have finally solved
    all the issues with the original code. Here is the final code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析了两种选项之后，我们最终解决了原始代码中的所有问题。以下是最终代码：
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the preceding code is not only easier to understand but is also
    safer and able to consider different paths of programming, since the default for
    `switch-case` was programmed. This pattern was discussed earlier in this chapter,
    which brings us to the happy conclusion that best practices can easily be followed
    by using one (or all) of the options discussed in this chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的代码不仅更容易理解，而且更安全，能够考虑不同的编程路径，因为已经为 `switch-case` 编程了默认值。这个模式在本章中已经讨论过，这让我们得出一个愉快的结论，即最佳实践可以通过使用本章讨论的（或所有）选项之一（或全部）来轻松遵循。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed some important tips for writing safe code. This
    chapter introduced a tool for analyzing code metrics so that you can manage the
    complexity and maintainability of the software you develop. To finish, we presented
    some good tips to guarantee that your software will not crash due to memory leaks
    and exceptions. In real life, a software architect will always be asked to solve
    this kind of problem.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些编写安全代码的重要提示。本章介绍了一个分析代码指标的工具，以便您可以管理您开发的软件的复杂性和可维护性。最后，我们提出了一些保证您的软件不会因内存泄漏和异常而崩溃的好建议。在现实生活中，软件架构师总会被要求解决这类问题。
- en: The chapter also recommended tools that can be used to apply the best practices
    of the coding we discussed. We looked at the Roslyn compiler, which enables code
    analysis while a developer codes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还推荐了一些可以用来应用我们讨论的编码最佳实践的工具体。我们探讨了 Roslyn 编译器，它允许在开发者编码时进行代码分析。
- en: You will find in *Chapter 21*, *Case Study*, a way to evaluate C# code prior
    to publishing an application, which implements code analysis during the Azure
    DevOps building process, using SonarCloud.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在第 21 章“案例研究”中找到一个在发布应用程序之前评估 C# 代码的方法，该方法在 Azure DevOps 构建过程中使用 SonarCloud
    进行代码分析。
- en: When you apply all the content you have learned in this chapter to your projects,
    you will find that code analysis will give you the opportunity to improve the
    quality of the code you deliver to your customers. This is a very important part
    of your role as a software architect.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将本章所学的内容应用到你的项目中时，你会发现代码分析将为你提供改进交付给客户代码质量的机会。这是你作为软件架构师角色中非常重要的一个部分。
- en: In the next chapter, you will learn about code reuse, which is an incredible
    technique to guarantee quality and velocity for your projects!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于代码重用的知识，这是一种保证项目质量和速度的惊人技术！
- en: Questions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why do we need to care about maintainability?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要关注可维护性？
- en: What is cyclomatic complexity?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是循环复杂度？
- en: List the advantages of using a version control system.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出使用版本控制系统的优势。
- en: What is the garbage collector?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是垃圾回收器？
- en: What is the importance of implementing the `IDisposable` interface?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现IDisposable接口的重要性是什么？
- en: What advantages do we gain from .NET 8 when it comes to coding?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 .NET 8 我们在编码方面获得了哪些优势？
- en: What makes it possible for a piece of software to be described as having well-written
    code?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么使得一段软件代码可以被描述为编写得很好？
- en: What is Roslyn?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Roslyn？
- en: What is code analysis?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是代码分析？
- en: What is the importance of code analysis?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码分析的重要性是什么？
- en: How does Roslyn help with code analysis?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Roslyn 如何帮助进行代码分析？
- en: What are Visual Studio extensions?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Visual Studio 扩展？
- en: What extension tools are available for code analysis?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可用于代码分析的可扩展工具有哪些？
- en: Further reading
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These are some books and websites where you will find more information about
    the topics of this chapter:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些书籍和网站，你可以在那里找到更多关于本章主题的信息：
- en: '*Clean Code*: *A Handbook of Agile Software Craftmanship*, by Martin, Robert
    C. Pearson Education, 2012.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《代码整洁之道》：*敏捷软件开发工艺手册*，马丁，罗伯特·C·皮尔森教育，2012 年。'
- en: '*The Art of Designing Embedded Systems*, by Jack G. Ganssle. Elsevier, 1999.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《嵌入式系统设计艺术》，杰克·G·甘斯勒著。Elsevier，1999 年。'
- en: '*Refactoring*, by Martin Fowler. Addison-Wesley, 2018.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《重构》，马丁·福勒著。Addison-Wesley，2018 年。'
- en: '*A Complexity Measure*, by Thomas J. McCabe. IEEE Trans. Software Eng. 2(4):
    308–320, 1976 ([https://dblp.uni-trier.de/db/journals/tse/tse2.html](https://dblp.uni-trier.de/db/journals/tse/tse2.html)).'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《复杂性度量》，托马斯·J·麦卡贝著。IEEE 软件工程杂志，第 2 卷第 4 期，1976 年，第 308-320 页 ([https://dblp.uni-trier.de/db/journals/tse/tse2.html](https://dblp.uni-trier.de/db/journals/tse/tse2.html))。'
- en: 'Code metrics information:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码度量信息：
- en: '[https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/](https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/)'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/](https://blogs.msdn.microsoft.com/zainnab/2011/05/25/code-metrics-class-coupling/)'
- en: '[https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019)'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2019)'
- en: 'Version control systems:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制系统：
- en: '[https://github.com/](https://github.com/)'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/](https://github.com/)'
- en: '[https://bitbucket.org/](https://bitbucket.org/)'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bitbucket.org/](https://bitbucket.org/)'
- en: '[https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/)'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/)'
- en: 'Code branching techniques:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码分支技术：
- en: '[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)'
- en: 'Logging fundamentals:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志基础：
- en: '[https://docs.microsoft.com/aspnet/core/fundamentals/logging/](https://docs.microsoft.com/aspnet/core/fundamentals/logging/)'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/aspnet/core/fundamentals/logging/](https://docs.microsoft.com/aspnet/core/fundamentals/logging/)'
- en: 'What is new in CSharp?:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSharp 有什么新内容？
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9)'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-9)'
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10)'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10)'
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11)'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-11)'
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12)'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-12)'
- en: 'Source code analyzers:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码分析器：
- en: '[https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2019](https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2019)'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2019](https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2019)'
- en: '[https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2022](https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2022)'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2022](https://marketplace.visualstudio.com/items?itemName=SonarSource.SonarLintforVisualStudio2022)'
- en: '[https://github.com/dotnet/roslyn-analyzers](https://github.com/dotnet/roslyn-analyzers)'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/dotnet/roslyn-analyzers](https://github.com/dotnet/roslyn-analyzers)'
- en: '[https://docs.microsoft.com/en-us/visualstudio/ide/code-styles-and-code-cleanup](https://docs.microsoft.com/en-us/visualstudio/ide/code-styles-and-code-cleanup)'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/visualstudio/ide/code-styles-and-code-cleanup](https://docs.microsoft.com/en-us/visualstudio/ide/code-styles-and-code-cleanup)'
- en: '[https://docs.sonarcloud.io/](https://docs.sonarcloud.io/)'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.sonarcloud.io/](https://docs.sonarcloud.io/)'
- en: '[https://www.guidgenerator.com/](https://www.guidgenerator.com/ )'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.guidgenerator.com/](https://www.guidgenerator.com/ )'
- en: Learn more on Discord
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多信息
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code175081751210902046.png)'
