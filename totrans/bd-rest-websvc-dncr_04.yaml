- en: Item Catalogue, Cart, and Checkout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will take a look at coding the main sections of an e-commerce app
    and its related API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed user registration and authentication in the previous
    chapter, and we will be carrying forward that knowledge to help us implement security
    inside different controllers that we build in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To display products and search for them efficiently, we are also going to design
    `ProductsController`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will also look at how to put your products into your shopping
    cart, discussing how to add, update, and delete items in a cart.
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, we will also take a look at order management and processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing different controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product listing and product searching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding, updating, and deleting cart items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imposing security on controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order processing and shipping information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are going to learn about the core functions of our app, we need to design
    its controllers so that we have REST endpoints to perform tasks from our client.
    Things such as *product listing*, *product searching*, *add to cart*, *placing
    orders*, and *processing shipments* can be done with one dedicated controller
    for each function. These controllers will be responsible for performing actions
    on the database, so we need to model classes for the related tables. Let's get
    to work!
  prefs: []
  type: TYPE_NORMAL
- en: Generating models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following line can be executed inside the Package Manager Console to generate
    model classes for all the tables in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will populate class files for each table inside the `Models`
    folder, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/281b8757-ef5d-40b2-b86c-3702e6fdbabc.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have not already done so, please refer to the database script in [https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core)
    to generate the database table for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Generating controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To generate controllers for the models, right-click on `Controllers` folder
    | Add | Controller | API Controller with actions, using Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's start with `ProductsdetailsController`, as we want to show the
    products list to our customers initially.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Productsdetail.cs` model class generated through scaffolding should look
    like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can also be used to generate the controller with `GET`,
    `POST`, `PUT`, and `DELETE` action methods: (We''re focusing on the `GetProductsdetail`
    method for now.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can quickly test whether your controller is working using Postman, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6c1645c-c091-4b39-9e5e-8da4ea9e01ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the URL is `http://localhost:57571/api/Productsdetails` and the type is
    `GET`. We can see the results in the result box, which shows us an array of product
    details in a JSON format. Note that we sent this request by setting the `contentType`
    header with the value `application/json` inside the request's Header tab.
  prefs: []
  type: TYPE_NORMAL
- en: Product listing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now design the jQuery code needed to consume this endpoint so that we
    can show these records on a web page and list our products available to buy. This
    should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To get the code to call the API in different languages, you can click on the
    *code* link inside Postman and then select the desired language. We have already
    discussed this in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding method makes a call to the endpoint `http://localhost:57571/api/Productsdetails`
    and loops through the records after receiving them with the `success` method.
    While looping, it builds an HTML table row that appends to a pre-existing table
    on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is the reflection of the jQuery code which is showing
    the details of all products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c88b2b8d-1a9f-4846-bfd2-367b627532fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that we have one Search box at the top, as well as Add To Cart buttons
    for each product. We will take a look at these functionalities later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice that the product''s main parameter, the price, is not displayed?
    This is because the price isn''t present in the `Productdetail` table. So, let''s
    now take a look at the `Product.cs` model class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, the `Product` class contains everything we need including `Name`, `Description`,
    `Url`, `Views`, and so on, with `Productdetail` as a reference point. We have
    already consumed the `GET` action of `ProductdetailsController` to display our
    products, so now it's time to read all of our products using `ProductsController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GET` action of `ProductsController` would return us all of the product
    records in `Productdetail`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The snippet in bold in the preceding code is the `Include` clause, which is
    used to include results from the `Productdetail`. Now, instead of calling `/api/Productsdetails`,
    we will call `/api/Products`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling this endpoint won''t actually work, this is because of circular reference.
    If you observe both the `Products` and `Productdetail` models closely, you should
    see that both contain references to each other. This creates a problem when parsing
    to JSON. To avoid this, we need to write the following code inside `Startup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`services.AddMvc()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`.AddJsonOptions(options =>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{`'
  prefs: []
  type: TYPE_NORMAL
- en: '`options.SerializerSettings.ReferenceLoopHandling =`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReferenceLoopHandling.Ignore;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now have a look at the response we receive for one product when we call
    this endpoint, as shown in the following snippet. Note that you would get an array
    in reality, but we are only showing you one record for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to alter our client-side code to reflect the fact that `Productdetail`
    is now inside the `Product` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That was easy to understand, wasn't it? Here, you should notice the changes
    we made to the URL and how we read the product details. `Productsdetail` is inside
    the `Product` object as an array, so it is written as `value.productsdetail[0]`,
    where `value` is the product object. We also introduced `value.price`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see the following screenshot, which has been updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b9d9b63-0b41-4a06-8d3b-c2bb24178216.png)'
  prefs: []
  type: TYPE_IMG
- en: Product searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's now time to implement the search feature, allowing customers to put any
    string inside the search box to look up a product. We need to add one search button
    to the UI, which when clicked will receive the entered string and fetch records
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the `action` method needs to accept the search text entered by a customer
    as a parameter; currently, `GetProducts()` does not accept any parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated `GetProducts()` should look like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `searchText` parameter is taken into consideration and the results are filtered
    by the title of a book, which resides in the `Name` field of the `Productsdetail`
    collection inside the `Product` object. Thus, `Any` is used to check if the `searchText`
    is present in the `Productsdetail` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the API is ready to search, let''s update the client-side code to
    send the parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding snippet, `LoadProducts` now accepts a `searchText`
    parameter that is passed to the API as a URL parameter. Now it is just a matter
    of sending the parameter value to this method while calling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code illustrates the search function as it fetches text and executes
    `LoadProducts` with the entered value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows this function in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92ffc624-a897-4b61-ba88-b4733c80a311.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding to cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re now ready for the next important topic: all about adding to cart! Before
    implementing this function, however, there is something worth taking note of.
    In our application, we are not going to allow unknown users to add to cart, as
    we will be storing any information related to the cart in our database.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is where security comes in, namely, authentication. As discussed in [Chapter
    3](09fe6ad3-7061-4ae2-a2cb-c454ba802985.xhtml), *User Registration and Administration*,
    basic authentication can be applied with the help of handlers, or bearer authentication
    can be applied with the help of tokens.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's generate `CartsController` using the same steps as previously.
    We now need to apply the `[Authorize]` attribute to the controller directly, so
    that all operations in the cart can be authenticated. Our app is already set up
    to handle bearer authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a code snapshot of `CartsController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Due to the `[Authorize]` attribute, this controller won't allow you to access
    the `GET`, `POST`, `PUT`, and `DELETE` action methods if you don't provide the
    access token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start designing some cart-related functions on the client side and try
    to call the action methods in this controller, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43c4f6fe-749c-4aa6-9e7d-fa1b32a95f35.png)'
  prefs: []
  type: TYPE_IMG
- en: Client-side AddToCart function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a customer hits Add To Cart, information is added to another HTML table
    called My Cart. If you hit Add To Cart twice for one product, its quantity is
    updated to 2 and the price is calculated accordingly. Each click assumes one unit
    of a particular product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now dive into the code. The following snippet shows us the `AddToCart`
    function for JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function takes the parameters `productId`, `productName`, `qty`, and `price`
    as this information is shown in the cart HTML table.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, in the preceding image, that there is a delete icon in each row. This
    is produced by adding a `glyphicon` inside a span that is wrapped with an anchor
    whose `click` event is also defined. We will take a look at the delete functionality
    later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note the `data-product-id` attribute that has been added to the row. This
    helps us identify a cart row uniquely, and you will see how that helps in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: We are now all set to call `CartsController` to insert cart details into the
    database. However, we still need one more thing inside this method. After all,
    what happens if a product is added to the cart unexpectedly?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we need the opportunity to update the cart, instead of just adding products
    to it, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Simple, isn't it? First, the record is fetched from the cart table with the
    help of a product ID and then its quantity and price is updated accordingly. From
    that block, a `return` statement ensures that the record isn't added to the table
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Now everything should work on the client side. We now just need to call our
    APIs to involve database operations so that any rows that have been inserted,
    updated, and deleted are also updated on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: API calls for AddToCart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at the actual API calls made by the client.
  prefs: []
  type: TYPE_NORMAL
- en: POST – api/Carts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inserting data into the cart table can be done by calling the `POST` action,
    which should look like the following code block in `CartsController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The client-side function to call this action can be designed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Straightforward, isn''t it? Now we can build a cart object and send it a `POST`
    action. You can try this out by calling the following method inside our `AddToCart()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first parameter is `Customerid`, which we have hard-coded. `Customerid`
    can be held in session storage for any requests—although this is considered a
    risky practice.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of sending the `Customerid`, you can send the email id to the POST action.
    Then using email id, you can get the `Customerid`, which can be used to insert
    a Cart record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now run our app and click on Add To Cart for a particular product. Oops!
    The following error has appeared in the developer tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/240e3e1e-4746-4876-b4bc-8e23d8b1b07b.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Why has this happened?*'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this error is actually pretty obvious. As an `[Authorize]` attribute
    has been applied to the controller, every call to `CartsController` now expects
    a token generated by a request to the OAuth2.0 Authorize server with `Email Id`
    and `Password`.
  prefs: []
  type: TYPE_NORMAL
- en: We already explored *OAuth2.0 Authentication* in detail.
  prefs: []
  type: TYPE_NORMAL
- en: To move on with our implementation, we will call the token server from Postman
    and use that inside our app. Ideally, when you receive an Unauthorized error,
    you should open the login screen so that the user can log in. If `Email Id` and
    `Password` are validated, a token would be returned. This token can be used for
    further requests, such as Add To Cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save time and space, we will generate a token using Postman directly by
    using `taditdash@gmail.com` as our email ID and `12345` as our password*.* The
    subsequent Ajax call with the token should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have removed the token string in the preceding snippet for brevity.
    With the previous code, one cart record will be created and data returned from
    the API will give us all the detail about that record. You can store the cart's
    `Id` on the HTML row (as shown inside the preceding code block) for further processing
    while updating or deleting the cart record.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot of the Elements tab in the Chrome Developer Tool illustrates
    the cart record''s ID stored as a `data-cart-id` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0855f623-f91a-4c67-bd89-27533f9274e6.png)'
  prefs: []
  type: TYPE_IMG
- en: PUT – api/Carts/{id}
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have added one cart record, let''s move to update that record whenever
    a customer repeatedly hits the Add To Cart button. We already have the code that
    updates the quantity and price on the client-side table, so we just need to write
    the code to call the `PUT` endpoint to update the record, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The important part of the preceding code is the URL, which also contains the
    cart `Id` because the route is actually `api/Carts/{id}`. The data goes inside
    the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter `cartItem` is the row which can be passed from the `AddToCart`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The API action should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `id` is read from the route, as it is marked with the attribute
    `[FromRoute]`, and the cart object is read from the body of the request, as it
    is marked `[FromBody]`. If an ID is not sent with a route, the client would receive
    a 400 BadRequest error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API action has now updated the record with the necessary details, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fdcedea-ae97-4a06-8a44-167ae0bf3b07.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have clicked Add To Cart four times. The `finalPrice` is
    calculated accordingly as `49.99 * 4`.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE – api/Carts/{id}
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Route `/api/Carts/{id}` tells us that we just need to send the cart `Id` to
    the API; everything else will be handled by the API so as to delete the record
    from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The action method for deleting a record is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The client-side application has to be updated to allow this feature. As the
    delete icon is already shown on every cart row on the HTML table, we just need
    to send the cart's ID to the API when clicked by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following JavaScript function can be used to delete a cart record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `DeleteCart` function expects one parameter, `cartId`, which
    will be provided when the delete icon is clicked. This function calls the API
    with the type `DELETE`, as well as the `Id` and URL. On successful deletion, the
    cart row is removed from the HTML table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code block where `DeleteCart` is called is inside `AddToCart`, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`DeleteCart` is called inside the click event of the anchor where the delete
    icon is shown. Inside the event, we get the cart `Id` from the row itself by extracting
    the value of the `data-cart-id` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: Placing orders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our cart is now full with the correct number of the desired products, so it's
    now time to place our order. For that, we need to call another controller—`OrdersController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two tables are responsible for the ordering process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Orders**: This stores the shipping address details, customer details, order
    status, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OrdersProducts**: This stores the products added to the cart, their price,
    and their quantity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Orders` class is generated by the scaffolding we did initially, which contains
    all the necessary information. Let's generate the controller with this class.
    Follow the same process to generate the controller as we did for `ProductsController`,
    `ProductsdetailsController`, and `CartsController`.
  prefs: []
  type: TYPE_NORMAL
- en: The model and controller class can be found in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to call the `POST` action of `OrdersController` to save the
    order on the client-side. The following code is the skeleton of the function that
    does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let's now explain this step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: UI design for placing an order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on any further, we need to show a modal to the user where they
    can enter their shipping address. The modal will be opened once the Place Order
    button is clicked, as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be1c0d95-e89f-4215-bdb1-17aeb01e44e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code snippet illustrates the click event for Place Order (the
    modal is opened if cart items are present):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'An Ajax call inserts an order''s record in the database by clicking Submit
    using `POST`. The following code snippet is the click event of Submit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The client-side PostOrder function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now move on to the steps required for `PostOrders`.
  prefs: []
  type: TYPE_NORMAL
- en: Building order objects to match the model class Orders.cs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we have to read the values from the text boxes related to shipping information
    and match them with the fields of `Orders.cs` to build an object. `OrdersProducts`
    is an array representing the model class, `OrdersProducts.cs`. Every order can
    have multiple products associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code implements order objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Pushing cart items into an order object as an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Populating the `OrdersProducts` array is the next step, and this can be done
    by looping through the cart table''s rows and pushing each cart row''s details
    to the array. Inside the loop, read all the necessary values from the row, either
    from its attribute or `td`. Remember to form an object and assign the values to
    field names that match the model class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Calling POST /api/Orders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Great, now we have our object! It''s now time to call the API `/api/Orders`
    with a `POST` request so that our order goes into the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything works correctly, you should see something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73a57966-56ba-42d0-89d3-7692b980e20b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But we are forgetting something here; although our order has been placed successfully,
    we need to empty the cart. This can be done by calling `DELETE /api/Carts` for
    each cart item inside the `success` function of `PostOrders`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We've explored everything from the client side, so now it's time to check the
    API.
  prefs: []
  type: TYPE_NORMAL
- en: PostOrders API POST method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Orders table looks a little different to what we sent to the client. In
    the following screenshot, note the fields marked in boxes. These are the fields
    we are not sending and will instead manipulate inside the action method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c498012d-ce9e-4bfd-9946-601fd6c4d6a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fields such as name, email, and telephone number can be fetched from the Customers
    table. `Customerid` is sent from the client, using which we will fetch these details,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet illustrates how a user can copy their billing address
    so that it is also their delivery address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Additional fields, including `datapurchased`, `lastmodified`, and `orderdatefinished`,
    will be set as `DateTime.Now`. Details such as `currency` and `currency_value`
    will be set as dollars ($) and zero (0). We will also set `Guid.NewGuid` as `shipingmethodid`
    and `paymentmethodid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These can be made inside the Orders constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `Orderstatus` is Placed. This is something that can be updated
    by the site when an order is ready for shipping. Subsequent statuses might include
    Approved, Ready, Shipped, Delivered, and so on. If you design the admin screen,
    make sure you handle this field update along with `latsmodified` and `orderdatefinished`.
  prefs: []
  type: TYPE_NORMAL
- en: The application demonstrated in this book is not production-ready. Generally,
    there should be a login page that works with *OAuth2.0 Authentication*. Basic
    validations on the API side, as well as the client side, also need to be handled.
    In this book, our application is built to showcase the concepts we are exploring,
    but you can definitely optimize our example and even build on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing shipping details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GET` requests can be used on `OrdersController` with an order ID so that order
    details can be consumed by third party sites for display. For example, many courier
    companies expose their APIs, which is used by other sites to display order, shipment,
    and tracking information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s check out our `GET` method `OrdersController`, which
    takes the ID as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `Include` clause is used to include results from the `OrdersProducts`
    table. Let''s now perform a quick Postman call to this endpoint to see the result
    of our earlier order, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/538eb690-57ed-4097-9e78-4856fce019ef.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can see every detail relating to the order, along with its products,
    are returned from the API.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've reached this point of the book, you will have designed some cool things
    using APIs. Well done!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we moved towards consuming `ProductsController` to display
    the product list on our client-side app. Product attributes along with their pricing
    details were shown with a simple UI that was designed using Bootstrap, jQuery,
    and HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Slightly modified `GET` requests inside `ProductsController` with a `searchString`
    parameter helped us to retrieve search results from the API. Clients could easily
    implement the search function by consuming the endpoint with text.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at our shopping cart. We explored how `CartsController` actions
    can be consumed to add, update, and delete cart items while updating the UI. In
    the process, we implemented security for the controller using authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we converted the items in our cart into a visualized order. This was
    done using `OrdersController`, which can also be used to provide shipping and
    tracking information to clients.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to take a look at different techniques for
    testing the RESTful Web API designed in .NET Core.
  prefs: []
  type: TYPE_NORMAL
