- en: Using Resources and MVVM Patterns
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using binary resources inside a WPF application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using binary resources from another assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing binary resources in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using static logical resources in WPF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dynamic logical resources in WPF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing logical resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using user selected colors and fonts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an application using the MVVM pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using routed commands in a WPF application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While binary resources play a vital role in any application, WPF also provides
    a different kind of resource, called a **logical resource**. These logical resources
    are objects that can be shared throughout the application and can be accessed
    across multiple assemblies. These can be of two types, static logical resources
    and dynamic logical resources.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, **MVVM** (**Model-View-ViewModel**) is a pattern that keeps
    a separation between the UI and the code, giving the designers and developers
    the flexibility to work on a single window without depending on each other.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will first cover binary resources, logical resources, and
    then move forward to learn building applications using the MVVM pattern. We will
    also cover how to use **RoutedCommands** to demonstrate the **Command Design Pattern**
    in WPF applications, which can be invoked from multiple locations.
  prefs: []
  type: TYPE_NORMAL
- en: Using binary resources inside a WPF application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Binary resources** are chunks of bytes added to a project with `Build Action`
    defined for it. Generally, these are images, logos, fonts, files, and so on, which
    are required by the application and are bundled with it.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use binary resources in a WPF application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, open your Visual Studio IDE and create a new project called
    `CH07.BinaryResourceDemo`. Make sure you select the WPF app as the project template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add images as binary resources inside a WPF application
    and load them into the application window:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the project to add a new folder. Follow the context menu path
    Add | New Folder. Rename the newly created folder as `Images`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44e88c7a-c8c1-48b6-937f-30c1f87cff37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now right-click on the Images folder to add a few images. From the context
    menu entry, select Add | Existing Item... and add two images of your choice. In
    this example, we have added two existing images, `image1.png` and `image2.png`,
    for demonstration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b4680435-a8c0-4974-bd50-7bbe6225cd56.png)'
  prefs: []
  type: TYPE_IMG
- en: From the Solution Explorer, right-click on the `image1.png` and go to its Properties.
    Set the Build Action of the image to Resource, which is the default:![](img/036e79bb-4c39-4c89-b047-a31b46c3ed42.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now right-click on the `image2.png` from Solution Explorer, and go to its Properties.
    Set its Build Action to Content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Copy to Output Directory to Copy Always:![](img/07e35f07-20d2-488a-8b3e-6b341e52228a.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Solution Explorer, open the `MainWindow.xaml` and replace the `Grid`
    with a horizontal `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now insert the two images inside the `StackPanel`, and set their `Source` property
    to `Images/image1.png` and `Images/image2.png`, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Build the project and run the application. You will see the following UI on
    the screen:![](img/002cfccd-a915-4aab-935b-d56a35475d18.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go to the project's bin | Debug directory. You will see a folder named Images
    containing the image (`image2.png`) that we defined as `Build Action = Content`
    and `Copy to Output Directory = Copy Always`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now replace the `image2.png` with a different image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application now, directly from the bin | Debug folder, instead of recompiling
    the project. Observe the output on the screen. You will see that the second image
    now points to the new image that we have placed in the bin | Debug | Images folder:![](img/a7c3afee-7d81-4e26-9481-788a577e7765.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `Build Action` is set to `Resource`, the file is stored as a resource
    inside the compiled assembly. In our case, `image1.png` was set to `Resource`
    inside the project binary, which makes the actual image file unnecessary while
    deploying the application.
  prefs: []
  type: TYPE_NORMAL
- en: When the `Build Action` is set to `Content`, the resource is not included in
    the assembly. To make it available to the application, `Copy to Output Directory`
    needs to be set to either `Copy Always` or `Copy if Newer`.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it more appropriate for when the resource needs to change often and
    a rebuild would be undesirable. If the resource is not available in the output
    directory, this will render a blank image while executing. If the resource is
    large and not always needed, it's better to leave it to the resulting assembly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While inserting the image in the XAML, we often use the relative URI (`Images/image1.png`,
    in our case) as it is relative to the application. You can also assign it more
    verbosely as `pack://application:,,,/Images/image1.png`, which is generally used
    while assigning the image source from the code behind.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the Visual Studio editor to assign the image source. To do
    so, right-click on the image from the XAML designer view and go to its Properties.
    From the Properties panel, click the dropdown arrow, as shown in the following
    screenshot, to select the desired image from the available items in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/068c8aa0-cf52-49d8-8e07-fad215f2a18a.png)'
  prefs: []
  type: TYPE_IMG
- en: Using binary resources from another assembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not mandatory to have the resources defined in the same assembly where
    they are going to be used. Sometime, on an as-needed basis, the binary resources
    are defined in one assembly (generally, a class library), and used in another
    assembly.
  prefs: []
  type: TYPE_NORMAL
- en: WPF provides a uniform way of accessing these resources defined in other assemblies.
    To work with this, we need to use the pack URI scheme. In this recipe, we will
    learn how to use binary resources from another assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin with creating a new project called `CH07.RemoteBinaryResourceDemo`.
    Make sure you select the WPF app template while creating this project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a class library to define the binary resource
    and use it from the application that we have already created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another project within the same solution. Let''s name it `CH07.ResourceLibrary`,
    and make sure you select Class Library (.NET Framework) as the project template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dcd734ec-5fcb-4e7a-8a24-5c8f0515d404.png)'
  prefs: []
  type: TYPE_IMG
- en: Remove the autogenerated class file `Class1.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now right-click on the project `CH07.ResourceLibrary` and create a new folder
    named `Images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now right-click on the newly created folder and add an existing image (`image1.png`,
    in our case) into that folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then right-click on the image (`image1.png`) and navigate to its Properties
    pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As demonstrated in the previous recipe, change its Build Action to `Resource`.
    Compile the project `CH07.ResourceLibrary` to make sure that the build is successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Solution Explorer, right-click on the other project named `CH07.RemoteBinaryResourceDemo`
    and navigate through the context menu entry Add | Reference... to add the assembly
    reference of the class library in this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the Reference Manager dialog window, navigate to Projects and select the
    class library (CH07.ResourceLibrary) that we created. As shown in the following
    screenshot, click OK once you are done. This will add our class library as a reference
    to our application project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/284ff79f-6ca0-4479-84c7-cf1bd16b8292.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, from the Solution Explorer, navigate to the `MainWindow.xaml` file of
    the `CH07.RemoteBinaryResourceDemo` project and add the following image inside
    the `Grid`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile the solution and run the application. You will see that the
    application window launches with an image, which is present in a different assembly.
    Here''s a screenshot, based on our demo application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9ec1e76a-333b-4b46-96d0-1d6a2e5d6be4.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are using a referenced assembly, the WPF pack URI recognizes it as
    `/AssemblyReference;component/ResourceName` format. In the preceding example,
    the **AssemblyReference** is the name of the assembly, which is `CH07.ResourceLibrary`
    in our case, and the **ResourceName** is the complete path of the resource relative
    to the project component.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An `AssemblyReference` may also include a version and/or the public key token
    (in case the assembly is strongly named). The version is denoted by prefixing
    it with a `v,` as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This does not work with resources marked with `Build Action` as `Content`.
    To work with this, we need to use the full pack URI with a `siteOfOrigin` base,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the Visual Studio Designer window will fail to load the image
    when `siteOfOrigin` is used, but this will work fine in runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing binary resources in code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing binary resources in XAML is very simple, but there is an option to
    read a binary resource from the code behind. In this recipe, we will learn how
    to read a binary resource in code and set it in the UI. We will be using an image
    as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your Visual Studio IDE. Let's begin with creating a new WPF project called
    `CH07.BinaryResourceFromCodeDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to read an image file, embedded as a `Resource`, and display
    it in the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a folder named `Images` inside the project and add an image inside
    it. Let's name the image `image1.png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file by navigating to Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an image tag inside the `Grid` panel and name it `img`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the `MainWindow.xaml.cs` file and, inside the constructor of the class,
    just after the `InitializeComponent()` call, create the `streamResourceInfo` from
    the resource stream of the image. Here''s the code to get the stream info:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create the instance of `BitmapImage` from that stream. Copy
    the following content and pass the `streamResourceInfo.Stream` to the `StreamSource`
    property of the `BitmapImage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now set the `bitmapImage` instance to the `Source` property of the image::'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the complete code for accessing the stream and assigning it to the
    image source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once done, build the project and run it. You will see that the assigned image
    is loaded into the application window:![](img/ce158173-a1ee-4262-8b93-569ad106ac6f.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The static method `Application.GetResourceStream` provides an easy way of accessing
    a resource using its relative URI. It returns a `StreamResourceInfo` object. The
    `Stream` property of the `StreamResourceInfo` object provides access to the actual
    binary data, which has been set as the image source property by converting it
    to an instance of `BitmapImage`.
  prefs: []
  type: TYPE_NORMAL
- en: For the `Application.GetResourceStream` method to work, the resource must be
    marked as a `Resource` in `Build Action`.
  prefs: []
  type: TYPE_NORMAL
- en: If the resource has been marked as `Content` in the `Build Action` property,
    then the `Application.GetContentStream` method should be used to get the resource
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: Using static logical resources in WPF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logical resources in WPF are the objects that can be shared and reused across
    some part of a Visual Tree or an entire application. These can be colors, brushes,
    geometrics, styles, or any other .NET objects (`int`, `string`, `List<T>`, `T`,
    and more) defined by the .NET Framework or developer. These objects are typically
    placed inside a `ResourceDictionary`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use logical resources using the binding
    key `StaticResource`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that Visual Studio is running. Create a project called `CH07.StaticResourceDemo`,
    based on the WPF application template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a logical resource and use it inside the application
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file and replace the `Grid` with a horizontal `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert a `Border` control inside the `StackPanel`. Set its `Height` and `Width`
    properties to `80` and `150,` respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a background color to the `Border` control. We will be using a linear
    gradient brush to decorate the background color. Let''s modify it as shared here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Copy the same border with the preceding background and paste it inside the same
    panel. Now the `StackPanel` will have two border controls with the same properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's build the project and run it. You will see two rectangular shapes with
    a nice gradient color as the background:![](img/916b85ed-1009-4414-acf1-c7ecaae40aa3.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see, we have added the same background brush twice to represent
    the color; it''s sometimes difficult to manage, and unnecessarily increases the
    XAML code as well as the complexity. To resolve this, we can now move the brush
    object as a logical resource, and access it within the same window or throughout
    the application. Let''s move it to the window level. Insert the `LinearGradientBrush`
    inside the window resource (`Window.Resources`) and assign a key (`myLinearBrush`)
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now remove the background definition in both the controls and replace it with
    a binding to the previously mentioned brush. As it is defined within the resource,
    we will be using `{StaticResource}` to access it. Here''s the modified version
    of the border controls inside the panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the application once again. You will see the same background applied
    to the rectangular shaped border controls. In this case, we have used just one
    definition of the brush.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every UI element derived from the `FrameworkElement` has a property called `Resources`,
    which is of type `ResourceDictionary`. Thus, every element can have resources
    associated with it. In XAML, we need to define the `x:Key` attribute to the resource
    to access it, either from the XAML or from the code-behind file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we defined `myLinearBrush` as an element of the `ResourceCollection`
    of the `Window`. Thus, it will be accessible by any control within the same window.
    If you move the definition inside the `StackPanel`, it will be accessible within
    that panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To use this resource in XAML, we need to use the markup extension, `{StaticResource}`,
    along with the resource key provided, `Background="{StaticResource myLinearBrush}"`,
    which will create the binding between them.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to manage the logical resources from the code behind. You can
    call the `FindResource` method, passing the resource key to it, to get the instance
    of the resource. Here''s how you can find the resource named `myLinearBrush`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also programmatically add or remove a resource to the collection. Call
    the methods `Resources.Add` and `Resources.Remove` to add or remove a specific
    resource, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As the `Resources` property is basically a `Dictionary` object, make sure you
    check whether the specified key is already present before doing any operation,
    such as `Add`/`Remove`, on it.
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic logical resources in WPF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to use logical resources using the `StaticResource`
    markup extension. In this recipe, we will learn how to use logical resources using
    the `DynamicResource` markup extension and will also learn the difference between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get started by creating a new project. Open the Visual Studio IDE and create
    a new WPF application project called `CH07.DynamicResourceDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to use logical resources dynamically and modify the values
    of the resource as per the need:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file and replace the `Grid` with a `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a border inside the `StackPanel` and set its dimensions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add another `StackPanel` inside the panel and add a group of three radio buttons
    inside it. Label them as `Red`, `Green`, and `Blue`. Here''s the complete XAML
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add a `LinearGradientBrush` to the window resources and set its key name
    as `myLinearBrush`. Add some `GradientStop` to define a nice gradient brush, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to bind the defined brush with the `Border` control. Modify the
    XAML to have a `StaticResource` binding between them, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Register `Checked` events for all three radio buttons, so that we can perform
    some changes on the checked status change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the `MainWindow.xaml.cs` and add the following implementation for
    all the radio buttons'' `Checked` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once this has been done, run the application. You will see a rectangle with
    three radio buttons. By default, the Green radio button will be selected. Change
    the selection to Red or Blue to observe the behavior. You will see that the color
    always stays Green, irrespective of the selection:![](img/4e984e14-d3fd-42d0-84d5-fa27cd5c0407.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's close the application and navigate back to `MainWindow.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `StaticResource` to `DynamicResource`, as shared in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the application once again. By default, Green will be selected, and
    the rectangle will have a green gradient background. Change the selection to Red
    or Blue to observe the color change:![](img/f3ebf49a-5140-49cb-a303-c0c53eed5d14.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you bind the logical resource as a `StaticResource`, it causes the binding
    to occur at construction time. On the other hand, the `DynamicResource` markup
    extension binds to a resource dynamically, only when it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, when we registered the resource to the `Background`
    property of the `Border` control as a `StaticResource`, we were not able to see
    the change reflected in the UI, even though we replaced the resource with a new
    object on selection of the radio button. But when we changed the binding to `DynamicResource`,
    the change was automatically reflected. This is because the dynamic resource binding
    refreshes itself if the object changes. But this is not same with the static resource
    binding, as it always keeps referencing the old object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `StaticResource` binding throws an error at design time if the object specified
    by the `x:Key` is not present. On the other hand, `DynamicResource` does not throw
    any exception, and displays as blank. Later, when it finds the `Key`, it binds
    itself with that resource.
  prefs: []
  type: TYPE_NORMAL
- en: '`StaticResource` should be used most of the time, unless there is a need to
    replace resources dynamically. `DynamicResource` should be used by the themes
    that can easily swap the resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Having a large collection of `DynamicResource` on a complex UI can impact the
    performance of the UI. Wherever possible, mark them as `StaticResource`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing logical resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There could be several types of logical resources in a single application, and
    placing them inside a single XAML file (for example, `App.xaml`) will increase
    problems while maintaining them. To resolve this problem, you can separate the
    resources of different types into their own respective files and reference them
    in `App.xaml`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to manage these logical resources with a simple
    example. Though this will be shown with a single file, you can create separate
    files and reference them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming that you have opened Visual Studio, now create a new WPF application
    project called `CH07.ManagingLogicalResourceDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these simple steps to create separate resource files and reference them
    in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: As we want to create a separate resource file, we need to create a file of type
    Resource Dictionary. Inside the Solution Explorer, right-click on the project
    node and create a new folder named `Themes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now right-click on the Themes folder and select Add | Resource Dictionary...
    from the context menu entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/037c287d-47ec-417c-aa89-582f890f6b31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Add New Item dialog, make sure that the Resource Dictionary (WPF) template
    is selected. Name it `Brushes.xaml`, and click Add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1e7d9177-bfbb-436f-b2f3-1b5a3a29d9e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the Solution Explorer, open the newly created file `Brushes.xaml` and
    add the following `LinearGradientBrush` inside the `ResourceDictionary` element
    with a `x:Key` name of `myLinearBrush`. You can add multiple elements inside the
    `ResourceDictionary` to have a resource collection. Make sure you assign a unique
    key name to each one of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `MainWindow.xaml` and replace the `Grid` with the following markup
    to have a `Border` control inside it. Set the size of the element and bind the
    `Background` property with the `myLinearBrush` that we have created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you run the application now, you won't see any elements inside the window,
    because the mapping of the file has not been created yet. As we have the binding
    as `DynamicResource`, you won't see any error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's close the application and open the `App.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `Application.Resources`, add an element named `ResourceDictionary`.
    Inside this, create another element named `ResourceDictionary.MergedDictionaries`
    and load the `ResourceDictionary` that we have created. Here''s how it will look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now run the application once again. You will see a rectangular shaped border
    control in the application window with a nice gradient color, which we have created
    in the `Brushes.xaml` file. Here a screenshot of the application window:![](img/8f442a66-a199-4115-b9cc-f90493e3e3bb.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `ResourceDictionary` can load one or more resource dictionaries using its
    `MergedDictionaries` property (`ResourceDictionary.MergedDictionaries`), which
    is a collection. It''s not always mandatory to have a reference to other resource
    dictionaries, but it can also have its own resources as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `Source` property of the `ResourceDictionary` element must point to the
    location of the `ResourceDictionary`. If that location is within a subfolder,
    that subfolder must be included.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When there exist two or more resources with the same key name that originated
    from multiple merged dictionaries, it will not throw any error or exception. Instead,
    it will load the one from the Resource Dictionary that was added last in the element
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: Using user selected colors and fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is useful to use the system theme in an application UI to have
    a synchronous flow of colors and fonts between the operating system and the application.
    In these cases, we can dynamically load those values and apply them to our UI
    elements. This is achievable by accessing some special resource keys within the
    `SystemColors` and `SystemFonts` classes. In this recipe, we will learn how to
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started by creating a new project called `CH07.SystemResourcesDemo`.
    Make sure you select the WPF application template from the available list.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now build an application that uses system colors and fonts. Follow
    these steps to proceed with it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` file and insert the following `Rectangle` inside
    the `Grid` panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to fill the rectangle with the color of the desktop brush. Add the
    following markup to fill the background color of the rectangle `Fill="{DynamicResource
    {x:Static SystemColors.DesktopBrushKey}}"`. Now the XAML will look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the application now. You will see that a background color for the
    rectangle has been picked up by the application. This is based on the selection
    that you have for the `DesktopBrush` in your system:![](img/1340d9d6-0d62-44ab-94ee-d9d766cac3ad.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To confirm this, right-click on your desktop and select Personalize. If you
    are using Windows 10, you will see the Settings app navigates to the Background
    Settings page. Check the color that is selected in the Background settings and
    the color applied to your application. Both will be the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d2c2de3c-5b9f-4421-bf6e-86440924c026.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s select a different color from the Background Settings. You will see
    that the color will automatically get applied to your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f1450077-c84c-42f0-9ecc-94214a3123c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Now select the + symbol (Custom color) to select another color of the default
    colors in the palette:![](img/b231a373-0eb6-49e8-ab1b-c9a2c42aa29a.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown here, pick a custom background color for your desktop and click Done:![](img/1c5b0bbb-caea-4289-8540-c9765f2244fa.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the application window now. You will see that the color selected on the
    Settings app is applied to the rectangle background. Navigate to your desktop,
    the same color will be applied there too:![](img/c0237bf1-4e73-48d5-b5c6-a53605d94aac.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is not mandatory to provide a `string` type key name to a resource binding.
    You can also provide a static object to the binding. In this example, we used
    the static value `SystemColors.DesktopBrushKey` in combination with the `{x:Static}`
    markup extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As we have learned about the dynamic resource binding in the previous recipes,
    this example also follows the same method, and thus you can see the selected color
    is automatically applied to the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: There are many static keys under the `SystemColors` class, which you can reference
    in your design. This is often useful when you want your application to be in sync
    with the operating system's theme.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like `SystemColors`, we have the `SystemFonts` class too, which exposes
    font related static properties. You can define `FontFamily`, `FontSize`, and `FontWeight`
    styles from the system palette, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Building an application using the MVVM pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MVVM** stands for **Model**, **View**, and **ViewModel**, which is a pattern
    that facilitates the separation between the **GUI** (**Graphical user interface**)
    from the business logic. It means that a designer and developer can work together,
    without any hassle.'
  prefs: []
  type: TYPE_NORMAL
- en: In this pattern, the model is the data that gets displayed in the view with
    the help of ViewModel. In this recipe, we will learn how to create an MVVM application,
    expose the properties from the ViewModel to the associated view, and display records
    without writing any code in the XAML code behind file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's open the Visual Studio IDE and create a new project, called `CH07.MVVMDemo`,
    based on the WPF app template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the project has been created, follow these steps to construct the project
    for the MVVM standard (not mandatory) and build a sample demo using the MVVM pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Each WPF app project has a `MainWindow.xaml`. From the Solution Explorer, let's
    delete the default file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the project, create three folders named `Models`, `Views`, and `ViewModels`.
    This is just to create a proper structure for all our code files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now right-click on the Views folder, create a new `Window` by following the
    context menu path Add | Window..., and name it `MainWindow.xaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `App.xaml` file and modify the `StartupUri` to point to the correct
    file. As shown in the following screenshot, change the `StartupUri` to `ViewsMainWindow.xaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dcefda1d-53a9-4c40-858f-705bf90bf401.png)'
  prefs: []
  type: TYPE_IMG
- en: Open the `MainWindow.xaml` file from the Views folder and replace the `Grid`
    with a `DockPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two `StackPanel` inside the `Dock` and design the UI, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application now, you will see the application window looks like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1f16a9cb-657c-4b98-afef-8ae15e437a8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, right-click on the Models folder and create a class file named `UserModel.cs`
    and modify the class to have two properties of type `string`. As shown here, name
    them `Firstname` and `Lastname`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Right-click on the ViewModels folder and add another class file. Name it `MainWindowViewModel.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `MainWindowViewModel.cs` file and add the following namespaces inside
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now inherit the `MainWindowViewModel` class from `INotifyPropertyChanged` interface,
    which is present under the `System.ComponentModel` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As we already know, the `INotifyPropertyChanged` interface exposes the `PropertyChanged`
    event handler; we need to register that inside the class. Copy the following code
    to implement the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this has been done, create two properties inside the `ViewModel`. Name
    one `SelectedUser`, which is of type `UserModel` and the other `UserCollection`,
    which is of type `ObservableCollection<UserModel>`. Make sure you call the `OnPropertyChanged(str)`
    method from both the setters, so that the value change can be automatically reported
    to the UI. Here are the properties that we are going to refer to in this demonstration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the constructor of the ViewModel, initialize the `UserCollection` property
    with some dummy data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `viewmodel` is ready, having all the properties that we need, let''s
    associate it with the view as its `DataContext`. You can do this either from the
    code behind or from the XAML itself. As our target is to keep the code behind
    as small as possible, let''s do it from the XAML. Open the `MainWindow.xaml` and
    add the following `XMLNS` entry to it, so that we can access the `viewmodel` that
    we have created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `Window.Resources` tag, add our `viewmodel` as a resource and define
    it as `x:Key="ViewModel"`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `viewmodel` has been registered as a resource, set the `DataContext`
    of the `DockPanel` to the `ViewModel` that we defined. The binding needs to be
    done using the `{StaticResource}` markup extension. Here''s how it will look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now set the `ItemsSource` and the `SelectedItem` properties of the `ListBox`
    control to have a data binding with the properties inside our `viewmodel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, set the `DataContext` property of the `TextBlock` to `SelectedUser`
    and create the data binding, as shown, here to display the selected full name
    of the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Let's run this application now. You will see the following UI, where the values
    in `ListBox` control will be shown as the fully qualified name of the `model`
    class:![](img/2f10b6ca-598c-469a-9ad3-491b8969bb8a.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To resolve this, we need to create the `DataTemplate` of the `ListBox`. Define
    the `ListBox.ItemTemplate` as follows, to have a `TextBlock` with the user''s
    full name, by concatenating the `Firstname` and `Lastname` properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this has been done, the XAML code of the application UI will look similar
    to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the application now. You will see the correct values inside the `ListBox`:![](img/b990e214-aec2-4fcd-85be-c5bad3a12a69.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select any of the `ListBox` items to see the selected username in the `TextBox`.
    Change the selection to update the UI automatically:![](img/2de2c792-f96b-4fa5-913c-4b58d219d4f8.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVVM consists of three important partsâ€”**Model**, **View**, and the **ViewModel**.
    The *Model* represents the data; the *View* is the actual UI, which displays the
    relevant parts of the model; and the *ViewModel* is the mechanism that hands out
    the required data to the view. A ViewModel basically exposes properties and commands,
    and maintains the relevant state of the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compare the MVVM pattern with a bike (as represented in the following
    screenshot), the bike **Body** is the **View**, the **Fuel** is the **Model**
    and the **Engine** of the bike is the **ViewModel**, which moves the View (bike
    body) by burning/using the Model (Fuel):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/733f6b5f-896f-4dab-8037-e6a8e5c9b146.png)'
  prefs: []
  type: TYPE_IMG
- en: In our application, we used the `DataContext` to define the binding between
    the View and the ViewModel, which we then used to access the properties. If you
    now navigate to the `MainWindow.xaml.cs` file, you won't see any additional code
    except the constructor of the code-behind class.
  prefs: []
  type: TYPE_NORMAL
- en: In the MVVM pattern, our intention is to keep the code-behind file (`MainWindow.xaml.cs`)
    code free (or less code), so that the direct binding between the UI and the code
    will be reduced. Note that the MVVM is not a framework, but in using this pattern
    you can create a framework. For example, the **MVVMLight** ([http://www.mvvmlight.net](http://www.mvvmlight.net))
    from **GalaSoft** provides a fully customized framework, which you can use in
    your application to keep the development hassle free.
  prefs: []
  type: TYPE_NORMAL
- en: Using routed commands in a WPF application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Routed commands** are used to navigate a route through the element hierarchy.
    This process is also well known as bubbling and tunneling. The class `RoutedCommand`
    implements the `ICommand` interface and allows the attaching of input gestures,
    such as mouse input and keyboard shortcuts, to the target.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use routed commands with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work on this recipe, we will be using the previous MVVM demo application.
    Launch your Visual Studio IDE and open the project `CH07.MVVMDemo`. In this example,
    we will be using `RoutedCommand` for the Add button click event.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these simple steps to register the routed command to the button click
    and perform the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Solution Explorer, right-click on the project node and create a folder
    named `Commands`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the Commands folder and create a new class named `RoutedCommands.cs`
    by following the Add | Class... context menu path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the class implementation, declare a static member of type `RoutedCommand`
    and name it `AddCommand`. Here''s the code implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following namespace to resolve the `RoutedCommand` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that has been done, navigate to the `MainWindowViewModel.cs` file, present
    under the ViewModels folder, and add a property named `NewUserDetails` of type
    `UserModel`. We will be using this property to bind with the `Text` property of
    the `TextBox` controls present in the UI. The property implementation is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the constructor of our ViewModel, initialize the `NewUserDetails`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to `MainWindow.xaml` now, which is present under the Views folder.
    Modify the XAML as follows, to set a `DataContext` for the `StackPanel` and create
    data bindings with the `TextBox` controls. Make sure you set the data binding
    mode to `TwoWay`, else the code will not receive the updated value received from
    the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the following `XMLNS` attribute to the XAML page, so that we can access
    the classes present under the `CH07.MVVMDemo.Commands` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: <Window.CommandBindings>
  prefs: []
  type: TYPE_NORMAL
- en: <CommandBinding Command="{x:Static commands:RoutedCommands.AddCommand}"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CanExecute="CanExecute_AddCommand"
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Executed="Execute_AddCommand"/>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: </Window.CommandBindings>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: <Button Content="Add"
  prefs: []
  type: TYPE_NORMAL
- en: Margin="0 8"
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Command="{x:Static commands:RoutedCommands.AddCommand}"/>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: <StackPanel Orientation="Vertical"
  prefs: []
  type: TYPE_NORMAL
- en: Margin="4 0"
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: DockPanel.Dock="Right"
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: DataContext="{Binding NewUserDetails}">
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <TextBlock Text="Firstname"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <TextBox Text="{Binding Firstname, Mode=TwoWay}"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <TextBlock Text="Lastname"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <TextBox Text="{Binding Lastname, Mode=TwoWay}"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Button Content="Add"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Margin="0 8"
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Command="{x:Static commands:RoutedCommands.AddCommand}"/>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: </StackPanel>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: private MainWindowViewModel ViewModel = null;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: public MainWindow()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: InitializeComponent();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ViewModel = Resources["ViewModel"] as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: MainWindowViewModel;
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if (ViewModel == null)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: throw new NullReferenceException("ViewModel
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: can't be NULL");
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: private void CanExecute_AddCommand(object sender,
  prefs: []
  type: TYPE_NORMAL
- en: CanExecuteRoutedEventArgs e)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if (ViewModel != null)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var userDetails = ViewModel.NewUserDetails;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: e.CanExecute =
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '!string.IsNullOrWhiteSpace(userDetails.Firstname) &&'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '!string.IsNullOrWhiteSpace(userDetails.Lastname);'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: private void Execute_AddCommand(object sender,
  prefs: []
  type: TYPE_NORMAL
- en: ExecutedRoutedEventArgs e)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: ViewModel.UserCollection.Add(ViewModel.NewUserDetails);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ViewModel.SelectedUser = ViewModel.NewUserDetails;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ViewModel.NewUserDetails = new Models.UserModel();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
