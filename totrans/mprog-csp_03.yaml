- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Demystifying through Existing Real-World Examples
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过现有的实际案例来揭秘
- en: In this chapter, we will look into how Microsoft’s **ASP.NET** leverages metaprogramming
    in order to automate tedious configuration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将探讨Microsoft的**ASP.NET**如何利用元编程来自动化繁琐的配置。
- en: Since the first release of **ASP.NET MVC** back in 2009, there has been quite
    a lot of automation going on to make developers more productive. The main objective
    of this chapter is to demystify what metaprogramming is by showing that you might
    already be leveraging something that takes advantage of metaprogramming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2009年**ASP.NET MVC**的第一个版本发布以来，为了提高开发者的生产力，已经进行了大量的自动化工作。本章的主要目标是通过对元编程的揭秘，展示您可能已经利用了利用元编程的优势。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: ASP.NET controllers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET控制器
- en: ASP.NET validation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET验证
- en: By the end of this chapter, you will understand how ASP.NET leverages metaprogramming
    with a non-intrusive approach and see the benefits of automation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解ASP.NET如何通过非侵入式方法利用元编程，并看到自动化的好处。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，您需要以下内容：
- en: A computer with either Windows, macOS, or Linux installed
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Windows、macOS或Linux的计算机
- en: The **.NET** **6 SDK**
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 6 SDK**'
- en: Preferably, a code editor or IDE (such as Visual Studio Code, Visual Studio,
    or JetBrains Rider)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议使用代码编辑器或IDE（例如Visual Studio Code、Visual Studio或JetBrains Rider）
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter3](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter3)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可以在以下位置找到：[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter3](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter3)
- en: Prerequisites for your system
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统的先决条件
- en: In this chapter, we’ll dive concretely into code, so you need to have your system
    prepared.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将具体深入到代码中，因此您需要准备好您的系统。
- en: The first thing we’ll need is the Microsoft .NET SDK. Go to [https://dot.net](https://dot.net)
    and download the SDK by clicking the **Download** button.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要的是Microsoft .NET SDK。请访问[https://dot.net](https://dot.net)，点击**下载**按钮下载SDK。
- en: Important note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This book is based on *version 7* of the .NET SDK.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书基于.NET SDK的*第7版*。
- en: 'To create and edit files, it all depends on your own preferences and also what
    system you’re running on. Visual Studio Code and JetBrains Rider are both available
    on Windows, macOS, and Linux. Visual Studio is only available for Windows and
    macOS. You can download any of these editors from the following links; if you
    don’t have a preference, VSCode is lightweight and will get you up and running
    very fast:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和编辑文件，这完全取决于您的个人喜好以及您所运行的系统。Visual Studio Code和JetBrains Rider都可在Windows、macOS和Linux上使用。Visual
    Studio仅适用于Windows和macOS。您可以从以下链接下载任何这些编辑器；如果您没有偏好，VSCode轻量级且能快速让您开始使用：
- en: '**VSCode** ([https://code.visualstudio.com/](https://code.visualstudio.com/))'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VSCode** ([https://code.visualstudio.com/](https://code.visualstudio.com/))'
- en: '**JetBrains** **Rider** ([https://www.jetbrains.com/rider/](https://www.jetbrains.com/rider/))'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JetBrains Rider** ([https://www.jetbrains.com/rider/](https://www.jetbrains.com/rider/))'
- en: '**Visual** **Studio** ([https://visualstudio.com/](https://visualstudio.com/))'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio** ([https://visualstudio.com/](https://visualstudio.com/))'
- en: Once you’ve picked your editor, go ahead and follow the installation process
    relevant to the product you chose.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您选择了您的编辑器，请继续按照您选择的产品相关的安装过程进行操作。
- en: To call on APIs, you can use the web browser, **Wget**, or **cURL**, but I recommend
    using **Postman** ([https://www.postman.com/](https://www.postman.com/)) for this.
    Samples in this book will use Postman.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用API，您可以使用网络浏览器、**Wget**或**cURL**，但我推荐使用**Postman**([https://www.postman.com/](https://www.postman.com/))进行此操作。本书中的示例将使用Postman。
- en: ASP.NET controllers
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET控制器
- en: Being explicit with registering artifacts of your application is very common
    among different frameworks. Discovering the artifacts and just doing an automated
    self-registration of them is becoming more popular. But it’s very common that
    you will have to go and explicitly add everything manually.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的框架中，明确注册应用程序的组件是很常见的。发现这些组件并自动进行自我注册变得越来越流行。但非常常见的情况是，您需要亲自手动添加所有内容。
- en: Although it is very clear what is going on with these registrations, the downside
    of manual registration is that you are basically adding code that is not directly
    contributing to the business value you’re trying to achieve. It is also code that
    is highly repeatable and tends to end up in large files with all the initialization
    going on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些注册的进行过程非常清晰，但手动注册的缺点是您基本上添加了不直接贡献于您试图实现的业务价值的代码。这也是一种高度可重复的代码，往往最终会出现在包含所有初始化的大文件中。
- en: For instance, with **ASP.NET Core 6** we got a brand-new minimal API, which
    is designed to have a smaller footprint and less ceremony to get started. You
    can start creating a Web API with three lines of setup code and then add your
    API as HTTP methods with routes at will.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 **ASP.NET Core 6** 我们得到了一个全新的最小化 API，它旨在具有更小的占用空间和更少的启动仪式。您可以使用三行设置代码开始创建
    Web API，然后随意添加您的 API 作为 HTTP 方法并指定路由。
- en: This is all fine and dandy, but can quite easily become unmaintainable as the
    project grows.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切看起来都很不错，但随着项目的增长，很容易变得难以维护。
- en: Let’s dive more concretely into how this works.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更具体地探讨一下它是如何工作的。
- en: Create a new folder for this on your system called [*Chapter 3*](B19418_03.xhtml#_idTextAnchor041).
    In this folder, we want to create a simple ASP.NET web application. This can be
    done in various ways, depending on the editor/IDE choice you made and also your
    personal preferences. However, throughout the book, we’ll just stick with doing
    it from the command line, as that will work in all environments.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的系统上为这次操作创建一个名为 [*第 3 章*](B19418_03.xhtml#_idTextAnchor041) 的新文件夹。在这个文件夹中，我们想要创建一个简单的
    ASP.NET 网络应用程序。这可以通过多种方式完成，具体取决于您选择的编辑器/IDE 以及个人偏好。然而，在本书中，我们将坚持使用命令行来完成，因为这样可以在所有环境中工作。
- en: 'Open up a command-line interface (Windows CMD, macOS Terminal, Linux bash,
    or similar). Navigate to the folder you created for this ([*Chapter 3*](B19418_03.xhtml#_idTextAnchor041)).
    Then run the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 打开命令行界面（Windows CMD、macOS 终端、Linux bash 或类似）。导航到您为本次操作创建的文件夹（[*第 3 章*](B19418_03.xhtml#_idTextAnchor041)）。然后运行以下命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will produce a minimal setup to get started. Open the folder/project in
    your editor/IDE. Your **Program.cs** file should look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个最小的设置以开始。在您的编辑器/IDE 中打开文件夹/项目。您的 **Program.cs** 文件应该看起来像这样：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It basically sets up a web application and adds a route at the root level that
    will return **"Hello World!"** when navigating to it using your web browser.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上设置了一个网络应用程序，并在根级别添加了一个路由，当使用您的网络浏览器导航到它时，将返回 **"Hello World!"**。
- en: The **app.MapGet()** call is a very simple way to expose an endpoint and could
    in fact be used to build simple REST APIs. Let’s create a simple one for returning
    employees of a system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**app.MapGet()** 调用是一种非常简单的方式来暴露端点，实际上可以用来构建简单的 REST API。让我们创建一个简单的 API 来返回系统的员工信息。'
- en: Custom HTTP Get handler
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 HTTP Get 处理器
- en: 'Start by creating a new file called **Employee.cs** and adding the following
    to the file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 **Employee.cs** 的新文件，并将以下内容添加到文件中：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This holds just a simple representation of an employee with their first and
    last name. Obviously, in a proper system, you would add more properties to this.
    But for the sake of this sample, this will suffice.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的员工表示，包括他们的名字和姓氏。显然，在一个合适的系统中，您会添加更多属性到这个中。但为了这个示例，这已经足够了。
- en: 'With the **Employee** type in place, we can now change our **Get** action to
    a different route and also just return a collection of the **Employee** type.
    Swap out the **.MapGet()** method call with the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了 **Employee** 类型后，我们现在可以将我们的 **Get** 动作更改为不同的路由，并仅返回 **Employee** 类型的集合。将
    **.MapGet()** 方法调用替换为以下内容：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At the top of the file, you also need to add a **using** statement for the
    **Chapter3** namespace. The new **Program.cs** file should look like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，您还需要为 **Chapter3** 命名空间添加一个 **using** 语句。新的 **Program.cs** 文件应该看起来如下：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can run this using **dotnet run** from your terminal/console or if you
    prefer to run it with your IDE, you should get a running program listing something
    like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 **dotnet run** 从您的终端/控制台运行此程序，或者如果您更喜欢使用您的 IDE 运行它，您应该得到一个运行中的程序，显示如下内容：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The two lines saying **Now listening on:** will have different ports on your
    computer, as it is randomly assigned when creating the project. Combine the URL
    with **/api/employees** from the **.MapGet()** method. It should be something
    like **https://localhost:7027/api/employees** or the non-HTTPS **http://localhost:5016/api/employees**,
    just remember to put your ports into it. Take this combined URL and navigate to
    it in your browser. You should see the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 两条显示**Now listening on:**的行将在您的计算机上具有不同的端口，因为它们是在创建项目时随机分配的。将URL与**.MapGet()**方法中的**/api/employees**结合。它可能类似于**https://localhost:7027/api/employees**或非HTTPS的**http://localhost:5016/api/employees**，只需记得将您的端口放入其中。将这个组合URL在浏览器中导航到它。您应该看到以下内容：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Obviously, if you’re adding a bunch of these API endpoints right there in the
    program file with additional logic within the handler method, this file will become
    big and hard to read and maintain.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果您直接在程序文件中添加这些API端点，并在处理程序方法中添加额外的逻辑，那么这个文件将会变得很大，难以阅读和维护。
- en: This is where we can improve a lot and let ASP.NET be clever. Let’s start by
    creating a controller for this instead.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们能够大幅改进并让ASP.NET变得聪明的地方。让我们先为这个创建一个控制器。
- en: Controller
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: 'Add a new file called **EmployeesController.cs** to the project. Make the file
    look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为**EmployeesController.cs**的新文件。使文件看起来像这样：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will now create a Web API controller that leverages explicit metadata using
    the available C# attributes found in ASP.NET. In front of the **EmployeesController**
    class, you have the **[Route]** attribute, which tells at which base route the
    controller will be located. Then we have a method we want to represent a particular
    HTTP verb; this is the **[****HttpGet]** attribute.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这将创建一个利用ASP.NET中可用的C#属性显式元数据的Web API控制器。在**EmployeesController**类之前，您有**[Route]**属性，它告诉控制器将位于哪个基本路由。然后我们有一个我们想要表示特定HTTP动词的方法；这是**[HttpGet]**属性。
- en: 'We have now rigged our code to be automatically discovered and configured by
    the ASP.NET engine itself. All we need to do is change the startup of this application
    and instruct ASP.NET to add controllers to our system. Open the **Program.cs**
    file and replace the content with the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将代码配置为能够被ASP.NET引擎本身自动发现和配置。我们所需做的只是更改此应用程序的启动方式，并指示ASP.NET向我们的系统中添加控制器。打开**Program.cs**文件，将其内容替换为以下内容：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The **builder.Services.AddControllers()** call will instruct ASP.NET to discover
    all the controllers in the current assembly. The second call you’ll notice is
    **app.MapControllers()**. This call maps all the controllers to the routes specified
    in the metadata.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**builder.Services.AddControllers()**调用将指示ASP.NET发现当前程序集中的所有控制器。您会注意到的第二个调用是**app.MapControllers()**。此调用将所有控制器映射到元数据中指定的路由。'
- en: By running this application and navigating the browser to the same URL as before,
    we should see the exact same result.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行此应用程序并导航到之前相同的URL，我们应该看到完全相同的结果。
- en: The beauty now with this model is that we can quite easily add a second controller
    without having to go into the configuration of our application to get it configured.
    It will just be discovered and automatically be there.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这种模型的美妙之处在于，我们可以非常容易地添加第二个控制器，而无需进入应用程序的配置来获取配置。它将只是被发现并自动存在。
- en: That means we can now concentrate on building out the business value and it
    is by default more manageable and maintainable, especially when you bring other
    developers into it to work together or if someone is inheriting your code base.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们现在可以专注于构建业务价值，并且默认情况下更易于管理和维护，尤其是在您将其他开发者引入其中共同工作或有人继承您的代码库时。
- en: ASP.NET validation
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET验证
- en: When doing HTTP requests against ASP.NET, it goes through a pipeline consisting
    of different middlewares with specific responsibilities. This pipeline is completely
    configurable and extensible by you as a developer. Out of the box, it comes pre-configured
    with a specific middleware that handles the validation of objects sent to a request.
    The validation engine behind this recognizes rules in the form of metadata that
    can be applied to the objects. This metadata again is based on C# attributes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当对ASP.NET进行HTTP请求时，它将通过一个由不同中间件组成的管道，这些中间件具有特定的职责。这个管道完全可由您作为开发者进行配置和扩展。默认情况下，它预配置了处理发送到请求的对象验证的特定中间件。此验证引擎识别可以应用于对象的元数据形式的规则。此元数据再次基于C#属性。
- en: 'Let’s start by changing our **Employee** object a bit. Open the **Employee.cs**
    file and make it look like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从稍微改变一下我们的**Employee**对象开始。打开**Employee.cs**文件，使其看起来如下所示：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This makes the **FirstName** and **LastName** properties required by adding
    the **[Required]** attribute to them. The ASP.NET pipeline will pick this up and
    check any input being sent to see if these properties have values.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过将**[Required]**属性添加到它们中，使**FirstName**和**LastName**属性成为必填项。ASP.NET管道将检测到这一点，并检查任何发送的输入是否包含这些属性值。
- en: However, ASP.NET does not decide for you how to treat invalid objects; it just
    populates an object called **ModelState** for you to decide how you want to deal
    with this.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ASP.NET不会为你决定如何处理无效对象；它只是为你填充一个名为**ModelState**的对象，让你决定如何处理这个问题。
- en: 'For us to deal with something like registering a new employee, we need to have
    an action in our controller that deals with that. Open **EmployeesController**
    and add the **Register** method as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理像注册新员工这样的操作，我们需要在我们的控制器中有一个处理该操作的动作。打开**EmployeesController**并添加以下**Register**方法：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice the **ModelState.IsValid** statement. If there are validation rules that
    are not valid, it will return **ValidationProblem** as the result containing the
    errors found in **ModelState**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到**ModelState.IsValid**语句。如果有无效的验证规则，它将返回包含在**ModelState**中找到的错误的结果**ValidationProblem**。
- en: 'Run the application and open Postman as discussed earlier. In Postman, you
    can create a new request by clicking on the button with the **+** sign on it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并打开之前讨论过的Postman。在Postman中，你可以通过点击带有**+**符号的按钮来创建一个新的请求：
- en: '![](img/Figure_3.1_B19418.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.1_B19418.jpg)'
- en: Figure 3.1 -Creating a new request in Postman
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 在Postman中创建新的请求
- en: 'This will create a new tab, much like a regular web browser that contains everything
    for the request. Select **POST** as an HTTP verb in the left dropdown of the request,
    then enter the URL for our API. Now you can simply click the **Send** button and
    see the result in the lower part:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的标签页，就像一个常规的网页浏览器，其中包含请求的所有内容。在请求的左侧下拉菜单中选择**POST**作为HTTP动词，然后输入我们API的URL。现在你可以简单地点击**发送**按钮，在下面的部分查看结果：
- en: '![](img/Figure_3.2_B19418.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.2_B19418.jpg)'
- en: Figure 3.2 – Creating a new tab that contains the request details
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 创建包含请求详情的新标签页
- en: Since we’re not really passing it an object, none of the properties are set.
    The errors listed will therefore say that the properties are required.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们实际上没有传递一个对象，所以没有任何属性被设置。因此，列出的错误将表明这些属性是必需的。
- en: Automatically hooking up model state handling
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动连接模型状态处理
- en: In ASP.NET, everything revolves around what is known as middlewares – small,
    special-purpose code blocks that perform a single task and then hand over to the
    next middleware. Every HTTP request that is handled by ASP.NET has these, and
    even the code that handles the controller is one of these. Every middleware can
    decide whether it should continue to the next middleware or whether it should
    exit with or without an error.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET中，一切围绕着被称为中间件的东西展开——这些是执行单个任务的小型、专用代码块，然后将其传递给下一个中间件。每个由ASP.NET处理的HTTP请求都有这些中间件，甚至处理控制器的代码也是其中之一。每个中间件都可以决定是否继续到下一个中间件，或者是否带有或没有错误退出。
- en: Controller handlers are just one of many formalized middlewares we can tap into.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器处理器只是我们可以利用的许多形式化中间件之一。
- en: 'You can find more details on middlewares here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到有关中间件的更多详细信息：
- en: '[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0)'
- en: If you never want to allow an invalid state to enter your controllers and want
    to get rid of the possibility of developers doing this manually, then there is
    a particular middleware we can put into the pipeline that allows us to stop it
    before we even hit the controller.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你永远不希望无效状态进入你的控制器，并想消除开发者手动执行此操作的可能性，那么我们可以将特定的中间件放入管道中，这样我们就可以在甚至触及控制器之前阻止它。
- en: 'ASP.NET has the concept of an **action filter**. This gets called before the
    controller performs any action and lets us decide whether we want to continue
    with the pipeline or not. You can read more about action filters here: [https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-7.0](https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-7.0).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET有一个**操作过滤器**的概念。它在控制器执行任何操作之前被调用，并允许我们决定是否继续管道。您可以在以下位置了解更多关于操作过滤器的内容：[https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-7.0](https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-7.0)。
- en: 'Let’s create a new file called **ValidationFilter.cs** and make it look like
    the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为**ValidationFilter.cs**的新文件，并使其看起来如下所示：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This takes over the checking of whether **ModelState** is valid. The line with
    **await next()** is the continuation of the pipeline. So by only calling this
    when things are valid, we avoid getting to the controller if we’re in an invalid
    state. Instead, we then create the same object the ASP.NET pipeline creates when
    calling the **ValidationProblem** method from the controller and return this.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将接管检查**ModelState**是否有效的任务。带有**await next()**的行是管道的延续。因此，只有在状态有效时才调用此操作，我们就可以避免在无效状态下到达控制器。相反，我们随后创建与ASP.NET管道在从控制器调用**ValidationProblem**方法时创建的相同对象，并返回此对象。
- en: 'We can then simplify the controller to look like the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简化控制器，使其看起来如下所示：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code does not need to consider **ModelState** at all and just assumes it
    is taken care of, simplifying the implementation of every controller and making
    it focus on its single purpose of registering an employee. For most controllers,
    this would be fine and, in fact, you’re now removing the possibility of developers
    forgetting to check for validity before doing their business logic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码根本不需要考虑**ModelState**，只是假设它已经被处理，从而简化了每个控制器的实现，使其专注于其单一目的——注册员工。对于大多数控制器来说，这将是可行的，实际上，你现在正在消除开发者忘记在执行业务逻辑之前检查有效性的可能性。
- en: 'The last piece of the puzzle is to hook it up in the ASP.NET pipeline. Open
    the **Program.cs** file and change the content to the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图是要将其连接到ASP.NET管道中。打开**Program.cs**文件，并将其内容更改为以下内容：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The **.AddControllers()** call takes a delegate that lets us configure **MvcOptions**.
    Within this, we can add our new action filter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**.AddControllers()**调用接受一个委托，允许我们配置**MvcOptions**。在此之内，我们可以添加我们新的操作过滤器。'
- en: Run the application and verify that you get the exact same result by clicking
    the **Send** button inside postman.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，并通过点击postman内的**发送**按钮验证您是否得到了完全相同的结果。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how an existing piece of technology leverages the
    power of the .NET runtime to make it easier for developers using the technology
    to do so. From the use of metadata in the right context, we get to focus on delivering
    business value and don’t have to worry about how it is all configured. It also
    automatically gives us a certain structure to abide by, which in the long run
    will yield a more maintainable, extensible, and predictable code base. By adding
    the action filter as we did, we added what we call a cross-cutting concern, something
    we will revisit in more detail in [*Chapter 13*](B19418_13.xhtml#_idTextAnchor206),
    *Applying* *Cross-Cutting Concerns*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何利用.NET运行时的力量来简化现有技术的使用，使得使用该技术的开发者能够更容易地实现这一点。通过在正确上下文中使用元数据，我们可以专注于交付业务价值，而无需担心如何进行配置。它还自动为我们提供了一种遵循的结构，从长远来看，这将产生更易于维护、扩展和可预测的代码库。通过添加我们刚才所做的操作过滤器，我们添加了一个所谓的跨切面关注点，我们将在[*第13章*](B19418_13.xhtml#_idTextAnchor206)中更详细地回顾，即*应用*
    *跨切面关注点*。
- en: In the next chapter, we will dive into how frameworks such as ASP.NET are capable
    of doing discovery and automation, and how we can leverage the .NET runtime type
    system to discover types and metadata to achieve something similar.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解框架（如ASP.NET）如何实现发现和自动化，以及我们如何利用.NET运行时类型系统来发现类型和元数据，以实现类似的功能。
- en: Part 2:Leveraging the Runtime
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：利用运行时
- en: In this part, you will see how powerful the .NET runtime is and dive into the
    details of its capabilities for metaprogramming. You’ll see the different metaprogramming
    models the runtime provides and get an idea of how they can be leveraged with
    real-world examples.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，您将看到.NET运行时的强大之处，并深入了解其元编程能力的细节。您将看到运行时提供的不同元编程模型，并通过实际示例了解它们如何被利用。
- en: 'This part has the following chapters:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 4*](B19418_04.xhtml#_idTextAnchor059), *Reasoning about Types Using
    Reflection*'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B19418_04.xhtml#_idTextAnchor059), *使用反射进行类型推理*'
- en: '[*Chapter 5*](B19418_05.xhtml#_idTextAnchor083), *Leveraging Attributes*'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B19418_05.xhtml#_idTextAnchor083), *利用属性*'
- en: '[*Chapter 6*](B19418_06.xhtml#_idTextAnchor098), *Dynamic Proxy Generation*'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19418_06.xhtml#_idTextAnchor098), *动态代理生成*'
- en: '[*Chapter 7*](B19418_07.xhtml#_idTextAnchor118), *Reasoning about Expressions*'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19418_07.xhtml#_idTextAnchor118), *表达式的推理*'
- en: '[*Chapter 8*](B19418_08.xhtml#_idTextAnchor132), *Building and Executing Expressions*'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19418_08.xhtml#_idTextAnchor132), *构建和执行表达式*'
- en: '[*Chapter 9*](B19418_09.xhtml#_idTextAnchor146), *Taking Advantage of the Dynamic
    Language Runtime*'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19418_09.xhtml#_idTextAnchor146), *利用动态语言运行时*'
