- en: '*Chapter 3*: Predefined Data Types and Memory Allocations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：预定义数据类型和内存分配'
- en: In this chapter, you will learn about **C#** predefined (that is, *built-in*)
    data types and C# object types, along with the different types of **memory allocations**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 **C#** 预定义（即 *内置*）数据类型和 C# 对象类型，以及不同类型的 **内存分配**。
- en: The most basic requirement for improving the performance of your application
    is to understand the predefined data types and their sizes. There may be times
    when the memory usage of your applications is critical. Knowing the size of data
    types and the values they hold can help you make accurate memory usage estimates,
    as do memory profiling tools such as **dotTrace** and **dotMemory**, which are
    developed by **JetBrains**. We will be discussing the use of dotTrace and dotMemory
    in the next chapter. It also makes sense to know the different types of memory
    allocations and how they affect your code performance. Here, we will be benchmarking
    the performance of various operations using **BenchmarkDotNet**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 提高应用程序性能的最基本要求是理解预定义数据类型及其大小。在某些情况下，应用程序的内存使用可能至关重要。了解数据类型的大小和它们所持有的值可以帮助你做出准确的内存使用估计，正如内存分析工具如
    **dotTrace** 和 **dotMemory** 所做的那样，这些工具由 **JetBrains** 开发。我们将在下一章讨论 dotTrace 和
    dotMemory 的使用。了解不同类型的内存分配及其对代码性能的影响也是有意义的。在这里，我们将使用 **BenchmarkDotNet** 对各种操作的性能进行基准测试。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '**Understanding the predefined .NET data types**: In this section, we will
    perform a review of the C# value and object types that are built into the C# programming
    language. Understanding these types and their size in bytes is useful when you
    need to provide memory usage estimates.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解预定义的 .NET 数据类型**：在本节中，我们将回顾 C# 编程语言中内置的 C# 值类型和对象类型。理解这些类型及其字节大小在需要提供内存使用估计时很有用。'
- en: '**Understanding the various types of memory used in C#**: In this section,
    we delve into the different types of memory used in C#, including the *stack*,
    *heap*, *small object heap*, and *large object heap*. It is useful to know what
    data gets stored in memory and how it gets stored. This can have a big effect
    on the performance of your applications. For instance, did you know that value
    types do not always get stored on the stack?'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解 C# 中使用的各种内存类型**：在本节中，我们将深入了解 C# 中使用的不同类型的内存，包括 *栈*、*堆*、*小对象堆* 和 *大对象堆*。了解数据存储在内存中的方式和位置很有用，这可能会对应用程序的性能产生重大影响。例如，你知道值类型并不总是存储在栈上吗？'
- en: '**Passing by value and passing by reference**: In this section, we will cover
    the differences between passing values by value and by reference, and the effects
    this has on the original variables. You will also understand how passing by value
    and by reference work in memory.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按值传递和按引用传递**：在本节中，我们将介绍按值传递和按引用传递之间的区别，以及这对原始变量的影响。你还将了解按值传递和按引用传递在内存中的工作方式。'
- en: '**Boxing and unboxing:** In this section, we will discuss what happens in memory
    when we *box* and *unbox* a variable, and we will explore how boxing and unboxing
    negatively impact the performance of programs. You will use the disassembler to
    view the intermediate language commands that perform the boxing and unboxing.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装箱和拆箱**：在本节中，我们将讨论当我们对变量进行 *装箱* 和 *拆箱* 时内存中发生的情况，并探讨装箱和拆箱如何对程序性能产生负面影响。你将使用反汇编器查看执行装箱和拆箱的中间语言命令。'
- en: 'By the end of this chapter, you will have the skills to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将具备以下技能：
- en: You will understand the different value type sizes.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将理解不同值类型的大小。
- en: You will understand the different reference types.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将理解不同的引用类型。
- en: You will understand the different types of memory and how they are allocated.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将理解不同类型的内存及其分配方式。
- en: You will understand the difference between passing by values and passing by
    references.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将理解按值传递和按引用传递之间的区别。
- en: You will understand how boxing and unboxing negatively impact performance and
    why.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将理解装箱和拆箱如何对性能产生负面影响以及原因。
- en: We will first look at the technical requirements for following along with this
    chapter, then, we will move on to look at the various predefined C# data types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看跟随本章的技术要求，然后，我们将继续探讨各种预定义的 C# 数据类型。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Required: **Microsoft** **Visual Studio** **2022**, latest version – preview'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必需：**Microsoft** **Visual Studio** **2022**，最新版本 – 预览版
- en: 'Required: BenchmarkDotNet'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必需：BenchmarkDotNet
- en: 'The code files for this chapter can be found in this book''s GitHub repository:
    [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH03](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH03)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH03](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH03)
- en: You will need to clone the git repository and do a release build. The compiled
    executable will be found under C:\Development\perfview\src\PerfView\bin\Release\net45.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要克隆 Git 仓库并执行发布构建。编译后的可执行文件将在 C:\Development\perfview\src\PerfView\bin\Release\net45
    下找到。
- en: Understanding the predefined .NET data types
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解预定义 .NET 数据类型
- en: 'There are two types of predefined data types:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义数据类型有两种：
- en: '**Reference types**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用类型**'
- en: '**Value types**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值类型**'
- en: The reference types are objects and strings. The value types consist of enumeration
    and struct types. Struct types are aggregated of simple types. Simple types consist
    of Boolean, char, and numeric types.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型是对象和字符串。值类型包括枚举和结构类型。结构类型是由简单类型组成的聚合。简单类型包括布尔型、字符型和数值类型。
- en: 'There are three main numeric types: decimal types, floating-point types, and
    integer types. Floating-point types consist of decimals, doubles, and floats.
    The integer types consist of bytes shorts, integers, longs, value tuples, and
    characters.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种主要的数值类型：十进制类型、浮点类型和整数类型。浮点类型包括十进制、双精度和单精度。整数类型包括字节、短整型、整型、长整型、值元组和字符。
- en: We are going to mention the stack and the heap in more detail later in the chapter.
    But for now, we should understand that the stack is *unmanaged* memory, and the
    heap is *managed* memory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面更详细地讨论栈和堆。但就目前而言，我们应该了解栈是 *非托管* 内存，而堆是 *托管* 内存。
- en: Value types live on the stack. Value types in arrays live on the heap. And reference
    types live on the heap, with their pointers living on the stack.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型位于栈上。数组中的值类型位于堆上。而引用类型位于堆上，它们的指针位于栈上。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even if arrays are not ideal for some scenarios, in most cases, arrays will
    often perform faster than lists and other data structures. Array contents are
    placed contiguously on the heap. The variable for the array will be placed on
    the stack, and its contents on the stack will be a pointer to the memory address
    of the array on the heap.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 即使数组在某些场景下不是理想的选择，但在大多数情况下，数组通常会比列表和其他数据结构运行得更快。数组的内容会连续地放置在堆上。数组变量将放置在栈上，其内容在栈上将是堆上数组内存地址的指针。
- en: The stack and the heap are the two main types of memory in **.NET**, and as
    mentioned, we will be covering them later in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 栈和堆是 **.NET** 中的两种主要内存类型，正如之前提到的，我们将在本章后面详细讨论它们。
- en: Now, let's look at the predefined value types in C#.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 C# 中的预定义值类型。
- en: Understanding the predefined value types in C#
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 C# 中的预定义值类型
- en: In this section, we will describe each predefined value type and its size in
    bytes. This is important for being able to choose the right data type to improve
    the memory performance of your applications. For those who are new to C#, you
    should know that *signed* data types are those data types that can have *positive*
    and *negative* values, whereas *unsigned* data types are those that can have only
    *positive* values.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述每个预定义值类型及其字节数。这对于选择正确的数据类型以改善应用程序的内存性能非常重要。对于 C# 新手来说，应该知道 *有符号* 数据类型是可以有
    *正* 值和 *负* 值的数据类型，而 *无符号* 数据类型是只能有 *正* 值的数据类型。
- en: '*Table 3.1* describes the different value types, their memory size, whether
    they are nullable, and their default, minimum, and maximum values, as well as
    providing notes where applicable:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 3.1* 描述了不同的值类型、它们的内存大小、是否可以为空，以及它们的默认值、最小值和最大值，并在适用的情况下提供注释：'
- en: '![Table 3.1 – The predefined value data types in C#'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 3.1 – C# 中的预定义值数据类型'
- en: '](img/Table_3.1_B16617.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_3.1_B16617.jpg)'
- en: Table 3.1 – The predefined value data types in C#
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – C# 中的预定义值数据类型
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `enum` data type is 4 bytes (that is, 32 bits) in size, nullable, and has
    a minimum value of `0`. You can measure the size of a value type using `sizeof(Type
    type)`. Custom structs can be measured using `Marshal.SizeOf(typeof(NameOfCustomStruct))`.
    The `ValueTuple` data type is 1 byte (8 bits) in size and grows with each type
    parameter. For example, `ValueTuple<double, double, double>` is 24 bytes (192
    bytes) in size.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 数据类型的大小为 4 字节（即 32 位），是可空的，并且最小值为 `0`。你可以使用 `sizeof(Type type)` 来测量值类型的大小。自定义结构体可以使用
    `Marshal.SizeOf(typeof(NameOfCustomStruct))` 来测量。`ValueTuple` 数据类型的大小为 1 字节（8
    位），并且随着每个类型参数的增长而增长。例如，`ValueTuple<double, double, double>` 的大小为 24 字节（192 字节）。'
- en: We will now look at understanding the predefined reference types in C#.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨理解 C# 中的预定义引用类型。
- en: Understanding the predefined reference types in C#
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 C# 中的预定义引用类型
- en: A **reference type** is a type that is placed in managed memory called the **managed
    heap**. The four predefined reference types in C# are the object type, string
    type, delegate type, and dynamic type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用类型**是一种放置在称为**托管堆**的托管内存中的类型。C# 中预定义的四种引用类型是对象类型、字符串类型、委托类型和动态类型。'
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unfortunately, with reference types, you cannot use `sizeof` (which is of the
    object type) to get the size of a reference type, and the `BinaryFormatter` class
    has been made obsolete. That means that you cannot serialize an object into binary,
    save it into a memory stream, and get its size from the memory stream's position.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于引用类型，你不能使用 `sizeof`（它属于对象类型）来获取引用类型的大小，并且 `BinaryFormatter` 类已经被弃用。这意味着你不能将对象序列化为二进制，将其保存到内存流中，并从内存流的位置获取其大小。
- en: We are, however, recommended to serialize and deserialize objects using **JSON**.
    We can then assign the JSON to a memory stream, and in doing so, the length of
    the memory stream will give us the size of our object in memory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们建议使用 **JSON** 来序列化和反序列化对象。然后我们可以将 JSON 赋值给内存流，这样做的话，内存流的长度将给出我们的对象在内存中的大小。
- en: Let's look at each of these in turn in terms of memory usage.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些类型在内存使用方面的表现。
- en: Describing the object reference type
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述对象引用类型
- en: The .NET `System.Object` type is aliased as object in C#. All types in C# either
    directly or indirectly inherit from `System.Object`. This includes predefined
    and user types (such as classes, enums, and structs), reference types, and value
    types. Objects can be nullable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 的 `System.Object` 类型在 C# 中被别名为 object。C# 中的所有类型要么直接要么间接继承自 `System.Object`。这包括预定义类型和用户类型（如类、枚举和结构体）、引用类型和值类型。对象可以是可空的。
- en: To obtain the memory size of your objects programmatically, serialize them to
    **XML** or JSON and load them into a memory stream, and the length of the memory
    stream will give you your object size in bytes. Alternatively, you can profile
    the memory of your application using a tool such as dotMemory to profile your
    application's memory usage.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要以编程方式获取对象的内存大小，可以将它们序列化为 **XML** 或 JSON，并将它们加载到内存流中，内存流的长度将给出你的对象大小（以字节为单位）。或者，你可以使用像
    dotMemory 这样的工具来分析你的应用程序的内存使用情况。
- en: Describing the string reference type
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述字符串引用类型
- en: A `string` type uses 2 bytes (16 bits) for each character. So, our famous little
    `string`, *Hello, World!*, which uses 13 characters, is 13 x 2 bytes long, which
    equates to 26 bytes (208 bits) of memory. Strings can be nullable, and they can
    be empty.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`string` 类型为每个字符使用 2 个字节（16 位）。因此，我们著名的简短 `string`，*Hello, World!*，它使用了 13
    个字符，长度为 13 x 2 字节，相当于 26 字节（208 位）的内存。字符串可以是可空的，也可以是空的。'
- en: Strings are immutable in .NET. But what do we mean by this?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，字符串是不可变的。但我们的意思是什么？
- en: When you create a `string` type, it is added to the heap. A variable is added
    to the stack that has an address pointer to the string's location on the heap.
    If you add the `string` type to another variable, that variable will be placed
    on the stack, and it will hold a copy of the address of the same string on the
    heap. But if you append an existing `string` type with another `string` type,
    a new `string` type is created in memory to hold the existing `string` type, plus
    the `string` type to be appended. The address pointer for the `string` type is
    updated on the stack to point to this new location.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个 `string` 类型时，它会被添加到堆中。一个变量会被添加到栈上，该变量包含一个指向堆上字符串位置的地址指针。如果你将 `string`
    类型添加到另一个变量中，该变量将被放置在栈上，并且它将持有堆上相同字符串的地址的副本。但是，如果你将一个现有的 `string` 类型与另一个 `string`
    类型连接，内存中会创建一个新的 `string` 类型来保存现有的 `string` 类型，以及要连接的 `string` 类型。`string` 类型的地址指针在栈上被更新，以指向这个新位置。
- en: Building an immutable string example program
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建不可变字符串示例程序
- en: 'We are going to write a simple `CH03_StringsAreImmutable`. Then, update the
    `Main(string[] _)` method as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个简单的 `CH03_StringsAreImmutable`。然后，按照以下方式更新 `Main(string[] _)` 方法：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We output a header to the console, and then we set the `greeting1` `string`
    type to `"Hello, world!"`. Then, we assign `greeting1` to the `string` `greeting2`
    type. The contents of both `string` variables are output to the console window.
    We then amend `greeting1` by appending `" Isn''t life grand!"` to the end of it.
    Next, we output the contents of both `greeting1` and `greeting2`. Run the program,
    and you should see the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将输出一个标题到控制台，然后我们将 `greeting1` `string` 类型设置为 `"Hello, world!"`。然后，我们将 `greeting1`
    赋值给 `string` 类型的 `greeting2`。两个 `string` 变量的内容都输出到控制台窗口。然后，我们在 `greeting1` 的末尾追加
    `" Isn't life grand!"` 来修改 `greeting1`。接下来，我们输出 `greeting1` 和 `greeting2` 的内容。运行程序，你应该看到以下内容：
- en: '![Figure 3.1 – The immutable strings example'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.1 – 不可变字符串示例](img/Figure_3.1_B16617.jpg)'
- en: '](img/Figure_3.1_B16617.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.1 – The immutable strings example](img/Figure_3.1_B16617.jpg)'
- en: Figure 3.1 – The immutable strings example
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.1 – 不可变字符串示例
- en: As you can see, although we assigned `greeting1` to `greeting2` and then updated
    `greeting1`, `greeting2` remains unchanged. So, we now have two strings on the
    heap. We have `"Hello, world!"`, and we have `"Hello, world! Isn't life grand!"`.
    And so, from our little example, we can see that strings are indeed immutable.
    And now, we will describe the `delegate` reference type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，尽管我们将 `greeting1` 赋值给 `greeting2` 并更新了 `greeting1`，但 `greeting2` 保持不变。因此，我们现在在堆上有两个字符串。我们有
    `"Hello, world!"`，我们还有 `"Hello, world! Isn't life grand!"`。因此，从我们的小例子中，我们可以看到字符串确实是不可变的。现在，我们将描述
    `delegate` 引用类型。
- en: Describing the delegate reference type
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述委托引用类型
- en: A `delegate` type must have the same signature and return type. When you compile
    code that uses delegates, a private sealed class is created for the delegate that
    inherits from `System.MulticastDelegate`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`delegate` 类型必须具有相同的签名和返回类型。当你编译使用委托的代码时，会创建一个继承自 `System.MulticastDelegate`
    的私有密封类。'
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please check *section I.8.9.3* in the following link for more information on
    delegates: [https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf](https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下链接中的 *第 I.8.9.3 节* 以获取有关委托的更多信息：[https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf](https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf)。
- en: We will now describe the `dynamic` reference type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将描述 `dynamic` 引用类型。
- en: Describing the dynamic reference type
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述动态引用类型
- en: Type checking is performed at compile time. This ensures type safety when your
    applications are executed at runtime. Type safety aims to prevent erroneous or
    undesirable program behavior that is caused by discrepancies between types.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查是在编译时执行的。这确保了在应用程序在运行时执行时的类型安全。类型安全旨在防止由类型之间的差异引起的错误或不希望的程序行为。
- en: Types that are defined as `dynamic` bypass type checking at compile time, as
    they and the members are resolved at runtime. The advantage of the `dynamic` type
    is that it simplifies our access to COM APIs (such as the **Office Automation**
    API) to dynamic APIs (such as the **IronPython** libraries) and to the HTML **Document
    Object Model** (**DOM**).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为 `dynamic` 的类型在编译时绕过类型检查，因为它们和成员在运行时解析。`dynamic` 类型的优点是它简化了我们访问 COM API（如
    **Office Automation** API）到动态 API（如 **IronPython** 库）以及到 HTML **文档对象模型**（**DOM**）的访问。
- en: Dynamic types are compiled as objects and exist as objects at runtime. A `dynamic`
    type only exists at compile time and not at runtime. When a `dynamic` type is
    compiled, it becomes an `object` type. Later in this section, and after we have
    written and built our console application, we will use ILDASM to show the IL type
    of a compiled dynamic variable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型在编译时作为对象存在，并在运行时作为对象存在。`dynamic` 类型仅在编译时存在，而不是在运行时。当 `dynamic` 类型被编译时，它成为
    `object` 类型。在本节稍后，在我们编写并构建我们的控制台应用程序之后，我们将使用 ILDASM 来显示编译后的动态变量的 IL 类型。
- en: When the object runs for the first time, it is correctly resolved by the runtime.
    This resolution incurs a performance penalty that can be considerable depending
    upon the type being resolved. Since `dynamic` is compiled into an object, boxing
    and unboxing take place. And as you know, boxing costs processor cycles.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象首次运行时，它会被运行时正确解析。这种解析会产生一个性能惩罚，这取决于正在解析的类型，可能会相当大。由于 `dynamic` 被编译成对象，因此会发生装箱和拆箱。正如你所知，装箱会消耗处理器周期。
- en: Let's demonstrate the performance difference when using different variations
    of `var` and `dynamic` when we are declaring variables and assigning values to
    them, compared to using the correct types and assigning them without having to
    use casting.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示在声明变量和为它们赋值时使用不同的 `var` 和 `dynamic` 变体与使用正确的类型并无需进行转换赋值时的性能差异。
- en: 'Start a new .NET 6 console application called `CH03_DynamicPerformance`.  You
    will need the following references:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的 .NET 6 控制台应用程序，名为 `CH03_DynamicPerformance`。你需要以下引用：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add a new member variable at the top of the `Program` class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program` 类的顶部添加一个新的成员变量：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This variable declaration will be investigated by using ILDASM after we have
    run our benchmarks. Next, update the `Main(string[] _)` method as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行基准测试后，将使用 ILDASM 对这个变量声明进行调查。接下来，更新 `Main(string[] _)` 方法如下：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are running the benchmarking tests in a class called `BenchmarkTests`. Add
    a new class called `BenchmarkTests` by using the same statements as the preceding
    example. Then, add the `MeasureVarUsage()` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在名为 `BenchmarkTests` 的类中运行基准测试。使用与前面示例相同的语句添加一个新类 `BenchmarkTests`。然后，添加 `MeasureVarUsage()`
    方法：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This method assigns a `double` object to the `x` variable of a type that will
    be resolved at runtime. Next, add the `MeasureVarDynamicUsage()` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将一个 `double` 对象分配给运行时解析类型的 `x` 变量。接下来，添加 `MeasureVarDynamicUsage()` 方法：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we are still assigning a number to the `x` variable of a type that will
    be resolved at runtime. But this time, we prefix the number with the `(dynamic)`
    cast. Remember that the `dynamic` keyword only exists at compile time. When compiled,
    `dynamic` types become the `object` type. Now, add the `MeasureTypeDynamicUsage()`
    method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们仍然在运行时解析类型的 `x` 变量上分配一个数字。但这次，我们在数字前加上 `(dynamic)` 转换。记住，`dynamic` 关键字只存在于编译时。当编译时，`dynamic`
    类型变为 `object` 类型。现在，添加 `MeasureTypeDynamicUsage()` 方法：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This time, we declare the variable as `double` and cast the assigned number
    as `(dynamic)`. At runtime, this number will be boxed in an `object` type, and
    so it will need to be unboxed. And for our final method, add the `MeasureTypeTypeUsage()`
    method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将变量声明为 `double` 并将分配的数字转换为 `(dynamic)`。在运行时，这个数字将被包装在 `object` 类型中，因此需要解包。并且为我们的最终方法，添加
    `MeasureTypeTypeUsage()` 方法：
- en: '[PRE36]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this method, we declare a `double` type and assign a `double` type. Compile
    the project in Release mode. Then, open a command line and navigate to your release
    folder. Type the name of the executable and press *Enter*. This will cause BenchmarkDotNet
    to detect the benchmarks within the project and sequentially run through them.
    You should see a summary similar to the following, albeit with different mean
    times:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们声明一个 `double` 类型并分配一个 `double` 类型。以发布模式编译项目。然后，打开命令行并导航到您的发布文件夹。输入可执行文件名并按
    *Enter*。这将导致 BenchmarkDotNet 检测项目中的基准测试并依次运行它们。你应该会看到一个类似于以下摘要的结果，尽管平均时间可能不同：
- en: '![Figure 3.2 – The variable type declaration and the assignment''s benchmarked
    mean timings'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 变量类型声明和赋值的基准平均时间'
- en: '](img/Figure_3.2_B16617.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B16617.jpg)'
- en: Figure 3.2 – The variable type declaration and the assignment's benchmarked
    mean timings
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 变量类型声明和赋值的基准平均时间
- en: '*Figure 3.2* shows us that there are differences in performance when we declare
    variables and assign values depending on the methods we use. The fastest combination
    of declaration and assignment is `var variableName = (dynamic)value`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.2* 展示了当我们根据使用的方法声明变量和赋值时，性能存在差异。声明和赋值最快组合是 `var variableName = (dynamic)value`。'
- en: Well, we have run our benchmark tests. So, let's view the IL code for the dynamic
    variable. Open the developer command prompt, then type `ildasm.exe` and press
    *Enter*. This will start the ILDASM application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经运行了基准测试。那么，让我们查看动态变量的 IL 代码。打开开发者命令提示符，然后输入 `ildasm.exe` 并按 *Enter*。这将启动
    ILDASM 应用程序。
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**.NET Core** and **.NET 6** applications are compiled differently from previous
    versions of the **.NET Framework**. Previously, ILDASM would open the compiled
    executable. But .NET Core and .NET 6 applications get compiled into a **dynamic-link
    library** (**DLL**), and a native executable is produced to run the code in the
    resulting DLL.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET Core** 和 **.NET 6** 应用程序与之前的 **.NET Framework** 版本编译方式不同。之前，ILDASM 会打开编译后的可执行文件。但
    .NET Core 和 .NET 6 应用程序被编译成 **动态链接库**（**DLL**），并生成一个本地可执行文件来运行结果 DLL 中的代码。'
- en: 'Open your compiled DLL. Expand the `CH03_DynamicPerformance` node and then
    expand the `CH03_DynamicPerformance.Program` node. Then, locate the `_dynamicType
    : private object` line call, as shown in *Figure 3.3*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '打开您的编译好的 DLL。展开 `CH03_DynamicPerformance` 节点，然后展开 `CH03_DynamicPerformance.Program`
    节点。然后，找到如 *图 3.3* 所示的 `_dynamicType : private object` 行调用：'
- en: '![Figure 3.3 – ILDASM showing us that the compiler converts a dynamic type
    into an object type at compile time'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – ILDASM 显示编译器在编译时将动态类型转换为对象类型](img/Figure_3.3_.jpg)'
- en: '](img/Figure_3.3_.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.3_.jpg)'
- en: Figure 3.3 – ILDASM showing us that the compiler converts a dynamic type into
    an object type at compile time
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – ILDASM 显示编译器在编译时将动态类型转换为对象类型
- en: As you can see, our `dynamic` type gets compiled into an `object` type. As a
    little exercise, play about with the ILDASM settings and view the code for the
    `BenchmarkTests` class for yourself. Now, let's look at static types.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的 `dynamic` 类型在编译时被编译成 `object` 类型。作为一个小练习，您可以调整 ILDASM 设置并查看 `BenchmarkTests`
    类的代码。现在，让我们看看静态类型。
- en: Understanding static types
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解静态类型
- en: In .NET versions earlier than .NET Core and **.NET** **5.0**, when you compile
    and run your applications, they run in their own application domains. If you run
    your applications multiple times, each running instance of your application will
    have its own app domain. In **ASP.NET**, you use multiple app domains for a single
    application. This becomes important when using static types in ASP.NET applications.
    In a single app domain, there will only be one instance of a static type. The
    runtime must create an instance of the static type before it can be used.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Core 和 **.NET** **5.0** 之前的 .NET 版本中，当您编译和运行应用程序时，它们将在自己的应用程序域中运行。如果您多次运行应用程序，每个运行实例都将有自己的应用程序域。在
    **ASP.NET** 中，您为单个应用程序使用多个应用程序域。当在 ASP.NET 应用程序中使用静态类型时，这变得很重要。在单个应用程序域中，将只有一个静态类型的实例。在可以使用之前，运行时必须创建静态类型的实例。
- en: The `AppDomain` object has its own static heap. Static value and reference types
    will be placed on the static heap and managed by the app domain. Static types
    are considered by the garbage collector, but they are never collected. The reason
    the garbage collector considers them is that they may have references to objects
    on other heaps. Static types and variables in other app domains are isolated from
    each other.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppDomain` 对象拥有自己的静态堆。静态值和引用类型将被放置在静态堆上，并由应用程序域管理。静态类型会被垃圾回收器考虑，但它们永远不会被回收。垃圾回收器考虑它们的原因是它们可能引用其他堆上的对象。其他应用程序域中的静态类型和变量彼此隔离。'
- en: In `AssemblyLoadContext` class for the dynamic loading of assemblies. By *processes
    and/or containers*, Microsoft means that you should split your single applications/modules
    into separate, interacting applications/modules/processes/containers. So, you
    are encouraged by Microsoft to refactor code using microservices so that you no
    longer need to use application domains.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AssemblyLoadContext` 类中用于动态加载程序集。通过 *进程和/或容器*，Microsoft 意味着您应该将单个应用程序/模块拆分为单独的、相互交互的应用程序/模块/进程/容器。因此，Microsoft
    鼓励您使用微服务重构代码，这样您就不再需要使用应用程序域。
- en: The `System.Runtime.Loader.AssemblyLoadContext` object represents a load context.
    A *load context* creates a scope for loading, resolving, and unloading assemblies.
    For more information on the `AssemblyLoadContext` class, see the official Microsoft
    documentation at [https://docs.microsoft.com/dotnet/api/system.runtime.loader.assemblyloadcontext?view=net-5.0](https://docs.microsoft.com/dotnet/api/system.runtime.loader.assemblyloadcontext?view=net-5.0).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Runtime.Loader.AssemblyLoadContext` 对象表示一个加载上下文。一个 *加载上下文* 为加载、解析和卸载程序集创建了一个作用域。有关
    `AssemblyLoadContext` 类的更多信息，请参阅官方 Microsoft 文档：[https://docs.microsoft.com/dotnet/api/system.runtime.loader.assemblyloadcontext?view=net-5.0](https://docs.microsoft.com/dotnet/api/system.runtime.loader.assemblyloadcontext?view=net-5.0)。'
- en: Static classes are instantiated only once by the runtime. You cannot instantiate
    a static class yourself. Static constructors are executed at the time the class
    is loaded into memory. If a non-static class has a static constructor and an instance
    constructor, the static constructor will be called before the instance constructor.
    Static constructors are parameterless, and there can only be one static constructor
    per class. Static constructors do not have access modifiers. Memory is allocated
    for static variables when a class loads and deallocated when a class is unloaded.
    Variables, constructors, and methods belong to the class and not to instantiated
    objects. So, modifying variables will modify the variable across all instances
    of a class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类仅由运行时实例化一次。您不能自己实例化一个静态类。静态构造函数在类被加载到内存时执行。如果一个非静态类有一个静态构造函数和一个实例构造函数，静态构造函数将在实例构造函数之前被调用。静态构造函数是无参的，并且每个类只能有一个静态构造函数。静态构造函数没有访问修饰符。当类加载时为静态变量分配内存，当类卸载时释放内存。变量、构造函数和方法属于类，而不是实例化的对象。因此，修改变量将修改类的所有实例中的变量。
- en: On the call stack, static methods tend to be faster to call than instance methods.
    The compiler emits a nonvirtual call sites static members. Nonvirtual call sites
    prevent runtime checks that ensure the current object pointer is non-null. Although
    you may not see any visual performance improvements, performance gains can be
    measured for performance-sensitive code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用栈上，静态方法通常比实例方法调用更快。编译器会发出非虚拟调用站点静态成员。非虚拟调用站点防止了运行时检查，这些检查确保当前对象指针非空。尽管你可能看不到任何可视的性能改进，但对于性能敏感的代码，性能提升是可以衡量的。
- en: Now that we have covered the various predefined C# data types, it is time to
    look at C# memory and how it works.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了各种预定义的C#数据类型，是时候看看C#的内存以及它是如何工作的了。
- en: Understanding the various types of memory used in C#
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解C#中使用的各种内存类型
- en: 'There are two main types of memory in C#: the stack and the heap. The heap
    is further broken down into the *small object heap* and the *large object heap*.
    In terms of physical memory, there is no difference between the stack or heap,
    as they are both stored in physical memory. Their differences are in their implementations.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: C#中有两种主要的内存类型：栈和堆。堆进一步分为*小对象堆*和*大对象堆*。在物理内存方面，栈和堆之间没有区别，因为它们都存储在物理内存中。它们的不同之处在于它们的实现。
- en: 'When your application starts up, it is allocated a portion of memory. A pointer
    will be assigned to your application that will be your application''s memory starting
    point. Above the pointer will be the stack, and below the pointer will be the
    heap. The heap will grow downwards, and the stack will grow upwards, as shown
    in *Figure 3.4*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序启动时，它会被分配一部分内存。一个指针将被分配给你的应用程序，这将是你应用程序的内存起始点。指针上方是栈，指针下方是堆。堆向下增长，栈向上增长，如*图3.4*所示：
- en: '![Figure 3.4 – The stack, heap, and application starting point memory address'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.4 – The stack, heap, and application starting point memory address]'
- en: '](img/Figure_3.4_B16617.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.4_B16617.jpg]'
- en: Figure 3.4 – The stack, heap, and application starting point memory address
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 栈、堆和应用启动点内存地址
- en: 'The following diagram visually represents the stack and heap for a simple program:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表直观地表示了一个简单程序中的栈和堆：
- en: '![Figure 3.5 – The stack and heap at work'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.5 – The stack and heap at work]'
- en: '](img/Figure_3.5_B16617.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.5_B16617.jpg]'
- en: Figure 3.5 – The stack and heap at work
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 栈和堆在工作
- en: To understand the different types of memory in C#, first, we'll look at the
    stack and how it operates.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解C#中的不同类型的内存，首先，我们将看看栈以及它是如何操作的。
- en: The stack
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈
- en: The *stack* is used to store value types and pointers to memory locations on
    the heap. When you call a method, it is added to a stack frame on the stack. Then,
    within that frame, the value types are added to the stack. If there are any reference
    types in the method, these are placed on the heap, and a variable is placed on
    the stack and assigned a pointer to a memory address for the reference type on
    the heap.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*栈*用于存储值类型和指向堆上内存位置的指针。当你调用一个方法时，它会被添加到栈上的一个栈帧中。然后，在该帧内，值类型被添加到栈上。如果有任何引用类型在方法中，这些类型将被放置在堆上，并且一个变量将被放置在栈上，并分配一个指向堆上引用类型内存地址的指针。'
- en: Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even though we can state that value types are added to the stack, this is not
    always true. For example, if you have an array of integers, the array – by virtue
    of being a reference type – will be added to the heap, and each of the integers
    that belong to the array will be added contiguously to the heap.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以声明值类型被添加到栈上，但这并不总是正确的。例如，如果你有一个整数数组，由于数组是一个引用类型，它将被添加到堆上，并且数组中的每个整数将连续添加到堆上。
- en: If a `struct` object has a reference type, the struct is placed on the stack,
    the reference type is placed on the heap, and a pointer to the address of the
    reference type on the heap is stored in the variable on the heap.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个`struct`对象具有引用类型，该结构体将被放置在栈上，引用类型将被放置在堆上，并且将引用类型在堆上的地址的指针存储在堆上的变量中。
- en: The stack is faster than the heap. It is arranged like a stack data structure.
    When you execute a method, the method is added to the stack in a stack frame.
    The local variables are then added to the stack frame on top of each other. When
    the method has completed execution, the memory is reclaimed immediately. The heap,
    however, must keep track of memory allocations, pointers, and reference counters,
    whereas the stack does not have to manage itself in this way.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 栈比堆快。它像栈数据结构一样排列。当你执行一个方法时，该方法被添加到栈上的栈帧中。然后，局部变量依次添加到栈帧的顶部。当方法执行完成后，内存立即被回收。然而，堆必须跟踪内存分配、指针和引用计数器，而栈则不需要以这种方式管理自己。
- en: Tip
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: With the stack, you can simply pop things on and off the stack. To increase
    the performance of your applications, look for heap usage in your applications.
    Measure the performance when using the stack and using the heap. If the stack
    is faster, then replace heap usage with stack usage.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用栈，你可以简单地从栈上弹出和添加东西。为了提高应用程序的性能，查找应用程序中的堆使用情况。测量使用栈和使用堆时的性能。如果栈更快，那么用栈使用替换堆使用。
- en: Keep in mind that the cost of using memory is not at the time of allocation
    but at the point of deallocation. The deallocation of items on the stack is more
    predictable than the deallocation of items on the heap. In some cases, the garbage
    collector is doing similar pointer arithmetic when *freeing* memory in generation
    0 or generation 1.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用内存的成本不是在分配时，而是在释放时。栈上项的释放比堆上项的释放更可预测。在某些情况下，垃圾收集器在释放0代或1代内存时执行类似的指针运算。
- en: Memory calls are also expensive because they are placed on the stack but may
    also reference the heap. Method performance is affected by code that does not
    execute. Therefore, you should refactor your methods to be as small as possible
    and remove any code that will not be executed, such as dead code that is no longer
    used. This will reduce the number of local variables in use and thereby reduce
    the stack size. And so, you will eliminate performance loss.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 内存调用也很昂贵，因为它们被放置在栈上，但可能也引用堆。方法性能受未执行代码的影响。因此，你应该重构你的方法，使其尽可能小，并删除任何不会执行的代码，例如不再使用的死代码。这将减少正在使用的局部变量数量，从而减少栈大小。这样，你将消除性能损失。
- en: The heap
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆
- en: The *heap* is used to store reference types. They are called reference types
    because they are reference-counted. To be reference-counted means that a count
    of variables referencing the allocated reference type is being kept by the runtime.
    When the reference count diminishes to zero, the reference type is deallocated
    by the garbage collector. For example, if I have a product object in memory and
    two variables on the stack pointing to that object, the product object has a reference
    count of two.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆*用于存储引用类型。它们被称为引用类型，因为它们是引用计数的。引用计数意味着运行时会保持引用分配的引用类型的变量计数。当引用计数减少到零时，引用类型将由垃圾收集器释放。例如，如果我在内存中有一个产品对象，并且有两个在栈上指向该对象的变量，那么产品对象有一个引用计数为二。'
- en: You may be surprised to learn that the allocation of objects in C# can sometimes
    be faster than in **C++**. The price is paid in C# when it comes to garbage collection.
    So, instantiating many objects does not cost us much at all, but the cleanup of
    those objects does. This means that the more objects you create, the harder the
    garbage collector must work, which negatively impacts your application's performance.
    Therefore, avoid using reference types if alternative value types can be used.
    Do not create objects if you do not need to.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地发现，在 C# 中分配对象有时可能比在 **C++** 中更快。但在垃圾回收方面，C# 需要付出代价。因此，实例化许多对象并不会给我们带来太多成本，但这些对象的清理却会。这意味着你创建的对象越多，垃圾收集器的工作就越困难，这会负面影响你的应用程序性能。因此，如果可以使用值类型，请避免使用引用类型。如果你不需要，请不要创建对象。
- en: When a new object is instantiated, it is placed on the heap. The variable is
    placed on the stack and is assigned a pointer to the address of the object on
    the heap.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的对象时，它会被放置在堆上。变量会被放置在栈上，并分配一个指向堆上对象地址的指针。
- en: 'Arrays of reference types are placed on the heap. The variable that references
    the array will be placed on the stack and it will be assigned to the memory address
    of the array on the heap. The array itself will contain a contiguous list of memory
    addresses, as shown in *Figure 3.5*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型数组被放置在堆上。引用数组的变量将被放置在栈上，并分配给堆上数组的内存地址。数组本身将包含一个连续的内存地址列表，如图 *图 3.5* 所示：
- en: '![Figure 3.6 – The heap displaying objects on the heap and their memory addresses
    within an array'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 堆中显示对象及其在数组中的内存地址'
- en: '](img/Figure_3.6_B16617.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.6_B16617.jpg)'
- en: Figure 3.6 – The heap displaying objects on the heap and their memory addresses
    within an array
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 堆中显示对象及其在数组中的内存地址
- en: These memory addresses are pointers to the memory addresses of reference type
    address locations on the heap. This is because when an array is placed on the
    heap that contains reference types, each of the reference types in the array is
    assigned to its own area of memory. The memory addresses of the reference types
    are then placed inside the array.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内存地址是指向堆上引用类型地址位置的指针。这是因为当一个包含引用类型的数组放置在堆上时，数组中的每个引用类型都被分配到它自己的内存区域。然后，引用类型的内存地址被放置在数组内部。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Array performance has been prioritized, followed by string performance. Arrays
    are often faster than lists and other data structures. But it is best to use benchmarks
    to decide which is better for your situation and choose the data structure that
    performs best for you.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 优先考虑了数组性能，其次是字符串性能。数组通常比列表和其他数据结构更快。但最好使用基准测试来决定哪种情况更适合你，并选择最适合你的数据结构。
- en: When it comes to maximizing the performance of memory usage, you need to ensure
    that objects on the heap are placed as close to their reference pointers as possible.
    The reason for this is to reduce the required CPU cycles when locating the memory
    that is being referenced by the pointer. The rule of thumb for memory performance
    is that the further memory is from its pointer, the more it costs you in CPU performance.
    Although, it must be said that predictive memory access reduces this greatly,
    and memory usage can be dependent on the system page file setup.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到最大化内存使用性能时，你需要确保堆上的对象尽可能靠近它们的引用指针。这样做的原因是为了减少定位指针所引用的内存所需的 CPU 周期。关于内存性能的经验法则是：内存距离其指针越远，它在你
    CPU 性能上的成本就越高。尽管如此，必须指出的是，预测性内存访问大大减少了这一点，内存使用可能取决于系统页面文件设置。
- en: Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The order in which you instantiate arrays, instantiate objects, assign values
    to objects, and assign values and objects to arrays affects the performance of
    your applications. This will be down to the placement of those items within memory.
    Remember that items on the heap should be close to their memory pointers, which
    may be stored either on the heap or on the stack.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你实例化数组、实例化对象、为对象赋值以及为数组和对象赋值和分配值的顺序会影响你应用程序的性能。这取决于这些项目在内存中的放置。记住，堆上的项目应该靠近它们的内存指针，这些指针可能存储在堆上或栈上。
- en: As already stated, object deallocation on the heap is slower than deallocation
    on the stack. The more objects you add to the heap, the slower your performance
    will be. The reason for this is that you give the garbage collector more work
    to do due to the frequent allocation and deallocation. It is this cycle of allocation
    and deallocation that causes the performance issues.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，堆上的对象释放比栈上的释放慢。你添加到堆上的对象越多，性能就会越慢。这是因为频繁的分配和释放导致垃圾收集器有更多的工作要做。正是这种分配和释放的循环导致了性能问题。
- en: 'There are two heaps within the main heap:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 主堆中有两个堆：
- en: '**Small object heap**: When a new object is instantiated, it is placed on the
    small object heap as generation 0 if it is less than 80,000 bytes in size.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小对象堆**：当一个新对象被实例化时，如果其大小小于 80,000 字节，它将被放置在小对象堆上作为第 0 代。'
- en: '**Large object heap**: When a new object is instantiated that is 80,000 bytes
    or larger in size, it is added to the large object heap. Large objects are always
    allocated in generation 2 because they are only garbage collected during a generation
    2 collection.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大对象堆**：当一个新对象被实例化，其大小为 80,000 字节或更大时，它将被添加到大对象堆上。大对象总是分配在第 2 代，因为它们只在第 2
    代收集期间进行垃圾回收。'
- en: We will be looking at the heap in more detail when we look at garbage collection
    in [*Chapter 4*](B16617_04_Final_SB_Epub.xhtml#_idTextAnchor072), *Memory Management*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看垃圾收集时，我们将更详细地查看堆，见 [*第 4 章*](B16617_04_Final_SB_Epub.xhtml#_idTextAnchor072)，*内存管理*。
- en: Building a stack versus building a heap (example project)
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建栈与构建堆（示例项目）
- en: 'Now, we will write a simple project that will get the number of ticks for object
    and struct instantiation with and without reference type properties. Start by
    adding a new .NET 6 console application called `CH03_StackAndHeap`. Then, add
    the `BenchmarkDotNet nuget` package. You will need to use the following `using`
    statements:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个简单的项目，该项目将获取具有和没有引用类型属性的实例化和结构体的 tick 数。首先，添加一个新的 .NET 6 控制台应用程序，名为
    `CH03_StackAndHeap`。然后，添加 `BenchmarkDotNet nuget` 包。你需要使用以下 `using` 语句：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, update the `Main(string[] _)` method as shown:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新 `Main(string[] _)` 方法，如下所示：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the method, we are calling the `BenchmarkTests` class that contains our
    benchmarks. Now, add the `ClassNoReference` class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在该方法中，我们正在调用包含我们的基准测试的 `BenchmarkTests` 类。现在，添加 `ClassNoReference` 类：
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This class has three value type properties and no reference type properties.
    Add the `ProcessClassNoReferences()` method in the `BenchmarkTests` class:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有三个值类型属性而没有引用类型属性。在 `BenchmarkTests` 类中添加 `ProcessClassNoReferences()` 方法：
- en: '[PRE66]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `ProcessClassNoReferences()` method declares a new instance of the `ClassNoReferences`
    class. It will be used as a benchmarking method. Add the `StructNoReferences`
    class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessClassNoReferences()` 方法声明了一个新的 `ClassNoReferences` 类实例。它将被用作基准测试方法。添加
    `StructNoReferences` 类：'
- en: '[PRE76]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This struct has three value type properties and no reference types. Let''s
    add the `ProcessStructNoReferences()` method to the `BenchmarkTests` class:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构有三个值类型属性而没有引用类型。让我们向 `BenchmarkTests` 类添加 `ProcessStructNoReferences()`
    方法：
- en: '[PRE92]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The `ProcessStructNoReferences()` method will be used as a benchmark, and it
    creates a new `StructNoReferences` struct. Next, add the `ClassWithReferences`
    class:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessStructNoReferences()` 方法将被用作基准，并创建一个新的 `StructNoReferences` 结构体。接下来，添加
    `ClassWithReferences` 类：'
- en: '[PRE102]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'This class has value and reference type properties. Now, we will add the `ProcessClassWithReferences()`
    method:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类具有值类型和引用类型属性。现在，我们将添加 `ProcessClassWithReferences()` 方法：
- en: '[PRE125]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The `ProcessClassWithReferences()` method will be used as a benchmark, and
    it creates an instance of `ClassWithReferences`. Next, we will add the `StructWithReferences`
    struct:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessClassWithReferences()` 方法将被用作基准，并创建一个 `ClassWithReferences` 类的实例。接下来，我们将添加
    `StructWithReferences` 结构体：'
- en: '[PRE135]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'This struct has value and reference types. And now, we will add our final method,
    `ProcessStructWithReferences()`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构体具有值类型和引用类型。现在，我们将添加我们的最终方法，`ProcessStructWithReferences()`：
- en: '[PRE158]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: The `ProcessStructWithReferences()` method will be used as a benchmark, and
    it creates a new `StructureWithReferences` struct.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessStructWithReferences()` 方法将被用作基准，并创建一个新的 `StructureWithReferences`
    结构体。'
- en: 'Compile the code in release mode. Then, run the executable. Your code will
    then be benchmarked, and you will see the following benchmark report:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以发布模式编译代码。然后，运行可执行文件。你的代码将被基准测试，你将看到以下基准报告：
- en: '![Figure 3.7 – The benchmark report comparing structs and classes with and
    without references'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 比较带和不带引用的结构体和类的基准报告'
- en: '](img/Figure_3.7.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.7.jpg]'
- en: Figure 3.7 – The benchmark report comparing structs and classes with and without
    references
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 比较带和不带引用的结构体和类的基准测试报告
- en: 'The benchmark results reveal the following insights:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试结果揭示了以下见解：
- en: Processing a class with no references is faster than processing a struct with
    no references
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有引用的类的处理比没有引用的结构体的处理更快
- en: Processing a class with references is slower than processing a struct with references
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用引用处理类比使用引用处理结构体慢
- en: As the benchmark results show, depending on the scenario, a struct can be faster
    than a class and vice versa. This is a good reason for benchmarking code, as you
    could be thinking your code is optimal when in fact it is slow.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如基准测试结果所示，根据场景的不同，结构体可能比类更快，反之亦然。这是基准测试代码的好理由，因为你可能会认为你的代码是最佳的，而实际上它很慢。
- en: So, how do you choose whether to use a struct or a class?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何选择使用结构体还是类呢？
- en: Choosing between a struct and a class
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在结构体和类之间进行选择
- en: 'As a rule of thumb, Microsoft recommends that we define our types as classes.
    If a type is embedded in other objects or if it is short-lived, then consider
    using a struct. When defining a struct, it should have the following characteristics:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 按照经验法则，微软建议我们将我们的类型定义为类。如果一个类型嵌入在其他对象中，或者如果它是短暂的，那么考虑使用结构体。在定义结构体时，它应该具有以下特征：
- en: Logically, the struct represents a single value.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从逻辑上讲，结构体代表一个单一值。
- en: The struct instance size is under 16 bytes.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体实例的大小小于16字节。
- en: The struct is immutable.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体是不可变的。
- en: The struct is not frequently boxed and unboxed.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体不经常进行装箱和拆箱。
- en: A *struct* is a *value type*. Value types are allocated on the stack or inline
    inside containing types. A value type will be deallocated when the stack is unwound
    or during the deallocation of the containing type. Value types are not garbage
    collected. The allocation and deallocation of value types on the stack are considered
    cheap. However, when a value type is boxed, it is wrapped in a reference type
    or cast to an interface, and this causes a performance slowdown. A performance
    slowdown is also experienced when a value type is unwrapped from inside a reference
    type, which is known as *unboxing*. You should do your best to avoid boxing and
    unboxing value types for performance reasons. When you assign value types, a complete
    copy of the value is passed into the assignment. The assignment of large value
    types can be more expensive than the assignment of large reference types.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构体* 是一种 *值类型*。值类型是在栈上分配或在包含类型内内联分配的。值类型将在栈展开或包含类型的释放期间被释放。值类型不会被垃圾回收。在栈上分配和释放值类型被认为是廉价的。然而，当一个值类型装箱时，它会被包裹在一个引用类型中或被转换为接口，这会导致性能下降。当值类型从引用类型内部解包时，也会经历性能下降，这被称为
    *拆箱*。出于性能原因，你应该尽可能避免对值类型进行装箱和拆箱。当你分配值类型时，值的完整副本会被传递到分配中。大型值类型的分配可能比大型引用类型的分配更昂贵。'
- en: A *class* is a *reference type*. Reference types are objects allocated on the
    heap with a pointer to the memory location placed on the stack. When a reference
    type comes to the end of its life, it is garbage-collected. The allocation and
    deallocation of reference types on the heap are considered expensive when compared
    with the allocation and deallocation of value types on the stack. Unlike value
    types, no boxing occurs when casting reference types. When you assign a reference
    type, a copy of the reference is passed to the assigned variable. The assignment
    of large reference types can be cheaper than the assignment of large value types.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*类* 是一种 *引用类型*。引用类型是在堆上分配的对象，其内存位置通过指针放置在栈上。当引用类型的生命周期结束时，它会被垃圾回收。与在栈上分配和释放值类型相比，在堆上分配和释放引用类型被认为是昂贵的。与值类型不同，在转换引用类型时不会发生装箱。当你分配一个引用类型时，引用的副本会被传递给分配的变量。大型引用类型的分配可能比大型值类型的分配更便宜。'
- en: An array of reference types contains pointers to the actual types on the heap.
    An array of value types contains the actual values of those reference types. The
    allocation and deallocation of value type arrays are cheap, and they have better
    locality when compared to arrays of reference types, as the value type values
    are inline.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型数组的数组包含指向堆上实际类型的指针。值类型数组的数组包含那些引用类型的实际值。值类型数组的分配和释放被认为是廉价的，并且与引用类型数组相比，它们具有更好的局部性，因为值类型的值是内联的。
- en: Let's move on to look at *passing by value* and *passing by reference*.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看 *按值传递* 和 *按引用传递*。
- en: Passing by value and passing by reference
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按值传递和按引用传递
- en: 'When passing values into a method or constructor, there are two ways to do
    this. They are *passing by value* and *passing by reference*:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当将值传递到方法或构造函数时，有两种方式可以这样做。它们是*按值传递*和*按引用传递*：
- en: '**Passing by value**: By default, all value types are passed by value into
    constructors and methods using *copy semantics*. This means that a copy is made
    of the value being passed in. The original value remains unchanged, and it is
    the copy that is used with the constructor or method.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按值传递**：默认情况下，所有值类型都是通过使用*复制语义*按值传递到构造函数和方法的。这意味着会复制传递的值。原始值保持不变，并且使用构造函数或方法使用的是副本。'
- en: '**Passing by reference**: When a reference type is passed into a constructor
    or method, a variable is made on the stack that points to the same object on the
    heap. So, both the variable that is passed in and the copied variable used inside
    the constructor or method operate on the same object in memory.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按引用传递**：当一个引用类型被传递到构造函数或方法中时，在堆栈上创建一个变量，该变量指向堆上相同对象。因此，传入的变量和构造函数或方法内部使用的副本变量都在内存中操作同一个对象。'
- en: Now that we know what passing by value and passing by reference are, let's write
    a simple program that demonstrates what we have learned.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了按值传递和按引用传递是什么，让我们写一个简单的程序来演示我们所学的。
- en: Building a pass-by-reference example program
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建按引用传递的示例程序
- en: 'We are going to write a very simple program that demonstrates the effects of
    passing by value and passing by reference. Add a new .NET 6 console application
    called `CH03_PassByValueAndReference`. Then, modify the `Main(string[] _)` method
    as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个非常简单的程序来演示按值传递和按引用传递的效果。添加一个新的.NET 6控制台应用程序，名为`CH03_PassByValueAndReference`。然后，按照以下方式修改`Main(string[]
    _)`方法：
- en: '[PRE168]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Here, we have declared an integer called `x` and assigned it a value of `0`.
    Some text is output to the console window, and we call two methods and output
    the value of `x` after they have been called. Let''s add the first method that
    is called – the `AddByValue(int x)` method:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为`x`的整数并给它赋值为`0`。一些文本被输出到控制台窗口，我们调用两个方法并在它们被调用后输出`x`的值。让我们添加第一个被调用的方法——`AddByValue(int
    x)`方法：
- en: '[PRE179]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'As you can see, it is a very simple method that increments the value for the
    variable passed in. Now, let''s repeat the same process, but this time, we will
    pass the value by reference:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个非常简单的函数，它增加了传入变量的值。现在，让我们重复同样的过程，但这次我们将按引用传递值：
- en: '[PRE183]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Run the program, and you should see the following output:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，你应该看到以下输出：
- en: '![Figure 3.8 – The value of x after incrementing using pass by value and pass
    by reference'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – 使用按值传递和按引用传递增加x后的值'
- en: '](img/Figure_3.8_B16617.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.8_B16617.jpg)'
- en: Figure 3.8 – The value of x after incrementing using pass by value and pass
    by reference
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 使用按值传递和按引用传递增加x后的值
- en: We can see that the original value is not updated when we pass by value. But
    it is updated when we pass by reference. We will now extend the application to
    cover the `in` parameter modifier.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当我们按值传递时，原始值不会被更新。但是当我们按引用传递时，它会更新。现在我们将扩展应用以涵盖`in`参数修饰符。
- en: 'Arguments passed with the `in` keyword are passed by reference. However, `in`
    arguments cannot be modified. Let''s demonstrate this – add a new method called
    `InParameterModifier()`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`in`关键字传递的参数是按引用传递的。然而，`in`参数不能被修改。让我们演示这一点——添加一个名为`InParameterModifier()`的新方法：
- en: '[PRE187]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'In the `InParameterModifier()` method, we create an integer and assign to it
    a value of `13`. We then call a method of the same name and pass in the variable
    as an argument. Then, we print out the value to the console window. Now, we will
    write the `InParameterModifier(in int argument)` method:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在`InParameterModifier()`方法中，我们创建了一个整数并将其赋值为`13`。然后我们调用一个同名的函数并将变量作为参数传入。然后，我们将值打印到控制台窗口。现在，我们将编写`InParameterModifier(in
    int argument)`方法：
- en: '[PRE193]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: The code is commented out because if we assign a value to the argument, we will
    get the compiler warning you see in the comment. Call the method from the `Main(string[]
    _)` object and run the program. You will see that the variable remains at `13`,
    as the compiler prevented us from being able to change it in the called method.
    Finally, in the next part of our program, we will look at the `out` keyword.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被注释掉了，因为如果我们给参数赋值，你将看到注释中提到的编译器警告。从`Main(string[] _)`对象中调用该方法并运行程序。你会看到变量保持在`13`，因为编译器阻止我们在被调用的方法中更改它。最后，在我们程序的下一部分，我们将探讨`out`关键字。
- en: An `out` argument does not have to be initialized before being passed in. This
    is different from a ref value that must be initialized before it is passed in.
    All `out` parameters are passed by reference. Any operation carried out on the
    argument inside the method becomes available to the external code that can see
    the argument. An example will make this easier to understand.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`参数在传递之前不需要初始化。这与在传递之前必须初始化的`ref`值不同。所有`out`参数都是通过引用传递的。在方法内部对参数进行的任何操作都对外部代码可见，这些代码可以看到参数。以下是一个示例，这将使理解更容易。'
- en: 'We will be adding two methods to demonstrate how the `out` parameter works.
    Add a new method called `OutParameterModifier()` to the `Program` class:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加两个方法来演示`out`参数的工作方式。向`Program`类添加一个名为`OutParameterModifier()`的新方法：
- en: '[PRE199]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'In the preceding code, we declare an integer variable. Then, we call a method
    that has an `out` parameter and we pass in our integer with its default value
    of `0`. Next, we print out the value of the integer once the method has returned.
    Now, add the `outParameter(out x)` method:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个整数变量。然后，我们调用一个具有`out`参数的方法，并将我们的整数及其默认值`0`传递给它。接下来，在方法返回后，我们打印出整数的值。现在，添加`outParameter(out
    x)`方法：
- en: '[PRE205]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Here, we are simply setting the argument to `123` and exiting. Call the `OutParameterModifier()`
    method from `Main(string[] _)`. If you run the code, you will see that our integer
    was updated to the value of `123` inside the method that we called. This is shown
    in *Figure 3.9*:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们只是将参数设置为`123`并退出。从`Main(string[] _)`中调用`OutParameterModifier()`方法。如果你运行代码，你会看到我们调用的方法中的整数被更新为`123`。这如图*3.9*所示：
- en: '![Figure 3.9 – Our integer has been updated inside the method we passed it
    into'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.9 – Our integer has been updated inside the method we passed it
    into'
- en: '](img/Figure_3.9_B16617.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.9 – Our integer has been updated inside the method we passed it
    into'
- en: Figure 3.9 – Our integer has been updated inside the method we passed it into
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 我们传递的方法中的整数已被更新
- en: In the following section, we will look at *boxing* and *unboxing*.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨*装箱*和*解箱*。
- en: Boxing and unboxing
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装箱和解箱
- en: '*Boxing* and *unboxing* variables negatively impact the performance of your
    applications. To improve your application''s code, you should do your best to
    avoid boxing and unboxing – especially when your code is mission-critical. In
    this section, we will look at what happens when you package (that is, box) a type.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*装箱*和*解箱*变量会对应用程序的性能产生负面影响。为了提高应用程序的代码质量，你应该尽力避免装箱和解箱 - 尤其是在代码是关键任务时。在本节中，我们将探讨当你包装（即装箱）类型时会发生什么。'
- en: Performing boxing
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行装箱
- en: When a variable is boxed, you are wrapping it in an object that gets stored
    on the heap. As you know, objects on the heap incur costs, as they must be managed
    by the runtime. On top of this, you also increase the memory used by the variable,
    as well as the number of CPU cycles needed to process the variable.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量被装箱时，你是在将其包装在一个将被存储在堆上的对象中。正如你所知，堆上的对象会产生成本，因为它们必须由运行时来管理。除此之外，你还会增加变量使用的内存，以及处理该变量所需的CPU周期数。
- en: An empty `class` definition is 12 bytes on a 32-bit operating system and 24
    bytes on a 64-bit operating system. This may not sound like a lot. But if a value
    type is boxed that does not need to be boxed, you will be wasting 12 or 24 bytes
    of memory unnecessarily.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位操作系统上，一个空的`class`定义占用12字节，而在64位操作系统上占用24字节。这听起来可能并不多。但如果将不需要装箱的值类型装箱，你将无谓地浪费12或24字节的内存。
- en: Now, we will look at what happens when you unbox a variable
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨当你解箱一个变量时会发生什么
- en: Performing unboxing
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行解箱
- en: A variable is copied to the evaluation stack that references an object on the
    heap. The variable is then unboxed (that is, unpacked) and the variable is placed
    on the evaluation stack. Then, whatever needs to be done with the unboxed variable
    can be done. Once all the work has been done with the variable, it then must be
    boxed up again and placed on the heap. This will create a new object on the heap,
    and the variable on the stack will be updated with its memory location.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量被复制到评估堆栈，它引用堆上的一个对象。然后，该变量被解封装（即，解包），并将变量放置在评估堆栈上。然后，可以对解封装的变量执行所需的任何操作。一旦完成对该变量的所有操作，它就必须再次封装并放置在堆上。这将创建堆上的新对象，并且堆栈上的变量将更新为其内存位置。
- en: Building a boxing-and-unboxing example program
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建封装与解封装示例程序
- en: 'Now, we will write a simple .NET 6 console application that shows the time
    difference between not boxing and boxing/unboxing on performance using `BenchmarkDotNet`.
    First, start a new .NET 6 console application and call it `CH03_BoxingAndUnboxing`.
    You will need to add the `BenchmarkDotNet` package and the following two namespaces:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个简单的 .NET 6 控制台应用程序，使用 `BenchmarkDotNet` 来展示不封装与封装/解封装在性能上的差异。首先，启动一个新的
    .NET 6 控制台应用程序，并将其命名为 `CH03_BoxingAndUnboxing`。您需要添加 `BenchmarkDotNet` 包和以下两个命名空间：
- en: '[PRE209]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'We need these namespaces to perform benchmarking. In the `Main(string[] _)`
    method, add the following line:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这些命名空间来执行基准测试。在 `Main(string[] _)` 方法中，添加以下行：
- en: '[PRE214]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'This line of code starts the benchmarks running. Next, add a new class called
    `BoxingAndUnboxingBenchmarkTests`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码开始运行基准测试。接下来，添加一个名为 `BoxingAndUnboxingBenchmarkTests` 的新类：
- en: '[PRE215]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'This class will hold two benchmarking methods called `NonBoxingUnboxingTest()`
    and `BoxingUnboxingTest()`. Add the `NonBoxingUnboxingTest()` method:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 此类将包含两个基准测试方法，分别称为 `NonBoxingUnboxingTest()` 和 `BoxingUnboxingTest()`。添加 `NonBoxingUnboxingTest()`
    方法：
- en: '[PRE216]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'In this method, we declare and assign three integers: `z = 0`, `a = 1`, and
    `b = 6`. We then add `a` and `b` together and assign the resulting value to `z`.
    Now, add the `BoxingUnboxingTest()` method:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们声明并赋值三个整数：`z = 0`、`a = 1` 和 `b = 6`。然后我们将 `a` 和 `b` 相加，并将结果赋值给 `z`。现在，添加
    `BoxingUnboxingTest()` 方法：
- en: '[PRE222]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'This time, we declare and assign two objects: `a = 4` and `b = 4`. We also
    declare an integer: `z`. Then, we cast `a` and `b` to integers, add them together,
    and assign the result to the `z` integer variable.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们声明并赋值两个对象：`a = 4` 和 `b = 4`。我们还声明了一个整数：`z`。然后，我们将 `a` 和 `b` 转换为整数，将它们相加，并将结果赋值给
    `z` 整数变量。
- en: 'Perform a release build of your code. Then, open a command line and navigate
    to your executable. Run your executable from the command line, and you should
    see the following summary:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 执行您的代码的发布构建。然后，打开命令行并导航到您的可执行文件。从命令行运行您的可执行文件，您应该会看到以下摘要：
- en: '![Figure 3.10 – The boxing-and-unboxing example project addition output'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10 – 封装与解封装示例项目添加输出'
- en: '](img/Figure_3.10.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.10.jpg)'
- en: Figure 3.10 – The boxing-and-unboxing example project addition output
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 封装与解封装示例项目添加输出
- en: As you can see from the screenshot in *Figure 3.10*, unboxing does add overhead
    to the performance of your applications.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从 *图 3.10* 中的截图所看到的，解封装确实会增加您应用程序的性能开销。
- en: 'If you open the `ILDASM`, this will load the intermediate language disassembler.
    Open the DLL file in your build folder, and expand the tree until you see the
    `Main : void(string[])` line, as shown in *Figure 3.11*:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您打开 `ILDASM`，这将加载中间语言反汇编器。打开您的构建文件夹中的 DLL 文件，展开树形结构，直到您看到 `Main : void(string[])`
    行，如图 *图 3.11* 所示：'
- en: '![Figure 3.11 – The Intermediate Language Disassembler (ILDASM)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.11 – 中间语言反汇编器 (ILDASM)'
- en: '](img/Figure_3.11_B16617.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.11_B16617.jpg)'
- en: Figure 3.11 – The Intermediate Language Disassembler (ILDASM)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 中间语言反汇编器 (ILDASM)
- en: 'Double-click the `Main` method. This will bring up the window that shows the
    disassembled intermediate language for our `Main(string[] _)` method, as shown
    in *Figure 3.12*:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 双击 `Main` 方法。这将打开一个窗口，显示我们的 `Main(string[] _)` 方法的反汇编中间语言，如图 *图 3.12* 所示：
- en: '![Figure 3.12 – The disassembled intermediate language for our Main(string[]
    _) method'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.12 – 我们 Main(string[] _) 方法的反汇编中间语言'
- en: '](img/Figure_3.12_B16617.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.12_B16617.jpg)'
- en: Figure 3.12 – The disassembled intermediate language for our Main(string[] _)
    method
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 我们 Main(string[] _) 方法的反汇编中间语言
- en: Study the disassembled code. When you see the `box` command, the value type
    is being wrapped inside of an object, which is a reference type that gets placed
    on the heap. And when you see the `unbox.any` command, the value type is being
    unwrapped from the object and assigned to an int value type that belongs on the
    stack.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 研究反汇编代码。当你看到`box`命令时，值类型被封装在一个对象中，这是一个引用类型，它会被放置在堆上。而当你看到`unbox.any`命令时，值类型被从对象中解包并分配给一个属于栈的int值类型。
- en: You now understand why boxing and unboxing affect the performance of your applications,
    and now we have come to the end of the chapter. In the next chapter, we will be
    focusing on how the garbage collector works and what we can do to improve its
    performance. But first, let's summarize what we have learned. You are then encouraged
    to answer the questions that follow and further your reading on this subject.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你理解了为什么装箱和拆箱会影响应用程序的性能，现在我们来到了本章的结尾。在下一章中，我们将关注垃圾回收器的工作原理以及我们可以做些什么来提高其性能。但首先，让我们总结一下我们已经学到的内容。然后，鼓励你回答以下问题，并进一步阅读这个主题。
- en: Summary
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started the chapter by looking at the various predefined .NET data types.
    First, we described the various value types, and then we moved on to the predefined
    reference types. Then, we concluded our discussion of predefined .NET data types
    by exploring static types.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时探讨了各种预定义的.NET数据类型。首先，我们描述了各种值类型，然后转向预定义的引用类型。然后，我们通过探索静态类型来结束对预定义.NET数据类型的讨论。
- en: You learned that value types live on the stack. But if they are part of an array,
    they are placed on the heap with the array that happens to be a reference type.
    You also learned that reference types live on the heap and that they have pointers
    to them in the form of variables that live on the stack.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解到值类型位于栈上。但如果它们是数组的一部分，它们会与数组一起放置在堆上，而数组是一个引用类型。你还了解到引用类型位于堆上，并且它们有指向它们的指针，这些指针以栈上变量的形式存在。
- en: Next, we looked at the different types of memory used in C#. First, we looked
    at the stack. Then, we looked at the heap, which consists of the small object
    heap and the large object heap. After looking at the differences between the stack
    and the heap, we saw that the stack performs much faster than the heap. The reason
    for this is that the stack memory does not have to be managed by the runtime.
    It is simply popped onto the stack when it is needed and popped off the stack
    when it is not needed. In contrast, the heap must be managed by the runtime that
    allocates the objects – it keeps a reference count of all the variables that reference
    those objects, and then it deallocates the objects when they are no longer needed.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了C#中使用的不同类型的内存。首先，我们看到了栈。然后，我们看到了堆，它由小对象堆和大对象堆组成。在查看栈和堆之间的差异后，我们发现栈的执行速度比堆快得多。原因是栈内存不需要由运行时管理。当需要时，它简单地被推入栈中，当不再需要时，它被弹出栈。相比之下，堆必须由运行时管理，它分配对象——它跟踪所有引用这些对象的变量的引用计数，然后在它们不再需要时释放对象。
- en: We then looked at passing by value and passing by reference. Values passed by
    value have a copy taken of them that is passed into the constructor or method.
    This copy is utilized, and the original value remains untouched. When passed by
    reference, a copy of a value is made and placed on the stack, and it is assigned
    the memory location of the object on the heap.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着探讨了按值传递和按引用传递。按值传递时，会复制一个值并将其传递给构造函数或方法。这个副本被使用，而原始值保持不变。当按引用传递时，会创建一个值的副本并将其放置在栈上，并分配给堆上对象的内存位置。
- en: Finally, we looked at the boxing and unboxing of variables and why this negatively
    impacts your application's performance.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了变量的装箱和拆箱以及为什么这会对应用程序的性能产生负面影响。
- en: With all that you have learned in this chapter, you can reduce the amount of
    memory your applications use by using the right types, and you can reduce the
    number of ticks per operation by avoiding boxing and unboxing. And now that you
    know how memory allocations work, you can improve performance by keeping methods
    small and using the stack instead of the heap when it is practical to do so.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章所学的内容，你可以通过使用正确的类型来减少应用程序使用的内存量，并且可以通过避免装箱和拆箱来减少每操作的tick数。现在，既然你知道了内存分配的工作原理，你可以在实际可行的情况下通过保持方法小和优先使用栈来提高性能。
- en: In the next chapter, we will be learning more about garbage collection.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于垃圾回收的内容。
- en: Questions
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: List the predefined .NET value types.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出预定义的.NET值类型。
- en: List the predefined reference types.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出预定义的引用类型。
- en: What does the runtime have to do before a static type can be accessed and utilized?
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在静态类型可以被访问和使用之前，运行时必须做什么？
- en: Is there a physical difference in the memory that is used that makes the stack
    run faster than the heap?
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用栈而不是堆的内存在物理上有什么区别，使得栈比堆运行得更快？
- en: Why is the stack faster than the heap?
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么栈比堆运行得更快？
- en: Explain why strings are immutable.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释为什么字符串是不可变的。
- en: What is the approximate size of objects placed on the small object heap?
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置在小对象堆上的对象的大致大小是多少？
- en: What is the approximate size of objects placed on the large object heap?
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置在大对象堆上的对象的大致大小是多少？
- en: Further reading
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*The C# type system*'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C#类型系统*'
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/)'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/)'
- en: '*C# Different Types of Heap Memory*'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C#不同类型的堆内存*'
- en: '[https://vivekcek.wordpress.com/tag/stub-heap/](https://vivekcek.wordpress.com/tag/stub-heap/)'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://vivekcek.wordpress.com/tag/stub-heap/](https://vivekcek.wordpress.com/tag/stub-heap/)'
- en: '*Drill Into .NET Framework Internals to See How the CLR Creates Runtime Objects*'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深入.NET框架内部以查看CLR如何创建运行时对象*'
- en: '[https://web.archive.org/web/20140724084944/http://msdn.microsoft.com/en-us/magazine/cc163791.aspx](https://web.archive.org/web/20140724084944/http://msdn.microsoft.com/en-us/magazine/cc163791.aspx)'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://web.archive.org/web/20140724084944/http://msdn.microsoft.com/en-us/magazine/cc163791.aspx](https://web.archive.org/web/20140724084944/http://msdn.microsoft.com/en-us/magazine/cc163791.aspx)'
- en: '*Passing Parameters (C# Programming Guide)*'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*传递参数（C#编程指南）*'
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/passing-parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/passing-parameters)'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/passing-parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/passing-parameters)'
- en: '*Boxing and Unboxing (C# Programming Guide)*'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*装箱与拆箱（C#编程指南）*'
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing)'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing)'
- en: '*The large object heap on Windows systems*'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Windows系统上的大对象堆*'
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap)'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap)'
- en: '*.NET Memory Allocations and Performance*'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.NET内存分配和性能*'
- en: '[https://www.youtube.com/watch?v=aylUPfOVM90](https://www.youtube.com/watch?v=aylUPfOVM90)'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=aylUPfOVM90](https://www.youtube.com/watch?v=aylUPfOVM90)'
- en: '*Replacing AppDomain in .NET Core*'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在.NET Core中替换AppDomain*'
- en: '[https://www.michael-whelan.net/replacing-appdomain-in-dotnet-core/](https://www.michael-whelan.net/replacing-appdomain-in-dotnet-core/)'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.michael-whelan.net/replacing-appdomain-in-dotnet-core/](https://www.michael-whelan.net/replacing-appdomain-in-dotnet-core/)'
