- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency Injection, Services, and Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we continue building our *Recipes!* app using .NET MAUI, we want to make
    the most of the MVVM design pattern. MVVM is great for keeping our code organized
    and also promotes industry-standard practices that make our code base more maintainable
    and testable. In this chapter, we will focus on two critical concepts that are
    central to a solid MVVM architecture: **Dependency** **Injection** (**DI**) and
    **messaging**. DI promotes separation of concerns and allows our code to be much
    more testable. Messaging helps us keep different parts of our code from getting
    tangled up with each other. It allows different areas of our app to talk to each
    other in a loosely coupled way. Both concepts are extremely important to ensure
    that our MVVM architecture truly stands out.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at what this chapter covers:'
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of Control through Dependency Injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering, resolving, and injecting services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have a good understanding of these concepts
    as we implement them in our *Recipes!* app. So, let’s go ahead and get into it.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we will be enhancing the functionality of the *Recipes!*
    app. All the resources, including additional classes and code required for the
    topics covered in this chapter, are available on GitHub at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter07](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter07).
    To follow along with this chapter’s content, you can start with the provided `Start`
    folder. It contains the initial code and necessary classes specific to this chapter.
    This code serves as the foundation, building upon what we have learned in the
    previous chapters. If you want to reference or compare the completed code, including
    all the code written throughout this chapter, you can find it in the `Finish`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of Control through Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inversion of Control** (**IoC**) is a programming principle where the control
    over certain aspects of a program’s flow is handed over from the main code to
    a framework or a container. In simple terms, instead of a component being responsible
    for managing its dependencies and life cycle, these responsibilities are inverted
    or delegated to an external controller. This approach is particularly useful for
    creating modular and flexible systems.'
  prefs: []
  type: TYPE_NORMAL
- en: In a typical software design without IoC, a class that requires certain functionalities
    from other classes would create or manage these dependent objects within itself.
    With IoC, this creation and management is handled by an external component, hence
    inverting the control.
  prefs: []
  type: TYPE_NORMAL
- en: IoC can be achieved through various methods such as DI, Factory Pattern, Service
    Locator, and more. Among these, DI is the most commonly used method in the context
    of MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DI, a specific form of IoC, involves injecting the dependencies of an object
    (such as services or components) into the object by an external entity rather
    than having the object create them. This is typically done through the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using DI brings a lot of advantages. Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concerns**: Each component or class focuses on its core responsibility.
    The creation and life cycle management of its dependencies are handled externally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: DI makes it much easier to test components by allowing mock
    dependencies to be injected. This is crucial because, in unit testing, you want
    to isolate the component being tested and not have to worry about the dependencies.
    For example, if a ViewModel depends on a service that fetches data, you can inject
    a mock data service that simulates data retrieval without actually hitting a database
    or API. This makes tests faster, repeatable, and more reliable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability and maintainability**: Components become more reusable and maintainable
    because they are not tightly coupled with their dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: It becomes easier to change or swap implementations of dependencies
    without altering the dependent class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By allowing dependencies to be injected from the outside, DI supports the creation
    of more loosely coupled code. This not only results in a more maintainable and
    scalable system but is also highly advantageous for testing. Through the injection
    of mock or stub implementations during testing, you can focus on testing the functionality
    of individual components in isolation, without the complexity and unpredictability
    of the entire system.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to inject different implementations is one of the powerful aspects
    of DI and is central to creating robust and flexible architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, back in [*Chapter 1*](B20941_01.xhtml#_idTextAnchor015), *What Is
    the MVVM Design Pattern?,* where we had a `MainPageViewModel` and its constructor
    accepted an interface called `IQuoteService`? Let’s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a textbook example of DI. `MainPageViewModel` should not be responsible
    for retrieving the “quote of the day.” Instead, this should be the responsibility
    of another class. `MainPageViewModel` is dependent on an instance of a class that
    implements `IQuoteService` for that functionality. However, instead of directly
    creating or managing an instance of this service, it receives the instance through
    its constructor. This is what’s known as `IQuoteService` dependency through its
    constructor, `MainPageViewModel` adheres to the principle of `MainPageViewModel`
    class’s responsibility is to provide data for the view, while the responsibility
    to fetch the actual data is delegated to `IQuoteService`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `MainPageViewModel` has no knowledge about where the class implementing
    the `IQuoteService` interface comes from, how it’s instantiated, or how its life
    cycle is managed. It simply receives an instance and uses it. This makes the ViewModel
    independent from the concrete implementation of the `IQuoteService` interface
    and it can be any class that implements this interface.
  prefs: []
  type: TYPE_NORMAL
- en: This `IQuoteService` interface, we can just create a new class that implements
    it and fetch data from the API. We can then inject this new class into our ViewModel
    without having to change any code inside `MainPageViewModel` itself. The ViewModel
    is only concerned with the fact it has a class implementing the `IQuoteService`
    interface to work with, not the details of how it accomplishes its tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While it’s common to see DI used with interfaces, it’s not a strict requirement.
    Interfaces are popular in DI because they promote loose coupling. However, abstract
    classes or even concrete classes can be injected as well. The choice depends on
    the specific needs of your application and your design goals.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this decoupling becomes even more evident when it comes to
    testing. Let’s say we want to write unit tests for `MainPageViewModel`. To make
    these tests reliable, we need to ensure they’re not affected by the unpredictability
    of external dependencies. With DI, we can easily achieve this by creating a mock
    implementation of `IQuoteService` that returns controlled data, perfect for testing
    scenarios. This way, we can test all aspects of `MainPageViewModel` in isolation,
    without any unpredictable behavior from external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see DI in action and have a look at how we can register, resolve, and
    inject dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Registering, resolving, and injecting services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET MAUI comes with built-in support for DI. It has been designed with DI in
    mind, which allows for easier configuration and management of services that your
    application relies on. By providing out-of-the-box support for DI, .NET MAUI enables
    developers to leverage the concept of DI and IoC to make their code more maintainable
    and more loosely coupled. As the MVVM pattern benefits tremendously from DI and
    IoC, it shows again that MVVM and .NET MAUI are a perfect match!
  prefs: []
  type: TYPE_NORMAL
- en: The `Microsoft.Extensions.DependencyInjection` namespace is where .NET MAUI
    gets its default implementation for DI. However, it’s important to note that .NET
    MAUI is DI container agnostic, which means you’re not limited to the default.
    If you prefer a third-party DI container, you’re free to replace the default with
    your preferred choice. Let’s see how we can register services using .NET MAUI’s
    default DI implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Registering services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET MAUI hosts a DI container and makes it accessible throughout your application.
    When your application starts, you have the opportunity to configure the services
    that will be available for injection. This is done using the `Services` property
    of the `MauiAppBuilder` instance. If you have worked with ASP.NET before, then
    you already know how this works. Through the `Services` property, we can set up
    services for use throughout your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Services` property on `MauiAppBuilder` is of type `IServiceCollection`,
    which is a framework-provided interface for a collection of service descriptors.
    It provides methods to register services in the container. In the following example,
    the `AddSingleton` method is used to register `QuoteService` as a Singleton service
    for the `IQuoteService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how we can associate a concrete implementation (`QuoteService`)
    with an interface (`IQuoteService`). As a consequence, when the app’s `IServiceProvider`
    needs to resolve an instance of a class that implements the `IQuoteService`, it
    will create (or reuse) an instance of the `QuoteService` class. `IServiceProvider`
    represents a service container, which is a collection of service registrations.
    It’s essentially the object that is responsible for resolving and providing instances
    of services, which were registered through the associated `IServiceCollection`,
    when they are needed. Registering a concrete implementation for a particular interface
    allows us to decouple the implementation from the actual usage in our code. It’s
    good practice to code against interfaces and not against implementations and this
    is exactly what we can achieve here.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in the case of ViewModels or other classes that don’t necessarily
    have an associated interface, we can register them directly, as the following
    snippet shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When we do this, every time an instance of `MainPageViewModel` is requested
    from the DI container, it will provide an instance of the class and manage its
    life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Services can be registered in different ways, depending on their intended lifetimes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transient**: Transient services are created each time they’re requested from
    the container. This lifetime works best for lightweight, stateless services. In
    theory, Transient services take up more memory because a new instance is created
    every time the service is requested. However, because each instance can be garbage-collected
    as soon as it’s no longer in use, this memory can be reclaimed quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: Singleton services are created once, and the same instance is
    used throughout the application’s lifetime. This works best for stateful services
    that need to maintain consistency across the app, or for heavy services that would
    be expensive to create multiple times. Singleton services take up the least amount
    of memory because only one instance is ever created. However, because the same
    instance is used throughout the entire application, it stays in memory for as
    long as the application is running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scoped**: Scoped services are created once per scope. However, in a .NET
    MAUI application, this is similar to Singleton since there is generally only one
    scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between these lifetimes depends entirely on the specific needs of the
    service. If your service is stateless and lightweight, a Transient lifetime might
    be appropriate. If your service needs to maintain state across the entire application,
    or if it’s expensive to create, a Singleton lifetime might be the best option.
    Choosing the right lifetime for your services is important. It can affect how
    your app behaves and performs, so think about it carefully. In my experience,
    I usually choose Transient as much as possible for my services. I do this because
    I aim to keep my services simple and without state. This way, they use memory
    more efficiently since they’re removed as soon as they’re not needed. Also, it
    helps to avoid problems that can come up when a shared state is changed in different
    places, especially in multi-threaded situations. But remember, there’s no one-size-fits-all
    solution here. Each service is unique and so is your app. Depending on what your
    service does and what your app needs, you might have to choose a different lifetime.
    That’s why it’s key to understand these concepts and make smart choices for your
    specific app.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we can resolve and inject these registered services.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving and injecting services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DI containers, such as the one built into .NET MAUI, are capable of resolving
    not only direct dependencies but also nested dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, when an instance of a class or service is being resolved by the
    container, all of its dependencies, and the dependencies of those dependencies,
    are automatically resolved and injected as well. This forms a complete object
    graph where every class has its dependencies satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a particular class has a dependency that needs to be injected, it is as
    simple as defining the dependency as a parameter of the class’s constructor. That’s
    exactly what we did with `MainPageViewModel`: it has a constructor that requires
    an instance of a class implementing the `IQuoteService` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Which constructor does the DI container use?
  prefs: []
  type: TYPE_NORMAL
- en: 'As the DI container can instantiate classes for us, you might wonder which
    constructor it uses when the class has multiple constructors. The answer is pretty
    simple: it uses the constructor with the most parameters that it can resolve.
    If there are two or more constructors with the same number of parameters the DI
    container can resolve, or when no constructor is found for which all dependencies
    could be resolved, an exception will be thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also able to resolve services on the fly, so long as we get a hold of
    the app’s `IServiceProvider` container. This interface exposes a `GetService<T>`
    method that we can call to get an instance of a class that was associated with
    the provided generic type parameter. The following code block shows how we can
    create a static `ServiceProvider` class that we could use to access the services
    container from anywhere in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, instead of instantiating a `MainPageViewModel` in the code behind the `MainPage_MVVM`
    class, and needing to manually provide an instance of a class that implements
    IQuoteService, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we have registered `MainPageViewModel` as a service and `QuoteService`,
    which we associated with the `IQuoteService` interface, the `GetService` method
    will return an instance of `MainPageViewModel`, which is instantiated by injecting
    an instance of the `QuoteService` class through its constructor. This `ServiceProvider`
    class can be very helpful to resolve instances of classes on the fly from the
    DI container. However, for this particular example, we could take this a step
    further and avoid the need to manually resolve an instance of `MainPageViewModel`.
    We can achieve this by adding an instance of `MainPageViewModel` as a dependency
    to the `MainPage_MVVM` class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet shows how we can register the `MainPage_MVVM` class
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this sample app, we’re using .NET MAUI Shell for navigation. This allows
    an instance of a page to be dynamically resolved during the navigation process.
    So, when we navigate to the `MainPage_MVVM` page, the DI container springs into
    action. It resolves an instance of the `MainPage_MVVM` page and all of its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: What is .NET MAUI Shell?
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B20941_08.xhtml#_idTextAnchor132), *Navigation in MVVM*, we
    will dive much deeper into the aspects of navigation and .NET MAUI Shell.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve got a taste of DI with the *Quote of the Day* app, let’s take
    things up a notch by applying what we’ve learned to our feature-rich *Recipes!*
    app. This will allow us to delve deeper into DI and see how it can be skillfully
    utilized in a more complex project. So, roll up your sleeves, and let’s get cooking
    with DI in the *Recipes!* app.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Dependency Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, in the ViewModels in our *Recipes!* app we have been working with hard-coded
    data. Now, it’s time to breathe more life into our application by introducing
    services that can fetch and manage data dynamically. The `Begin` directory in
    the GitHub repository for this chapter presents some updates and additional code
    that includes new service interfaces such as `IRecipeService`, `IFavoritesService`,
    and `IRatingsService`, along with their respective implementations. These services
    will play crucial roles in our application: the `IRecipeService` interface defines
    a contract for a service that will load and manage recipe data. Similarly, `IFavoritesService`
    outlines the rules for a service that will handle the user’s favorite recipes,
    and the `IRatingsService` interface does the same for a service managing recipe
    ratings. As we move forward, we’ll explore how to use these services within the
    MVVM architecture and how DI brings it all together in a clean, manageable manner.'
  prefs: []
  type: TYPE_NORMAL
- en: To introduce DI in our *Recipes!* app, we need to make sure that, unlike what
    we have been doing up until now, we don’t initialize ViewModels in the code-behind
    ourselves. Instead, these ViewModels need to be injected and assigned to the page’s
    `BindingContext`. Let’s have a look at this before we update the ViewModels.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies to pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add the dependency of a particular ViewModel to a page, we simply need to
    add the type of ViewModel as a parameter to the constructor. Also, we need to
    make sure that both the page and the ViewModel are registered in the DI container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to the code-behind of `RecipesOverviewPage` and add a parameter of
    type `RecipeOverviewViewModel` to the page’s constructor, as shown in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to make sure the `RecipesOverviewPage` and `RecipeOverviewViewModel`
    classes are registered with the DI container. Only then can the DI container resolve
    `RecipesOverviewPage` and resolve its dependency, an instance of `RecipesOverviewViewModel`.
    Head over to `MauiProgram` and add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, we need to do the same for `RecipeDetailPage` and `RecipeRatingDetailPage`:
    add their respective ViewModels as dependencies by including them as parameters.
    This is what it looks like for `RecipesOverviewPage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And likewise, for `RecipeRatingDetailPage`, we must do the following, where
    we want to inject `RecipeRatingsDetailViewModel`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, just like we did before, let’s register these additional pages and their
    ViewModels in the DI container within the `MauiProgram` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these modifications in place, we’ve successfully implemented the foundational
    elements of DI in our *Recipes!* app. By registering the pages and their corresponding
    ViewModels with the DI container, we’ve ensured that whenever these components
    are needed, they can be easily resolved and provided by the DI container. Moreover,
    by injecting the ViewModels into our pages through their constructors, we’ve shifted
    the responsibility of creating and managing ViewModel instances away from the
    pages themselves and toward the DI container. This sets up a more flexible and
    maintainable structure for our application, paving the way for us to further enhance
    it with additional services and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a closer look at the specific changes we need to make to our
    ViewModels to fully incorporate DI.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies to ViewModels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We no longer want our ViewModels to contain hard-coded data, nor do we want
    them to be responsible for retrieving data. So, let’s introduce some dependencies
    to our ViewModels:'
  prefs: []
  type: TYPE_NORMAL
- en: At the very top of the `RecipesOverviewViewModel` class, we can start by removing
    the `items` field. We’re moving away from hard-coded data and will use services
    to fetch data instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we introduce two fields to this class:
    `recipeService`, which is of type `IRecipeService`, and `favoritesService`, which
    is of type `IFavoritesService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These services will take responsibility for loading the recipes on this page
    and displaying whether they are favorited by the user or not. Both of these services
    are dependencies that will be injected into the ViewModel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This code block shows exactly how these dependencies can get injected through
    the constructor of the ViewModel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By defining these two parameters in the constructor for `RecipesOverviewViewModel`,
    the DI container will attempt to resolve instances for both when creating a `RecipesOverviewViewModel`.
    The resolved instances are then passed as parameters to the constructor, where
    we can assign them to the fields we created earlier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When we examine the `LoadRecipes` method, we can see how we utilize these services
    to load the data we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The ViewModel doesn’t concern itself with where these recipes or favorites are
    coming from. It only trusts that the injected services – `recipeService` and `favoritesService`
    – adhere to the specified interfaces and deliver the required functionality. The
    exact implementation is abstracted away from the ViewModel, highlighting one of
    the main benefits of DI.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Head over to `RecipeDetailViewModel`. In this class, we also want to remove
    all hard-coded data: `Title`, `Allergens`, `Calories`, and so on. And while we
    are at it, we should update the properties to “full” properties that trigger the
    `PropertyChanged` event. This is needed because the data on the ViewModel will
    be loaded asynchronously, so it won’t be there when the page is being rendered.
    As a result, the `PropertyChanged` event for each property needs to be triggered
    when the data is loaded to reflect the loaded values on the UI. The following
    snippet shows some of the updated properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now is also the time to update the binding mode on the label, which shows the
    recipe’s title. Up until now, this was defined as a `OneTime` binding, but as
    we now load the data of the recipe after the ViewModel is set as the `BindingContext`
    of the `RecipeDetailPage`, we need to make sure the updated value is shown on
    the screen as well. Let’s update the binding mode to `OneWay` so that when the
    `PropertyChanged` event is triggered after the value of the `Title` property is
    set, the binding engine updates the value on the UI. The following snippet shows
    the updated label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s update the constructor of `RecipeDetailViewModel` so that it accepts
    an instance of `IRecipeService`, `IFavoritesService`, and `IRatingsService`, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These services (`recipeService`, `favoritesService`, and `ratingsService`)
    are `readonly` fields that we should define in the ViewModel, as demonstrated
    in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code block shows `LoadRecipe`, which accepts the ID of the recipe
    to load as a parameter. This method uses the injected services to load all relevant
    data for this ViewModel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The three async tasks that retrieve `RecipeDetailDto`, `RatingsSummaryDto`,
    and the `bool` value indicating whether the recipe is a favorite or not are launched
    in parallel. Through the `Task.WhenAll` method, we wait for all three to complete.
    Beyond this point, the `Result` property of the tasks holds the retrieved data.
    This data is then mapped to the ViewModel through the `MapRecipeData` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the next chapter, [*Chapter 8*](B20941_08.xhtml#_idTextAnchor132), *Navigation
    in MVVM*, we’ll have a look at how we can pass the ID of the selected recipe from
    `RecipesOverviewViewModel` to `RecipeDetailViewModel` to load the recipe details
    of the chosen recipe. For now, let’s add the following snippet at the end of the
    ViewModel’s constructor to load the details of the recipe with an ID of `3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we also need to update `RecipeRatingsDetailViewModel`. As before,
    we want to remove all hard-coded data and update the constructor so that it accepts
    an instance of a class that implements `IRecipeService` and one that implements
    the `IRatingsService` interface. The following snippet shows the updated constructor,
    where we also deleted the initialization of both the `Reviews` and `GroupedReviews`
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Reviews` property can be removed and we should make sure the `RecipeTitle`
    property calls the `PropertyChanged` event when it is being updated. Again, like
    we did previously, we must do this because the data is loaded asynchronously and
    we must notify the UI about the updated values. The following code block shows
    the updated `RecipeTitle` property, which uses the `SetProperty` method of the
    `ObservableObject` class to assign the value and trigger the `PropertyChanged`
    event. It also shows the fields that we added, to which we assign the injected
    dependencies in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also add the `LoadData` method, which accepts the ID of the recipe we
    want to load the rating for. It uses the injected services to dynamically load
    the data needed in this ViewModel. Let’s take a look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For now, let’s call the `LoadData` method from the constructor so that it loads
    some data when we initialize the ViewModel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With all the updates done on the ViewModels, let’s finish up by registering
    the services that our updated ViewModels now have as dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Registering services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that our ViewModels have some dependencies, we have to make sure these dependencies
    get registered so that the DI container can resolve them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Registering the required dependencies is done again in the `MauiProgram` class.
    The following snippet shows how we register `FavoritesService`, which is very
    straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We intentionally register `FavoritesService` as a Singleton because this particular
    implementation stores the user’s favorites in memory. If we were to register it
    as Transient, a new instance would be created each time it’s injected as a dependency,
    which would result in the favorites not persisting between page navigations. It’s
    worth noting, however, that keeping favorites in memory isn’t ideal, but for the
    sake of this example, it will serve our purpose. In a real-life scenario, we would
    want the favorites to be persisted in an (online) data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Registering `RecipeService` involves a slightly more complex process. The reason
    for this is that the constructor of `RecipeService` requires a `Task` property
    that returns a stream to a JSON file that holds all the recipe information. This
    is shown in the constructor of `RecipeService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can’t register `RecipeService` in the same way we did with `FavoritesService`
    or other services we registered in earlier examples. This is because the DI container
    needs to know what parameter to pass to the constructor. In previous examples,
    it was straightforward: we just specified the concrete type that we wanted to
    associate with an interface or base class, or with the type itself. The container
    could then create an instance of the concrete class by invoking its default constructor
    or injecting other resolved dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in the case of `RecipeService`, the required parameter for creating
    an instance isn’t something we plan to register, meaning it cannot be resolved
    by the DI container. To tackle scenarios like this, the `AddTransient`, `AddSingleton`,
    and `AddScoped` methods provide an overload. This overload lets us pass in a function
    that returns an instance of the type we want to associate with the given base
    type. This function is invoked every time the associated type needs to be resolved.
    What’s more, the function’s parameter is `IServiceProvider` itself, allowing us
    to resolve any additional dependencies if necessary. The following code block
    shows how we can register `RecipeService`, using the overloaded function, while
    passing in a function that creates an instance of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The passed-in function will be invoked every time an object of `IRecipeService`
    needs to be resolved by the DI container. However, as the `AddSingleton` method
    was used, the function would be invoked only once. This means that in this specific
    use case, registering the service as a Singleton could be a sensible decision
    as it would ensure that the JSON file only gets read once, keeping the recipes
    in memory, and thereby optimizing the application’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same thing goes for the registration of `RatingsService`. Just like `RecipeService`,
    this class will also read from a local file to get the ratings. So, as before,
    we want to register this service using the overloaded `AddTransient` method, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Once all these services have been registered, we can go ahead and run the *Recipes!*
    app. Our code now leverages DI, a practice that greatly enhances the modularity
    and testability of our application. By injecting dependencies, we decouple concrete
    classes with interfaces or base classes, allowing us to change or swap underlying
    implementations without affecting dependent classes. In the context of the MVVM
    pattern, DI allows us to provide ViewModels with the necessary services to handle
    their tasks, such as data fetching or business logic, without hard-coding these
    dependencies, promoting a clean separation of concerns. Moreover, we have even
    taken this concept a step further by using DI to inject ViewModels directly into
    our views, further emphasizing the flexibility and versatility this practice provides
    in our app development process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While we’ve primarily discussed constructor-based DI in .NET MAUI, it’s worth
    mentioning that in broader contexts, dependencies can also be injected via properties
    or methods. However, such methods are not natively supported in .NET MAUI. The
    essence of DI is providing the class with its dependencies, irrespective of the
    method. Constructor injection is often preferred for clarity, but the technique
    that’s used might vary based on the platform and the design goals.
  prefs: []
  type: TYPE_NORMAL
- en: DI plays a crucial role in keeping our application’s components decoupled. Next,
    we’ll delve into another mechanism that promotes decoupling in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Messaging is a software architectural pattern that facilitates communication
    between different parts of an application. In the context of .NET MAUI and MVVM
    architecture, messaging is typically used to send notifications between loosely
    coupled components, such as between ViewModels, or from a Model to a ViewModel.
    This decouples the components and promotes a more modular and maintainable code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of messaging is especially useful when data needs to be passed or
    events need to be communicated between parts of your application that do not have
    a direct relationship. Instead of tightly coupling these parts by having them
    directly call each other, you can use a messaging system where one part sends
    a message that any interested part of your application can receive and react to.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is a form of the **Observer** pattern, where an object, named
    the **Subject**, maintains a list of its dependents, called **Observers**, and
    notifies them automatically of any state changes, typically by calling one of
    their methods. Similarly, in MVVM, messaging is used to communicate between decoupled
    components of the application: any object in your application, including a ViewModel,
    a service, or a model class or service can send a message, and any other class
    that is subscribed to that particular type of message will be notified and can
    react accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: About MessagingCenter
  prefs: []
  type: TYPE_NORMAL
- en: '`MessagingCenter`, originally introduced in Xamarin.Forms as a mechanism for
    loosely-coupled communication between components, is present but marked as obsolete
    in .NET MAUI. While it’s retained in .NET 8 for transition scenarios, its use
    is discouraged!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, in the context of MVVM, as shown in the following figure, the messaging
    system itself maintains a list of observers and handles passing messages from
    senders to appropriate receivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Messaging overview](img/B20941_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Messaging overview'
  prefs: []
  type: TYPE_NORMAL
- en: 'One notable challenge with the messaging pattern is its inherent opacity: it
    can be difficult to determine which parts of the application are subscribing to
    a particular message. This lack of transparency can lead to unforeseen side effects
    when altering the code and makes the code base more challenging to navigate and
    debug. When I do use messaging, I use it with caution. Keeping messages minimal
    and focused on a specific task can help mitigate this challenge. Another potential
    risk of using messaging is inadvertently causing memory leaks. This can occur
    when an object subscribes to a message but never unsubscribes. If this happens,
    the messaging system continues to hold a reference to the subscriber object, preventing
    it from being garbage collected even if there are no other references to it in
    the application. Over time, this can lead to increased memory usage and can eventually
    degrade the performance of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: This issue is particularly important in the context of MVVM, where ViewModels
    might subscribe to messages during their initialization and then get replaced
    by new ViewModels as the user navigates through the application. If these ViewModels
    don’t unsubscribe from the messages when they’re no longer in use, they will stay
    in memory indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: That’s where `WeakReferenceMessenger` comes in.
  prefs: []
  type: TYPE_NORMAL
- en: WeakReferenceMessenger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MVVM Toolkit, which we discussed earlier, provides us with a robust messenger
    implementation called `WeakReferenceMessenger`. Designed with MVVM applications
    in mind, this messenger ensures we can enjoy the benefits of messaging without
    worrying about potential memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a traditional messenger, which holds strong references to its subscribers,
    `WeakReferenceMessenger` holds weak references. This means it doesn’t prevent
    its subscribers from being garbage collected. So, even if you forget to unsubscribe,
    the garbage collector can still clean up your ViewModel when it’s no longer in
    use, preventing memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll be using `WeakReferenceMessenger` from the MVVM Toolkit
    as our messaging system. However, it’s important to note that other messaging
    systems are available as well. While we’re focusing on `WeakReferenceMessenger`,
    the core concepts we’ll be discussing here – such as sending and receiving messages
    – apply to most messaging systems. Always remember to study and understand the
    specific messaging system you’re working with to make the most of its features
    and avoid potential pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: '`WeakReferenceMessenger` uses a type-based messaging system. This means that
    when you send a message, you specify a message type and only the recipients that
    have subscribed to that specific type will receive the message. The message type
    is typically defined as a class, and the message data is stored as properties
    of that class.'
  prefs: []
  type: TYPE_NORMAL
- en: To send a message, you must use the `Send` method, passing in the message object
    and, optionally, a sender and target. The messenger will then deliver the message
    to all the registered recipients for the specified message type. To receive messages,
    a class needs to register with the messenger by calling the `Register` method,
    specifying the message type it wishes to receive, and providing a callback method
    that will be invoked when a message of that type is sent.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at how we can update our code and make it more loosely coupled
    by using `WeakReferenceMessenger`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the number of servings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Through messaging, ViewModels can communicate with each other in a loosely
    coupled manner. As an example, let’s take a look at `IngredientsListViewModel`.
    When updating the value of the `NumberOfServings` property, we loop through all
    elements in the `Ingredients` collection (which are `RecipeIngredientViewModel`
    objects) and call their `UpdateServings` method, passing in the updated value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is tightly coupled since the property knows about the implementation
    details of other objects, specifically `RecipeIngredientViewModel`. Also, it doesn’t
    adhere well to the **Single Responsibility Principle**: *the property doesn’t
    only concern itself; it is also responsible for updating the values of* *other
    properties.*'
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s introduce messaging here!
  prefs: []
  type: TYPE_NORMAL
- en: As `WeakReferenceMessenger` is a type-based messaging system, we must create
    a new type that we can send and subscribe to whenever the number of servings is
    being updated by the user. Right-click the `Messages`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right-click the `ServingsChangedMessage`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although `WeakReferenceMessenger` can send messages of any type, there are some
    base message classes you might want to inherit from. In this case, we could inherit
    from the generic `CommunityToolkit.Mvvm.Messaging.Messages.ValueChanged` class
    because that is exactly what `ServingsChangedMessage` is for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows the implementation of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now go ahead and update the `NumberOfServings` method on the `IngredientsListViewModel`
    class. Instead of looping over every item in the ingredients list and calling
    its `UpdateServings` method, we can now send `ServingsChangedMessage`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Sending a message is as easy as calling the `Send` method on an instance of
    `WeakReferenceMessenger`, passing the message you want to send.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to update `RecipeIngredientViewModel`. This class will need
    to subscribe to `ServingsChangedMessage` so that it can react to it. Registering
    to a type of message is done by calling the generic `Register` method on `WeakReferenceMessenger`.
    As a type parameter, you need to pass in the type of message you want to listen
    to. Here is one way to register to the `ServingsChangedMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter of the `Register` method is the recipient of the message,
    which in our case will be the class itself. The second parameter is the handler
    that gets invoked when the message is received. The first parameter of the handler
    is the receiver and the second one is the message itself. The passed-in receiver
    allows the Lambda expression to not capture `this`, which improves performance.
    It might also be a good idea to update the access modifier of the `UpdateServings`
    method to `private` as no public access to this method is needed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: With this updated implementation, the `NumberOfServings` property in `IngredientsListViewModel`
    no longer needs to know about the `RecipeIngredientViewModel` objects. Instead,
    it simply sends a message when its value changes. The `RecipeIngredientViewModel`
    objects, which are subscribed to these messages, can update their state accordingly.
    This decouples the two classes and ensures that each is only responsible for managing
    its own state, adhering to the single responsibility principle and separation
    of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we’ll have a look at the fact that messaging isn’t
    only valuable between ViewModels. A service might also send messages that ViewModels
    can respond to.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping favorites in sync
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the *Recipes!* app, the `RecipesOverviewPage` displays all recipes, and users
    can mark favorites on the `RecipeDetailPage`. However, without reloading `RecipesOverviewPage`,
    newly favorited recipes aren’t highlighted. Given that the recipes database isn’t
    frequently updated, constant page reloads would be overkill and could be bad for
    the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more efficient strategy involves using messaging. When a recipe is favorited,
    a message is dispatched. The individual `RecipeListItemViewModel`s contained within
    `RecipesOverviewViewModel` subscribe to this message, and upon receiving it, they
    update their favorite status in real time. This approach prevents unnecessary
    data fetches, thereby enhancing the app’s performance and responsiveness. Let’s
    see what we need to do to make this work:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s add a new message type. Right-click the `FavoriteUpdateMessage`
    as the class name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `FavoriteUpdateMessage` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class holds two properties, `RecipeId` and `IsFavorite`, so that with this
    message, we can signal which recipe has been marked or removed as a favorite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following code block shows how we can send this `FavoriteUpdateMessage`
    from the `FavoritesService` whenever a recipe is added as a favorite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, when a recipe is removed as a favorite, a `FavoriteUpdateMessage`
    can be sent, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step involves subscribing to this message in `RecipeListItemViewModel`.
    This ensures that when a `FavoriteUpdateMessage` arrives, the `IsFavorite` property
    can be updated accordingly. Unlike the previous example, where we defined a message
    handler using the `Register` method, we’ll use a different approach this time
    by implementing the `IRecipient` interface. Here’s how we can do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By implementing the `CommunityToolkit.Mvvm.Messaging.IRecipient<TMessage>` interface,
    where `TMessage` is `FavoriteUpdateMessage` in this case, we’re specifying the
    type of message we want to handle. Implementing this interface allows us to call
    the `Register` method of `WeakReferenceMessenger` and pass the class itself as
    the only parameter. The interface requires us to implement the `Receive` method,
    which is invoked when a message of the specified type is received.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Through the updated code, a message is dispatched whenever a user adds or removes
    a recipe as a favorite. Instances of `RecipeListItemViewModel` are set to listen
    for this message and update their `IsFavorite` property accordingly. As a result,
    when the user navigates back from a detail page, where the favorite status was
    updated, the refreshed status is immediately visible on the overview page – all
    without reloading any data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While `WeakReferenceMessenger` provides a robust solution for many messaging
    scenarios, it’s important to use it with caution when dealing with a large number
    of listeners. Always monitor the performance and behavior of your application,
    especially when dispatching messages to thousands of listeners, and consider optimizing
    or reevaluating your design if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we delved into two pivotal topics in the architecture of modern
    applications: DI and messaging. First, we explored DI, a technique for achieving
    loose coupling between objects and their dependencies. In the context of the MVVM
    pattern, we utilized this technique to inject services and other dependencies
    into our ViewModels, enhancing their testability and maintainability.'
  prefs: []
  type: TYPE_NORMAL
- en: The latter part of this chapter focused on messaging, another integral component
    in MVVM applications for promoting decoupled communication between components.
    We examined `WeakReferenceMessenger` provided by the MVVM Toolkit, which facilitates
    loose coupling in the application.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, this chapter aimed to reinforce the importance of loose coupling
    in software design, showcasing how both DI and messaging contribute significantly
    to the creation of maintainable and testable applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we’ll delve deep into the intricacies of navigation
    in .NET MAUI and how we can integrate navigation into our MVVM architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependency injection: [https://learn.microsoft.com/dotnet/architecture/maui/dependency-injection](https://learn.microsoft.com/dotnet/architecture/maui/dependency-injection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MVVM Toolkit messenger: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/messenger](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/messenger)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
