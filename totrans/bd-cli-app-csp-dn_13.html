<html><head></head><body>
		<div><h1 id="_idParaDest-216" class="chapter-number"><a id="_idTextAnchor220"/>13</h1>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor221"/>Security Considerations for CLI Applications</h1>
			<p>Security is <a id="_idIndexMarker498"/>one of the most critical concerns in any application development project. Itâ€™s interesting to see that, in many projects, development teams tend to think that because they implemented measures to prevent their applicationâ€™s code from being subject to SQL injection, XSS attacks, or similar, their application is secure.</p>
			<p>However, it is important to keep in mind that security takes different forms and spans different areas, which means that it does not only concern the security of the applicationâ€™s code or its usage but also extends to the security of the whole development lifecycle.</p>
			<p>In this chapter, we will discuss these different areas and how they are related to securing CLI applications, and we will cover the key areas that you need to consider in order to enhance the security of your CLI application and the security of your development lifecycle. More specifically, we will do the following:</p>
			<ul>
				<li>Discuss the different areas in which security should be considered</li>
				<li>Learn how to assess the security posture of a CLI application</li>
				<li>Learn how to implement authentication in order to secure access to user data</li>
			</ul>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor222"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this book, <a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter13">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter13</a></p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor223"/>Security areas</h1>
			<p>As <a id="_idIndexMarker499"/>mentioned earlier, security is not only limited to the applicationâ€™s code, nor can it only be achieved by implementing authentication, although these areas are very important.</p>
			<p>Letâ€™s first start by highlighting the key areas involved in securing an application throughout its lifecycle. It is important for me to make this point (or reminder) here as I still meet with customers who introduce security too late in the lifecycle of an application (typically after the application has been developed and released to production), expecting security professionals to do miracles and secure the application with minimal or no modification to the application, which is, obviously, unrealistic.</p>
			<p>Always keep in mind that security should span the entire lifecycle of the application. In concrete terms, security should be a concern from the early stages of designing the application:</p>
			<ul>
				<li><strong class="bold">In the design phase</strong>: It is important to define security<a id="_idIndexMarker500"/> requirements and objectives and to conduct threat modeling using methodologies such as STRIDE<a id="_idIndexMarker501"/> to identify potential security risks so we can incorporate the appropriate security controls into the initial design. STRIDE helps categorize threats into six groups: Spoofing, Tampering, Repudiation, Information disclosure, Denial of service, and Elevation of privilege. After identifying threats, we can use the DREAD model<a id="_idIndexMarker502"/> to quantitatively assess and prioritize them based on their Damage potential, Reproducibility, Exploitability, Affected users, and Discoverability. During this phase, we should also consider privacy and data protection measures, such as encryption, authentication, and authorization.</li>
				<li><strong class="bold">In the architecture phase</strong>: We are <a id="_idIndexMarker503"/>not only talking about the software architecture here but also about the infrastructure and networking architecture. Of course, we need to design a secure architecture that includes defense-in-depth strategies and integrates security mechanisms such as authentication and authorization. But we also need to plan for secure communication channels and data storage, using techniques such as encryption at rest and in transit along with network segmentation to ensure only appropriate routes of communication, through the appropriate network <a id="_idIndexMarker504"/>addresses, ports, and domains, and using appropriate protocols are allowed.</li>
				<li><strong class="bold">In the development phase</strong>: It is<a id="_idIndexMarker505"/> important to apply secure coding practices by relying on coding standards, such as implementing input validation and sanitization, and to ensure that our application is not vulnerable to common OWASP Top 10 security risks. It is equally important to ensure that secure coding practices are applied during code reviews. But this is not enough! You should use secure libraries and frameworks. In other words, ensure that your frameworks and libraries are still supported and receive security updates. Since we are using .NET 8 here, we know that it is still supported (and will receive security updates) until November 10, 2026 (Iâ€™m writing this in November 2024). As a framework or a library becomes unsupported, it is important to plan to migrate to a newer version (not necessarily the latest, by the way ðŸ˜‰).<p class="list-inset">Suppose our application communicates with external dependencies, such as web services. In that case, we have to ensure that these communications happen in a secure manner (by leveraging authentication and authorization) and using the appropriate protocols (such as HTTPS).</p></li>
				<li><strong class="bold">In the infrastructure configuration phase</strong>: All efforts to enhance the applicationâ€™s security could be in vain if<a id="_idIndexMarker506"/> the infrastructure on which it is running is unsecured. In the case of CLI applications, which run on the userâ€™s computer, this responsibility is delegated to them or their organizationâ€™s IT department, which usually controls employeesâ€™ workstations.</li>
				<li><strong class="bold">In the testing phase</strong>: Security-specific <a id="_idIndexMarker507"/>testing, including penetration testing and vulnerability assessments, should be performed during the testing phase to ensure user data cannot leak, user accounts cannot be compromised, and the application cannot be diverted from its intended usage toward malicious activities. Performing security testing allows us to validate that security requirements are met. Mature DevSecOps teams perform such testing on a regular basis. However, security tests should at least be performed before<a id="_idIndexMarker508"/> releasing an application to production.</li>
				<li><strong class="bold">In the deployment phase</strong>: Every <a id="_idIndexMarker509"/>DevSecOps engineer knows that your CI/CD pipelines can be a security threat if not properly secured. Secrets (such as passwords, API keys, service connections, connection strings, and so on) should be keptâ€¦ well, secret. Every CI/CD tool has its own secret management mechanism, which usually takes the form of a key vault, but we can also rely on external tools that are designed for such purposes, such as Azure Key Vault or HashiCorp Vault. Access to these secrets is usually restricted using roles and permissions.</li>
				<li><strong class="bold">While the application is being used</strong>: It is<a id="_idIndexMarker510"/> a common mistake for immature teams and organizations to believe that once the application has been released to production, the job of security is done. Wrong! This is where it all starts. You may argue that we put a lot of effort into securing the application before releasing it to our users, and you would be right. However, by releasing our application into the wild, it will experience a wide range of usage patterns and user environments, way beyond what we could have expected, thought of, and planned for. We will hence have to monitor for security incidents and anomalies, by implementing logging and auditing mechanisms and by regularly updating and patching the application and its dependencies.</li>
				<li><code>Destructure.ByMaskingProperties</code> method and pass a list of properties to be ignored <a id="_idIndexMarker513"/>when logging.</li>
				<li><strong class="bold">As new versions or bug fixes are released</strong>: Either when introducing new functionalities or<a id="_idIndexMarker514"/> fixing bugs, it is important to conduct a security impact analysis for the introduced changes. This can be done by performing regression testing to ensure existing security controls are still met and no vulnerability has been introduced.</li>
			</ul>
			<p>Fortunately, there is a variety of tools to help at every stage. If your team or organization has adopted a DevSecOps culture, you will already be aware of many of these tools.</p>
			<p>DevSecOps<a id="_idIndexMarker515"/> being way beyond the scope of this book, we will not be discussing the broad spectrum of tools you may use at every step. However, I do want to cover tools that will help us assess and enhance the security posture of a CLI application.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor224"/>Assessing the security posture of a CLI application</h1>
			<p>There are <a id="_idIndexMarker516"/>multiple tools that help assess the security posture of an application (including a CLI application). Among the most widely used ones, we find the following:</p>
			<ul>
				<li><code>.csproj</code> files to detect vulnerabilities in third-party libraries.</li>
				<li><strong class="bold">Snyk</strong>: This popular tool <a id="_idIndexMarker519"/>offers vulnerability reporting and scanning for .NET projects. It can be integrated into local development environments as well as into CI/CD pipelines for continuous monitoring.</li>
				<li><strong class="bold">Mend Bolt</strong>: Previously<a id="_idIndexMarker520"/> known as <strong class="bold">WhiteSource Bolt</strong>, this security scanning <a id="_idIndexMarker521"/>tool<a id="_idIndexMarker522"/> integrates<a id="_idIndexMarker523"/> with <strong class="bold">Azure DevOps</strong> or <strong class="bold">GitHub</strong> pipelines, scanning .NET projects for open source vulnerabilities and generating detailed reports.</li>
				<li><strong class="bold">OWASP Dependency-Check</strong>: This<a id="_idIndexMarker524"/> tool is effective for scanning third-party libraries and dependencies, which is crucial for .NET applications that often rely on external packages.</li>
				<li><strong class="bold">GitHub Advanced Security</strong>: This<a id="_idIndexMarker525"/> tool integrates security features directly into GitHub or Azure DevOps workflows, performs code scanning (it uses static analysis to detect potential security vulnerabilities and coding errors) and secret scanning (it recognizes patterns for passwords, API keys, and other secrets and detects whether they are stored in clear text in the repository), and performs dependency reviews and highlights vulnerable <a id="_idIndexMarker526"/>ones.</li>
			</ul>
			<p>These tools have in<a id="_idIndexMarker527"/> common that they inform us about the vulnerable library, and give us detailed information about the vulnerability itself and the recommended fix for it.</p>
			<p>These tools are either free (such as Mend Bolt and OWASP Dependency-Check) or offer a free plan but with limited functionality (such as SonarQube, Snyk, and GitHub Advanced Security).</p>
			<p>They also vary in the level of complexity and effort required to set up and configure them. Hence, you will find SonarQube to be the most complex to set up, Snyk to be moderately easy to set up, and Mend Bolt, OWASP Dependency-Checker, and GitHub Advanced Security to be the easiest ones to set up.</p>
			<p>I would recommend Mend Bolt<a id="_idIndexMarker528"/> as a good starting point since it comes as an Azure DevOps or GitHub free extension that can be obtained from their respective marketplaces. For these reasons, these tools are usually intended for organizations or larger teams.</p>
			<p>However, the good news is that .NET already provides us with an out-of-the-box tool to serve this very purpose of assessing and enhancing the security posture of our application.</p>
			<p>This tool, commonly <a id="_idIndexMarker529"/>known as dotnet-audit, focuses<a id="_idIndexMarker530"/> on detecting vulnerabilities in .NET project dependencies (namely, <code>NuGet</code> packages) by relying on the <code>GitHub Advisory Database</code>. For .NET-only projects, such<a id="_idIndexMarker531"/> as <strong class="bold">Bookmarkr</strong>, this tool is the perfect starting point!</p>
			<p>To execute this tool, we simply need to type the following command:</p>
			<pre class="console">
dotnet list package --vulnerable</pre>			<p>The results will be shown in the terminal window, and will look like this:</p>
			<div><div><img src="img/B22400_13_01.jpg" alt="Figure 13.1 â€“ Listing vulnerable packages"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 â€“ Listing vulnerable packages</p>
			<p>As you may have noticed in this figure, the command has not been executed on Bookmarkrâ€™s code but rather for another application. As it turns out, we are glad that no vulnerability has been detected for Bookmarkr (yeah!), but this might change over time as vulnerabilities in referenced libraries are detected.</p>
			<div><div><img src="img/B22400_13_02.jpg" alt="Figure 13.2 â€“ No vulnerable packages for Bookmarkr"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 â€“ No vulnerable packages for Bookmarkr</p>
			<p>Keep in mind that this command may ask you to<a id="_idIndexMarker532"/> run <code>dotnet restore</code> before you can execute it. This is especially true if this is the first time you have cloned the Git repository.</p>
			<p>There is another <a id="_idIndexMarker533"/>command that does not directly scan for vulnerabilities, but which I recommend. This command lists outdated packages. While these packages might not have known vulnerabilities, being outdated means that they will no longer receive security updates. My recommendation is that you consider upgrading these packages to newer supported versions (once again, not necessarily the latest version if this introduces breaking changes).</p>
			<p>To run this command, simply type the following:</p>
			<pre class="console">
dotnet list package --outdated</pre>			<p>As you can see from the result of executing this command, although no vulnerability has been detected in Bookmarkrâ€™s dependencies, some of them are outdated:</p>
			<div><div><img src="img/B22400_13_03.jpg" alt="Figure 13.3 â€“ Listing outdated packages"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 â€“ Listing outdated packages</p>
			<p>The appropriate way to upgrade these packages is to create a new branch, update the packages, test the application (both using manual and automated testing, as described in <a href="B22400_10.xhtml#_idTextAnchor155"><em class="italic">Chapter 10</em></a>) to ensure that the application still works as expected and that we did not introduce regressions, and finally, issue a pull request to merge the modifications into the <code>main</code> branch.</p>
			<p>We now have the necessary knowledge and tools to assess, and ultimately enhance, the security posture of our CLI application. Letâ€™s focus our attention on securing communication between our CLI application and the external services it interacts with, to protect against <a id="_idIndexMarker534"/>unauthorized access and ensure proper user management. This can be achieved through authentication.</p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor225"/>Securing remote communications using authentication</h1>
			<p>In <a href="B22400_09.xhtml#_idTextAnchor136"><em class="italic">Chapter 9</em></a>, we introduced the <code>sync</code> command, which <a id="_idIndexMarker535"/>allows Bookmarkr to back up local bookmarks to a remote location and retrieve them when needed. When doing so, the command also synchronizes local and remote bookmarks.</p>
			<p>Until now, the communication between the local CLI application and the remote external service has happened in an insecure manner. This means that anyone who invokes the <code>sync</code> command may retrieve your personal bookmarks, which you clearly donâ€™t want, do you?</p>
			<p>To address this issue, we need to implement authentication.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor226"/>Why is authentication important?</h2>
			<p>You may be wondering why authentication<a id="_idIndexMarker536"/> should be required in the context of CLI applications. After all, a CLI application runs on the userâ€™s computer, which already requires that user to authenticate to their session.</p>
			<p>In the context of CLI applications, authentication is usually required when communicating with external services (i.e., sending data to and retrieving data from these services). This ensures that users have access to their data at the remote location by proving who they are.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor227"/>How to perform authentication</h2>
			<p>Authentication <a id="_idIndexMarker537"/>can be achieved in many ways. One of the most common ones is for the external service provider to provide you with <a id="_idIndexMarker538"/>a <strong class="bold">Personal Access Token</strong> (<strong class="bold">PAT</strong>). You can usually get or generate such tokens by visiting the service providerâ€™s website and logging in to your account. From there, on your accountâ€™s settings page, you should be able to get that token or to generate a new one. Such tokens are usually valid for a given period of time and expire after that.</p>
			<p>Once you have this token, you can pass it as a parameter to a command that performs the call to the external service. An example of this would be the <code>sync</code> command, which could be invoked as follows:</p>
			<pre class="console">
bookmarkr sync --pat YOUR_PAT</pre>			<p>Here, <code>YOUR_PAT</code> is most commonly a GUID value.</p>
			<p>This call would then authenticate the user using the received PAT value before performing the sync operation.</p>
			<p>As you may have noticed, this approach could quickly become tedious as it is not easy to remember the value of a <a id="_idIndexMarker539"/>PAT. For this reason, CLI applications usually store such values either in a local configuration file, in an environment variable, or in the operating systemâ€™s key vault. This allows the user to invoke the command without always having to pass the PAT as a parameter. The command will be smart enough to look for it in the local configuration file or in the<a id="_idIndexMarker540"/> environment variable and use it if it is present. If it is not present, the command should display an error message asking the user to provide it. If the PAT is invalid or expired, the command should also be able to inform the user about that.</p>
			<p>This is the approach adopted by GitHub â€“ for example: you create a PAT within your GitHub account, which you can use to authenticate and access GitHub resources from external services or applications. In our use case, the external service is the one that provides and manages the tokens, whereas the CLI application is only responsible for sending these tokens to the external service.</p>
			<p>Another commonly used <a id="_idIndexMarker541"/>approach is to authenticate the user against an <code>auth</code>). Invoking this command usually triggers the default web browser and redirects the user to the application providerâ€™s login page. After successful authentication, the IdP provides access and an ID token that the CLI can use for subsequent requests to the external service. These tokens are, as for the PAT, usually included in the HTTP headers when performing the requests to the external service. This approach leverages the <code>OAuth 2.0</code> and the <code>OpenID </code><code>Connect</code> protocols.</p>
			<p>In the remainder of this chapter, we will explore how to implement authentication for Bookmarkr to secure communications with the <strong class="bold">BookmarkrSyncr</strong> external service.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor228"/>Implementing authentication</h1>
			<p>Here, we will leverage the PAT<a id="_idIndexMarker542"/> approach as it is more convenient and can work even in environments where no web browser can be launched, such as CI/CD pipelines.</p>
			<p>To illustrate how this could be achieved, we will need to implement functionalities at two levels:</p>
			<ul>
				<li><strong class="bold">BookmarkrSyncr</strong>: The<a id="_idIndexMarker543"/> external service will receive the PAT, validate it, and authenticate the user if it is valid</li>
				<li><strong class="bold">Bookmarkr</strong>: The <a id="_idIndexMarker544"/>responsibility of the CLI application is to pass the token to the external service and act according to the response it gets from the sent request</li>
			</ul>
			<p>Letâ€™s start by adding the required functionality into BookmarkrSyncr.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor229"/>Authenticating external services using a PAT</h2>
			<p>To<a id="_idIndexMarker545"/> make things simple, we will assume that BookmarkrSyncr (the code for which can be found in the <code>AppendixB</code> folder) holds two PAT tokens: a valid one and an expired one. All other values that the user passes will be considered invalid and will be rejected for this reason.</p>
			<p>The token validation service will also be a very basic one.</p>
			<p>While most of the code remains as it was, we had to make the following changes to the parameters we pass to the <code>MapPost</code> method:</p>
			<pre class="source-code">
app.MapPost("/sync", async ([FromHeader(Name = "X-PAT")] string pat, List&lt;Bookmark&gt; bookmarks, ITokenValidator tokenValidator, HttpContext context) =&gt;
{
Â Â Â Â Â â€¦
}</pre>			<p>Letâ€™s explain these changes:</p>
			<ol>
				<li>We indicate that the value of the PAT token comes from an HTTP header named <code>X-PAT</code> and that this value will be stored in the input parameter named <code>pat</code>.</li>
				<li>We pass a parameter of type <code>ITokenValidator</code>, which is a service we have created to retrieve and validate PAT tokens.</li>
				<li>We pass the current HTTP context that we will need to set HTTP headers for the HTTP response, especially to notify the client that the received PAT token is either invalid or expired. We use a different response header to ensure that the client knows exactly why the request was unauthorized, as this is good programming practice.</li>
			</ol>
			<p>We then invoke <a id="_idIndexMarker546"/>methods of the <code>TokenValidator</code> service to check whether the PAT token is invalid or expired, and if so, we set the appropriate HTTP header in the response object. The code looks like this:</p>
			<pre class="source-code">
// Ensure the Personal Access Token (PAT) is valid
if (!tokenValidator.IsValid(pat))
{
Â Â Â Â context!.Response.Headers["X-Invalid-PAT"] = pat;
Â Â Â Â return Results.Unauthorized();
}
// Ensure the Personal Access Token (PAT) is not expired
if (tokenValidator.IsExpired(pat))
{
Â Â Â Â context!.Response.Headers["X-Expired-PAT"] = pat;
Â Â Â Â return Results.Unauthorized();
}</pre>			<p>Notice how <a id="_idIndexMarker547"/>we set the HTTP header. We use the indexer syntax. This will set the header. If the header already exists, it will replace the existing value with the new one.</p>
			<p>The last thing we need to do is to register the <code>TokenValidator</code> service. This can be done for any service, using this widely known syntax:</p>
			<pre class="source-code">
builder.Services.AddScoped&lt;ITokenValidator, TokenValidator&gt;();</pre>			<p>The <code>TokenValidator</code> service is very basic and its code looks as follows:</p>
			<pre class="source-code">
public class TokenValidator : ITokenValidator
{
Â Â Â Â private readonly List&lt;PatToken&gt; _tokens = new();
Â Â Â Â public TokenValidator()
Â Â Â Â {
Â Â Â Â Â Â Â Â // we are simulating a token store here...
Â Â Â Â Â Â Â Â _tokens.Add(new PatToken { Value = "4de3b2b9-afaf-406c-ab0d-
Â Â Â Â Â Â Â Â d59ac534411d", IsExpired = false });
Â Â Â Â Â Â Â Â _tokens.Add(new PatToken { Value = "16652977-c654-431e-8f84-
Â Â Â Â Â Â Â Â bd53b4ccd47d", IsExpired = true });
Â Â Â Â }
Â Â Â Â public bool IsExpired(string token)
Â Â Â Â {
Â Â Â Â Â Â Â Â var retrievedToken = _tokens.FirstOrDefault(t =&gt; t.Value.
Â Â Â Â Â Â Â Â Equals(token, StringComparison.OrdinalIgnoreCase));
Â Â Â Â Â Â Â Â if(retrievedToken == null) return false;
Â Â Â Â Â Â Â Â return retrievedToken.IsExpired;
Â Â Â Â }
Â Â Â Â public bool IsValid(string token)
Â Â Â Â {
Â Â Â Â Â Â Â Â var retrievedToken = _tokens.FirstOrDefault(t =&gt; t.Value.
Â Â Â Â Â Â Â Â Equals(token, StringComparison.OrdinalIgnoreCase));
Â Â Â Â Â Â Â Â return retrievedToken != null;
Â Â Â Â }
}</pre>			<p>The only thing worth mentioning here is that we are simulating a token store (in the classâ€™s constructor). In a real-world scenario, we would have a persistent token store (such as a database). But for the purposes of this demonstration, storing these PAT tokens in memory makes the code easier to understand. I also want you to notice that, for the purpose of the demonstration, we have two tokens: one is a valid token, and the other represents an expired token. Any other value will be considered invalid since it cannot be found in the<a id="_idIndexMarker548"/> token store (which is realistic, by the way ðŸ˜‰). The client (the CLI application) will hence behave differently depending on the validity of the token.</p>
			<p>Excellent! Now that we have our external service ready, itâ€™s time to update the client so that it can pass the PAT.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor230"/>Passing the PAT from the CLI application to the external service</h2>
			<p>For <a id="_idIndexMarker549"/>this to happen, we will need to modify the code of both the <code>sync</code> command and the service agent.</p>
			<p>More specifically, we will need to do the following:</p>
			<ol>
				<li>Add a <code>--pat</code> parameter to the <code>sync</code> command.</li>
				<li>Modify the request that the HTTP client makes to the external service so that it sends the PAT token.</li>
				<li>Modify the code to store the PAT token in an environment variable and retrieve it from there if the <code>--pat</code> parameter is not specified when invoking the <code>sync</code> command.</li>
			</ol>
			<p>Letâ€™s start with the first step.</p>
			<p>Letâ€™s go to the <code>SyncCommand.cs</code> file and, in the <code>Options</code> region, letâ€™s add an <code>Option</code> for the PAT as follows:</p>
			<pre class="source-code">
private Option&lt;string&gt; patOption = new Option&lt;string&gt;(
Â Â Â Â ["--pat", "-p"],
Â Â Â Â "The PAT used to authenticate to BookmarkrSyncr"
);</pre>			<p>This <code>Option</code> is optional, as we mentioned earlier.</p>
			<p>Next, we need to <a id="_idIndexMarker550"/>make the command use this <code>Option</code>. For that matter, we need to add this instruction to the classâ€™s constructor:</p>
			<pre class="source-code">
AddOption(patOption);</pre>			<p>Now, letâ€™s modify the commandâ€™s handler method so that the HTTP client can send the PAT to the BookmarkrSyncr service. For that matter, we need to modify the handler methodâ€™s signature to pass the PAT as a parameter, as follows:</p>
			<pre class="source-code">
private async Task OnSyncCommand(string patValue)
{
Â Â Â Â ...
}</pre>			<p>Back to the classâ€™s constructor again, we need to modify the call to the <code>SetHandler</code> method to pass the PAT Option as a parameter. The modified method call looks like this:</p>
			<pre class="source-code">
this.SetHandler(OnSyncCommand, patOption);</pre>			<p>Next, we need to pass this token to the service agent. For that matter, we first need to modify the call to the service agent in the handler method, as follows:</p>
			<pre class="source-code">
var mergedBookmarks = await _serviceAgent.Sync(patValue, retrievedBookmarks);</pre>			<p>Then, we need to update the code of the <code>BookmarkrSyncrServiceAgent</code> class to ensure the presence of the token before calling the external service.</p>
			<p>The first thing we need to do is, obviously, pass the PAT value as a parameter to its <code>Sync</code> method, as follows:</p>
			<pre class="source-code">
public async Task&lt;List&lt;Bookmark&gt;&gt; Sync(string pat, List&lt;Bookmark&gt; localBookmarks)</pre>			<p>After that, the first thing the method should do is to ensure the presence of the PAT (i.e., ensure that we are not sending a null or an empty value to the external service). We do this by adding<a id="_idIndexMarker551"/> the following code at the beginning of the method:</p>
			<pre class="source-code">
// ensure that the pat is present
if(string.IsNullOrWhiteSpace(pat))
{
Â Â Â Â string? value = Environment.GetEnvironmentVariable("BOOKMARKR_
Â Â Â Â PAT");
Â Â Â Â if(value == null) throw new PatNotFoundException(pat);
Â Â Â Â pat = value;
}</pre>			<p>A few things to note here:</p>
			<ul>
				<li>We do not validate the token, nor do we check whether it is expired. This is the role of the BookmarkrSyncr external service.</li>
				<li>The environment variable that is used to hold the PAT token is named <code>BOOKMARKR_PAT</code>. This name ensures that this variable does not conflict with any other variable set on the userâ€™s computer.</li>
				<li>We have created a custom exception class, <code>PatNotFoundException</code>, to inform the client in case the PAT token has not been found.</li>
			</ul>
			<p>Now, since the PAT token is retrieved, we need to send it to the external service. We hence need to modify the HTTP client to pass the token in the HTTP headers of the request, as follows:</p>
			<pre class="source-code">
var client = _clientFactory.CreateClient("bookmarkrSyncr");
// Add the PAT to the request header
client.DefaultRequestHeaders.Add("X-PAT", pat);
var response = await client.PostAsync("sync", content);</pre>			<p>If the request to the external service is successful, we know that the PAT token is valid. We will then save it to the environment variable if it is not already present there. The updated code is <a id="_idIndexMarker552"/>therefore as follows:</p>
			<pre class="source-code">
if (response.IsSuccessStatusCode)
{
Â Â Â Â // saving the PAT to the environment variable, if not already
Â Â Â Â string? value = Environment.GetEnvironmentVariable("BOOKMARKR_
Â Â Â Â PAT");
Â Â Â Â if(value == null || !value.Equals(pat)) Environment.
Â Â Â Â SetEnvironmentVariable("BOOKMARKR_PAT", pat);
Â Â Â Â // remaining of the code
}</pre>			<p>However, if the PAT token is invalid or expired, we need to inform the client so that the proper error message is displayed to the user. We therefore need to modify the code block that handles the <code>Unauthorized</code> status code, as follows:</p>
			<pre class="source-code">
switch(response.StatusCode)
{
Â Â Â Â case HttpStatusCode.Unauthorized:
Â Â Â Â Â Â Â Â if (response.Headers.TryGetValues("X-Invalid-PAT", out var 
Â Â Â Â Â Â Â Â headerValues))
Â Â Â Â Â Â Â Â Â Â Â Â throw new PatInvalidException(pat);
Â Â Â Â Â Â Â Â if (response.Headers.TryGetValues("X-Expired-PAT", out var 
Â Â Â Â Â Â Â Â headerValues2))
Â Â Â Â Â Â Â Â Â Â Â Â throw new PatExpiredException(pat);
Â Â Â Â Â Â Â Â throw new HttpRequestException($"Unauthorized access: 
Â Â Â Â Â Â Â Â {response.StatusCode}");
Â Â Â Â // remaining of the code
}</pre>			<p>This code is straightforward and easy to understand. One thing worth mentioning though is that here, again, we created custom exception classes, namely <code>PatInvalidException</code> and <code>PatExpiredException</code>, to clearly express the intent of an error when raising them. These exception classes can be found in the <code>Exceptions.cs</code> file located in the <code>BookmarkrSyncrServiceAgent</code> folder.</p>
			<p>The last step is to go back to the <code>SyncCommand</code> class, handle the responses from the service agent, and display the appropriate error messages to the user. For that matter, we need to modify<a id="_idIndexMarker553"/> the code of the <code>OnSyncCommand</code> handler method to catch the custom exceptions described previoulsy. The <code>catch</code> blocks are as follows:</p>
			<pre class="source-code">
catch(PatNotFoundException ex)
{
Â Â Â Â Helper.ShowErrorMessage([$"The provided PAT value ({ex.Pat}) was 
Â Â Â Â not found."]);
}
catch(PatInvalidException ex)
{
Â Â Â Â Helper.ShowErrorMessage([$"The provided PAT value ({ex.Pat}) is 
Â Â Â Â invalid."]);
}
catch(PatExpiredException ex)
{
Â Â Â Â Helper.ShowErrorMessage([$"The provided PAT value ({ex.Pat}) is 
Â Â Â Â expired."]);
}</pre>			<p>And thatâ€™s it â€“ we have completed all the required code modifications for Bookmarkr to ensure secure communication with the external service, BookmarkrSyncr, by using a PAT (it was about time, right? ðŸ˜‰).</p>
			<p>Letâ€™s see if this works!</p>
			<p>The first test is to invoke the <code>sync</code> command without passing a PAT token. Knowing that it will not be <a id="_idIndexMarker554"/>found in the <code>BOOKMARKR_PAT</code> environment variable, the following error is expected:</p>
			<div><div><img src="img/B22400_13_04.jpg" alt="Figure 13.4 â€“ The PAT token was not found"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 â€“ The PAT token was not found</p>
			<p>The second test is to invoke the <code>sync</code> command with an invalid PAT token. Here too, an error message is expected:</p>
			<div><div><img src="img/B22400_13_05.jpg" alt="Figure 13.5 â€“ The PAT token is invalid"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 â€“ The PAT token is invalid</p>
			<p>The next test is<a id="_idIndexMarker555"/> to invoke the <code>sync</code> command with an expired PAT token. Here too, an error message is expected:</p>
			<div><div><img src="img/B22400_13_06.jpg" alt="Figure 13.6 â€“ The PAT token is expired"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 â€“ The PAT token is expired</p>
			<p>The final test is to invoke the <code>sync</code> command with a valid PAT token. We can see that the bookmarks have been synchronized and that the PAT token has been saved to the <code>BOOKMARKR_PAT</code> environment variable:</p>
			<div><div><img src="img/B22400_13_07.jpg" alt="Figure 13.7 â€“ The PAT token is valid"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 â€“ The PAT token is valid</p>
			<p>Wonderful! We now know all we need to know to assess and enhance the security of our CLI applications.</p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor231"/>Summary</h1>
			<p>In this chapter, we explored the various forms security can take, and we learned that it is not limited to the security of the applicationâ€™s code but rather covers a broad spectrum of areas that span its entire lifecycle. We learned what tools and techniques we can use to assess and enhance the security posture of our CLI application. We also learned how to secure access to user data, especially when dealing with external services, by implementing authentication and authorization.</p>
			<p>Congratulations! You have now all the necessary knowledge and skills to build, secure, test, package, and release your very own CLI applications to the world. Look at you â€“ what a milestone you have achieved. Take a moment to be proud of yourself and to celebrate!</p>
			<p>My journey with you, throughout the pages of this book, is almost over. But before you turn the last page and gently close the cover of this book, there is one last thing I wanted to share with you, one final chapter whose purpose is to provide you with additional learning material to help you continue your journey as well as pointing you to some useful tools and libraries.</p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor232"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn through practice.</p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to improve the Bookmarkr application by adding the following features.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor233"/>Task #1 â€“ Update dependency versions</h2>
			<p>We have seen how to list outdated packages that have reached their end of support and talked about the importance of updating these. However, I havenâ€™t updated these.</p>
			<p>Your task is to clone the code into your GitHub or Azure DevOps account and to update it.</p>
			<p>Once the dependencies have been updated, you will need to validate that the behavior of the application was not impacted, in other words, you need to ensure that the application still behaves as expected. This can be done by running the tests you developed earlier.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor234"/>Task #2 â€“ Use Mend Bolt to scan the code for vulnerabilities</h2>
			<p>Your task is to clone the code into your GitHub or Azure DevOps account, enable Mend Bolt, and run a security scan. If any vulnerability is to be found, fix it!</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor235"/>Task #3 â€“ Allow BookmarkrSyncr to manage multiple users</h2>
			<p>Although we updated BookmarkrSyncr to receive and validate a PAT, it does not use this token to retrieve and update the appropriate userâ€™s data.</p>
			<p>You are tasked to update the code to make this happen. The easiest way to achieve this is to have a separate JSON file for every user whose name matches the value of the PAT. Hence, the bookmarks for every user can be stored and retrieved from there.</p>
		</div>
	</body></html>