- en: Object Lifetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object Lifetime is the time duration between an object's creation and destruction.
    In Functional Programming Languages, data stored in constant variables have a
    scope defined which is immutable in nature. This means that their lifetimes have
    a functional scope (no destruction) as long as the app is not stopped. On the
    other hand, the objects in Object Oriented Programming are mutable and have different
    types of scope which leads to different lifestyles.
  prefs: []
  type: TYPE_NORMAL
- en: Memory plays a vital role in application life cycle. All objects and variables
    use memory space. Therefore, it is important to learn the concepts which deal
    with an object's flow during application execution. Unless we know how to free
    up space by using proper codes or patterns, it would result in **Memory Leaks**.
  prefs: []
  type: TYPE_NORMAL
- en: If a computer program exposes bugs and erroneously manages the memory allocations,
    then resources become unavailable. This condition is called Memory Leaks.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid Memory Leaks, we should take proper care while designing our classes,
    so that the resources are available when needed. That would only happen if and
    only if resources attached to objects are released by the program as soon as objects
    go out of scope. Thus, the app runs seamlessly as unused space is regularly cleared.
    However, this process is not automatic in all scenarios. The reason, we are going
    to explore this topic, is to understand how exactly the DI technique manages the
    lifetime of objects differently in different scenarios, which in return helps
    us take appropriate decisions while designing our classes.
  prefs: []
  type: TYPE_NORMAL
- en: An object is born when it's related class is instantiated. The newly born object
    stays around for a limited period of time as long as the application keeps a reference
    of that and continues to use that. If your application is closed or the reference
    of the object goes out of scope in the code, then .NET Framework will flag that
    object to be removed from memory.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular chapter, we will learn how objects are managed by .NET Core.
    Also, we will look into techniques to determine when an object is disposable and
    how to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics we will cover in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Managed and unmanaged resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object's creation and destruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IDisposal` interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object lifetime management in .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage the object life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two basic places in the memory--stack and heap.
  prefs: []
  type: TYPE_NORMAL
- en: Stack versus heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's learn a little bit about these memory space types.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Stack** | **Heap** |'
  prefs: []
  type: TYPE_TB
- en: '| Static memory: Fixed memory space allocated for the app. | Dynamic memory:
    No fixed space. |'
  prefs: []
  type: TYPE_TB
- en: '| When a method is called, a chunk of stack is reserved to store the method''s
    information like a method name, local variables, return type, and so on. | Can
    store anything. The developer has the flexibility to manage this space. |'
  prefs: []
  type: TYPE_TB
- en: '| Memory allocation has a pattern in **LIFO** (**Last In First Out**) order.
    So, when the `Main` function calls method `A()` and then `A()` calls `B()`, `B()`
    will be stored at the top and executes first. Refer to the following diagram:
    | No such pattern to store data. |'
  prefs: []
  type: TYPE_TB
- en: 'The following diagram shows how the data gets stored in stack and heap for
    one program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dff1fbbb-ae31-446a-87ba-1c011ddfec81.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Main()` calls `A()` which then calls `B()` method. According to stack properties,
    it first moves the last one out, which is `B()`. So, `B()` executes first. Then `B()` is
    removed from the stack and then `A()` is processed and removed from memory. After
    that, the `Main()` method executes and removed. The reference type variable named
    as `foo` inside `Main()` is stored in stack, but the actual object is allocated
    memory in heap.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The variable `name` is a value type, which is directly stored on the stack.
    But, when we write `SomeClass sc = new SomeClass()`, it actually tells the framework
    to store the object in heap. In addition to this, it also allocates a memory space
    for a variable `sc` in the stack, which holds the reference to this object.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when the `Main` method execution is completed, the variables `name` and
    `sc` will be released and memory space becomes free. Here is the catch though.
    The variable `sc` (reference type) is released from the stack, but the actual
    object is still on the heap. It's just the reference, which is removed. As the
    reference is removed from the stack, so there is no way to actually know if there
    is an object existing on the heap., related to it. We have ended up with a management
    problem now.
  prefs: []
  type: TYPE_NORMAL
- en: To get rid of this (in C++), we could have done something like this `delete
    sc;`. However, in C#, which is a managed language, there is a service known as
    **Garbage Collector** (**GC**), which automatically cleans up the unused memory
    by analyzing all those flagged *out of scoped* objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Managed Language** is a high-level language that depends on services provided
    by a runtime environment to execute, such as Garbage Collection service, Security
    Service, Exception Handling, and more. It uses Common Language Runtime (CLR) to
    execute in .Net languages or **Java Virtual Machine** (**JVM**) in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: Managed and unmanaged resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure .NET code is called **managed resources** as that can be directly managed
    by the runtime environment. On the other hand, unmanaged resources are those that
    are not in direct control of the runtime such as, file handles, COM objects, database
    connections, and so on. For example, if you open a connection to a database server
    this will use resources on the server (for maintaining the connection) and possibly
    other non .NET resources.
  prefs: []
  type: TYPE_NORMAL
- en: The managed resources are targeted directly by CLR, therefore, Garbage Collector
    cleans them up, which is an automatic process. As a developer, you don't usually
    need to explicitly call GC. However, there is a catch, when we consider the unmanaged
    resources like database connections. We have to deal with them ourselves as the
    CLR can't. We have to release them manually using the `Finalize` method.
  prefs: []
  type: TYPE_NORMAL
- en: Generations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heap is categorized into three generations so it can handle long-lived and
    short-lived objects. Garbage collection basically reclaims short-lived objects
    that typically occupy only a small part of the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are the following three generations of objects on the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generation 0**: When an object is initialized, it''s generation gets started.
    It first falls into Generation 0\. This generation''s objects are usually short-lived.
    These objects are more prone to GC for destruction. GC collects these short-lived
    objects so that they can be released to free up memory space. If the objects survive
    from being collected by GC, that means they are going to stay for a longer time,
    thereby being promoted to the next generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generation 1**: This generation objects live for a longer duration than Generation
    0 objects. GC does collect the objects from this generation, but not so regularly
    as it does for Generation 0 because their existence is extended by the application
    for more operations. Survivors of this generation go to Generation 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generation 2**: These are the longest existing objects in the application.
    Prolonged objects which successfully pass through the previous two generations
    are automatically considered for Generation 2\. GC rarely comes into the picture
    when it comes to releasing these objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constructors are responsible for giving birth to the object of a particular
    class. If we create any class without a constructor, the compiler will automatically
    create a one default constructor for that class. At least one constructor is present
    in every class.
  prefs: []
  type: TYPE_NORMAL
- en: The constructors can be overloaded too which provide a convenient way to build
    the object with different attributes, meaning, it can instantiate the object by
    taking certain parameters (like a normal method) and assign them to its properties
    inside its body (also called as a parameterized constructor). A constructor should
    have the same name as the class name.
  prefs: []
  type: TYPE_NORMAL
- en: The Copy constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another type of constructor called the **Copy constructor**. As the
    name suggests, it can copy one object to the new object (of the same class) which
    is going to be instantiated. In other words, it is a parameterized constructor
    that contains a parameter of same class type. The main purpose of a copy constructor
    is to initialize a new instance to the values of an existing instance. We will
    see how this can be done with an example in a while.
  prefs: []
  type: TYPE_NORMAL
- en: Object destruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have different ways to destroy an object. Let's explore them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Finalize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finalizers are used to destroy the objects. We can design Finalizers using
    destructor methods using the tilde (`~`) sign with the class name. We will see
    it in action soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Garbage Collector has full control on the finalization process as it internally
    calls this method when objects go out of scope. We can, however, write codes inside
    the destructor to customize our requirements, but we can't just say to someone
    to call the destructor. Even if you are very sure that the object is not required
    anymore and decide to release it, you can't explicitly execute destructor in order
    to free up space. You have to wait until GC collects the object for destruction.
  prefs: []
  type: TYPE_NORMAL
- en: The finalization process has two collection cycles. In the first cycle, short-lived
    objects are flagged for finalization. In the next cycle, it calls the finalizers
    to release them completely from memory space.
  prefs: []
  type: TYPE_NORMAL
- en: The IDisposable interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unmanaged resources, as we discussed, are not in direct control of the framework.
    We can easily reclaim these resources inside Finalizers, as we discussed. That
    means, they will be released when the objects are destroyed by the garbage collector.
    However, the GC destroys the objects only when the CLR demands more free memory.
    So, resources may still exist even long even after the object goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, there is a need to free up resources as soon as we are done with them.
    Your classes can provide a mechanism to actively manage system resources if they
    implement the `IDisposable` interface. This interface exposes one method, `Dispose()`,
    which clients should call when they finish using an object. You can use the `Dispose`
    method to immediately release resources to perform tasks such as closing files
    and database connections etc. Unlike the `Finalize` destructor, the `Dispose`
    method is not called automatically. Objects must explicitly call `Dispose` when
    they want to release the resources.
  prefs: []
  type: TYPE_NORMAL
- en: This method is the single method in an `IDisposable` interface and can be used
    to release unmanaged resources manually.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now it's just a matter of calling the `Dispose()`. But wait. You can only call
    this method from an object of a class which have implemented this interface and
    defined the `Dispose()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `SqlConnection` class has implemented this interface and provided
    us with the `Dispose()` method, which can be used as follows. As soon as you are
    finished using the connection object, call `Dispose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another beautiful way to deal with the disposal of objects in .NET.
    Instead of calling `Dispose` directly, we can use the `using` block. The same
    statement can be decorated with the `using` block coded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When we do this, it converts the code to `try...finally` intermediate code.
    It disposes the connection object inside the `finally` block, which we created.
    Unless you do this, the connection object stays in memory. In due course, when
    we get a huge number of connections, memory starts to leak.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the finalizer (destructor) method, then make sure to call `Dispose()` inside
    it for the resources you want to deallocate. Thus, you will be doubly sure that
    your resources will be cleaned by GC even if someone forgets to release them in
    their code while using your class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of curiosity, you must be asking yourself, what would happen if some exception
    occurs before `Dispose()` is called? Will that object be disposed of? The solution
    to this is to wrap that with a `try...finally` block, so that no matter what happens
    to the program, finally will be called and you can dispose of objects inside that.
    To make it simple, the framework has a beautiful thing called the `using` block
    which can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dispose()` versus `Close()`: Are you confused which one to call for an `SqlConnection`
    object? They are two different methods which solve different problems. `Close()`
    just closes the connection. You can reopen the connection using the same object.
    However, `Dispose()` closes the connection (calls `Close()` under the hood) and
    then deallocates the object from memory. You can''t use the object anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about Garbage Collector at [https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/).
  prefs: []
  type: TYPE_NORMAL
- en: Consider an example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple `Order` class can have a default, parameterized, copy constructor
    along with a destructor (to destroy the object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can see how the constructors are formed using and without the parameters.
    Notice the copy constructor, which takes an object of the same class as an argument
    and inside the body, assigns it's properties to the object in making.
  prefs: []
  type: TYPE_NORMAL
- en: 'The finalizer implicitly calls `Finalize` on the base class of the object.
    Therefore, when GC calls the Finalizer, that might call a method something like
    shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify this behavior with a code snippet inside a console app using
    .NET Core 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DeriveClass2` object is created first which logs the constructor messages.
    Then the `DeriveClass2` destructor is executed. Thus, it is destroyed first when
    the `Main` function execution completes. Additionally, the parent classes have
    destructors. As the child class (`DeriveClass2`) object is already destroyed,
    it runs the parent class destructors too. The following screenshot is taken from
    the output window of visual studio. Make sure you run the app in Release mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffc917d6-732d-47c0-b688-4056666c2f2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the IDisposable Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important to learn how to implement `IDisposable` interface as you might
    work with a user-defined class in your project which will deal with unmanaged
    resources. The system defines classes using unmanaged resources implement `IDisposable`
    and expose Dispose so that we can easily call that method to dispose of the object
    like we saw in the code snippet for `SqlConnection` class.
  prefs: []
  type: TYPE_NORMAL
- en: There is a pattern called **Dispose Pattern**, which the developers must follow
    while implementing `IDisposable`. Let's explore that. I will go through it step
    by step.
  prefs: []
  type: TYPE_NORMAL
- en: Step1 -  Basic structure of class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will have an `ExampleIDisposable` class which implements the `IDisposable`
    interface. I am not going to demonstrate usage of unmanaged resources, as our
    intention is to learn the pattern. I just have a console line inside the constructor
    telling that we are acquiring unmanaged resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the class contains one managed property which is initialized
    inside the constructor. We will print a line for it. Likewise, we might have some
    property using unmanaged resources declared in the class and given life by the
    constructor. Since we implemented `IDisposable`, we are bound to define the only
    method `Dispose()`. For now, we just have a console line inside this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af3d32ed-b02a-4594-b70c-2984ed113c4d.png)'
  prefs: []
  type: TYPE_IMG
- en: We need to understand two important points before moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: '**What happens when Finalizer is called by GC? **When an object goes out of
    scope, that will be added to the Finalizer queue for Garbage Collector to take
    action on them to release it from memory. And we don''t know when that will happen.
    If you kill the managed resources inside `Dispose()`, then we need to restrict
    the objects going into the finalizer queue thereby informing GC not to take action
    on them as they don''t exist anymore. Also, that is an overhead for GC.'
  prefs: []
  type: TYPE_NORMAL
- en: '**What if the developer forgets to call Dispose? **Suppose, the developer who
    is using our class does not dispose of it. Still, we need to handle this situation.
    We can easily do that by calling `Dispose()` inside Finalizer, but wait! We need
    to ask the `Dispose()` method to kill unmanaged resources only, not managed ones
    because GC is there to automatically deal with them.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where another method comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: Step2 - Defining a Dispose Overload method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Dispose()` method we defined inside the class is going to help us while
    calling it directly through the object of the class. However, we need another
    overload of `Dispose()` inside the class which would answer the questions we previously
    discussed. Let's introduce that to our class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Modifications done to the `Dispose` methods are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public void Dispose()`: Now, we are asking the `Dispose(bool)` method to release
    all type of resources. `public void Dispose(). GC.SuppressFinalize(this)`; suppresses
    the GC finalizer call, as we have already disposed of everything inside the `Dispose(bool)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void Dispose(bool)`: This method is the important part of this pattern.
    With the `bool` param, it decides whether there is a need to kill the managed
    resources or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I have replaced the console lines with trace lines so that the `main` method
    ends and we can see the lines on the output screen. If you just remove `Console.ReadLine();`
    from the `Main` method and run the app again, the output produced will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd4c2965-f338-4a83-96b1-6dca53511e7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Removal of the `Dispose()` calls from the `Main` method that is `disposable.Dispose();`,
    will result in something as follows. Note to call `GC.Collect();` at the end of
    `Main` method as we did in Step 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ab0882c-c4b8-412a-a457-cc9b83b35a01.png)'
  prefs: []
  type: TYPE_IMG
- en: That means whenever developer forgets to dispose, the finalizer is called where
    we have called `Dispose(false);`, which eventually released unmanaged resources.
    Of course, finalizer will remove the managed resources automatically. You can
    see that the lines Someone called Dispose and Managed Resources disposed are missing
    in the last case.
  prefs: []
  type: TYPE_NORMAL
- en: Step3 -Modifying the Dispose(bool) for Derived classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have `Dispose(bool)` overload, it will be available directly on the object
    to call. There is no need to expose `Dispose(bool)` to the object for the direct
    call as we are internally calling it from `Dispose()` and Finalizer.
  prefs: []
  type: TYPE_NORMAL
- en: The user should not pass boolean and decide what to dispose of and how. The
    only thing they will do is to call `Dispose()` which will release all type of
    resources. For that reason, we will restrict the call to `Dispose(bool)` by changing
    the access specifier from `public` to `protected`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Dispose(bool)` is a logical block for the class which is implementing `IDisposable`.
    Any class which is going to derive a base class implementing `IDisposable` might
    have their own custom logic for disposal. So, instead of adding another dispose
    method, they can just override the base class `Dispose(bool)`. To make that happen,
    we need to prepend a `virtual` keyword before the method name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding paragraphs call for a modification of our very well known method `Dispose(bool)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 - Handling duplicate Dispose calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should manage the scenario where the user might call Dispose more than once.
    If we don't tackle this situation, the subsequent calls will just be unnecessary
    executions for the runtime because the runtime will try to release an object which
    has been already disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily put a flag inside the class which will indicate whether the object
    was disposed or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `disposed` variable, which is used inside `Dispose(bool)`. We are
    checking if that is true inside the method. If true, then we return/exit from
    the method, otherwise execute the disposal codes. At last, we set it as true.
    So, for the first time `Dispose(bool)` is going to execute fully, after that,
    it will just return once called. This way, we are preventing disposing of the
    same object many times which is an overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the code to call `Dispose()` multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This would give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac96fa07-23c1-4416-9e2f-fb32c5d50b49.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see, for the first call, everything works as expected. The the next
    two subsequent Dispose() calls for the same object results in a simple return
    from the method. That is why we see two sets of Someone called Dispose and Dispose(bool)
    already called messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, I would like to show you the final code after all these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget that you can use the `using` statement with any class which implements
    `IDisposable`. For instance, let''s write that for `ExampleIDisposable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this, it would produce the same result as shown in the first screenshot
    under *Step 2: Defining a Dispose Overload method *section.'
  prefs: []
  type: TYPE_NORMAL
- en: Object lifetime management in .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have already explored how Dependency Injection is built
    into .NET Core. Now that we learned how objects are managed by .NET Framework,
    let's shed some light on their lifestyle in .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'With just one line, I can say, in Startup, .NET Core takes one class, tags
    a lifetime to it as specified in code, then instantiates and stores it in the
    container or service collection. Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/663079d7-0bb5-478d-a787-557867ec8ef7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will be covering how the following is addressed in .NET Core:'
  prefs: []
  type: TYPE_NORMAL
- en: Object Creation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object's Lifestyles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object's Disposal after everything is done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically in ASP.NET Core 2.0, an injected type is called a **service**. For
    example, the injected interface is called as `IServiceCollection` and we can add
    services, as we need, by using the `AddSingleton` method here. We will learn more
    about it soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The built-in DI framework in ASP.NET Core performs two important steps when
    we perform the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instantiation:** The object of the provided service (example: `ExampleService`)
    is instantiated so that it can be made available to controllers when they are
    called. The object gets injected through constructor injection or property injection.
    `IExampleService` will be an argument to the controller. The implementer of this
    interface `ExampleService` can be instantiated and injected. We will see the constructor
    in a while.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lifetime Management:** Then it decides the lifetime (creation and disposal)
    of the object injected to the controller. There are different types of lifestyles
    served by the framework, which we will learn next.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s explore the three-lifetime modes served by *ASP.NET Core* by default.
    The following is a quick reference table for these lifestyles:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Lifestyle** | **Description** | **Disposal** |'
  prefs: []
  type: TYPE_TB
- en: '| Transient (temporary or short-lived) | A new instance will be created each
    time the service is requested. | Never |'
  prefs: []
  type: TYPE_TB
- en: '| Scoped (extent or ranged) | An instance will be created for a defined scope.
    When out of scope is reached, another instance will be created, if requested.
    A simple scope can be stated as one `Web Request`. Any resource, requesting the
    instance in a particular `Web Request` will be served the same from the container.
    | Disposed when the scope ends |'
  prefs: []
  type: TYPE_TB
- en: '| Singleton (single or individual) | One instance created by the container
    which will be used/shared throughout the app for every request. | Disposed when
    the container is disposed |'
  prefs: []
  type: TYPE_TB
- en: We will look at each concept in detail now. Don't worry, if you are confused
    after reading this. After a well-designed example, you will definitely get the
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's design our ASP.NET MVC Core app to use all these kinds of
    lifetimes. This example is similar to that given in the official documentation,
    which can be found at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main goal here is to understand how the instances stay during the incoming
    requests. We will investigate the instances from two places: one from a controller
    and another from a class. Both these guys will use the same interfaces as dependencies
    injected to their constructors. Let''s go through things step by step.'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First code an interface `IExampleService` with a `Guid` type property `ExampleId`.
    Then write four interfaces implementing this interface. We have named them according
    to a different type of lifetimes so that we can easily recognize them afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The Concrete class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstract which means something which can be conceptualized whereas concrete
    means something which exists in reality and not abstract. Suppose we consider
    three Shapes like a circle, a rectangle, and a square. The shape seems like a
    concept, doesn't it? On the other hand a circle, a rectangle, and a square actually
    have the behavior of shape to represent a concrete idea. An Abstract class is
    incomplete in nature and when a class takes (or inherits) its behavior, it becomes
    complete which is denoted as **Concrete**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, Abstract (or incomplete) concept is meant to be completed by other classes
    inheriting it, forming *Concrete Classes*. An Abstract class is incomplete and
    just a concept, so instantiating it becomes meaningless. Shape, for instance,
    is not meant to be instantiated, rather it''s meant to be inherited by actual
    shape classes. The following diagram shows the relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36b8337a-1d81-4ff2-9ace-c1d5a66d9050.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A single `Example` class implements all these interfaces and defines the `ExampleId` guid.
    Two constructors are there: one which takes the `Guid` as a param and the other
    one is the default which initializes a new guid. All those interfaces will be
    resolved as this class in *Startup*. We are approaching that code soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The Service class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said to have a simple class using these interfaces, here is that class
    called as `ExampleService`. We have a constructor here, which is waiting for the
    interfaces to be injected and assigned to local interface type variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The controller is almost the same as the service class with an additional reference
    of `ExampleService`. It has a constructor to initialize them. The properties of
    `ExampleService` will be printed on a view, that''s why we are referring to that
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Inside `Index()` action, we are returning all these values in `ViewBag`.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Last, but not least, we will simply design a view which can show all these values
    so that we can start our observation. This would be `Index.cshtml` inside `Views/Example`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we completed the codes. Are you sure? We forgot the main entry point.
    The one which decides what class will be resolved against which interface.
  prefs: []
  type: TYPE_NORMAL
- en: Startup ConfigureServices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now each type of lifestyle is added to the container resolved using `Example`
    class. The class `ExampleService` is resolved for itself. That means, whenever
    we need `ExampleService` anywhere in the app, to be injected, it will automatically
    assign an object of that class with all its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`Add***` methods (with different lifestyles) make sure that the objects are
    created according to the desired behavior expected from them. Once these objects
    are initialized, they can be injected where ever required.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the app now, for the first request, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a77645f-5f93-4b86-9e98-17f9d68cf2aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I opened the page in another tab (or you can just refresh the tab). I saw the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eed82ac7-6517-4824-90c6-44afd3b3ed53.png)'
  prefs: []
  type: TYPE_IMG
- en: Object lifetimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's examine all the lifetimes one by one according to the values we see in
    these screenshots. The values help us recognize the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at the screenshots and diagrams, the first thing which is clearly seen
    is the `Singleton` one. No matter how many requests you do after running the app,
    the object will be the same. It does not depend upon the Controller or the `Service`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Scoped
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a particular request, the object is same throughout the scope. Notice how
    the object's guid value is different in the second request. However, the values
    are same for Controller and `Service` class in both the requests. Here the scope
    is the web request. When one more request is served, the object is recreated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a scope in code is possible though. There is an interface called `IServiceScopeFactory`
    which exposes the method `CreateScope`. `CreateScope` is of the type `IServiceScope`,
    which implements `IDisposable`. Here the `using` block comes to our rescue for
    disposal of the scoped instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We created two scoped instances in the preceding code using `CreateScope`. Both
    are independent of each other and are not shared within a request like a normal
    scoped instance. That is because we manually assigned the scope instead of the
    default Web Request scope.
  prefs: []
  type: TYPE_NORMAL
- en: Transient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simple! A new object is always created whenever requested from the container.
    In the screenshot, you can see the guid values are different in the Controller
    and the `Service` class even for a single request.
  prefs: []
  type: TYPE_NORMAL
- en: Instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last one is a special case of Singleton, where the user creates the object
    and provides that to the `AddSingleton` method. So, we are explicitly creating
    the object of the `Example` class ( `services.AddSingleton(new Example(Guid.Empty))`)
    and asking DI framework to register it as a Singleton. In this case, we are sending
    `Guid.Empty`. Thus, an empty guid is assigned which stays unchanged for all requests.
  prefs: []
  type: TYPE_NORMAL
- en: Object disposal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we register a service directly with the `Add***` method, the container
    is responsible for creating the object and managing the lifetime. Essentially,
    it calls `Dispose` for the objects, which implement `IDisposable` according to
    the lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example where `ServiceDisposable` implements `IDisposable`
    and we told services to manage its lifetime as `Scoped`. Therefore, it will create
    the instance, then make it available across all resources in the app for a single
    request. At last, it disposes of it when the request ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when we create the object explicitly and provide that to the DI, we
    need to handle it''s disposal our self. In the following case, we have to manually
    call `Dispose()` somewhere to dispose the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When to choose what?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important how we deal with different objects in our application so that
    they consume limited memory space and resources, yet optimize the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Objects which require more space and utilize large server resources should not
    be recreated, rather they should be reused. Database objects, for instance, should
    be reused for all the requests which follow a `Singleton` pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations which runs in a batch or a loop can be reused in a particular request
    but should be recreated for another. That indicates a Scoped lifetime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Model` and `View Model` classes should be instantiated every time we try
    to form them. We can't reuse a Model class object while doing a CRUD operation,
    else we might end up with the wrong values going into the database. Of course,
    that is `Transient` as it lives for a short period of time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationship and dependencies among lifetimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will dig more to find out the relation between the lifetimes.
    The reason is pretty clear. While instantiating our classes with a different type
    of lifestyle, we might face situations where we need dependency of one class in
    another class. But the catch here is that they may not be following a similar
    lifestyle. So, what happens to the instance which is following a scoped lifestyle
    referred inside a `Singleton` class. Does that behave as Scoped?
  prefs: []
  type: TYPE_NORMAL
- en: Let's get our hands dirty and do some code modifications to inject dependencies
    into one another.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton depending on Scoped and Transient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to add two new properties to the existing `IExampleSingleton`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, we want to design a new class explicitly for all lifestyles. As we have
    planned, let's inject Transient and Scoped dependencies into this `Singleton`
    class through the constructor. The properties defined for dependent lifestyles
    are assigned values accordingly from the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: I have defined all classes in a single place just for the readability purposes
    of this book. You should ideally add them in different files every time.
  prefs: []
  type: TYPE_NORMAL
- en: The controller is the next place where we need to have an action which will
    return the view where we will show the values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It's similar to what we have done with the `Index` action. The difference is
    that we have removed the `SingletonInstance` reference and returned a view called
    as `Singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So, I am trying to print the `ExampleId` of `Singleton` object and properties
    related to the dependent objects (`Transient` and `Scoped`). I have omitted the
    styles from this code which is just to make the table look cool.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to tell the `Startup` `ConfigureService` to register the classes
    with the appropriate lifestyle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Voila! We are done. Let''s check the output. I have pasted the screenshots
    of two requests done to the controller side by side so that we can easily mark
    the findings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f98f9b19-cec3-4dbe-b7ec-7aa5d7e9b4a7.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Observation**: The `Singleton` object is shared across two requests as the
    underlined `ExampleId` value is same.'
  prefs: []
  type: TYPE_NORMAL
- en: Hold on! There is something weird. Dependent objects' values are also the same
    across request. Notice the values in red blocks. Even though those classes are
    registered as `Scoped` and `Transient`, they are behaving like a `Singleton`.
    That means the normal lifestyle of these objects is tampered.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inference**: It''s not recommended to refer `Scoped` and `Transient` lifestyle
    classes inside a `Singleton` class as they will lose their usual behavior and
    become Singletons.'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, a `Singleton` class can depend on another a `Singleton` class. Likewise,
    other lifestyles follow the same rule. So, a `Scoped` class can refer another
    `Scoped` class and a `Transient` can refer another `Transient`. They all will
    behave as expected when executed.
  prefs: []
  type: TYPE_NORMAL
- en: Scoped depending on Singleton and Transient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly, we can test for dependencies inside a `Scoped` class. We will start
    by adding two properties to the interface `IExampleScoped`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`ExampleScoped` should now implement these two properties. Also, the interfaces
    related to `Transient` and `Singleton` need to be injected into the `constructor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A new action is added which will return the view named as `Scoped`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks like we are done. Let''s run the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ded12cfc-42d1-41fa-a62f-a1699b3d40d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Oops! We see an exception screen which says a Circular Dependency was detected.
  prefs: []
  type: TYPE_NORMAL
- en: '**Circular Dependency**, as the name suggests, is a class which depends on
    another, which in turn, depends on the first class. We designed everything to
    test the dependencies of other lifestyles in Scoped lifestyle, but we forgot one
    thing before doing that. Previously, we added a dependency of `Scoped` class inside
    a `Singleton` class and now, if you see the preceding `ExampleScoped` constructor,
    we now inject `IExampleSingleton`, which is resolved as the `Singleton` class
    `ExampleSingleton`. That''s how it became circular.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we need to remove the dependencies from the `Singleton` class to
    test. We can also test by doing another interface and class for `Singleton`. So,
    when you fix the code, we will get the following output. I am not going to write
    the codes of the `View` here. It''s pretty much the same as we done in `Singleton`.
    We just need to print `ExampleId`, `SingletonExampleId` and `TransientExampleId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/157c30df-1f4d-4d51-817f-978969316d74.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Observation:** In the red boxes, we have transient object values. That is
    because they are not `Transient` anymore and behave like `Scoped`, as the values
    are the same in a request, which is not what `Transient` looks like. It should
    be different every time it is requested. But in the case of `Singleton` dependency,
    it is the same across requests, which not only satisfies the `Singleto`n paradigm
    but also behaves like scoped in a particular request.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inference:** That''s why it is recommended to use `Scoped` and `Singleton`
    dependencies inside a `Scoped` class, but not Transient.'
  prefs: []
  type: TYPE_NORMAL
- en: Transient depending on Singleton and Scoped
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following the same pattern for `Transient`, we will design the interface
    and class as required. The interface will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Next is the `Transient` class depending on `Singleton` and `Scoped`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Last, but not the least, a new action to render the view `Transient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this after designing the view will end up with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/964da5d3-1efd-41bf-a166-cb3cd8aa5334.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the `Transient` `ExampleId` differs in inside and outside the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: '**Observation:** You must be wondering why I don''t have red boxes in this
    picture. That is because everything looks perfect. `Singleton` is the same everywhere
    and `Scoped` is the same in a particular request, however, changes in the next
    request.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inference:** That means, both these dependencies carry their usual characteristics
    when injected inside a *Transient* class. Also, another *Transient* dependency
    will definitely work if injected to a *Transient* class.'
  prefs: []
  type: TYPE_NORMAL
- en: Saying all this, I would say these are the recommended patterns to follow while
    injecting one lifestyle into another. We should be careful while designing the
    classes and their lifestyle. Either we will end up in a Circular Dependency or
    lose the appropriate behavior of the lifestyle injected as we saw in the preceding
    examples. We can still mix it up as long as we are aware of the consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'With just a simple table, I can represent the whole point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99131700-c1b9-4a79-a682-50d2c5038a10.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about how objects are created and destroyed by .NET
    Framework. Creation and destruction mechanism were discussed. *Garbage Collector*
    plays an important role in the automatic disposal through Finalizers, which we
    analyzed through examples.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, we saw a step-by-step walkthrough to manually dispose of objects
    as soon as we are done by implementing the `IDisposal` interface.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we explored the different lifetimes maintained by objects in .NET
    Core. We saw examples using the controller and service classes. We learned how
    the objects are created and disposed of. Most importantly, we experimented with
    the adaptability of different lifestyles with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Interception, another pillar of DI, will be covered in [Chapter 7](d36b8d07-937a-4f06-ba4c-3cd040798052.xhtml),
    *Interception*.
  prefs: []
  type: TYPE_NORMAL
