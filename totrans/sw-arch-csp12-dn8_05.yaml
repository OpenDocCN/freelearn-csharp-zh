- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Code Reusability in C# 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Code reusability** is one of the most important topics in software architecture.
    This chapter aims to discuss ways to enable code reuse, as well as help you understand
    how .NET 8 solves the problem of managing and maintaining a reusable library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the principles of code reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of working with .NET 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable libraries using .NET 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although code reuse is an exceptional practice, as a software architect, you
    must be aware of when this is important for the scenario you are dealing with.
    Many good software architects agree that there is a lot of overengineering due
    to trying to make things reusable even though they are often single-use or not
    understood well enough, leading to unnecessary complexity and slowing down the
    development process.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need the free Visual Studio 2022 Community Edition
    or above, with all the database tools installed.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the principles of code reusability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a single reason that you can always use to justify code reuse – you
    cannot spend your valuable time reinventing the wheel if it is already running
    well in other scenarios. That is why most engineering domains are based on reusability
    principles like modularity, standardization, abstraction, and documentation. Think
    about the light switches you have in your house. You can only change them without
    modifying other components of your house because it was built based on a standard,
    abstracting the idea of what a switch is according to a specification, providing
    modularity as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Can you imagine the number of applications that can be made with the same interface
    components? The fundamentals of code reuse are the same. Again, it is a matter
    of planning a good solution so part of it can be reused later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In software engineering, code reuse is one of the techniques that can bring
    a bunch of advantages to a software project, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: There is confidence in the software, considering that the reused piece of code
    was already tested in another application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is more efficient usage of software architects and the senior team since
    they can be dedicated to solving this kind of problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is the possibility of bringing to the project a pattern that is already
    accepted by the market.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development speed goes up due to the already-implemented components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintenance is easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These aspects suggest that code reuse should be done whenever possible. However,
    creating reusable components does carry higher costs initially. That is why you
    need to focus on creating it in situations where you recognize that this piece
    of code will really be reused in the future or where you are trying to reuse code
    that has not been created as a component. It is your responsibility, as a software
    architect, to ensure the preceding advantages are utilized and, more than that,
    that you incentivize your team to enable reuse in the software they are creating.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss what can be considered code reuse and what
    cannot. The main purpose of discussing it is to help you define a code reuse strategy
    that will transform the efficiency of your team.
  prefs: []
  type: TYPE_NORMAL
- en: What code reuse is not
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing you must understand is that code reuse does not mean copying
    and pasting code from one class to another. Even if this code was written by another
    team or project, this does not indicate that you are properly working with reusability
    principles. Let us imagine a scenario that we will find in this book’s use case,
    the **WWTravelClub** evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project scenario, you may want to evaluate different kinds of subjects,
    such as the **Package**, **DestinationExpert**, **City**, **Comments**, and so
    on. The process for getting the evaluation average is the same, no matter which
    subject you are referring to. Due to this, you may want to *enable* reuse by copying
    and pasting the code for each evaluation. The (bad) result will be something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19820_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Bad implementation – there is no code reuse here'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the process of calculating the evaluation average
    is decentralized, which means that the same code will be duplicated in different
    classes. This will cause a lot of trouble, especially if the same approach is
    used in other applications. For instance, if there is a new specification covering
    how you must calculate the average, or even if you just get a bug in the calculation
    formula, you will have to fix it in all instances of the code. If you do not remember
    to update it everywhere, you will possibly end up with an inconsistent implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will reorganize this code to respect some principles
    that you, as a software architect, should follow to avoid the issues we have mentioned
    here.
  prefs: []
  type: TYPE_NORMAL
- en: What code reuse is
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution to the problem mentioned in the previous section is quite simple:
    you must analyze your code and select the parts of it that would be good to decouple
    from your application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most compelling reason you should decouple them is related to how you are
    sure that this code can be reused in other parts of the application or even in
    another application. This is exactly what Andrew Hunt and David Thomas present
    as the DRY principle (don’t repeat yourself):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19820_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: An implementation focused on code reuse'
  prefs: []
  type: TYPE_NORMAL
- en: 'The centralization of the code brings with it a different responsibility for
    software architects such as yourself. You must keep in mind that if there is a
    mistake or problem in this code, it can cause issues in many parts of the application
    or even other applications that use it. On the other hand, once you have this
    code tested and running, you will be able to reuse this code again in new projects
    with no worries. Besides, let’s remember the use case we are implementing here:
    you may want to evaluate different kinds of subjects, such as the **Package**,
    **DestinationExpert**, **City**, **Comments**, and so on. The process for getting
    the evaluation average is the same, no matter which subject you are referring
    to. What if you need to evolve the average calculation process? In the design
    now provided, you will have to change the code in a single class. Considering
    what we have already learned, we could also:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a base class implementing the logic of the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inherit all other classes from the newly created base class and eventually augment/modify
    the method’s behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn the inheritance into an association (as discussed in the previous chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth mentioning that the more you use the same code, the cheaper this
    development will become. Although it might seem like developing reusable code
    costs more initially, the more you use it, the more cost-effective and efficient
    the development process becomes over time. Cost needs to be mentioned because,
    in general, the concept of reusable software costs more in the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Reusability in the development life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you understand that code reusability will take you to another level of coding,
    improving the way you write and use code, then it’s time to think about how to
    make this technique available in your development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, creating and maintaining a component library is not very
    easy due to the responsibility you will take on and the lack of good tools to
    support the search for existing components.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, there are some practices that you may consider implementing
    in your software development process every time you initiate a new development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use** the already-implemented components from your user library, selecting
    features that need them in the software requirements specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identify** features in the software requirements specification that are candidates
    to be designed as library components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modify** the specification, considering that these features will be developed
    using reusable components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design** the reusable components and be sure that they have the appropriate
    interfaces to be used in many projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build** the project architecture with the new component library version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document** the component library version so that every developer and team
    knows about it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *use-identify-modify-design-build* process is a technique that you may consider
    implementing every time you need to enable software reuse. As soon as you have
    the components you need to write for this library, you will need to decide on
    the technology that will provide these components.
  prefs: []
  type: TYPE_NORMAL
- en: During the history of software development, there have been many approaches
    to enable code reuse, from **dynamic link libraries** (**DLLs**) to microservices,
    as we will discuss in *Chapter 11*, *Applying a Microservice Architecture to Your
    Enterprise Application*, in the *Microservices and the evolution of the concept
    of modules* section. The methodology explained in the section can be used by you,
    as a software architect, to implement this strategy to accelerate software development.
    Now, let us check how .NET 8 can help us with it.
  prefs: []
  type: TYPE_NORMAL
- en: Using .NET 8 for code reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**.NET** has evolved a lot since its first version. This evolution is related
    not only to the number of commands and performance issues but also to the supported
    platforms. As we discussed in *Chapter 1*, *Understanding the Importance of Software
    Architecture*, you can run C# .NET on billions of devices, even if they are running
    Linux, Android, macOS, or iOS. For this reason, .NET Standard was first announced
    together with .NET Core 1.0, but .NET Standard became particularly important with
    .NET Standard 2.0 when .NET Framework 4.7.2, .NET Core, and Xamarin became compatible
    with it.'
  prefs: []
  type: TYPE_NORMAL
- en: The key point is that .NET Standard was not only a Visual Studio project. More
    than that, it was a formal specification available to all .NET implementations.
    As you can see in the following table, .NET Standard 2.0, which is recommended
    by Microsoft, covers everything in .NET. You can find a full .NET Standard overview
    at [https://docs.microsoft.com/en-us/dotnet/standard/net-standard](https://docs.microsoft.com/en-us/dotnet/standard/net-standard).
  prefs: []
  type: TYPE_NORMAL
- en: '| **.NET implementation** | **Version support** |'
  prefs: []
  type: TYPE_TB
- en: '| .NET and .NET Core | 2.0, 2.1, 2.2, 3.0, 3.1, 5.0, 6.0, 7.0, 8.0 |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Framework 1 | 4.6.1 2, 4.6.2, 4.7, 4.7.1, 4.7.2, 4.8, 4.8.1 |'
  prefs: []
  type: TYPE_TB
- en: '| Mono | 5.4, 6.4 |'
  prefs: []
  type: TYPE_TB
- en: '| Xamarin.iOS | 10.14, 12.16 |'
  prefs: []
  type: TYPE_TB
- en: '| Xamarin.Mac | 3.8, 5.16 |'
  prefs: []
  type: TYPE_TB
- en: '| Xamarin.Android | 8.0, 10.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Universal Windows Platform | 10.0.16299, TBD |'
  prefs: []
  type: TYPE_TB
- en: '| Unity | 2018.1 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: .NET Standard 2.0 support'
  prefs: []
  type: TYPE_NORMAL
- en: This indicates that if you build a class library that is compatible with this
    standard, you will be able to reuse it on any of the platforms presented. Think
    about how fast your development process could become if you plan to do this in
    all your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, some components are not included in .NET Standard, but its evolution
    is continuous. It is worth mentioning that Microsoft’s official documentation
    indicates that *the higher the version, the more APIs are available to you*.
  prefs: []
  type: TYPE_NORMAL
- en: The initiative of having a single framework for all platforms brought us to
    .NET 5\. Microsoft indicated that from .NET 5.0, the framework would run everywhere.
    The next question you, as a software architect, might have is *what is going to
    happen to .NET Standard?*
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to this question is well explained by Immo Landwerth at the dotnet
    blog: [https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/).
    The basic answer is that .NET 5.0 (and future versions) needs to be thought of
    as the foundation for sharing code moving forward. Considering .NET 8 is an **LTS**
    (**Long-Term Support**) version, we can now understand the framework as the best
    option to share code for new applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Bearing this scenario in mind, it is time to check how to create reusable class
    libraries. So, let us move to the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reusable class library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to make useful functionalities to be used by multiple applications,
    you will need to create a **class library** project. So, creating class libraries
    is the best way to reuse code using .NET. It is quite simple to create a **class
    library**. Basically, you need to choose the following project when creating the
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Texto  Descrição gerada automaticamente](img/B19820_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Creating a class library'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have concluded this part, you will notice that the project file keeps
    the information about the **target framework moniker** (**TFM**). The idea of
    the TFM is to define the set of APIs that will be available to the library. You
    can find a list of the available TFMs at [https://docs.microsoft.com/en-us/dotnet/standard/frameworks](https://docs.microsoft.com/en-us/dotnet/standard/frameworks):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As soon as your project is loaded, you can start coding the classes that you
    intend to reuse. The advantage of building reusable classes using this approach
    is that you will be able to reuse the written code in all the project types we
    checked previously. On the other hand, you will find out that some APIs that are
    available in .NET Framework do not exist in this type of project.
  prefs: []
  type: TYPE_NORMAL
- en: Considering that you already have the correct project type selected for creating
    reusable code, let us check how C# deals with code reuse in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How does C# deal with code reuse?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Considering you are writing class libraries using C#.NET, there are many approaches
    where **C#** helps us deal with code reuse. The ability to build libraries, as
    we did in the previous section, is one of them. One of the most important ones
    is the fact that the language is **object-oriented**. Besides this, it is also
    worth mentioning the facilities that generics brought to the C# language. This
    section will discuss object-oriented analysis and generics principles.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The object-oriented analysis approach gives us the ability to reuse code in
    different ways, from the facility of inheritance to the changeability of polymorphism.
    Complete adoption of object-oriented programming will let you implement abstraction
    and encapsulation, too.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to mention that in *Chapter 4*, *Best Practices in Coding C#
    12*, we discuss how inheritance can cause complexity in your code. Although the
    following example presents a valid way to reuse code, consider using composition
    over inheritance in real-life applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how using the object-oriented approach makes reuse
    easier. As you can see, there are different ways to calculate the grades of an
    evaluation, considering that you can be a basic or a prime user of this example
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Object-oriented case analysis'
  prefs: []
  type: TYPE_NORMAL
- en: There are two aspects to be analyzed as code reuse in this design. The first
    is that there is no need to declare the properties in each child class since inheritance
    does it for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second is the opportunity to use polymorphism, enabling different behaviors
    for the same method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, you can see the usage of the polymorphism principle,
    where the calculation of evaluation for prime users will increase by 20%. Now,
    look at how easy it is to call different objects inherited by the same class.
    Since the collection content implements the same interface, `IContentEvaluated`,
    it can have basic and prime users, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Object-oriented adoption can be considered mandatory when using C#. However,
    more specific usage requires study and practice. You, as a software architect,
    should always incentivize your team to study object-oriented analysis. The more
    abstract abilities they have, the easier code reuse will become.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Generics** were introduced in C# in version 2.0 and are considered an approach
    that increases code reuse. It also maximizes type safety and performance.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic principle of generics is that you can define in an interface, class,
    method, property, event, or even delegate a placeholder that will be replaced
    with a specific type later when one of the preceding entities is used. The opportunity
    you have with this feature is incredible since you can use the same code to run
    different generic versions of the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a modification of `EvaluationService`, which was presented
    in the previous section. The idea here is to enable the generalization of the
    service, giving us the opportunity to define the goal of evaluation since its
    creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This declaration indicates that any class that implements the `IContentEvaluated`
    interface can be used for this service. The new constraint indicates this class
    must have a public parameter-less default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service will be responsible for creating the evaluated content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth mentioning that this code works because all the classes are in
    the same assembly. The result of this modification can be checked in the instance
    creation of the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The good news is that now, you have a generic service that will automatically
    instantiate the `list` object with the evaluations of the content you need. It’s
    worth mentioning that generics will obviously need more time dedicated to the
    first project’s construction. However, once the design is done, you will have
    good, fast, and easy-to-maintain code. This is what we call reuse!
  prefs: []
  type: TYPE_NORMAL
- en: What if the code is not reusable?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In fact, any code can be reusable. The key point here is that the code you
    intend to reuse must be well-written and follow good patterns for reuse. There
    are several reasons why code should be considered not ready for reuse:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The code has not been tested before**: Before reusing code, it is a good
    approach to guarantee that it works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The code is duplicated**: If you have duplicate code, you will need to find
    each place where it is used so you only have a single version of the code being
    reused. If you find different versions of the code duplicated, you will need to
    define the best version of it to be considered the reusable one, and, at the same
    time, you will need to retest every replacement of the duplicated code to guarantee
    that the functionality of the software remains the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The code is too complex to understand:** Code that is reused in many places
    needs to be written with simplicity to enable easy understanding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The code has tight coupling**: This is a discussion related to composition
    versus inheritance when building separate class libraries. Classes (with interfaces)
    are usually much easier to reuse than base classes that can be inherited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In any of these cases, considering a refactoring strategy can be a great approach.
    When you refactor code, you write it in a better way, guaranteeing the code standards,
    reducing complexity, and respecting the input and output data that this code will
    process. This enables more comprehensive and lower-cost changes to be made to
    the code when the time comes. Martin Fowler, in his book *Refactoring* of 2018,
    indicates some reasons why you should consider refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It improves software design**: The more expert your team becomes, the better
    the design will be. A better software design will not only deliver faster coding
    but also bring us the opportunity to process more tasks in less time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It makes the software easier to understand**: Regardless of whether we are
    talking about juniors or seniors, good software needs to be understood by every
    developer in your team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It helps us find bugs**: While you are refactoring, you are reviewing code.
    During this process, you will find business rules that may not have been well
    programmed, so you will probably find bugs. However, do not forget that the basis
    of refactoring is keeping the behavior, so be sure that it is the correct moment
    for fixing issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It makes our program quicker**: The result of refactoring will be code that
    will enable faster development in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When refactoring, we can guarantee good results and minimize the errors that
    occur during the journey by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Be sure you have a set of tests to guarantee the correct processing**: This
    set of tests will eliminate the fear of breaking the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eliminate duplication**: Refactoring is a good opportunity to eliminate code
    duplication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimize complexity**: Given that one goal is to make the code more understandable,
    following the best practices of programming, as mentioned in *Chapter 4*, *Best
    Practices in Coding C# 12*, will help you reduce the complexity of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clean up the design**: Refactoring is a good time to reorganize the design
    of your libraries, too. Do not forget to update them as well. This can be a great
    way to eliminate bugs and security issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a software architect, you will receive many refactoring demands from your
    team. The incentive for refactoring must be continuous, but you must remind your
    team that refactoring without following the preceding steps might be risky once
    it may cause bugs during the process. So, it is your responsibility to ensure
    that refactoring happens in a way that both enables fast programming and reduces
    the impact of unnecessary bugs caused by the refactoring process, thus delivering
    real business value.
  prefs: []
  type: TYPE_NORMAL
- en: I have my libraries. How do I promote them?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have made all the necessary effort to guarantee you have good libraries
    that can be reused in many of your projects, you will find another difficult situation
    arises when enabling reusability: it is not so easy to let programmers know you
    have libraries ready to reuse.'
  prefs: []
  type: TYPE_NORMAL
- en: There are some simple approaches to documenting a library. As we mentioned when
    we talked about the development life cycle, documenting is a good way to help
    developers take notice of the libraries they have. There are two examples of documenting
    reusable code that we would like to mention in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting .NET libraries using DocFX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DocFX is a good option for documenting a library using comments made in its
    code. By simply adding the `docfx.console` NuGet package, the tool allows you
    to create a task that will run once your library has been built:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interface gráfica do usuário, Texto  Descrição gerada automaticamente](img/B19820_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: docfx.console NuGet library'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this compilation is a stylish static website that contains the
    documentation of your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: DocFx result'
  prefs: []
  type: TYPE_NORMAL
- en: This website is useful because you can distribute the documentation to your
    team so that they can search for the libraries you have. You can check the customizations
    of the output and find more information about it at [https://dotnet.github.io/docfx/](https://dotnet.github.io/docfx/).
  prefs: []
  type: TYPE_NORMAL
- en: Documenting a web API using Swagger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no doubt that a web API is one of the technologies that facilitates
    and promotes code reuse. For this reason, ensuring good documentation and, more
    than that, respecting a standard is good practice and indicates that you are up
    to date with the approach to delivering reusable APIs. To do this, we have **Swagger**,
    which respects the **OpenAPI Specification**.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenAPI Specification is known as the standard for describing modern APIs.
    One of the most widely used tools for documenting APIs in an **ASP.NET Core Web
    API** is `Swashbuckle.AspNetCore`.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing about using the `Swashbuckle.AspNetCore` library is where you
    can set the **Swagger UI** viewer for your web API, which is a good, graphical
    way to distribute the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to use this library in ASP.NET Core web APIs in *Chapter 15*,
    *Applying Service-Oriented Architectures with .NET*. Until then, it is important
    to understand that this documentation will help not only your team but any developer
    who might use the APIs you are developing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter aimed to help you understand the advantages of code reuse. It also
    gave you an idea about what code is not appropriate for reuse. This chapter also
    presented approaches for reusing and refactoring code.
  prefs: []
  type: TYPE_NORMAL
- en: Considering that technology without processes does not take you anywhere, a
    process was presented that helps enable code reuse. This process is related to
    using already completed components from your library, identifying features in
    the software requirements specification that are candidates to be designed as
    library components, modifying the specification considering these features, designing
    the reusable components, and building the project architecture with the new component
    library version.
  prefs: []
  type: TYPE_NORMAL
- en: Concluding this chapter, we presented .NET Standard libraries as an approach
    to reusing code for different C# platforms, indicating that .NET 8 and new versions
    allow the reuse of code across different platforms. This chapter also reinforced
    the principles of object-oriented programming when reusing code and presented
    generics as a sophisticated implementation to simplify the treatment of objects
    with the same characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can copy-and-paste be considered code reuse? What are the impacts of this approach?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you reuse code without copying and pasting it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there a process that can help with code reuse?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between .NET Standard and .NET Core?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of creating a .NET Standard library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does object-oriented analysis help with code reuse?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do generics help with code reuse?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Will .NET Standard be replaced by .NET 6?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the challenges related to refactoring?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some books and websites where you will find more information
    about the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Clean Code: A Handbook of Agile Software Craftmanship* by Martin, Robert C.
    Pearson Education, 2012.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clean Architecture: A Craftsman’s Guide to Software Structure and Design*
    by Martin, Robert C. Pearson Education, 2018.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Eric Gamma
    [et al.] Addison-Wesley, 1994.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Principles and Design Patterns* by Robert C. Martin, 2000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Refactoring* by Martin Fowler, 2018.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need more information about .NET Standard:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/introducing-net-standard/](https://devblogs.microsoft.com/dotnet/introducing-net-standard/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/net-standard-20-cookbook](https://www.packtpub.com/application-development/net-standard-20-cookbook)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A great guide for programming using the generics concept: [https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some links that may help you with the documentation of libraries and APIs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dotnet.github.io/docfx/](https://dotnet.github.io/docfx/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/domaindrivendev/Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code175081751210902046.png)'
  prefs: []
  type: TYPE_IMG
