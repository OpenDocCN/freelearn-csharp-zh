- en: Chapter 8. Positions, Movement and Navigation for Character GameObjects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Player control of a 2D GameObject (and limiting the movement within a rectangle)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player control of a 3D GameObject (and limiting the movement within a rectangle)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing destinations – find the nearest (or a random) spawn point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing destinations – respawn to the most recently passed checkpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPC NavMeshAgent to seek or flee destination while avoiding obstacles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPC NavMeshAgent to follow waypoints in sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the object group movement through flocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many GameObjects in games move! Movement can be controlled by the player, by
    the (simulated) laws of physics in the environment, or by the **Non-Player Character**
    (**NPC**) logic; for example, objects that follow a path of waypoints, or seek
    (move towards) or flee (away) from the current position of a character. Unity
    provides several controllers, for first and third-person characters, and for vehicles
    such as cars and airplanes. GameObject movement can also be controlled through
    the state machines of the Unity Mecanim animation system.
  prefs: []
  type: TYPE_NORMAL
- en: However, there maybe times when you wish to tweak the Player character controllers
    from Unity, or write your own. You might wish to write directional logic—simple
    or sophisticated **Artificial Intelligence** (**AI**) to control the game's NPC
    and enemy characters. Such AI might involve your computer program making objects
    orient and move towards or away from characters or other game objects.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter presents a range of such directional recipes, from which many games
    can benefit in terms of a richer and more exciting user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides sophisticated classes and components including the Vector3 class
    and rigid body physics for modeling realistic movements, forces, and collisions
    in games. We make use of these game engine features to implement some sophisticated
    NPC and enemy character movements in the recipes of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For 3D games (and to some extent, 2D games as well), a fundamental class of
    object is the Vector3 class—objects that store and manipulate (x,y,z) values representing
    locations in 3D space. If we draw an imaginary arrow from the origin (0,0,0) to
    a point on space, then the direction and length of this arrow (vector) can represent
    a velocity or force (that is, a certain amount of magnitude in a certain direction).
  prefs: []
  type: TYPE_NORMAL
- en: If we ignore all the character controller components, colliders, and the physics
    system in Unity, we can write code that teleports objects directly to a particular
    (x, y, z) location in our scene. And sometimes this is just what we want to do;
    for example, we may wish to spawn an object at a location. However, in most cases,
    if we want objects to move in more physically realistic ways, then we either apply
    a force to the object, or change its velocity component. Or if it has a Character
    Controller component, then we can send it a `Move()` message. With the introduction
    of Unity NavMeshAgents (and associated Navigation Meshes), we can now set a destination
    for an object with a NavMeshAgent, and then the built-in pathfinding logic will
    do the work of moving our NPC object on a path towards the given (x, y, z) destination
    location.
  prefs: []
  type: TYPE_NORMAL
- en: As well as deciding which technique will be used to move an object, our game
    must also do the work of deciding how to choose the destination locations, or
    the direction and magnitude of changes to movement. This can involve logic to
    tell an NPC or enemy object the destination of the Player's character (to be moved
    towards, and then perhaps attacked when close enough). Or perhaps shy NPC objects
    will be given the direction to the Player's character, so that they can flee in
    the opposite direction, until they are a safe distance away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other core concepts in the NPC object movement and creation (instantiation)
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: Spawn points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific locations in the scene where objects are to be created, or moved to
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Waypoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sequence of locations to define a path for NPCs or perhaps, the Player's
    character to follow
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Checkpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locations (or colliders) that, once passed through, change what happens in the
    game (for example, extra time, or if a Player's character gets killed, they respawn
    to the last crossed checkpoint, and so on)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Player control of a 2D GameObject (and limiting the movement within a rectangle)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the rest of the recipes in this chapter are demonstrated in 3D projects,
    basic character movement in 2D, and also limiting the movement to a bounding rectangle,
    are core skills for many 2D games, and so this first recipe illustrates how to
    achieve these features for a 2D game.
  prefs: []
  type: TYPE_NORMAL
- en: Since in [Chapter 3](ch03.html "Chapter 3. 2D Animation"), *Inventory GUI*,
    we already have a basic 2D game, we'll adapt this game to restrict the movement
    to a bounding rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Player control of a 2D GameObject (and limiting the movement within a rectangle)](img/1362OT_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds on a simple 2D game called *Creating the Simple2DGame_SpaceGirl*
    mini-game from [Chapter 3](ch03.html "Chapter 3. 2D Animation"), *Inventory GUI*.
    Start with a copy of this game, or use the provided completed recipe project as
    the basis for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a 2D sprite controlled by the user with the movement that is limited
    within a rectangle, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new empty GameObject named **corner_max**, and position it somewhere
    above and to the right of the GameObject called **Player-girl1**. With this GameObject
    selected in the **Hierarchy** view, choose the large yellow oblong icon, highlighted
    in the **Inspector** panel.![How to do it...](img/1362OT_08_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the **corner_max** GameObject by naming the clone as **corner_min**,
    and position this clone somewhere below and to the left of the **player-spaceGirl1**
    GameObject. The coordinates of these two GameObjects will determine the maximum
    and minimum bounds of movement, permitted for the player's character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the C# Script called `PlayerMove` to declare some new variables at the
    beginning of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the C# Script called `PlayerMove` so that the `Awake()` method now gets
    a reference to the SpriteRenderer, and uses this object to help setup the maximum
    and minimum X and Y movement limits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the C# Script called `PlayerMove` to declare a new method called `KeepWithinMinMaxRectangle()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the C# Script called `PlayerMove` so that, after having done everything
    else in the `FixedUpdate()`method, a call will finally be made to the `KeepWithinMinMaxRectangle()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the **player-SpaceGirl1** GameObject in the **Hierarchy** view, drag the
    **corner_max** and **corner_min** GameObjects over the public variables called
    `corner_max` and `corner_min` in the **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before running the scene in the **Scene** panel, try repositioning the **corner_max**
    and **corner_min** GameObjects. When you run the scene, the positions of these
    two GameObjects (max and min, and X and Y) will be used as the limits of movement
    for the Player's **player-SpaceGirl1** character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While all this works fine, let''s make the rectangular bounds of the movement
    visually explicit in the **Scene** panel by having a yellow "gizmo" rectangle
    drawn. Add the following method to the C# script class called `PlayerMove`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You added the empty GameObjects called **corner_max** and **corner_min** to
    the scene. The X- and Y- coordinates of these GameObjects will be used to determine
    the bounds of movement that we will permit for the character called **player-SpaceGirl1**.
    Since these are the empty GameObjects, they will not be seen by the player when
    in the play-mode. However, we can see and move them in the **Scene** panel, and
    having added the yellow oblong icons, we can see their positions and names very
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: Upon `Awake()` the `PlayerMoveWithLimits` object, inside the **player-SpaceGirl1**
    GameObject, records the maximum and minimum X- and Y- values of the GameObjects
    called **corner_max** and **corner_min**. Each time the physics system is called
    via the `FixedUpdate()` method, the velocity of the **player-SpaceGirl1** character
    is set according to the horizontal and vertical keyboard/joystick inputs. However,
    the final action of the `FixedUpdate()` method is to call the `KeepWithinMinMaxRectangle()`
    method, which uses the `Math.Clamp(…)` function to move the character back inside
    the X- and Y- limits. This happens so that the player's character is not permitted
    to move outside the area defined by the **corner_max** and **corner_min** GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnDrawGizmos() m`ethod tests that the references to the **corner_max**
    and **corner_min** GameObjects are not null, and then sets the positions of the
    four Vector3 objects, representing the four corners defined by the rectangle with
    **corner_max** and **corner_min** at the opposite corners. It then sets the Gizmo
    color to yellow, and draws lines, connecting the four corners in the **Scene**
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the next recipe for more information about limiting player controlled
    character movements.
  prefs: []
  type: TYPE_NORMAL
- en: Player control of a 3D GameObject (and limiting the movement within a rectangle)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the 3D recipes in this chapter are built on this basic project, which
    constructs a scene with a textured terrain, a **Main Camera**, and a red cube
    that can be moved around by the user with the four directional arrow keys. The
    bounds of movement of the cube are constrained using the same technique as in
    the previous 2D recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![Player control of a 3D GameObject (and limiting the movement within a rectangle)](img/1362OT_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a basic 3D cube controlled game, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new, empty 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the project has been created, import the single Terrain Texture named
    `SandAlbedo` (it was named `GoodDirt` in Unity 4). Choose menu: **Assets | Import
    Package | Environments**, deselect everything, and then locate and tick the asset:
    `Assets/Environment/TerrainAssets/SurfaceTextures/ SandAlbedo.psd`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You could have just added the Environment Asset Package when creating the project—but
    this would have imported 100s of files, and we only needed this one. Starting
    a project in Unity, then selectively importing just what we need is the best approach
    to take, if you want to keep the project's Asset folders to small sizes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a terrain positioned at (-15, 0, -10) and sized 30 by 20.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The transform position for the terrains relates to their corner and not their
    center.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since the Transform position of the terrains relates to the corner of the object,
    we center such objects at (0,0,0) by setting the X-coordinate equal to ( -1*width/2),
    and the Z-coordinate equal to (-1*length/2). In other words, we slide the object
    by half its width and half its height to ensure that its center is just where
    we want it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this case, the width is 30 and the length is 20, hence we get -15 for X (-1
    * 30/2), and -10 for Z (-1 * 20/2).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Texture paint this terrain with your texture called `SandAlbedo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directional light (it should face downwards to the terrain with the
    default settings—but if it doesn't for some reason, then rotate it so that the
    terrain is well lit).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes to the Main Camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: position = (0, 20, -15)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: rotation = (60, 0, 0)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the **Aspect Ratio** of the **Game Panel** from **Free Aspect** to **4:3**.
    You will now see the whole of the **Terrain** in the **Game Panel**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new empty GameObject named **corner_max**, and position it at (14,
    0, 9). With this GameObject selected in the **Hierarchy,** choose the large, yellow
    oblong icon, highlighted in the **Inspector** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the **corner_max** GameObject, naming the clone as **corner_min**,
    and position this clone at (-14, 0, -9). The coordinates of these two GameObjects
    will determine the maximum and minimum bounds of the movement permitted for the
    player's character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **Cube** GameObject named **Cube-player** at a position called
    (0, 0.5, 0), and size it as (1,1,1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add to the **Cube-player** GameObject, apply a component called **Physics |
    RigidBody**, and uncheck the **RigidBody** property **Use Gravity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a red **Material** named **m_red**, and apply this **Material** to **Cube-player**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script class called `PlayerControl` to the **Cube-player**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the **Cube-player** GameObject selected in the **Hierarchy,** drag the
    GameObjects called **corner_max** and **corner_min** over the public variables
    called `corner_max` and `corner_min` in the **Inspector** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you run the scene, the positions of the **corner_max** and **corner_min**
    GameObjects will define the bounds of movement for the Player's **Cube-player**
    character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The scene contains a positioned terrain so that its center is `(0,0,0)`. The
    red cube is controlled by the user's arrow keys through the `PlayerControl` script.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the previous 2D recipe, a reference to the (3D) RigidBody component
    is stored when the `Awake()` method executes, and the maximum and minimum X- and
    Z- values are retrieved from the two corner GameObjects, and is stored in the
    `x_min`, `x_max`, `z_min`, and `z_max` variables. Note that for this basic 3D
    game, we won't allow any Y-movement, although such movement (and bounding limits
    by adding a third 'max-height' corner GameObject) can be easily added by extending
    the code in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `KeyboardMovement() m`ethod reads the horizontal and vertical input values
    (which the Unity default settings read from the four directional arrow keys).
    Based on these left-right and up-down values, the velocity of the cube is updated.
    The amount it will move depends on the speed variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `KeepWithinMinMaxRectangle()` method uses the `Math.Clamp(…)` function to
    move the character back inside the X and Z limits, so that the player's character
    is not permitted to move outside the area defined by the **corner_max** and **corner_min**
    GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnDrawGizmos()` method tests that the references to the **corner_max**
    and **corner_min** GameObjects are not null, and then sets the positions of the
    four Vector3 objects, representing the four corners defined by the rectangle with
    the **corner_max** and **corner_min** GameObjects at the opposite corners. It
    then sets the Gizmo color to **yellow**, and draws lines connecting the four corners
    in the **Scene** panel.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing destinations – find the nearest (or a random) spawn point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many games make use of spawn points and waypoints. This recipe demonstrates
    two very common examples of spawning—the choosing of either a random spawn point,
    or the nearest one to an object of interest (such as the Player's character),
    and then the instantiation of an object at that chosen point.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds upon the previous recipe. So, make a copy of this project,
    open it, and then follow the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find a random spawn point, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Sphere** sized as (1,1,1) at (2,2,2) position, and apply the `m_red`
    Material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Prefab named `Prefab-ball`, and drag your **Sphere** into it (and
    then delete the **Sphere** from the **Hierarchy** panel).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new capsule object named `Capsule-spawnPoint` at (3, 0.5, 3), give
    it the tag as `Respawn` (this is one of the default tags that Unity provides).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For testing, we'll leave these Respawn points visible. For the final game, we'll
    then uncheck the Mesh Rendered of each Respawn GameObject, so that they are not
    visible to the Player.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make several copies of your **Capsule-spawnPoint** by moving them to different
    locations on the terrain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance of the following C# script class called `SpawnBall` to the
    **Cube-the player** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an instance of the following C# script class called `SpawnPointManager`
    to the `Cube-player` GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ensure that **Cube-player** is selected in the **Inspector** for the `SpawnBall`
    scripted component. Then, drag **Prefab-ball** over the public variable projectile
    called **Prefab Ball**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, run your game. When you click on the mouse (fire) button, a sphere will
    be instantiated randomly to one of the capsule locations.![How to do it...](img/1362OT_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Capsule-spawnPoint** objects represent candidate locations, where we might
    wish to create an instance of our ball Prefab. When our `SpawnPointManager` object,
    inside the **Cube-player** GameObject, receives the `Start()` message, the **respawns**
    GameObject array is set to the array, which is returned from the call to `FindGameObjectsWithTag("Respawn")`.
    This creates an array of all the objects in the scene with the tag called `Respawn`
    — that is, all our **Capsule-spawnPoint** objects.
  prefs: []
  type: TYPE_NORMAL
- en: When our `SpawnBall` object GameObject **Cube-player** receives the `Start()`
    message, it sets the `spawnPointManager` variable to be a reference to its sibling
    `SpawnPointManager` script component. Next, we start the **coroutine** method
    called `CheckFireKeyAfterShortDelay()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `CheckFireKeyAfterShortDelay()` method uses a typical Unity coroutine technique
    that goes into an infinite loop using a delay controlled by the value of the `testFireKeyDelay`
    variable. The delay is to make Unity wait before calling `CheckFireKey()` to test
    if the user wants a new sphere to be spawned.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Coroutines are an advanced technique, where execution inside the method can
    be paused, and resumed from the same point. The `Yield` command temporarily halts
    the execution of code in the method, allowing Unity to go off and execute code
    in the other GameObjects and undertake physics and rendering work and more. They
    are perfect for situations where, at regular intervals, we wish to check whether
    something has happened (such as testing for the Fire key, or whether a response
    message has been received from an Internet request and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about the Unity coroutines at [http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html).
  prefs: []
  type: TYPE_NORMAL
- en: The `SpawnBall` method `CheckFireKey()` tests whether, at that instant, the
    user is pressing the **Fire** button. If the **Fire** button is pressed, then
    the `CreateSphere()`method is called. Also, the `testFireKeyDelay` variable is
    set to 0.5\. This ensures that we won't test the **Fire** button again for half
    a second.
  prefs: []
  type: TYPE_NORMAL
- en: The `SpawnBall` method `CreateSphere()`assigns variable `spawnPoint` to the
    `GameObject` returned by a call to the `RandomSpawnpoint(…)` method of our `spawnPointManager`.
    Then it creates a new instance of `prefab_Ball` (via the public variable) at the
    same position as the `spawnPoint` GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the nearest spawn point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than just choosing a random spawn point, let's search through array spawnpoints,
    and choose the closest one to our player.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the nearest spawn point, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the C# script class called `SpawnPointManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to change the first line in the C# class called `SpawnBall` so
    that the `spawnPoint` variable is set by a call to our new method called `NearestSpawnpoint(…)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `NearestSpawnpoint(…)` method, we set `nearestSpawnpoint` to the first
    (array index 0) GameObject in the array as our default. We then loop through the
    rest of the array (array index 1 up to `spawnPoints.Length`). For each GameObject
    in the array, we test to see if its distance is less than the shortest distance
    so far, and if it is, then we update the shortest distance, and also set `nearestSpawnpoint`
    to the current element. When the array has been searched, we return the GameObject
    that the `nearestSpawnpoint` variable refers to.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding errors due to an empty array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's make our code a little more robust, so that it can cope with the issue
    of an empty `spawnPoints` array—that is, when there are no objects tagged **Respawn**
    in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cope with the no objects tagged **Respawn** we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Improve our `Start()` method in the C# script class called `SpawnPointManager`,
    so that an ERROR is logged if the array of objects tagged **Respawn** is empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Improve the `RandomSpawnPoint()` and `NearestSpawnpoint()`methods in the C#
    script class called `SpawnPointManager`, so that they still return a GameObject
    even if the array is empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Improve the `CreateSphere()`method in the C# class called `SpawnBall`, so that
    we only attempt to instantiate a new GameObject if the `RandomSpawnPoint()` and
    `NearestSpawnpoint()`methods have returned a non-null object reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same techniques and code can be used for selecting spawn points or waypoints.
    Refer to the *NPC NavMeshAgent control to follow waypoints in sequence* recipe
    in this chapter for more information about waypoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing destinations – respawn to the most recently passed checkpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **checkpoint** usually represents a certain distance through the game (or
    perhaps a **track**) in which an agent (user or NPC) has succeeded reaching. Reaching
    (or passing) checkpoints often results in bonus awards, such as *extra time*,
    *points*, *ammo*, and so on. Also, if a player has multiple lives, then often
    a player will be respawned only back as far as the most recently passed checkpoint,
    rather than right to the beginning of the level.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates a simple approach to the checkpoints, whereby once
    the player's character has passed a checkpoint, if they die they are moved back
    only to the most recently passed checkpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing destinations – respawn to the most recently passed checkpoint](img/1362OT_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds upon the player-controlled 3D cube Unity project that you
    created at the beginning of this chapter. So, make a copy of this project, open
    it, and then follow the steps for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To have the respawn position upon losing a life change depending on the checkpoints
    passed, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the **Cube-player** GameObject to the (12, 0.5, 0) position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Cube-player** in the **Inspector** panel and add a **Character Controller**
    component by clicking on **Add Component** | **Physics** | **Character Controller**
    (this is to enable the `OnTriggerEnter` collision messages to be received).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a cube named **Cube-checkpoint-1** at (5, 0, 0), scaled to (1, 1, 20).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **Cube-checkpoint-1** selected, check the **Is Trigger** property of its
    **Box Collider** component in the **Inspector** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **CheckPoint** tag, and assign this tag to **Cube-checkpoint-1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate **Cube-checkpoint-1** by naming the **Cube-checkpoint-2** clone and
    positioning it at (-5, 0, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a sphere named **Sphere-Death** at (7, 0.5, 0). Assign the **m_red**
    material to this sphere to make it red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **Sphere-Death** selected, check the **Is Trigger** property of its **Sphere
    Collider** component in the **Inspector** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Death** tag, and assign this tag to **Sphere-Death**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate **Sphere-Death**, and position this clone at (0, 0.5, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate **Sphere-Death** a second time, and position this second clone at
    (-10, 0.5, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance of the following C# script class called `CheckPoints` to the
    **Cube-player** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the scene. If the cube runs into a red sphere *before* crossing a checkpoint,
    it will be respawned back to its starting position. Once the red cube has passed
    a checkpoint, if a red sphere is hit, then the cube will be moved back to the
    location of the most recent checkpoint that it passed through.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C# script class called `CheckPoints` has one variable called `respawnPosition`,
    which is a Vector3 that refers to the position the player's cube is to be moved
    to (respawned) if it collides with a **Death** tagged object. The default setting
    for this is the position of the player's cube when the scene begins—so in the
    `Start()`method, we set it to the player's position.
  prefs: []
  type: TYPE_NORMAL
- en: Each time an object tagged called **CheckPoint** is collided with, the value
    of `respawnPosition` is updated to the current position of the player's red cube
    at this point in time (that is, where it is when it touches the stretched cube
    tagged called **CheckPoint**). So that the next time the object tagged **Death**
    is hit, the cube will be respawned back to where it last touched the object tagged
    called **CheckPoint**.
  prefs: []
  type: TYPE_NORMAL
- en: NPC NavMeshAgent to seek or flee destination while avoiding obstacles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introduction of Unity's NavMeshAgent has greatly simplified the coding for
    NPC and enemy agent behaviors. In this recipe, we'll add some wall (scaled cubes)
    obstacles, and generate a NavMesh, so that Unity knows not to try to walk through
    the walls. We then add a NavMeshAgent component to our NPC GameObject, and tell
    it to head to a stated destination location by intelligently planning and following
    a path, while avoiding the wall obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: In the next screenshot, we can see in the **Scene** panel the squares that represent
    potential points on the path. We can also see lines showing the current temporary
    direction and destination around the current obstacle.
  prefs: []
  type: TYPE_NORMAL
- en: When the **Navigation** panel is visible, then the **Scene** panel displays
    the blue-shaded *walkable* areas, and unshaded, non-walkable areas at the edge
    of the terrain and around each of the two *wall* objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![NPC NavMeshAgent to seek or flee destination while avoiding obstacles](img/1362OT_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds upon the player-controlled 3D cube Unity project that you
    created at the beginning of this chapter. So, make a copy of this project, open
    it, and then follow the steps for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make an object seek or flee from a position, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the **Cube-player** GameObject, since we are going to be creating an
    NPC computer controlled agent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a sphere named **Sphere-arrow** that is positioned at (2, 0.5, 2). Scale
    it as (1,1,1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second sphere named **Sphere-small**. Scale it as (0.5, 0.5, 0.5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Child **Sphere-small** to **Sphere-arrow** and position it at (0, 0, 0.5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Childing** refers to making one GameObject, in the **Hierarchy** panel, a
    child of another GameObject. This is done by dragging the object that is to be
    childed over the object to be the parent. Once completed, the parent-child relationship
    is indicated visually by all children being right-indented and positioned immediately
    below their parent in the **Hierarchy** panel. If a parent object is transformed
    (moved/scaled/rotated), then all its children will also be transformed accordingly.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the **Inspector** panel, add a new NavMeshAgent to **Sphere-arrow**; choose
    **Add Component** | **Navigation** | **Nav Mesh Agent**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Stopping Distance** property of **NavMeshAgent** component to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script class called `ArrowNPCMovement` to GameObject **Sphere-arrow**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ensure that **Sphere-arrow** is selected in the **Inspector** panel for the
    `ArrowNPCMovement` scripted component. Drag **Capsule-destination** over the variable
    **Projectile** called **Target GO**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 3D cube named **Cube-wall** at (-6, 0, 0), and scale it to (1, 2, 10).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another 3D cube named **Cube-wall** at (-2, 0, 6), and scale it to (1,
    2, 7).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the **Navigation** panel by choosing **Window** | **Navigation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: A great place to *dock* the **Navigation** panel is next to the **Inspector**
    panel since you will never be using the **Inspect** and **Navigation** panels
    at the same time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the **Hierarchy** tab, select both of the **Cube-wall** objects (we select
    the objects that are *not* supposed to be a part of the **walkable** parts of
    our scene), and then in the **Navigation** panel, check the **Navigation Static**
    checkbox. Then, click on the **Bake** button at the bottom of the **Navigation**
    panel. When the **Navigation** panel is displayed, you'll see a blue *tint* on
    the parts of the **Scene** that are walkable. Candidate areas for a **NavMeshAgent**
    are supposed to be considered as parts of a path to a destination.![How to do
    it...](img/1362OT_08_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now run your game. You will see the **Sphere-arrow** GameObject automatically
    move towards the **Capsule-destination** GameObject, following a path that avoids
    the two wall objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **NavMeshAgent** component that we added to GameObject **Sphere-arrow**
    does most of the work for us. **NavMeshAgents** need 2 things: a destination location
    to head towards, and a **NavMesh** component of the terrain with walkable/non-walkable
    areas, so that it can plan a path, avoiding obstacles. We created two obstacles
    (the **Cube-wall** objects), and these were selected when we created **NavMesh**
    for this scene in the **Navigation** panel.'
  prefs: []
  type: TYPE_NORMAL
- en: The location for our NPC object to travel towards is the position of the **Capsule-destination**
    GameObject at (-12, 0, 8); but of course, we could just move this object in the
    **Scene** panel at **Design-time**, and its new position would be the destination
    when we run the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C# script class called `ArrowNPCMovement` has two variables: one is a reference
    to the destination GameObject, and the second is a reference to the NavMeshAgent
    component of the GameObject in which our instance of the `ArrowNPCMovement` class
    is also a component. When the scene starts, via the `Start()` method, the **NavMeshAgent**
    sibling component is found, and the `HeadForDestination()` method is called, which
    sets the destination of the NavMeshAgent to the position of the destination GameObject.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the NavMeshAgent has a target to head towards, it will plan a path there
    and will keep moving until it arrives (or gets within the **Stopping Distance**
    if that parameter has been set to a distance greater than zero).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ensure that the object with the NavMeshAgent component is selected in the **Hierarchy**
    panel at runtime to be able to see this navigation data in the **Scene** panel.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Constantly updating the NavMeshAgent destination to Player's character current
    location
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than a destination that is fixed when the scene starts, let's allow the
    **Capsule-destination** object to be moved by the player while the scene is running.
    In every frame, we'll get our NPC arrow to reset the NavMeshAgent's destination
    to wherever the **Capsule-destination** has been moved to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow the user movement of the destination object and frame-by-frame updating
    of NavMeshAgent destination, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an instance of the C# script class called `PlayerControl` as a component
    of **Capsule-destination**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the C# script class called `ArrowNPCMovement` so that we call the `HeadForDestintation()`
    method every frame, that is, from `Update()`, rather than just once in `Start()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, when you run the game, you can use the arrow keys to move the destination
    location, and the NavMeshAgent will update its paths in each frame, based on the
    updated position of the **Capsule-destination** GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: Constantly update NavMeshAgent destination to flee away from Player's character
    current location
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than seeking towards the player's current position, let's make our NPC
    agent always attempt to flee away from the player's location. For example, an
    enemy with very low-health points might run away, and so gain time to regain its
    health before fighting again.
  prefs: []
  type: TYPE_NORMAL
- en: '![Constantly update NavMeshAgent destination to flee away from Player''s character
    current location](img/1362OT_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To instruct our NavMeshAgent to flee away from the player''s location, we need
    to replace the C# script class called `ArrowNPCMovement` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Start()` method caches a reference to the NavMeshAgent component, and also
    calculates the `runAwayDistance` variable to be twice the NavMeshAgent's stopping
    distance (although this can be changed by changing the value of the `runAwayMultiplier`
    variable accordingly). When the distance to the enemy is less than the value of
    this variable, then we'll instruct the computer-controlled object to flee in the
    opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()` method calculates whether the distance to the enemy is within
    the `runAwayDistance`, and if so, it calls the `FleeFromTarget(…)` method that
    passes the location of the enemy as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The `FleeFromTarget(…)` method calculates a point that is the `runAwayDistance`
    Unity units away from the Player's cube, in a direction that is directly away
    from the computer-controlled object. This is achieved by subtracting the enemy
    position vector from the current transform's position. Finally, the `HeadForDestintation(…)`
    method is called, passing the flee-to position, which results in the NavMeshAgent
    being told to set the location as its new destination.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Unity units are arbitrary, since they are just numbers in a computer. However,
    in most cases, it simplifies things to think of distances in terms of meters (1
    Unity unit = 1 meter), and mass in terms of kilograms (1 Unity unit = 1 kilogram).
    Of course, if your game is based on a microscopic world, or a pan-galatic space
    travel and more, then you need to decide what each Unity unit corresponds to for
    your game context. For more discussion of units in Unity, check out the [http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487](http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487)
    link.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the following screenshot illustrates, the NavMeshAgent plans a path to the
    position to flee towards:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Constantly update NavMeshAgent destination to flee away from Player''s character
    current location](img/1362OT_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create a mini point-and-click game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to choose the destination for our **Sphere-arrow** GameObject is
    by the user clicking on an object on the screen, and then the **Sphere-arrow**
    GameObject moving to the location of the clicked object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow the user to select the destination objects with point-and-click, we
    need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `ArrowNPCMovement` component from the **Sphere-arrow** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create some target objects, such as a black cube, a blue sphere, and a green
    cylinder. Note that, to be a target, each object needs to have a collider component
    in order to receive the `OnMouseOver` event messages (when creating primitives
    objects from the Unity menu **Create** | **3D Object**, the colliders are automatically
    created).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance of the following C# script class called `ClickMeToSetDestination`
    to each of the GameObjects that you wish to be a clickable target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, while running the game, when your mouse is over one of the three objects,
    that object will be highlighted yellow. If you click on the mouse button when
    the object is highlighted, the **Sphere-arrow** GameObject will make its way up
    to (but stopping just before) the clicked object.
  prefs: []
  type: TYPE_NORMAL
- en: NPC NavMeshAgent to follow the waypoints in a sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Waypoints are often used as a guide to make autonomously moving NPCs and enemies
    follow a path in a general way (but be able to respond with other directional
    behaviors, such as flee or seek, if friends/predators/prey are sensed nearby).
    The waypoints are arranged in a sequence, so that when the character reaches,
    or gets close to a waypoint, it will then select the next waypoint in the sequence
    as the target location to move towards. This recipe demonstrates an arrow object
    moving towards a waypoint, and then, when it gets close enough, it will choose
    the next waypoint in the sequence as the new target destination. When the last
    waypoint has been reached, it again starts heading towards the first waypoint.
  prefs: []
  type: TYPE_NORMAL
- en: Since Unity's NavMeshAgent has simplified coding NPC behavior, our work in this
    recipe becomes basically finding the position of the next waypoint, and then telling
    the NavMeshAgent that this waypoint is its new destination.
  prefs: []
  type: TYPE_NORMAL
- en: '![NPC NavMeshAgent to follow the waypoints in a sequence](img/1362OT_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds upon the player-controlled 3D cube Unity project that you
    created at the beginning of this chapter. So, make a copy of this project, open
    it, and then follow the steps for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the yellow brick texture image that you need
    in a folder named `Textures` in the `1362_08_06` folder`.`
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To instruct an object to follow a sequence of waypoints, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the **Cube-player** GameObject, since we are going to be creating an
    NPC computer controlled agent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a sphere named **Sphere-arrow**, position at (2, 0.5, 2), and scale it
    as (1,1,1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second sphere named **Sphere-small**, and scale it as (0.5, 0.5, 0.5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Child **Sphere-small** to **Sphere-arrow**, and then position it at (0, 0, 0.5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector,** add a new NavMeshAgent to **Sphere-arrow**, and then choose
    **Add Component** | **Navigation** | **NavMeshAgent**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Stopping Distance** property of the **NavMeshAgent** component to
    `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the **Navigation** panel by choosing **Window** | **Navigation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Bake** button at the bottom of the **Navigation** panel. When
    the **Navigation** panel is displayed, you'll see a blue *tint* on the parts of
    the **Scene** panel that are walkable, which will be all parts of the terrain,
    except near the edges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an instance of the following C# script class called `ArrowNPCMovement`
    to the **Sphere-arrow** GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new capsule object named **Capsule-waypoint-0** at (-12, 0, 8), and
    give it the **waypoint** tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy **Capsule-waypoint -0,** name the copy as **Capsule-waypoint -3,** and
    position this copy at (8, 0, -8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to add some intermediate waypoints numbered 1 and 2 later on. This
    is why our second waypoint here is numbered 3, in case you were wondering.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following C# script class called `WaypointManager` to the **Sphere-arrow**
    GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ensure that **Sphere-arrow** is selected in the **Inspector** for the `WaypointManager`
    scripted component. Drag **Capsule-waypoint-0** and **Capsule-waypoint-3** over
    the public variable projectile called **Way Point 0** and **Way Point 3,** respectively.![How
    to do it...](img/1362OT_08_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the Navigation panel by choosing **Window | Navigation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Bake** button at the bottom of the **Navigation** panel. When
    the **Navigation** panel is displayed, you'll see a blue *tint* on the parts of
    the **Scene** that are *walkable*, which will be all the parts of the terrain,
    except near the edges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, run your game. The arrow object will first move towards one of the waypoint
    capsules, then when it gets close to it, it will slow down, turn around, head
    towards the other waypoint capsule, and keep doing that continuously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **NavMeshAgent** component that we added to the **Sphere-arrow** GameObject
    does most of the work for us. **NavMeshAgents** need two things: a destination
    location to head towards, and a NavMesh, so that it can plan a path, avoiding
    obstacles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We created two possible waypoints to be the location for our NPC to move towards:
    **Capsule-waypoint-0** and **Capsule-waypoint-3**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The C# script class called `WaypointManager` has one job — to return a reference
    to the next waypoint that our NPC should head towards. There are two variables:
    `wayPoint0` and `wayPoint3` that reference to the two waypoint GameObjects in
    our scene. The `NextWaypoint(…)` method takes a single parameter named `current`,
    which is a reference to the current waypoint that the object was moving towards
    (or null). This method''s task is to return a reference to the **next** waypoint
    that the NPC should travel towards. The logic for this method is simple—if `current`
    refers to `waypoint0`, then we''ll return `waypoint3`, otherwise we''ll return
    `waypoint0`. Note that if we pass this `null` method, then we''ll get `waypoint0`
    back (so, it is our default first waypoint).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The C# script class called `ArrowNPCMovement` has three variables: one is a
    reference to the destination GameObject named `targetGO`. The second is a reference
    to the `NavMeshAgent` component of the GameObject in which our instance of the
    class called `ArrowNPCMovement` is also a component. The third variable called
    `WaypointManager` is a reference to the sibling scripted component, an instance
    of our `WaypointManager` script class.'
  prefs: []
  type: TYPE_NORMAL
- en: When the scene starts, via the `Start()`method, the **NavMeshAgent** and `WaypointManager`
    sibling components are found, and the `HeadForDestination()`method is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `HeadForDestination()` method first sets the variable called `targetGO`
    to refer to the GameObject that is returned by a call to `NextWaypoint(…)` of
    the scripted component called `WaypointManager` (that is, `targetGO` is set to
    refer to either **Capsule-waypoint-0** or **Capsule-waypoint-3**). Next, it instructs
    the `NavMeshAgent` to make its destination the position of the `targetGO` GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: Each frame method called `Update()` is called. A test is made to see if the
    distance from the NPC arrow object is close to the destination waypoint. If the
    distance is smaller than twice the *stopping distance*, set in our `NavMeshAgent`,
    then a call is made to `WaypointManager`.`NextWaypoint(…)` to update our target
    destination to be the next waypoint in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: More efficient to avoid using NavMeshes for waypoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NavMeshes are far superior to waypoints, since a location in a general area
    (not a specific point) can be used, and the path finding the algorithm will automatically
    find the shortest route. For a succinct recipe (such as the above), we can simplify
    the implementation of waypoints using NavMeshes for calculating movements for
    us. However, for optimized, real-world games the most common way to move from
    one waypoint to the next is via linear interpolation, or by implementing Craig
    Reynold's Seek algorithm (for details follow the link listed in the Conclusion
    section, at the end of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays of waypoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having a separate C# script class called `WaypointManager` to simply swap between
    **Capsule-waypoint-0** and **Capsule-waypoint-3** may have seemed to be a heavy
    duty and over-engineering task, but this was actually a very good move. An object
    of the script class called `WaypointManager` has the job of returning the *next*
    waypoint. It is now very straightforward to add a more sophisticated approach
    of having an array of waypoints, without us having to change any code in the script
    class called `ArrowNPCMovement`. We can choose a random waypoint to be the next
    destination (see the *Choosing destinations – find nearest (or a random) spawnpoint*
    recipe). Or, we can have an array of waypoints, and choose the next one in the
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve our game to work with an array of waypoints in the sequence to be
    followed, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy **Capsule-waypoint-0**, name the copy as **Capsule-waypoint-1**, and position
    this copy at (0, 0, 8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make four more copies (named **Capsule-waypoint-1**, **2, 4**, **5**), and
    position them as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Capsule-waypoint-1**: Position = (-2, 0, 8)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capsule-waypoint-2**: Position = (8, 0, 8)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capsule-waypoint-4**: Position = (-2, 0, -8)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Capsule-waypoint-5**: Position = (-12, 0, -8)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Replace the C# script class called `WaypointManager` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ensure that **Sphere-arrow** is selected. In the **Inspector** panel for the
    `WaypointManager` scripted component set the size of the `Waypoints` array to
    `6`. Now, drag in all the six capsule waypoint objects called as `Capsule-waypoint`-`0`/`1`/`2`/`3`/`4`/`5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. Now, the **Sphere-arrow** GameObject will first move towards the
    waypoint 0 (top left, and then follow the sequence around the terrain).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you can make it look as if the Sphere is following a yellow brick road.
    Import the provided yellow brick texture, add this to your terrain, and paint
    the texture an oval-shaped path between the waypoints. You may also uncheck the
    Mesh Rendered component for each waypoint capsule, so that the user does not see
    any of the way points, but just the arrow object following the yellow brick path
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `NextWaypoint(…)` method, first we check in case the array is empty,
    in which case an error is logged. Next, the array index for the current waypoint
    GameObject is found (if present in the array). Finally, the array index for the
    next waypoint is calculated using a modulus operator to support a cyclic sequence,
    returning to the beginning of the array after the last element has been visited.
  prefs: []
  type: TYPE_NORMAL
- en: Increased flexibility with a WayPoint class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than forcing a GameObject to follow a single rigid sequence of locations,
    we can make things more flexible by defining a `WayPoint` class, whereby each
    waypoint GameObject has an array of possible destinations, and each of these has
    its own array and so on. In this way a **di-graph** (**directed graph**) can be
    implemented, of which a linear sequence is just one possible instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve our game to work with a di-graph of waypoints, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the scripted `WayPointManager` component from the **Sphere-arrow** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the C# script class called `ArrowNPCMovement` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new C# script class called `WayPoint` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select all the six GameObjects called **Capsule-waypoint -0**/**1**/**2**/**3**/**4**/**5,**
    and add to them a scripted instance of C# class called `WayPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Sphere-arrow** GameObject and add to it a scripted instance of
    C# class called `WayPoint`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the **Sphere-arrow** GameObject is selected: in the **Inspector**
    panel for the `ArrowNPCMovement` scripted component drag **Capsule-waypoint-0**
    into the **Waypoint** public variable slot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to link **Capsule-waypoint-0** to **Capsule-waypoint-1**, **Capsule-waypoint-1**
    to **Capsule-waypoint -2**, and so on. Select **Capsule-waypoint-0**, set its
    `Waypoints` array size to `1`, and drag in **Capsule-waypoint-1**. Next, select
    **Capsule-waypoint-1**, set its **Waypoints** array size to 1, and drag in **Capsule-waypoint-2**.
    Do the following until you finally link **Capsule-waypoint-5** back to **Capsule-waypoint-0**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now have a much more flexible game architecture, allowing GameObjects to
    randomly select one of several different paths at each waypoint reached. In this
    final recipe variation, we have implemented a waypoint sequence, since each waypoint
    has an array of just one linked waypoint. However, if you change the array size
    to 2 or more, you will then be creating a graph of linked waypoints, adding random
    variations in the sequence of waypoints that a computer controlled character follows
    for any given run of your game.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the object group movement through flocking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A realistic, natural-looking, flocking behavior (for example birds or antelopes
    or bats) can be created through creating collections of objects with the following
    four simple rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation**: Avoiding getting too close to neighbors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid Obstacle**: Turning away from an obstacle immediately ahead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alignment**: Moving in the general direction the flock is heading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cohesion**: Moving towards the location in the middle of the flock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each member of the flock acts independently, but needs to know about the current
    heading and location of the members of its flock. This recipe shows you how to
    create a scene with two flocks of cubes: one flock of green cubes and, one flock
    of yellow cubes. To keep things simple, we''ll not worry about separation in our
    recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the object group movement through flocking](img/1362OT_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds upon the player-controlled cube Unity project that you created
    in the first recipe. So, make a copy of this project, open it, and then follow
    the steps for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make a group of objects flock together, please follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Material in the **Project** panel, and name it as `m_green` with the
    Main Color tinted green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Material in the **Project** panel, and name it as `m_yellow` with Main
    Color tinted yellow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 3D Cube GameObject named `Cube-drone` at (0,0,0). Drag the `m_yellow`
    Material into this object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Navigation** | **NavMeshAgent** component to `Cube-drone`. Set the **Stopping
    Distance** property of the **NavMeshAgent** component to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Physics RigidBody** component to `Cube-drone` with the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Mass** is `1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drag** is `0`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Drag** is `0.05`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Gravity** and **Is Kinematic** are both unchecked'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Under **Constrains Freeze Position** for the **Y**-axis is checked
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You will see the following Inspector values for your cube's rigid body component:![How
    to do it...](img/1362OT_08_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the following C# script class called `Drone`, and add an instance as
    a component to the `Cube-drone` GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new empty Prefab named `dronePrefabYellow`, and from the **Hierarchy**
    panel, drag your `Cube-boid` GameObject into this Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag the `m_green` Material into the `Cube-boid` GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new empty Prefab named `dronePrefabGreen`, and from the **Hierarchy**
    panel, drag your `Cube-drone` GameObject into this Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `Cube-drone` GameObject from the **Scene** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# script `Swarm` class to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With **Main Camera** selected in the **Hierarchy** panel, drag `prefab_boid_yellow`,
    from the **Project** panel, over the public variable of **Drone** Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With **Main Camera** selected in the **Hierarchy** panel, add a second instance
    of the script class called `Swarm` to this GameObject, and then drag `prefab_boid_green`,
    from the **Project** panel, over the public variable of **Drone** Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Cube named `wall-left` with the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position = (-15, 0.5, 0)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale = (1, 1, 20)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicate the `wall-left` object by naming the new object as `wall-right`, and
    change the position of `wall-right` to (15, 0.5, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Cube named as `wall-top` with the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position = (0, 0.5, 10)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale = (31, 1, 1)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicate the `wall-top` object by naming the new object as `wall-bottom`, and
    change the position of `wall-bottom` to (0, 0.5, -10).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Sphere named as `Sphere-obstacle` with the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position = (5, 0, 3)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale = (10, 3, 3)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **Hierarchy** panel, select the `Sphere-obstacle` GameObject. Then in
    the **Navigation** panel, check the **Navigation Static** checkbox. Then, click
    on the **Bake** button at the bottom of the **Navigation** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, make the player's red cube larger by setting its scale to (3,3,3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Swarm` class contains three variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`droneCount`: It is an integer referencing the number of the `Swarm` class
    members created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dronePrefab`: It references to the Prefab to be cloned to create swarm members'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Drone`: A list of objects that reference `drones`, a list of all the scripted
    `Drone` components inside all the `Swarm` objects that have been created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon creation, as the scene starts, the `Swarm` script class `Awake()` method
    loops to create `droneCount` swarm members by repeatedly calling the `AddDrone()`
    method. This method instantiates a new `GameObject` from the prefab, and then
    sets the `newDrone` variable to be a reference to the Drone-scripted object, inside
    the new `Swarm` class member. In each frame, the `FixedUpdate()` method loops
    through the list of `Drone` objects by calling their `SetTargetPosition(…)` method,
    and passing in the `Swarm` center location and the average of all the swarm member
    velocities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of this `Swarm` class is made up of two methods: one (`SwarmCenterAverage`)
    returns a Vector3 object, representing the average position of all the `Drone`
    objects, and the other (`SwarmMovementAverage`) returns a `Vector3` object, representing
    the average velocity (movement force) of all the `Drone` objects as described
    in the following list.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SwarmMovementAverage()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the general direction that the swarm is moving in?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is known as **alignment**—a swarm member attempting to move in the same
    direction as the swarm average
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SwarmCenterAverage()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the center position of the swarm?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is known as **cohesion**—a swarm member attempting to move towards the
    center of the swarm
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The core work is undertaken by the `Drone` class. Each drone's `Start(…)` method
    finds and caches a reference to its NavMeshAgent component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each drone''s `UpdateVelocity(…)` method takes as input two Vector3 arguments:
    `swarmCenterAverage` and `swarmMovementAverage`. This method then calculates the
    desired new velocity for this Drone (by simply adding the two vectors), and then
    uses the result (a Vector3 location) to update the NavMeshAgent''s target location.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about flocking Artificial Intelligence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the flocking models in modern computing owe much to the work of Craig
    Reynolds in the 1980s. Learn more about Craig and his boids program at [http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)](http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)).
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have introduced recipes demonstrating a range of player
    and computer controlled characters, vehicles, and objects. Player character controllers
    are fundamental to the usability experience of every game, while the NPC objects
    and characters add rich interactions to many games:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about Unity NavMeshes from this Unity tutorial, which is available
    at [http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes](http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more about the Unity 2D character controllers at [http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers](http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn lots about the computer-controlled moving GameObjects from the classic
    paper entitled *Steering Behaviors For Autonomous Characters* by Craig W. Reynolds,
    presented at the GDC-99 (Game Developer's Conference) at [http://www.red3d.com/cwr/steer/gdc99/](http://www.red3d.com/cwr/steer/gdc99/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn about the Unity 3D character component and control at:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/Manual/class-CharacterController.html](http://docs.unity3d.com/Manual/class-CharacterController.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character](http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every game needs textures—here are some of the sources of free textures suitable
    for many games:'
  prefs: []
  type: TYPE_NORMAL
- en: CG Textures are available at [http://www.cgtextures.com/](http://www.cgtextures.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naldz Graphics blog are available at [http://naldzgraphics.net/textures/](http://naldzgraphics.net/textures/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
