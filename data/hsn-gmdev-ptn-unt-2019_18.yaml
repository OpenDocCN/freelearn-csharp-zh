- en: Adapter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器
- en: In a world full of different types of cables and plugs, we have all become accustomed
    to the concept of adapters. The Adapter pattern will be one of those patterns
    that will be easy for you to grasp, because it correlates so perfectly with our
    real-world experiences with technology. The Adapter pattern's name perfectly reveals
    its core purpose; it offers us a way to seamlessly use old code with new code
    by adding an interface between the code that will act as an Adapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个充满各种类型电缆和插头的世界里，我们都已经习惯了适配器的概念。适配器模式将是那些你容易掌握的模式之一，因为它与我们与技术的现实世界经验完美相关。适配器模式的名字完美地揭示了其核心目的；它通过在充当适配器的代码之间添加一个接口，为我们提供了一种无缝使用旧代码与新代码的方法。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: We will review the basics of the Adapter pattern.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将回顾适配器模式的基础知识。
- en: We will use the Adapter pattern to adjust an online user management system without
    modifying any code.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用适配器模式调整在线用户管理系统，而不修改任何代码。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is a hands-on chapter; you will need to have a basic understanding
    of Unity and C#.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个实践章节；你需要对Unity和C#有一个基本的了解。
- en: 'We will be using the following specific Unity engine and C# language concept:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下特定的Unity引擎和C#语言概念：
- en: Sealed class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封闭类
- en: If you are unfamiliar with this concept, please review it before starting this
    chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个概念不熟悉，请在开始这一章之前复习一下。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看代码的实际效果：
- en: '[http://bit.ly/2UieM9v](http://bit.ly/2UieM9v)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2UieM9v](http://bit.ly/2UieM9v)'
- en: An overview of the Adapter pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式概述
- en: As its name implies, the Adapter pattern adapts two incompatible interfaces;
    like a plug adapter, it doesn't modify what it adjusts, but bridges one interface
    with another. This approach can be beneficial when you are dealing with legacy
    code that you cannot refactor due to its fragility.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，适配器模式适配两个不兼容的接口；就像插头适配器一样，它不修改它调整的内容，而是将一个接口与另一个接口连接起来。当你处理无法因脆弱性而重构的遗留代码时，这种方法可能是有益的。
- en: 'They are two main approaches to implementing the Adapter pattern; here''s a
    quick breakdown:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是实现适配器模式的两种主要方法；以下是一个快速分解：
- en: '**Object adapter**: A simple approach that uses composition'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象适配器**：一种使用组合的简单方法'
- en: '**Class adapter**: A more advanced approach that uses inheritance'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类适配器**：一种使用继承的更高级方法'
- en: Trying to learn both at the same time can get confusing, so in this chapter,
    we will try to focus on the core purpose of the Adapter pattern by implementing
    an object adapter and briefly reviewing the class adapter afterward.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 同时尝试学习这两者可能会让人感到困惑，所以在这一章中，我们将通过实现对象适配器并简要回顾类适配器来尝试专注于适配器模式的核心目的。
- en: 'Let''s take a look at a side-by-side diagram of the Object and Class adapters;
    the core differences can be subtle, but the similarities are apparent:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看对象适配器和类适配器的并列图；核心差异可能很微妙，但相似之处很明显：
- en: '![](img/98b3339b-57b7-4db4-ac53-d2e0a72eaf80.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98b3339b-57b7-4db4-ac53-d2e0a72eaf80.png)'
- en: As you can see, in both cases, the **Adapter** class is positioned between the
    **Client** and the class that's being adapted (**Adaptee**). They only differ
    through their relationship to the **Adaptee**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在两种情况下，**适配器**类都位于**客户端**和被适配的类（**适配者**）之间。它们只是通过它们与**适配者**的关系而有所不同。
- en: 'So, the core differences between the **Object** and **Class** adapters are
    as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**对象**适配器和**类**适配器之间的核心差异如下：
- en: The **Object Adapter** usually contains an instance of the **Adaptee** and translates
    the calls from the **Client** to the **Adaptee**; in other words, it acts slightly
    like a wrapper.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象适配器**通常包含一个**适配者**的实例，并将**客户端**的调用翻译成**适配者**；换句话说，它稍微像一个包装器。'
- en: The **Class Adapter** implements the expected interface while inheriting the
    **Adaptee**; it's a more advanced approach to adaption.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类适配器**实现了预期的接口，同时继承了**适配者**；这是一种更高级的适配方法。'
- en: From experience, I have found that the Adapter pattern can sometimes be confused
    with the Facade pattern. It's essential we understand that the core difference
    between them is that the Facade pattern offers a simple interface to a complicated
    collection of interdependent sub-systems, while the Adapter pattern adapts an
    interface of another class so that it's consistent with the expectations of a
    client.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从经验来看，我发现适配器模式有时会与外观模式混淆。我们必须理解它们之间的核心区别是，外观模式提供了一个简单的接口来访问一组复杂的、相互依赖的子系统，而适配器模式则是将另一个类的接口适配，使其与客户端的期望保持一致。
- en: So, if you're attempting to adapt access to multiple classes with a singular
    interface, then you are probably implementing a Facade and not an Adapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你试图通过一个单一接口适配多个类，那么你很可能实现的是外观模式而不是适配器模式。
- en: Benefits and drawbacks
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好处和缺点
- en: I don't consider the Adapter pattern a long-term solution to architecture issues;
    even though it offers some benefits, its long-term drawbacks should always be
    taken into consideration.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为适配器模式不是解决架构问题的长期解决方案；尽管它提供了一些好处，但其长期缺点始终应该被考虑。
- en: 'The following are the benefits:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些好处：
- en: '**Adapting without modifying**: The main benefit of the Adapter pattern is
    that it offers a standard approach to adapting code without modifying it.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需修改即可适配**：适配器模式的主要好处是它提供了一个在不修改代码的情况下适配代码的标准方法。'
- en: '**Reusability and flexibility**: This pattern permits continuing to use legacy
    code with new systems with a minimal amount of changes; this has an immediate
    return on investment.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性和灵活性**：这个模式允许以最小的更改继续使用遗留代码与新的系统一起使用；这立即带来了投资回报。'
- en: 'The following are the drawbacks:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些缺点：
- en: '**Persisting legacy**: The ability to use legacy code with new systems is cost-effective,
    but in the long term, it can become an issue, because the old code might limit
    your upgrading options as it becomes deprecated and incompatible with new versions
    of Unity or third-party libraries.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久化遗留代码**：使用新系统与遗留代码一起使用是成本效益的，但从长远来看，可能会成为一个问题，因为旧代码可能会限制你的升级选项，因为它变得过时且与新版本的Unity或第三方库不兼容。'
- en: '**Slight overhead**: Because you are redirecting calls between objects, there
    might be a slight performance hit.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻微的性能损耗**：因为你在对象之间重定向调用，可能会有轻微的性能损失。'
- en: From experience, migrating code bases from one version of Unity to another can
    be quite time-consuming. So, don't be surprised if you end up having multiple
    versions of Unity installed on your computer so that you can maintain legacy code
    that's too expensive to upgrade.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从经验来看，将代码库从一个Unity版本迁移到另一个版本可能相当耗时。所以，如果你最终在电脑上安装了多个Unity版本，以便维护那些升级成本过高的遗留代码，请不要感到惊讶。
- en: Use case example
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: Let's suppose that we are dealing with a typical real-world game development
    scenario. Our lead online programmer is on vacation and has left explicit instructions
    that we should not make any modifications to his online player management system
    during his absence. However, our producer needs a change to our online components
    because he wants to showcase our live streaming service to a new investor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在处理一个典型的现实世界游戏开发场景。我们的主要在线程序员正在休假，并明确指示我们在他缺席期间不要对他的在线玩家管理系统进行任何修改。然而，我们的制作人需要对我们在线组件进行更改，因为他想向一位新投资者展示我们的直播服务。
- en: 'To accomplish this in time, we will need to make changes; so, we have two choices:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按时完成这项工作，我们需要做出一些改变；因此，我们有两种选择：
- en: Modify the online player management system directly, even if we are not the
    owner of this section of the code base and don't understand it well.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接修改在线玩家管理系统，即使我们不是这段代码库的所有者，也不太了解它。
- en: Find a way to extend the current system and implement the requested changes
    using a temporary adapter, which will limit the direct modification of our colleague's
    code.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找一种方法来扩展当前系统，并使用临时适配器实现所需更改，这将限制对我们同事代码的直接修改。
- en: With the Adapter pattern, we can implement the second option in a structured
    and consistent manner. In the next section, we will apply this use case with a
    straightforward example, which will undoubtedly showcase the usefulness of this
    pattern.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适配器模式，我们可以以结构化和一致的方式实现第二种选择。在下一节中，我们将通过一个简单的示例应用这个用例，这无疑将展示这个模式的有用性。
- en: Code example
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: As we have mentioned, we are going to implement a change to our online player
    management system by adapting the `OnlinePlayer` class, without modifying it directly.
    The example is straightforward, but from experience, it's always better to learn
    a new pattern by implementing the simplest systems first.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，我们将通过适配`OnlinePlayer`类来实施对我们在线玩家管理系统的一个更改，而不直接修改它。这个例子很简单，但根据经验，最好是通过首先实现最简单的系统来学习一个新的模式。
- en: 'For reasons of brevity, we are going to adapt the way the following `OnlinePlayer`
    class returns the full name of a specific player. Let''s keep in mind that we
    can''t refactor or extend this class; we can only adapt it. We will do this by
    using these two primary forms of the Adapter pattern:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们将适配以下`OnlinePlayer`类返回特定玩家全名的方式。请记住，我们无法重构或扩展这个类；我们只能适配它。我们将通过使用适配器模式的这两种主要形式来完成这项工作：
- en: Object adapter
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象适配器
- en: Class adapter
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类适配器
- en: Object adapter
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象适配器
- en: The following `OnlinePlayer` class can return the first and last name of an
    online player, as well as their full name. However, the programmer that implemented
    the class decided to return the string in a formal naming structure. We need to
    have the full name in a standard sequence, which is the first then the last name.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`OnlinePlayer`类可以返回在线玩家的名字和姓氏，以及他们的全名。然而，实现这个类的程序员决定以正式的命名结构返回字符串。我们需要有一个标准序列的全名，即先名字后姓氏。
- en: 'Of course, we could call the first and last name `GET` functions individually,
    and then concatenate them together in our client, but this means that we will
    have to do it everywhere that we might need to get a user''s full name. In other
    words, we lose consistency and localized control of how the full name is returned.
    You can imagine how this could become risky if we were to adapt something more
    complex, such as an in-game currency transaction system:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以单独调用名字和姓氏的`GET`函数，然后在客户端将它们连接起来，但这意味着我们可能需要在需要获取用户全名的地方都这样做。换句话说，我们失去了对全名返回方式的一致性和本地化控制。您可以想象，如果我们需要适配更复杂的东西，比如游戏中的货币交易系统，这可能会变得多么危险：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There''s something else important to note in the `OnlinePlayer` class; it''s
    `sealed`, which means that we can''t use it as a base class. As a consequence,
    we can''t extend it directly, so adapting it is our only option:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnlinePlayer`类中还有其他一些重要的事情需要注意；它是`sealed`，这意味着我们不能将其用作基类。因此，我们不能直接扩展它，所以适应它是我们的唯一选择：
- en: 'Let''s build an adapter class that will fix our issue with the `GetFullName()`
    function:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建一个适配器类来修复我们`GetFullName()`函数的问题：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the `OnlinePlayerObjectAdapter` class receives an instance of
    the `OnlinePlayer` class and wraps the `GetFullName()` method, so it returns the
    expected full name format. So, we are not modifying or extending the behavior
    of the class that's being adapted, but are merely adjusting it to the client's
    expectations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`OnlinePlayerObjectAdapter`类接收一个`OnlinePlayer`类的实例，并包装`GetFullName()`方法，因此返回预期的全名格式。因此，我们并没有修改或扩展被适配的类的行为，而只是调整它以满足客户端的期望。
- en: 'Let''s implement a `Client` class in order to test our implementation:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现一个`Client`类来测试我们的实现：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have an adapter, we have access to the `OnlinePlayer` class's original
    implementation of the `GetFullName()` function, and also an adapted version of
    it. This approach offers us a lot of flexibility with minimal risk, because we
    are not modifying anything, but are merely adapting.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了适配器，我们可以访问`OnlinePlayer`类中`GetFullName()`函数的原始实现，以及它的一个适配版本。这种方法为我们提供了很多灵活性，风险最小，因为我们没有修改任何东西，而只是进行了适配。
- en: In this section, we implemented a simple example of the object adapter. In the
    next section, we will review a sophisticated approach to the adapter by implementing
    a class adapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们实现了一个简单的对象适配器示例。在下一节中，我们将通过实现类适配器来回顾一个更复杂的适配器方法。
- en: Class adapter
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类适配器
- en: 'There''s one detail that we are going to modify in our `OnlinePlayer` class
    for this section; we are going to remove the sealed modifier, because we want
    to be able to inherit the `OnlinePlayer` class. So, let''s pretend that it was
    never there in the first place:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在我们的`OnlinePlayer`类中修改一个细节；我们将移除密封修饰符，因为我们希望能够继承`OnlinePlayer`类。所以，让我们假装它从一开始就不在那里：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To implement the class adapter approach, let''s follow a step-by-step procedure:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现类适配器方法，让我们遵循以下步骤：
- en: 'Let''s start by implementing a target interface for our clients; we are going
    to call it `IOnlinePlayer`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先为我们的客户端实现一个目标接口；我们将称之为`IOnlinePlayer`：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You should notice that we are adapting the `OnlinePlayer` class by adding a
    new interface that will expose the new functionality for the class that we are
    improving. This approach is flexible, as you will see in the following steps.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到，我们通过添加一个新的接口来适配`OnlinePlayer`类，这将暴露我们正在改进的类的新的功能。这种方法是灵活的，正如你将在以下步骤中看到的那样。
- en: 'Now, in our adapter class, we are going to implement the `IOnliePlayer` interface:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的适配器类中，我们将实现`IOnliePlayer`接口：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It looks simple, but there are a lot of things going on. Let''s try to unwrap
    this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来很简单，但有很多事情在进行中。让我们尝试解开这个谜团：
- en: '`OnlinePlayerClassAdapter` is implementing the `IOnlinePlayer` interface.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnlinePlayerClassAdapter`正在实现`IOnlinePlayer`接口。'
- en: '`OnlinePlayerClassAdapter` is also inheriting the `OnlinePlayer` class.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnlinePlayerClassAdapter`也继承了`OnlinePlayer`类。'
- en: Because we are inheriting the `OnlinePlayer` class, `GetFirstName()` and `GetLastName()`
    are implemented by default.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们继承了`OnlinePlayer`类，`GetFirstName()`和`GetLastName()`默认实现。
- en: '`OnlinePlayerClassAdapter` only needs to explicitly implement `GetFullNameLastFirst()`
    and `GetFullNameFirstLast()`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnlinePlayerClassAdapter`只需要显式实现`GetFullNameLastFirst()`和`GetFullNameFirstLast()`。'
- en: '`GetFullNameLastFirst()` redirects the call to `GetFullName()`, implemented
    inside the `OnlinePlayer` parent class.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetFullNameLastFirst()`将调用重定向到`OnlinePlayer`父类内部实现的`GetFullName()`。'
- en: '`GetFullNameFirstLast()` actually adapts the way that we return a full name
    to a client.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetFullNameFirstLast()`实际上适配了向客户端返回全名的方式。'
- en: 'Let''s look at how we can use this to our advantage with a `Client` class:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看我们如何利用`Client`类来利用这一点：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have decoupled the client from the adapted class because we only need to
    point it towards the adapter during the assignment of the `m_OnlinePlayer` member
    variable. For the client, the interaction with the adapted `OnlinePlayer` class
    is relatively transparent and is consistent with the previous implementations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将客户端与适配类解耦，因为我们只需要在`m_OnlinePlayer`成员变量的赋值过程中将其指向适配器。对于客户端来说，与适配的`OnlinePlayer`类的交互相对透明，并且与之前的实现保持一致。
- en: In other words, we were able to adapt the `OnlinePlayer` class without modifying
    it while maintaining a consistent interface. That's the core purpose of the Adapter
    pattern.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们能够在不修改`OnlinePlayer`类的同时，保持一致的接口来适配它。这就是适配器模式的核心目的。
- en: Summary
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we added the Adapter pattern to our toolbox. It's a type of
    pattern that's very useful in the field, because one of the biggest challenges
    for a professional programmer is dealing with legacy code, which is often maintained
    by people you don't know. So, having a consistent approach to adapting other peoples'
    code without causing regression with unnecessary changes is the secret to a long
    career and a good reputation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将适配器模式添加到我们的工具箱中。这是一种在领域内非常有用的模式，因为对于专业程序员来说，最大的挑战之一就是处理遗留代码，这些代码通常由你不知道的人维护。因此，以一致的方式适配他人的代码而不造成回归和不必要的更改，是长期职业生涯和良好声誉的秘诀。
- en: In the next chapter, we will review the decorator, a more complex and advanced
    structural pattern.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾装饰器，这是一种更复杂和高级的结构模式。
- en: Exercises
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In this chapter, we implemented a straightforward use case of the Adapter pattern,
    but its return on investment is in adapting legacy code into a new context. As
    an exercise, I recommend looking into your Unity projects and finding components
    or systems that you could adapt from one project to another without modifying
    them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了适配器模式的一个简单用例，但其投资回报在于将遗留代码适应到新的环境中。作为一个练习，我建议检查你的Unity项目，寻找可以适配到另一个项目中而不需要修改的组件或系统。
- en: Further reading
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Game Programming Patterns* by Robert Nystrom: [http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《游戏编程模式》* by Robert Nystrom: [http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)'
