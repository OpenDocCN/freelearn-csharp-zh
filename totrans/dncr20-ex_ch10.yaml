- en: Functional Programming with F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to build functional programs with F# that
    leverage .NET Core. We will also master data access layer implementation for microservices
    that use a SQL Server vNext database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics to be covered in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data access layer with F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying SQL vNext with F#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly discussed functional programming and F# in [Chapter 1](ch01.html),
    *Getting Started*. In the F# primer section, we said that functional programming
    treats programs as mathematical expressions and evaluates expressions. It focuses
    on functions and constants, which don't change like variables and states. Functional
    programming solves complex problems with simple code; it is a very efficient programming
    technique for writing bug-free applications; for example, the null exception can
    be avoided using this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is language-agnostic, which means it is not language-specific.
    Functional programming focuses on a structured approach; it doesn't have multiple
    entry and exit points. It doesn't have goto statements, so it is easy to create
    small modules and create large modules using small blocks of structured code (or
    in other words sub-modules), which increases the re-usability of code. One function
    can be used as the input of another function and that function can output a new
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some rules which make it easy for us to understand functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, a function's output never gets affected by outside
    code changes and the function always gives the same result for the same parameters.
    This gives us confidence in the function's behavior that it will give the expected
    result in all the scenarios, and this is helpful for multithread or parallel programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In functional programming, variables are immutable, which means we cannot modify
    a variable once it is initialized, so it is easy to determine the value of a variable
    at any given point at program runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functional programming works on referential transparency, which means it doesn''t
    use assignment statements in a function. For example, if a function is assigning
    a new value to a variable such as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is changing the value of `x,` but if we write it as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is not changing the variable value and the function returns the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming uses recursion for looping. A recursive function calls
    itself and runs till the condition is satisfied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss some functional programming features:'
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions (HOF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One function can take an input argument as another function and it can return
    a function. This originated from calculus and is widely used in functional programming.
    Order can be determined by domain and range of order such as order `0` has no
    function data and order `1` has a domain and range of order `0`, if order is higher
    than `1`, it is called a higher-order function. For example, the `ComplexCalc`
    function takes another function as input and returns a different function as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we created two functions, `sum` and `divide`. We pass
    these two functions as parameters to the `ComplexCalc` function, and it returns
    a value of `4` and `1`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Purity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In functional programming, a function is referred to as a pure function if all
    its input arguments are known and all its output results are also well known and
    declared; or we can say the input and output result has no side-effects. Now,
    you must be curious to know what the side-effect could be, let's discuss it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, the function `sum` takes an integer input and returns
    an integer value and predefined result. This kind of function is referred to as
    a pure function. Let''s investigate the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `verifyData()` function does not take any input
    parameter and does not return anything, but this function is internally calling
    the `getEmp()` function so `verifyData()` depends on the `getEmp()` function.
    If the output of `getEmp()` is not null, it calls another function, called `ProcessForm()` and
    we pass the `getEmp()` function output as input for `ProcessForm(emp)`. In this
    example, both the functions, `getEmp()` and `ProcessForm(),` are unknown at the `verifyData()`
    function level call, also `emp` is a hidden value. This kind of program, which
    has hidden input and output, is treated as a side-effect of the program. We cannot
    understand what it does in such functions. This is different from encapsulation;
    encapsulation hides the complexity but in such function, the functionality is
    not clear and input and output are unreliable. These kinds of function are referred
    to as impure functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the main concepts of pure functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Immutable data**: Functional programming works on immutable data, it removes
    the side-effect of variable state change and gives guarantee of an expected result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Referential transparency**: Large modules can be replaced by small code blocks
    and reuse any existing modules. For example, if `a = b*c` and `d = b*c*e` then
    the value of `d` can be written as `d = a*e`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lazy evaluation**: Referential transparency and immutable data give us the
    flexibility to calculate the function at any given point of time and we will get
    the same result, because a variable will not change its state at any time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In functional programming, looping is performed by recursive functions. In
    F#, to make a function recursive, we need to use the `rec` keyword. By default,
    functions are not recursive in F#, we have to rectify this explicitly using the `rec`
    keyword. Let''s take an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we used the keyword `rec` for the recursion function and if the
    value passed is `0` , the sum would be `0`; otherewise it will add `x + summation(x-1)`,
    like `1+0` then `2+1` and so on. We should take care with recursion because it
    can consume memory heavily.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This converts a function with multiple input parameter to a function which
    takes one parameter at a time, or we can say it breaks the function into multiple
    functions, each taking one parameter at a time. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Closure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Closure is a feature which allows us to access a variable which is not in the
    scope of the current module. It is a way of implementing lexically scoped named
    binding, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `add()` function is internally called by the `addTen()`
    function. In an ideal world, the variables `x` and `y` should not be accessible
    when the `add()` function finishes its execution, but when we are calling the
    function `addTen()`, it returns `15`. So, the state of the function `add()` is
    saved though code execution is finished, otherwise there is no way of knowing
    the `add(10)` value, where `x = 10`. We are able to find the value of `x` because
    of lexical scoping and this is called closure.
  prefs: []
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier about HOF, function composition means getting two functions
    together to create a third new function where the output of a function is the
    input of another function.
  prefs: []
  type: TYPE_NORMAL
- en: There are *n* number of functional programming features. Functional programming
    is a technique to solve problems and write code in an efficient way. It is not
    language-specific, but many languages support functional programming. We can also
    use non-functional languages (such as C#) to write programs in a functional way.
    F# is a Microsoft programming language for concise and declarative syntax. We
    will learn more about F# in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html), *Getting Started*, we discussed the F# language and
    its functional programming features, basic keywords, operators, and variable declarations.
    We also looked at the difference between F# and C#, functions, and the basic input-output
    syntax. In this section, we will discuss F# in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes are types of object which can contain functions, properties, and events.
    An F# class must have a parameter and a function attached like a member. Both
    properties and functions can use the `member` keyword. The following is the class
    definition syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s discuss the preceding syntax for class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type`: In the F# language, class definition starts with a `type` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`access-modifier`: The F# language supports three access modifiers—`public`,
    `private`, and `internal`. By default, it considers the `public` modifier if no
    other access modifier is provided. The `Protected` keyword is not used in the
    F# language, and the reason is that it will become object oriented rather than
    functional programming. For example, F# usually calls a member using a lambda
    expression and if we make a member type protected and call an object of a different
    instance, it will not work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type-name`: It is any of the previously mentioned valid identifiers; the default
    access modifier is `public`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type-params`: It defines optional generic type parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameter-list`: It defines constructor parameters; the default access modifier
    for the primary constructor is `public`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`identifier`: It is used with the optional `as` keyword, the `as` keyword gives
    a name to an instance variable which can be used in the type definition to refer
    to the instance of the type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Inherit`: This keyword allows us to specify the base class for a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let-bindings`: This is used to declare fields or function values in the context
    of a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do-bindings`: This is useful for the execution of code to create an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`member-list`: The `member-list` comprises extra constructors, instance and
    static method declarations, abstract bindings, interface declarations, and event and
    property declarations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we have not defined the parameter type. By default,
    the program considers it as a string value but we can explicitly define a data
    type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Constructor of a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In F#, the constructor works in a different way to any other .NET language.
    The constructor creates an instance of a class. A parameter list defines the arguments
    of the primary constructor and class. The constructor contains `let` and `do`
    bindings, which we will discuss next. We can add multiple constructors, apart
    from the primary constructor, using the `new` keyword and it must invoke the primary
    constructor, which is defined with the class declaration. The syntax of defining
    a new constructor is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example to explain the concept. In the following code, the `StudentDetail`
    class has two constructors: a primary constructor that takes two arguments and
    another constructor that takes no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A let and do binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `let` and `do` binding creates the primary constructor of a class and runs
    when an instance of a class is created.
  prefs: []
  type: TYPE_NORMAL
- en: A function is compiled into a member if it has a `let` binding. If the `let`
    binding is a value which is not used in any function or member, then it is compiled
    into a local variable of a constructor; otherwise, it is compiled into a field
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: The `do` expression executes the initialized code. As any extra constructors
    always call the primary constructor, `let` and `do` bindings always execute, irrespective
    of which constructor is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fields that are created by `let` bindings can be accessed through the methods
    and properties of the class, though they cannot be accessed from static methods,
    even if the static methods take an instance variable as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Generic type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'F# also supports a generic parameter type. We can specify multiple generic
    type parameters separated by a comma. The syntax of a generic parameter declaration
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of the parameter infers where it is used. In the following code, we
    call the `MyGenericClassExample` method and pass a sequence of tuples, so here
    the parameter type became a sequence of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Values related to an object are represented by properties. In object-oriented
    programming, properties represent data associated with an instance of an object.
    The following snippet shows two types of property syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two kinds of property declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Explicitly specify the value**: We should use the explicit way to implement
    the property if it has non-trivial implementation. We should use a member keyword
    for the explicit property declaration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatically generate the value**: We should use this when the property
    is just a simple wrapper for a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many ways of implementing an explicit property syntax based on need:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read-only**: Only the `get()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write-only**: Only the `set()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read/write**: Both `get()` and `set()` methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Backing stores are private values that contain data for properties. The keyword, `member
    val` instructs the compiler to create backing stores automatically and then gives
    an expression to initialize the property. The F# language supports immutable types,
    but if we want to make a property mutable, we should use `get` and `set`. As shown
    in the following example, the `MyClassExample` class has two properties: `propExample1`
    is read-only and is initialized to the argument provided to the primary constructor,
    and `propExample2` is a settable property initialized with a string value `".Net
    Core 2.0"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Automatically implemented properties don't work efficiently with some libraries,
    for example, Entity Framework. In these cases, we should use explicit properties.
  prefs: []
  type: TYPE_NORMAL
- en: Static and instance properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There can be further categorization of properties as static or instance properties.
    Static, as the name suggests, can be invoked without any instance. The self-identifier
    is neglected by the `static` property while it is necessary for the instance property.
    The following is an example of the `static` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Abstract properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Abstract properties have no implementation and are fully abstract. They can
    be virtual. It should not be `private` and if one accessor is `abstract` all others
    must be `abstract`. The following is an example of the `abstract` property and
    how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance and casts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In F#, the inherit keyword is used while declaring a class. The following is
    the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In a derived class, we can access all methods and members of the base class,
    but it should not be a private member. To refer to base class instances in the
    F# language, the base keyword is used.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual methods and overrides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In F#, the `abstract` keyword is used to declare a virtual member. So, here
    we can write a complete definition of the `member` as we use `abstract` for virtual.
    F# is not similar to other .NET languages. Let''s have a look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we declared a virtual method, `virtualMethodExample`,
    in a base class, `MyClassExampleBase`, and overrode it in a derived class, `MyClassExampleDerived`.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An inherited class constructor must be called in a derived class. If a base
    class constructor contains some arguments, then it takes parameters of the derived
    class as input. In the following example, we will see how derived class arguments
    are passed in the base class constructor with inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If a class has multiple constructors, such as `new(str)` or `new()`, and this
    class is inherited in a derived class, we can use a base class constructor to
    assign values. For example, `DerivedClass`, which inherits `BaseClass`, has `new(str1,str2)`,
    and in place of the first string, we pass `inherit BaseClass(str1)`. Similarly
    for blank, we wrote `inherit BaseClass()`. Let''s explore the following example
    for more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Functions and lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lambda expression is one kind of anonymous function, which means it doesn''t
    have a name attached to it. But if we want to create a function which can be called,
    we can use the `fun` keyword with a lambda expression. We can pass the input parameter
    in the lambda function, which is created using the `fun` keyword. This function
    is quite similar to a normal F# function. Let''s see a normal F# function and
    a lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Handling data – tuples, lists, record types, and data manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'F# supports many data types, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primitive types**: `bool`, `int`, `float`, `string` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregate type**: `class`, `struct`, `union`, `record`, and `enum`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Array**: `int[]`, `int[ , ]`, and `float[ , , ]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tuple**: `type1 * type2 *` like (`a,1,2,true`) type is—`char * int * int
    * bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generic**: `list<’x>`, dictionary `< ’key, ’value>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In an F# function, we can pass one tuple instead of multiple parameters of
    different types. Declaration of a `tuple` is very simple and we can assign values
    of a `tuple` to different variables, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding examples, we saw that `tuple` supports pattern matching. These
    are option types and an option type in F# supports the idea that the value may
    or not be present at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'List is a generic type implementation. An F# list is similar to a linked list
    implementation in any other functional language. It has a special opening and
    closing bracket construct, a short form of the standard empty list (`[ ]`) syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cons` operator is used to prepend an item to a list using a double colon `cons(prepend,::)`.
    To append another list to one list, we use the append operator—`@`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Lists are decomposable using pattern matching into a head and a tail part,
    where the head is the first item in the list and the tail part is the remaining
    list, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Record type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `class`, `struct`, `union`, `record`, and `enum` types come under aggregate
    types. The record type is one of them, it can have *n* number of members of any
    individual type. Record type members are by default immutable but we can make
    them mutable. In general, a record type uses the members as an immutable data
    type. There is no way to execute logic during instantiation as a record type don''t
    have constructors. A record type also supports match expression, depending on
    the values inside those records, and they can also again decompose those values
    for individual handling, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we declared a `Box` with `float` a value `width` and
    an integer `height`. When we declare `giftbox`, the compiler automatically detects
    its type as `Box` by matching the value types. We can also specify type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This kind of type declaration is used when we have the same type of fields or
    field type declared in more than one type. This declaration is called a record
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming in F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'F# also supports implementation inheritance, the creation of object, and interface
    instances. In F#, constructed types are fully compatible .NET classes which support
    one or more constructors. We can implement a `do` block with code logic, which
    can run at the time of class instance creation. The constructed type supports
    inheritance for class hierarchy creation. We use the `inherit` keyword to inherit
    a class. If the member doesn''t have implementation, we can use the `abstract`
    keyword for declaration. We need to use the `abstractClass` attribute on the class
    to inform the compiler that it is abstract. If the `abstractClass` attribute is
    not used and `type` has all abstract members, the F# compiler automatically creates
    an `interface` type. Interface is automatically inferred by the compiler as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f70fe4c-bfb1-46c7-bc41-22531b0061d0.png)'
  prefs: []
  type: TYPE_IMG
- en: The `override` keyword is used to override the base class implementation; to
    use the base class implementation of the same member, we use the `base` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: In F#, interfaces can be inherited from another interface. In a class, if we
    use the construct interface, we have to implement all the members in the interface
    in that class, as well. In general, it is not possible to use interface members
    from outside the class instance, unless we upcast the instance type to the required
    interface type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an instance of a class or interface, the object expression syntax
    is used. We need to override virtual members if we are creating a class instance
    and need member implementation for interface instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `exception` keyword is used to create a custom exception in F#; these exceptions
    adhere to Microsoft best practices, such as constructors supplied, serialization
    support, and so on. The keyword `raise` is used to throw an exception. Apart from
    this, F# has some helper functions, such as `failwith`, which throws a failure
    exception at F# runtime, and `invalidop`, `invalidarg`, which throw the .NET Framework
    standard type invalid operation and invalid argument exception, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`try`/`with` is used to catch an exception; if an exception occurred on an
    expression or while evaluating a value, then the `try`/`with` expression could
    be used on the right side of the value evaluation and to assign the value back
    to some other value. `try`/`with` also supports pattern matching to check an individual
    exception type and extract an item from it. `try`/`finally` expression handling
    depends on the actual code block. Let''s take an example of declaring and using
    a custom exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we created a custom exception called `MyCustomExceptionExample,`
    using the `exception` keyword, passing value fields which we want to pass. Then
    we used the `raise` keyword to raise exception passing values, which we want to
    display while running the application or throwing the exception. However, as shown
    here, while running this code, we don''t get our custom message in the error value
    and the standard exception message is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91765e3a-daf7-4587-b354-bd4fa2c4c6df.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see in the previous screenshot that the exception message doesn't contain
    the message that we passed. In order to display our custom error message, we need
    to override the standard message property on the exception type. We will use pattern
    matching assignment to get two values and up-cast the actual type, due to the
    internal representation of the exception object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this program again, we will get the custom message in the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a334951-89eb-43d2-a946-359d7c4bb5e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous screenshot, we can see our custom message with integer and
    string values included in the output. We can also use the helper function, `failwith`,
    to raise a failure exception, as it includes our message as an error message,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding error message can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/998a4b62-ba78-4fd6-95eb-ae01ae6220a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a detailed exception screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a29b4a48-f087-4184-9a18-1d6906e7d23f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of the `invalidarg` helper function follows. In this factorial function,
    we are checking that the value of `x` is greater than zero. For cases where `x`
    is less than `0`, we call `invalidarg`, pass `x` as the parameter name that is
    invalid, and then some error message saying the value should be greater than 0\.
    The `invalidarg` helper function throws an invalid argument exception from the
    standard system namespace in .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Data access layer with F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The F# type provider feature gives the flexibility to access different types
    of data, such as databases, structured types (that is, JSON, XML, CSV, HTML) and
    web-scale data.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's look at data access resources.
  prefs: []
  type: TYPE_NORMAL
- en: CSV, HTML, JSON, and XML data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In F# applications and scripts, `FSharp.Data.dll` is used to implement the functionality
    to access data. It is also useful for structured file formats such as JSON, XML
    and for consuming freebase services. A sample document structure is used for type
    safe access to the document; it works as a type provider, like the CSV type provider
    takes a CSV sample as input and creates a column format data for that sample.
  prefs: []
  type: TYPE_NORMAL
- en: Providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'F# supports different types of provider, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HtmlProvider<>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JsonProvider<>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlProvider<>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorldBankDataProvider<>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CsvProvider<>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s discuss one of them, for example, the CSV type provider. The `FSharp.Data` NuGet
    package contains `CsvProvider`. We can pass a `.csv` file and can read other `.csv`
    files; for example, we created a `.csv` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b94d1a6-7324-412d-927d-9dcc439fe0df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we have another `.csv` file which we want to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17bfca3d-c442-4757-9c16-da1a4e3d17f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what values are calculated by the F# compiler for `Salesitem`, as
    the `ExampleCSV` file is passed, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cba4b196-ef5b-4374-ac90-48401a08ae84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see the compiler is able to detect the header name and took it
    from the second `.csv` file. We can control column types by customizing them using
    the `InferRows` static parameter of `CsvProvider`. To use the full file, we can
    pass `0`. If the first row of a file is not a header, then we can pass the `HasHeaders`
    static parameter value to `false`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42b792ae-5584-4f09-87c1-902afbfc51cf.png)'
  prefs: []
  type: TYPE_IMG
- en: The `FSharp.Data` library also contains helpers for parsing JSON, HTML files,
    and helpers to send HTTP requests. It is available with the name `FSharp.Data`
    on NuGet.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON.NET is a JSON framework for .NET. It has full support with F# serialization
    from and to JSON. We can install using NuGet by using the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Data access tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed data type providers earlier. F# also has dynamic API support for
    faster and dynamic data retrieval. It contains CSV, HTML, JSON parsers, and also
    tools for HTTP request parsing. Let''s briefly discuss each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CSV parser**: To access data dynamically, we can use the CSV parser. The
    afore mentioned CSV provider is built on top of the F# CSV parser. The `FSharp.Data`
    namespace has the `CsvFile` type, which provides two methods for loading data:
    the `Parse` method for string data, and the `Load` method for reading data from
    a file or any web source (example: `CsvFIle.Load(<file path>)`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTML parser**: It parses HTML documents into the DOM. When it gets parsed
    into DOM, F# supports many extension functions for HTML DOM elements, to extract
    information from the web page. Let''s see an example where we will search `.NET
    Core` in Google and parse the first search result page, getting all URLs and hyperlinks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, using `HtmlDocument.Load(),` we are parsing the web page
    into DOM. `resultsDocument` contains all data from the page, as this method will
    make a synchronous web call. We can also make an asynchronous call using the method, `HtmlDocument.AsyncLoad()`.
    To extract data from the result document, we first find all HTML anchor tags and
    then find all `href` tags to get the link and its text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will show all first page search results for `.NET Core` in Google.
    The result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/299b1578-dbb6-44fc-b43a-0edcf4267fb7.png)'
  prefs: []
  type: TYPE_IMG
- en: '**JSON Parser**: The same as the CSV provider, the JSON provider is built on
    top of the JSON parser. We need the same library for all the parsers: `FSharp.Data.dll`.
    It has the `JsonValue` type for parsing. Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`FSharp.Data.Extensions` supports many extension methods such as `value.Properties()` and
    gives a list of properties of a record node.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Utilities**: In the `FSharp.Data` namespace, we have HTTP utilities,
    which are easy and quick for HTTP requests, post data or responses such as get
    status code. HTTP has a few overloaded methods, `requestString` and `AsyncRequest`
    or `AsyncRequestString` and `AsyncRequest`; these can create a simple request
    synchronously or asynchronously, respectively. Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ff45d98-d657-4f55-af0e-4b88dd0c30df.png)'
  prefs: []
  type: TYPE_IMG
- en: SQL data access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In F#, there are multiple libraries for SQL data access. We can browse them
    in NuGet; a few of them are discussed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FSharp.Data.SqlClient`: This library provides `SqlCommandProvider`, which
    gives type safe access to transactional SQL languages. `SqlProgrammabilityProvider`
    provides quick access to a SQL server **stored procedure** (**SP**), tables, and
    functions, and `SqlEnumProvider` generates an `enum` type on the ground of static
    lookup data from an ADO.NET-compliant source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install the `FSharp.Data.SqlClient` library from NuGet, use the following
    command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`FSharp.Data.SQLProvider`: `SQLProvider` is a general .NET/Mono SQL database
    provider. This library supports automatic constraint navigation, CRUD operations
    with identity support, asynchronous operations, LINQ query, functions, SP support,
    record types mapping, .NET Core/.NET Standard, and so on. `SQLProvider` has explicit
    implementation for SQL Server, SQLite, Oracle, MySQL, MSAccess, Firebird, and
    so on. SQL Server and MS Access don''t require third-party ADO.NET connector objects,
    the rest all require this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install the `FSharp.Data.SqlProvider` library from NuGet, use the following
    command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SqlDataConnection`: `SqlDataConnection` type provider generates types,
    for data in SQL DB on live connections. It is for accessing SQL using LINQ queries.
    It requires a Microsoft SQL server. We need three references in a F# project—`FSharp.Data.TypeProviders`,
    `System.Data`, and `System.Data.Linq`. Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SqlEntityConnection`: `SqlEntityConnection` type provider is for accessing
    SQL through LINQ queries and Entity Framework. It works with many databases. We
    need `System.Data.Linq`, `System.Data.Entity`, and `Microsoft.FSharp.Data.TypeProviders`
    references. Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '**ADO.NET**: It provides data access services and functionality for writing
    managed code and consistent data source access for SQL Server, and also data sources
    exposed through OLEDB or XML. Customers can use ADO.NET to connect with any data
    source to retrieve, manipulate, and update data. It can perform all CRUD operations.
    ADO.NET also supports frontend database creation, and middle-tier objects for
    application, tools, or browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web data access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FSharp.Data` library provides many type providers, and in F# it is very
    easy to integrate these data stores in programming. Additional web data stores
    can be accessed using JSON, XML, and CSV format support of F#.
  prefs: []
  type: TYPE_NORMAL
- en: Querying SQL vNext with F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQL vNext is Microsoft''s major release for SQL open source and platform-independent
    DBs. It has introduced major features of the relational database to Linux: in-memory
    OLTP, in-memory columnstores, transparent data encryption, Always Encrypted, and
    row-level security, to make SQL Server the platform of choice across operating
    systems. It provides us with development language selection options, on-premise
    or cloud options, and operating system options such as Linux (Red Hat, SUSE, and
    Ubuntu), and Linux-based Docker containers or windows, adaptive query processing,
    SQL graphs, improvements to analysis services, reporting services, and integration
    services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It has new features such as integration services; till now SQL Server 2016
    SSIS package execution was limited to one machine, but now integration services
    give high-performance package execution by distributing execution on multiple
    machines like parallel execution on different servers. It involves:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SSIS Scale Out Master**: It is for scaling out management and receives package
    execution requests from the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSIS Scale Out Worker**: It pulls execution tasks from the scaled out master
    and works on package execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In an F# program, we can read data using the LINQ query by writing in F# languages
    or by using ADO.NET classes, such as `SqlCommand`. Mostly ADO.NET classes are
    used when we need a simple query call but while calling SP, we must add multiple
    parameters using `SqlParameter` in this approach. We can use dynamic operators
    for dynamic invocations in F#. As we saw providers have helper functions, which
    are used but each has many drawbacks. Let''s discuss how to define a query and
    create helper functions with parameters. Here is some example code for illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To get `Sqlconnection` and other ADO.NET methods, install the NuGet package
    of `System.Data.SqlClient`. In the preceding code, we defined a type `SqlQueryExample`,where
    `Query` is a string and `Parameters` is a tuple type. We created a module, `QueryHelpersForFsharp`,
    where we defined `param` which takes two values, `name` and `value`, and a function, `sqlFunction`
    which takes two parameters, `query` and `parameters`; we are assigning these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the preceding module and use `sqlFunction` and the `param` parameter
    to run a `query.` The `sqlFunction.query<type>` function will run the query and
    it will convert each data row into a specified type object. `Query` is not created
    in the same place where the `query` execution code is written. It is a separate
    piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see an example of data insertion using the ADO.NET function by `FsSql`.
    We will create an entity that is one row of a table and insert it into the DB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert records, we created a type, `changeQueryObject`, which has `query`
    as string type and `parameters` as the `SqlParameter` type `list`. We created
    a `private insert ()` method which takes `Employee` data as input, and here `query`
    has the `insert sql query` string and `parameter` contains a list of `SqlParameters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute this, code the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed functional programming and its features, such
    as higher-order functions, purity, lazy evaluation, currying, and so on. We learned
    about F# basics such as classes, `let` and `do` bindings, generic type parameters,
    properties in F#, how to write functions and lambda expressions in F#, exception
    handling, and so on. Also, we saw different types of data provider in F# and how
    different types of data parser work. We also learned about querying SQL vNext
    with F#. This brings us towards the end of this book but our journey of learning
    has just got started.
  prefs: []
  type: TYPE_NORMAL
