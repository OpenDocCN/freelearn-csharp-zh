<html><head></head><body>
<div class="chapter" title="Chapter&#xA0;6.&#xA0; Sequences - The Core of Data Processing Patterns">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch06"/>
 Chapter 6.  Sequences - The Core of Data Processing Patterns</h1>
</div>
</div>
</div>
<p>In this chapter, we will take a deep dive into one of the most essential and utterly important arrangements of functional programming, that is, sequences. The ability to represent any data transformation as a composition of atomic functions applied to the elements of an arbitrary enumerable data container is a must for a functional programmer. The goal of this chapter is to help you acquire this mental skill. The way towards this goal is paved by the following topics covered here:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">Review the basic data transformations and partition the immense host of standard library data transformation functions by handful of underlying processing patterns</li>
<li class="listitem">Consider the duality of sequence data generators being at once a data and an on-demand calculation</li>
<li class="listitem">Cover how a sequence generalizes arbitrary collections by enumerating them, which represents the pull data transformation pattern</li>
<li class="listitem">Further consider just another pattern of using generated sequences for data drilling</li>
<li class="listitem">Wrap up by practically exploring how the usage of sequences affects the code performance</li>
</ul>
</div>
<div class="section" title="Basic sequence transformations">
<div class="titlepage">
<div>
<div>
<h1 class="title" id="toc_1"><a id="ch06lvl1sec45"/>
 Basic sequence transformations</h1>
</div>
</div>
</div>
<p>Let's revisit the functional solution of the sample problem from <a class="link" title="Chapter 1. Begin Thinking Functionally" href="text00015.html#page">Chapter 1</a>
 , <span class="emphasis">
<em>Begin Thinking Functionally</em>
</span>
 . It represents the common functional pattern of <span class="emphasis">
<em>finding a given property of the collection</em>
</span>
 as follows:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">From the given string literal representing 1000 consecutive single digit characters, make a collection of the collections represented by chunks of just five consecutive single digit characters of the original collection. Each chunk takes the inner characters of a five character-wide stencil aligned first with the left-hand side border of the string literal. The stencil then gets moved to the right by a single character before extracting the next sub collection. This sliding of the stencil to the right is continued until the right-hand side borders of both the stencil and the literal get aligned. To be exact, the main sequence consists of 996 such five character sub sequences.</li>
<li class="listitem">Note that the originally sought-for property of the maximal product of five consecutive digits at this point is substituted with a similar property of the sequence of elements, each representing a candidate group from which the sought-for property originates. It is worth pointing out that in order to solve the original problem, <span class="emphasis">
<em>all</em>
</span>
 elements of this secondary sequence must be taken into account (other patterns may differ in this respect, for example, <span class="emphasis">
<em>finding any sequence element with a given property</em>
</span>
 ).</li>
<li class="listitem">Perform a complete scan of the substitute sequence, looking for the maximal value of the sought-for property, which is the product of the constituents of the inner sequence representing an element of the outer sequence that substitutes the original string literal.</li>
</ul>
</div>
<p>Those of you who are attentive to detail may have already spotted the similarity of the preceding solution approach to the <span class="strong">
<strong>MapReduce</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/MapReduce">https://en.wikipedia.org/wiki/MapReduce</a>
 ) pattern, just without the possible partitioning and parallelization of the <span class="strong">
<strong>map</strong>
</span>
 phase for now. This similarity is not coincidental. After implementing a serious amount of F# <span class="strong">
<strong>ETL</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Extract,_transform,_load">https://en.wikipedia.org/wiki/Extract,_transform,_load</a>
 ) tasks, big and small for enterprise <span class="strong">
<strong>Line of Business</strong>
</span>
 (<span class="strong">
<strong>LOB</strong>
</span>
 ) applications, I can conclude that the part of the F# core library covering basic operations upon enumerable sequences, namely the <code class="literal">Collections.seq</code>
 library module of the <span class="strong">
<strong>Microsoft.FSharp.Collections</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ee353635.aspx">https://msdn.microsoft.com/en-us/library/ee353635.aspx</a>
 ) namespace, has already distilled the typical functional patterns of data sequence processing. Any effective F# developer should be conversant in representing a sought-for data transformation solution at hand into a combination of these library functions from <code class="literal">Collections.seq</code>
 .</p>
<p>Based on my own experience, this set of 70 library functions (for version 4.0 of F#) is hard to grok when you consider it as a list that is just alphabetically ordered by the function name. It is hard to memorize what exactly this or that function is doing without distinguishing their commonalities and differences. This perception can be facilitated if we start seeing a certain data transformation pattern being implemented by each of these functions. These patterns stem from years of accumulated experience in applying functional programming to data processing and are coined into the selection of functions that the F# designers have slated for inclusion into the core library.</p>
<p>I believe that by observing the <code class="literal">Collection.seq</code>
 library constituents from this data processing pattern relationship angle, the following function groups can be distinguished:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<span class="strong">
<strong>Aggregates</strong>
</span>
 : These functions traverse the sequence in its entirety, returning a single value calculated upon the sequence elements.</li>
<li class="listitem">
<span class="strong">
<strong>Generators</strong>
</span>
 : These functions produce sequences "out of thin air", or seriously, sequences of special kinds (such as empty typed sequence) and sequences defined either by a quantitative relation between the element and its sequence order number or just by a recurrently defined function deriving the next element based on the previous element(s).</li>
<li class="listitem">
<span class="strong">
<strong>Wrappers and Type Converters</strong>
</span>
 : These functions either wrap the entire sequence into a useful property (caching is a good example of a wrap) or just convert the sequence to other collection types (lists or arrays).</li>
<li class="listitem">
<span class="strong">
<strong>Appliers</strong>
</span>
 : These functions just traverse the sequence, applying the given calculation to each element for the sake of a side effect, for example, to print out sequence elements as strings.</li>
<li class="listitem">
<span class="strong">
<strong>Recombinators</strong>
</span>
 : These functions shuffle the sequence or extract its elements in a type-uniform manner; in other words, for a sequence of type <code class="literal">'T</code>
 dealing exclusively with <code class="literal">seq&lt;'T&gt;</code>
 or <code class="literal">'T</code>
 objects. For example, create a new sequence by skipping the first 100 elements of the original one.</li>
<li class="listitem">
<span class="strong">
<strong>Filters</strong>
</span>
 : These functions are concerned with the selection of elements that conform to an arbitrary condition(s). For example, try to find the first element of a sequence for which a given predicate function returns true.</li>
<li class="listitem">
<span class="strong">
<strong>Mappers</strong>
</span>
 : These functions change shape and/or the type of the original sequence(s) by producing a transformed sequence(s), for example, a zipping function that takes two input sequences and produces the single result sequence with each element being a tuple that combines elements from both input sequences sharing the same order number.</li>
</ul>
</div>
<p>Equipped with this classification approach, I've partitioned the library functions by the following set of patterns. Under each pattern, all the relevant library functions are listed along with their signatures. I encourage you to explore the signatures in order to spot the commonalities responsible for each group formation.</p>
<p>Additional information for those of you who are eager to dig deeper is given in the <code class="literal">Ch6_1.fsx</code>
 script of this book's accompanying code, where the use of each of the library functions is illustrated by a brief code sample.</p>
<div class="section" title="The aggregation pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_2"><a id="ch06lvl2sec71"/>
 The aggregation pattern</h2>
</div>
</div>
</div>
<pre class="programlisting">average : seq&lt;^T&gt; -&gt; ^T (requires member (+) and member    DivideByInt and member get_Zero)averageBy : ('T -&gt; ^U) -&gt; seq&lt;'T&gt; -&gt; ^U (requires ^U with static    member (+) and ^U with static member DivideByInt and ^U with    static member Zero) 
fold : ('State -&gt; 'T -&gt; 'State) -&gt; 'State -&gt; seq&lt;'T&gt; -&gt; 'State 
length : seq&lt;'T&gt; -&gt; int 
sum : seq&lt;^T&gt; -&gt; ^T (requires member (+) and member get_Zero) 
sumBy : ('T -&gt; ^U) -&gt; seq&lt;'T&gt; -&gt; ^U (requires ^U with static  member (+) and ^U with static member Zero) 
max : seq&lt;'T&gt; -&gt; 'T (requires comparison) 
maxBy : ('T -&gt; 'U) -&gt; seq&lt;'T&gt; -&gt; 'T (requires comparison) 
min : seq&lt;'T&gt; -&gt; 'T (requires comparison) 
minBy : ('T -&gt; 'U) -&gt; seq&lt;'T&gt; -&gt; 'T (requires comparison) 
isEmpty : seq&lt;'T&gt; -&gt; bool 
reduce : ('T -&gt; 'T -&gt; 'T) -&gt; seq&lt;'T&gt; -&gt; 'T 
exactlyOne : seq&lt;'T&gt; -&gt; 'T 
compareWith : ('T -&gt; 'T -&gt; int) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt; -&gt; int 
</pre>
</div>
<div class="section" title="The generation pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_3"><a id="ch06lvl2sec72"/>
 The generation pattern</h2>
</div>
</div>
</div>
<pre class="programlisting">empty : seq&lt;'T&gt;
init : int -&gt; (int -&gt; 'T) -&gt; seq&lt;'T&gt;
initInfinite : (int -&gt; 'T) -&gt; seq&lt;'T&gt;
singleton : 'T -&gt; seq&lt;'T&gt;
unfold : ('State -&gt; 'T * 'State option) -&gt; 'State -&gt; seq&lt;'T&gt;</pre>
</div>
<div class="section" title="The wrapping and type conversion pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_4"><a id="ch06lvl2sec73"/>
 The wrapping and type conversion pattern</h2>
</div>
</div>
</div>
<pre class="programlisting">cast : IEnumerable -&gt; seq&lt;'T&gt;
cache : seq&lt;'T&gt; -&gt; seq&lt;'T&gt;
delay : (unit -&gt; seq&lt;'T&gt;) -&gt; seq&lt;'T&gt;
readonly : seq&lt;'T&gt; -&gt; seq&lt;'T&gt;
toArray : seq&lt;'T&gt; -&gt; 'T []
toList : seq&lt;'T&gt; -&gt; 'T
list ofArray : 'T array -&gt; seq&lt;'T&gt;
ofList : 'T list -&gt; seq&lt;'T&gt;</pre>
</div>
<div class="section" title="The application pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_5"><a id="ch06lvl2sec74"/>
 The application pattern</h2>
</div>
</div>
</div>
<pre class="programlisting">iter : ('T -&gt; unit) -&gt; seq&lt;'T&gt; -&gt; unit
iter2 : ('T1 -&gt; 'T2 -&gt; unit) -&gt; seq&lt;'T1&gt; -&gt; seq&lt;'T2&gt; -&gt; unit
iteri : (int -&gt; 'T -&gt; unit) -&gt; seq&lt;'T&gt; -&gt; unit</pre>
</div>
<div class="section" title="The recombination pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_6"><a id="ch06lvl2sec75"/>
 The recombination pattern</h2>
</div>
</div>
</div>
<pre class="programlisting">append : seq&lt;'T&gt; -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;
collect : ('T -&gt; 'Collection) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'U&gt;
concat : seq&lt;'Collection&gt; -&gt; seq&lt;'T&gt;
head : seq&lt;'T&gt; -&gt; 'T
last : seq&lt;'T&gt; -&gt; 'T
nth : int -&gt; seq&lt;'T&gt; -&gt; 'T
skip : int -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;
take : int -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;
sort : seq&lt;'T&gt; -&gt; seq&lt;'T&gt;
sortBy : ('T -&gt; 'Key) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;
truncate : int -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;
distinct : seq&lt;'T&gt; -&gt; seq&lt;'T&gt;
distinctBy : ('T -&gt; 'Key) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;</pre>
</div>
<div class="section" title="The filtering pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_7"><a id="ch06lvl2sec76"/>
 The filtering pattern</h2>
</div>
</div>
</div>
<pre class="programlisting">choose : ('T -&gt; 'U option) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'U&gt;
exists : ('T -&gt; bool) -&gt; seq&lt;'T&gt; -&gt; bool
exists2 : ('T1 -&gt; 'T2 -&gt; bool) -&gt; seq&lt;'T1&gt; -&gt; seq&lt;'T2&gt; -&gt; bool
filter : ('T -&gt; bool) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;
find : ('T -&gt; bool) -&gt; seq&lt;'T&gt; -&gt; 'T
findIndex : ('T -&gt; bool) -&gt; seq&lt;'T&gt; -&gt; int
forall : ('T -&gt; bool) -&gt; seq&lt;'T&gt; -&gt; bool
forall2 : ('T1 -&gt; 'T2 -&gt; bool) -&gt; seq&lt;'T1&gt; -&gt; seq&lt;'T2&gt; -&gt; bool
pick : ('T -&gt; 'U option) -&gt; seq&lt;'T&gt; -&gt; 'U
skipWhile : ('T -&gt; bool) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;
takeWhile : ('T -&gt; bool) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;
tryFind : ('T -&gt; bool) -&gt; seq&lt;'T&gt; -&gt; 'T option
tryFindIndex : ('T -&gt; bool) -&gt; seq&lt;'T&gt; -&gt; int
option tryPick : ('T -&gt; 'U option) -&gt; seq&lt;'T&gt; -&gt; 'U option
where : ('T -&gt; bool) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T&gt;</pre>
</div>
<div class="section" title="The mapping pattern">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_8"><a id="ch06lvl2sec77"/>
 The mapping pattern</h2>
</div>
</div>
</div>
<pre class="programlisting">countBy : ('T -&gt; 'Key) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'Key * int&gt;
groupBy : ('T -&gt; 'Key) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'Key * seq&lt;'T&gt;&gt;
pairwise : seq&lt;'T&gt; -&gt; seq&lt;'T * 'T&gt;
map : ('T -&gt; 'U) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'U&gt;
map2 : ('T1 -&gt; 'T2 -&gt; 'U) -&gt; seq&lt;'T1&gt; -&gt; seq&lt;'T2&gt; -&gt; seq&lt;'U&gt;
mapi : (int -&gt; 'T -&gt; 'U) -&gt; seq&lt;'T&gt; -&gt; seq&lt;'U&gt;
scan : ('State -&gt; 'T -&gt; 'State) -&gt; 'State -&gt; seq&lt;'T&gt; -&gt; seq&lt;'State&gt; windowed : int -&gt; seq&lt;'T&gt; -&gt; seq&lt;'T []&gt;
zip : seq&lt;'T1&gt; -&gt; seq&lt;'T2&gt; -&gt; seq&lt;'T1 * 'T2&gt;
zip3 : seq&lt;'T1&gt; -&gt; seq&lt;'T2&gt; -&gt; seq&lt;'T3&gt; -&gt; seq&lt;'T1 * 'T2 * 'T3&gt;</pre>
</div>
</div>
</div>


<div class="section" title="The sequence: Duality of data and calculation">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch06lvl1sec46"/>
 The sequence: Duality of data and calculation</h1>
</div>
</div>
</div>
<p>What makes the F# sequence so ambient and versatile is its dual nature. Being a strongly typed generic data collection, it exposes the contained data via two archetypal .NET interfaces of the <code class="literal">System.Collections.Generic</code>
 namespace, namely <code class="literal">IEnumerable&lt;T&gt;</code>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/9eekhta0(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/9eekhta0(v=vs.110).aspx</a>
 ) and <code class="literal">IEnumerator&lt;T&gt;</code>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx</a>
 ).</p>
<p>These interfaces personify the classic data pull protocol, where a data consumer actively pulls data from the producer. Indeed, the type of <code class="literal">seq&lt;'T&gt;</code>
 in the F# is defined as the following abbreviation:</p>
<pre class="programlisting">type seq&lt;'T&gt; = System.Collections.Generic.IEnumerable&lt;'T&gt; 
</pre>
<p>The preceding line of code means in practice that each F# sequence is a data collection, which can be traversed by getting an <span class="emphasis">
<em>enumerator</em>
</span>
 that allows you to stir through the sequence from its head towards its tail, obtaining the values of its elements. The enumerator itself can be obtained using the <code class="literal">GetEnumerator()</code>
 method of the <code class="literal">IEnumerable&lt;'T&gt;</code>
 interface.</p>
<p>With the enumerator, which in turn implements the <code class="literal">IEnumerator&lt;'T&gt;</code>
 interface, the sequence can be traversed using the pair of members that constitute this interface: the <code class="literal">Current</code>
 property, which gets the value of the sequence element at the current position of the enumerator, and the <code class="literal">MoveNext()</code>
 method, which advances the position of the enumerator to the next element of the sequence.</p>
<p>Rather boring, right? Well, it might be boring when being applied to <span class="emphasis">
<em>materialized</em>
</span>
 data collections such as the F# list, where all elements exist in the physical memory space. However, nothing in the preceding scheme insists upon the element materialization! It doesn't require much mental effort to imagine <code class="literal">IEnumerator&lt;'T&gt;</code>
 being implemented by a calculation that returns the freshly constructed value of <code class="literal">'T</code>
 in response to getting the <code class="literal">Current</code>
 property, and for <code class="literal">MoveNext()</code>
 , it just advances the imaginable current position marker of the sequence. The whole arrangement is <span class="emphasis">
<em>immaterial</em>
</span>
 with regard to the memory space occupied by elements, as there is no need to keep more than just one materialized <code class="literal">Current</code>
 element, right? With that, you just rediscovered the inner workings of the F# sequences!</p>
<div class="section" title="Sequence as a lazy data collection">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_1"><a id="ch06lvl2sec78"/>
 Sequence as a lazy data collection</h2>
</div>
</div>
</div>
<p>The F# sequences do not eagerly materialize data elements in the memory. This feature aligns very well with the data pull protocol. That is, the current sequence element is not required unless the sequence enumerator has reached its position in the sequence after a series of <code class="literal">MoveNext()</code>
 method invocations and the element value has been demanded via getting the enumerator's <code class="literal">Current</code>
 property.</p>
<p>However, in order to really master the F# sequences, it is important that you understand its nuances. In particular, it is important to be aware of whether sequence elements are materialized or not. If a sequence has been calculated on the enumerator's demand and is not being converted from a materialized collection, such as a list or an array, or is not cached, then there is normally no backing memory where sequence element values are persisted. On the contrary, if a sequence has been produced from a concrete collection by a library function, for example, <code class="literal">Seq.ofList</code>
 , then at least one instance of the original list must be present for the entire lifespan of the derived collection, as this list can be completely arbitrary and no way exists to recreate it from scratch in a manner similar to a sequence being re-enumerated multiple times if the re-enumeration is cheap and performance considerations do not prompt for caching.</p>
</div>
<div class="section" title="Sequence as a calculation">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_2"><a id="ch06lvl2sec79"/>
 Sequence as a calculation</h2>
</div>
</div>
</div>
<p>As I've just mentioned, a sequence can be an enumeration atop a concrete data collection where the enumerator is implemented on the collection's side. However, more interesting cases represent sequences that have an enumerator that programmatically generates sequence elements upon the traversal pull demand. These might be different, syntactically sugared forms as sequence comprehensions, sequence computation expressions, or standard library functions representing the <span class="emphasis">
<em>generator pattern</em>
</span>
 considered at the beginning of the chapter. As a last resort, a sequence can be brought to life in a fully de-sugared manner by implementing some required interfaces. The last approach is the most tedious and error-prone; however, it grants unprecedented flexibility in comparison to other methods. In a majority of development situations, the custom sequence enumerator implementation is unwarranted; however, there might be some situations where there is simply no alternative to the custom implementation. This topic will be my next subject.</p>
</div>
<div class="section" title="Sequence as an enumerator interface wrapper">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_3"><a id="ch06lvl2sec80"/>
 Sequence as an enumerator interface wrapper</h2>
</div>
</div>
</div>
<p>Although implementing a custom sequence is a tedious task, it's not rocket science. I'm going to walk you through the process and make you <span class="emphasis">
<em>understand</em>
</span>
 it. No matter how simple or complex the custom sequence is, the implementation process will be the same.</p>
<p>To begin with, what do you think defines the sequence behavior? Apparently, it is not syntactic constructions used for sequence traversing, and it does not matter whether it's sugared or not sugared. All implementation specifics are abstracted by the entity standing behind any sequence (and even more broadly, behind any .NET collection): the <span class="strong">
<strong>enumerator</strong>
</span>
 . Enumerator is a class that must implement the previously mentioned strongly typed interface <code class="literal">IEnumerator&lt;'T&gt;</code>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx</a>
 ) of the <code class="literal">System.Collections.Generic</code>
 namespace. In turn, <code class="literal">IEnumerator&lt;'T&gt;</code>
 inherits from two other interfaces: the routine <code class="literal">System.IDisposable</code>
 interface and the legacy untyped <code class="literal">IEnumerator</code>
 interface of the <code class="literal">System.Collections</code>
 namespace. (Pay attention to the difference between typed <code class="literal">System.Collections.Generic</code>
 and untyped <code class="literal">System.Collections</code>
 namespaces). <code class="literal">IEnumerator&lt;'T&gt;</code>
 overrides the <code class="literal">Current</code>
 property and inherits the <code class="literal">MoveNext()</code>
 and <code class="literal">Reset()</code>
 methods of the <code class="literal">IEnumerator</code>
 interface. As these relationships between involved components are quite intricate, I have provided a component relationship diagram in the following figure to facilitate comprehension:</p>
<div class="mediaobject"><img src="Image00023.jpg" alt="Sequence as an enumerator interface wrapper"/>
<div class="caption">
<p>The relationship between components constituting the F# sequence implementation</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Considering these intricacies, the implementation plan for any custom F# sequence is as following:</p>
<div class="orderedlist">
<ol class="orderedlist arabic">
<li class="listitem">Provide a custom <code class="literal">Enumerator</code>
 class for the sequence that implements <code class="literal">System.Collections.Generic.IEnumerator&lt;'T&gt;</code>
 , <code class="literal">System.Collections.IEnumerator</code>
 , and <code class="literal">System.IDisposable</code>
 interfaces. For the first interface, just implement an override of the <code class="literal">Current</code>
 property, and the rest of the implementation goes into nongeneric <code class="literal">IEnumerator</code>
 .</li>
<li class="listitem">Provide a factory function that is similar to the <code class="literal">GetEnumerator()</code>
 methods of generic .NET collections that have a <code class="literal">unit -&gt;</code>
 <code class="literal">System.Collections.Generic.IEnumerator&lt;'T&gt;</code>
 signature. This function constructs the requested instance of the enumerator passing through its own arguments directly to the constructor, then it upcasts the constructed instance into <code class="literal">System.Collections.Generic.IEnumerator&lt;'T&gt;</code>
 and returns the result as a function of the previously listed signature.</li>
<li class="listitem">Provide another factory function, this time to build a sought-for sequence out of the function built in Step 2.</li>
</ol>
<div style="height: 10px; width: 1px;"/>
</div>
<p>As this may still sound a bit complicated, let's take a quick walk-through. I want us to implement the easiest thing: a strongly typed empty sequence, which is a sequence without elements, when its enumerator does not have anything to enumerate.</p>
<p>At the same time, apparently, it must be a normal sequence similar to any other native sequence from .NET libraries or a sugared one constructed with the F# language facilities or core libraries. Let's do this.</p>
<div class="section" title="Step 1 - The custom enumerator implementation">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_4"><a id="ch06lvl3sec17"/>
 Step 1 - The custom enumerator implementation</h3>
</div>
</div>
</div>
<p>The behavior of an empty sequence is pretty straightforward: both typed and untyped versions of the <code class="literal">Current</code>
 property never have a chance to work as any attempt to enumerate empty sequence must immediately terminate; <code class="literal">MoveNext()</code>
 always returns <code class="literal">false</code>
 , indicating that the end of the sequence has already been reached. Expressed in the F# code, these considerations are shown in the following snippet (<code class="literal">Ch6_2.fsx</code>
 ):</p>
<pre class="programlisting">type private DummyEnumerate&lt;'T&gt;() = 
  interface System.Collections.Generic.IEnumerator&lt;'T&gt; with 
    member x.Current = Unchecked.defaultof&lt;'T&gt; 
 
  interface System.Collections.IEnumerator with  
    member x.Current = box Unchecked.defaultof&lt;'T&gt; 
    member x.MoveNext() = false 
    member x.Reset() = () 
 
  interface System.IDisposable with  
    member x.Dispose() = () 
</pre>
<p>As mentioned earlier, <code class="literal">System.Collections.Generic.IEnumerator&lt;'T&gt;</code>
 overrides <code class="literal">Current</code>
 and inherits <code class="literal">MoveNext()</code>
 and <code class="literal">Reset()</code>
 of <code class="literal">System.Collections.IEnumerator</code>
 . Both <code class="literal">Current</code>
 properties use the typed default value; the <code class="literal">Current</code>
 property of the untyped enumerator boxes this default value according to the specification. Step 1 is now complete.</p>
</div>
<div class="section" title="Step 2 - The custom enumerator factory">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_5"><a id="ch06lvl3sec18"/>
 Step 2 - The custom enumerator factory</h3>
</div>
</div>
</div>
<p>Step 2 is quite simple, especially in our case, where the implemented sequence does not have any specifics to be communicated to the enumerator at the time of construction as shown in the following code (<code class="literal">Ch6_2.fsx</code>
 ):</p>
<pre class="programlisting">let makeDummyEnumerator&lt;'T&gt;() = 
  fun() -&gt; (new DummyEnumerate&lt;'T&gt;() 
    :&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;) 
</pre>
<p>Step 2 is now complete too.</p>
</div>
<div class="section" title="Step 3 - The custom sequence factory">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_6"><a id="ch06lvl3sec19"/>
 Step 3 - The custom sequence factory</h3>
</div>
</div>
</div>
<p>This one is a breeze, thanks to the great <span class="strong">
<strong>object expressions</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233237.aspx">https://msdn.microsoft.com/en-us/library/dd233237.aspx</a>
 ) feature of the F# as shown (<code class="literal">Ch6_2.fsx</code>
 ):</p>
<pre class="programlisting">let makeSeq enumerator = 
{ 
  new System.Collections.Generic.IEnumerable&lt;_&gt; with 
    member x.GetEnumerator() = enumerator() 
  interface System.Collections.IEnumerable with 
    member x.GetEnumerator() = 
    (enumerator() :&gt; System.Collections.IEnumerator) 
} 
</pre>
<p>Here we go; it is easy to spot that this particular piece does not in any way depend on the produced sequence and is a good candidate to be a member of a Helpers library. The implementation is complete.</p>
<p>Now is a perfect moment to give it a test drive to check whether everything is really OK and that I did not miss anything. The results of a concise testing are reflected in the following screenshot:</p>
<div class="mediaobject"><img src="Image00024.jpg" alt="Step 3 - The custom sequence factory"/>
<div class="caption">
<p>Testing the implemented empty sequence</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>The empty sequence is created with the following code:</p>
<pre class="programlisting">let ss = makeSeq (makeDummyEnumerator&lt;int&gt;()) 
</pre>
<p>Then some checks are performed as shown:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">ss |&gt; Seq.isEmpty</code>
 , as expected, returns <code class="literal">true</code>
</li>
<li class="listitem">
<code class="literal">ss |&gt; Seq.length</code>
 , as expected, equals <code class="literal">0</code>
</li>
<li class="listitem">An attempt to skip some elements with <code class="literal">ss |&gt; Seq.skip 10</code>
 fails with the expected diagnostics</li>
</ul>
</div>
<p>Before we switch to the next topic, I want to reiterate this: the de-sugared custom sequence implementation using bare .NET interfaces is not much fun. The good thing about it is that in most situations, you simply do not need to descend to this level. Syntactically sugared language constructions and core library functions will do the same job. However, once in a while, you will need to do something special, such as counting the number of times your code traverses a sequence, and this technique will be at your service.</p>
</div>
</div>
</div>


<div class="section" title="Sequence of an indefinite length as a design pattern">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch06lvl1sec47"/>
 Sequence of an indefinite length as a design pattern</h1>
</div>
</div>
</div>
<p>The conventional engineering vision of data transformations is that they occur over finite collections materialized in the memory, hence allowing these collections to be enumerated with <code class="literal">Seq.length</code>
 , yielding a number of elements. However, the F# sequences (as well as .NET <code class="literal">IEnumerable&lt;T&gt;</code>
 per se) grant the following generalization: in some cases, a more math-centric vision might be useful, which suggests looking at sequences as countable but not necessarily finite.</p>
<p>A meticulous reader may immediately object that the <span class="emphasis">
<em>countable</em>
</span>
 entity, when applied to practical computing, is necessarily finite because eventually, it is limited by underlying physical hardware, which comes out in boundary values, for example:</p>
<pre class="programlisting">System.Int32.MaxValue = 2147483647 
System.Int64.MaxValue = 9223372036854775807L 
</pre>
<p>However, I would oppose this objection by saying that this mere consideration does not in any way limit the length of the F# sequences that might be produced. As a proof, let's implement at the low level without using any F# syntactic sugar the <span class="strong">
<strong>repeater</strong>
</span>
 , or sequence that when being given an element of any type returns the endless repetition of the given element.</p>
<p>I will begin with a plain vanilla <code class="literal">IEnumerator&lt;'T&gt;</code>
 implementation as shown in the following code (<code class="literal">Ch6_3.fsx</code>
 ):</p>
<pre class="programlisting">type private Repeater&lt;'T&gt;(repeated) = 
  let _repeated = repeated 
    interface System.Collections.Generic.IEnumerator&lt;'T&gt; with 
    member x.Current = _repeated 
 
  interface System.Collections.IEnumerator with  
    member x.Current = box _repeated 
    member x.MoveNext() = true 
    member x.Reset() = () 
 
  interface System.IDisposable with 
    member x.Dispose() = () 
</pre>
<p>The preceding snippet is quite straightforward. The <code class="literal">Repeater&lt;'T&gt;</code>
 type defines a class with which the single default constructor obtains the element to be repeated as <code class="literal">repeated</code>
 and persists it within the class instance as <code class="literal">_repeated</code>
 .</p>
<p>Then, as a fulfillment of the <code class="literal">System.Collections.Generic.IEnumerator&lt;'T&gt;</code>
 contract, this interface is implemented with the single property <code class="literal">Current</code>
 returning the persisted <code class="literal">_repeated</code>
 value.</p>
<p>Then, the implementation of the nongeneric <code class="literal">System.Collections.IEnumerator</code>
 interface follows with its three contract methods. Here is the place where the desired sequence behavior is coined: the <code class="literal">Current</code>
 untyped property also returns a persisted <code class="literal">_repeated</code>
 value, but this time, it's boxed according to the contract, yielding <code class="literal">obj</code>
 . The <code class="literal">MoveNext()</code>
 method, as Energizer Bunny says, should keep going, going, going... so that it always returns <code class="literal">true</code>
 , which means that the next element is available no matter what. The <code class="literal">Reset()</code>
 legacy method is just a stub.</p>
<p>Finally, a bogus implementation of <code class="literal">System.IDisposable</code>
 that is required by the <code class="literal">IEnumerator&lt;'T&gt;</code>
 contract completes the implementation.</p>
<p>Now, for the usage convenience, I add a thin wrapper that upcasts the implemented interface of <code class="literal">Repeater&lt;'T&gt;</code>
 to the explicit <code class="literal">System.Collections.Generic.IEnumerator&lt;'T&gt;</code>
 as shown in the following code (<code class="literal">Ch6_3.fsx</code>
 ):</p>
<pre class="programlisting">let repeat&lt;'T&gt;(e) = 
  (new Repeater&lt;'T&gt;(e) 
  :&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;) 
</pre>
<p>Finally, a generic <code class="literal">makeSeq</code>
 shim function provides the conversion of any <code class="literal">IEnumerator&lt;'T&gt;</code>
 into the corresponding <code class="literal">seq&lt;'T&gt;</code>
 sequence by implementing both generic and nongeneric flavors of <code class="literal">IEnumerable</code>
 as shown in the following code (<code class="literal">Ch6_3.fsx</code>
 ):</p>
<pre class="programlisting">let makeSeq enumerator = 
{ 
  new System.Collections.Generic.IEnumerable&lt;'U&gt; with 
    member x.GetEnumerator() = enumerator 
  interface System.Collections.IEnumerable with 
    member x.GetEnumerator() = 
    (enumerator :&gt; System.Collections.IEnumerator) 
} 
</pre>
<p>Here, the <code class="literal">enumerator</code>
 argument provides the underlying <code class="literal">IEnumerator&lt;'T&gt;</code>
 for both implementations of <code class="literal">IEnumerable</code>
 constituting an arbitrary F# <code class="literal">seq</code>
 .</p>
<p>It's time for field tests! Executing the freshly created <code class="literal">makeSeq</code>
 function with three different arguments that represent the <code class="literal">repeat '.'</code>
 , <code class="literal">repeat 42</code>
 , and <code class="literal">repeat</code>
 <code class="literal">"Hooray!"</code>
 enumerators in FSI yields sequences of indefinite length of the corresponding types, as demonstrated in the following screenshot:</p>
<div class="mediaobject"><img src="Image00025.jpg" alt="Sequence of an indefinite length as a design pattern"/>
<div class="caption">
<p>Generating sequences of indefinite length</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>However, how can we prove that these sequences are indeed of indefinite length? Ironically, only by counting elements: if for any indiscriminately big number, the sequence yields that many elements, then that is the proof that these sequences are of indefinite length. Unfortunately, this is exactly where we hit the already mentioned counting problem: counting might be effectively limited by the underlying hardware.</p>
<p>But wait a minute; .NET provides a numeric type that, for all practical purposes, represents an arbitrarily large countable <span class="strong">
<strong>System.Numerics.BigInteger</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/system.numerics.biginteger(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.numerics.biginteger(v=vs.110).aspx</a>
 ). So, it would be nice to base the counting on this type.</p>
<p>Assuming that you are not afraid of challenges, it would be a good exercise to implement a generic technique of counting not limited by standard <code class="literal">int</code>
 . For F#, this task is not very complicated. I would suggest the following idiomatic approach (<code class="literal">Ch6_3.fsx</code>
 ):</p>
<pre class="programlisting">let inline traverse n s = 
  let counter = 
    (Seq.zip 
    (seq { LanguagePrimitives.GenericOne..n }) s) 
    .GetEnumerator() 
  let i = ref LanguagePrimitives.GenericOne 
  let mutable last = Unchecked.defaultof&lt;_&gt; 
  while counter.MoveNext() do 
    if !i = n then last &lt;- counter.Current 
      i := !i + LanguagePrimitives.GenericOne 
  last 
</pre>
<p>The <code class="literal">traverse</code>
 counting function is inlined in order to allow the compiler to build the compiled code aligned with the type on argument <code class="literal">n</code>
 picked for the counting. The <code class="literal">n</code>
 argument of <code class="literal">traverse</code>
 represents the amount of elements expected to be generated. The second <code class="literal">traverse</code>
 argument <code class="literal">s</code>
 represents a generic unlimited sequence generator. <code class="literal">makeSeq</code>
 with a given generic repetitive element makes a perfect second argument for <code class="literal">traverse</code>
 .</p>
<p>The sequence counting enumerator can be elegantly expressed as <code class="literal">Seq.zip</code>
 zipping together the presumably unlimited length sequence of <code class="literal">makeSeq</code>
 and a limited length sequence that has exactly the expected arbitrarily large (within boundaries that the underlying type allows) number of elements. As zipping stops upon reaching the end of the shorter sequence, the <code class="literal">counter</code>
 value represents exactly the desired enumerator obtained from the zipper expression result.</p>
<p>Finally, I traverse the obtained enumerator until it stops yielding elements keeping track of the last traversed element. This <code class="literal">last</code>
 element, which is apparently a tuple of the last element number and the unbound sequence element, is returned as the evidence of arbitrary length. The following screenshot demonstrates how the field tests passed. The first test shows how <code class="literal">traverse</code>
 worked with the <code class="literal">BigInteger</code>
 counter; the second test just illustrates how to produce the sequence that is 10 elements longer than <code class="literal">System.Int32.MaxValue</code>
 :</p>
<div class="mediaobject"><img src="Image00026.jpg" alt="Sequence of an indefinite length as a design pattern"/>
<div class="caption">
<p>Checking out unlimited sequence workings</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Another interesting experiment would be to generate a sequence longer than <code class="literal">System.Int64.MaxValue</code>
 , which I leave to you as an exercise. My only concern is the time duration it may take to complete. My rough estimate shows that at the rate of 1,000,000 elements traversed per second, it would take no less than the next 29 centuries to complete; so, some serious revisions of the method and optimizations of the implementation may be due.</p>
<div class="section" title="Generating the F# sequences">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_1"><a id="ch06lvl2sec81"/>
 Generating the F# sequences</h2>
</div>
</div>
</div>
<p>As you had a chance to notice recently, generating sequences with the de-sugared .NET way has a fair amount of moving parts and, frankly, is not the best <span class="emphasis">
<em>one fits all</em>
</span>
 use case. Fortunately, F# provides enough support through syntactic sugar as well as library functions, making the generation of sequences of finite and infinite lengths a breeze. Let's take a peek at them.</p>
<div class="section" title="Sequence comprehensions">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_2"><a id="ch06lvl3sec20"/>
 Sequence comprehensions</h3>
</div>
</div>
</div>
<p>Sequence comprehensions allow you to represent a sequence as a special kind of expression, namely <span class="strong">
<strong>sequence expression</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233209.aspx">https://msdn.microsoft.com/en-us/library/dd233209.aspx</a>
 ). Or, the other way around, sequence expression, when being evaluated, yields a sequence.</p>
<p>Sequence comprehensions may take plenty of forms. We'll be discussing some that are typical.</p>
<div class="section" title="Ranges">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a id="ch06lvl4sec2"/>
 Ranges</h4>
</div>
</div>
</div>
<p>These are the simplest forms of comprehensions, producing sequences from ranges. Observe that ranges are not limited to just numeric ones; any type supporting the <code class="literal">'get_One'</code>
 operator is fine too as shown here (<code class="literal">Ch6_4.fsx</code>
 ):</p>
<pre class="programlisting">// odd int64 between 1 and 1000 
seq { 1L .. 2L .. 1000L } 
// val it : seq&lt;int64&gt; = seq [1L; 3L; 5L; 7L; ...] 
 
// range not necessarily must be numeric! 
seq { 'A' .. 'Z' } 
// val it : seq&lt;char&gt; = seq ['A'; 'B'; 'C'; 'D'; ...] 
</pre>
</div>
<div class="section" title="Maps">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a id="ch06lvl4sec3"/>
 Maps</h4>
</div>
</div>
</div>
<p>These expressions generalize ranges by allowing the projection of one or more enumerations into something of another type. Also, note that the enumeration definition can be very flexible: from a simple range to nested enumerations to just another sequence as shown here (<code class="literal">Ch6_4.fsx</code>
 ):</p>
<pre class="programlisting">// even int from 2 to 1000 
seq { for i in 1..2..999 -&gt; ((+) 1 i) } 
// val it : seq&lt;int&gt; = seq [2; 4; 6; 8; ...] 
 
// nested enumerations 
seq { for i in 1..10 do for j in 1..10 -&gt; if i = j then 1 else 0} 
// val it : seq&lt;int&gt; = seq [1; 0; 0; 0; ...] 
 
// cartesian product tuple projection 
seq { for i in 1..10 do for j in 1..10 -&gt; (i,j) } 
// val it : seq&lt;int * int&gt; = seq [(1, 1); (1, 2); (1, 3); ...] 
 
// cartesian product nested enumerations 
seq { for i in seq {'a'..'b'} do for j in 1..2 -&gt; (i,j) } 
val it : seq&lt;char * int&gt; = seq [('a', 1); ('a', 2); ('b', 1); ('b', 2)] 
 
</pre>
</div>
<div class="section" title="Arbitrary sequence expressions">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a id="ch06lvl4sec4"/>
 Arbitrary sequence expressions</h4>
</div>
</div>
</div>
<p>All sequence comprehensions represent the idiomatic F# syntax sugar related to the extremely powerful mechanism of <span class="strong">
<strong>computation expressions</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233182.aspx">https://msdn.microsoft.com/en-us/library/dd233182.aspx</a>
 ), in particular, providing a convenient syntax for dreaded <span class="emphasis">
<em>M-word things</em>
</span>
 , also known as <span class="strong">
<strong>monads</strong>
</span>
 . <span class="strong">
<strong>Computation expressions</strong>
</span>
 represent the extremely powerful F# pattern of sequencing and combining computations. They may be custom built; however, F# also offers some built-in computation expressions: along with <span class="strong">
<strong>sequence expressions</strong>
</span>
 , there are <span class="strong">
<strong>asynchronous workflows</strong>
</span>
 and <span class="strong">
<strong>query expressions</strong>
</span>
 as well. I will be covering built-in computation expressions in the upcoming chapters of this book.</p>
<p>Arbitrary sequence expressions are just computations wrapped by <code class="literal">seq { and }</code>
 tokens, although in contrast to the <span class="strong">
<strong>ranges</strong>
</span>
 and <span class="strong">
<strong>maps</strong>
</span>
 covered earlier, computations can be pretty much anything. Two constructs within sequence expression tokens play a special role as shown here:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">yield &lt;expression&gt;</code>
 makes the expression value the next element of the final sequence</li>
<li class="listitem">
<code class="literal">yield! &lt;sequence expression&gt;</code>
 (reads <span class="emphasis">
<em>yield-bang</em>
</span>
 ) appends the sequence expression operand to the end of the final sequence</li>
</ul>
</div>
<p>The presence of <code class="literal">yield!</code>
 turns arbitrary sequence expressions into extremely powerful data transformations. In particular, as <code class="literal">seq {...}</code>
 is still an expression, being used as a return value of recursive functions, this pattern allows you to extremely succinctly and elegantly implement sequences of finite and infinite length, in particular, easily turn any finite sequence into an infinite circular one, which is often very convenient for the partitioning of other sequences through the element markup.</p>
<p>Enough words; let's look at some code!</p>
<p>I begin with a sample demonstrating how the entire pattern match construct can be nested into a sequence expression in order to detect when the sequence should halt. The following snippet produces a descending sequence of an integer from any non-negative number down to zero (<code class="literal">Ch6_4.fsx</code>
 ):</p>
<pre class="programlisting">let rec descend top =  
  seq { 
    match top with 
      | _ when top &lt; 0 -&gt; () 
      | _ -&gt; 
      yield top 
      yield! descend (top - 1) 
  } 
 
// descend 3;; 
// val it : seq&lt;int&gt; = seq [3; 2; 1; 0] 
// descend -3;; 
// val it : seq&lt;int&gt; = seq [] 
</pre>
<p>Note how generation halting is achieved by returning <code class="literal">unit</code>
 instead of yielding the next element.</p>
<p>So far, so good. Now let's generate just an endless sequence of alternating strings as shown (<code class="literal">Ch6_4.fsx</code>
 ):</p>
<pre class="programlisting">let rec fizzbuzz = seq {  
  yield "Fizz" 
  yield "Buzz" 
  yield! fizzbuzz 
} 
in fizzbuzz 
 
// val it : seq&lt;string&gt; = seq ["Fizz"; "Buzz"; "Fizz"; "Buzz";  ...]</pre>
<p>To wrap up the theme, look at how elegantly the circularization of any arbitrary sequence can be achieved as shown here (<code class="literal">Ch6_4.fsx</code>
 ):</p>
<pre class="programlisting">let rec circular ss = 
  seq { yield! ss; yield! circular ss } 
 
circular (seq { yield '+'; yield '-' }) 
// val it : seq&lt;char&gt; = seq ['+'; '-'; '+'; '-'; ...] 
</pre>
<p>Deserves two bangs that are required in the definition above to arrange the circularization indeed.</p>
</div>
</div>
<div class="section" title="Library functions generating sequences">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_3"><a id="ch06lvl3sec21"/>
 Library functions generating sequences</h3>
</div>
</div>
</div>
<p>Now I turn to the support for sequence generation that the F# core libraries provide.</p>
<div class="section" title="Seq.init">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a id="ch06lvl4sec5"/>
 Seq.init</h4>
</div>
</div>
</div>
<p>This method is for sequences of predefined length as the length sits right in the function signature. This is quite a simple function that assumes but does not prescribe a projection of the current element number. Here goes a sample with a projection of the sequence number in a string performed in the <span class="strong">
<strong>tacit</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Tacit_programming">https://en.wikipedia.org/wiki/Tacit_programming</a>
 ) manner (<code class="literal">Ch6_4.fsx</code>
 ):</p>
<pre class="programlisting">Seq.init 10 (sprintf "%s%d""I'm element #") 
//val it : seq&lt;string&gt; = 
//  seq 
//    ["I'm element #0"; "I'm element #1"; "I'm element #2"; 
//    "I'm element #3"; ...] 
 
</pre>
</div>
<div class="section" title="Seq.initInfinite">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a id="ch06lvl4sec6"/>
 Seq.initInfinite</h4>
</div>
</div>
</div>
<p>This function is very similar to the previous one, but it is missing the first argument indeed, as shown here (<code class="literal">Ch6_4.fsx</code>
 ):</p>
<pre class="programlisting">Seq.initInfinite (sprintf "%s%d""I'm element #") 
//val it : seq&lt;string&gt; = 
//  seq 
//    ["I'm element #0"; "I'm element #1"; "I'm element #2"; 
//    "I'm element #3"; ...] 
</pre>
<p>Pretty much nothing has changed, but the underlying abstraction is more powerful than the finite variant. Unfortunately, the power of abstraction can be easily hurt by the implementation limitation that shrewd F# programmers may guess: it has only as many element sequence numbers as the hardware architecture allows. This is easy to check with the following little hack (<code class="literal">Ch6_4.fsx</code>
 ):</p>
<pre class="programlisting">Seq.initInfinite (fun _ -&gt; ()) 
|&gt; Seq.skip (System.Int32.MaxValue) 
//&gt; 
//val it : seq&lt;unit&gt; = 
//  Error: Enumeration based on System.Int32 exceeded System.Int32.MaxValue. 
</pre>
<p>Ouch, it hurts!</p>
</div>
<div class="section" title="Seq.unfold">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a id="ch06lvl4sec7"/>
 Seq.unfold</h4>
</div>
</div>
</div>
<p>The <code class="literal">Seq.unfold</code>
 library function, which concludes the matter of sequence generation, is my favorite. Instead of bothering with sequence numbers, its projection function unwraps the recurrent relationship between the current and the next element. It also demonstrates a very smart manner of addressing the halt problem by prescribing the projection result as <code class="literal">option</code>
 when returning <code class="literal">None</code>
 signals to stop generating further elements. Let's look at this library function in action using rather worn down by bloggers and Academia <span class="strong">
<strong>Fibonacci numbers</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Fibonacci_number">https://en.wikipedia.org/wiki/Fibonacci_number</a>
 ) as an example shown here (<code class="literal">Ch6_4.fsx</code>
 ):</p>
<pre class="programlisting">// Oh NO! Not Fibonacci again! 
let fibnums = Seq.unfold (fun (current, next) -&gt; 
  Some(current, (next, current+next)))(1,1) 
 
fibnums |&gt; Seq.take 10 |&gt; Seq.toList 
// val it : int list = [1; 1; 2; 3; 5; 8; 13; 21; 34; 55] 
</pre>
<p>After some years of using F#, I'm still excited what clarity of intent it allows! The projection function literally explains itself, so I do not have anything to add.</p>
</div>
</div>
</div>
</div>


<div class="section" title="Sequence and the code performance">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch06lvl1sec48"/>
 Sequence and the code performance</h1>
</div>
</div>
</div>
<p>Sequences are, without doubt, extremely powerful members of the functional programmer tool belt. However, they are not free of <span class="emphasis">
<em>gotchas</em>
</span>
 that may hurt the performance badly. It is best that they are known and avoided. A few of them are as follows:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">Unfortunate materialization, which may be either unnecessary/premature elements materialization or the other way around, missing elements materialization.</li>
<li class="listitem">Data laziness, in concert with the non-preserving once current element values, can severely hurt the performance in a situation where the algorithm requires multiple traversals or where calculating elements is expensive. The developer should be able to compensate for these detrimental factors by applying patterns such as <span class="strong">
<strong>caching</strong>
</span>
 and/or <span class="strong">
<strong>memoization</strong>
</span>
 .</li>
<li class="listitem">Often, when composing data processing pipelines, the developer may carelessly use a library function that unexpectedly requires them to enumerate the entire sequence. This is not necessarily a bad thing, but it should be used sparingly.</li>
<li class="listitem">With all the aesthetic beauty of sequences of indefinite length, if misdemeanors mentioned in the previous bullet point just hurt the performance of finite length sequences, the first such negligence upon an indefinite length sequence simply <span class="emphasis">
<em>kills!</em>
</span>
 Beware and proceed with due caution when dealing with unlimited length sequences!</li>
</ul>
</div>
<div class="section" title="Sequence caching">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_1"><a id="ch06lvl2sec82"/>
 Sequence caching</h2>
</div>
</div>
</div>
<p>F# language creators were nice enough to provide an out-of-the-box tool for caching, namely the <code class="literal">Seq.cache</code>
 library function. It should be used in a situation where lazy materialization is not a killer, but element generation is not cheap and repetitive enumerations are really required. Let me demonstrate how easy putting caching to work would be.</p>
<p>To begin with, I need an indicator of the enumerator consumption. This is not complicated for those who already have experience working with sequence guts. Let's slightly modify our good old <code class="literal">makeSeq</code>
 function as following (<code class="literal">Ch6_5.fsx</code>
 ):</p>
<pre class="programlisting">let makeSeq f = 
{ 
  new System.Collections.Generic.IEnumerable&lt;'U&gt; with 
    member x.GetEnumerator() = printfn "Fresh enumerator given"; f() 
  interface System.Collections.IEnumerable with 
    member x.GetEnumerator() = 
    (f() :&gt; System.Collections.IEnumerator) 
} 
</pre>
<p>Now we are ready to see how the caching works as shown here (<code class="literal">Ch6_5.fsx</code>
 ):</p>
<pre class="programlisting">//caching 
let nums = (seq {1..100}).GetEnumerator |&gt; makeSeq 
// non-cached - double enumeration 
((nums |&gt; Seq.sum),(nums |&gt; Seq.length)) 
//Fresh enumerator given 
//Fresh enumerator given 
//val it : int * int = (5050, 100) 
 
let cache = nums |&gt; Seq.cache 
// cached - single enumeration 
((cache |&gt; Seq.sum),(cache |&gt; Seq.length)) 
//Fresh enumerator given 
//val it : int * int = (5050, 100) 
// just another time - no enumerations at all 
((cache |&gt; Seq.sum),(cache |&gt; Seq.length)) 
//val it : int * int = (5050, 100) 
</pre>
<p>First, in the absence of any caching, <code class="literal">Seq.sum</code>
 and <code class="literal">Seq.length</code>
 each imposed an independent sequence traversal, which the presence of two enumerator alerts confirms.</p>
<p>Then, after wrapping the working sequence with <code class="literal">Seq.cache</code>
 , I repeat the calculation using the wrapper sequence. As expected, we notice only a single enumerator alert to populate the cache; the second traversal did not leave any traces as it went through the cache.</p>
<p>To be sure, just reissue the calculation. Now, all the data come from the cache, and no traversals of the original sequence take place at all.</p>
</div>
<div class="section" title="The fusion of sequence transformations">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_2"><a id="ch06lvl2sec83"/>
 The fusion of sequence transformations</h2>
</div>
</div>
</div>
<p>I want to wrap up this chapter by demonstrating a pattern known as <span class="strong">
<strong>fusion</strong>
</span>
 . It is not conceptually difficult: imagine that you have a composition of functions that collectively transform a data sequence. At some point, your implementation requires multiple traversals of the sequence. However, the compiler in principle, or the human in practice, may optimize the transformation, so multiple traversals have now fused into just the single one.</p>
<p>Let's perform fusion in practice, reusing our <code class="literal">makeSeq</code>
 implementation as the indicator of obtaining enumerators as shown in the following code (<code class="literal">Ch6_5.fsx</code>
 ):</p>
<pre class="programlisting">let series = (seq {1..100}).GetEnumerator |&gt; makeSeq 
let average dd = (Seq.sum dd) / (Seq.length dd) 
average series 
//Fresh enumerator given 
//Fresh enumerator given 
//val it : int = 50 
</pre>
<p>The preceding naive implementation of <code class="literal">average</code>
 traverses the sequence twice, of which the enumeration alerts give the evidence.</p>
<p>However, rewriting the implementation of <code class="literal">average</code>
 less naively as <code class="literal">averageFused</code>
 ends up in the fusion of these traversals as shown in the following code (<code class="literal">Ch6_5.fsx</code>
 ):</p>
<pre class="programlisting">let averageFused dd = 
  dd 
  |&gt; Seq.fold (fun acc x -&gt; (fst acc + x, snd acc + 1)) (0,0) 
  |&gt; fun x -&gt; fst x / snd x 
averageFused series 
//Fresh enumerator given 
//val it : int = 50 
</pre>
<p>The single enumeration alert confirms my statement completely.</p>
</div>
</div>


<div class="section" title="Summary">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch06lvl1sec49"/>
 Summary</h1>
</div>
</div>
</div>
<p>This chapter covers one of the cornerstones of the F# data processing, namely sequences. The existing F# core sequence library allows you to apply all typical patterns of functional data processing.</p>
<p>When you feel an urge to implement just another custom function for sequence processing, the first thing you need to do is determine which known pattern groups it would belong to and then check twice whether this function is really not implemented already or whether it can be simply composed from the remaining library functions. Recollect the <span class="emphasis">
<em>Minimizing moving parts over hiding them</em>
</span>
  section from <a class="link" title="Chapter 1. Begin Thinking Functionally" href="text00015.html#page">Chapter 1</a>
 , <span class="emphasis">
<em>Begin Thinking Functionally</em>
</span>
 . Core libraries are minimalistic sets of such high-quality parts, so sticking to them eventually positively influences the quality and readability of your code.</p>
<p>You obtained plenty of details about the inner workings of the F# sequences and should now be able to produce sequences by a variety of means by dealing, when appropriate, with conceptually clean sequences of indefinite length.</p>
<p>Finally, I provided some sequence performance clues and considerations accompanied by some practical optimization coding, leaving you in a good position for further mastery.</p>
<p>In the next chapter, I will revisit the subject of functions as you should now be ready to pick up some advanced techniques on top of the already acquired skills.</p>
</div>
</body></html>