- en: Unity Engine Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity引擎架构
- en: We are about to start on a journey that will teach us how to use software design
    patterns inside the Unity engine's development environment. This book takes a
    very hands-on approach to learning and applying design patterns. We are going
    to avoid getting lost in academic definitions of patterns and instead focus on
    implementing them with Unity's API on genuine game-development use cases. For
    those that want to dig deeper into the theory of a specific pattern, at the end
    of each chapter, there will be references to further reading material.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将开始一段旅程，这段旅程将教会我们如何在Unity引擎的开发环境中使用软件设计模式。本书采用非常实践的方法来学习和应用设计模式。我们将避免陷入模式的学术定义中，而是专注于使用Unity的API在真正的游戏开发用例中实现它们。对于那些想要深入研究特定模式的理论的人，在每一章的结尾，都会有进一步阅读材料的参考。
- en: But the most important note to keep in mind is that this book focuses on simplicity
    over complexity. That means the code examples and use cases are designed to be
    as simple as possible so we can concentrate on the essential elements of a pattern,
    while avoiding getting lost in complex implementations. As a reader, I encourage
    you to take the source code of each chapter, elaborate on it, and then make it
    your own.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但最重要的注意事项是，这本书的重点是简洁而非复杂。这意味着代码示例和用例被设计得尽可能简单，这样我们就可以专注于模式的基本要素，同时避免陷入复杂的实现中。作为读者，我鼓励你获取每一章的源代码，对其进行扩展，然后使其成为你自己的。
- en: However, before diving into a new game engine and start coding with its API,
    it's essential to understand its architecture. So, in this chapter, we will be
    reviewing the core engineering pillars of the Unity engine. But first, for those
    that are still new to game development, we are going to quickly discuss the core
    components that are common to most game engines and how they influence the way
    we write code for video games.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在深入一个新游戏引擎并开始使用其API进行编码之前，理解其架构是至关重要的。因此，在本章中，我们将回顾Unity引擎的核心工程支柱。但首先，对于那些对游戏开发还不太熟悉的人来说，我们将快速讨论大多数游戏引擎共有的核心组件以及它们如何影响我们编写游戏代码的方式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Engine architectures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎架构
- en: Unity's component system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity的组件系统
- en: Unity's scripting API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity的脚本API
- en: Engine architectures
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引擎架构
- en: In this section, we will review the basic principles behind game engines. Of
    course, the focus of this book is not about mastering engine architecture. Nevertheless,
    it's wise to take the time to familiarize ourselves with an engine's core architecture
    before making a game with it. We don't want to be blindsided later on by technical
    details that will break our design choices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾游戏引擎背后的基本原理。当然，本书的重点不是掌握引擎架构。尽管如此，在用这个引擎制作游戏之前花时间熟悉其核心架构是明智的。我们不希望后来被那些会破坏我们的设计选择的技术细节所困扰。
- en: What are game engines?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是游戏引擎？
- en: Game engines are what drives the game industry forward, and Unity is the best
    example of this. Since its release, the number of game studios has grown at an
    exponential rate. Unity has democratized the process of making video games by
    offering an extensible development environment for amateurs and professionals
    alike.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏引擎是推动游戏行业前进的动力，Unity是这一点的最佳例证。自从其发布以来，游戏工作室的数量以指数级增长。Unity通过为业余爱好者和专业人士 alike
    提供可扩展的开发环境，使制作视频游戏的过程民主化。
- en: But for those unfamiliar with the concept of game engines, or even why they
    are called engines, I have a straightforward way to describe them. Look under
    the hood of your car, what do you see? Cables, filters, tubes, batteries, and
    gears connected but working in unison to run the vehicle. A game engine is very
    similar to the concept of a car engine, but instead of being made out of metal
    and rubber, it's pure software. If you look under the *hood*, known as the codebase
    of any modern game engine, you will see hundreds of systems, tools, and components
    all interconnected and running in unison.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于那些不熟悉游戏引擎的概念，甚至不知道为什么它们被称为引擎的人来说，我有一个简单的方法来描述它们。看看你汽车的引擎盖下，你看到了什么？电缆、过滤器、管道、电池和齿轮连接在一起，但协同工作以运行车辆。游戏引擎与汽车引擎的概念非常相似，但不同的是，它不是由金属和橡胶制成的，而是纯软件。如果你查看所谓的“引擎盖”，即任何现代游戏引擎的代码库，你将看到数百个系统、工具和组件相互连接并协同工作。
- en: So, if you are planning to produce a video game, the most critical decision
    you will have to make is what engine you are going to use, because this is what
    will be running your game. This single choice will influence every aspect of your
    production. Every department will be required to adjust and alter their pipelines
    and workflows. Many games have been canceled or have ended up being bug-ridden
    disasters because of an unwise choice in engine technology.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你计划制作一款视频游戏，你必须做出的最关键决定是选择哪个引擎，因为这将运行你的游戏。这个单一的选择将影响你生产的各个方面。每个部门都需要调整和改变他们的管道和工作流程。许多游戏因为引擎技术选择不当而被取消或最终成为充满bug的灾难。
- en: That's one of the reasons that Unity became so popular, as its name implies,
    it's an engine that has the core intention of unifying the game industry. You
    can find Unity being used to build games ranging from Angry Birds clones to epic
    **Japanese Role-playing Game** (**JRPGs**); in other words, it's genre-agnostic.
    By combining all the best practices of the industry and integrating them into
    a unique but straightforward development environment, Unity has made its engine
    a cornerstone of the industry.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是Unity变得如此受欢迎的原因之一，正如其名字所暗示的，它是一个具有统一游戏行业核心意图的引擎。你可以找到Unity被用来构建从愤怒的小鸟克隆到史诗般的**日本角色扮演游戏**（**JRPGs**）的游戏；换句话说，它是跨类型的。通过结合行业中的最佳实践并将它们整合到一个独特但直观的开发环境中，Unity使其引擎成为行业的基石。
- en: Please note that Unity is a closed codebase. Only partners of Unity have direct
    access to the source code of the engine. So there's a certain degree of speculation
    when we talk about the inner workings of Unity's architecture. That's why we are
    keeping this chapter very high-level and not diving too deep into specifications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Unity是一个闭源代码库。只有Unity的合作伙伴才能直接访问引擎的源代码。因此，当我们谈论Unity架构的内部运作时，会有一定程度的推测。这就是为什么我们将本章保持在一个非常高级的水平，并没有深入到具体规格。
- en: Unity's architecture
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity的架构
- en: 'Now it''s time to tackle our main subject, Unity and its core engine architecture
    pillars. One thing we must keep in mind is that Unity is a closed source engine;
    this means that we have to extrapolate our mental model of its overall architecture
    from its official documentation. To avoid going into gray areas of Unity''s design
    that cannot easily be validated, we will focus on the most visible and useful
    pillars for us to know. The two main core engine architecture pillars are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候处理我们的主要主题了，Unity及其核心引擎架构支柱。我们必须牢记的一点是，Unity是一个闭源引擎；这意味着我们必须从其官方文档中推断出我们对它整体架构的心理模型。为了避免深入Unity设计中的灰色区域，这些区域难以验证，我们将专注于对我们来说最明显和最有用的支柱。以下是我们需要了解的两个主要核心引擎架构支柱：
- en: Components
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件
- en: Scripting API
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本API
- en: Components
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: 'Unity is a component-driven engine, and it''s with a combination of components
    that we build our game. If we analyze the following graph, we can see there''s
    a high-level hierarchy that entities contain other entities. The essential elements
    of this structure are the Components; they are the building blocks of a game:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Unity是一个以组件驱动的引擎，我们正是通过组件的组合来构建我们的游戏。如果我们分析以下图表，我们可以看到存在一个高级层次结构，实体包含其他实体。这个结构的基本元素是组件；它们是游戏的基本构建块：
- en: '![](img/d62180f2-84a7-4547-bc17-21059d239906.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d62180f2-84a7-4547-bc17-21059d239906.png)'
- en: 'A simple way to visualize this architecture is to consider that a **Scene**
    is a collection of GameObjects, and GameObjects are a collection of Components
    that can implement and include the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可视化这种架构的简单方法是考虑一个**场景**是一组GameObject，而GameObject是一组可以实现和包含以下内容的组件：
- en: Systems (cameras and physics)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统（摄像头和物理）
- en: Data (configurations, animations, and textures)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据（配置、动画和纹理）
- en: Behaviors (game mechanics and scripted events)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为（游戏机制和脚本事件）
- en: So with this approach, we can quickly transform a GameObject that's behaving
    like a camera into an animated character by merely changing the components that
    it holds. That means that GameObjects are *composed* of components, and, depending
    on what type of component we attach to a GameObject, it will *morph* it into a
    specific kind of entity such as a camera, animated character, or particle. So
    it's a very straightforward and modular approach to constructing a game.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过这种方法，我们只需更改它所持有的组件，就可以快速将一个表现像摄像机的GameObject转换成一个动画角色。这意味着GameObject是由组件组成的，并且，根据我们附加到GameObject的组件类型，它将将其转换成特定类型的实体，如摄像机、动画角色或粒子。因此，这是一种非常直接和模块化的构建游戏的方法。
- en: In the next section, we will review the API that Unity provides, which permits
    us to write those various components.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾Unity提供的API，它允许我们编写这些各种组件。
- en: Scripting API
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本API
- en: The original designers of Unity understood if they wanted to make an engine
    that could be used by developers of various skill levels, they needed to design
    a programming environment that was easy to use, but flexible enough to make any
    types of game. They achieved this by wrapping and exposing the engine's core functionalities
    and libraries through a managed scripting API. So, this means that a Unity developer
    can focus on writing code without worrying about the intricacies of memory management,
    or the inner workings of the engine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的原始设计者明白，如果他们想要制作一个可以被不同技能水平的开发者使用的引擎，他们需要设计一个易于使用但足够灵活的编程环境，以便制作任何类型的游戏。他们通过封装和暴露引擎的核心功能和库，通过一个受管理的脚本API实现了这一点。这意味着Unity开发者可以专注于编写代码，而无需担心内存管理的复杂性或引擎内部的工作原理。
- en: This approach is common even with AAA in-house engines. The core components
    of the engine are usually coded in low-level programming languages, like C++ and
    assembly language because you need precise control over memory and processing
    usage. But programmers that are responsible for implementing in-game systems,
    such as AI behaviors or gameplay mechanics, can code on a higher layer of the
    engine's architecture. So engine programmers will often expose an API or library
    for gameplay programmers, so they can implement in-game components in a safe and
    controlled environment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法甚至在AAA内部引擎中也很常见。引擎的核心组件通常使用低级编程语言，如C++和汇编语言编写，因为需要对内存和处理使用进行精确控制。但负责实现游戏内系统，如AI行为或游戏机制的程序员，可以在引擎架构的更高层进行编码。因此，引擎程序员通常会向游戏程序员公开一个API或库，以便他们在安全和受控的环境中实现游戏内组件。
- en: Gameplay programmers will often implement another layer of abstraction in the
    form of a simple scripting language, such as LUA, so designers can script behaviors
    without having to know how to code. Some engines go even further with this approach
    of simplification by implementing a visual scripting environment; an excellent
    example of this is Unreal's Blueprint system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏程序员通常会通过一种简单的脚本语言，如LUA，实现另一层抽象，这样设计师就可以在不了解如何编码的情况下编写脚本。一些引擎甚至通过实现一个可视化的脚本环境来进一步简化这种简化方法；一个很好的例子是Unreal的蓝图系统。
- en: The end goal of all these layers of abstraction is to make the process of building
    a game more accessible to developers of diverse expertise, but also protect the
    engine from crashing because of poorly-implemented code. In other words, we want
    to avoid having a designer crash the engine because he wrote a script that spawns
    a thousand enemy characters at once in a scene, and as a consequence, causes an
    insufficient memory exception. So, we want to make sure the API or scripting library,
    which we offer to those that create content with our engine, can assist them in
    avoiding provoking critical errors that might affect the overall stability of
    the development environment.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些抽象层的目标是使构建游戏的过程对各种专业水平的开发者更加容易接近，同时保护引擎免受因代码实现不当而崩溃的影响。换句话说，我们希望避免设计师因为编写了一个在场景中一次性生成一千个敌人角色的脚本而导致引擎崩溃，从而引发内存不足异常。因此，我们希望确保我们提供给使用我们引擎的内容创作者的API或脚本库能够帮助他们避免引发可能影响开发环境整体稳定性的关键错误。
- en: 'The following diagram showcases the architectural hierarchy and the chain of
    responsibility of a typical AAA game development team. As we go up in the chain,
    technical details become abstracted, and there''s a higher level of focus on content
    creation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图展示了典型AAA游戏开发团队的架构层次和责任链。随着我们向上移动链，技术细节变得更加抽象，对内容创作的关注级别更高：
- en: '![](img/d5c27945-e262-4416-b664-edc4f6537ec1.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5c27945-e262-4416-b664-edc4f6537ec1.png)'
- en: The purpose of this is to control access to the engine's limited resources,
    while exposing core features to the end user, which are usually designers and
    artists. And so, Unity's Scripting API has a similar purpose; its objective is
    to expose Unity's core features to the end user, in this case, developers, while
    protecting the inner workings of the engine.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的目的是控制对引擎有限资源的访问，同时向最终用户（通常是设计师和艺术家）暴露核心功能。因此，Unity的脚本API具有类似的目的；其目标是向最终用户（在这种情况下，是开发者）暴露Unity的核心功能，同时保护引擎的内部运作。
- en: 'So, the combination of a scripting API and a component system gives us a very
    simple, but powerful, coding model in Unity. You can see by the following code
    example how easy it is to implement a reference to a component of a GameObject
    and call its `public` methods:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，脚本API和组件系统的结合为Unity提供了一个非常简单但强大的编码模型。您可以通过以下代码示例看到实现GameObject组件引用并调用其`public`方法是多么容易：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This approach to programming games is straightforward, but also powerful. In
    this book, we are going to exploit the flexibility of Unity's API and its component
    driven architecture, while applying classic and modern software design patterns
    to make our code more robust. Our final goal is to build a toolkit of patterns
    that are adapted to Unity's unique coding model so we can develop games with a
    robust architecture.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程游戏的方法简单直接，但也很强大。在这本书中，我们将利用Unity的API和以组件驱动的架构的灵活性，同时应用经典和现代的软件设计模式，使我们的代码更加健壮。我们的最终目标是构建一套适应Unity独特编码模型的模式工具包，以便我们可以用健壮的架构开发游戏。
- en: For every industry-standard pattern or best practice, there's potential corresponding
    anti-patterns or drawbacks. It's important as a programmer to keep in mind not
    just the benefits of implementing a pattern, but also its potential pitfalls if
    incorrectly integrated into your overall architecture.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个行业标准模式或最佳实践，都可能存在相应的反模式或缺点。作为程序员，不仅要记住实现模式的好处，还要记住如果错误地集成到整体架构中，其潜在的风险。
- en: Summary
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we started to explore the world of game engines and two of
    Unity''s core engineering pillars:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始探索游戏引擎的世界，以及Unity的两个核心工程支柱：
- en: The component system
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件系统
- en: The scripting API
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本API
- en: Engines are very complex pieces of software, Unity has hundreds of features
    that we won't be able to cover in this book, but if we focus on mastering Unity's
    API, we will know how to access them when needs be.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎是非常复杂的软件组件，Unity有数百个功能，我们在这本书中无法全部涵盖，但如果我们专注于掌握Unity的API，我们将知道在需要时如何访问它们。
- en: In the upcoming chapters, we will focus on architecture, but more specifically,
    design patterns. We will learn how we can adapt proven industry patterns and best
    practices into Unity's unique coding model, without falling into the pitfalls
    of over-engineering. In the next chapter, we will review the two most critical
    concepts and patterns in game programming, the Game Loop and the Update method,
    which can be considered the heartbeat and ears of a video game.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将专注于架构，但更具体地说，是设计模式。我们将学习如何将经过验证的行业模式和最佳实践适应Unity独特的编码模型，同时避免过度工程化的陷阱。在下一章中，我们将回顾游戏编程中最关键的两种概念和模式：游戏循环和更新方法，它们可以被认为是视频游戏的脉搏和耳朵。
- en: Further reading
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Game Engine Architecture* by Jason Gregory:[http://www.gameenginebook.com](http://www.gameenginebook.com)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《游戏引擎架构》由Jason Gregory著：[http://www.gameenginebook.com](http://www.gameenginebook.com)
