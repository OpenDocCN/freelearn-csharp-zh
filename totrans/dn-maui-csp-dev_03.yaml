- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: XAML and Fluent C#
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XAML 和 Fluent C#
- en: In this chapter, we will look at how .NET MAUI applications are created using
    a markup language for the user interface and C# for all the logic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用标记语言创建用户界面和 C# 逻辑来创建 .NET MAUI 应用程序。
- en: .NET MAUI programs are (typically) written in two languages. One is C#, which
    is used for all the logic, and the other is **XAML** (pronounced *zamel*, to rhyme
    with camel), which is used for the layout and creation of controls. As you’ll
    see, the use of XAML is optional. You can create your layout and controls all
    in C#, but most people don’t. However, that may be changing (more and more of
    the Microsoft Learn documentation shows both ways).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 程序通常用两种语言编写。一种是 C#，用于所有逻辑，另一种是 **XAML**（发音为 *zamel*，与 camel 同韵），用于布局和控制创建。正如你将看到的，使用
    XAML 是可选的。你可以完全用 C# 创建布局和控制，但大多数人不会这样做。然而，这种情况可能正在改变（越来越多的 Microsoft Learn 文档展示了两种方法）。
- en: When might you choose to use C#?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你何时会选择使用 C#？
- en: There are a few reasons to use C# instead of XAML, not least that you know C#
    and don’t want to bother learning XAML. If you do this, however, you’ll find it
    difficult to read other people’s code, as most existing `Xamarin.Forms` (the precursor
    to .NET MAUI) apps are written with XAML.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C# 而不是 XAML 的原因有很多，最不重要的是你熟悉 C#，不想学习 XAML。然而，如果你这样做，你会发现阅读其他人的代码很困难，因为大多数现有的
    `Xamarin.Forms`（.NET MAUI 的前身）应用程序都是用 XAML 编写的。
- en: Using C# can assist in those situations where the design should change based
    on some condition (such as the type of data you get at runtime). But there are
    other ways to handle that with XAML as explained in [*Chapter 11*](B19723_11.xhtml#_idTextAnchor216),
    *Advanced Topics*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C# 可以帮助在需要根据某些条件（例如运行时获取的数据类型）更改设计的情况下。但正如在 [*第 11 章*](B19723_11.xhtml#_idTextAnchor216)
    中解释的，还有其他方法可以使用 XAML 来处理这种情况，*高级主题*。
- en: This book will show C# for some pages, but the focus will be on XAML.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将展示一些页面的 C#，但重点将放在 XAML 上。
- en: All of the Microsoft documentation is at least in XAML; only some is in C# and
    some is in Fluent C# (a topic we’ll take up later in this chapter). Nearly all
    **Xamarin.Forms** applications and samples use XAML and, for that reason alone,
    it is worth learning. More important, XAML is a highly expressive declarative
    markup language that makes creating layouts and controls if not easy, then at
    least manageable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Microsoft 文档至少包含 XAML；只有部分是 C# 编写的，还有一些是 Fluent C#（我们将在本章后面讨论的话题）。几乎所有的 **Xamarin.Forms**
    应用和示例都使用 XAML，仅此一点就值得学习。更重要的是，XAML 是一种高度表达性的声明性标记语言，它使得创建布局和控制变得即便不是容易，至少也是可管理的。
- en: 'This chapter will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the structure of XAML
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 XAML 的结构
- en: Code-behind and event handlers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码隐藏和事件处理器
- en: Exploring the layout options
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索布局选项
- en: Creating the UI in C#
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C# 创建 UI
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with this chapter, you will need the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，你需要以下条件：
- en: Visual Studio version 17.5 or later (it’s best to update to the latest version)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 版本 17.5 或更高版本（最好更新到最新版本）
- en: 'The source code covered in this chapter can be found in the GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/XAMLAndCSharp](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/XAMLAndCSharp)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章涉及到的源代码可以在 GitHub 仓库中找到：[https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/XAMLAndCSharp](https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/XAMLAndCSharp)
- en: Understanding the structure of XAML
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 XAML 的结构
- en: XAML files have the `.xaml` extension, for example, `MainPage.xaml`, in the
    out-of-the-box program as shown in [*Chapter 1*](B19723_01.xhtml#_idTextAnchor016).
    Let’s examine this file to explore XAML for its layout and declaration of controls.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: XAML 文件具有 `.xaml` 扩展名，例如，`MainPage.xaml`，在默认程序中，如 [*第 1 章*](B19723_01.xhtml#_idTextAnchor016)
    所示。让我们检查这个文件，以探索 XAML 的布局和控件声明。
- en: Just an overview
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简要概述
- en: This chapter will only scratch the surface of creating XAML layout and controls.
    [*Chapter 4*](B19723_04.xhtml#_idTextAnchor054) and [*Chapter 5*](B19723_05.xhtml#_idTextAnchor092)
    will cover the details on controls and layouts, respectively.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将仅对创建 XAML 布局和控制进行初步介绍。[*第 4 章*](B19723_04.xhtml#_idTextAnchor054) 和 [*第 5
    章*](B19723_05.xhtml#_idTextAnchor092) 将分别详细介绍控制和布局的细节。
- en: A .NET MAUI page that is written in XAML will have a name in the format `MyName.xaml`,
    and associated with that page will be a code-behind page (explained shortly) in
    the format `MyName.xaml.cs`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 用XAML编写的 .NET MAUI 页面将具有 `MyName.xaml` 的格式，并且与该页面相关联的后置代码页面（稍后解释）将具有 `MyName.xaml.cs`
    的格式。
- en: At the top of the XAML page is a declaration that this file is, in reality,
    an XML-type file. That declaration must be at the very top of every `.``xaml`
    file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在XAML页面的顶部是一个声明，即该文件实际上是一个XML类型的文件。该声明必须位于每个 `.xaml` 文件的顶部。
- en: 'There are different types of pages (also called views). The most common is
    `ContentPage`, and here `MainPage` is created as `ContentPage` using this code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的页面（也称为视图）。最常见的是 `ContentPage`，在这里 `MainPage` 被创建为 `ContentPage`，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As part of the declaration of `ContentPage`, we identify two namespaces (`xmlns`).
    The first namespace is unnamed and is for .NET MAUI itself. The second namespace,
    named `x`, is for XAML.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `ContentPage` 声明的一部分，我们识别了两个命名空间（`xmlns`）。第一个命名空间是无名的，用于 .NET MAUI 本身。第二个命名空间，名为
    `x`，用于 XAML。
- en: Finally, the class that this XAML file is part of is `ForgetMeNotDemo.View.MainPage`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个XAML文件所属的类是 `ForgetMeNotDemo.View.MainPage`。
- en: The first part (`ForgetMeNotDemo.View`) is the namespace, and `MainPage` is
    the name of the class. The `View` part is added to indicate the folder under the
    project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分 (`ForgetMeNotDemo.View`) 是命名空间，而 `MainPage` 是类的名称。`View` 部分被添加以表示项目下的文件夹。
- en: Associated with every `.xaml` page is a code-behind page, as mentioned earlier.
    It is possible to put the logic of your program in the code-behind, which is what
    we will do for this chapter (in the next chapter, we’ll look at an alternative
    that is better for testing). In any case, there are a few things that must go
    in the code-behind, as you’ll see in the next section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个 `.xaml` 页面都有一个相关的后置代码页面。您可以在后置代码中放置程序的逻辑，这就是我们将在本章中做的事情（在下一章中，我们将查看一个更适合测试的替代方案）。无论如何，后置代码中必须包含一些内容，您将在下一节中看到。
- en: The code-behind file
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后置代码文件
- en: Every XAML file has an associated code-behind page whose name is in the format
    `<pagename>.xaml.cs`. Thus, the code-behind for this page is `MainPage.xaml.cs`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个XAML文件都有一个相关的后置代码页面，其名称为 `<pagename>.xaml.cs`。因此，这个页面的后置代码是 `MainPage.xaml.cs`。
- en: 'The code-behind file is typically (and correctly) named after the class (that
    is, the `MainPage` class will be in `MainPage.xaml` and `MainPage.xaml.cs`). The
    namespace is explicitly declared in the file and should follow the folder structure.
    Thus, if the namespace is `ForgetMeNotDemo`/`MainPage`, then we’d expect `MainPage.cs`
    to have the `ForGetMeNotDemo` namespace:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 后置代码文件通常（并且正确地）以类的名称命名（即，`MainPage` 类将在 `MainPage.xaml` 和 `MainPage.xaml.cs`
    中）。命名空间在文件中明确声明，并应遵循文件夹结构。因此，如果命名空间是 `ForgetMeNotDemo`/`MainPage`，那么我们预计 `MainPage.cs`
    将具有 `ForGetMeNotDemo` 命名空间：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that this is a partial class. In .NET MAUI, all UI classes are marked
    partial. Notice also that the class indicates that it is `ContentPage`, which
    is consistent with what we saw in the XAML.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是一个部分类。在 .NET MAUI 中，所有 UI 类都被标记为部分。注意，该类表明它是 `ContentPage`，这与我们在 XAML 中看到的一致。
- en: In addition to defining classes, you can use XAML to create the layout of the
    page, that is, where things go in relation to one another. XAML provides a number
    of layout options as described next.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义类之外，您还可以使用XAML来创建页面的布局，即元素之间相互关系的位置。XAML提供了一系列布局选项，如下所述。
- en: Exploring the layout options
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索布局选项
- en: Returning to `MainPage.xaml`, the first thing we see below `ContentPage` is
    a `ScrollView` layout element. This is a layout that essentially says that anything
    contained in `ScrollView` can (surprise!) scroll.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `MainPage.xaml`，我们看到 `ContentPage` 下方的是 `ScrollView` 布局元素。这是一个布局，本质上表示 `ScrollView`
    中包含的任何内容都可以（惊喜！）滚动。
- en: 'A layout contains other layouts and controls. It does this just as it’s done
    in XML, which is with opening and closing tags. Here is the syntax:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 布局包含其他布局和控制元素。它就像在XML中做的那样做，即使用开闭标签。以下是语法：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A page can have only one element. Typically, that element is a layout, and since
    layouts can contain other layouts and controls, an entire hierarchy can be created.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个页面只能有一个元素。通常，这个元素是一个布局，由于布局可以包含其他布局和控制元素，因此可以创建整个层次结构。
- en: 'The top four elements in `MainPage.xaml` (out of the box) are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainPage.xaml` 中的前四个元素（默认情况下）如下：'
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Why is this code different from what is in the repo?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这段代码与仓库中的代码不同？
- en: The preceding code is what you get out of the box. In this chapter, we will
    enhance this code, and the repo reflects the finished version as of the end of
    the chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take this one element at a time. We’ve already discussed the first element,
    `ScrollView`, so let’s start with the next, that is, `VerticalStackLayout`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: VerticalStackLayout
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside `ScrollView` is `VerticalStackLayout`. As the name implies, this layout
    holds things stacked one on top of another. Here, we have defined three properties
    for `VerticalStackLayout`: `Spacing`, `Padding`, and `VerticalOptions`. Now, `VerticalStackLayout`
    has dozens of properties and methods. We will learn more about this in [*Chapter*
    *5*](B19723_05.xhtml#_idTextAnchor092)*, Layouts*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '`Spacing` determines the amount of vertical space there is between each of
    the contained elements. Here, `Spacing` is set to `25` **device-independent units**
    (**DIPs**). Using DIPs means that you can define the size for one device (phone,
    Windows, and so on) and have it look as you intend on all other devices. At least
    that’s the theory. As a good friend once said, “In theory, theory and practice
    are the same. But in practice, they never are.”'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The second property is `Padding`. This is one of the ways you can control the
    position and alignment of your controls. The second principal way is with `Margins`.
    This tells you the distance from the nearest other element (or from the edge of
    the page), whereas `Padding` tells you the size of the buffer around the current
    element, as shown in *Figure 3**.1*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Padding and Margin'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B19723.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Padding and Margin
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '`Padding` is written in the format *left*, *top*, *right*, *bottom*. A `Padding`
    value of (`20`,`10`,`5`,`0`) would have a padding on the left of `20` DIPs, `10`
    on the top, `5` on the right, and no DIPs on the bottom. If the top and bottom
    are the same, they can be combined. The same is true for the right and left. Thus,
    as we have here, `Padding = "30,0"`, which means that the left and right will
    have a padding of `30` but there will be no padding on the top and bottom.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'The final property in `VerticalStackLayout` is `VerticalOptions`, which indicates
    where to place `VerticalStackLayout` with respect to its container (in this case,
    `ScrollView`). The options for this are based on an enumeration:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '*Center*'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*End*'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fill*'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Start*'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This enumeration is used with a number of different layouts and controls. For
    now, it is enough to know that *Start* means *top* for vertical layouts and *far
    left* for horizontal. Similarly, *End* means *far right* for horizontal and *bottom*
    for vertical. We’ll return to these values later in the book.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Image
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third element of the page is an `Image` element, which in this case has
    four properties. The first is the source (where to find the image). The second
    is called `SemanticProperties.Description`. **Semantic properties** are added
    to assist those who use screen readers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: You cannot set the height directly (it is read only), but you can set `HeightRequest`,
    which we have done here to `200` DIPs. .NET MAUI will try to provide that height
    depending on your other settings on the page and the available space. Finally,
    we set `HorizontalOptions` to `Center` so that we center the image on the horizontal
    axis.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能直接设置高度（它是只读的），但您可以设置`HeightRequest`，我们在这里将其设置为`200` DIPs。.NET MAUI将尝试根据您在页面上的其他设置和可用空间提供该高度。最后，我们将`HorizontalOptions`设置为`Center`，以便在水平轴上居中图像。
- en: Label
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签
- en: Next, we see `Label`. In this case, it too has four properties. The first is
    the text to display on the label. The second is, again, for screen readers, indicating
    the organizational structure (here the label is at the top level). The third property
    is `FontSize`. There are a couple of ways to set `FontSize`, as we’ll see in [*Chapter
    4*](B19723_04.xhtml#_idTextAnchor054), but here we are using DIPs. Finally, once
    again, we set `HorizontalOptions` to `Center`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到`Label`。在这种情况下，它也有四个属性。第一个是标签上要显示的文本。第二个属性，同样是为了屏幕阅读器，表示组织结构（在这里标签位于顶层）。第三个属性是`FontSize`。设置`FontSize`有几种方法，我们将在[*第4章*](B19723_04.xhtml#_idTextAnchor054)中看到，但在这里我们使用DIPs。最后，再次设置`HorizontalOptions`为`Center`。
- en: If you scroll down the page, you’ll see there is another `Label` and a `Button`
    control (which does pretty much what you’d guess).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向下滚动页面，您会看到另一个`Label`和一个`Button`控件（它几乎可以做您所猜测的一切）。
- en: At the bottom, you will see the close for `VerticalStackLayout`, then the close
    for `ScrollView`, and finally the close for `ContentPage` itself.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，您将看到`VerticalStackLayout`的关闭，然后是`ScrollView`的关闭，最后是`ContentPage`本身的关闭。
- en: 'The XAML thus provides a highly structured approach to describing the layout.
    Here is the complete XAML page:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，XAML提供了一种高度结构化的方法来描述布局。以下是完整的XAML页面：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This page opens by declaring `ContentPage` (the most common type of page) and
    defines the namespace and name of the page (which will be reflected in the code-behind
    as well). It then declares two standard namespaces (using `xmlns`), the first
    for .NET MAUI and the second for the XAML markup.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面通过声明`ContentPage`（最常见的页面类型）并定义页面的命名空间和名称（这将在代码后也反映出来）来打开。然后声明两个标准命名空间（使用`xmlns`），第一个用于.NET
    MAUI，第二个用于XAML标记。
- en: We see `ScrollView`, and inside of that, we see `VerticalStackLayout`, which
    is set to use padding and spacing and to be centered vertically. We’ll review
    these properties as we go along.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`ScrollView`，在其中我们看到`VerticalStackLayout`，它被设置为使用填充和间距，并垂直居中。我们将随着我们的进展回顾这些属性。
- en: '`VerticalStackout` contains four controls: an image, two labels, and a button.
    Each of these controls has its own properties. You do not have to be concerned
    about these properties now; they are explained later. The takeaway here is that
    layouts can contain layouts and controls. They stack like Ukrainian dolls, one
    within the other (though controls do not contain controls).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`VerticalStackout`包含四个控件：一个图像，两个标签和一个按钮。每个控件都有自己的属性。您现在不必担心这些属性；它们将在稍后解释。这里的要点是布局可以包含布局和控件。它们像乌克兰娃娃一样堆叠，一个套一个（尽管控件不包含控件）。'
- en: Notes
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Each `ContentPage` can have only one layout, but that layout can contain other
    layouts (as we see here), and so that is not a troublesome problem.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`ContentPage`只能有一个布局，但该布局可以包含其他布局（正如我们在这里看到的），因此这不是一个问题。
- en: Also, note that due to the size restriction of the printed page, some text will
    wrap to the next line.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，由于打印页面的尺寸限制，一些文本将换行到下一行。
- en: You can even do this in Visual Studio by going to **Tools** | **Options** |
    **C#** | **General** and checking the box for **Word wrap**. If you do this, I
    recommend also checking **Show visual glyphs for word wrap**, which makes reading
    the code easier. While you are there, you may want to check **Line numbers**,
    which can come in very handy, especially when tracking down compile errors. These
    options are shown in *Figure 3**.2*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以在Visual Studio中这样做，方法是转到**工具** | **选项** | **C#** | **常规**，并勾选**自动换行**复选框。如果您这样做，我建议您还勾选**显示自动换行视觉符号**，这会使阅读代码更容易。当您在那里时，您可能还想检查**行号**，这在追踪编译错误时非常有用。这些选项在*图3.2*中显示。
- en: '![Figure 3.2 – Setting Word wrap and Line numbers'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 设置自动换行和行号'
- en: '](img/Figure_3.2_B19723.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B19723.jpg)'
- en: Figure 3.2 – Setting Word wrap and Line numbers
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 设置自动换行和行号
- en: Now, when your line of code is too wide to display, it will wrap and you’ll
    see a small arrow on the right side indicating that the line has continued, as
    shown in *Figure 3**.3*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你的代码行太宽而无法显示时，它将自动换行，你会在右侧看到一个小的箭头，表示该行已继续，如*图3.3*所示。3*.
- en: '![Figure 3.3 – Visual Studio word wrap'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – Visual Studio自动换行'
- en: '](img/Figure_3.3_B19723.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.3_B19723.jpg)'
- en: Figure 3.3 – Visual Studio word wrap
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – Visual Studio自动换行
- en: When something happens such as the user clicking a button, an event is raised.
    The event is handled in the code-behind, which we’ll review next.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生某些事件，例如用户点击按钮时，会引发一个事件。该事件在代码背后被处理，我们将在下一节中回顾。
- en: Events versus commands
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 事件与命令
- en: Starting in the next chapter, we will stop working with events and switch to
    commands. Commands are handled in the ViewModel, which makes them easier to test.
    For now, for convenience, we’ll handle events and we’ll do so in the code-behind.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一章开始，我们将停止使用事件，转而使用命令。命令在ViewModel中处理，这使得它们更容易测试。现在，为了方便起见，我们将处理事件，并在代码背后进行处理。
- en: Code-behind and event handlers
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码背后和事件处理器
- en: 'We see in the `Button` control listed next that there is a `Clicked` property
    that points to a `OnCounterClicked` method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下面的`Button`控件列表中看到有一个`Clicked`属性，它指向`OnCounterClicked`方法：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method (`onCounterClicked`) is found in the code-behind file, `MainPage.xaml.cs`.
    All `EventArgs` (or a class derived from `EventArgs`). By convention, the `EventArgs`
    parameter is named `e`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法（`onCounterClicked`）位于代码背后文件，`MainPage.xaml.cs`中。所有`EventArgs`（或从`EventArgs`派生的类）。按照惯例，`EventArgs`参数被命名为`e`。
- en: 'In our case (and most cases), we don’t care about the sender and the simple
    `EventArgs` (as used here) is empty and serves only as a base class for derived
    classes that provide additional information to the event handler (thus you might
    have a type derived from `EventArgs` that provides information that the event
    handler needs):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的情况（以及大多数情况）中，我们并不关心发送者以及简单的`EventArgs`（如这里所用的），它是空的，仅作为提供额外信息的派生类的事件处理器的基类（因此你可能有一个从`EventArgs`派生的类型，它提供了事件处理器所需的信息）： '
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The event handler name matches the event handler identified in the XAML.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器名称与XAML中识别的事件处理器匹配。
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This handler’s job is only to update the text on the button each time the button
    is clicked. Finally, it uses the `SemanticScreenReader Announce` method to show
    that text, again for screen readers:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理器的任务仅在每个按钮被点击时更新按钮上的文本。最后，它使用`SemanticScreenReader Announce`方法再次显示该文本，以便屏幕阅读器：
- en: 'The count instance field is declared at the top of the class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 计数实例字段在类的顶部声明：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: InitializeComponent
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: InitializeComponent
- en: Notice that the constructor calls `InitializeComponent`. This will be true in
    the code-behind file of every XAML file. It is the job of `InitializeComponent`
    to initialize all the elements of the page.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，构造函数调用了`InitializeComponent`。这将在每个XAML文件的代码背后文件中成立。`InitializeComponent`的职责是初始化页面的所有元素。
- en: When we get to [*Chapter 4*](B19723_04.xhtml#_idTextAnchor054), you’ll see that
    we try to minimize the contents of the code-behind file, principally to facilitate
    the creation of unit tests. At that point, we’ll substitute commands for our events,
    but let’s hold off on that for now.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达[*第4章*](B19723_04.xhtml#_idTextAnchor054)时，你会看到我们试图最小化代码背后文件的 内容，主要是为了便于创建单元测试。到那时，我们将用命令替换我们的事件，但现在我们先不这么做。
- en: While nearly all the Microsoft documentation and all the existing sample code
    uses XAML for markup, it is possible to create layouts and views in C#. In fact,
    in recent years, more and more of the Microsoft documentation shows both.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然几乎所有Microsoft文档和现有的示例代码都使用XAML进行标记，但也可以使用C#创建布局和视图。事实上，近年来，越来越多的Microsoft文档显示了这两种方法。
- en: .NET MAUI Community Toolkit
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI Community Toolkit
- en: This section requires the .NET MAUI Community Toolkit that you added as a NuGet
    package in the previous chapter. The Community Toolkit is actually part of a set
    of toolkits that are open source projects and supplement what is in the release
    version of .NET MAUI. They are created by community members who work closely with
    Microsoft developers. It is fair to assume that many of the Community Toolkit
    features will migrate into .NET MAUI properly over time. I would strongly urge
    you to use these toolkits, and this book does so.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本节需要您在上一章中添加的.NET MAUI社区工具包。实际上，社区工具包是工具包集合的一部分，这些工具包是开源项目，并补充了.NET MAUI发布版本中的内容。它们是由与微软开发者紧密合作的社区成员创建的。可以合理假设，许多社区工具包的功能将随着时间的推移正确迁移到.NET
    MAUI中。我强烈建议您使用这些工具包，本书也是如此。
- en: If you can do it in XAML, you can do it in C#
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果您能在XAML中做到，您就能在C#中做到。
- en: Anything that can be declared in XAML can be declared in C#. Containment is
    managed by using the `children` property of an object. Event handlers must be
    registered on an instance of the control. That is, an event handler would be registered
    for a particular button, as you’ll see in this example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以在XAML中声明的都可以在C#中声明。包含是通过使用对象的`children`属性来管理的。事件处理程序必须在控件的一个实例上注册。也就是说，将为特定的按钮注册一个事件处理程序，正如您将在本例中看到的那样。
- en: 'Here is the code we wrote in XAML converted to C#:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们在XAML中编写的代码转换为C#：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s quickly take a look at hooking up this new `MainPage`. To test this C#
    version, set the `ShellContent` element in `AppShell.xaml` to point to your new
    page like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下如何连接这个新的`MainPage`。为了测试这个C#版本，将`AppShell.xaml`中的`ShellContent`元素设置为指向您的新页面，如下所示：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Coming back to the XAML converted to C# code, let’s break it down for a better
    understanding. The numbers refer to the numbers in square brackets in the code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 回到将XAML转换为C#代码，让我们分析一下，以便更好地理解。这些数字指的是代码中括号内的数字：
- en: We begin by adding a `using` statement for `CommunityToolkit`. We need this
    for the semantic hints, which are used by screen readers for people with limited
    or no eyesight. While a finished project should have these for every control,
    we won’t be using them in this book to save space and confusion.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先添加一个`using`语句用于`CommunityToolkit`。我们需要这个用于语义提示，这些提示被屏幕阅读器用于视力有限或无视力的人。虽然一个完成的项目应该为每个控件都有这些，但我们不会在这本书中使用它们以节省空间和混淆。
- en: We want to add a button, and that button will need an event handler (for the
    click event). In this example, the event handler for the `Clicked` event is at
    the bottom of the file. To add an event handler to our button, we must first define
    `Button`. We do this outside of the constructor and we set its properties [`2`].
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想添加一个按钮，并且这个按钮需要一个事件处理程序（用于点击事件）。在这个例子中，`Clicked`事件的事件处理程序位于文件底部。为了向我们的按钮添加事件处理程序，我们必须首先定义`Button`。我们这样做是在构造函数之外，并设置其属性[2]。
- en: At the very beginning of the constructor, we assign the event handler method
    to the `Clicked` event. As noted, that event handler method is at the bottom of
    the file, though of course it could be (and perhaps should be) in its own file
    [`3`].
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数的非常开始处，我们将事件处理程序方法分配给`Clicked`事件。正如所注，该事件处理程序方法位于文件底部，尽管当然它可以是（也许应该是）在它自己的文件中[3]。
- en: We are now ready to create `VerticalStackLayout` and all the elements contained
    within the stack layout [`4`].
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好创建`VerticalStackLayout`以及其中包含的所有元素[4]。
- en: These elements will be in the stack layout’s `Children` collection [`5`].
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些元素将位于堆叠布局的`Children`集合中[5]。
- en: Notice that the semantic description is attached to the image using a fluent
    syntax [`6`].
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，语义描述是通过流畅的语法附加到图像上的[6]。
- en: After all the other elements, we are ready to insert our button into the stack
    layout’s `Children` collection [`7`].
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加了所有其他元素之后，我们就可以将按钮插入到堆叠布局的`Children`集合中[7]。
- en: We’ve put the event handler for the button at the bottom of this file, though
    you certainly could move it to a different file, probably in a different folder.
    If you do so, however, remember to add a `using` statement for that namespace
    [`8`].
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将按钮的事件处理程序放在这个文件的底部，尽管您当然可以将其移动到不同的文件，可能是在不同的文件夹中。但是，如果您这样做，请记住为该命名空间添加一个`using`语句[8]。
- en: A note on comments
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于注释的说明
- en: 'There is a raging controversy in the industry about the use of comments in
    C# code. I take a rather extreme position: code should be almost completely self-explanatory.
    That is, if you use appropriate and descriptive names for variables, fields, methods,
    and so on, no comments should be needed. I’m not a fanatic about this; if the
    code is sufficiently complex, a comment here and there can be a big help, but
    comments *rust* and should be used sparingly. Thus, you will find few comments
    in the code, though we will walk through the code in some detail in the paragraphs
    that follow each listing.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在业界关于在 C# 代码中使用注释的问题上存在激烈的争议。我持一个非常极端的观点：代码应该几乎完全自解释。也就是说，如果您为变量、字段、方法等使用适当且描述性的名称，则不需要注释。我并不是一个狂热者；如果代码足够复杂，这里或那里的注释可以大有帮助，但注释会生锈，应该谨慎使用。因此，您会发现代码中注释很少，尽管我们将在接下来的段落中详细讲解代码。
- en: A recent addition to our tool set is the ability to use Fluent C#, which can
    make your C# code tighter and yet easier to read.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们工具集最近增加的功能是能够使用 Fluent C#，这可以使您的 C# 代码更加紧凑且易于阅读。
- en: C# versus Fluent C#
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 与 Fluent C#
- en: In addition to using C# to create your pages, there is a new (as of Winter 2022)
    **Community Toolkit** for Fluent C#. This does not change the basic approach but
    can make creating C# pages cleaner and easier to understand.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 C# 创建您的页面外，还有一个新的（截至 2022 年冬季）**Community Toolkit** 用于 Fluent C#。这并不会改变基本方法，但可以使创建
    C# 页面更加简洁且易于理解。
- en: 'To use this, you’ll need to add the `CommunityToolkit.Maui.Markup` NuGet package.
    Refer to the following figure:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此功能，您需要添加 `CommunityToolkit.Maui.Markup` NuGet 包。请参考以下图示：
- en: '![Figure 3.4 – Getting the markup package from NuGet'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 从 NuGet 获取标记包](img/Figure_3.4_B19723.jpg)'
- en: '](img/Figure_3.4_B19723.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 从 NuGet 获取标记包](img/Figure_3.4_B19723.jpg)'
- en: Figure 3.4 – Getting the markup package from NuGet
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 从 NuGet 获取标记包
- en: The project is open source and can be examined (and extended!) at [https://github.com/communitytoolkit/Maui.Markup](https://github.com/communitytoolkit/Maui.Markup).
    The `ReadMe` file will get you started, though we’ll cover that material in this
    book as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目是开源的，可以在 [https://github.com/communitytoolkit/Maui.Markup](https://github.com/communitytoolkit/Maui.Markup)
    上检查（并扩展！）`ReadMe` 文件将帮助您入门，尽管我们也会在本书中介绍该材料。
- en: 'The first thing you need to do is to update `MauiProgram.cs` to add the toolkit
    to the builder using the following code snippet:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是更新 `MauiProgram.cs`，使用以下代码片段将工具包添加到构建器中：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can and should chain `UseMauiCommunityToolkitMarkup` to `UseMauiCommunityToolkit`
    in the builder [`1`].
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 `UseMauiCommunityToolkitMarkup` 链接到 `UseMauiCommunityToolkit` 在构建器中[1]。
- en: 'Now, you can avoid writing this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以避免编写以下内容：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Instead, you can chain all of that together and just write this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以将其全部链接起来，只需写下这个：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This makes the code much cleaner.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得代码更加简洁。
- en: I will provide C# and Fluent C# examples throughout the book; although, as noted,
    the primary markup language we’ll use is XAML.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在整本书中提供 C# 和 Fluent C# 的示例；尽管如此，正如所提到的，我们将使用的主要标记语言是 XAML。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we examined the markup language XAML, which is used to create
    layouts and controls. We saw that anything that can be done in XAML can also be
    done in C#, and we saw that there are two ways to write that C#: the traditional
    declarative way and the newer fluent form.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了标记语言 XAML，它用于创建布局和控件。我们看到在 XAML 中可以完成的事情也可以在 C# 中完成，我们看到了有两种方式来编写
    C#：传统的声明性方式和较新的流畅形式。
- en: We examined a few important classes (`Button`, `Label`, `Image`, and so on)
    and how events can be handled in the code-behind class. I also hinted that code-behind
    event handlers will be replaced by commands and their implementation in the ViewModel
    in the next chapter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查了一些重要的类（如 `Button`、`Label`、`Image` 等）以及如何在代码后端类中处理事件。我还暗示，在下一章中，代码后端的事件处理程序将被命令及其在
    ViewModel 中的实现所取代。
- en: 'In [*Chapter 4*](B19723_04.xhtml#_idTextAnchor054), we’ll dive into the principal
    architecture for writing apps in .NET MAUI: **Model-View-ViewModel** (**MVVM**)
    and we’ll look at data binding. We’ll then explore a number of controls and how
    they can work together.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B19723_04.xhtml#_idTextAnchor054) 中，我们将深入了解在 .NET MAUI 中编写应用程序的主要架构：**模型-视图-视图模型**（**MVVM**），我们将探讨数据绑定。然后我们将探索许多控件以及它们如何协同工作。
- en: Quiz
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: In a sentence, what is XAML?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一句话来说，XAML 是什么？
- en: What is XAML used for?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XAML 用于什么？
- en: What is an alternative to using XAML?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 XAML 的替代方案是什么？
- en: How do we nest one layout inside another using C#?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用 C# 在一个布局内部嵌套另一个布局？
- en: What is an event handler?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是事件处理程序？
- en: If an event is declared in XAML, where is the event handler?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在 XAML 中声明了一个事件，事件处理程序在哪里？
- en: Try it out
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下
- en: Time to start writing code!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始编写代码了！
- en: Create a new project named `ForgetMeNotJesse` (you might want to use your own
    name where I have put mine). Ideally, put that project under source control (see
    the *Technical requirements* section at the top of this chapter).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `ForgetMeNotJesse` 的新项目（你可能想在放置我的名字的地方使用你自己的名字）。理想情况下，将该项目置于源代码管理之下（参见本章顶部章节的
    *技术要求* 部分）。
- en: Use the .NET MAUI template to create your project, using the latest version
    of .NET (.NET 7 at the time of the writing of this book).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET MAUI 模板创建你的项目，使用本书编写时的最新版本 .NET（.NET 7）。
- en: Run your program to make sure everything is set up correctly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的程序以确保一切设置正确。
- en: Change `MainPage` so that clicking on the button updates a label below the button
    with the number of clicks (in addition to displaying it on the button itself).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `MainPage`，以便点击按钮时，在按钮下方更新一个标签，显示点击次数（除了在按钮本身显示外）。
- en: 'Once the page is working as intended, create a new page and recreate your `MainPage`
    in C# rather than in XAML. To test it, remember to set the `ShellContent` element
    in `AppShell.xaml` to point to your new page like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦页面按预期工作，创建一个新页面，并在 C# 中而不是在 XAML 中重新创建你的 `MainPage`。为了测试，请记住将 `AppShell.xaml`
    中的 `ShellContent` 元素设置为指向你的新页面，如下所示：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you get stuck at any point, pull down the XAML and C# branch from the book’s
    repository and compare that solution with yours.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在任何地方遇到困难，请从本书的仓库中拉取 XAML 和 C# 分支，并将该解决方案与你的解决方案进行比较。
