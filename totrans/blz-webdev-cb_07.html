<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-236">
    <a id="_idTextAnchor236">
    </a>
    
     7
    
   </h1>
   <h1 id="_idParaDest-237">
    <a id="_idTextAnchor237">
    </a>
    
     Validating User Input Forms
    
   </h1>
   <p>
    
     In this chapter, we explore the essential aspect of ensuring the accuracy and integrity of data submitted through forms in Blazor applications.
    
    
     With effective validation, you’ll prevent erroneous data entry and enhance user interactions and application security.
    
    
     Throughout this chapter, we will explore a comprehensive range of techniques and strategies you can employ while validating
    
    
     
      user inputs.
     
    
   </p>
   <p>
    
     We begin with the fundamental process of adding validation to a form, setting the stage for more complex validation scenarios.
    
    
     You will learn how Blazor handles basic validation scenarios and how you can extend them to meet specific domain needs.
    
    
     After that, we explore the use of data annotations for form validation.
    
    
     You’ll uncover how to simplify form validation using built-in annotations and how to leverage them to enforce rules and constraints directly on data models, reducing boilerplate code.
    
    
     Right after, you will see how to implement custom validation attributes, which provide the flexibility to address unique business requirements.
    
    
     Then, we address the validation of complex data models, ensuring that data integrity is maintained even in
    
    
     
      intricate scenarios.
     
    
   </p>
   <p>
    
     At the end of the chapter, we focus on improving the user experience of your forms.
    
    
     We cover the styling of validation messages and modernizing validation summaries.
    
    
     Good styling makes validation messages clear and more aligned with the application’s design, while toasts offer a dynamic way to alert users about issues without disrupting their workflow.
    
    
     Lastly, we explore how to dynamically control form actions based on validation results, ensuring that users can only submit forms in a valid state, thereby avoiding unnecessary submissions and
    
    
     
      server load.
     
    
   </p>
   <p>
    
     By the end of this chapter, you’ll know how to implement effective validation strategies in your Blazor applications, ensuring correct user inputs and enhancing the usability and reliability of
    
    
     
      your application.
     
    
   </p>
   <p>
    
     Here’s the list of recipes we’re going to cover in
    
    
     
      this chapter:
     
    
   </p>
   <ul>
    <li>
     
      Adding validation to
     
     
      
       a form
      
     
    </li>
    <li>
     
      Leveraging data annotations for
     
     
      
       form validation
      
     
    </li>
    <li>
     
      Implementing custom
     
     
      
       validation attributes
      
     
    </li>
    <li>
     
      Validating complex
     
     
      
       data models
      
     
    </li>
    <li>
     
      Styling
     
     
      
       validation messages
      
     
    </li>
    <li>
     
      Displaying a toast when
     
     
      
       validation fails
      
     
    </li>
    <li>
     
      Enabling the submit option based on the
     
     
      
       form state
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-238">
    <a id="_idTextAnchor238">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     In this chapter, recipes build on each other, so you can follow the entire journey within the same directory.
    
    
     However, for clarity and easier initial setup, at the beginning of each recipe, you will find instructions on what working directory to create and which files are required to execute the task at hand.
    
    
     But before diving in, make sure you have all the basic tools for
    
    
     
      Blazor development:
     
    
   </p>
   <ul>
    <li>
     
      A modern IDE (that supports
     
     
      
       Blazor development)
      
     
    </li>
    <li>
     
      A modern web browser (that
     
     
      
       supports WebAssembly)
      
     
    </li>
    <li>
     
      Browser dev tools (which can be a part of the modern
     
     
      
       browser already)
      
     
    </li>
    <li>
     
      A Blazor project (where you’ll write
     
     
      
       your code)
      
     
    </li>
   </ul>
   <p>
    
     In the
    
    <em class="italic">
     
      Validating complex data models
     
    </em>
    
     recipe, we utilize the
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.Components.DataAnnotations.Validation
     
    </strong>
    
     NuGet package, which is not pre-installed by default, so you might as well add it to your project now.
    
    
     Keep in mind that the validation package is still in preview, so you’ll have to include prerelease packages in the NuGet feed in
    
    
     
      your IDE.
     
    
   </p>
   <p>
    
     You can find all the code written in this chapter and code samples on GitHub at:
    
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter07">
     
      
       https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter07
      
     
    </a>
   </p>
   <h1 id="_idParaDest-239">
    <a id="_idTextAnchor239">
    </a>
    
     Adding validation to a form
    
   </h1>
   <p>
    
     In this recipe, we’ll
    
    <a id="_idIndexMarker320">
    </a>
    
     explore the basics of user input validation in Blazor.
    
    
     Validation is
    
    <a id="_idIndexMarker321">
    </a>
    
     critical for preventing errors and security vulnerabilities, maintaining data consistency, and enhancing the user experience.
    
    
     The Blazor community has created various NuGet packages for handling input validation, offering a range of features and configurations.
    
    
     However, Blazor provides extensive built-in support for validating forms and displaying validation results in a user-friendly manner.
    
    
     The native functionalities are lightweight and integrate directly with Blazor’s data binding and
    
    
     
      UI features.
     
    
   </p>
   <p>
    
     Let’s implement a small event creation form, where a user must provide the event name.
    
    
     We will also display a validation message when the event name
    
    
     
      is empty.
     
    
   </p>
   <h2 id="_idParaDest-240">
    <a id="_idTextAnchor240">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we add the first, basic validation to a form, create a
    
    <strong class="source-inline">
     
      Chapter07
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      Recipe01
     
    </strong>
    
     directory – this will be your
    
    
     
      working directory.
     
    
   </p>
   <h2 id="_idParaDest-241">
    <a id="_idTextAnchor241">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to add a simple validation to
    
    
     
      a form:
     
    
   </p>
   <ol>
    <li>
     
      Create an
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      class with a
     
     <strong class="source-inline">
      
       Name
      
     </strong>
     
      property – we will use it as a
     
     
      
       form model:
      
     
     <pre class="source-code">
public class Event
{
    public string Name { get; set; }
}</pre>
    </li>
    <li>
     
      Create a routable
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component that implements the
     
     <strong class="source-inline">
      
       IDisposable
      
     </strong>
     
      interface.
     
     
      You
     
     <a id="_idIndexMarker322">
     </a>
     
      will
     
     <a id="_idIndexMarker323">
     </a>
     
      see compilation errors now, but we will resolve
     
     
      
       them later:
      
     
     <pre class="source-code">
@page "/ch07r01"
@implements IDisposable</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      , declare an
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      model to serve as the backing model for
     
     
      
       the form:
      
     
     <pre class="source-code">
[SupplyParameterFromForm]
public Event Model { get; set; }</pre>
    </li>
    <li>
     
      Below the
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      parameter declaration, introduce the
     
     <strong class="source-inline">
      
       Context
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Store
      
     </strong>
     
      variables for the form’s
     
     
      
       state management:
      
     
     <pre class="source-code">
protected EditContext Context;
protected ValidationMessageStore Store;</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a
     
     <strong class="source-inline">
      
       Save()
      
     </strong>
     
      placeholder method to simulate
     
     
      
       form submission:
      
     
     <pre class="source-code">
private void Save()
    =&gt; Console.WriteLine($"Saved {Model.Name}.");</pre>
    </li>
    <li>
     
      Alongside
     
     <strong class="source-inline">
      
       Save()
      
     </strong>
     
      , implement a
     
     <strong class="source-inline">
      
       ValidateForm()
      
     </strong>
     
      method, with a signature matching the response
     
     <a id="_idIndexMarker324">
     </a>
     
      of a
     
     <strong class="source-inline">
      
       EventHandler
      
     </strong>
     
      validation, which checks whether the
     
     <strong class="source-inline">
      
       Model.Name
      
     </strong>
     
      property
     
     <a id="_idIndexMarker325">
     </a>
     
      has a
     
     
      
       valid value:
      
     
     <pre class="source-code">
private void ValidateForm(object sender, ValidationRequestedEventArgs args)
{
    Store.Clear();
    if (string.IsNullOrWhiteSpace(Model.Name))
        Store.Add(() =&gt; Model.Name,
            "You must provide a name.");
}</pre>
    </li>
    <li>
     
      Continuing in the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, override the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      life cycle method to initialize the
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      instance if needed and set up both the form context and the validation
     
     
      
       message container:
      
     
     <pre class="source-code">
protected override void OnInitialized()
{
    Model ??= new();
    Context = new(Model);
    Context.OnValidationRequested += ValidateForm;
    Store = new(Context);
}</pre>
    </li>
    <li>
     
      Finalize the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block by implementing the
     
     <strong class="source-inline">
      
       Dispose()
      
     </strong>
     
      method to adhere to the
     
     <strong class="source-inline">
      
       IDisposable
      
     </strong>
     
      requirement and unsubscribe from the validation
     
     
      
       event handler:
      
     
     <pre class="source-code">
public void Dispose()
{
    if (Context is not null)
        Context.OnValidationRequested -= ValidateForm;
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      markup, include an
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      component, attaching
     
     <strong class="source-inline">
      
       Context
      
     </strong>
     
      to the
     
     <a id="_idIndexMarker326">
     </a>
     
      appropriate
     
     <a id="_idIndexMarker327">
     </a>
     
      parameter and linking the
     
     <strong class="source-inline">
      
       Save()
      
     </strong>
     
      method to handle the
     
     
      
       form submission:
      
     
     <pre class="source-code">
&lt;EditForm EditContext="@Context"
          event-form="forEvent-form"
          OnValidSubmit="@Save"&gt;
&lt;/EditForm&gt;</pre>
    </li>
    <li>
     
      Inside
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      , add an
     
     <strong class="source-inline">
      
       InputText
      
     </strong>
     
      component and bind it to the
     
     <strong class="source-inline">
      
       Model.Name
      
     </strong>
     
      property.
     
     
      Alongside
     
     <strong class="source-inline">
      
       InputText
      
     </strong>
     
      , add a
     
     <strong class="source-inline">
      
       ValidationMessage
      
     </strong>
     
      component to display validation errors for the
     
     
      
       attached property:
      
     
     <pre class="source-code">
&lt;p&gt;Name: &lt;InputText @bind-Value="@Model.Name" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;ValidationMessage For="() =&gt; Model.Name" /&gt;&lt;/p&gt;</pre>
    </li>
    <li>
     
      Lastly, complete
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      by adding a submit button below the
     
     
      
       form fields:
      
     
     <pre class="source-code">
&lt;button type="submit"&gt;Save&lt;/button&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-242">
    <a id="_idTextAnchor242">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create a simple
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     class with a single
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     property.
    
    
     We will use
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     as a model for our form.
    
    
     Next, in
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we create a routable
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component, not specifying any render mode, which leads Blazor to default to static server-side mode.
    
    
     As form validation is event driven,
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     must implement the
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     interface, which we apply using the
    
    <strong class="source-inline">
     
      @implements
     
    </strong>
    
     directive.
    
    
     You will see compilation errors now, but we will resolve
    
    
     
      them later.
     
    
   </p>
   <p>
    
     Moving to
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , within the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     , we utilize the
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     class to declare the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     parameter, tagging it with the
    
    <strong class="source-inline">
     
      SupplyParameterFromForm
     
    </strong>
    
     attribute to enable an automatic binding with the form.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we introduce two form-backing variables:
    
    <strong class="source-inline">
     
      EditContext
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      ValidationMessageStore
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      EditContext
     
    </strong>
    
     instance tracks changes to form inputs and manages the validation state, while
    
    <strong class="source-inline">
     
      ValidationMessageStore
     
    </strong>
    
     holds and displays validation messages, simplifying the
    
    
     
      validation process.
     
    
   </p>
   <p>
    
     Proceeding to
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we implement a
    
    <strong class="source-inline">
     
      Save()
     
    </strong>
    
     placeholder method.
    
    
     Data persistence isn’t the focus of this chapter, so we log a brief message to the console to simulate a save operation.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we implement the
    
    <strong class="source-inline">
     
      ValidateForm()
     
    </strong>
    
     method with a signature that matches the
    
    <a id="_idIndexMarker328">
    </a>
    
     validation
    
    <a id="_idIndexMarker329">
    </a>
    
     handler required by
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     .
    
    
     Whenever Blazor invokes
    
    <strong class="source-inline">
     
      ValidateForm()
     
    </strong>
    
     , we first clear any messages in
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     to handle multiple validation attempts smoothly.
    
    
     Then, we check whether the user provided the
    
    <strong class="source-inline">
     
      Model.Name
     
    </strong>
    
     property; if not, we add a
    
    <strong class="bold">
     
      You must provide a name.
     
    </strong>
    
     message to
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     and identify the invalid property with a delegate,
    
    <strong class="source-inline">
     
      () =&gt; Model.Name
     
    </strong>
    
     .
    
    
     Under the hood, Blazor breaks down this delegate into the object (
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     ) and the property path string (
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     ) to efficiently track and manage validation and
    
    
     
      error association.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we override the
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     life cycle method to set up the form’s underlying logic.
    
    
     We resolve the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     value, supporting the pattern for the parameter with the
    
    <strong class="source-inline">
     
      SupplyParameterFromForm
     
    </strong>
    
     attribute.
    
    
     We then initialize
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     with the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     object and subscribe
    
    <strong class="source-inline">
     
      ValidateForm()
     
    </strong>
    
     to the
    
    <strong class="source-inline">
     
      OnValidationRequested
     
    </strong>
    
     event handler that
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     exposes.
    
    
     With that, Blazor will automatically invoke
    
    <strong class="source-inline">
     
      ValidateForm()
     
    </strong>
    
     every time the user submits the form.
    
    
     Finally, we initialize
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     by passing
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     , so the validation container can access the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     fields.
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we wrap up the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block by implementing the
    
    <strong class="source-inline">
     
      Dispose()
     
    </strong>
    
     method, adhering to the
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     pattern.
    
    
     Within
    
    <strong class="source-inline">
     
      Dispose()
     
    </strong>
    
     , we safely unsubscribe
    
    <strong class="source-inline">
     
      ValidateForm()
     
    </strong>
    
     from the validation trigger of
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     to prevent potential
    
    
     
      memory leaks.
     
    
   </p>
   <p>
    
     Having the backend logic in place, we proceed to the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     markup.
    
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we add an
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component, but instead of attaching the backing
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     instance directly, we attach
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     to the
    
    <strong class="source-inline">
     
      EditContext
     
    </strong>
    
     parameter.
    
    
     Blazor will not allow attaching both
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      EditContext
     
    </strong>
    
     since
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     already encompasses an instance of
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     .
    
    
     We also use the
    
    <strong class="source-inline">
     
      OnValidSubmit
     
    </strong>
    
     callback rather than the standard
    
    <strong class="source-inline">
     
      OnSubmit
     
    </strong>
    
     .
    
    
     Blazor invokes
    
    <strong class="source-inline">
     
      OnValidSumbit
     
    </strong>
    
     only when all validations pass successfully, making it ideal for our needs.
    
    
     In
    
    <em class="italic">
     
      step 10
     
    </em>
    
     , within
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     , we place an
    
    <strong class="source-inline">
     
      InputText
     
    </strong>
    
     component and bind it to the
    
    <strong class="source-inline">
     
      Model.Name
     
    </strong>
    
     property, enabling the user to provide the required event name.
    
    
     Alongside
    
    <strong class="source-inline">
     
      InputText
     
    </strong>
    
     , we position a
    
    <strong class="source-inline">
     
      ValidationMessage
     
    </strong>
    
     component that displays validation messages for the specific form field.
    
    
     As
    
    <strong class="source-inline">
     
      ValidationMessage
     
    </strong>
    
     requires a delegate to retrieve messages from the container, we leverage the same delegate we used in
    
    <strong class="source-inline">
     
      ValidateForm()
     
    </strong>
    
     for seeding a validation message into
    
    <strong class="source-inline">
     
      Store
     
    </strong>
    
     .
    
    
     Finally, in
    
    <em class="italic">
     
      step 11
     
    </em>
    
     , we complete the form implementation by adding a
    
    
     
      submit button.
     
    
   </p>
   <p>
    
     When the user submits the form, Blazor triggers the
    
    <strong class="source-inline">
     
      OnValidationRequested
     
    </strong>
    
     event handler first.
    
    
     If
    
    <a id="_idIndexMarker330">
    </a>
    
     validation results in errors, the
    
    <strong class="source-inline">
     
      Save()
     
    </strong>
    
     method is not
    
    <a id="_idIndexMarker331">
    </a>
    
     activated, ensuring that only valid data
    
    
     
      is processed.
     
    
   </p>
   <p>
    
     Here’s what the validation error looks like in
    
    
     
      our form:
     
    
   </p>
   <div><div><img alt="Figure 7.1: Validation message when user submits the form without providing the name" src="img/B22020_07_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.1: Validation message when user submits the form without providing the name
    
   </p>
   <h2 id="_idParaDest-243">
    <a id="_idTextAnchor243">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     With the
    
    <strong class="source-inline">
     
      ValidationMessage
     
    </strong>
    
     component, we
    
    <a id="_idIndexMarker332">
    </a>
    
     can control where Blazor renders validation messages for each field, providing granular feedback directly next to individual form elements.
    
    
     However, you might want to display a consolidated validation summary rather than scattered messages.
    
    
     That’s where the
    
    <strong class="source-inline">
     
      ValidationSummary
     
    </strong>
    
     component comes in handy.
    
    
     The
    
    <strong class="source-inline">
     
      ValidationSummary
     
    </strong>
    
     component gathers and displays all validation messages within one container.
    
    
     You can see such summaries at the top or bottom of the forms or even as part of a
    
    
     
      validation popup.
     
    
   </p>
   <p>
    
     To implement a summary in
    
    <a id="_idIndexMarker333">
    </a>
    
     our
    
    <a id="_idIndexMarker334">
    </a>
    
     form, we only need to replace
    
    <strong class="source-inline">
     
      ValidationMessage
     
    </strong>
    
     with
    
    <strong class="source-inline">
     
      ValidationSummary
     
    </strong>
    
     and add a
    
    <strong class="source-inline">
     
      DataAnnotationsValidator
     
    </strong>
    
     component within
    
    
     
      the form:
     
    
   </p>
   <pre class="source-code">
&lt;EditForm EditContext="@Context" 
          FormName="forEvent-form"
          OnValidSubmit="@Save"&gt;
    &lt;DataAnnotationsValidator /&gt;
    &lt;p&gt;Name: &lt;InputText @bind-Value="@Model.Name" /&gt;&lt;/p&gt;
    &lt;p&gt;&lt;ValidationSummary /&gt;&lt;/p&gt;
    &lt;button type="submit"&gt;Save&lt;/button&gt;
&lt;/EditForm&gt;</pre>
   <p>
    
     We must embed
    
    <strong class="source-inline">
     
      DataAnnotationsValidator
     
    </strong>
    
     as it triggers the population and re-render of
    
    <strong class="source-inline">
     
      ValidationSummary
     
    </strong>
    
     .
    
    
     Without the validator, will get the red input styling, indicating that the value provided is invalid, but
    
    <a id="_idIndexMarker335">
    </a>
    
     no
    
    <a id="_idIndexMarker336">
    </a>
    
     message
    
    
     
      explaining why.
     
    
   </p>
   <p>
    
     We explore
    
    <strong class="source-inline">
     
      DataAnnotationsValidator
     
    </strong>
    
     further in the
    
    
     
      next recipe.
     
    
   </p>
   <h1 id="_idParaDest-244">
    <a id="_idTextAnchor244">
    </a>
    
     Leveraging data annotations for form validation
    
   </h1>
   <p>
    
     In this recipe, we
    
    <a id="_idIndexMarker337">
    </a>
    
     explore
    
    <a id="_idIndexMarker338">
    </a>
    
     the role of
    
    <strong class="bold">
     
      data annotations
     
    </strong>
    
     in streamlining and enhancing the validation processes in a form in Blazor.
    
    
     Data annotations are attributes applied directly to model properties that enable a declarative way of specifying validation rules.
    
    
     By implementing data annotations, you can significantly simplify the validation logic and encapsulate it within the model rather than coupling it with any specific form.
    
    
     Such separation ensures that validation is consistently enforced across different parts of your application regardless of the context in which you use the model.
    
    
     Blazor has a built-in
    
    <strong class="source-inline">
     
      DataAnnotationsValidator
     
    </strong>
    
     component that seamlessly integrates data annotations into a form.
    
    <strong class="source-inline">
     
      DataAnnotationsValidator
     
    </strong>
    
     checks the data annotations applied to the model and produces validation results without
    
    
     
      additional coding.
     
    
   </p>
   <p>
    
     Let’s convert an explicit validation logic in a form into data annotations and leverage Blazor’s native support to handle
    
    
     
      validation efficiently.
     
    
   </p>
   <h2 id="_idParaDest-245">
    <a id="_idTextAnchor245">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we encapsulate the validation logic into a
    
    
     
      separate component:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter07
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Adding validation to a form
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter07
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe01
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-246">
    <a id="_idTextAnchor246">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps
    
    <a id="_idIndexMarker339">
    </a>
    
     to
    
    <a id="_idIndexMarker340">
    </a>
    
     leverage data annotations for
    
    
     
      model validation:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      class and decorate the
     
     <strong class="source-inline">
      
       Name
      
     </strong>
     
      property with the
     
     <strong class="source-inline">
      
       Required
      
     </strong>
     
      attribute with a user-friendly error message.
     
     
      You must reference a
     
     <strong class="source-inline">
      
       System.ComponentModel.DataAnnotations
      
     </strong>
     
      namespace, but your IDE might include
     
     
      
       it automatically:
      
     
     <pre class="source-code">
[Required(ErrorMessage = "You must provide a name.")]
public string Name { get; set; }</pre>
    </li>
    <li>
     
      Move to the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component and remove the
     
     <strong class="source-inline">
      
       IDisposable
      
     </strong>
     
      declaration from the top of the file.
     
     
      You should have only a route
     
     
      
       declaration left.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      markup, locate
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      and embed the
     
     <strong class="source-inline">
      
       DataAnnotationsValidator
      
     </strong>
     
      component just below the
     
     
      
       submission button:
      
     
     <pre class="source-code">
&lt;EditForm EditContext="@Context"
          event-form="event-forEvent"
          OnValidSubmit="@Save"&gt;
    @* ... existing form body ... *@
    &lt;button type="submit"&gt;Save&lt;/button&gt;
    &lt;DataAnnotationsValidator /&gt;
&lt;/EditForm&gt;</pre>
    </li>
    <li>
     
      Jump to the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      and do
     
     
      
       some cleanup:
      
     
     <ul>
      <li>
       
        Remove the subscription to the
       
       <strong class="source-inline">
        
         OnValidationRequested
        
       </strong>
       
        event handler from the
       
       <strong class="source-inline">
        
         OnInitialized()
        
       </strong>
       
        
         method implementation
        
       
      </li>
      <li>
       
        Remove the
       
       <strong class="source-inline">
        
         Dispose()
        
       </strong>
       
        and
       
       <strong class="source-inline">
        
         ValidateForm()
        
       </strong>
       
        
         methods entirely
        
       
      </li>
     </ul>
    </li>
   </ol>
   <h2 id="_idParaDest-247">
    <a id="_idTextAnchor247">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we
    
    <a id="_idIndexMarker341">
    </a>
    
     enhance
    
    <a id="_idIndexMarker342">
    </a>
    
     the
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     class by implementing data annotations to enforce input validation.
    
    
     We decorate the
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     property with the
    
    <strong class="source-inline">
     
      Required
     
    </strong>
    
     attribute to ensure a user always provides that value.
    
    
     Data annotations also accept the
    
    <strong class="source-inline">
     
      ErrorMessage
     
    </strong>
    
     parameter, where we can pass in a user-friendly validation message, so we extend the
    
    <strong class="source-inline">
     
      Required
     
    </strong>
    
     attribute with the
    
    <strong class="bold">
     
      You must provide a name.
     
    </strong>
    
     
      error message.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we move to the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component.
    
    
     With data annotations in place, we no longer need explicit event handling.
    
    
     Consequently, we remove the
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     declaration from the top of the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     file.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we enhance the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     markup and embed the
    
    <strong class="source-inline">
     
      DataAnnotationsValidator
     
    </strong>
    
     component at the end of
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     , just below the submission button.
    
    <strong class="source-inline">
     
      DataAnnotationsValidator
     
    </strong>
    
     operates seamlessly within the form, carrying no distinct markup and relying on the cascading
    
    <strong class="source-inline">
     
      EditContext
     
    </strong>
    
     for validation operations.
    
    
     We placed
    
    <strong class="source-inline">
     
      DataAnnotationsValidator
     
    </strong>
    
     at the end of the form, but you can put it anywhere as long as it’s within the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     tags.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we update the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     .
    
    
     With data annotations now managing validation, we can simplify the component code by removing most of the previously necessary validation logic.
    
    
     We remove the
    
    <strong class="source-inline">
     
      OnValidationRequested
     
    </strong>
    
     subscription within the
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     method, as
    
    <strong class="source-inline">
     
      DataAnnotationsValidator
     
    </strong>
    
     now automatically monitors the validation state.
    
    
     Following this, we also eliminate the
    
    <strong class="source-inline">
     
      ValidateForm()
     
    </strong>
    
     method, as the management of the validation message store and error messages has shifted to
    
    <strong class="source-inline">
     
      DataAnnotationsValidator
     
    </strong>
    
     as well.
    
    
     Lastly, we remove the
    
    <strong class="source-inline">
     
      Dispose()
     
    </strong>
    
     method because
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     no longer implements the
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     interface or listens to
    
    
     
      any events.
     
    
   </p>
   <p>
    
     With these few adjustments, we achieve the same validation scope as in the
    
    <em class="italic">
     
      Adding validation to a form
     
    </em>
    
     recipe
    
    <a id="_idIndexMarker343">
    </a>
    
     but with significantly
    
    <a id="_idIndexMarker344">
    </a>
    
     
      less code!
     
    
   </p>
   <h2 id="_idParaDest-248">
    <a id="_idTextAnchor248">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     With
    
    <strong class="source-inline">
     
      DataAnnotationsValidator
     
    </strong>
    
     in place, Blazor can perform two types
    
    
     
      of validation:
     
    
   </p>
   <ul>
    <li>
     
      The first type is
     
     <strong class="bold">
      
       full-model validation
      
     </strong>
     
      – Blazor
     
     <a id="_idIndexMarker345">
     </a>
     
      executes when the user submits the form.
     
     
      This validation occurs when you click the
     
     <strong class="bold">
      
       Save
      
     </strong>
     
      button on the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      form.
     
     
      It involves checking every validation rule across all fields in the model, ensuring that all data meets the specified criteria before the form is processed.
     
     
      As we’re working in the SSR render mode, which has inherently limited interactivity, only full-model validation
     
     
      
       is supported.
      
     
    </li>
    <li>
     
      However, should you opt to render
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      in an interactive mode,
     
     <strong class="source-inline">
      
       DataAnnotationsValidator
      
     </strong>
     
      can execute another layer of validation –
     
     <strong class="bold">
      
       field validation
      
     </strong>
     
      .
     
     
      Blazor
     
     <a id="_idIndexMarker346">
     </a>
     
      triggers field validation when the user moves the focus away from an individual form field, displaying immediate feedback on the input provided in
     
     <a id="_idIndexMarker347">
     </a>
     
      that
     
     <a id="_idIndexMarker348">
     </a>
     
      
       specific field.
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-249">
    <a id="_idTextAnchor249">
    </a>
    
     Implementing custom validation attributes
    
   </h1>
   <p>
    
     In this recipe, we dive
    
    <a id="_idIndexMarker349">
    </a>
    
     into the flexibility of customizing validation attributes.
    
    
     While built-in data annotations simplify validation logic, they cover only the most commonly used validation rules.
    
    
     You might find yourself missing the coverage for your specific needs.
    
    
     Fortunately, you can implement custom data validation attributes with unique rules beyond the standard validations provided by .NET.
    
    
     Additionally, Blazor’s native
    
    <strong class="source-inline">
     
      DataAnnotationsValidator
     
    </strong>
    
     component seamlessly integrates with any
    
    
     
      custom attributes.
     
    
   </p>
   <p>
    
     Let’s implement an event name validation attribute that checks whether the user provided the event name and scans for any
    
    
     
      forbidden keywords.
     
    
   </p>
   <h2 id="_idParaDest-250">
    <a id="_idTextAnchor250">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we implement a custom validation attribute, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter07
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Leveraging data annotations for form validation
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter07
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-251">
    <a id="_idTextAnchor251">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these instructions to implement a custom
    
    
     
      validation attribute:
     
    
   </p>
   <ol>
    <li>
     
      Create a new
     
     <strong class="source-inline">
      
       EventNameValidationAttribute
      
     </strong>
     
      class that inherits from a
     
     <strong class="source-inline">
      
       ValidationAttribute
      
     </strong>
     
      class.
     
     
      You must reference the
     
     <strong class="source-inline">
      
       System.ComponentModel.DataAnnotations
      
     </strong>
     
      assembly, but your IDE might include
     
     
      
       it automatically:
      
     
     <pre class="source-code">
using System.ComponentModel.DataAnnotations;
public class EventNameValidationAttribute
    : ValidationAttribute
{
}</pre>
    </li>
    <li>
     
      Inside the
     
     <strong class="source-inline">
      
       EventNameValidationAttribute
      
     </strong>
     
      class, declare a private variable,
     
     <strong class="source-inline">
      
       _forbidden
      
     </strong>
     
      , and initialize it with the
     
     
      <strong class="source-inline">
       
        event
       
      </strong>
     
     
      
       value:
      
     
     <pre class="source-code">
private const string _forbidden = "event";</pre>
    </li>
    <li>
     
      Below the
     
     <strong class="source-inline">
      
       _forbidden
      
     </strong>
     
      variable, implement a
     
     <strong class="source-inline">
      
       Failure()
      
     </strong>
     
      method that accepts
     
     <strong class="source-inline">
      
       message
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       member
      
     </strong>
     
      parameters and returns an instance
     
     
      
       of
      
     
     
      <strong class="source-inline">
       
        ValidationResult
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
private static ValidationResult Failure(
    string message, string member)
    =&gt; new(message, [member]);</pre>
    </li>
    <li>
     
      Complete
     
     <a id="_idIndexMarker350">
     </a>
     
      the implementation of
     
     <strong class="source-inline">
      
       EventNameValidationAttribute
      
     </strong>
     
      by overriding the
     
     <strong class="source-inline">
      
       IsValid()
      
     </strong>
     
      method, which returns a
     
     <strong class="source-inline">
      
       ValidationResult
      
     </strong>
     
      object.
     
     
      Return the result of
     
     <strong class="source-inline">
      
       Failure()
      
     </strong>
     
      invocation if the incoming
     
     <strong class="source-inline">
      
       value
      
     </strong>
     
      was not provided or it contains the
     
     <strong class="source-inline">
      
       _forbidden
      
     </strong>
     
      keyword.
     
     
      Otherwise, return the
     
     
      
       default
      
     
     
      <strong class="source-inline">
       
        ValidationResult.Success
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
protected override ValidationResult IsValid(
    object value, ValidationContext validationContext)
{
    var text = value?.ToString();
    if (string.IsNullOrWhiteSpace(text))
        return Failure("You must provide a name.",
            validationContext.MemberName);
    if (text.Contains(_forbidden,
        StringComparison.InvariantCultureIgnoreCase))
        return Failure(
            "You mustn't use the 'event' keyword.",
                validationContext.MemberName);
    return ValidationResult.Success;
}</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      class and update the decoration of the
     
     <strong class="source-inline">
      
       Name
      
     </strong>
     
      property by replacing the
     
     <a id="_idIndexMarker351">
     </a>
     
      existing
     
     <strong class="source-inline">
      
       Required
      
     </strong>
     
      attribute with the newly implemented
     
     
      <strong class="source-inline">
       
        EventNameValidation
       
      </strong>
     
     
      
       attribute:
      
     
     <pre class="source-code">
[EventNameValidation]
public string Name { get; set; }</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-252">
    <a id="_idTextAnchor252">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create an
    
    <strong class="source-inline">
     
      EventNameValidationAttribute
     
    </strong>
    
     class, inheriting from
    
    <strong class="source-inline">
     
      ValidationAttribute
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      ValidationAttribute
     
    </strong>
    
     class is a base class for validation attributes, providing a framework for implementing custom validation rules in .NET applications.
    
    
     It allows for defining specific conditions that data must meet before being processed further.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we declare a
    
    <strong class="source-inline">
     
      _forbidden
     
    </strong>
    
     variable within our custom validation attribute class to store the forbidden keyword to check against the input value.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we implement a
    
    <strong class="source-inline">
     
      Failure()
     
    </strong>
    
     method that accepts the
    
    <strong class="source-inline">
     
      message
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      member
     
    </strong>
    
     parameters.
    
    <strong class="source-inline">
     
      Failure()
     
    </strong>
    
     creates and returns an instance of
    
    <strong class="source-inline">
     
      ValidationResult
     
    </strong>
    
     , representing a failure in validation.
    
    
     The
    
    <strong class="source-inline">
     
      member
     
    </strong>
    
     parameter allows associating the error message with specific fields, enhancing the clarity of feedback provided to
    
    
     
      the user.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we implement the custom validation logic by overriding the
    
    <strong class="source-inline">
     
      IsValid()
     
    </strong>
    
     method from the
    
    <strong class="source-inline">
     
      ValidationAttribute
     
    </strong>
    
     class.
    
    
     Blazor triggers
    
    <strong class="source-inline">
     
      IsValid()
     
    </strong>
    
     when it validates the form model.
    
    
     We choose to override the overload that returns a
    
    <strong class="source-inline">
     
      ValidationResult
     
    </strong>
    
     object rather than a simple
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     , as we want to provide detailed feedback on validation issues.
    
    
     We first convert the incoming
    
    <strong class="source-inline">
     
      value
     
    </strong>
    
     to a
    
    <strong class="source-inline">
     
      text
     
    </strong>
    
     variable.
    
    
     If
    
    <strong class="source-inline">
     
      text
     
    </strong>
    
     doesn’t carry a meaningful value, we call the
    
    <strong class="source-inline">
     
      Failure()
     
    </strong>
    
     method to return a validation error with the message
    
    <strong class="bold">
     
      You must provide a name.
     
    </strong>
    
     .
    
    
     But
    
    <strong class="source-inline">
     
      Failure()
     
    </strong>
    
     also requires providing a
    
    <strong class="source-inline">
     
      member
     
    </strong>
    
     name.
    
    
     The
    
    <strong class="source-inline">
     
      IsValid()
     
    </strong>
    
     method accepts another parameter of type
    
    <strong class="source-inline">
     
      ValidationContext
     
    </strong>
    
     , which provides context about the validation operation, including
    
    <strong class="source-inline">
     
      MemberName
     
    </strong>
    
     identifying the validated field.
    
    
     With
    
    <strong class="source-inline">
     
      MemberName
     
    </strong>
    
     , we can conform to the
    
    <strong class="source-inline">
     
      Failure()
     
    </strong>
    
     method signature.
    
    
     We then check whether
    
    <strong class="source-inline">
     
      text
     
    </strong>
    
     contains the
    
    <strong class="source-inline">
     
      _forbidden
     
    </strong>
    
     keyword, ignoring case and culture differences.
    
    
     If the forbidden keyword is found, we invoke
    
    <strong class="source-inline">
     
      Failure()
     
    </strong>
    
     again with the message
    
    <strong class="bold">
     
      You mustn’t use the ‘event’ keyword.
     
    </strong>
    
     .
    
    
     Lastly, if all checks pass successfully, we return
    
    <strong class="source-inline">
     
      ValidationResult.Success
     
    </strong>
    
     – a success indicator encapsulated inside the
    
    
     <strong class="source-inline">
      
       ValidationResult
      
     </strong>
    
    
     
      class.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     class and replace the existing
    
    <strong class="source-inline">
     
      Required
     
    </strong>
    
     attribute on the
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     property
    
    <a id="_idIndexMarker352">
    </a>
    
     with our newly created
    
    <strong class="source-inline">
     
      EventNameValidation
     
    </strong>
    
     attribute.
    
    
     Thanks to code generators and the C# and Blazor compilers, we can reference custom attributes using the class name without the
    
    
     <strong class="source-inline">
      
       Attribute
      
     </strong>
    
    
     
      suffix.
     
    
   </p>
   <p>
    
     Now, we validate not only whether the user provides the event name but also whether they use the
    
    
     
      forbidden keyword:
     
    
   </p>
   <div><div><img alt="Figure 7.2: Validation message when user submits a value containing a forbidden keyword" src="img/B22020_07_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.2: Validation message when user submits a value containing a forbidden keyword
    
   </p>
   <h2 id="_idParaDest-253">
    <a id="_idTextAnchor253">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     When building multilingual applications, you might need to translate user-friendly error messages.
    
    
     Additionally, with continuous delivery trends, you may need to conditionally enable validation rules based on feature flags or application settings.
    
    
     You will require access to the dependency injection container to support such advanced scenarios.
    
    
     While in a class based on
    
    <strong class="source-inline">
     
      ValidationAttribute
     
    </strong>
    
     , you can reach dependency injection through the
    
    <strong class="source-inline">
     
      ValidationContext
     
    </strong>
    
     parameter, which encapsulates the behavior of
    
    <strong class="source-inline">
     
      IServiceProvider
     
    </strong>
    
     and exposes all the standard dependency injection methods available
    
    
     
      in .NET.
     
    
   </p>
   <p>
    
     For example, assuming that you’ve registered an
    
    <strong class="source-inline">
     
      Api
     
    </strong>
    
     service in the service container, you can inject this
    
    <a id="_idIndexMarker353">
    </a>
    
     dependency within your attribute in the
    
    
     
      following way:
     
    
   </p>
   <pre class="source-code">
protected override ValidationResult IsValid(object value,
    ValidationContext validationContext)
{
    var api = validationContext.GetRequiredService&lt;Api&gt;();
    //...
}</pre>
   <p>
    
     We override the
    
    <strong class="source-inline">
     
      IsValid()
     
    </strong>
    
     method, inherited from the
    
    <strong class="source-inline">
     
      ValidationAttribute
     
    </strong>
    
     class, and we get an instance of
    
    <strong class="source-inline">
     
      ValidationContext
     
    </strong>
    
     .
    
    
     As
    
    <strong class="source-inline">
     
      ValidationContext
     
    </strong>
    
     implements the
    
    <strong class="source-inline">
     
      IServiceProvider
     
    </strong>
    
     interface, we leverage the built-in generic
    
    <strong class="source-inline">
     
      GetRequiredService()
     
    </strong>
    
     extension method to retrieve an instance of our
    
    
     <strong class="source-inline">
      
       Api
      
     </strong>
    
    
     
      service.
     
    
   </p>
   <p>
    
     It’s important to note that custom validation attributes in .NET do not support asynchronous validation.
    
    
     This limitation is crucial to consider when designing your validation strategy to
    
    <a id="_idIndexMarker354">
    </a>
    
     ensure performance and user experience are not
    
    
     
      adversely affected.
     
    
   </p>
   <h1 id="_idParaDest-254">
    <a id="_idTextAnchor254">
    </a>
    
     Validating complex data models
    
   </h1>
   <p>
    
     In this recipe, we
    
    <a id="_idIndexMarker355">
    </a>
    
     tackle the validation of complex forms and data models.
    
    
     Having well-structured and modularized code makes the code base easier to maintain and reduces the likelihood of errors by clearly defining and isolating each component’s responsibilities.
    
    
     In forms, complex models segment the data into manageable parts, each with its validation logic, making it easier to maintain the overall form’s state and ensuring each segment adheres to specific business rules.
    
    
     The
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.Components.DataAnnotations.Validation
     
    </strong>
    
     package, although experimental, exposes Blazor-native validators and offers enhanced data annotations that integrate smoothly with
    
    
     
      complex models.
     
    
   </p>
   <p>
    
     Let’s extend the event creation form to include a nested object that encapsulates details about the
    
    
     
      event location.
     
    
   </p>
   <h2 id="_idParaDest-255">
    <a id="_idTextAnchor255">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we set up nested, complex model validation, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter07
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       EventNameValidationAttribute
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Implementing custom validation attributes
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter07
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory
     
     <a id="_idIndexMarker356">
     </a>
     
      in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-256">
    <a id="_idTextAnchor256">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to enable validation of the
    
    
     
      nested model:
     
    
   </p>
   <ol>
    <li>
     
      Add a reference to the
     
     <strong class="source-inline">
      
       Microsoft.AspNetCore.Components.DataAnnotations.Validation
      
     </strong>
     
      package to your
     
     
      
       project file:
      
     
     <pre class="source-code">
&lt;ItemGroup&gt;
  &lt;PackageReference
    Include="Microsoft.AspNetCore.Components
      .DataAnnotations.Validation"
    Version="3.2.0-rc1.20223.4" /&gt;
&lt;/ItemGroup&gt;</pre>
    </li>
    <li>
     
      Create a new
     
     <strong class="source-inline">
      
       EventLocation
      
     </strong>
     
      class and define two properties within it –
     
     <strong class="source-inline">
      
       Venue
      
     </strong>
     
      
       and
      
     
     
      <strong class="source-inline">
       
        Capacity
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
public class EventLocation
{
    public string Venue { get; set; }
    public int Capacity { get; set; }
}</pre>
    </li>
    <li>
     
      Apply the
     
     <strong class="source-inline">
      
       Required
      
     </strong>
     
      attribute to the
     
     <strong class="source-inline">
      
       Venue
      
     </strong>
     
      property and include a meaningful error message when a user leaves the
     
     
      
       field blank:
      
     
     <pre class="source-code">
[Required(ErrorMessage = "You must provide a venue.")]
public string Venue { get; set; }</pre>
    </li>
    <li>
     
      For the
     
     <strong class="source-inline">
      
       Capacity
      
     </strong>
     
      property, decorate it with both the
     
     <strong class="source-inline">
      
       Required
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       Range
      
     </strong>
     
      attributes and provide a meaningful error message to ensure the user inputs only valid
     
     
      
       capacity
      
     
     
      <a id="_idIndexMarker357">
      </a>
     
     
      
       values:
      
     
     <pre class="source-code">
[Required, Range(1, 1000,
    ErrorMessage =
        "Capacity must be between 1 and 1000.")]
public int Capacity { get; set; }</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      class and add a new
     
     <strong class="source-inline">
      
       Location
      
     </strong>
     
      property.
     
     
      Decorate
     
     <strong class="source-inline">
      
       Location
      
     </strong>
     
      with a
     
     
      <strong class="source-inline">
       
        ValidateComplexType
       
      </strong>
     
     
      
       attribute:
      
     
     <pre class="source-code">
[ValidateComplexType]
public EventLocation Location { get; set; } = new();</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component, locate
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      within
     
     
      
       the markup.
      
     
    </li>
    <li>
     
      Inside
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      , directly below the input field for
     
     <strong class="source-inline">
      
       Name
      
     </strong>
     
      , add a new paragraph with an
     
     <strong class="source-inline">
      
       InputText
      
     </strong>
     
      component bound to the
     
     
      <strong class="source-inline">
       
        Model.Location.Venue
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
&lt;p&gt;
    Venue:
    &lt;InputText @bind-Value="@Model.Location.Venue" /&gt;
&lt;/p&gt;</pre>
    </li>
    <li>
     
      Below the
     
     <strong class="source-inline">
      
       Venue
      
     </strong>
     
      input field, add another paragraph containing an
     
     <strong class="source-inline">
      
       InputNumber
      
     </strong>
     
      component
     
     <a id="_idIndexMarker358">
     </a>
     
      bound to the
     
     
      <strong class="source-inline">
       
        Model.Location.Capacity
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
&lt;p&gt;
    Capacity:
    &lt;InputNumber
        @bind-Value="@Model.Location.Capacity" /&gt;
&lt;/p&gt;</pre>
    </li>
    <li>
     
      Still within
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      , replace the existing
     
     <strong class="source-inline">
      
       ValidationMessage
      
     </strong>
     
      for the
     
     <strong class="source-inline">
      
       Model.Name
      
     </strong>
     
      property
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        ValidationSummary
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
&lt;p&gt;&lt;ValidationSummary  /&gt;&lt;/p&gt;</pre>
    </li>
    <li>
     
      Lastly, swap out the
     
     <strong class="source-inline">
      
       DataAnnotationsValidator
      
     </strong>
     
      component
     
     
      
       for
      
     
     
      <strong class="source-inline">
       
        ObjectGraphDataAnnotationsValidator
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
&lt;ObjectGraphDataAnnotationsValidator /&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-257">
    <a id="_idTextAnchor257">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we open the
    
    <strong class="source-inline">
     
      csproj
     
    </strong>
    
     file of our project and add a reference to the
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.Components.DataAnnotations.Validation
     
    </strong>
    
     package that contains all the extensions required for seamless validation of complex, nested
    
    
     
      data models.
     
    
   </p>
   <p>
    
     Next, in
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we create a new
    
    <strong class="source-inline">
     
      EventLocation
     
    </strong>
    
     class with the
    
    <strong class="source-inline">
     
      Venue
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Capacity
     
    </strong>
    
     properties, representing event location details.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we decorate the
    
    <strong class="source-inline">
     
      Venue
     
    </strong>
    
     property with a
    
    <strong class="source-inline">
     
      Required
     
    </strong>
    
     attribute to ensure that users cannot submit the form without filling in the venue description.
    
    
     Should they forget to enter a
    
    <strong class="source-inline">
     
      Venue
     
    </strong>
    
     value, they will see a
    
    <strong class="bold">
     
      You must provide a venue.
     
    </strong>
    
     validation message to guide them.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we add validation to the
    
    <strong class="source-inline">
     
      Capacity
     
    </strong>
    
     property by applying both the
    
    <strong class="source-inline">
     
      Required
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Range
     
    </strong>
    
     attributes.
    
    
     We enforce that users fill the capacity value and that it falls within a specified range (1 to 1,000).
    
    
     Users will receive a
    
    <strong class="bold">
     
      Capacity must be between 1 and 1000.
     
    </strong>
    
     error message if they enter a value outside the
    
    
     
      declared range.
     
    
   </p>
   <p>
    
     For
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we turn to the
    
    <strong class="source-inline">
     
      Event
     
    </strong>
    
     class and extend it with a new property –
    
    <strong class="source-inline">
     
      Location
     
    </strong>
    
     , of type
    
    <strong class="source-inline">
     
      EventLocation
     
    </strong>
    
     .
    
    
     To ensure Blazor understands that this property represents a complex type requiring nested validation, we decorate it with the
    
    <strong class="source-inline">
     
      ValidateComplexType
     
    </strong>
    
     attribute.
    
    <strong class="source-inline">
     
      ValidateComplexType
     
    </strong>
    
     comes with the
    
    
     <strong class="source-inline">
      
       Microsoft.AspNetCore.Components.DataAnnotations.Validation
      
     </strong>
    
    
     
      package.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we proceed
    
    <a id="_idIndexMarker359">
    </a>
    
     to the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component and locate the existing
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     within the markup.
    
    
     We will extend the form to include fields for entering the event location details.
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we embed a new paragraph just below the
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     field where we insert an
    
    <strong class="source-inline">
     
      InputText
     
    </strong>
    
     component bound to
    
    <strong class="source-inline">
     
      Model.Location.Venue
     
    </strong>
    
     to allow users to input the venue details.
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we add another paragraph, this time incorporating an
    
    <strong class="source-inline">
     
      InputNumber
     
    </strong>
    
     component bound to
    
    <strong class="source-inline">
     
      Model.Location.Capacity
     
    </strong>
    
     to allow users to specify the spots available in a given venue.
    
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , aiming to streamline the display of validation messages, we replace the
    
    <strong class="source-inline">
     
      ValidationMessage
     
    </strong>
    
     component previously dedicated to the
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     property with a
    
    <strong class="source-inline">
     
      ValidationSummary
     
    </strong>
    
     instance.
    
    
     The
    
    <strong class="source-inline">
     
      ValidationSummary
     
    </strong>
    
     component consolidates all form validation messages into one area.
    
    
     Finally, in
    
    <em class="italic">
     
      step 10
     
    </em>
    
     , we enhance our validation setup by replacing the standard
    
    <strong class="source-inline">
     
      DataAnnotationsValidator
     
    </strong>
    
     with
    
    <strong class="source-inline">
     
      ObjectGraphDataAnnotationsValidator
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      ObjectGraphDataAnnotationsValidator
     
    </strong>
    
     component is an advanced component capable of validating nested object graphs, allowing Blazor to trigger validation on every part of our complex
    
    
     <strong class="source-inline">
      
       Event
      
     </strong>
    
    
     
      model.
     
    
   </p>
   <h2 id="_idParaDest-258">
    <a id="_idTextAnchor258">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     When working with Blazor’s built-in input components, you get an additional layer of flexibility.
    
    
     Any default input component, inheriting from the
    
    <strong class="source-inline">
     
      InputBase
     
    </strong>
    
     class, such as the
    
    <strong class="source-inline">
     
      InputNumber
     
    </strong>
    
     component we’ve used in this recipe, automatically intercepts any unmatched parameters and attaches them directly to the underlying HTML
    
    <strong class="source-inline">
     
      input
     
    </strong>
    
     element as attributes.
    
    
     With that, you can easily enhance the
    
    <strong class="source-inline">
     
      InputNumber
     
    </strong>
    
     component used for
    
    <strong class="source-inline">
     
      Model.Location.Capacity
     
    </strong>
    
     by declaring
    
    <strong class="source-inline">
     
      min
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      max
     
    </strong>
    
     attributes and disallowing users from manually increasing or decreasing the value beyond the
    
    
     
      specified range:
     
    
   </p>
   <pre class="source-code">
Capacity:
    &lt;InputNumber min="1" max="1000"
        @bind-Value="@Model.Location.Capacity" /&gt;</pre>
   <p>
    
     By adding
    
    <strong class="source-inline">
     
      min
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      max
     
    </strong>
    
     attributes to the
    
    <strong class="source-inline">
     
      InputNumber
     
    </strong>
    
     component in the form and declaring their values to
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      1000
     
    </strong>
    
     , respectively, we ensure users won’t be able to reduce the value in the input below
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     nor increment it above
    
    <strong class="source-inline">
     
      1000
     
    </strong>
    
     .
    
    
     They can still type an invalid value by
    
    <a id="_idIndexMarker360">
    </a>
    
     hand, but they’ll trigger validation on the model properties.
    
    
     Following that example, you can leverage any other HTML input attributes you’re
    
    
     
      familiar with.
     
    
   </p>
   <h1 id="_idParaDest-259">
    <a id="_idTextAnchor259">
    </a>
    
     Styling validation messages
    
   </h1>
   <p>
    
     In this recipe, we
    
    <a id="_idIndexMarker361">
    </a>
    
     explore the styling of form validation in Blazor.
    
    
     You’ve probably noticed in previous recipes that Blazor automatically applies validation classes to form fields during validation.
    
    
     Default validation CSS classes align with default Bootstrap styles, where invalid fields get a red accent and valid ones get a green accent.
    
    
     While the default settings increase the delivery velocity, in most cases, you will still have to customize the visual feedback to suit your application branding or functional requirements.
    
    
     Fortunately, Blazor allows customizing styling and classes appended to fields upon validation.
    
    
     This customization maintains the integrity of your application’s modular and loosely coupled architecture, ensuring that enhancements do not compromise the maintainability of
    
    
     
      your code.
     
    
   </p>
   <p>
    
     Let’s implement a custom validation class provider, making Blazor mark missing labels in red while missing location capacity
    
    
     
      in yellow.
     
    
   </p>
   <h2 id="_idParaDest-260">
    <a id="_idTextAnchor260">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before implementing a custom validation class provider, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter07
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       EventLocation
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       EventNameValidationAttribute
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Validating complex data models
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter07
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-261">
    <a id="_idTextAnchor261">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Execute the following steps to add a custom validation
    
    
     
      class provider:
     
    
   </p>
   <ol>
    <li>
     
      Add a new
     
     <strong class="source-inline">
      
       EventManager.razor.css
      
     </strong>
     
      file to the working directory.
     
     
      Your IDE might automatically nest that CSS file
     
     
      
       under
      
     
     
      <strong class="source-inline">
       
        EventManager.razor
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Within
     
     <strong class="source-inline">
      
       EventManager.razor.css
      
     </strong>
     
      , define an
     
     <strong class="source-inline">
      
       invalid-warning
      
     </strong>
     
      style class that adds an
     
     <a id="_idIndexMarker362">
     </a>
     
      orange outline to any element we apply
     
     
      
       it to:
      
     
     <pre class="source-code">
::deep .invalid-warning {
    outline: 1px solid orange;
}</pre>
    </li>
    <li>
     
      Create a new
     
     <strong class="source-inline">
      
       TypeValidationClassProvider
      
     </strong>
     
      class, inheriting from
     
     <strong class="source-inline">
      
       FieldCssClassProvider
      
     </strong>
     
      available under the
     
     
      <strong class="source-inline">
       
        Microsoft.AspNetCore.Components.Forms
       
      </strong>
     
     
      
       namespace:
      
     
     <pre class="source-code">
public class TypeValidationClassProvider
    : FieldCssClassProvider { }</pre>
    </li>
    <li>
     
      In
     
     <strong class="source-inline">
      
       TypeValidationClassProvider
      
     </strong>
     
      , declare a private
     
     <strong class="source-inline">
      
       _capacity
      
     </strong>
     
      field holding the name of the
     
     <strong class="source-inline">
      
       Capacity
      
     </strong>
     
      property from the
     
     
      <strong class="source-inline">
       
        EventLocation
       
      </strong>
     
     
      
       class:
      
     
     <pre class="source-code">
private static readonly string
    _capacity = nameof(EventLocation.Capacity);</pre>
    </li>
    <li>
     
      To finalize the implementation of
     
     <strong class="source-inline">
      
       TypeValidationClassProvider
      
     </strong>
     
      , override the
     
     <strong class="source-inline">
      
       GetFieldCssClass()
      
     </strong>
     
      method and implement logic to return the
     
     <strong class="source-inline">
      
       invalid-warning
      
     </strong>
     
      class when the current field’s value is invalid and corresponds
     
     <a id="_idIndexMarker363">
     </a>
     
      to the
     
     <strong class="source-inline">
      
       _capacity
      
     </strong>
     
      property; otherwise, fall back to the
     
     
      <strong class="source-inline">
       
        base
       
      </strong>
     
     
      
       implementation:
      
     
     <pre class="source-code">
public override string GetFieldCssClass(
    EditContext editContext,
    in FieldIdentifier fieldIdentifier)
{
    var isValid =
        editContext.IsValid(fieldIdentifier);
    var isCapacity =
        fieldIdentifier.FieldName == _capacity;
    if (!isValid &amp;&amp; isCapacity)
        return "invalid-warning";
    return base.GetFieldCssClass(
        editContext, fieldIdentifier);
}</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component and find the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      method.
     
     
      After the existing setup, use the
     
     <strong class="source-inline">
      
       SetFieldCssClassProvider()
      
     </strong>
     
      extension method of
     
     <strong class="source-inline">
      
       EditContext
      
     </strong>
     
      and attach
     
     <strong class="source-inline">
      
       TypeValidationClassProvider
      
     </strong>
     
      
       to
      
     
     
      <strong class="source-inline">
       
        Context
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
protected override void OnInitialized()
{
    // ... existing form context building ...
    Context.SetFieldCssClassProvider(
        new TypeValidationClassProvider());
}</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-262">
    <a id="_idTextAnchor262">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we add a new CSS file to our working directory, specifically naming it
    
    <strong class="source-inline">
     
      EventManager.razor.css
     
    </strong>
    
     to adhere to the CSS isolation requirements and match the name of the component it will style.
    
    
     In
    
    <a id="_idIndexMarker364">
    </a>
    
     Blazor,
    
    <strong class="bold">
     
      CSS isolation
     
    </strong>
    
     allows styles defined in a component-specific CSS file to affect only that component, preventing styles from leaking.
    
    
     If you enable the file nesting in your IDE, you will see isolated CSS files wrapped under the parent component file.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , within
    
    <strong class="source-inline">
     
      EventManager.razor.css
     
    </strong>
    
     , we introduce a
    
    <strong class="source-inline">
     
      .invalid-warning
     
    </strong>
    
     class, which applies an orange outline to fields we attach it to.
    
    
     We use the
    
    <strong class="source-inline">
     
      ::deep
     
    </strong>
    
     combinator to ensure that styling penetrates DOM-like encapsulations and affects
    
    
     
      nested components.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we initiate our custom validation class provider by creating a new
    
    <strong class="source-inline">
     
      TypeValidationClassProvider
     
    </strong>
    
     class, which inherits from
    
    <strong class="source-inline">
     
      FieldCssClassProvider
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      FieldCssClassProvider
     
    </strong>
    
     class provides the necessary API to customize CSS classes that Blazor applies based on field validation states.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we
    
    <a id="_idIndexMarker365">
    </a>
    
     persist the name of the
    
    <strong class="source-inline">
     
      Capacity
     
    </strong>
    
     field in a
    
    <strong class="source-inline">
     
      _capacity
     
    </strong>
    
     variable within
    
    <strong class="source-inline">
     
      TypeValidationClassProvider
     
    </strong>
    
     .
    
    
     By declaring it as
    
    <strong class="source-inline">
     
      private
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      static
     
    </strong>
    
     , we ensure that this value remains unchanged and consumes minimal memory throughout the application’s life cycle, effectively becoming a singleton instance.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we complete our custom provider by overriding the
    
    <strong class="source-inline">
     
      GetFieldCssClass()
     
    </strong>
    
     method, which Blazor calls whenever it needs to determine the appropriate CSS class based on the validation state of a field.
    
    
     In our implementation, we first check whether the field’s current state is valid and its name matches the
    
    <strong class="source-inline">
     
      _capacity
     
    </strong>
    
     value.
    
    
     If the field is invalid and refers to the capacity, we return
    
    <strong class="source-inline">
     
      invalid-warning
     
    </strong>
    
     , instructing Blazor to apply the orange outline to highlight the error.
    
    
     Otherwise, we default to the base implementation by returning the result of the
    
    <strong class="source-inline">
     
      base.GetFieldCssClass()
     
    </strong>
    
     call, preserving standard behavior for
    
    
     
      other fields.
     
    
   </p>
   <p>
    
     Finally, in
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we jump to the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component and locate the overridden
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     life cycle method, where we initialize the
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     variable.
    
    
     After the initial configurations, we utilize the
    
    <strong class="source-inline">
     
      SetFieldCssClassProvider()
     
    </strong>
    
     extension method of
    
    <strong class="source-inline">
     
      EditContext
     
    </strong>
    
     to configure
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     to employ our
    
    <strong class="source-inline">
     
      TypeValidationClassProvider
     
    </strong>
    
     for resolving CSS classes based on field validation.
    
    
     Our custom styling logic is now
    
    
     
      in place.
     
    
   </p>
   <h2 id="_idParaDest-263">
    <a id="_idTextAnchor263">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     We’ve implemented a custom CSS validation class and leveraged the CSS isolation feature that Blazor
    
    <a id="_idIndexMarker366">
    </a>
    
     offers.
    
    
     However, if you have already integrated a CSS framework into your application, you can simply use the validation classes the framework provides instead of creating
    
    
     
      custom ones.
     
    
   </p>
   <p>
    
     Bootstrap, being the most common CSS framework to date, offers
    
    <strong class="source-inline">
     
      border
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      border-warning
     
    </strong>
    
     CSS classes, which you can use to highlight invalid input fields.
    
    
     Navigate to
    
    <strong class="source-inline">
     
      TypeValidationClassProvider
     
    </strong>
    
     and update the
    
    <strong class="source-inline">
     
      GetFieldCssClass()
     
    </strong>
    
     implementation
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
public override string GetFieldCssClass(
    EditContext editContext,
    in FieldIdentifier fieldIdentifier)
{
    var isValid = editContext.IsValid(fieldIdentifier);
    var isCapacity =
        fieldIdentifier.FieldName == _capacity;
    if (!isValid &amp;&amp; isCapacity)
        return "border border-warning";
    return base.GetFieldCssClass(
        editContext, fieldIdentifier);
}</pre>
   <p>
    
     The custom validation logic remains intact – we still check whether the validation context is valid and whether the validated field refers to the capacity.
    
    
     However, when the custom validation fails, instead of returning the custom warning class, we leverage the
    
    <strong class="source-inline">
     
      border border-warning
     
    </strong>
    
     classes
    
    <a id="_idIndexMarker367">
    </a>
    
     combination and effectively delegate the styling
    
    
     
      to Bootstrap.
     
    
   </p>
   <h1 id="_idParaDest-264">
    <a id="_idTextAnchor264">
    </a>
    
     Displaying a toast when validation fails
    
   </h1>
   <p>
    
     In this recipe, we
    
    <a id="_idIndexMarker368">
    </a>
    
     explore how to enhance form validation
    
    <a id="_idIndexMarker369">
    </a>
    
     feedback with a custom display of validation errors.
    
    
     Blazor’s
    
    <strong class="source-inline">
     
      ValidationSummary
     
    </strong>
    
     component provides a straightforward way to collect and display all validation messages from a form in a single container, typically rendered as a simple
    
    <strong class="source-inline">
     
      div
     
    </strong>
    
     .
    
    
     While functional, this default presentation might not always align with a desired user experience or the aesthetic standards of your application.
    
    
     You can replace the standard
    
    <strong class="source-inline">
     
      ValidationSummary
     
    </strong>
    
     component with a custom implementation to make validation messages more engaging and fit seamlessly with the broader notification strategy of
    
    
     
      your application.
     
    
   </p>
   <p>
    
     Let’s implement a custom component that displays validation errors inside a default Bootstrap toast, making a more modern version
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       ValidationSummary
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-265">
    <a id="_idTextAnchor265">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before diving into the implementation of a custom validation summary, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter07
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe06
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       EventLocation
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       EventNameValidationAttribute
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       TypeValidationClassProvider
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Styling validation messages
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter07
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-266">
    <a id="_idTextAnchor266">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to introduce a custom
    
    
     
      validation summary:
     
    
   </p>
   <ol>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       ValidationToast
      
     </strong>
     
      component that implements the
     
     
      <strong class="source-inline">
       
        IDisposable
       
      </strong>
     
     
      
       interface:
      
     
     <pre class="source-code">
@implements IDisposable</pre>
    </li>
    <li>
     
      Inside the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of the
     
     <strong class="source-inline">
      
       ValidationToast
      
     </strong>
     
      component, declare a
     
     <strong class="source-inline">
      
       CascadingParameter
      
     </strong>
     
      parameter of type
     
     <strong class="source-inline">
      
       EditContext
      
     </strong>
     
      and an
     
     
      <strong class="source-inline">
       
        IsDisplayed
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
[CascadingParameter]
public EditContext Context { get; set; }
protected bool IsDisplayed { get; set; }</pre>
    </li>
    <li>
     
      Still within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, implement a
     
     <strong class="source-inline">
      
       Rerender()
      
     </strong>
     
      method, matching the signature of a subscriber of an
     
     
      <strong class="source-inline">
       
        EventHandler&lt;ValidationStateChangedEventArgs&gt;
       
      </strong>
     
     
      
       handler:
      
     
     <pre class="source-code">
private void Rerender(object sender,
ValidationStateChangedEventArgs args) { }</pre>
    </li>
    <li>
     
      Inside
     
     <strong class="source-inline">
      
       Rerender()
      
     </strong>
     
      , set
     
     <a id="_idIndexMarker370">
     </a>
     
      the
     
     <strong class="source-inline">
      
       IsDisplayed
      
     </strong>
     
      property
     
     <a id="_idIndexMarker371">
     </a>
     
      based on whether there are any validation messages in
     
     <strong class="source-inline">
      
       Context
      
     </strong>
     
      and invoke the
     
     <strong class="source-inline">
      
       StateHasChanged()
      
     </strong>
     
      to trigger a
     
     
      
       UI refresh:
      
     
     <pre class="source-code">
IsDisplayed = Context.GetValidationMessages().Any();
StateHasChanged();</pre>
    </li>
    <li>
     
      Below
     
     <strong class="source-inline">
      
       Rerender()
      
     </strong>
     
      , override the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      life cycle method and subscribe to the
     
     <strong class="source-inline">
      
       OnValidationStateChanged
      
     </strong>
     
      event
     
     
      
       of
      
     
     
      <strong class="source-inline">
       
        EditContext
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
protected override void OnInitialized()
    =&gt; Context.OnValidationStateChanged += Rerender;</pre>
    </li>
    <li>
     
      Complete the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block by implementing the
     
     <strong class="source-inline">
      
       Dispose()
      
     </strong>
     
      method and unsubscribe from the
     
     
      <strong class="source-inline">
       
        OnValidationStateChanged
       
      </strong>
     
     
      
       event:
      
     
     <pre class="source-code">
public void Dispose()
    =&gt; Context.OnValidationStateChanged -= Rerender;</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       ValidationToast
      
     </strong>
     
      markup, below the
     
     <strong class="source-inline">
      
       @implements
      
     </strong>
     
      directive, include a fast-return clause to prevent any markup rendering based on the
     
     
      <strong class="source-inline">
       
        IsDisplayed
       
      </strong>
     
     
      
       value:
      
     
     <pre class="source-code">
@if (!IsDisplayed) return;</pre>
    </li>
    <li>
     
      Below the fast-return clause, construct a frame of a default Bootstrap
     
     
      
       toast notification:
      
     
     <pre class="source-code">
&lt;div class="position-fixed bottom-0 end-0 p-3"
    style="z-index: 1"&gt;
    &lt;div class="toast text-white bg-danger show"&gt;
        @* toast area *@
    &lt;/div&gt;
&lt;/div&gt;</pre>
    </li>
    <li>
     
      Within the toast
     
     <a id="_idIndexMarker372">
     </a>
     
      area, add
     
     <a id="_idIndexMarker373">
     </a>
     
      an empty header for aesthetics, and in the toast body, implement logic to dynamically render the list of validation messages retrieved
     
     
      
       from
      
     
     
      <strong class="source-inline">
       
        EditContext
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
&lt;div class="toast-header" /&gt;
&lt;div class="toast-body"&gt;
    @foreach (var message in
        Context.GetValidationMessages())
    {
        &lt;div&gt;@message&lt;/div&gt;
    }
&lt;/div&gt;</pre>
    </li>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component, above the form submit button, and remove the existing
     
     <strong class="source-inline">
      
       ValidationSummary
      
     </strong>
     
      paragraph.
     
     
      Replace it with an instance of the new
     
     
      <strong class="source-inline">
       
        ValidationToast
       
      </strong>
     
     
      
       component:
      
     
     <pre class="source-code">
&lt;ValidationToast /&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-267">
    <a id="_idTextAnchor267">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create a new
    
    <strong class="source-inline">
     
      ValidationToast
     
    </strong>
    
     component that implements the
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     interface to ensure a proper resource clean-up as we will work with an
    
    
     
      event handler.
     
    
   </p>
   <p>
    
     From
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we work on the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of the
    
    <strong class="source-inline">
     
      ValidationToast
     
    </strong>
    
     component.
    
    
     We declare a
    
    <strong class="source-inline">
     
      CascadingParameter
     
    </strong>
    
     parameter of type
    
    <strong class="source-inline">
     
      EditContext
     
    </strong>
    
     to gain access to the parent form’s context.
    
    
     We also declare an
    
    <strong class="source-inline">
     
      IsDisplayed
     
    </strong>
    
     property, which will help us control the visibility of the toast based on validation results.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we initialize a
    
    <strong class="source-inline">
     
      Rerender
     
    </strong>
    
     method, accepting the
    
    <strong class="source-inline">
     
      sender
     
    </strong>
    
     parameter and
    
    <strong class="source-inline">
     
      args
     
    </strong>
    
     of type
    
    <strong class="source-inline">
     
      ValidationStateChangedEventArgs
     
    </strong>
    
     , so we can subscribe it later to a matching
    
    <strong class="source-inline">
     
      EventHandler
     
    </strong>
    
     .
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we implement the
    
    <strong class="source-inline">
     
      Rerender
     
    </strong>
    
     logic, where we determine whether there are any validation messages in the
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     instance and set the
    
    <strong class="source-inline">
     
      IsDisplayed
     
    </strong>
    
     property, indicating
    
    <a id="_idIndexMarker374">
    </a>
    
     that there are errors to display.
    
    
     We
    
    <a id="_idIndexMarker375">
    </a>
    
     then invoke
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     to prompt Blazor to refresh the UI and reflect the updated state.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we override the
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     life cycle method to subscribe the
    
    <strong class="source-inline">
     
      Rerender()
     
    </strong>
    
     method to the
    
    <strong class="source-inline">
     
      OnValidationStateChanged
     
    </strong>
    
     event of
    
    <strong class="source-inline">
     
      EditContext
     
    </strong>
    
     .
    
    
     Blazor will execute
    
    <strong class="source-inline">
     
      Rerender()
     
    </strong>
    
     every time the form’s validation state changes, allowing our toast notification to update reactively.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we implement the
    
    <strong class="source-inline">
     
      Dispose()
     
    </strong>
    
     method, where we unsubscribe from the
    
    <strong class="source-inline">
     
      OnValidationStateChanged
     
    </strong>
    
     event, ensuring that
    
    <strong class="source-inline">
     
      ValidationToast
     
    </strong>
    
     does not continue to react to events after it has been removed from the UI, thus preventing
    
    
     
      memory leaks.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we focus on the markup of
    
    <strong class="source-inline">
     
      ValidationToast
     
    </strong>
    
     .
    
    
     We start below the
    
    <strong class="source-inline">
     
      @implements
     
    </strong>
    
     directive with a fast-return clause, based on the
    
    <strong class="source-inline">
     
      IsDisplayed
     
    </strong>
    
     value, which instructs Blazor to immediately exit the rendering process when there are no validation messages.
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we construct a visual frame using default Bootstrap classes to create a toast notification.
    
    
     As it’s standard Bootstrap code, we won’t analyze it deeply.
    
    
     Shortly, we position the frame fixed at the bottom end of the viewport, ensuring that it is visible but non-intrusive.
    
    
     We also make the toast red to clearly indicate that there’s a problem.
    
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we implement the toast area.
    
    
     We add an empty header for visual balance and a body where we iterate over the result of the
    
    <strong class="source-inline">
     
      Context.GetValidationMessages()
     
    </strong>
    
     call and dynamically render each
    
    
     
      validation message.
     
    
   </p>
   <p>
    
     Lastly, in
    
    <em class="italic">
     
      step 10
     
    </em>
    
     , we jump to the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component.
    
    
     Here, we remove the existing
    
    <strong class="source-inline">
     
      ValidationSummary
     
    </strong>
    
     paragraph and replace it with the new
    
    <strong class="source-inline">
     
      ValidationToast
     
    </strong>
    
     component, which now handles the display of validation messages in a more interactive and visually
    
    
     
      engaging manner.
     
    
   </p>
   <p>
    
     We arrive at a still simple
    
    <a id="_idIndexMarker376">
    </a>
    
     but
    
    <a id="_idIndexMarker377">
    </a>
    
     more modern validation summary that our users
    
    
     
      will appreciate:
     
    
   </p>
   <div><div><img alt="Figure 7.3: Toast notification replacing a standard validation summary container" src="img/B22020_07_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 7.3: Toast notification replacing a standard validation summary container
    
   </p>
   <h1 id="_idParaDest-268">
    <a id="_idTextAnchor268">
    </a>
    
     Enabling a submit option based on the form state
    
   </h1>
   <p>
    
     In this recipe, we
    
    <a id="_idIndexMarker378">
    </a>
    
     dive into a strategy to enhance
    
    <a id="_idIndexMarker379">
    </a>
    
     the user experience by dynamically controlling the state of the form’s submit button.
    
    
     We use forms not only when creating a new object but also when modifying an existing one as well.
    
    
     It makes sense that we would prevent the form submission when a user didn’t make any changes or if some input is invalid.
    
    
     Having that feature in place, we improve the user experience, conserve memory usage, and reduce unnecessary
    
    
     
      server requests.
     
    
   </p>
   <p>
    
     Let’s enhance a form with a mechanism that enables form saving only when there have been changes to the form data and all inputs
    
    
     
      are valid.
     
    
   </p>
   <h2 id="_idParaDest-269">
    <a id="_idTextAnchor269">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before making the form submit button react to the form state, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      Create a
     
     <strong class="source-inline">
      
       Chapter07
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe07
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy
     
     <strong class="source-inline">
      
       Event
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       EventLocation
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       EventNameValidationAttribute
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       TypeValidationClassProvider
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       ValidationToast
      
     </strong>
     
      from the
     
     <em class="italic">
      
       Displaying toast when validation fails
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Chapter07
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe06
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-270">
    <a id="_idTextAnchor270">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to
    
    <a id="_idIndexMarker380">
    </a>
    
     make
    
    <a id="_idIndexMarker381">
    </a>
    
     the form submit button reactive to the
    
    
     
      form state:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      component and update it to implement the
     
     <strong class="source-inline">
      
       IDisposable
      
     </strong>
     
      interface and to render mode
     
     
      
       in
      
     
     
      <strong class="source-inline">
       
        InteractiveWebAssembly
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
@rendermode InteractiveWebAssembly
@implements IDisposable</pre>
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block of
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      , introduce an
     
     <strong class="source-inline">
      
       IsSubmittable
      
     </strong>
     
      variable of
     
     
      
       type
      
     
     
      <strong class="source-inline">
       
        bool
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
protected bool IsSubmittable;</pre>
    </li>
    <li>
     
      Still in the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, add a
     
     <strong class="source-inline">
      
       FieldChanged()
      
     </strong>
     
      method that conforms to the
     
     <strong class="source-inline">
      
       EventHandler&lt;FieldChangedEventArgs&gt;
      
     </strong>
     
      response pattern and resolve the form’s current state into the
     
     
      <strong class="source-inline">
       
        IsSubmittable
       
      </strong>
     
     
      
       variable:
      
     
     <pre class="source-code">
private void FieldChanged(
    object sender, FieldChangedEventArgs args)
{
    IsSubmittable =
        Context.Validate() &amp;&amp; Context.IsModified();
    StateHasChanged();
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      method, initiate a default value for the
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      instance to simulate a
     
     
      
       data-editing scenario:
      
     
     <pre class="source-code">
Model ??= new()
{
    Name = "Packt Party",
    Location = new()
    {
        Venue = "Packt Room",
        Capacity = 150
    }
};</pre>
    </li>
    <li>
     
      At the
     
     <a id="_idIndexMarker382">
     </a>
     
      end
     
     <a id="_idIndexMarker383">
     </a>
     
      of the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      method, subscribe the
     
     <strong class="source-inline">
      
       FieldChanged()
      
     </strong>
     
      method to the
     
     <strong class="source-inline">
      
       OnFieldChanged
      
     </strong>
     
      event, exposed by the
     
     
      <strong class="source-inline">
       
        EditContext
       
      </strong>
     
     
      
       API:
      
     
     <pre class="source-code">
Context.OnFieldChanged += FieldChanged;</pre>
    </li>
    <li>
     
      Complete the
     
     <strong class="source-inline">
      
       IDisposable
      
     </strong>
     
      implementation by adding a
     
     <strong class="source-inline">
      
       Dispose()
      
     </strong>
     
      method at the end of the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block and unsubscribe
     
     <strong class="source-inline">
      
       FieldChanged()
      
     </strong>
     
      from the
     
     
      <strong class="source-inline">
       
        OnFieldChanged
       
      </strong>
     
     
      
       handler:
      
     
     <pre class="source-code">
public void Dispose()
    =&gt; Context.OnFieldChanged -= FieldChanged;</pre>
    </li>
    <li>
     
      Switch to the
     
     <strong class="source-inline">
      
       EventManager
      
     </strong>
     
      markup and locate the submit button.
     
     
      Set the button’s
     
     <strong class="source-inline">
      
       disabled
      
     </strong>
     
      attribute to the negated value of the
     
     
      <strong class="source-inline">
       
        IsSubmittable
       
      </strong>
     
     
      
       variable:
      
     
     <pre class="source-code">
&lt;button type="submit" disabled="@(!IsSubmittable)"&gt;
    Save
&lt;/button&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-271">
    <a id="_idTextAnchor271">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we start by enhancing the interactivity of our form located in
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     .
    
    
     We configure
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     to render in an
    
    <strong class="source-inline">
     
      InteractiveWebAssembly
     
    </strong>
    
     mode, enabling component interactivity, and we declare that it will implement the
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     interface allowing a custom
    
    
     
      cleanup implementation.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we move to the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block of
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     and declare an
    
    <strong class="source-inline">
     
      IsSubmittable
     
    </strong>
    
     variable that we will leverage in managing the state of the form’s submit button.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we implement a
    
    <strong class="source-inline">
     
      FieldChanged()
     
    </strong>
    
     method that takes the
    
    <strong class="source-inline">
     
      sender
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      args
     
    </strong>
    
     parameters of type
    
    <strong class="source-inline">
     
      FieldChangedEventArgs
     
    </strong>
    
     .
    
    
     Inside
    
    <strong class="source-inline">
     
      FieldChanged()
     
    </strong>
    
     , we utilize the
    
    <strong class="source-inline">
     
      EditContext
     
    </strong>
    
     API through the
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     instance to dynamically evaluate the form’s state.
    
    
     We set the
    
    <strong class="source-inline">
     
      IsSubmittable
     
    </strong>
    
     variable by checking whether
    
    <a id="_idIndexMarker384">
    </a>
    
     all
    
    <a id="_idIndexMarker385">
    </a>
    
     form fields are valid, using
    
    <strong class="source-inline">
     
      Context.Validate()
     
    </strong>
    
     , and the form was modified, using
    
    <strong class="source-inline">
     
      Context.IsModified()
     
    </strong>
    
     .
    
    
     Given that this operation can affect the state of the form’s submit button, we call
    
    <strong class="source-inline">
     
      StateHasChanged()
     
    </strong>
    
     to notify Blazor that the UI might
    
    
     
      need updating.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we adjust how
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     initializes.
    
    
     Instead of resetting the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     object to a new instance, we simulate editing an existing model by setting initial properties, reflecting a typical data-editing scenario.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , as part of the initialization process, we also subscribe
    
    <strong class="source-inline">
     
      FieldChanged()
     
    </strong>
    
     to the
    
    <strong class="source-inline">
     
      Context.OnFieldChanged
     
    </strong>
    
     event handler.
    
    
     Blazor triggers
    
    <strong class="source-inline">
     
      OnFieldChanged
     
    </strong>
    
     whenever the form field’s value changes, ensuring our form responds to every edit.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we finalize the
    
    <strong class="source-inline">
     
      IDisposable
     
    </strong>
    
     implementation.
    
    
     We implement the
    
    <strong class="source-inline">
     
      Dispose()
     
    </strong>
    
     method, where we unsubscribe
    
    <strong class="source-inline">
     
      FieldChanged()
     
    </strong>
    
     from the
    
    <strong class="source-inline">
     
      OnFieldChanged
     
    </strong>
    
     event handler to prevent memory leaks and ensure that the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     component is disposed of gracefully when it is no
    
    
     
      longer needed.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we jump to the
    
    <strong class="source-inline">
     
      EventManager
     
    </strong>
    
     markup to reflect our backend logic in the UI.
    
    
     We locate the form’s submit button and attach a
    
    <strong class="source-inline">
     
      disabled
     
    </strong>
    
     attribute, setting its value to the
    
    <strong class="source-inline">
     
      IsSubmittable
     
    </strong>
    
     negation.
    
    
     Whenever the user changes focus between fields in the form, we will recalculate the value of
    
    <strong class="source-inline">
     
      IsSubmittable
     
    </strong>
    
     – and since
    
    <strong class="source-inline">
     
      IsSubmittable
     
    </strong>
    
     indicates whether the user made changes and the form is in a valid state, negating this value determines when the submit button should be disabled, preventing unnecessary submission until all conditions for a valid and modified form
    
    
     
      are met.
     
    
   </p>
   <h2 id="_idParaDest-272">
    <a id="_idTextAnchor272">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    <strong class="source-inline">
     
      EditContext
     
    </strong>
    
     in Blazor plays a
    
    <a id="_idIndexMarker386">
    </a>
    
     crucial role in
    
    <a id="_idIndexMarker387">
    </a>
    
     managing form
    
    <a id="_idIndexMarker388">
    </a>
    
     states and validations but has some limitations.
    
    
     One significant caveat is that it does not track the initial state of model properties.
    
    <strong class="source-inline">
     
      EditContext
     
    </strong>
    
     monitors changes to input fields, marking them as modified when their values change.
    
    
     However, if the user reverts a field’s value to its original state,
    
    <strong class="source-inline">
     
      EditContext
     
    </strong>
    
     still considers it modified.
    
    
     This behavior can lead to scenarios where forms may incorrectly allow submission or display validation states because they do not recognize that the field value has returned to its
    
    
     
      initial state.
     
    
   </p>
   <p>
    
     To address this limitation and refine the behavior of form modifications, you must implement an equality comparer, inheriting from
    
    <strong class="source-inline">
     
      IEqualityComparer&lt;T&gt;
     
    </strong>
    
     to customize how equality for reference types is determined.
    
    
     Having an explicit comparison logic, we can persist the initial value of the model in an
    
    <strong class="source-inline">
     
      _initialModel
     
    </strong>
    
     variable and replace the standard
    
    <strong class="source-inline">
     
      Context.IsModified()
     
    </strong>
    
     check with an
    
    <strong class="source-inline">
     
      _initialModel != Model
     
    </strong>
    
     evaluation.
    
    
     Blazor will disable the submit button when the user’s input returns to the initial values, ensuring that the form is only submittable with
    
    
     
      actual changes.
     
    
   </p>
  </div>
 </body></html>